<!doctype html><html lang=zh class=no-js>
<head>
<meta name=ROBOTS content="NOINDEX, NOFOLLOW">
<script async src="https://www.googletagmanager.com/gtag/js?id=G-JPP6RFM2BP"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-JPP6RFM2BP')</script>
<link rel=alternate hreflang=en href=https://kubernetes.io/docs/setup/production-environment/windows/>
<link rel=alternate hreflang=ko href=https://kubernetes.io/ko/docs/setup/production-environment/windows/>
<link rel=alternate hreflang=ja href=https://kubernetes.io/ja/docs/setup/production-environment/windows/>
<link rel=alternate hreflang=fr href=https://kubernetes.io/fr/docs/setup/production-environment/windows/>
<link rel=alternate hreflang=uk href=https://kubernetes.io/uk/docs/setup/production-environment/windows/>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=generator content="Hugo 0.87.0">
<link rel=canonical type=text/html href=https://kubernetes.io/zh/docs/setup/production-environment/windows/>
<link rel="shortcut icon" type=image/png href=/images/favicon.png>
<link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180>
<link rel=manifest href=/manifest.webmanifest>
<link rel=apple-touch-icon href=/images/kubernetes-192x192.png>
<title>Windows Kubernetes | Kubernetes</title><meta property="og:title" content="Windows Kubernetes">
<meta property="og:description" content="生产级别的容器编排系统">
<meta property="og:type" content="website">
<meta property="og:url" content="https://kubernetes.io/zh/docs/setup/production-environment/windows/"><meta property="og:site_name" content="Kubernetes">
<meta itemprop=name content="Windows Kubernetes">
<meta itemprop=description content="生产级别的容器编排系统"><meta name=twitter:card content="summary">
<meta name=twitter:title content="Windows Kubernetes">
<meta name=twitter:description content="生产级别的容器编排系统">
<link href=/scss/main.css rel=stylesheet>
<script src=/js/jquery-3.3.1.min.js integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin=anonymous></script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","url":"https://kubernetes.io","logo":"https://kubernetes.io/images/favicon.png"}</script>
<meta name=theme-color content="#326ce5">
<link rel=stylesheet href=/css/feature-states.css>
<meta name=description content>
<meta property="og:description" content>
<meta name=twitter:description content>
<meta property="og:url" content="https://kubernetes.io/zh/docs/setup/production-environment/windows/">
<meta property="og:title" content="Windows Kubernetes">
<meta name=twitter:title content="Windows Kubernetes">
<meta name=twitter:image content="https://kubernetes.io/images/favicon.png">
<meta name=twitter:image:alt content="Kubernetes">
<meta property="og:image" content="/images/kubernetes-horizontal-color.png">
<meta property="og:type" content="article">
<script src=/js/script.js></script>
</head>
<body class=td-section>
<header>
<nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar" data-auto-burger=primary>
<a class=navbar-brand href=/zh/></a>
<div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar>
<ul class="navbar-nav mt-2 mt-lg-0">
<li class="nav-item mr-2 mb-lg-0">
<a class="nav-link active" href=/zh/docs/>文档</a>
</li>
<li class="nav-item mr-2 mb-lg-0">
<a class=nav-link href=/zh/blog/>Kubernetes 博客</a>
</li>
<li class="nav-item mr-2 mb-lg-0">
<a class=nav-link href=/zh/training/>培训</a>
</li>
<li class="nav-item mr-2 mb-lg-0">
<a class=nav-link href=/zh/partners/>合作伙伴</a>
</li>
<li class="nav-item mr-2 mb-lg-0">
<a class=nav-link href=/zh/community/>社区</a>
</li>
<li class="nav-item mr-2 mb-lg-0">
<a class=nav-link href=/zh/case-studies/>案例分析</a>
</li>
<li class="nav-item dropdown">
<a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>
Versions
</a>
<div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink>
<a class=dropdown-item href=/releases>Release Information</a>
<a class=dropdown-item href=https://kubernetes.io/zh/docs/setup/production-environment/windows/>v1.27</a>
<a class=dropdown-item href=https://v1-26.docs.kubernetes.io/zh/docs/setup/production-environment/windows/>v1.26</a>
<a class=dropdown-item href=https://v1-25.docs.kubernetes.io/zh/docs/setup/production-environment/windows/>v1.25</a>
<a class=dropdown-item href=https://v1-24.docs.kubernetes.io/zh/docs/setup/production-environment/windows/>v1.24</a>
<a class=dropdown-item href=https://v1-23.docs.kubernetes.io/zh/docs/setup/production-environment/windows/>v1.23</a>
</div>
</li>
<li class="nav-item dropdown">
<a class="nav-link dropdown-toggle" href=# id=navbarDropdownMenuLink role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>
中文 Chinese
</a>
<div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink>
<a class=dropdown-item href=/docs/setup/production-environment/windows/>English</a>
<a class=dropdown-item href=/ko/docs/setup/production-environment/windows/>한국어 Korean</a>
<a class=dropdown-item href=/ja/docs/setup/production-environment/windows/>日本語 Japanese</a>
<a class=dropdown-item href=/fr/docs/setup/production-environment/windows/>Français</a>
<a class=dropdown-item href=/uk/docs/setup/production-environment/windows/>Українська</a>
</div>
</li>
</ul>
</div>
<button id=hamburger onclick=kub.toggleMenu() data-auto-burger-exclude><div></div></button>
</nav>
</header>
<div class="container-fluid td-outer">
<div class=td-main>
<div class="row flex-xl-nowrap">
<main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main>
<div class=td-content>
<div class="pageinfo pageinfo-primary d-print-none">
<p>
这是本节的多页打印视图。
<a href=# onclick="return print(),!1">点击此处打印</a>.
</p><p>
<a href=/zh/docs/setup/production-environment/windows/>返回本页常规视图</a>.
</p>
</div>
<h1 class=title>Windows Kubernetes</h1>
<ul>
<li>1: <a href=#pg-a307d413f1f7430fced233023087e2a1>Kubernetes 对 Windows 的支持</a></li>
<li>2: <a href=#pg-3a51e66c5de55f9093a8dc55742006d3>Kubernetes 中 Windows 容器的调度指南</a></li>
</ul>
<div class=content>
</div>
</div>
<div class=td-content>
<h1 id=pg-a307d413f1f7430fced233023087e2a1>1 - Kubernetes 对 Windows 的支持</h1>
<p>在很多组织中，其服务和应用的很大比例是 Windows 应用。
<a href=https://aka.ms/windowscontainers>Windows 容器</a>提供了一种对进程和包依赖关系
进行封装的现代方式，这使得用户更容易采用 DevOps 实践，令 Windows 应用同样遵从
云原生模式。
Kubernetes 已经成为事实上的标准容器编排器，Kubernetes 1.14 发行版本中包含了将
Windows 容器调度到 Kubernetes 集群中 Windows 节点上的生产级支持，从而使得巨大
的 Windows 应用生态圈能够充分利用 Kubernetes 的能力。
对于同时投入基于 Windows 应用和 Linux 应用的组织而言，他们不必寻找不同的编排系统
来管理其工作负载，其跨部署的运维效率得以大幅提升，而不必关心所用操作系统。</p>
<h2 id=windows-containers-in-kubernetes>kubernetes 中的 Windows 容器 </h2>
<p>若要在 Kubernetes 中启用对 Windows 容器的编排，可以在现有的 Linux 集群中
包含 Windows 节点。在 Kubernetes 上调度 <a class=glossary-tooltip title="Pod 表示您的集群上一组正在运行的容器。" data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pods>Pods</a>
中的 Windows 容器与调用基于 Linux 的容器类似。</p>
<p>为了运行 Windows 容器，你的 Kubernetes 集群必须包含多个操作系统，控制面
节点运行 Linux，工作节点则可以根据负载需要运行 Windows 或 Linux。
Windows Server 2019 是唯一被支持的 Windows 操作系统，在 Windows 上启用
<a href=https://github.com/kubernetes/community/blob/master/contributors/design-proposals/architecture/architecture.md#the-kubernetes-node>Kubernetes 节点</a>
支持（包括 kubelet, <a href=https://docs.microsoft.com/en-us/virtualization/windowscontainers/deploy-containers/containerd>容器运行时</a>、
以及 kube-proxy）。关于 Windows 发行版渠道的详细讨论，可参见
<a href=https://docs.microsoft.com/en-us/windows-server/get-started-19/servicing-channels-19>Microsoft 文档</a>。</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> Kubernetes 控制面，包括<a href=/zh/docs/concepts/overview/components/>主控组件</a>，
继续在 Linux 上运行。
目前没有支持完全是 Windows 节点的 Kubernetes 集群的计划。
</div>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 在本文中，当我们讨论 Windows 容器时，我们所指的是具有进程隔离能力的 Windows
容器。具有 <a href=https://docs.microsoft.com/en-us/virtualization/windowscontainers/manage-containers/hyperv-container>Hyper-V 隔离能力</a>
的 Windows 容器计划在将来发行版本中推出。
</div>
<h2 id=supported-functionality-and-limitations>支持的功能与局限性 </h2>
<h3 id=supported-functionality>支持的功能 </h3>
<h4 id=windows-os-version-support>Windows 操作系统版本支持 </h4>
<p>参考下面的表格，了解 Kubernetes 中支持的 Windows 操作系统。
同一个异构的 Kubernetes 集群中可以同时包含 Windows 和 Linux 工作节点。
Windows 容器仅能调度到 Windows 节点，Linux 容器则只能调度到 Linux 节点。</p>
<table>
<thead>
<tr>
<th>Kubernetes 版本</th>
<th>Windows Server LTSC 版本</th>
<th>Windows Server SAC 版本</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><em>Kubernetes v1.20</em></td>
<td>Windows Server 2019</td>
<td>Windows Server ver 1909, Windows Server ver 2004</td>
<td></td>
</tr>
<tr>
<td><em>Kubernetes v1.21</em></td>
<td>Windows Server 2019</td>
<td>Windows Server ver 2004, Windows Server ver 20H2</td>
<td></td>
</tr>
<tr>
<td><em>Kubernetes v1.22</em></td>
<td>Windows Server 2019</td>
<td>Windows Server ver 2004, Windows Server ver 20H2</td>
<td></td>
</tr>
</tbody>
</table>
<p>关于不同的 Windows Server 版本的服务渠道，包括其支持模式等相关信息可以在
<a href=https://docs.microsoft.com/en-us/windows-server/get-started-19/servicing-channels-19>Windows Server servicing channels</a>
找到。</p>
<p>我们并不指望所有 Windows 客户都为其应用频繁地更新操作系统。
对应用的更新是向集群中引入新代码的根本原因。
对于想要更新运行于 Kubernetes 之上的容器中操作系统的客户，我们会在添加对新
操作系统版本的支持时提供指南和分步的操作指令。
该指南会包含与集群节点一起来升级用户应用的建议升级步骤。
Windows 节点遵从 Kubernetes
<a href=/zh/docs/setup/release/version-skew-policy/>版本偏差策略</a>（节点到控制面的
版本控制），与 Linux 节点的现行策略相同。</p>
<p>Windows Server 主机操作系统会受
<a href=https://www.microsoft.com/en-us/cloud-platform/windows-server-pricing>Windows Server</a>
授权策略控制。Windows 容器镜像则遵从
<a href=https://docs.microsoft.com/en-us/virtualization/windowscontainers/images-eula>Windows 容器的补充授权条款</a>
约定。</p>
<p>带进程隔离的 Windows 容器受一些严格的兼容性规则约束，
<a href=https://docs.microsoft.com/en-us/virtualization/windowscontainers/deploy-containers/version-compatibility>其中宿主 OS 版本必须与容器基准镜像的 OS 版本相同</a>。
一旦我们在 Kubernetes 中支持带 Hyper-V 隔离的 Windows 容器，
这一约束和兼容性规则也会发生改变。</p>
<h4 id=pause-image>Pause 镜像 </h4>
<p>Kubernetes 维护着一个多体系结构镜像，其中包括对 Windows 的支持。
对于 Kubernetes v1.22，推荐的 pause 镜像是 <code>k8s.gcr.io/pause:3.5</code>。
<a href=https://github.com/kubernetes/kubernetes/tree/master/build/pause>源代码</a>可在 GitHub 上找到。</p>
<p>Microsoft 维护了一个支持 Linux 和 Windows amd64 的多体系结构镜像： <code>mcr.microsoft.com/oss/kubernetes/pause:3.5</code>。
此镜像与 Kubernetes 维护的镜像是从同一来源构建，但所有 Windows 二进制文件
均由 Microsoft <a href=https://docs.microsoft.com/en-us/windows-hardware/drivers/install/authenticode>签名</a>。
当生产环境需要被签名的二进制文件时，建议使用 Microsoft 维护的镜像。</p>
<h4 id=compute>计算 </h4>
<p>从 API 和 kubectl 的角度，Windows 容器的表现在很大程度上与基于 Linux 的容器
是相同的。不过也有一些与关键功能相关的差别值得注意，这些差别列举于
<a href=#limitations>局限性</a>小节中。</p>
<p>关键性的 Kubernetes 元素在 Windows 下与其在 Linux 下工作方式相同。我们在本节中
讨论一些关键性的负载支撑组件及其在 Windows 中的映射。</p>
<ul>
<li>
<p><a href=/zh/docs/concepts/workloads/pods/>Pods</a></p>
<p>Pod 是 Kubernetes 中最基本的构造模块，是 Kubernetes 对象模型中你可以创建或部署的
最小、最简单元。你不可以在同一 Pod 中部署 Windows 和 Linux 容器。
Pod 中的所有容器都会被调度到同一节点（Node），而每个节点代表的是一种特定的平台
和体系结构。Windows 容器支持 Pod 的以下能力、属性和事件：</p>
<ul>
<li>在带进程隔离和卷共享支持的 Pod 中运行一个或多个容器</li>
<li>Pod 状态字段</li>
<li>就绪态（Readiness）和活跃性（Liveness）探针</li>
<li>postStart 和 preStop 容器生命周期事件</li>
<li>ConfigMap、Secrets：用作环境变量或卷</li>
<li>emptyDir 卷</li>
<li>从宿主系统挂载命名管道</li>
<li>资源限制</li>
</ul>
</li>
<li>
<p><a href=/zh/docs/concepts/workloads/controllers/>控制器（Controllers）</a></p>
<p>Kubernetes 控制器处理 Pod 的期望状态。Windows 容器支持以下负载控制器：</p>
<ul>
<li>ReplicaSet</li>
<li>ReplicationController</li>
<li>Deployment</li>
<li>StatefulSet</li>
<li>DaemonSet</li>
<li>Job</li>
<li>CronJob</li>
</ul>
</li>
<li>
<p><a href=/zh/docs/concepts/services-networking/service/>服务（Services）</a></p>
<p>Kubernetes Service 是一种抽象对象，用来定义 Pod 的一个逻辑集合及用来访问这些
Pod 的策略。Service 有时也称作微服务（Micro-service）。你可以使用服务来实现
跨操作系统的连接。在 Windows 系统中，服务可以使用下面的类型、属性和能力：</p>
<ul>
<li>Service 环境变量</li>
<li>NodePort</li>
<li>ClusterIP</li>
<li>LoadBalancer</li>
<li>ExternalName</li>
<li>无头（Headless）服务</li>
</ul>
</li>
</ul>
<p>Pods、控制器和服务是在 Kubernetes 上管理 Windows 负载的关键元素。
不过，在一个动态的云原生环境中，这些元素本身还不足以用来正确管理
Windows 负载的生命周期。我们为此添加了如下功能特性：</p>
<ul>
<li>Pod 和容器的度量（Metrics）</li>
<li>对水平 Pod 自动扩展的支持</li>
<li>对 kubectl exec 命令的支持</li>
<li>资源配额</li>
<li>调度器抢占</li>
</ul>
<h4 id=container-runtime>容器运行时 </h4>
<h5 id=docker-ee>Docker EE</h5>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.14 [stable]</code>
</div>
<p>Docker EE-basic 19.03+ 是建议所有 Windows Server 版本采用的容器运行时。
该容器运行时能够与 kubelet 中的 dockershim 代码协同工作。</p>
<h5 id=cri-containerd>CRI-ContainerD</h5>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.20 [stable]</code>
</div>
<p><a class=glossary-tooltip title=强调简单性、健壮性和可移植性的一种容器运行时 data-toggle=tooltip data-placement=top href=https://containerd.io/docs/ target=_blank aria-label=ContainerD>ContainerD</a> 1.4.0+
也可作为 Windows Kubernetes 节点上的容器运行时。</p>
<h4 id=persistent-storage>持久性存储 </h4>
<p>使用 Kubernetes <a href=/zh/docs/concepts/storage/volumes/>卷</a>，对数据持久性和 Pod 卷
共享有需求的复杂应用也可以部署到 Kubernetes 上。
管理与特定存储后端或协议相关的持久卷时，相关的操作包括：对卷的配备（Provisioning）、
去配（De-provisioning）和调整大小，将卷挂接到 Kubernetes 节点或从节点上解除挂接，
将卷挂载到需要持久数据的 Pod 中的某容器或从容器上卸载。
负责实现为特定存储后端或协议实现卷管理动作的代码以 Kubernetes 卷
<a href=/zh/docs/concepts/storage/volumes/#types-of-volumes>插件</a>的形式发布。
Windows 支持以下大类的 Kubernetes 卷插件：</p>
<h5 id=in-tree-volume-plugins>树内卷插件 </h5>
<p>与树内卷插件（In-Tree Volume Plugin）相关的代码都作为核心 Kubernetes 代码基
的一部分发布。树内卷插件的部署不需要安装额外的脚本，也不需要额外部署独立的
容器化插件组件。这些插件可以处理：对应存储后端上存储卷的配备、去配和尺寸更改，
将卷挂接到 Kubernetes 或从其上解挂，以及将卷挂载到 Pod 中各个容器上或从其上
卸载。以下树内插件支持 Windows 节点：</p>
<ul>
<li><a href=/zh/docs/concepts/storage/volumes/#awselasticblockstore>awsElasticBlockStore</a></li>
<li><a href=/zh/docs/concepts/storage/volumes/#azuredisk>azureDisk</a></li>
<li><a href=/zh/docs/concepts/storage/volumes/#azurefile>azureFile</a></li>
<li><a href=/zh/docs/concepts/storage/volumes/#gcepersistentdisk>gcePersistentDisk</a></li>
<li><a href=/zh/docs/concepts/storage/volumes/#vspherevolume>vsphereVolume</a></li>
</ul>
<h5 id=flexvolume-plugins>FlexVolume 插件 </h5>
<p>与 <a href=/zh/docs/concepts/storage/volumes/#flexVolume>FlexVolume</a> 插件相关的代码是作为
树外（Out-of-tree）脚本或可执行文件来发布的，因此需要在宿主系统上直接部署。
FlexVolume 插件处理将卷挂接到 Kubernetes 节点或从其上解挂、将卷挂载到 Pod 中
各个容器上或从其上卸载等操作。对于与 FlexVolume 插件相关联的持久卷的配备和
去配操作，可以通过外部的配置程序来处理。这类配置程序通常与 FlexVolume 插件
相分离。下面的 FlexVolume
<a href=https://github.com/Microsoft/K8s-Storage-Plugins/tree/master/flexvolume/windows>插件</a>
可以以 PowerShell 脚本的形式部署到宿主系统上，支持 Windows 节点：</p>
<ul>
<li><a href=https://github.com/microsoft/K8s-Storage-Plugins/tree/master/flexvolume/windows/plugins/microsoft.com~smb.cmd>SMB</a></li>
<li><a href=https://github.com/microsoft/K8s-Storage-Plugins/tree/master/flexvolume/windows/plugins/microsoft.com~iscsi.cmd>iSCSI</a></li>
</ul>
<h5 id=csi-plugins>CSI 插件 </h5>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.22 [stable]</code>
</div>
<p>与 <a class=glossary-tooltip title="容器存储接口 （CSI）定义了存储系统暴露给容器的标准接口。" data-toggle=tooltip data-placement=top href=/zh/docs/concepts/storage/volumes/#csi target=_blank aria-label=CSI>CSI</a> 插件相关联的代码作为
树外脚本和可执行文件来发布且通常发布为容器镜像形式，并使用 DaemonSet 和
StatefulSet 这类标准的 Kubernetes 构造体来部署。
CSI 插件处理 Kubernetes 中的很多卷管理操作：对卷的配备、去配和调整大小，
将卷挂接到 Kubernetes 节点或从节点上解除挂接，将卷挂载到需要持久数据的 Pod
中的某容器或从容器上卸载，使用快照和克隆来备份或恢复持久数据。</p>
<p>来支持；csi-proxy 是一个社区管理的、独立的可执行文件，需要预安装在每个
Windows 节点之上。请参考你要部署的 CSI 插件的部署指南以进一步了解其细节。</p>
<p>CSI 插件与执行本地存储操作的 CSI 节点插件通信。
在 Windows 节点上，CSI 节点插件通常调用处理本地存储操作的 <a href=https://github.com/kubernetes-csi/csi-proxy>csi-proxy</a>
公开的 API, csi-proxy 由社区管理。</p>
<p>有关安装的更多详细信息，请参阅你要部署的 Windows CSI 插件的环境部署指南。
你也可以参考以下<a href=https://github.com/kubernetes-csi/csi-proxy#installation>安装步骤</a> 。</p>
<h4 id=networking>联网 </h4>
<p>Windows 容器的联网是通过
<a href=/zh/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/>CNI 插件</a>
来暴露出来的。Windows 容器的联网行为与虚拟机的联网行为类似。
每个容器有一块虚拟的网络适配器（vNIC）连接到 Hyper-V 的虚拟交换机（vSwitch）。
宿主的联网服务（Host Networking Service，HNS）和宿主计算服务（Host Compute
Service，HCS）协同工作，创建容器并将容器的虚拟网卡连接到网络上。
HCS 负责管理容器，HNS 则负责管理网络资源，例如：</p>
<ul>
<li>虚拟网络（包括创建 vSwitch）</li>
<li>端点（Endpoint）/ vNIC</li>
<li>名字空间（Namespace）</li>
<li>策略（报文封装、负载均衡规则、访问控制列表、网络地址转译规则等等）</li>
</ul>
<p>支持的服务规约类型如下：</p>
<ul>
<li>NodePort</li>
<li>ClusterIP</li>
<li>LoadBalancer</li>
<li>ExternalName</li>
</ul>
<h5 id=network-modes>网络模式 </h5>
<p>Windows 支持五种不同的网络驱动/模式：二层桥接（L2bridge）、二层隧道（L2tunnel）、
覆盖网络（Overlay）、透明网络（Transparent）和网络地址转译（NAT）。
在一个包含 Windows 和 Linux 工作节点的异构集群中，你需要选择一种对 Windows 和
Linux 兼容的联网方案。下面是 Windows 上支持的一些树外插件及何时使用某种
CNI 插件的建议：</p>
<table>
<thead>
<tr>
<th>网络驱动</th>
<th>描述</th>
<th>容器报文更改</th>
<th>网络插件</th>
<th>网络插件特点</th>
</tr>
</thead>
<tbody>
<tr>
<td>L2bridge</td>
<td>
容器挂接到外部 vSwitch 上。容器挂接到下层网络之上，但由于容器的 MAC
地址在入站和出站时被重写，物理网络不需要这些地址。
</td>
<td>
MAC 地址被重写为宿主系统的 MAC 地址，IP 地址也可能依据 HNS OutboundNAT
策略重写为宿主的 IP 地址。
</td>
<td>
<a href=https://github.com/containernetworking/plugins/tree/master/plugins/main/windows/win-bridge>win-bridge<a>、
<a href=https://github.com/Azure/azure-container-networking/blob/master/docs/cni.md>Azure-CNI</a>、
Flannel 宿主网关（host-gateway）使用 win-bridge
</td>
<td>
win-bridge 使用二层桥接（L2bridge）网络模式，将容器连接到下层宿主系统上，
从而提供最佳性能。需要用户定义的路由（User-Defined Routes，UDR）才能
实现节点间的连接。
</td>
</tr>
<tr>
<td>L2Tunnel</td>
<td>
这是二层桥接的一种特殊情形，但仅被用于 Azure 上。
所有报文都被发送到虚拟化环境中的宿主机上并根据 SDN 策略进行处理。
</td>
<td>
MAC 地址被改写，IP 地址在下层网络上可见。
</td>
<td>
<a href=https://github.com/Azure/azure-container-networking/blob/master/docs/cni.md>Azure-CNI</a>
</td>
<td>
Azure-CNI 使得容器能够与 Azure vNET 集成，并允许容器利用
[Azure 虚拟网络](https://azure.microsoft.com/en-us/services/virtual-network/)
所提供的功能特性集合。例如，可以安全地连接到 Azure 服务上或者使用 Azure NSG。
你可以参考
[azure-cni](https://docs.microsoft.com/en-us/azure/aks/concepts-network#azure-cni-advanced-networking)
所提供的一些示例。
</td>
</tr>
<tr>
<td>覆盖网络（Kubernetes 中为 Windows 提供的覆盖网络支持处于 *alpha* 阶段）</td>
<td>
每个容器会获得一个连接到外部 vSwitch 的虚拟网卡（vNIC）。
每个覆盖网络都有自己的、通过定制 IP 前缀来定义的 IP 子网。
覆盖网络驱动使用 VxLAN 封装。
</td>
<td>
封装于外层包头内。
</td>
<td>
<a href=https://github.com/containernetworking/plugins/tree/master/plugins/main/windows/win-overlay>Win-overlay</a>、
Flannel VXLAN（使用 win-overlay）
</td>
<td>
当（比如出于安全原因）期望虚拟容器网络与下层宿主网络隔离时，
应该使用 win-overlay。如果你的数据中心可用 IP 地址受限，
覆盖网络允许你在不同的网络中复用 IP 地址（每个覆盖网络有不同的 VNID 标签）。
这一选项要求在 Windows Server 2009 上安装
[KB4489899](https://support.microsoft.com/help/4489899) 补丁。
</td>
</tr>
<tr>
<td>
透明网络（[ovn-kubernetes](https://github.com/openvswitch/ovn-kubernetes) 的特殊用例）
</td>
<td>
需要一个外部 vSwitch。容器挂接到某外部 vSwitch 上，该 vSwitch
通过逻辑网络（逻辑交换机和路由器）允许 Pod 间通信。
</td>
<td>
报文或者通过 [GENEVE](https://datatracker.ietf.org/doc/draft-gross-geneve/) 来封装，
或者通过 [STT](https://datatracker.ietf.org/doc/draft-davie-stt/) 隧道来封装，
以便能够到达不在同一宿主系统上的每个 Pod。<br>
报文通过 OVN 网络控制器所提供的隧道元数据信息来判定是转发还是丢弃。<br>
北-南向通信通过 NAT 网络地址转译来实现。
</td>
<td>
<a href=https://github.com/openvswitch/ovn-kubernetes>ovn-kubernetes</a>
</td>
<td>
[通过 Ansible 来部署](https://github.com/openvswitch/ovn-kubernetes/tree/master/contrib)。
所发布的 ACL 可以通过 Kubernetes 策略来应用实施。支持 IPAM 。
负载均衡能力不依赖 kube-proxy。
网络地址转译（NAT）也不需要 iptables 或 netsh。
</td>
</tr>
<tr>
<td>NAT（<b>未在 Kubernetes 中使用</b>）</td>
<td>
容器获得一个连接到某内部 vSwitch 的 vNIC 接口。
DNS/DHCP 服务通过名为
[WinNAT](https://blogs.technet.microsoft.com/virtualization/2016/05/25/windows-nat-winnat-capabilities-and-limitations/)
的内部组件来提供。
</td>
<td>
MAC 地址和 IP 地址都被重写为宿主系统的 MAC 地址和 IP 地址。
</td>
<td>
<a href=https://github.com/Microsoft/windows-container-networking/tree/master/plugins/nat>nat</a>
</td>
<td>
列在此表中仅出于完整性考虑
</td>
</tr>
</tbody>
</table>
<p>如前所述，<a href=https://github.com/coreos/flannel>Flannel</a> CNI
<a href=https://github.com/containernetworking/plugins/tree/master/plugins/meta/flannel>meta 插件</a>
在 Windows 上也是
<a href=https://github.com/containernetworking/plugins/tree/master/plugins/meta/flannel#windows-support-experimental>被支持</a>
的，方法是通过 <a href=https://github.com/coreos/flannel/blob/master/Documentation/backends.md#vxlan>VXLAN 网络后端</a>
（<strong>alpha 阶段</strong> ：委托给 win-overlay）和
<a href=https://github.com/coreos/flannel/blob/master/Documentation/backends.md#host-gw>主机-网关（host-gateway）网络后端</a>
（稳定版本；委托给 win-bridge 实现）。
此插件支持将操作委托给所引用的 CNI 插件（win-overlay、win-bridge）之一，
从而能够与 Windows 上的 Flannel 守护进程（Flanneld）一同工作，自动为节点
分配子网租期，创建 HNS 网络。
该插件读入其自身的配置文件（cni.conf），并将其与 FlannelD 所生成的 subnet.env
文件中的环境变量整合，之后将其操作委托给所引用的 CNI 插件之一以完成网络发现，
并将包含节点所被分配的子网信息的正确配置发送给 IPAM 插件（例如 host-local）。</p>
<p>对于节点、Pod 和服务对象，可针对 TCP/UDP 流量支持以下网络数据流：</p>
<ul>
<li>Pod -> Pod （IP 寻址）</li>
<li>Pod -> Pod （名字寻址）</li>
<li>Pod -> 服务（集群 IP）</li>
<li>Pod -> 服务（部分限定域名，仅适用于名称中不包含“.”的情形）</li>
<li>Pod -> 服务（全限定域名）</li>
<li>Pod -> 集群外部（IP 寻址）</li>
<li>Pod -> 集群外部（DNS 寻址）</li>
<li>节点 -> Pod</li>
<li>Pod -> 节点</li>
</ul>
<h5 id=ipam>IP 地址管理（IPAM） </h5>
<p>Windows 上支持以下 IPAM 选项：</p>
<ul>
<li><a href=https://github.com/containernetworking/plugins/tree/master/plugins/ipam/host-local>host-local</a></li>
<li>HNS IPAM (Inbox 平台 IPAM，未指定 IPAM 时的默认设置）</li>
<li><a href=https://github.com/Azure/azure-container-networking/blob/master/docs/ipam.md>Azure-vnet-ipam</a>（仅适用于 azure-cni ）</li>
</ul>
<h5 id=load-balancing-and-services>负载均衡与服务 </h5>
<p>在 Windows 系统上，你可以使用以下配置来设定服务和负载均衡行为：</p>
<table><caption style=display:none>Windows 服务设置</caption>
<thead>
<tr>
<th>功能特性</th>
<th>描述</th>
<th>所支持的 Kubernetes 版本</th>
<th>所支持的 Windows OS 版本</th>
<th>如何启用</th>
</tr>
<thead>
<tbody>
<tr>
<td>会话亲和性</td>
<td>
确保来自特定客户的连接每次都被交给同一 Pod。
</td>
<td>v1.20+</td>
<td>
[Windows Server vNext Insider Preview Build 19551](https://blogs.windows.com/windowsexperience/2020/01/28/announcing-windows-server-vnext-insider-preview-build-19551/)
或更高版本
</td>
<td>
将 <code>service.spec.sessionAffinitys</code> 设置为 "ClientIP"
</td>
</tr>
<tr>
<td>直接服务器返回（DSR）</td>
<td>
这是一种负载均衡模式，IP 地址的修正和负载均衡地址转译（LBNAT）
直接在容器的 vSwitch 端口上处理；服务流量到达时，其源端 IP 地址
设置为来源 Pod 的 IP。
</td>
<td>v1.20+</td>
<td>
Windows Server 2019
</td>
<td>
为 kube-proxy 设置标志：`--feature-gates="WinDSR=true" --enable-dsr=true`
</td>
</tr>
<tr>
<td>保留目标地址</td>
<td>
对服务流量略过 DNAT 步骤，这样就可以在到达后端 Pod 的报文中保留目标服务的
虚拟 IP 地址。还要禁止节点之间的转发。
</td>
<td>v1.20+</td>
<td>Windows Server 1903 或更高版本</td>
<td>
在服务注解中设置 `"preserve-destination": "true"` 并启用
kube-proxy 中的 DSR 标志。
</td>
</tr>
<tr>
<td>IPv4/IPv6 双栈网络</td>
<td>
在集群内外同时支持原生的 IPv4-到-IPv4 和 IPv6-到-IPv6 通信。
</td>
<td>v1.19+</td>
<td>Windows Server 2004 或更高版本</td>
<td>
参见 [IPv4/IPv6 双栈网络](#ipv4ipv6-dual-stack)
</td>
</tr>
<tr>
<td>保留客户端 IP</td>
<td>
确保入站流量的源 IP 地址被保留。同样要禁止节点之间的转发。
</td>
<td>v1.20+</td>
<td>Windows Server 2019 或更高版本</td>
<td>
将 <code>service.spec.externalTrafficPolicy</code> 设置为 "Local"，
并在 kube-proxy 上启用 DSR。
</td>
</tr>
</tbody>
</table>
<h4 id=ipv4ipv6-dual-stack>IPv4/IPv6 双栈支持 </h4>
<p>你可以通过使用 <code>IPv6DualStack</code>
<a href=/zh/docs/reference/command-line-tools-reference/feature-gates/>特性门控</a>
来为 <code>l2bridge</code> 网络启用 IPv4/IPv6 双栈联网支持。
进一步的细节可参见
<a href=/zh/docs/concepts/services-networking/dual-stack#enable-ipv4ipv6-dual-stack>启用 IPv4/IPv6 双协议栈</a>。</p>
<p>对 Windows 而言，在 Kubernetes 中使用 IPv6 需要
Windows Server 2004 （内核版本 10.0.19041.610）或更高版本。</p>
<p>目前 Windows 上的覆盖网络（VXLAN）还不支持双协议栈联网。</p>
<h3 id=limitations>局限性 </h3>
<p>在 Kubernetes 架构和节点阵列中仅支持将 Windows 作为工作节点使用。
这意味着 Kubernetes 集群必须总是包含 Linux 主控节点，零个或者多个 Linux
工作节点以及零个或者多个 Windows 工作节点。</p>
<h4 id=resource-handling>资源处理</h4>
<p>Linux 上使用 Linux 控制组（CGroups）作为 Pod 的边界，以实现资源控制。
容器都创建于这一边界之内，从而实现网络、进程和文件系统的隔离。
控制组 CGroups API 可用来收集 CPU、I/O 和内存的统计信息。
与此相比，Windows 为每个容器创建一个带有系统名字空间过滤设置的 Job 对象，
以容纳容器中的所有进程并提供其与宿主系统间的逻辑隔离。
没有现成的名字空间过滤设置是无法运行 Windows 容器的。
这也意味着，系统特权无法在宿主环境中评估，因而 Windows 上也就不存在特权容器。
归咎于独立存在的安全账号管理器（Security Account Manager，SAM），容器也不能
获得宿主系统上的任何身份标识。</p>
<h4 id=resource-reservations>资源预留 </h4>
<h5 id=memory-reservations>内存预留 </h5>
<p>Windows 不像 Linux 一样有一个内存耗尽（Out-of-memory）进程杀手（Process
Killer）机制。Windows 总是将用户态的内存分配视为虚拟请求，页面文件（Pagefile）
是必需的。这一差异的直接结果是 Windows 不会像 Linux 那样出现内存耗尽的状况，
系统会将进程内存页面写入磁盘而不会因内存耗尽而终止进程。
当内存被过量使用且所有物理内存都被用光时，系统的换页行为会导致性能下降。</p>
<p>使用 kubelet 参数 <code>--kubelet-reserve</code> 与/或 <code>-system-reserve</code> 可以统计
节点上的内存用量（各容器之外），进而可能将内存用量限制在一个合理的范围，。
这样做会减少节点可分配内存
（<a href=/zh/docs/tasks/administer-cluster/reserve-compute-resources/#node-allocatable>NodeAllocatable</a>）。</p>
<p>在你部署工作负载时，对容器使用资源限制（必须仅设置 limits 或者让 limits 等于
requests 值）。这也会从 NodeAllocatable 中耗掉部分内存量，从而避免在节点
负荷已满时调度器继续向节点添加 Pods。</p>
<p>避免过量分配的最佳实践是为 kubelet 配置至少 2 GB 的系统预留内存，以供
Windows、Docker 和 Kubernetes 进程使用。</p>
<h5 id=cpu-reservations>CPU 预留 </h5>
<p>为了统计 Windows、Docker 和其他 Kubernetes 宿主进程的 CPU 用量，建议
预留一定比例的 CPU，以便对事件作出相应。此值需要根据 Windows 节点上
CPU 核的个数来调整，要确定此百分比值，用户需要为其所有节点确定 Pod
密度的上线，并监控系统服务的 CPU 用量，从而选择一个符合其负载需求的值。</p>
<p>使用 kubelet 参数 <code>--kubelet-reserve</code> 与/或 <code>-system-reserve</code> 可以统计
节点上的 CPU 用量（各容器之外），进而可能将 CPU 用量限制在一个合理的范围，。
这样做会减少节点可分配 CPU
（<a href=/zh/docs/tasks/administer-cluster/reserve-compute-resources/#node-allocatable>NodeAllocatable</a>）。</p>
<h5 id=feature-restrictions>功能特性限制 </h5>
<ul>
<li>终止宽限期（Termination Grace Period）：未实现</li>
<li>单文件映射：将用 CRI-ContainerD 来实现</li>
<li>终止消息（Termination message）：将用 CRI-ContainerD 来实现</li>
<li>特权容器：Windows 容器当前不支持</li>
<li>巨页（Huge Pages）：Windows 容器当前不支持</li>
<li>现有的节点问题探测器（Node Problem Detector）仅适用于 Linux，且要求使用特权容器。
一般而言，我们不设想此探测器能用于 Windows 节点，因为 Windows 不支持特权容器。</li>
<li>并非支持共享名字空间的所有功能特性（参见 API 节以了解详细信息）</li>
</ul>
<h4 id=与-linux-相比参数行为的差别>与 Linux 相比参数行为的差别</h4>
<p>以下 kubelet 参数的行为在 Windows 节点上有些不同，描述如下：</p>
<ul>
<li><code>--kubelet-reserve</code>、<code>--system-reserve</code> 和 <code>--eviction-hard</code> 标志
会更新节点可分配资源量</li>
<li>未实现通过使用 <code>--enforce-node-allocable</code> 来完成的 Pod 驱逐</li>
<li>未实现通过使用 <code>--eviction-hard</code> 和 <code>--eviction-soft</code> 来完成的 Pod 驱逐</li>
<li><code>MemoryPressure</code> 状况未实现</li>
<li><code>kubelet</code> 不会采取措施来执行基于 OOM 的驱逐动作</li>
<li>Windows 节点上运行的 kubelet 没有内存约束。
<code>--kubelet-reserve</code> 和 <code>--system-reserve</code> 不会为 kubelet 或宿主系统上运行
的进程设限。这意味着 kubelet 或宿主系统上的进程可能导致内存资源紧张，
而这一情况既不受节点可分配量影响，也不会被调度器感知。</li>
<li>在 Windows 节点上存在一个额外的参数用来设置 kubelet 进程的优先级，称作
<code>--windows-priorityclass</code>。此参数允许 kubelet 进程获得与 Windows 宿主上
其他进程相比更多的 CPU 时间片。
关于可用参数值及其含义的进一步信息可参考
<a href=https://docs.microsoft.com/en-us/windows/win32/procthread/scheduling-priorities#priority-class>Windows Priority Classes</a>。
为了让 kubelet 总能够获得足够的 CPU 周期，建议将此参数设置为
<code>ABOVE_NORMAL_PRIORITY_CLASS</code> 或更高。</li>
</ul>
<h4 id=storage>存储 </h4>
<p>Windows 上包含一个分层的文件系统来挂载容器的分层，并会基于 NTFS 来创建一个
拷贝文件系统。容器中的所有文件路径都仅在该容器的上下文内完成解析。</p>
<ul>
<li>Docker 卷挂载仅可针对容器中的目录进行，不可针对独立的文件。
这一限制不适用于 CRI-containerD。</li>
<li>卷挂载无法将文件或目录投射回宿主文件系统。</li>
<li>不支持只读文件系统，因为 Windows 注册表和 SAM 数据库总是需要写访问权限。
不过，Windows 支持只读的卷。</li>
<li>不支持卷的用户掩码和访问许可，因为宿主与容器之间并不共享 SAM，二者之间不存在
映射关系。所有访问许可都是在容器上下文中解析的。</li>
</ul>
<p>因此，Windows 节点上不支持以下存储功能特性：</p>
<ul>
<li>卷的子路径挂载；只能在 Windows 容器上挂载整个卷。</li>
<li>为 Secret 执行子路径挂载；</li>
<li>宿主挂载投射；</li>
<li>默认访问模式 defaultMode（因为该特性依赖 UID/GID）；</li>
<li>只读的根文件系统；映射的卷仍然支持 <code>readOnly</code>；</li>
<li>块设备映射；</li>
<li>将内存作为存储介质；</li>
<li>类似 UUID/GUID、每用户不同的 Linux 文件系统访问许可等文件系统特性；</li>
<li>基于 NFS 的存储和卷支持；</li>
<li>扩充已挂载卷（resizefs）。</li>
</ul>
<h4 id=networking-limitations>联网 </h4>
<p>Windows 容器联网与 Linux 联网有着非常重要的差别。
<a href=https://docs.microsoft.com/en-us/virtualization/windowscontainers/container-networking/architecture>Microsoft documentation for Windows Container Networking</a>
中包含额外的细节和背景信息。</p>
<p>Windows 宿主联网服务和虚拟交换机实现了名字空间隔离，可以根据需要为 Pod 或容器
创建虚拟的网络接口（NICs）。不过，很多类似 DNS、路由、度量值之类的配置数据都
保存在 Windows 注册表数据库中而不是像 Linux 一样保存在 <code>/etc/...</code> 文件中。
Windows 为容器提供的注册表与宿主系统的注册表是分离的，因此类似于将 /etc/resolv.conf
文件从宿主系统映射到容器中的做法不会产生与 Linux 系统相同的效果。
这些信息必须在容器内部使用 Windows API 来配置。
因此，CNI 实现需要调用 HNS，而不是依赖文件映射来将网络细节传递到 Pod
或容器中。</p>
<p>Windows 节点不支持以下联网功能：</p>
<ul>
<li>Windows Pod 不能使用宿主网络模式；</li>
<li>从节点本地访问 NodePort 会失败（但从其他节点或外部客户端可访问）</li>
<li>Windows Server 的未来版本中会支持从节点访问服务的 VIP；</li>
<li>每个服务最多支持 64 个后端 Pod 或独立的目标 IP 地址；</li>
<li>kube-proxy 的覆盖网络支持是 Beta 特性。此外，它要求在 Windows Server 2019 上安装
<a href=https://support.microsoft.com/en-us/help/4482887/windows-10-update-kb4482887>KB4482887</a> 补丁；</li>
<li>非 DSR（保留目标地址）模式下的本地流量策略；</li>
<li>连接到覆盖网络的 Windows 容器不支持使用 IPv6 协议栈通信。
要使得这一网络驱动支持 IPv6 地址需要在 Windows 平台上开展大量的工作，
还需要在 Kubernetes 侧修改 kubelet、kube-proxy 以及 CNI 插件。</li>
</ul>
<ul>
<li>
<p>通过 win-overlay、win-bridge 和 Azure-CNI 插件使用 ICMP 协议向集群外通信。
尤其是，Windows 数据面
（<a href=https://www.microsoft.com/en-us/research/project/azure-virtual-filtering-platform/>VFP</a>）
不支持转换 ICMP 报文。这意味着：</p>
<ul>
<li>指向同一网络内目标地址的 ICMP 报文（例如 Pod 之间的 ping 通信）是可以工作的，
没有局限性；</li>
<li>TCP/UDP 报文可以正常工作，没有局限性；</li>
<li>指向远程网络的 ICMP 报文（例如，从 Pod 中 ping 外部互联网的通信）无法被转换，
因此也无法被路由回到其源点；</li>
<li>由于 TCP/UDP 包仍可被转换，用户可以将 <code>ping &lt;目标></code> 操作替换为 <code>curl &lt;目标></code>
以便能够调试与外部世界的网络连接。</li>
</ul>
</li>
</ul>
<p>Kubernetes v1.15 中添加了以下功能特性：</p>
<ul>
<li><code>kubectl port-forward</code></li>
</ul>
<h5 id=cni-plugins>CNI 插件 </h5>
<ul>
<li>
<p>Windows 参考网络插件 win-bridge 和 win-overlay 当前未实现
<a href=https://github.com/containernetworking/cni/blob/master/SPEC.md>CNI spec</a> v0.4.0，
原因是缺少检查（CHECK）用的实现。</p>
</li>
<li>
<p>Windows 上的 Flannel VXLAN CNI 有以下局限性：</p>
<ol>
<li>其设计上不支持从节点到 Pod 的连接。
只有在 Flannel v0.12.0 或更高版本后才有可能访问本地 Pods。</li>
<li>我们被限制只能使用 VNI 4096 和 UDP 端口 4789。
VNI 的限制正在被解决，会在将来的版本中消失（开源的 Flannel 更改）。
参见官方的 <a href=https://github.com/coreos/flannel/blob/master/Documentation/backends.md#vxlan>Flannel VXLAN</a>
后端文档以了解关于这些参数的详细信息。</li>
</ol>
</li>
</ul>
<h5 id=dns-limitations>DNS</h5>
<ul>
<li>
<p>不支持 DNS 的 ClusterFirstWithHostNet 配置。Windows 将所有包含 “.” 的名字
视为全限定域名（FQDN），因而不会对其执行部分限定域名（PQDN）解析。</p>
</li>
<li>
<p>在 Linux 上，你可以有一个 DNS 后缀列表供解析部分限定域名时使用。
在 Windows 上，我们只有一个 DNS 后缀，即与该 Pod 名字空间相关联的 DNS
后缀（例如 <code>mydns.svc.cluster.local</code>）。
Windows 可以解析全限定域名、或者恰好可用该后缀来解析的服务名称。
例如，在 default 名字空间中生成的 Pod 会获得 DNS 后缀
<code>default.svc.cluster.local</code>。在 Windows Pod 中，你可以解析
<code>kubernetes.default.svc.cluster.local</code> 和 <code>kubernetes</code>，但无法解析二者
之间的形式，如 <code>kubernetes.default</code> 或 <code>kubernetes.default.svc</code>。</p>
</li>
<li>
<p>在 Windows 上，可以使用的 DNS 解析程序有很多。由于这些解析程序彼此之间
会有轻微的行为差别，建议使用 <code>Resolve-DNSName</code> 工具来完成名字查询解析。</p>
</li>
</ul>
<h5 id=ipv6>IPv6</h5>
<p>Windows 上的 Kubernetes 不支持单协议栈的“只用 IPv6”联网选项。
不过，系统支持在 IPv4/IPv6 双协议栈的 Pod 和节点上运行单协议家族的服务。
更多细节可参阅 <a href=#ipv4ipv6-dual-stack>IPv4/IPv6 双协议栈联网</a>一节。</p>
<h5 id=session-affinity>会话亲和性 </h5>
<p>不支持使用 <code>service.spec.sessionAffinityConfig.clientIP.timeoutSeconds</code> 来为
Windows 服务设置最大会话粘滞时间。</p>
<h5 id=security>安全性 </h5>
<p>Secret 以明文形式写入节点的卷中（而不是像 Linux 那样写入内存或 tmpfs 中）。
这意味着客户必须做以下两件事：</p>
<ol>
<li>使用文件访问控制列表来保护 Secret 文件所在的位置</li>
<li>使用 <a href=https://docs.microsoft.com/en-us/windows/security/information-protection/bitlocker/bitlocker-how-to-deploy-on-windows-server>BitLocker</a>
来执行卷层面的加密</li>
</ol>
<p>用户可以为 Windows Pods 或 Container 设置
<a href=/zh/docs/tasks/configure-pod-container/configure-runasusername><code>RunAsUserName</code></a>
以便以非节点默认用户来执行容器中的进程。这大致等价于设置
<a href=/zh/docs/concepts/policy/pod-security-policy/#users-and-groups><code>RunAsUser</code></a>。</p>
<p>不支持特定于 Linux 的 Pod 安全上下文特权，例如 SELinux、AppArmor、Seccomp、
权能字（POSIX 权能字）等等。</p>
<p>此外，如前所述，Windows 不支持特权容器。</p>
<h4 id=api>API</h4>
<p>对 Windows 而言，大多数 Kubernetes API 的工作方式没有变化。
一些不易察觉的差别通常体现在 OS 和容器运行时上的不同。
在某些场合，负载 API （如 Pod 或 Container）的某些属性在设计时假定其
在 Linux 上实现，因此会无法在 Windows 上运行。</p>
<p>在较高层面，不同的 OS 概念有：</p>
<ul>
<li>
<p>身份标识 - Linux 使用证书类型来表示用户 ID（UID）和组 ID（GID）。用户和组名
没有特定标准，它们是 <code>/etc/groups</code> 或 <code>/etc/passwd</code> 中的别名表项，会映射回
UID+GID。Windows 使用一个更大的二进制安全标识符（SID），保存在 Windows
安全访问管理器（Security Access Manager，SAM）数据库中。此数据库并不在宿主系统
与容器间，或者任意两个容器之间共享。</p>
</li>
<li>
<p>文件许可 - Windows 使用基于 SID 的访问控制列表，而不是基于 UID+GID 的访问权限位掩码。</p>
</li>
</ul>
<ul>
<li>
<p>文件路径 - Windows 上的习惯是使用 <code>\</code> 而非 <code>/</code>。Go 语言的 IO
库同时接受这两种文件路径分隔符。不过，当你在指定要在容器内解析的路径或命令行时，
可能需要使用 <code>\</code>。</p>
</li>
<li>
<p>信号（Signal） - Windows 交互式应用以不同方式来处理终止事件，并可实现以下方式之一或组合：</p>
<ul>
<li>
<p>UI 线程处理包含 <code>WM_CLOSE</code> 在内的良定的消息</p>
</li>
<li>
<p>控制台应用使用控制处理程序来处理 Ctrl-C 或 Ctrl-Break</p>
</li>
<li>
<p>服务会注册服务控制处理程序，接受 <code>SERVICE_CONTROL_STOP</code> 控制代码</p>
</li>
</ul>
</li>
</ul>
<p>退出代码遵从相同的习惯，0 表示成功，非 0 值表示失败。
特定的错误代码在 Windows 和 Linux 上可能会不同。不过，从 Kubernetes 组件
（kubelet、kube-proxy）所返回的退出代码是没有变化的。</p>
<ul>
<li>
<p><code>v1.Container.ResourceRequirements.limits.cpu</code> 和
<code>v1.Container.ResourceRequirements.limits.memory</code> - Windows
不对 CPU 分配设置硬性的限制。与之相反，Windows 使用一个份额（share）系统。
基于毫核（millicores）的现有字段值会被缩放为相对的份额值，供 Windows 调度器使用。
参见 <a href=https://github.com/kubernetes/kubernetes/blob/master/pkg/kubelet/kuberuntime/helpers_windows.go>kuberuntime/helpers_windows.go</a> 和
<a href=https://docs.microsoft.com/en-us/virtualization/windowscontainers/manage-containers/resource-controls>Microsoft 文档中关于资源控制的部分</a>。</p>
<ul>
<li>Windows 容器运行时中没有实现巨页支持，因此相关特性不可用。
巨页支持需要<a href=https://docs.microsoft.com/en-us/windows/desktop/Memory/large-page-support>判定用户的特权</a>
而这一特性无法在容器级别配置。</li>
</ul>
</li>
</ul>
<ul>
<li>
<p><code>v1.Container.ResourceRequirements.requests.cpu</code> 和
<code>v1.Container.ResourceRequirements.requests.memory</code> - 请求
值会从节点可分配资源中扣除，从而可用来避免节点上的资源过量分配。
但是，它们无法用来在一个已经过量分配的节点上提供资源保障。
如果操作员希望彻底避免过量分配，作为最佳实践，他们就需要为所有容器设置资源请求值。</p>
</li>
<li>
<p><code>v1.Container.SecurityContext.allowPrivilegeEscalation</code> - 在 Windows
上无法实现，对应的权能无一可在 Windows 上生效。</p>
</li>
</ul>
<ul>
<li><code>v1.Container.SecurityContext.Capabilities</code> - Windows 上未实现 POSIX 权能机制</li>
<li><code>v1.Container.SecurityContext.privileged</code> - Windows 不支持特权容器</li>
<li><code>v1.Container.SecurityContext.procMount</code> - Windows 不包含 <code>/proc</code> 文件系统</li>
<li><code>v1.Container.SecurityContext.readOnlyRootFilesystem</code> - 在 Windows 上无法实现，
要在容器内使用注册表或运行系统进程就必需写访问权限。</li>
</ul>
<ul>
<li>
<p><code>v1.Container.SecurityContext.runAsGroup</code> - 在 Windows 上无法实现，没有 GID 支持</p>
</li>
<li>
<p><code>v1.Container.SecurityContext.runAsNonRoot</code> - Windows 上没有 root 用户。
与之最接近的等价用户是 <code>ContainerAdministrator</code>，而该身份标识在节点上并不存在。</p>
</li>
<li>
<p><code>v1.Container.SecurityContext.runAsUser</code> - 在 Windows 上无法实现，
因为没有作为整数支持的 GID。</p>
</li>
<li>
<p><code>v1.Container.SecurityContext.seLinuxOptions</code> - 在 Windows 上无法实现，
因为没有 SELinux</p>
</li>
<li>
<p><code>V1.Container.terminationMessagePath</code> - 因为 Windows 不支持单个文件的映射，这一功能
在 Windows 上也受限。默认值 <code>/dev/termination-log</code> 在 Windows 上也无法使用因为
对应路径在 Windows 上不存在。</p>
</li>
</ul>
<h5 id=v1-pod>V1.Pod</h5>
<ul>
<li><code>v1.Pod.hostIPC</code>、<code>v1.Pod.hostPID</code> - Windows 不支持共享宿主系统的名字空间</li>
<li><code>v1.Pod.hostNetwork</code> - Windows 操作系统不支持共享宿主网络</li>
<li><code>v1.Pod.dnsPolicy</code> - 不支持 <code>ClusterFirstWithHostNet</code>，因为 Windows 不支持宿主网络</li>
<li><code>v1.Pod.podSecurityContext</code> - 参见下面的 <code>v1.PodSecurityContext</code></li>
<li><code>v1.Pod.shareProcessNamespace</code> - 此为 Beta 特性且依赖于 Windows 上未实现
的 Linux 名字空间。
Windows 无法共享进程名字空间或者容器的根文件系统。只能共享网络。</li>
</ul>
<ul>
<li>
<p><code>v1.Pod.terminationGracePeriodSeconds</code> - 这一特性未在 Windows 版本的 Docker 中完全实现。
参见<a href=https://github.com/moby/moby/issues/25982>问题报告</a>。
目前实现的行为是向 <code>ENTRYPOINT</code> 进程发送 <code>CTRL_SHUTDOWN_EVENT</code> 事件，之后 Windows 默认
等待 5 秒钟，并最终使用正常的 Windows 关机行为关闭所有进程。
这里的 5 秒钟默认值实际上保存在
<a href=https://github.com/moby/moby/issues/25982#issuecomment-426441183>容器内</a>
的 Windows 注册表中，因此可以在构造容器时重载。</p>
</li>
<li>
<p><code>v1.Pod.volumeDevices</code> - 此为 Beta 特性且未在 Windows 上实现。Windows 无法挂接
原生的块设备到 Pod 中。</p>
</li>
</ul>
<ul>
<li>
<p><code>v1.Pod.volumes</code> - <code>emptyDir</code>、<code>secret</code>、<code>configMap</code> 和 <code>hostPath</code>
都可正常工作且在 TestGrid 中测试。</p>
<ul>
<li><code>v1.emptyDir.volumeSource</code> - Windows 上节点的默认介质是磁盘。
不支持将内存作为介质，因为 Windows 不支持内置的 RAM 磁盘。</li>
</ul>
</li>
<li>
<p><code>v1.VolumeMount.mountPropagation</code> - Windows 上不支持挂载传播。</p>
</li>
</ul>
<h5 id=v1-podsecuritycontext>V1.PodSecurityContext</h5>
<p>PodSecurityContext 的所有选项在 Windows 上都无法工作。这些选项列在下面仅供参考。</p>
<ul>
<li>
<p><code>v1.PodSecurityContext.seLinuxOptions</code> - Windows 上无 SELinux</p>
</li>
<li>
<p><code>v1.PodSecurityContext.runAsUser</code> - 提供 UID；Windows 不支持</p>
</li>
<li>
<p><code>v1.PodSecurityContext.runAsGroup</code> - 提供 GID；Windows 不支持</p>
</li>
<li>
<p><code>v1.PodSecurityContext.runAsNonRoot</code> - Windows 上没有 root 用户
最接近的等价账号是 <code>ContainerAdministrator</code>，而该身份标识在节点上不存在</p>
</li>
<li>
<p><code>v1.PodSecurityContext.supplementalGroups</code> - 提供 GID；Windows 不支持</p>
</li>
<li>
<p><code>v1.PodSecurityContext.sysctls</code> - 这些是 Linux sysctl 接口的一部分；Windows 上
没有等价机制。</p>
</li>
</ul>
<h4 id=operating-system-version-restrictions>操作系统版本限制 </h4>
<p>Windows 有着严格的兼容性规则，宿主 OS 的版本必须与容器基准镜像 OS 的版本匹配。
目前仅支持容器操作系统为 Windows Server 2019 的 Windows 容器。
对于容器的 Hyper-V 隔离、允许一定程度上的 Windows 容器镜像版本向后兼容性等等，
都是将来版本计划的一部分。</p>
<h2 id=troubleshooting>获取帮助和故障排查 </h2>
<p>对你的 Kubernetes 集群进行排查的主要帮助信息来源应该是
<a href=/docs/tasks/debug-application-cluster/troubleshooting/>这份文档</a>。
该文档中包含了一些额外的、特定于 Windows 系统的故障排查帮助信息。
Kubernetes 中日志是故障排查的一个重要元素。确保你在尝试从其他贡献者那里获得
故障排查帮助时提供日志信息。你可以按照 SIG-Windows
<a href=https://github.com/kubernetes/community/blob/master/sig-windows/CONTRIBUTING.md#gathering-logs>贡献指南和收集日志</a>
所给的指令来操作。</p>
<ul>
<li>
<p>我怎样知道 <code>start.ps1</code> 是否已成功完成？</p>
<p>你应该能看到节点上运行的 kubelet、kube-proxy 和（如果你选择 Flannel
作为联网方案）flanneld 宿主代理进程，它们的运行日志显示在不同的
PowerShell 窗口中。此外，你的 Windows 节点应该在你的 Kubernetes 集群
列举为 "Ready" 节点。</p>
</li>
</ul>
<ul>
<li>
<p>我可以将 Kubernetes 节点进程配置为服务运行在后台么？</p>
<p>kubelet 和 kube-proxy 都已经被配置为以本地 Windows 服务运行，
并且在出现失效事件（例如进程意外结束）时通过自动重启服务来提供一定的弹性。
你有两种办法将这些节点组件配置为服务。</p>
<ul>
<li>
<p>以本地 Windows 服务的形式</p>
<p>Kubelet 和 kube-proxy 可以用 <code>sc.exe</code> 以本地 Windows 服务的形式运行：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=color:#080;font-style:italic># 用两个单独的命令为 kubelet 和 kube-proxy 创建服务</span>
sc.exe create &lt;组件名称&gt; binPath=<span style=color:#b44>&#34;&lt;可执行文件路径&gt; -service &lt;其它参数&gt;&#34;</span>

<span style=color:#080;font-style:italic># 请注意如果参数中包含空格，必须使用转义</span>
sc.exe create kubelet binPath= <span style=color:#b44>&#34;C:\kubelet.exe --service --hostname-override &#39;minion&#39; &lt;其它参数&gt;&#34;</span>

<span style=color:#080;font-style:italic># 启动服务</span>
<span style=color:#a2f>Start-Service</span> kubelet
<span style=color:#a2f>Start-Service</span> <span style=color:#a2f>kube-proxy</span>

<span style=color:#080;font-style:italic># 停止服务</span>
<span style=color:#a2f>Stop-Service</span> kubelet (-Force)
<span style=color:#a2f>Stop-Service</span> <span style=color:#a2f>kube-proxy</span> (-Force)

<span style=color:#080;font-style:italic># 查询服务状态</span>
<span style=color:#a2f>Get-Service</span> kubelet
<span style=color:#a2f>Get-Service</span> <span style=color:#a2f>kube-proxy</span>
</code></pre></div></li>
</ul>
<ul>
<li>
<p>使用 nssm.exe</p>
<p>你也总是可以使用替代的服务管理器，例如<a href=https://nssm.cc/>nssm.exe</a>，来为你在后台运行
这些进程（<code>flanneld</code>、<code>kubelet</code> 和 <code>kube-proxy</code>）。你可以使用这一
<a href=https://github.com/Microsoft/SDN/tree/master/Kubernetes/flannel/register-svc.ps1>示例脚本</a>，
利用 <code>nssm.exe</code> 将 <code>kubelet</code>、<code>kube-proxy</code> 和 <code>flanneld.exe</code> 注册为要在后台运行的
Windows 服务。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=color:#a2f>register-svc</span>.ps1 -NetworkMode &lt;网络模式&gt; -ManagementIP &lt;Windows 节点 IP&gt; -ClusterCIDR &lt;集群子网&gt; -KubeDnsServiceIP &lt;<span style=color:#a2f>kube-dns</span> 服务 IP&gt; -LogDir &lt;日志目录&gt;
</code></pre></div>
<p>这里的参数解释如下：</p>
<ul>
<li><code>NetworkMode</code>：网络模式 l2bridge（flannel host-gw，也是默认值）或
overlay（flannel vxlan）选做网络方案</li>
<li><code>ManagementIP</code>：分配给 Windows 节点的 IP 地址。你可以使用 ipconfig 得到此值</li>
<li><code>ClusterCIDR</code>：集群子网范围（默认值为 10.244.0.0/16）</li>
<li><code>KubeDnsServiceIP</code>：Kubernetes DNS 服务 IP（默认值为 10.96.0.10）</li>
<li><code>LogDir</code>：kubelet 和 kube-proxy 的日志会被重定向到这一目录中的对应输出文件，
默认值为 <code>C:\k</code>。</li>
</ul>
<p>若以上所引用的脚本不适合，你可以使用下面的例子手动配置 <code>nssm.exe</code>。</p>
<p>注册 flanneld.exe：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell>nssm install flanneld C:\flannel\flanneld.exe
nssm <span style=color:#a2f>set </span>flanneld AppParameters --kubeconfig<span style=color:#666>-file</span>=c:\k\config --iface=&lt;ManagementIP&gt; --ip-masq=1 --kube-subnet-mgr=1
nssm <span style=color:#a2f>set </span>flanneld AppEnvironmentExtra NODE_NAME=&lt;hostname&gt;
nssm <span style=color:#a2f>set </span>flanneld AppDirectory C:\flannel
nssm <span style=color:#a2f>start </span>flanneld
</code></pre></div>
<p>注册 kubelet.exe：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell>nssm install kubelet C:\k\kubelet.exe
nssm <span style=color:#a2f>set </span>kubelet AppParameters --hostname-override=&lt;hostname&gt; --v=6 --pod-infra-container-image=k8s.gcr.io/pause<span>:</span>3.5 --resolv-conf=<span style=color:#b44>&#34;&#34;</span> --allow-privileged=true --enable-debugging-handlers --cluster-dns=&lt;<span style=color:#a2f>DNS-service</span>-IP&gt; --cluster-domain=cluster.local --kubeconfig=c:\k\config --hairpin-mode=<span style=color:#a2f>promiscuous-bridge</span> --image-pull-progress-deadline=20m --cgroups-per-qos=false  --log-dir=&lt;log directory&gt; --logtostderr=false --enforce-node-allocatable=<span style=color:#b44>&#34;&#34;</span> --network-plugin=cni --cni-bin-dir=c:\k\cni --cni-conf-dir=c:\k\cni\config
nssm <span style=color:#a2f>set </span>kubelet AppDirectory C:\k
nssm <span style=color:#a2f>start </span>kubelet
</code></pre></div>
<p>注册 kube-proxy.exe（二层网桥模式和主机网关模式）</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell>nssm install <span style=color:#a2f>kube-proxy</span> C:\k\<span style=color:#a2f>kube-proxy</span>.exe
nssm <span style=color:#a2f>set kube-proxy</span> AppDirectory c:\k
nssm <span style=color:#a2f>set kube-proxy</span> AppParameters --v=4 --proxy-mode=kernelspace --hostname-override=&lt;hostname&gt;--kubeconfig=c:\k\config --enable-dsr=false --log-dir=&lt;log directory&gt; --logtostderr=false
nssm.exe <span style=color:#a2f>set kube-proxy</span> AppEnvironmentExtra KUBE_NETWORK=cbr0
nssm <span style=color:#a2f>set kube-proxy</span> DependOnService kubelet
nssm <span style=color:#a2f>start kube-proxy</span>
</code></pre></div>
<p>注册 kube-proxy.exe（覆盖网络模式或 VxLAN 模式）</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell>nssm install <span style=color:#a2f>kube-proxy</span> C:\k\<span style=color:#a2f>kube-proxy</span>.exe
nssm <span style=color:#a2f>set kube-proxy</span> AppDirectory c:\k
nssm <span style=color:#a2f>set kube-proxy</span> AppParameters --v=4 --proxy-mode=kernelspace --feature-gates=<span style=color:#b44>&#34;WinOverlay=true&#34;</span> --hostname-override=&lt;hostname&gt; --kubeconfig=c:\k\config --network-name=vxlan0 --source-vip=&lt;<span style=color:#a2f>source-vip</span>&gt; --enable-dsr=false --log-dir=&lt;log directory&gt; --logtostderr=false
nssm <span style=color:#a2f>set kube-proxy</span> DependOnService kubelet
nssm <span style=color:#a2f>start kube-proxy</span>
</code></pre></div>
<p>作为初始的故障排查操作，你可以使用在 <a href=https://nssm.cc/>nssm.exe</a> 中使用下面的标志
以便将标准输出和标准错误输出重定向到一个输出文件：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell>nssm <span style=color:#a2f>set </span>&lt;服务名称&gt; AppStdout C:\k\mysvc.log
nssm <span style=color:#a2f>set </span>&lt;服务名称&gt; AppStderr C:\k\mysvc.log
</code></pre></div><p>要了解更多的细节，可参见官方的 <a href=https://nssm.cc/usage>nssm 用法</a>文档。</p>
</li>
</ul>
</li>
</ul>
<ul>
<li>
<p>我的 Windows Pods 无发连接网络</p>
<p>如果你在使用虚拟机，请确保 VM 网络适配器均已开启 MAC 侦听（Spoofing）。</p>
</li>
</ul>
<ul>
<li>
<p>我的 Windows Pods 无法 ping 外部资源</p>
<p>Windows Pods 目前没有为 ICMP 协议提供出站规则。不过 TCP/UDP 是支持的。
尝试与集群外资源连接时，可以将 <code>ping &lt;IP></code> 命令替换为对应的 <code>curl &lt;IP></code> 命令。</p>
<p>如果你还遇到问题，很可能你在
<a href=https://github.com/Microsoft/SDN/blob/master/Kubernetes/flannel/l2bridge/cni/config/cni.conf>cni.conf</a>
中的网络配置值得额外的注意。你总是可以编辑这一静态文件。
配置的更新会应用到所有新创建的 Kubernetes 资源上。</p>
<p>Kubernetes 网络的需求之一（参见
<a href=/zh/docs/concepts/cluster-administration/networking/>Kubernetes 网络模型</a>）
是集群内部无需网络地址转译（NAT）即可实现通信。
为了符合这一要求，对所有我们不希望出站时发生 NAT 的通信都存在一个
<a href=https://github.com/Microsoft/SDN/blob/master/Kubernetes/flannel/l2bridge/cni/config/cni.conf#L20>ExceptionList</a>。
然而这也意味着你需要将你要查询的外部 IP 从 ExceptionList 中移除。
只有这时，从你的 Windows Pod 发起的网络请求才会被正确地通过 SNAT 转换以接收到
来自外部世界的响应。
就此而言，你在 <code>cni.conf</code> 中的 <code>ExceptionList</code> 应该看起来像这样：</p>
<pre><code class=language-conf data-lang=conf>&quot;ExceptionList&quot;: [
    &quot;10.244.0.0/16&quot;,  # 集群子网
    &quot;10.96.0.0/12&quot;,   # 服务子网
    &quot;10.127.130.0/24&quot; # 管理（主机）子网
]
</code></pre></li>
</ul>
<ul>
<li>
<p>我的 Windows 节点无法访问 NodePort 服务</p>
<p>从节点自身发起的本地 NodePort 请求会失败。这是一个已知的局限。
NodePort 服务的访问从其他节点或者外部客户端都可正常进行。</p>
</li>
</ul>
<ul>
<li>
<p>容器的 vNICs 和 HNS 端点被删除了</p>
<p>这一问题可能因为 <code>hostname-override</code> 参数未能传递给
<a href=/zh/docs/reference/command-line-tools-reference/kube-proxy/>kube-proxy</a>
而导致。解决这一问题时，用户需要按如下方式将主机名传递给 kube-proxy：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell>C:\k\<span style=color:#a2f>kube-proxy</span>.exe --hostname-override=$(hostname)
</code></pre></div></li>
</ul>
<ul>
<li>
<p>使用 Flannel 时，我的节点在重新加入集群时遇到问题</p>
<p>无论何时，当一个之前被删除的节点被重新添加到集群时，flannelD 都会将为节点分配
一个新的 Pod 子网。
用户需要将将下面路径中的老的 Pod 子网配置文件删除：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=color:#a2f>Remove-Item</span> C:\k\SourceVip.json
<span style=color:#a2f>Remove-Item</span> C:\k\SourceVipRequest.json
</code></pre></div></li>
</ul>
<ul>
<li>
<p>在启动了 <code>start.ps1</code> 之后，flanneld 一直停滞在 "Waiting for the Network
to be created" 状态</p>
<p>关于这一<a href=https://github.com/coreos/flannel/issues/1066>问题</a>有很多的报告；
最可能的一种原因是关于何时设置 Flannel 网络的管理 IP 的时间问题。
一种解决办法是重新启动 <code>start.ps1</code> 或者按如下方式手动重启之：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=color:#800>[Environment]</span>::SetEnvironmentVariable(<span style=color:#b44>&#34;NODE_NAME&#34;</span>, <span style=color:#b44>&#34;&lt;Windows 工作节点主机名&gt;&#34;</span>)
C:\flannel\flanneld.exe --kubeconfig<span style=color:#666>-file</span>=c:\k\config --iface=&lt;Windows 工作节点 IP&gt; --ip-masq=1 --kube-subnet-mgr=1
</code></pre></div></li>
</ul>
<ul>
<li>
<p>我的 Windows Pods 无法启动，因为缺少 <code>/run/flannel/subnet.env</code> 文件</p>
<p>这表明 Flannel 网络未能正确启动。你可以尝试重启 flanneld.exe 或者将文件手动地
从 Kubernetes 主控节点的 <code>/run/flannel/subnet.env</code> 路径复制到 Windows 工作
节点的 <code>C:\run\flannel\subnet.env</code> 路径，并将 <code>FLANNEL_SUBNET</code> 行改为一个
不同的数值。例如，如果期望节点子网为 <code>10.244.4.1/24</code>：</p>
<pre><code class=language-none data-lang=none>FLANNEL_NETWORK=10.244.0.0/16
FLANNEL_SUBNET=10.244.4.1/24
FLANNEL_MTU=1500
FLANNEL_IPMASQ=true
</code></pre></li>
</ul>
<ul>
<li>
<p>我的 Windows 节点无法使用服务 IP 访问我的服务</p>
<p>这是 Windows 上当前网络协议栈的一个已知的限制。
Windows Pods 能够访问服务 IP。</p>
</li>
</ul>
<ul>
<li>
<p>启动 kubelet 时找不到网络适配器</p>
<p>Windows 网络堆栈需要一个虚拟的适配器，这样 Kubernetes 网络才能工作。
如果下面的命令（在管理员 Shell 中）没有任何返回结果，证明虚拟网络创建
（kubelet 正常工作的必要前提之一）失败了：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=color:#a2f>Get-HnsNetwork</span> | ? Name <span style=color:#666>-ieq</span> <span style=color:#b44>&#34;cbr0&#34;</span>
<span style=color:#a2f>Get-NetAdapter</span> | ? Name <span style=color:#666>-Like</span> <span style=color:#b44>&#34;vEthernet (Ethernet*&#34;</span>
</code></pre></div>
<p>当宿主系统的网络适配器名称不是 "Ethernet" 时，通常值得更改 <code>start.ps1</code> 脚本中的
<a href=https://github.com/microsoft/SDN/blob/master/Kubernetes/flannel/start.ps1#L7>InterfaceName</a>
参数来重试。否则可以查验 <code>start-kubelet.ps1</code> 的输出，看看是否在虚拟网络创建
过程中报告了其他错误。</p>
</li>
</ul>
<ul>
<li>
<p>我的 Pods 停滞在 "Container Creating" 状态或者反复重启</p>
<p>检查你的 pause 镜像是与你的 OS 版本兼容的。
<a href=https://docs.microsoft.com/en-us/virtualization/windowscontainers/kubernetes/deploying-resources>这里的指令</a>
假定你的 OS 和容器版本都是 1803。如果你安装的是更新版本的 Windows，比如说
某个 Insider 构造版本，你需要相应地调整要使用的镜像。
请参照 Microsoft 的 <a href=https://hub.docker.com/u/microsoft/>Docker 仓库</a>
了解镜像。不管怎样，pause 镜像的 Dockerfile 和示例服务都期望镜像的标签
为 <code>:latest</code>。</p>
</li>
</ul>
<ul>
<li>
<p>DNS 解析无法正常工作</p>
<p>参阅 Windows 上 <a href=#dns-limitations>DNS 相关的局限</a> 节。</p>
</li>
</ul>
<ul>
<li>
<p><code>kubectl port-forward</code> 失败，错误信息为 "unable to do port forwarding: wincat not found"</p>
<p>此功能是在 Kubernetes v1.15 中实现的，pause 基础设施容器
<code>mcr.microsoft.com/oss/kubernetes/pause:3.4.1</code> 中包含了 wincat.exe。
请确保你使用的是这些版本或者更新版本。
如果你想要自行构造你自己的 pause 基础设施容器，要确保其中包含了
<a href=https://github.com/kubernetes-sigs/sig-windows-tools/tree/master/cmd/wincat>wincat</a></p>
<p>Windows 的端口转发支持需要在 <a href=#pause-image>pause 基础设施容器</a> 中提供 wincat.exe。
确保你使用的是与你的 Windows 操作系统版本兼容的受支持镜像。
如果你想构建自己的 pause 基础架构容器，请确保包含 <a href=https://github.com/kubernetes/kubernetes/tree/master/build/pause/windows/wincat>wincat</a>.。</p>
</li>
</ul>
<ul>
<li>
<p>我的 Kubernetes 安装失败，因为我的 Windows Server 节点在防火墙后面</p>
<p>如果你处于防火墙之后，那么必须定义如下 PowerShell 环境变量：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-PowerShell data-lang=PowerShell><span style=color:#800>[Environment]</span>::SetEnvironmentVariable(<span style=color:#b44>&#34;HTTP_PROXY&#34;</span>, <span style=color:#b44>&#34;http://proxy.example.com:80/&#34;</span>, <span style=color:#800>[EnvironmentVariableTarget]</span>::Machine)
<span style=color:#800>[Environment]</span>::SetEnvironmentVariable(<span style=color:#b44>&#34;HTTPS_PROXY&#34;</span>, <span style=color:#b44>&#34;http://proxy.example.com:443/&#34;</span>, <span style=color:#800>[EnvironmentVariableTarget]</span>::Machine)
</code></pre></div></li>
</ul>
<ul>
<li>
<p><code>pause</code> 容器是什么？</p>
<p>在一个 Kubernetes Pod 中，一个基础设施容器，或称 "pause" 容器，会被首先创建出来，
用以托管容器端点。属于同一 Pod 的容器，包括基础设施容器和工作容器，会共享相同的
网络名字空间和端点（相同的 IP 和端口空间）。我们需要 pause 容器来工作容器崩溃或
重启的状况，以确保不会丢失任何网络配置。</p>
<p>请参阅 <a href=#pause-image>pause 镜像</a> 部分以查找 pause 镜像的推荐版本。</p>
</li>
</ul>
<h3 id=further-investigation>进一步探究 </h3>
<p>如果以上步骤未能解决你遇到的问题，你可以通过以下方式获得在 Kubernetes
中的 Windows 节点上运行 Windows 容器的帮助：</p>
<ul>
<li>StackOverflow <a href=https://stackoverflow.com/questions/tagged/windows-server-container>Windows Server Container</a> 主题</li>
<li>Kubernetes 官方论坛 <a href=https://discuss.kubernetes.io/>discuss.kubernetes.io</a></li>
<li>Kubernetes Slack <a href=https://kubernetes.slack.com/messages/sig-windows>#SIG-Windows 频道</a></li>
</ul>
<h2 id=reporting-issues-and-feature-requests>报告问题和功能需求 </h2>
<p>如果你遇到看起来像是软件缺陷的问题，或者你想要提起某种功能需求，请使用
<a href=https://github.com/kubernetes/kubernetes/issues>GitHub 问题跟踪系统</a>。
你可以在 <a href=https://github.com/kubernetes/kubernetes/issues/new/choose>GitHub</a>
上发起 Issue 并将其指派给 SIG-Windows。你应该首先搜索 Issue 列表，看看是否
该 Issue 以前曾经被报告过，以评论形式将你在该 Issue 上的体验追加进去，并附上
额外的日志信息。SIG-Windows Slack 频道也是一个获得初步支持的好渠道，可以在
生成新的 Ticket 之前对一些想法进行故障分析。</p>
<p>在登记软件缺陷时，请给出如何重现该问题的详细信息，例如：</p>
<ul>
<li>Kubernetes 版本：kubectl 版本</li>
<li>环境细节：云平台、OS 版本、网络选型和配置情况以及 Docker 版本</li>
<li>重现该问题的详细步骤</li>
<li><a href=https://github.com/kubernetes/community/blob/master/sig-windows/CONTRIBUTING.md#gathering-logs>相关的日志</a></li>
<li>通过为该 Issue 添加 <code>/sig windows</code> 评论为其添加 <code>sig/windows</code> 标签，
进而引起 SIG-Windows 成员的注意。</li>
</ul>
<h2 id=what-s-next>What's next</h2>
<p>在我们的未来蓝图中包含很多功能特性（要实现）。下面是一个浓缩的简要列表，不过我们
鼓励你查看我们的 <a href=https://github.com/orgs/kubernetes/projects/8>roadmap 项目</a>并
通过<a href=https://github.com/kubernetes/community/blob/master/sig-windows/>贡献</a>的方式
帮助我们把 Windows 支持做得更好。</p>
<h3 id=hyper-v-isolation>Hyper-V 隔离 </h3>
<p>要满足 Kubernetes 中 Windows 容器的如下用例，需要利用 Hyper-V 隔离：</p>
<ul>
<li>在 Pod 之间实施基于监管程序（Hypervisor）的隔离，以增强安全性</li>
<li>出于向后兼容需要，允许添加运行新 Windows Server 版本的节点时不必
重新创建容器</li>
<li>为 Pod 设置特定的 CPU/NUMA 配置</li>
<li>实施内存隔离与预留</li>
</ul>
<h3 id=deployment-with-kubeadm-and-cluster-api>使用 kubeadm 和 Cluster API 来部署 </h3>
<p>kubeadm 已经成为用户部署 Kubernetes 集群的事实标准。
kubeadm 对 Windows 节点的支持目前还在开发过程中，不过你可以阅读相关的
<a href=/zh/docs/tasks/administer-cluster/kubeadm/adding-windows-nodes/>指南</a>。
我们也在投入资源到 Cluster API，以确保 Windows 节点被正确配置。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-3a51e66c5de55f9093a8dc55742006d3>2 - Kubernetes 中 Windows 容器的调度指南</h1>
<p>Windows 应用程序构成了许多组织中运行的服务和应用程序的很大一部分。
本指南将引导您完成在 Kubernetes 中配置和部署 Windows 容器的步骤。</p>
<h2 id=目标>目标</h2>
<ul>
<li>配置一个示例 deployment 以在 Windows 节点上运行 Windows 容器</li>
<li>（可选）使用组托管服务帐户（GMSA）为您的 Pod 配置 Active Directory 身份</li>
</ul>
<h2 id=在你开始之前>在你开始之前</h2>
<ul>
<li>创建一个 Kubernetes 集群，其中包括一个控制平面和
<a href=/zh/docs/tasks/administer-cluster/kubeadm/adding-windows-nodes/>运行 Windows 服务器的工作节点</a></li>
<li>重要的是要注意，对于 Linux 和 Windows 容器，在 Kubernetes
上创建和部署服务和工作负载的行为几乎相同。
与集群接口的 <a href=/zh/docs/reference/kubectl/overview/>kubectl 命令</a>相同。
提供以下部分中的示例只是为了快速启动 Windows 容器的使用体验。</li>
</ul>
<h2 id=入门-部署-windows-容器>入门：部署 Windows 容器</h2>
<p>要在 Kubernetes 上部署 Windows 容器，您必须首先创建一个示例应用程序。
下面的示例 YAML 文件创建了一个简单的 Web 服务器应用程序。
创建一个名为 <code>win-webserver.yaml</code> 的服务规约，其内容如下：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>win-webserver<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>win-webserver<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># the port that this service should serve on</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>win-webserver<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>NodePort<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>win-webserver<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>win-webserver<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>2</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>win-webserver<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>win-webserver<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>win-webserver<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>windowswebserver<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>mcr.microsoft.com/windows/servercore:ltsc2019<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- powershell.exe<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- -command<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:#b44>&#34;&lt;#code used from https://gist.github.com/19WAS85/5424431#&gt; ; $$listener = New-Object System.Net.HttpListener ; $$listener.Prefixes.Add(&#39;http://*:80/&#39;) ; $$listener.Start() ; $$callerCounts = @{} ; Write-Host(&#39;Listening at http://*:80/&#39;) ; while ($$listener.IsListening) { ;$$context = $$listener.GetContext() ;$$requestUrl = $$context.Request.Url ;$$clientIP = $$context.Request.RemoteEndPoint.Address ;$$response = $$context.Response ;Write-Host &#39;&#39; ;Write-Host(&#39;&gt; {0}&#39; -f $$requestUrl) ;  ;$$count = 1 ;$$k=$$callerCounts.Get_Item($$clientIP) ;if ($$k -ne $$null) { $$count += $$k } ;$$callerCounts.Set_Item($$clientIP, $$count) ;$$ip=(Get-NetAdapter | Get-NetIpAddress); $$header=&#39;&lt;html&gt;&lt;body&gt;&lt;H1&gt;Windows Container Web Server&lt;/H1&gt;&#39; ;$$callerCountsString=&#39;&#39; ;$$callerCounts.Keys | % { $$callerCountsString+=&#39;&lt;p&gt;IP {0} callerCount {1} &#39; -f $$ip[1].IPAddress,$$callerCounts.Item($$_) } ;$$footer=&#39;&lt;/body&gt;&lt;/html&gt;&#39; ;$$content=&#39;{0}{1}{2}&#39; -f $$header,$$callerCountsString,$$footer ;Write-Output $$content ;$$buffer = [System.Text.Encoding]::UTF8.GetBytes($$content) ;$$response.ContentLength64 = $$buffer.Length ;$$response.OutputStream.Write($$buffer, 0, $$buffer.Length) ;$$response.Close() ;$$responseStatus = $$response.StatusCode ;Write-Host(&#39;&lt; {0}&#39; -f $$responseStatus)  } ; &#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>nodeSelector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>kubernetes.io/os</span>:<span style=color:#bbb> </span>windows<span style=color:#bbb>
</span></code></pre></div>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 端口映射也是支持的，但为简单起见，在此示例中容器端口 80 直接暴露给服务。
</div>
<ol>
<li>
<p>检查所有节点是否健康：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl get nodes
</code></pre></div></li>
<li>
<p>部署服务并观察 pod 更新：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl apply -f win-webserver.yaml
kubectl get pods -o wide -w
</code></pre></div><p>正确部署服务后，两个 Pod 都标记为“Ready”。要退出 watch 命令，请按 Ctrl + C。</p>
</li>
<li>
<p>检查部署是否成功。验证：</p>
<ul>
<li>Windows 节点上每个 Pod 有两个容器，使用 <code>docker ps</code></li>
<li>Linux 控制平面节点列出两个 Pod，使用 <code>kubectl get pods</code></li>
<li>跨网络的节点到 Pod 通信，从 Linux 控制平面节点 <code>curl</code> 您的 pod IPs 的端口80，以检查 Web 服务器响应</li>
<li>Pod 到 Pod 的通信，使用 docker exec 或 kubectl exec 在 Pod 之间
（以及跨主机，如果你有多个 Windows 节点）进行 ping 操作</li>
<li>服务到 Pod 的通信，从 Linux 控制平面节点和各个 Pod 中 <code>curl</code> 虚拟服务 IP
（在 <code>kubectl get services</code> 下可见）</li>
<li>服务发现，使用 Kubernetes <code>curl</code> 服务名称
<a href=/zh/docs/concepts/services-networking/dns-pod-service/#services>默认 DNS 后缀</a></li>
<li>入站连接，从 Linux 控制平面节点或集群外部的计算机 <code>curl</code> NodePort</li>
<li>出站连接，使用 kubectl exec 从 Pod 内部 curl 外部 IP</li>
</ul>
</li>
</ol>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 由于当前平台对 Windows 网络堆栈的限制，Windows 容器主机无法访问在其上调度的服务的 IP。只有 Windows pods 才能访问服务 IP。
</div>
<h2 id=observability>可观测性 </h2>
<h3 id=抓取来自工作负载的日志>抓取来自工作负载的日志</h3>
<p>日志是可观测性的重要一环；使用日志用户可以获得对负载运行状况的洞察，
因而日志是故障排查的一个重要手法。
因为 Windows 容器中的 Windows 容器和负载与 Linux 容器的行为不同，
用户很难收集日志，因此运行状态的可见性很受限。
例如，Windows 工作负载通常被配置为将日志输出到 Windows 事件跟踪
（Event Tracing for Windows，ETW），或者将日志条目推送到应用的事件日志中。
<a href=https://github.com/microsoft/windows-container-tools/tree/master/LogMonitor>LogMonitor</a>
是 Microsoft 提供的一个开源工具，是监视 Windows 容器中所配置的日志源
的推荐方式。
LogMonitor 支持监视时间日志、ETW 提供者模块以及自定义的应用日志，
并使用管道的方式将其输出到标准输出（stdout），以便 <code>kubectl logs &lt;pod></code>
这类命令能够读取这些数据。</p>
<p>请遵照 LogMonitor GitHub 页面上的指令，将其可执行文件和配置文件复制到
你的所有容器中，并为其添加必要的入口点（Entrypoint），以便 LogMonitor
能够将你的日志输出推送到标准输出（stdout）。</p>
<h2 id=使用可配置的容器用户名>使用可配置的容器用户名</h2>
<p>从 Kubernetes v1.16 开始，可以为 Windows 容器配置与其镜像默认值不同的用户名
来运行其入口点和进程。
此能力的实现方式和 Linux 容器有些不同。
在<a href=/zh/docs/tasks/configure-pod-container/configure-runasusername/>此处</a>
可了解更多信息。</p>
<h2 id=使用组托管服务帐户管理工作负载身份>使用组托管服务帐户管理工作负载身份</h2>
<p>从 Kubernetes v1.14 开始，可以将 Windows 容器工作负载配置为使用组托管服务帐户（GMSA）。
组托管服务帐户是 Active Directory 帐户的一种特定类型，它提供自动密码管理，
简化的服务主体名称（SPN）管理以及将管理委派给跨多台服务器的其他管理员的功能。
配置了 GMSA 的容器可以访问外部 Active Directory 域资源，同时携带通过 GMSA 配置的身份。
在<a href=/zh/docs/tasks/configure-pod-container/configure-gmsa/>此处</a>了解有关为
Windows 容器配置和使用 GMSA 的更多信息。</p>
<h2 id=污点和容忍度>污点和容忍度</h2>
<p>目前，用户需要将 Linux 和 Windows 工作负载运行在各自特定的操作系统的节点上，
因而需要结合使用污点和节点选择算符。 这可能仅给 Windows 用户造成不便。
推荐的方法概述如下，其主要目标之一是该方法不应破坏与现有 Linux 工作负载的兼容性。</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> <p>如果 <code>IdentifyPodOS</code> <a href=/zh/docs/reference/command-line-tools-reference/feature-gates/>特性门控</a>是启用的，
你可以（并且应该）为 Pod 设置 <code>.spec.os.name</code> 以表明该 Pod
中的容器所针对的操作系统。 对于运行 Linux 容器的 Pod，设置
<code>.spec.os.name</code> 为 <code>linux</code>。 对于运行 Windows 容器的 Pod，设置 <code>.spec.os.name</code>
为 <code>Windows</code>。</p>
<p>在将 Pod 分配给节点时，调度程序不使用 <code>.spec.os.name</code> 的值。你应该使用正常的 Kubernetes
机制<a href=/zh/docs/concepts/scheduling-eviction/assign-pod-node/>将 Pod 分配给节点</a>，
确保集群的控制平面将 Pod 放置到适合运行的操作系统。
对 Windows Pod 的调度没有影响，因此仍然需要污点、容忍度以及节点选择器，
以确保 Windows Pod 调度至合适的 Windows 节点。</p>
</div>
<h3 id=确保特定操作系统的工作负载落在适当的容器主机上>确保特定操作系统的工作负载落在适当的容器主机上</h3>
<p>用户可以使用污点和容忍度确保 Windows 容器可以调度在适当的主机上。目前所有 Kubernetes 节点都具有以下默认标签：</p>
<ul>
<li>kubernetes.io/os = [windows|linux]</li>
<li>kubernetes.io/arch = [amd64|arm64|...]</li>
</ul>
<p>如果 Pod 规范未指定诸如 <code>"kubernetes.io/os": windows</code> 之类的 nodeSelector，则该 Pod
可能会被调度到任何主机（Windows 或 Linux）上。
这是有问题的，因为 Windows 容器只能在 Windows 上运行，而 Linux 容器只能在 Linux 上运行。
最佳实践是使用 nodeSelector。</p>
<p>但是，我们了解到，在许多情况下，用户都有既存的大量的 Linux 容器部署，以及一个现成的配置生态系统，
例如社区 Helm charts，以及程序化 Pod 生成案例，例如 Operators。
在这些情况下，您可能会不愿意更改配置添加 nodeSelector。替代方法是使用污点。
由于 kubelet 可以在注册期间设置污点，因此可以轻松修改它，使其仅在 Windows 上运行时自动添加污点。</p>
<p>例如：<code>--register-with-taints='os=windows:NoSchedule'</code></p>
<p>向所有 Windows 节点添加污点后，Kubernetes 将不会在它们上调度任何负载（包括现有的 Linux Pod）。
为了使某 Windows Pod 调度到 Windows 节点上，该 Pod 需要 nodeSelector 和合适的匹配的容忍度设置来选择 Windows，</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>nodeSelector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>kubernetes.io/os</span>:<span style=color:#bbb> </span>windows<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>node.kubernetes.io/windows-build</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;10.0.17763&#39;</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>tolerations</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;os&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;Equal&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;windows&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>effect</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;NoSchedule&#34;</span><span style=color:#bbb>
</span></code></pre></div>
<h3 id=处理同一集群中的多个-windows-版本>处理同一集群中的多个 Windows 版本</h3>
<p>每个 Pod 使用的 Windows Server 版本必须与该节点的 Windows Server 版本相匹配。
如果要在同一集群中使用多个 Windows Server 版本，则应该设置其他节点标签和
nodeSelector。</p>
<p>Kubernetes 1.17 自动添加了一个新标签 <code>node.kubernetes.io/windows-build</code> 来简化此操作。
如果您运行的是旧版本，则建议手动将此标签添加到 Windows 节点。</p>
<p>此标签反映了需要兼容的 Windows 主要、次要和内部版本号。以下是当前每个
Windows Server 版本使用的值。</p>
<table>
<thead>
<tr>
<th>产品名称</th>
<th>内部编号</th>
</tr>
</thead>
<tbody>
<tr>
<td>Windows Server 2019</td>
<td>10.0.17763</td>
</tr>
<tr>
<td>Windows Server version 1809</td>
<td>10.0.17763</td>
</tr>
<tr>
<td>Windows Server version 1903</td>
<td>10.0.18362</td>
</tr>
</tbody>
</table>
<h3 id=使用-runtimeclass-简化>使用 RuntimeClass 简化</h3>
<p><a href=/zh/docs/concepts/containers/runtime-class/>RuntimeClass</a> 可用于
简化使用污点和容忍度的过程。
集群管理员可以创建 <code>RuntimeClass</code> 对象，用于封装这些污点和容忍度。</p>
<ol>
<li>
<p>将此文件保存到 <code>runtimeClasses.yml</code> 文件。
它包括适用于 Windows 操作系统、体系结构和版本的 <code>nodeSelector</code>。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>node.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>RuntimeClass<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>windows-2019<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>handler</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;docker&#39;</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>scheduling</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>nodeSelector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubernetes.io/os</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;windows&#39;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubernetes.io/arch</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;amd64&#39;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>node.kubernetes.io/windows-build</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;10.0.17763&#39;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>tolerations</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>effect</span>:<span style=color:#bbb> </span>NoSchedule<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>os<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span>Equal<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;windows&#34;</span><span style=color:#bbb>
</span></code></pre></div></li>
</ol>
<ol start=2>
<li>集群管理员执行 <code>kubectl create -f runtimeClasses.yml</code> 操作</li>
<li>根据需要向 Pod 规约中添加 <code>runtimeClassName: windows-2019</code></li>
</ol>
<p>例如：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>iis-2019<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>iis-2019<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>iis-2019<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>iis-2019<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>runtimeClassName</span>:<span style=color:#bbb> </span>windows-2019<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>iis<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>mcr.microsoft.com/windows/servercore/iis:windowsservercore-ltsc2019<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>800Mi<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span>.1<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>300Mi<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>iis-2019<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>iis<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>LoadBalancer<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>iis-2019<span style=color:#bbb>
</span></code></pre></div>
</div>
</main>
</div>
</div>
<footer class=d-print-none>
<div class=footer__links>
<nav>
<a class=text-white href=/zh/docs/home/>主页</a>
<a class=text-white href=/zh/blog/>博客</a>
<a class=text-white href=/zh/training/>培训</a>
<a class=text-white href=/zh/partners/>合作伙伴</a>
<a class=text-white href=/zh/community/>社区</a>
<a class=text-white href=/zh/case-studies/>案例分析</a>
</nav>
</div>
<div class=container-fluid>
<div class=row>
<div class="col-6 col-sm-2 text-xs-center order-sm-2">
<ul class="list-inline mb-0">
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="User mailing list" aria-label="User mailing list">
<a class=text-white target=_blank href=https://discuss.kubernetes.io>
<i class="fa fa-envelope"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Twitter aria-label=Twitter>
<a class=text-white target=_blank href=https://twitter.com/kubernetesio>
<i class="fab fa-twitter"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Calendar aria-label=Calendar>
<a class=text-white target=_blank href="https://calendar.google.com/calendar/embed?src=calendar%40kubernetes.io">
<i class="fas fa-calendar-alt"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Youtube aria-label=Youtube>
<a class=text-white target=_blank href=https://youtube.com/kubernetescommunity>
<i class="fab fa-youtube"></i>
</a>
</li>
</ul>
</div>
<div class="col-6 col-sm-2 text-right text-xs-center order-sm-3">
<ul class="list-inline mb-0">
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub>
<a class=text-white target=_blank href=https://github.com/kubernetes/kubernetes>
<i class="fab fa-github"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Slack aria-label=Slack>
<a class=text-white target=_blank href=https://slack.k8s.io>
<i class="fab fa-slack"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Contribute aria-label=Contribute>
<a class=text-white target=_blank href=https://git.k8s.io/community/contributors/guide>
<i class="fas fa-edit"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Stack Overflow" aria-label="Stack Overflow">
<a class=text-white target=_blank href=https://stackoverflow.com/questions/tagged/kubernetes>
<i class="fab fa-stack-overflow"></i>
</a>
</li>
</ul>
</div>
<div class="col-12 col-sm-8 text-center order-sm-2">
<small class=text-white>&copy; 2023 The Kubernetes Authors | Documentation Distributed under <a href=https://git.k8s.io/website/LICENSE class=light-text>CC BY 4.0</a></small>
<br>
<small class=text-white>Copyright &copy; 2023 The Linux Foundation &reg;. All rights reserved. The Linux Foundation has registered trademarks and uses trademarks. For a list of trademarks of The Linux Foundation, please see our <a href=https://www.linuxfoundation.org/trademark-usage class=light-text>Trademark Usage page</a></small>
<br>
<small class=text-white>ICP license: 京ICP备17074266号-3</small>
</div>
</div>
</div>
</footer>
</div>
<script src=/js/popper-1.14.3.min.js integrity=sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49 crossorigin=anonymous></script>
<script src=/js/bootstrap-4.3.1.min.js integrity=sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM crossorigin=anonymous></script>
<script src=/js/main.min.40616251a9b6e4b689e7769be0340661efa4d7ebb73f957404e963e135b4ed52.js integrity="sha256-QGFiUam25LaJ53ab4DQGYe+k1+u3P5V0BOlj4TW07VI=" crossorigin=anonymous></script>
</body>
</html>