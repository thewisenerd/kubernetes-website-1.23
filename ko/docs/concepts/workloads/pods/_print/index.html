<!doctype html><html lang=ko class=no-js>
<head>
<meta name=ROBOTS content="NOINDEX, NOFOLLOW">
<script async src="https://www.googletagmanager.com/gtag/js?id=G-JPP6RFM2BP"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-JPP6RFM2BP')</script>
<link rel=alternate hreflang=en href=https://kubernetes.io/docs/concepts/workloads/pods/>
<link rel=alternate hreflang=zh href=https://kubernetes.io/zh/docs/concepts/workloads/pods/>
<link rel=alternate hreflang=ja href=https://kubernetes.io/ja/docs/concepts/workloads/pods/>
<link rel=alternate hreflang=fr href=https://kubernetes.io/fr/docs/concepts/workloads/pods/>
<link rel=alternate hreflang=de href=https://kubernetes.io/de/docs/concepts/workloads/pods/>
<link rel=alternate hreflang=es href=https://kubernetes.io/es/docs/concepts/workloads/pods/>
<link rel=alternate hreflang=id href=https://kubernetes.io/id/docs/concepts/workloads/pods/>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=generator content="Hugo 0.87.0">
<link rel=canonical type=text/html href=https://kubernetes.io/ko/docs/concepts/workloads/pods/>
<link rel="shortcut icon" type=image/png href=/images/favicon.png>
<link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180>
<link rel=manifest href=/manifest.webmanifest>
<link rel=apple-touch-icon href=/images/kubernetes-192x192.png>
<title>파드 | Kubernetes</title><meta property="og:title" content="파드">
<meta property="og:description" content="운영 수준의 컨테이너 오케스트레이션">
<meta property="og:type" content="website">
<meta property="og:url" content="https://kubernetes.io/ko/docs/concepts/workloads/pods/"><meta property="og:site_name" content="Kubernetes">
<meta itemprop=name content="파드">
<meta itemprop=description content="운영 수준의 컨테이너 오케스트레이션"><meta name=twitter:card content="summary">
<meta name=twitter:title content="파드">
<meta name=twitter:description content="운영 수준의 컨테이너 오케스트레이션">
<link href=/scss/main.css rel=stylesheet>
<script src=/js/jquery-3.3.1.min.js integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin=anonymous></script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","url":"https://kubernetes.io","logo":"https://kubernetes.io/images/favicon.png"}</script>
<meta name=theme-color content="#326ce5">
<link rel=stylesheet href=/css/feature-states.css>
<meta name=description content="파드(Pod) 는 쿠버네티스에서 생성하고 관리할 수 있는 배포 가능한 가장 작은 컴퓨팅 단위이다.
파드 (고래 떼(pod of whales)나 콩꼬투리(pea pod)와 마찬가지로)는 하나 이상의 컨테이너의 그룹이다. 이 그룹은 스토리지 및 네트워크를 공유하고, 해당 컨테이너를 구동하는 방식에 대한 명세를 갖는다. 파드의 콘텐츠는 항상 함께 배치되고, 함께 스케줄되며, 공유 콘텍스트에서 실행된다. 파드는 애플리케이션 별 &#34;논리 호스트&#34;를 모델링한다. 여기에는 상대적으로 밀접하게 결합된 하나 이상의 애플리케이션 컨테이너가 포함된다. 클라우드가 아닌 콘텍스트에서, 동일한 물리 또는 가상 머신에서 실행되는 애플리케이션은 동일한 논리 호스트에서 실행되는 클라우드 애플리케이션과 비슷하다.">
<meta property="og:description" content="파드(Pod) 는 쿠버네티스에서 생성하고 관리할 수 있는 배포 가능한 가장 작은 컴퓨팅 단위이다.
파드 (고래 떼(pod of whales)나 콩꼬투리(pea pod)와 마찬가지로)는 하나 이상의 컨테이너의 그룹이다. 이 그룹은 스토리지 및 네트워크를 공유하고, 해당 컨테이너를 구동하는 방식에 대한 명세를 갖는다. 파드의 콘텐츠는 항상 함께 배치되고, 함께 스케줄되며, 공유 콘텍스트에서 실행된다. 파드는 애플리케이션 별 &#34;논리 호스트&#34;를 모델링한다. 여기에는 상대적으로 밀접하게 결합된 하나 이상의 애플리케이션 컨테이너가 포함된다. 클라우드가 아닌 콘텍스트에서, 동일한 물리 또는 가상 머신에서 실행되는 애플리케이션은 동일한 논리 호스트에서 실행되는 클라우드 애플리케이션과 비슷하다.">
<meta name=twitter:description content="파드(Pod) 는 쿠버네티스에서 생성하고 관리할 수 있는 배포 가능한 가장 작은 컴퓨팅 단위이다.
파드 (고래 떼(pod of whales)나 콩꼬투리(pea pod)와 마찬가지로)는 하나 이상의 컨테이너의 그룹이다. 이 그룹은 스토리지 및 네트워크를 공유하고, 해당 컨테이너를 구동하는 방식에 대한 명세를 갖는다. 파드의 콘텐츠는 항상 함께 배치되고, 함께 스케줄되며, 공유 콘텍스트에서 실행된다. 파드는 애플리케이션 별 &#34;논리 호스트&#34;를 모델링한다. 여기에는 상대적으로 밀접하게 결합된 하나 이상의 애플리케이션 컨테이너가 포함된다. 클라우드가 아닌 콘텍스트에서, 동일한 물리 또는 가상 머신에서 실행되는 애플리케이션은 동일한 논리 호스트에서 실행되는 클라우드 애플리케이션과 비슷하다.">
<meta property="og:url" content="https://kubernetes.io/ko/docs/concepts/workloads/pods/">
<meta property="og:title" content="파드">
<meta name=twitter:title content="파드">
<meta name=twitter:image content="https://kubernetes.io/images/favicon.png">
<meta name=twitter:image:alt content="Kubernetes">
<meta property="og:image" content="/images/kubernetes-horizontal-color.png">
<meta property="og:type" content="article">
<script src=/js/script.js></script>
</head>
<body class=td-section>
<header>
<nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar" data-auto-burger=primary>
<a class=navbar-brand href=/ko/></a>
<div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar>
<ul class="navbar-nav mt-2 mt-lg-0">
<li class="nav-item mr-2 mb-lg-0">
<a class="nav-link active" href=/ko/docs/>문서</a>
</li>
<li class="nav-item mr-2 mb-lg-0">
<a class=nav-link href=/ko/blog/>쿠버네티스 블로그</a>
</li>
<li class="nav-item mr-2 mb-lg-0">
<a class=nav-link href=/ko/training/>교육</a>
</li>
<li class="nav-item mr-2 mb-lg-0">
<a class=nav-link href=/ko/partners/>파트너</a>
</li>
<li class="nav-item mr-2 mb-lg-0">
<a class=nav-link href=/ko/community/>커뮤니티</a>
</li>
<li class="nav-item mr-2 mb-lg-0">
<a class=nav-link href=/ko/case-studies/>사례 연구</a>
</li>
<li class="nav-item dropdown">
<a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>
버전
</a>
<div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink>
<a class=dropdown-item href=/releases>Release Information</a>
<a class=dropdown-item href=https://kubernetes.io/ko/docs/concepts/workloads/pods/>v1.27</a>
<a class=dropdown-item href=https://v1-26.docs.kubernetes.io/ko/docs/concepts/workloads/pods/>v1.26</a>
<a class=dropdown-item href=https://v1-25.docs.kubernetes.io/ko/docs/concepts/workloads/pods/>v1.25</a>
<a class=dropdown-item href=https://v1-24.docs.kubernetes.io/ko/docs/concepts/workloads/pods/>v1.24</a>
<a class=dropdown-item href=https://v1-23.docs.kubernetes.io/ko/docs/concepts/workloads/pods/>v1.23</a>
</div>
</li>
<li class="nav-item dropdown">
<a class="nav-link dropdown-toggle" href=# id=navbarDropdownMenuLink role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>
한국어 Korean
</a>
<div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink>
<a class=dropdown-item href=/docs/concepts/workloads/pods/>English</a>
<a class=dropdown-item href=/zh/docs/concepts/workloads/pods/>中文 Chinese</a>
<a class=dropdown-item href=/ja/docs/concepts/workloads/pods/>日本語 Japanese</a>
<a class=dropdown-item href=/fr/docs/concepts/workloads/pods/>Français</a>
<a class=dropdown-item href=/de/docs/concepts/workloads/pods/>Deutsch</a>
<a class=dropdown-item href=/es/docs/concepts/workloads/pods/>Español</a>
<a class=dropdown-item href=/id/docs/concepts/workloads/pods/>Bahasa Indonesia</a>
</div>
</li>
</ul>
</div>
<button id=hamburger onclick=kub.toggleMenu() data-auto-burger-exclude><div></div></button>
</nav>
</header>
<div class="container-fluid td-outer">
<div class=td-main>
<div class="row flex-xl-nowrap">
<main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main>
<div class=td-content>
<div class="pageinfo pageinfo-primary d-print-none">
<p>
이 섹션의 다중 페이지 출력 화면임.
<a href=# onclick="return print(),!1">여기를 클릭하여 프린트</a>.
</p><p>
<a href=/ko/docs/concepts/workloads/pods/>이 페이지의 일반 화면으로 돌아가기</a>.
</p>
</div>
<h1 class=title>파드</h1>
<ul>
<li>1: <a href=#pg-c3c2b9cf30915ec9d46c147201da3332>파드 라이프사이클</a></li>
<li>2: <a href=#pg-1ccbd4eeded6ab138d98b59175bd557e>초기화 컨테이너</a></li>
<li>3: <a href=#pg-c8d62295ca703fdcef1aaf89fb4c916a>파드 토폴로지 분배 제약 조건</a></li>
<li>4: <a href=#pg-4aaf43c715cd764bc8ed4436f3537e68>중단(disruption)</a></li>
<li>5: <a href=#pg-53a1005011e1bda2ce81819aad7c8b32>임시(Ephemeral) 컨테이너</a></li>
</ul>
<div class=content>
<p><em>파드(Pod)</em> 는 쿠버네티스에서 생성하고 관리할 수 있는 배포 가능한 가장 작은 컴퓨팅 단위이다.</p>
<p><em>파드</em> (고래 떼(pod of whales)나 콩꼬투리(pea pod)와 마찬가지로)는 하나 이상의
<a href=/ko/docs/concepts/containers/>컨테이너</a>의 그룹이다. 이 그룹은 스토리지 및 네트워크를 공유하고, 해당 컨테이너를 구동하는 방식에 대한 명세를 갖는다. 파드의 콘텐츠는 항상 함께 배치되고,
함께 스케줄되며, 공유 콘텍스트에서 실행된다. 파드는
애플리케이션 별 "논리 호스트"를 모델링한다. 여기에는 상대적으로 밀접하게 결합된 하나 이상의
애플리케이션 컨테이너가 포함된다.
클라우드가 아닌 콘텍스트에서, 동일한 물리 또는 가상 머신에서 실행되는 애플리케이션은 동일한 논리 호스트에서 실행되는 클라우드 애플리케이션과 비슷하다.</p>
<p>애플리케이션 컨테이너와 마찬가지로, 파드에는
파드 시작 중에 실행되는 <a href=/ko/docs/concepts/workloads/pods/init-containers/>초기화 컨테이너</a>가
포함될 수 있다. 클러스터가 제공하는 경우, 디버깅을 위해
<a href=/ko/docs/concepts/workloads/pods/ephemeral-containers/>임시 컨테이너</a>를
삽입할 수도 있다.</p>
<h2 id=파드란-무엇인가>파드란 무엇인가?</h2>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> <a href=https://www.docker.com/>도커</a>가 가장 일반적으로 잘 알려진
<a class=glossary-tooltip title="컨테이너 런타임은 컨테이너 실행을 담당하는 소프트웨어이다." data-toggle=tooltip data-placement=top href=/ko/docs/setup/production-environment/container-runtimes/ target=_blank aria-label="컨테이너 런타임">컨테이너 런타임</a>이지만,
쿠버네티스는 도커 외에도 다양한 컨테이너 런타임을 지원하며,
파드를 설명할 때 도커 관련 용어를 사용하면 더 쉽게 설명할 수 있다.
</div>
<p>파드의 공유 콘텍스트는 리눅스 네임스페이스, 컨트롤 그룹(cgroup) 및
도커 컨테이너를 격리하는 것과 같이 잠재적으로 다른 격리 요소들이다.
파드의 콘텍스트 내에서 개별 애플리케이션은
추가적으로 하위 격리가 적용된다.</p>
<p>도커 개념 측면에서, 파드는 공유 네임스페이스와 공유 파일시스템 볼륨이
있는 도커 컨테이너 그룹과 비슷하다.</p>
<h2 id=파드의-사용>파드의 사용</h2>
<p>다음은 <code>nginx:1.14.2</code> 이미지를 실행하는 컨테이너로 구성되는 파드의 예시이다.</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/ko/examples/pods/simple-pod.yaml download=pods/simple-pod.yaml><code>pods/simple-pod.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-simple-pod-yaml')" title="Copy pods/simple-pod.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-simple-pod-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.14.2<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>위에서 설명한 파드를 생성하려면, 다음 명령을 실행한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/pods/simple-pod.yaml
</code></pre></div><p>일반적으로 파드는 직접 생성하지는 않으며, 대신 워크로드 리소스를 사용하여 생성한다.
<a href=#%ED%8C%8C%EB%93%9C-%EC%9E%91%EC%97%85>파드 작업</a> 섹션에서 파드와 워크로드 리소스의 관계에 대한
더 많은 정보를 확인한다.</p>
<h3 id=workload-resources-for-managing-pods>Workload resources for managing pods</h3>
<p>일반적으로 싱글톤(singleton) 파드를 포함하여 파드를 직접 만들 필요가 없다. 대신, <a class=glossary-tooltip title="클러스터에서 복제된 애플리케이션을 관리한다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/controllers/deployment/ target=_blank aria-label=디플로이먼트(Deployment)>디플로이먼트(Deployment)</a> 또는 <a class=glossary-tooltip title="완료를 목표로 실행되는 유한 또는 배치 작업." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/controllers/job/ target=_blank aria-label=잡(Job)>잡(Job)</a>과 같은 워크로드 리소스를 사용하여 생성한다.
파드가 상태를 추적해야 한다면,
<a class=glossary-tooltip title="내구성이 있는 스토리지와 파드별로 지속성 식별자를 사용해서 파드 집합의 디플로이먼트와 스케일링을 관리한다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/controllers/statefulset/ target=_blank aria-label=스테이트풀셋(StatefulSet)>스테이트풀셋(StatefulSet)</a> 리소스를 고려한다.</p>
<p>쿠버네티스 클러스터의 파드는 두 가지 주요 방식으로 사용된다.</p>
<ul>
<li>
<p><strong>단일 컨테이너를 실행하는 파드</strong>. "파드 당 하나의 컨테이너" 모델은
가장 일반적인 쿠버네티스 유스케이스이다. 이 경우, 파드를 단일 컨테이너를 둘러싼
래퍼(wrapper)로 생각할 수 있다. 쿠버네티스는 컨테이너를 직접 관리하는 대신
파드를 관리한다.</p>
</li>
<li>
<p><strong>함께 작동해야 하는 여러 컨테이너를 실행하는 파드</strong>. 파드는
밀접하게 결합되어 있고 리소스를 공유해야 하는 함께 배치된 여러 개의 컨테이너로
구성된 애플리케이션을 캡슐화할 수 있다. 이런 함께 배치된 컨테이너는
하나의 결합된 서비스 단위를 형성한다. 예를 들어, 하나의 컨테이너는 공유 볼륨에
저장된 데이터를 퍼블릭에 제공하는 반면, 별도의 <em>사이드카</em> 컨테이너는
해당 파일을 새로 고치거나 업데이트한다.
파드는 이러한 컨테이너, 스토리지 리소스, 임시 네트워크 ID를
단일 단위로 함께 래핑한다.</p>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> 단일 파드에서 함께 배치된 또는 함께 관리되는 여러 컨테이너를 그룹화하는 것은
비교적 고급 유스케이스이다. 이 패턴은 컨테이너가 밀접하게 결합된
특정 인스턴스에서만 사용해야 한다.
</div>
</li>
</ul>
<p>각 파드는 특정 애플리케이션의 단일 인스턴스를 실행하기 위한 것이다. 더 많은
인스턴스를 실행하여 더 많은 전체 리소스를 제공하기 위해 애플리케이션을
수평적으로 확장하려면, 각 인스턴스에 하나씩, 여러 파드를 사용해야 한다.
쿠버네티스에서는 이를 일반적으로 <em>레플리케이션</em> 이라고 한다.
복제된 파드는 일반적으로 워크로드 리소스와
해당 <a class=glossary-tooltip title="API 서버를 통해 클러스터의 공유된 상태를 감시하고, 현재 상태를 원하는 상태로 이행시키는 컨트롤 루프." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/architecture/controller/ target=_blank aria-label=컨트롤러>컨트롤러</a>에 의해 그룹으로 생성되고 관리된다.</p>
<p>쿠버네티스가 워크로드 리소스와 해당 컨트롤러를 사용하여 애플리케이션 스케일링과
자동 복구를 구현하는 방법에 대한 자세한 내용은
<a href=#%ED%8C%8C%EB%93%9C%EC%99%80-%EC%BB%A8%ED%8A%B8%EB%A1%A4%EB%9F%AC>파드와 컨트롤러</a>를 참고한다.</p>
<h3 id=파드가-여러-컨테이너를-관리하는-방법>파드가 여러 컨테이너를 관리하는 방법</h3>
<p>파드는 응집력있는 서비스 단위를 형성하는 여러 협력 프로세스(컨테이너)를
지원하도록 설계되었다. 파드의 컨테이너는 클러스터의 동일한 물리 또는 가상 머신에서
자동으로 같은 위치에 배치되고 함께 스케줄된다. 컨테이너는
리소스와 의존성을 공유하고, 서로 통신하고, 종료 시기와 방법을
조정할 수 있다.</p>
<p>예를 들어, 다음 다이어그램에서와 같이
공유 볼륨의 파일에 대한 웹 서버 역할을 하는 컨테이너와, 원격 소스에서 해당 파일을 업데이트하는
별도의 "사이드카" 컨테이너가 있을 수 있다.</p>
<figure class=diagram-medium>
<img src=/images/docs/pod.svg alt="파드 생성 다이어그램">
</figure>
<p>일부 파드에는 <a class=glossary-tooltip title="워크로드의 일부를 실행하는데 사용되는 컨테이너. 초기화 컨테이너와 비교된다." data-toggle=tooltip data-placement=top href="/ko/docs/reference/glossary/?all=true#term-app-container" target=_blank aria-label="앱 컨테이너">앱 컨테이너</a> 뿐만 아니라 <a class=glossary-tooltip title="앱 컨테이너가 동작하기 전에 완료되기 위해 실행되는 하나 이상의 초기화 컨테이너." data-toggle=tooltip data-placement=top href="/ko/docs/reference/glossary/?all=true#term-init-container" target=_blank aria-label="초기화 컨테이너">초기화 컨테이너</a>를 갖고 있다. 초기화 컨테이너는 앱 컨테이너가 시작되기 전에 실행되고 완료된다.</p>
<p>파드는 기본적으로 파드에 속한 컨테이너에 <a href=#%ED%8C%8C%EB%93%9C-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%82%B9>네트워킹</a>과 <a href=#pod-storage>스토리지</a>라는
두 가지 종류의 공유 리소스를 제공한다.</p>
<h2 id=파드-작업>파드 작업</h2>
<p>사용자가 쿠버네티스에서 직접 개별 파드를 만드는 경우는 거의 없다. 싱글톤 파드도 마찬가지이다. 이는
파드가 상대적으로 일시적인, 일회용 엔티티로 설계되었기 때문이다. 파드가
생성될 때(사용자가 직접 또는
<a class=glossary-tooltip title="API 서버를 통해 클러스터의 공유된 상태를 감시하고, 현재 상태를 원하는 상태로 이행시키는 컨트롤 루프." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/architecture/controller/ target=_blank aria-label=컨트롤러>컨트롤러</a>가 간접적으로), 새 파드는
클러스터의 <a class=glossary-tooltip title="노드는 쿠버네티스의 작업 장비(worker machine)이다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/architecture/nodes/ target=_blank aria-label=노드>노드</a>에서 실행되도록 스케줄된다.
파드는 파드 실행이 완료되거나, 파드 오브젝트가 삭제되거나,
리소스 부족으로 인해 파드가 <em>축출</em> 되거나, 노드가 실패할 때까지 해당 노드에 남아있다.</p>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> 파드에서 컨테이너를 다시 시작하는 것과 파드를 다시 시작하는 것을 혼동해서는 안된다. 파드는
프로세스가 아니라 컨테이너를 실행하기 위한 환경이다. 파드는
삭제될 때까지 유지된다.
</div>
<p>파드 오브젝트에 대한 매니페스트를 만들 때, 지정된 이름이 유효한
<a href=/ko/docs/concepts/overview/working-with-objects/names/#dns-%EC%84%9C%EB%B8%8C%EB%8F%84%EB%A9%94%EC%9D%B8-%EC%9D%B4%EB%A6%84>DNS 서브도메인 이름</a>인지 확인한다.</p>
<h3 id=파드와-컨트롤러>파드와 컨트롤러</h3>
<p>워크로드 리소스를 사용하여 여러 파드를 만들고 관리할 수 있다. 리소스에 대한 컨트롤러는
파드 장애 시 복제 및 롤아웃과 자동 복구를
처리한다. 예를 들어, 노드가 실패하면, 컨트롤러는 해당 노드의 파드가 작동을 중지했음을
인식하고 대체 파드를 생성한다. 스케줄러는
대체 파드를 정상 노드에 배치한다.</p>
<p>다음은 하나 이상의 파드를 관리하는 워크로드 리소스의 몇 가지 예시이다.</p>
<ul>
<li><a class=glossary-tooltip title="클러스터에서 복제된 애플리케이션을 관리한다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/controllers/deployment/ target=_blank aria-label=디플로이먼트>디플로이먼트</a></li>
<li><a class=glossary-tooltip title="내구성이 있는 스토리지와 파드별로 지속성 식별자를 사용해서 파드 집합의 디플로이먼트와 스케일링을 관리한다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/controllers/statefulset/ target=_blank aria-label=스테이트풀셋>스테이트풀셋</a></li>
<li><a class=glossary-tooltip title="파드의 복제본을 클러스터 노드 집합에서 동작하게 한다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/controllers/daemonset target=_blank aria-label=데몬셋(DaemonSet)>데몬셋(DaemonSet)</a></li>
</ul>
<h3 id=파드-템플릿>파드 템플릿</h3>
<p><a class=glossary-tooltip title="워크로드는 클러스터의 컨테이너를 동작시키고 관리하기 위해 사용하는 오브젝트이다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/ target=_blank aria-label=워크로드>워크로드</a> 리소스에 대한 컨트롤러는
<em>파드 템플릿</em> 에서 파드를 생성하고 사용자 대신 해당 파드를 관리한다.</p>
<p>파드템플릿(PodTemplate)은 파드를 생성하기 위한 명세이며,
<a href=/ko/docs/concepts/workloads/controllers/deployment/>디플로이먼트</a>,
<a href=/ko/docs/concepts/workloads/controllers/job/>잡</a> 및
<a href=/ko/docs/concepts/workloads/controllers/daemonset/>데몬셋</a>과 같은 워크로드 리소스에 포함된다.</p>
<p>워크로드 리소스의 각 컨트롤러는 워크로드 오브젝트 내부의 <code>PodTemplate</code> 을
사용하여 실제 파드를 생성한다. <code>PodTemplate</code> 은 앱을 실행하는 데 사용되는 워크로드 리소스가
무엇이든지 원하는 상태의 일부이다.</p>
<p>아래 샘플은 하나의 컨테이너를 시작하는 <code>template</code> 이 있는 간단한 잡의
매니페스트이다. 해당 파드의 컨테이너는 메시지를 출력한 다음 일시 중지한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>batch/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Job<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>hello<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 여기서부터 파드 템플릿이다</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>hello<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#39;sh&#39;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#39;-c&#39;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#39;echo &#34;Hello, Kubernetes!&#34; &amp;&amp; sleep 3600&#39;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>OnFailure<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 여기까지 파드 템플릿이다</span><span style=color:#bbb>
</span></code></pre></div><p>파드 템플릿을 수정하거나 새로운 파드 템플릿으로 바꿔도 이미 존재하는
파드에는 직접적인 영향을 주지 않는다. 워크로드 리소스의 파드 템플릿을
변경하는 경우, 해당 리소스는 수정된 템플릿을 사용하는 대체 파드를 생성해야 한다.</p>
<p>예를 들어, 스테이트풀셋 컨트롤러는 실행 중인 파드가 각 스테이트풀셋 오브젝트에 대한 현재
파드 템플릿과 일치하는지 확인한다. 스테이트풀셋을 수정하여 파드 템플릿을
변경하면, 스테이트풀셋이 업데이트된 템플릿을 기반으로 새로운 파드를 생성하기 시작한다.
결국, 모든 이전의 파드가 새로운 파드로 교체되고, 업데이트가 완료된다.</p>
<p>각 워크로드 리소스는 파드 템플릿의 변경 사항을 처리하기 위한 자체 규칙을 구현한다.
스테이트풀셋에 대해 자세히 알아 보려면,
스테이트풀셋 기본 튜토리얼에서 <a href=/ko/docs/tutorials/stateful-application/basic-stateful-set/#%EC%8A%A4%ED%85%8C%EC%9D%B4%ED%8A%B8%ED%92%80%EC%85%8B-%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8%ED%95%98%EA%B8%B0>업데이트 전략</a>을 읽어본다.</p>
<p>노드에서 <a class=glossary-tooltip title="클러스터의 각 노드에서 실행되는 에이전트. Kubelet은 파드에서 컨테이너가 확실하게 동작하도록 관리한다." data-toggle=tooltip data-placement=top href=/docs/reference/generated/kubelet target=_blank aria-label=kubelet>kubelet</a>은
파드 템플릿과 업데이트에 대한 상세 정보를 직접 관찰하거나 관리하지 않는다. 이러한
상세 내용은 추상화된다. 이러한 추상화와 관심사 분리(separation of concerns)는
시스템 시맨틱을 단순화하고, 기존 코드를 변경하지 않고도 클러스터의 동작을
확장할 수 있게 한다.</p>
<h2 id=파드-갱신-및-교체>파드 갱신 및 교체</h2>
<p>이전 섹션에서 언급한 바와 같이, 워크로드 리소스의 파드
템플릿이 바뀌면, 컨트롤러는 기존의 파드를 갱신하거나 패치하는 대신
갱신된 템플릿을 기반으로 신규 파드를 생성한다.</p>
<p>쿠버네티스는 사용자가 파드를 직접 관리하는 것을 막지는 않는다.
동작 중인 파드의 필드를 갱신하는 것도 가능하다.
그러나,
<a href=/docs/reference/generated/kubernetes-api/v1.23/#patch-pod-v1-core><code>patch</code></a> 및
<a href=/docs/reference/generated/kubernetes-api/v1.23/#replace-pod-v1-core><code>replace</code></a>와 같은
파드 갱신 작업에는 다음과 같은 제약이 있다.</p>
<ul>
<li>
<p>파드에 대한 대부분의 메타데이터는 불변(immutable)이다. 예를 들면, 사용자는
<code>namespace</code>, <code>name</code>, <code>uid</code>, 또는 <code>creationTimestamp</code> 필드를 변경할 수 없다.
그리고 <code>generation</code> 필드는 고유하다. 이 필드는 필드의 현재 값을 증가시키는
갱신만 허용한다.</p>
</li>
<li>
<p><code>metadata.deletionTimestamp</code> 가 설정된 경우,
<code>metadata.finalizers</code> 리스트에 새로운 항목이 추가될 수 없다.</p>
</li>
<li>
<p>파드 갱신은 <code>spec.containers[*].image</code>, <code>spec.initContainers[*].image</code>,
<code>spec.activeDeadlineSeconds</code>, 또는 <code>spec.tolerations</code> 이외의 필드는
변경하지 않을 것이다. <code>spec.tolerations</code> 에 대해서만 새로운 항목을 추가할 수 있다.</p>
</li>
<li>
<p><code>spec.activeDeadlineSeconds</code> 필드를 추가할 때는, 다음의 두 가지 형태의 갱신만
허용한다.</p>
<ol>
<li>지정되지 않은 필드를 양수로 설정;</li>
<li>필드의 양수를 음수가 아닌 더 작은 숫자로
갱신.</li>
</ol>
</li>
</ul>
<h2 id=리소스-공유와-통신>리소스 공유와 통신</h2>
<p>파드는 파드에 속한 컨테이너 간의 데이터 공유와 통신을
지원한다.</p>
<h3 id=pod-storage>파드 스토리지</h3>
<p>파드는 공유 스토리지 <a class=glossary-tooltip title="데이터를 포함하고 있는 디렉터리이며, 파드의 컨테이너에서 접근 가능하다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/storage/volumes/ target=_blank aria-label=볼륨>볼륨</a>의
집합을 지정할 수 있다. 파드의 모든 컨테이너는
공유 볼륨에 접근할 수 있으므로, 해당 컨테이너가 데이터를 공유할 수
있다. 또한 볼륨은 내부 컨테이너 중 하나를 다시
시작해야 하는 경우 파드의 영구 데이터를 유지하도록 허용한다.
쿠버네티스가 공유 스토리지를 구현하고 파드에서 사용할 수 있도록 하는 방법에 대한
자세한 내용은 <a href=/ko/docs/concepts/storage/>스토리지</a>를 참고한다.</p>
<h3 id=파드-네트워킹>파드 네트워킹</h3>
<p>각 파드에는 각 주소 패밀리에 대해 고유한 IP 주소가 할당된다. 파드의
모든 컨테이너는 IP 주소와 네트워크 포트를 포함하여 네트워크 네임스페이스를
공유한다. 파드 내부(그때 <strong>만</strong> 해당)에서, 파드에 속한
컨테이너는 <code>localhost</code> 를 사용하여 서로 통신할 수 있다. 파드의 컨테이너가
<em>파드 외부의</em> 엔티티와 통신할 때,
공유 네트워크 리소스(포트와 같은)를 사용하는 방법을 조정해야 한다.
파드 내에서 컨테이너는 IP 주소와 포트 공간을 공유하며,
<code>localhost</code> 를 통해 서로를 찾을 수 있다. 파드의 컨테이너는 SystemV 세마포어 또는
POSIX 공유 메모리와 같은 표준 프로세스 간 통신을 사용하여 서로
통신할 수도 있다. 다른 파드의 컨테이너는
고유한 IP 주소를 가지며
<a href=/ko/docs/concepts/policy/pod-security-policy/>특별한 구성</a> 없이 IPC로 통신할 수 없다.
다른 파드에서 실행되는 컨테이너와 상호 작용하려는 컨테이너는 IP 네트워킹을
사용하여 통신할 수 있다.</p>
<p>파드 내의 컨테이너는 시스템 호스트명이 파드에 대해 구성된
<code>name</code> 과 동일한 것으로 간주한다. <a href=/ko/docs/concepts/cluster-administration/networking/>네트워킹</a> 섹션에 이에 대한
자세한 내용이 있다.</p>
<h2 id=컨테이너에-대한-특권-모드>컨테이너에 대한 특권 모드</h2>
<p>리눅스에서, 파드의 모든 컨테이너는 컨테이너 명세의 <a href=/docs/tasks/configure-pod-container/security-context/>보안 컨텍스트</a>에 있는 <code>privileged</code> (리눅스) 플래그를 사용하여 특권 모드를 활성화할 수 있다. 이는 네트워크 스택 조작이나 하드웨어 장치 접근과 같은 운영 체제 관리 기능을 사용하려는 컨테이너에 유용하다.</p>
<p>클러스터가 <code>WindowsHostProcessContainers</code> 기능을 활성화하였다면, 파드 스펙의 보안 컨텍스트의 <code>windowsOptions.hostProcess</code> 에 의해 <a href=/docs/tasks/configure-pod-container/create-hostprocess-pod>윈도우 HostProcess 파드</a>를 생성할 수 있다. 이러한 모든 컨테이너는 윈도우 HostProcess 컨테이너로 실행해야 한다. HostProcess 파드는 직접적으로 호스트에서 실행하는 것으로, 리눅스 특권있는 컨테이너에서 수행되는 관리 태스크 수행에도 사용할 수 있다. 파드의 모든 컨테이너는 윈도우 HostProcess 컨테이너로 반드시 실행해야 한다. HostProcess 파드는 호스트에서 직접 실행되며 리눅스 특권있는 컨테이너에서 수행되는 것과 같은 관리 작업을 수행하는데도 사용할 수 있다.</p>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> 이 설정을 사용하려면 사용자의 <a class=glossary-tooltip title="컨테이너 런타임은 컨테이너 실행을 담당하는 소프트웨어이다." data-toggle=tooltip data-placement=top href=/ko/docs/setup/production-environment/container-runtimes/ target=_blank aria-label="컨테이너 런타임">컨테이너 런타임</a>이 특권이 있는 컨테이너의 개념을 지원해야 한다.
</div>
<h2 id=정적-파드>정적 파드</h2>
<p><em>정적 파드</em> 는 <a class=glossary-tooltip title="쿠버네티스 API를 제공하는 컨트롤 플레인 컴포넌트." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/overview/components/#kube-apiserver target=_blank aria-label="API 서버">API 서버</a>가
관찰하는 대신 특정 노드의 kubelet 데몬에 의해 직접
관리된다.
대부분의 파드는 컨트롤 플레인(예를 들어,
<a class=glossary-tooltip title="클러스터에서 복제된 애플리케이션을 관리한다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/controllers/deployment/ target=_blank aria-label=디플로이먼트>디플로이먼트</a>)에 의해 관리되고, 정적 파드의
경우, kubelet이 각 정적 파드를 직접 감독한다(실패하면 다시 시작한다).</p>
<p>정적 파드는 항상 특정 노드의 <a class=glossary-tooltip title="클러스터의 각 노드에서 실행되는 에이전트. Kubelet은 파드에서 컨테이너가 확실하게 동작하도록 관리한다." data-toggle=tooltip data-placement=top href=/docs/reference/generated/kubelet target=_blank aria-label=Kubelet>Kubelet</a> 하나에 바인딩된다.
정적 파드의 주요 용도는 자체 호스팅 컨트롤 플레인을 실행하는 것이다. 즉,
kubelet을 사용하여 개별 <a href=/ko/docs/concepts/overview/components/#%EC%BB%A8%ED%8A%B8%EB%A1%A4-%ED%94%8C%EB%A0%88%EC%9D%B8-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8>컨트롤 플레인 컴포넌트</a>를 감독한다.</p>
<p>kubelet은 자동으로 각 정적 파드에 대한 쿠버네티스 API 서버에서 <a class=glossary-tooltip title="Kubelet의 스태틱 파드(Static Pod)를 추적하는 API 서버 내부의 오브젝트." data-toggle=tooltip data-placement=top href="/ko/docs/reference/glossary/?all=true#term-mirror-pod" target=_blank aria-label="미러 파드">미러 파드</a>를
생성하려고 한다.
즉, 노드에서 실행되는 파드는 API 서버에서 보이지만,
여기에서 제어할 수는 없다는 의미이다.</p>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> 스태틱 파드의 <code>스펙(spec)</code>은 다른 API 오브젝트
(예를 들면, <a class=glossary-tooltip title="파드에서 실행 중인 프로세스를 위한 신원(identity)을 제공한다." data-toggle=tooltip data-placement=top href=/docs/tasks/configure-pod-container/configure-service-account/ target=_blank aria-label=서비스어카운트>서비스어카운트</a>,
<a class=glossary-tooltip title="키-값 쌍으로 기밀이 아닌 데이터를 저장하는 데 사용하는 API 오브젝트이다. 볼륨에서 환경 변수, 커맨드-라인 인수 또는 구성 파일로 사용될 수 있다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/configuration/configmap/ target=_blank aria-label=컨피그맵>컨피그맵</a>,
<a class=glossary-tooltip title="비밀번호, OAuth 토큰 및 ssh 키와 같은 민감한 정보를 저장한다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/configuration/secret/ target=_blank aria-label=시크릿>시크릿</a>, 등)가 참조할 수 없다.
</div>
<h2 id=컨테이너-프로브>컨테이너 프로브</h2>
<p>_프로브_는 컨테이너의 kubelet에 의해 주기적으로 실행되는 진단이다. 진단을 수행하기 위하여 kubelet은 다음과 같은 작업을 호출할 수 있다.</p>
<ul>
<li><code>ExecAction</code> (컨테이너 런타임의 도움을 받아 수행)</li>
<li><code>TCPSocketAction</code> (kubelet에 의해 직접 검사)</li>
<li><code>HTTPGetAction</code> (kubelet에 의해 직접 검사)</li>
</ul>
<p><a href=/ko/docs/concepts/workloads/pods/pod-lifecycle/#%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88-%ED%94%84%EB%A1%9C%EB%B8%8C-probe>프로브</a>에 대한 자세한 내용은
파드 라이프사이클 문서를 참고한다.</p>
<h2 id=다음-내용>다음 내용</h2>
<ul>
<li><a href=/ko/docs/concepts/workloads/pods/pod-lifecycle/>파드의 라이프사이클</a>에 대해 알아본다.</li>
<li><a href=/ko/docs/concepts/containers/runtime-class/>런타임클래스(RuntimeClass)</a>와 이를 사용하여
다양한 컨테이너 런타임 구성으로 다양한 파드를 설정하는 방법에 대해 알아본다.</li>
<li><a href=/ko/docs/concepts/workloads/pods/pod-topology-spread-constraints/>파드 토폴로지 분배 제약 조건</a>에 대해 읽어본다.</li>
<li><a href=/ko/docs/concepts/workloads/pods/disruptions/>PodDisruptionBudget</a>과 이를 사용하여 서비스 중단 중에 애플리케이션 가용성을 관리하는 방법에 대해 읽어본다.</li>
<li>파드는 쿠버네티스 REST API의 최상위 리소스이다.
<a href=/docs/reference/kubernetes-api/workload-resources/pod-v1/>Pod</a>
오브젝트 정의는 오브젝트를 상세히 설명한다.</li>
<li><a href=/blog/2015/06/the-distributed-system-toolkit-patterns/>분산 시스템 툴킷: 컴포지트 컨테이너에 대한 패턴</a>은 둘 이상의 컨테이너가 있는 파드의 일반적인 레이아웃을 설명한다.</li>
</ul>
<p>쿠버네티스가 다른 리소스(<a class=glossary-tooltip title="내구성이 있는 스토리지와 파드별로 지속성 식별자를 사용해서 파드 집합의 디플로이먼트와 스케일링을 관리한다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/controllers/statefulset/ target=_blank aria-label=스테이트풀셋>스테이트풀셋</a>이나 <a class=glossary-tooltip title="클러스터에서 복제된 애플리케이션을 관리한다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/controllers/deployment/ target=_blank aria-label=디플로이먼트>디플로이먼트</a>와 같은)에서 공통 파드 API를 래핑하는 이유에 대한 콘텍스트를 이해하기 위해서, 다음과 같은 선행 기술에 대해 읽어볼 수 있다.</p>
<ul>
<li><a href=https://aurora.apache.org/documentation/latest/reference/configuration/#job-schema>Aurora</a></li>
<li><a href=https://research.google.com/pubs/pub43438.html>Borg</a></li>
<li><a href=https://mesosphere.github.io/marathon/docs/rest-api.html>Marathon</a></li>
<li><a href=https://research.google/pubs/pub41684/>Omega</a></li>
<li><a href=https://engineering.fb.com/data-center-engineering/tupperware/>Tupperware</a>.</li>
</ul>
</div>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-c3c2b9cf30915ec9d46c147201da3332>1 - 파드 라이프사이클</h1>
<p>이 페이지에서는 파드의 라이프사이클을 설명한다. 파드는 정의된 라이프사이클을 따른다.
<code>Pending</code> <a href=#%ED%8C%8C%EB%93%9C%EC%9D%98-%EB%8B%A8%EA%B3%84>단계</a>에서 시작해서, 기본 컨테이너 중 적어도 하나
이상이 OK로 시작하면 <code>Running</code> 단계를 통과하고, 그런 다음 파드의 컨테이너가
실패로 종료되었는지 여부에 따라 <code>Succeeded</code> 또는 <code>Failed</code> 단계로 이동한다.</p>
<p>파드가 실행되는 동안, kubelet은 일종의 오류를 처리하기 위해 컨테이너를 다시
시작할 수 있다. 파드 내에서, 쿠버네티스는 다양한 컨테이너
<a href=#%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88-%EC%83%81%ED%83%9C>상태</a>를 추적하고 파드를 다시 정상 상태로 만들기 위해 취할 조치를
결정한다.</p>
<p>쿠버네티스 API에서 파드는 명세와 실제 상태를 모두 가진다.
파드 오브젝트의 상태는 일련의 <a href=#%ED%8C%8C%EB%93%9C%EC%9D%98-%EC%BB%A8%EB%94%94%EC%85%98>파드 컨디션</a>으로 구성된다.
사용자의 애플리케이션에 유용한 경우, 파드의 컨디션 데이터에
<a href=#pod-readiness-gate>사용자 정의 준비성 정보</a>를 삽입할 수도 있다.</p>
<p>파드는 파드의 수명 중 한 번만 <a href=/ko/docs/concepts/scheduling-eviction/>스케줄</a>된다.
파드가 노드에 스케줄(할당)되면, 파드는 중지되거나 <a href=#pod-termination>종료</a>될 때까지
해당 노드에서 실행된다.</p>
<h2 id=파드의-수명>파드의 수명</h2>
<p>개별 애플리케이션 컨테이너와 마찬가지로, 파드는 비교적
임시(계속 이어지는 것이 아닌) 엔티티로 간주된다. 파드가 생성되고, 고유
ID(<a href=/ko/docs/concepts/overview/working-with-objects/names/#uids>UID</a>)가
할당되고, 종료(재시작 정책에 따라) 또는 삭제될 때까지 남아있는 노드에
스케줄된다.
만약 <a class=glossary-tooltip title="노드는 쿠버네티스의 작업 장비(worker machine)이다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/architecture/nodes/ target=_blank aria-label=노드>노드</a>가 종료되면, 해당 노드에 스케줄된 파드는
타임아웃 기간 후에 <a href=#pod-garbage-collection>삭제되도록 스케줄된다</a>.</p>
<p>파드는 자체적으로 자가 치유되지 않는다. 파드가
<a class=glossary-tooltip title="노드는 쿠버네티스의 작업 장비(worker machine)이다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/architecture/nodes/ target=_blank aria-label=노드>노드</a>에 스케줄된 후에 해당 노드가 실패하면, 파드는 삭제된다. 마찬가지로, 파드는
리소스 부족 또는 노드 유지 관리 작업으로 인한 축출에서 살아남지 못한다. 쿠버네티스는
<a class=glossary-tooltip title="API 서버를 통해 클러스터의 공유된 상태를 감시하고, 현재 상태를 원하는 상태로 이행시키는 컨트롤 루프." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/architecture/controller/ target=_blank aria-label=컨트롤러>컨트롤러</a>라
부르는 하이-레벨 추상화를 사용하여
상대적으로 일회용인 파드 인스턴스를 관리하는 작업을 처리한다.</p>
<p>UID로 정의된 특정 파드는 다른 노드로 절대 "다시 스케줄"되지 않는다. 대신,
해당 파드는 사용자가 원한다면 이름은 같지만, UID가 다른, 거의 동일한 새 파드로
대체될 수 있다.</p>
<p><a class=glossary-tooltip title="데이터를 포함하고 있는 디렉터리이며, 파드의 컨테이너에서 접근 가능하다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/storage/volumes/ target=_blank aria-label=볼륨>볼륨</a>과
같은 어떤 것이 파드와 동일한 수명을 갖는다는 것은,
특정 파드(정확한 UID 포함)가 존재하는 한 그것이 존재함을
의미한다. 어떤 이유로든 해당 파드가 삭제되고, 동일한 대체 파드가
생성되더라도, 관련된 그것(이 예에서는 볼륨)도 폐기되고
새로 생성된다.</p>
<figure class=diagram-medium>
<img src=/images/docs/pod.svg> <figcaption>
<h4>Pod diagram</h4>
</figcaption>
</figure>
<p><em>컨테이너 간의 공유 스토리지에 퍼시스턴트 볼륨을 사용하는 웹 서버와
파일 풀러(puller)가 포함된 다중 컨테이너 파드이다.</em></p>
<h2 id=파드의-단계>파드의 단계</h2>
<p>파드의 <code>status</code> 필드는
<code>phase</code> 필드를 포함하는
<a href=/docs/reference/generated/kubernetes-api/v1.23/#podstatus-v1-core>PodStatus</a> 오브젝트로 정의된다.</p>
<p>파드의 phase는 파드가 라이프사이클 중 어느 단계에 해당하는지 표현하는 간단한
고수준의 요약이다. Phase는 컨테이너나 파드의 관측 정보에 대한 포괄적인
롤업이나, 포괄적인 상태 머신을 표현하도록 의도되지는 않았다.</p>
<p>파드 phase 값에서 숫자와 의미는 엄격하게 지켜진다.
여기에 문서화된 내용 이외에는, 파드와 파드에 주어진 <code>phase</code> 값에 대해서
어떤 사항도 가정되어서는 안 된다.</p>
<p><code>phase</code>에 가능한 값은 다음과 같다.</p>
<table>
<thead>
<tr>
<th style=text-align:left>값</th>
<th style=text-align:left>의미</th>
</tr>
</thead>
<tbody>
<tr>
<td style=text-align:left><code>Pending</code></td>
<td style=text-align:left>파드가 쿠버네티스 클러스터에서 승인되었지만, 하나 이상의 컨테이너가 설정되지 않았고 실행할 준비가 되지 않았다. 여기에는 파드가 스케줄되기 이전까지의 시간 뿐만 아니라 네트워크를 통한 컨테이너 이미지 다운로드 시간도 포함된다.</td>
</tr>
<tr>
<td style=text-align:left><code>Running</code></td>
<td style=text-align:left>파드가 노드에 바인딩되었고, 모든 컨테이너가 생성되었다. 적어도 하나의 컨테이너가 아직 실행 중이거나, 시작 또는 재시작 중에 있다.</td>
</tr>
<tr>
<td style=text-align:left><code>Succeeded</code></td>
<td style=text-align:left>파드에 있는 모든 컨테이너들이 성공적으로 종료되었고, 재시작되지 않을 것이다.</td>
</tr>
<tr>
<td style=text-align:left><code>Failed</code></td>
<td style=text-align:left>파드에 있는 모든 컨테이너가 종료되었고, 적어도 하나 이상의 컨테이너가 실패로 종료되었다. 즉, 해당 컨테이너는 non-zero 상태로 빠져나왔거나(exited) 시스템에 의해서 종료(terminated)되었다.</td>
</tr>
<tr>
<td style=text-align:left><code>Unknown</code></td>
<td style=text-align:left>어떤 이유에 의해서 파드의 상태를 얻을 수 없다. 이 단계는 일반적으로 파드가 실행되어야 하는 노드와의 통신 오류로 인해 발생한다.</td>
</tr>
</tbody>
</table>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> 파드가 삭제될 때, 일부 kubectl 커맨드에서 <code>Terminating</code> 이 표시된다.
이 <code>Terminating</code> 상태는 파드의 단계에 해당하지 않는다.
파드에는 그레이스풀하게(gracefully) 종료되도록 기간이 부여되며, 그 기본값은 30초이다.
<a href=/ko/docs/concepts/workloads/pods/pod-lifecycle/#pod-termination-forced>강제로 파드를 종료</a>하려면 <code>--force</code> 플래그를 설정하면 된다.
</div>
<p>노드가 죽거나 클러스터의 나머지와의 연결이 끊어지면, 쿠버네티스는
손실된 노드의 모든 파드의 <code>phase</code> 를 Failed로 설정하는 정책을 적용한다.</p>
<h2 id=컨테이너-상태>컨테이너 상태</h2>
<p>전체 파드의 <a href=#%ED%8C%8C%EB%93%9C%EC%9D%98-%EB%8B%A8%EA%B3%84>단계</a>뿐 아니라, 쿠버네티스는 파드 내부의
각 컨테이너 상태를 추적한다.
<a href=/ko/docs/concepts/containers/container-lifecycle-hooks/>컨테이너 라이프사이클 훅(hook)</a>을
사용하여 컨테이너 라이프사이클의 특정 지점에서 실행할 이벤트를 트리거할 수 있다.</p>
<p>일단 <a class=glossary-tooltip title="노드가 배정되지 않은 새로 생성된 파드를 감지하고, 실행할 노드를 선택하는 컨트롤 플레인 컴포넌트." data-toggle=tooltip data-placement=top href=/docs/reference/command-line-tools-reference/kube-scheduler/ target=_blank aria-label=스케줄러>스케줄러</a>가
노드에 파드를 할당하면, kubelet은 <a class=glossary-tooltip title="컨테이너 런타임은 컨테이너 실행을 담당하는 소프트웨어이다." data-toggle=tooltip data-placement=top href=/ko/docs/setup/production-environment/container-runtimes/ target=_blank aria-label="컨테이너 런타임">컨테이너 런타임</a>을
사용하여 해당 파드에 대한 컨테이너 생성을 시작한다.
표시될 수 있는 세 가지 컨테이너 상태는 <code>Waiting</code>, <code>Running</code> 그리고 <code>Terminated</code> 이다.</p>
<p>파드의 컨테이너 상태를 확인하려면, <code>kubectl describe pod &lt;name-of-pod></code> 를
사용할 수 있다. 출력 결과는 해당 파드 내의 각 컨테이너 상태가
표시된다.</p>
<p>각 상태에는 특정한 의미가 있다.</p>
<h3 id=container-state-waiting><code>Waiting</code></h3>
<p>만약 컨테이너가 <code>Running</code> 또는 <code>Terminated</code> 상태가 아니면, <code>Waiting</code> 상태이다.
<code>Waiting</code> 상태의 컨테이너는 시작을 완료하는 데 필요한
작업(예를 들어, 컨테이너 이미지 레지스트리에서 컨테이너 이미지 가져오거나,
<a class=glossary-tooltip title="비밀번호, OAuth 토큰 및 ssh 키와 같은 민감한 정보를 저장한다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/configuration/secret/ target=_blank aria-label=시크릿(Secret)>시크릿(Secret)</a> 데이터를 적용하는 작업)을
계속 실행하고 있는 중이다.
<code>kubectl</code> 을 사용하여 컨테이너가 <code>Waiting</code> 인 파드를 쿼리하면, 컨테이너가
해당 상태에 있는 이유를 요약하는 Reason 필드도 표시된다.</p>
<h3 id=container-state-running><code>Running</code></h3>
<p><code>Running</code> 상태는 컨테이너가 문제없이 실행되고 있음을 나타낸다. <code>postStart</code> 훅이
구성되어 있었다면, 이미 실행되고 완료되었다. <code>kubectl</code> 을
사용하여 컨테이너가 <code>Running</code> 인 파드를 쿼리하면, 컨테이너가 <code>Running</code> 상태에 진입한 시기에 대한
정보도 볼 수 있다.</p>
<h3 id=container-state-terminated><code>Terminated</code></h3>
<p><code>Terminated</code> 상태의 컨테이너는 실행을 시작한 다음 완료될 때까지
실행되었거나 어떤 이유로 실패했다. <code>kubectl</code> 을 사용하여 컨테이너가 <code>Terminated</code> 인 파드를
쿼리하면, 이유와 종료 코드 그리고 해당 컨테이너의 실행 기간에 대한 시작과
종료 시간이 표시된다.</p>
<p>컨테이너에 구성된 <code>preStop</code> 훅이 있는 경우, 컨테이너가 <code>Terminated</code> 상태에 들어가기 전에
실행된다.</p>
<h2 id=restart-policy>컨테이너 재시작 정책</h2>
<p>파드의 <code>spec</code> 에는 <code>restartPolicy</code> 필드가 있다. 사용 가능한 값은 Always, OnFailure 그리고
Never이다. 기본값은 Always이다.</p>
<p><code>restartPolicy</code> 는 파드의 모든 컨테이너에 적용된다. <code>restartPolicy</code> 는
동일한 노드에서 kubelet에 의한 컨테이너 재시작만을 의미한다. 파드의 컨테이너가
종료된 후, kubelet은 5분으로 제한되는 지수 백오프 지연(10초, 20초, 40초, …)으로
컨테이너를 재시작한다. 컨테이너가 10분 동안 아무런 문제없이 실행되면,
kubelet은 해당 컨테이너의 재시작 백오프 타이머를 재설정한다.</p>
<h2 id=파드의-컨디션>파드의 컨디션</h2>
<p>파드는 하나의 PodStatus를 가지며,
그것은 파드가 통과했거나 통과하지 못한
<a href=/docs/reference/generated/kubernetes-api/v1.23/#podcondition-v1-core>PodConditions</a> 배열을 가진다.</p>
<ul>
<li><code>PodScheduled</code>: 파드가 노드에 스케줄되었다.</li>
<li><code>ContainersReady</code>: 파드의 모든 컨테이너가 준비되었다.</li>
<li><code>Initialized</code>: 모든 <a href=/ko/docs/concepts/workloads/pods/init-containers/>초기화 컨테이너</a>가
성공적으로 완료(completed)되었다.</li>
<li><code>Ready</code>: 파드는 요청을 처리할 수 있으며 일치하는 모든 서비스의 로드
밸런싱 풀에 추가되어야 한다.</li>
</ul>
<table>
<thead>
<tr>
<th style=text-align:left>필드 이름</th>
<th style=text-align:left>설명</th>
</tr>
</thead>
<tbody>
<tr>
<td style=text-align:left><code>type</code></td>
<td style=text-align:left>이 파드 컨디션의 이름이다.</td>
</tr>
<tr>
<td style=text-align:left><code>status</code></td>
<td style=text-align:left>가능한 값이 "<code>True</code>", "<code>False</code>", 또는 "<code>Unknown</code>"으로, 해당 컨디션이 적용 가능한지 여부를 나타낸다.</td>
</tr>
<tr>
<td style=text-align:left><code>lastProbeTime</code></td>
<td style=text-align:left>파드 컨디션이 마지막으로 프로브된 시간의 타임스탬프이다.</td>
</tr>
<tr>
<td style=text-align:left><code>lastTransitionTime</code></td>
<td style=text-align:left>파드가 한 상태에서 다른 상태로 전환된 마지막 시간에 대한 타임스탬프이다.</td>
</tr>
<tr>
<td style=text-align:left><code>reason</code></td>
<td style=text-align:left>컨디션의 마지막 전환에 대한 이유를 나타내는 기계가 판독 가능한 UpperCamelCase 텍스트이다.</td>
</tr>
<tr>
<td style=text-align:left><code>message</code></td>
<td style=text-align:left>마지막 상태 전환에 대한 세부 정보를 나타내는 사람이 읽을 수 있는 메시지이다.</td>
</tr>
</tbody>
</table>
<h2 id=pod-readiness-gate>파드의 준비성(readiness)</h2>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.14 [stable]</code>
</div>
<p>애플리케이션은 추가 피드백 또는 신호를 PodStatus: <em>Pod readiness</em>
와 같이 주입할 수 있다. 이를 사용하기 위해, kubelet이 파드의 준비성을 평가하기
위한 추가적인 컨디션들을 파드의 <code>spec</code> 내 <code>readinessGate</code> 필드를 통해서 지정할 수 있다.</p>
<p>준비성 게이트는 파드에 대한 <code>status.condition</code> 필드의 현재
상태에 따라 결정된다. 만약 쿠버네티스가 <code>status.conditions</code> 필드에서 해당하는
컨디션을 찾지 못한다면, 그 컨디션의 상태는
기본 값인 "<code>False</code>"가 된다.</p>
<p>여기 예제가 있다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>readinessGates</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>conditionType</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;www.example.com/feature-1&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>conditions</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Ready                             <span style=color:#bbb> </span><span style=color:#080;font-style:italic># 내장된 PodCondition이다</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;False&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>lastProbeTime</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>null</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>lastTransitionTime</span>:<span style=color:#bbb> </span>2018-01-01T00:00:00Z<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;www.example.com/feature-1&#34;</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># 추가적인 PodCondition</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;False&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>lastProbeTime</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>null</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>lastTransitionTime</span>:<span style=color:#bbb> </span>2018-01-01T00:00:00Z<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containerStatuses</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>containerID</span>:<span style=color:#bbb> </span>docker://abcd...<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>ready</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></code></pre></div><p>추가하는 파드 상태에는 쿠버네티스 <a href=/ko/docs/concepts/overview/working-with-objects/labels/#%EA%B5%AC%EB%AC%B8%EA%B3%BC-%EC%BA%90%EB%A6%AD%ED%84%B0-%EC%85%8B>레이블 키 포맷</a>을 충족하는 이름이 있어야 한다.</p>
<h3 id=pod-readiness-status>파드 준비성 상태</h3>
<p><code>kubectl patch</code> 명령어는 아직 오브젝트 상태 패치(patching)를 지원하지 않는다.
이러한 <code>status.conditions</code> 을 파드에 설정하려면 애플리케이션과
<a class=glossary-tooltip title="A specialized controller used to manage a custom resource" data-toggle=tooltip data-placement=top href=/docs/concepts/extend-kubernetes/operator/ target=_blank aria-label=오퍼레이터>오퍼레이터</a>의
<code>PATCH</code> 액션을 필요로 한다.
<a href=/ko/docs/reference/using-api/client-libraries/>쿠버네티스 클라이언트 라이브러리</a>를
사용해서 파드 준비성에 대한 사용자 지정 파드 컨디션을 설정하는 코드를 작성할 수 있다.</p>
<p>사용자 지정 컨디션을 사용하는 파드의 경우, 다음 두 컨디션이 모두 적용되는
경우에 <strong>만</strong> 해당 파드가 준비된 것으로 평가된다.</p>
<ul>
<li>파드 내의 모든 컨테이너들이 준비 상태이다.</li>
<li><code>readinessGates</code>에 지정된 모든 컨디션들이 <code>True</code> 이다.</li>
</ul>
<p>파드의 컨테이너가 Ready 이나 적어도 한 개의 사용자 지정 컨디션이 빠졌거나 <code>False</code> 이면,
kubelet은 파드의 <a href=#%ED%8C%8C%EB%93%9C%EC%9D%98-%EC%BB%A8%EB%94%94%EC%85%98>컨디션</a>을 <code>ContainerReady</code> 로 설정한다.</p>
<h2 id=컨테이너-프로브-probe>컨테이너 프로브(probe)</h2>
<p><em>프로브</em> 는
컨테이너에서 <a href=/docs/reference/command-line-tools-reference/kubelet/>kubelet</a>에 의해
주기적으로 수행되는 진단(diagnostic)이다.
진단을 수행하기 위해서,
kubelet은 컨테이너 안에서 코드를 실행하거나,
또는 네트워크 요청을 전송한다.</p>
<h3 id=probe-check-methods>체크 메커니즘</h3>
<p>프로브를 사용하여 컨테이너를 체크하는 방법에는 4가지가 있다.
각 프로브는 다음의 4가지 메커니즘 중 단 하나만을 정의해야 한다.</p>
<dl>
<dt><code>exec</code></dt>
<dd>컨테이너 내에서 지정된 명령어를 실행한다.
명령어가 상태 코드 0으로 종료되면 진단이 성공한 것으로 간주한다.</dd>
<dt><code>grpc</code></dt>
<dd><a href=https://grpc.io/>gRPC</a>를 사용하여
원격 프로시저 호출을 수행한다.
체크 대상이 <a href=https://grpc.io/grpc/core/md_doc_health-checking.html>gRPC 헬스 체크</a>를 구현해야 한다.
응답의 <code>status</code> 가 <code>SERVING</code> 이면
진단이 성공했다고 간주한다.
gRPC 프로브는 알파 기능이며
<code>GRPCContainerProbe</code> <a href=/ko/docs/reference/command-line-tools-reference/feature-gates/>기능 게이트</a>를
활성화해야 사용할 수 있다.</dd>
<dt><code>httpGet</code></dt>
<dd>지정한 포트 및 경로에서 컨테이너의 IP주소에 대한
HTTP <code>GET</code> 요청을 수행한다.
응답의 상태 코드가 200 이상 400 미만이면
진단이 성공한 것으로 간주한다.</dd>
<dt><code>tcpSocket</code></dt>
<dd>지정된 포트에서 컨테이너의 IP주소에 대해 TCP 검사를 수행한다.
포트가 활성화되어 있다면 진단이 성공한 것으로 간주한다.
원격 시스템(컨테이너)가 연결을 연 이후 즉시 닫는다면,
이 또한 진단이 성공한 것으로 간주한다.</dd>
</dl>
<h3 id=프로브-결과>프로브 결과</h3>
<p>각 probe는 다음 세 가지 결과 중 하나를 가진다.</p>
<dl>
<dt><code>Success</code></dt>
<dd>컨테이너가 진단을 통과함.</dd>
<dt><code>Failure</code></dt>
<dd>컨테이너가 진단에 실패함.</dd>
<dt><code>Unknown</code></dt>
<dd>진단 자체가 실패함(아무런 조치를 수행해서는 안 되며, kubelet이
추가 체크를 수행할 것이다)</dd>
</dl>
<h3 id=프로브-종류>프로브 종류</h3>
<p>kubelet은 실행 중인 컨테이너들에 대해서 선택적으로 세 가지 종류의 프로브를 수행하고
그에 반응할 수 있다.</p>
<dl>
<dt><code>livenessProbe</code></dt>
<dd>컨테이너가 동작 중인지 여부를 나타낸다. 만약
활성 프로브(liveness probe)에 실패한다면, kubelet은 컨테이너를 죽이고, 해당 컨테이너는
<a href=#restart-policy>재시작 정책</a>의 대상이 된다. 만약 컨테이너가
활성 프로브를 제공하지 않는 경우, 기본 상태는 <code>Success</code> 이다.</dd>
<dt><code>readinessProbe</code></dt>
<dd>컨테이너가 요청을 처리할 준비가 되었는지 여부를 나타낸다.
만약 준비성 프로브(readiness probe)가 실패한다면, 엔드포인트 컨트롤러는
파드에 연관된 모든 서비스들의 엔드포인트에서 파드의 IP주소를 제거한다. 준비성 프로브의
초기 지연 이전의 기본 상태는 <code>Failure</code> 이다. 만약 컨테이너가 준비성 프로브를
지원하지 않는다면, 기본 상태는 <code>Success</code> 이다.</dd>
<dt><code>startupProbe</code></dt>
<dd>컨테이너 내의 애플리케이션이 시작되었는지를 나타낸다.
스타트업 프로브(startup probe)가 주어진 경우, 성공할 때까지 다른 나머지 프로브는
활성화되지 않는다. 만약 스타트업 프로브가 실패하면, kubelet이 컨테이너를 죽이고,
컨테이너는 <a href=#restart-policy>재시작 정책</a>에 따라 처리된다. 컨테이너에 스타트업
프로브가 없는 경우, 기본 상태는 <code>Success</code> 이다.</dd>
</dl>
<p>활성, 준비성 및 스타트업 프로브를 설정하는 방법에 대한 추가적인 정보는,
<a href=/docs/tasks/configure-pod-container/configure-liveness-readiness-probes/>활성, 준비성 및 스타트업 프로브 설정하기</a>를 참조하면 된다.</p>
<h4 id=언제-활성-프로브를-사용해야-하는가>언제 활성 프로브를 사용해야 하는가?</h4>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.0 [stable]</code>
</div>
<p>만약 컨테이너 속 프로세스가 어떠한 이슈에 직면하거나 건강하지 못한
상태(unhealthy)가 되는 등 프로세스 자체의 문제로 중단될 수 있더라도, 활성 프로브가
반드시 필요한 것은 아니다. 그 경우에는 kubelet이 파드의 <code>restartPolicy</code>에
따라서 올바른 대처를 자동적으로 수행할 것이다.</p>
<p>프로브가 실패한 후 컨테이너가 종료되거나 재시작되길 원한다면, 활성 프로브를
지정하고, <code>restartPolicy</code>를 항상(Always) 또는 실패 시(OnFailure)로 지정한다.</p>
<h4 id=언제-준비성-프로브를-사용해야-하는가>언제 준비성 프로브를 사용해야 하는가?</h4>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.0 [stable]</code>
</div>
<p>프로브가 성공한 경우에만 파드에 트래픽 전송을 시작하려고 한다면,
준비성 프로브를 지정하길 바란다. 이 경우에서는, 준비성 프로브가 활성 프로브와 유사해
보일 수도 있지만, 스팩에 준비성 프로브가 존재한다는 것은 파드가
트래픽을 받지 않는 상태에서 시작되고 프로브가 성공하기 시작한 이후에만
트래픽을 받는다는 뜻이다.</p>
<p>만약 컨테이너가 유지 관리를 위해서 자체 중단되게 하려면,
준비성 프로브를 지정하길 바란다.
준비성 프로브는 활성 프로브와는 다르게 준비성에 특정된 엔드포인트를 확인한다.</p>
<p>만약 애플리케이션이 백엔드 서비스에 엄격한 의존성이 있다면,
활성 프로브와 준비성 프로브 모두 활용할 수도 있다. 활성 프로브는 애플리케이션 스스로가 건강한 상태면
통과하지만, 준비성 프로브는 추가적으로 요구되는 각 백-엔드 서비스가 가용한지 확인한다. 이를 이용하여,
오류 메시지만 응답하는 파드로
트래픽이 가는 것을 막을 수 있다.</p>
<p>만약 컨테이너가 시동 시 대량 데이터의 로딩, 구성 파일, 또는
마이그레이션에 대한 작업을
수행해야 한다면, <a href=#%EC%96%B8%EC%A0%9C-%EC%8A%A4%ED%83%80%ED%8A%B8%EC%97%85-%ED%94%84%EB%A1%9C%EB%B8%8C%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%B4%EC%95%BC-%ED%95%98%EB%8A%94%EA%B0%80>스타트업 프로브</a>를 사용하면 된다. 그러나, 만약
failed 애플리케이션과 시동 중에 아직 데이터를 처리하고 있는 애플리케이션을 구분하여 탐지하고
싶다면, 준비성 프로브를 사용하는 것이 더 적합할 것이다.</p>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> 파드가 삭제될 때 요청들을 흘려 보내기(drain) 위해
준비성 프로브가 꼭 필요한 것은 아니다. 삭제 시에, 파드는
프로브의 존재 여부와 무관하게 자동으로 스스로를 준비되지 않은 상태(unready)로 변경한다.
파드는 파드 내의 모든 컨테이너들이 중지될 때까지 준비되지 않은 상태로
남아 있다.
</div>
<h4 id=언제-스타트업-프로브를-사용해야-하는가>언제 스타트업 프로브를 사용해야 하는가?</h4>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.20 [stable]</code>
</div>
<p>스타트업 프로브는 서비스를 시작하는 데 오랜 시간이 걸리는 컨테이너가 있는
파드에 유용하다. 긴 활성 간격을 설정하는 대신, 컨테이너가 시작될 때
프로브를 위한 별도의 구성을 설정하여, 활성 간격보다
긴 시간을 허용할 수 있다.</p>
<p>컨테이너가 보통 <code>initialDelaySeconds + failureThreshold × periodSeconds</code>
이후에 기동된다면, 스타트업 프로브가
활성화 프로브와 같은 엔드포인트를 확인하도록 지정해야 한다.
<code>periodSeconds</code>의 기본값은 10s 이다. 이 때 컨테이너가 활성화 프로브의
기본값 변경 없이 기동되도록 하려면, <code>failureThreshold</code> 를 충분히 높게 설정해주어야
한다. 그래야 데드락(deadlocks)을 방지하는데 도움이 된다.</p>
<h2 id=pod-termination>파드의 종료</h2>
<p>파드는 클러스터의 노드에서 실행되는 프로세스를 나타내므로, 해당 프로세스가
더 이상 필요하지 않을 때 정상적으로 종료되도록 하는 것이 중요하다(<code>KILL</code>
시그널로 갑자기 중지되고 정리할 기회가 없는 것 보다).</p>
<p>디자인 목표는 삭제를 요청하고 프로세스가 종료되는 시기를 알 수
있을 뿐만 아니라, 삭제가 결국 완료되도록 하는 것이다.
사용자가 파드의 삭제를 요청하면, 클러스터는 파드가 강제로 종료되기 전에
의도한 유예 기간을 기록하고 추적한다. 강제 종료 추적이
적용되면, <a class=glossary-tooltip title="클러스터의 각 노드에서 실행되는 에이전트. Kubelet은 파드에서 컨테이너가 확실하게 동작하도록 관리한다." data-toggle=tooltip data-placement=top href=/docs/reference/generated/kubelet target=_blank aria-label=kubelet>kubelet</a>은 정상
종료를 시도한다.</p>
<p>일반적으로, 컨테이너 런타임은 각 컨테이너의 기본 프로세스에 TERM 신호를
전송한다. 많은 컨테이너 런타임은 컨테이너 이미지에 정의된 <code>STOPSIGNAL</code> 값을 존중하며
TERM 대신 이 값을 보낸다.
일단 유예 기간이 만료되면, KILL 시그널이 나머지 프로세스로
전송되고, 그런 다음 파드는
<a class=glossary-tooltip title="쿠버네티스 API를 제공하는 컨트롤 플레인 컴포넌트." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/overview/components/#kube-apiserver target=_blank aria-label="API 서버">API 서버</a>로부터 삭제된다. 프로세스가
종료될 때까지 기다리는 동안 kubelet 또는 컨테이너 런타임의 관리 서비스가 다시 시작되면, 클러스터는
전체 원래 유예 기간을 포함하여 처음부터 다시 시도한다.</p>
<p>플로우의 예는 다음과 같다.</p>
<ol>
<li>이 <code>kubectl</code> 도구를 사용하여 기본 유예 기간(30초)으로 특정 파드를 수동으로
삭제한다.</li>
<li>API 서버의 파드는 유예 기간과 함께 파드가 "dead"로 간주되는
시간으로 업데이트된다.
<code>kubectl describe</code> 를 사용하여 삭제하려는 파드를 확인하면, 해당 파드가 "Terminating"으로
표시된다.
파드가 실행 중인 노드에서, kubelet이 파드가 종료된 것(terminating)으로 표시되었음을
확인하는 즉시(정상적인 종료 기간이 설정됨), kubelet은 로컬 파드의 종료
프로세스를 시작한다.
<ol>
<li>파드의 컨테이너 중 하나가 <code>preStop</code>
<a href=/ko/docs/concepts/containers/container-lifecycle-hooks>훅</a>을 정의한 경우, kubelet은
컨테이너 내부에서 해당 훅을 실행한다. 유예 기간이 만료된 후 <code>preStop</code> 훅이
계속 실행되면, kubelet은 2초의 작은 일회성 유예 기간 연장을
요청한다.
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> <code>preStop</code> 훅을 완료하는 데 기본 유예 기간이 허용하는 것보다 오랜 시간이 필요한 경우,
이에 맞게 <code>terminationGracePeriodSeconds</code> 를 수정해야 한다.
</div></li>
<li>kubelet은 컨테이너 런타임을 트리거하여 각 컨테이너 내부의 프로세스 1에 TERM 시그널을
보낸다.
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> 파드의 컨테이너는 서로 다른 시간에 임의의 순서로 TERM 시그널을
수신한다. 종료 순서가 중요한 경우, <code>preStop</code> 훅을 사용하여 동기화하는 것이 좋다.
</div></li>
</ol>
</li>
<li>kubelet이 정상 종료를 시작하는 동시에, 컨트롤 플레인은
구성된 <a class=glossary-tooltip title="사용자가 레이블에 따라서 리소스 리스트를 필터할 수 있게 한다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/overview/working-with-objects/labels/ target=_blank aria-label=셀렉터>셀렉터</a>가 있는
<a class=glossary-tooltip title="네트워크 서비스로 파드 집합에서 실행 중인 애플리케이션을 노출하는 방법" data-toggle=tooltip data-placement=top href=/ko/docs/concepts/services-networking/service/ target=_blank aria-label=서비스>서비스</a>를 나타내는
엔드포인트(Endpoint)(그리고, 활성화된 경우, 엔드포인트슬라이스(EndpointSlice)) 오브젝트에서 종료된 파드를 제거한다.
<a class=glossary-tooltip title="레플리카셋은 지정된 수의 파드 레플리카가 동시에 실행이 되도록 보장한다" data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/controllers/replicaset/ target=_blank aria-label=레플리카셋(ReplicaSet)>레플리카셋(ReplicaSet)</a>과 기타 워크로드 리소스는
더 이상 종료된 파드를 유효한 서비스 내 복제본으로 취급하지 않는다. 로드 밸런서(서비스 프록시와 같은)가
종료 유예 기간이 <em>시작되는</em> 즉시 엔드포인트 목록에서 파드를 제거하므로 느리게 종료되는
파드는 트래픽을 계속 제공할 수 없다.</li>
<li>유예 기간이 만료되면, kubelet은 강제 종료를 트리거한다. 컨테이너 런타임은
<code>SIGKILL</code> 을 파드의 모든 컨테이너에서 여전히 실행 중인 모든 프로세스로 전송한다.
kubelet은 해당 컨테이너 런타임이 하나를 사용하는 경우 숨겨진 <code>pause</code> 컨테이너도 정리한다.</li>
<li>kubelet은 유예 기간을 0(즉시 삭제)으로 설정하여, API 서버에서 파드 오브젝트의
강제 삭제를 트리거한다.</li>
<li>API 서버가 파드의 API 오브젝트를 삭제하면, 더 이상 클라이언트에서 볼 수 없다.</li>
</ol>
<h3 id=pod-termination-forced>강제 파드 종료</h3>
<div class="alert alert-warning caution callout" role=alert>
<strong>주의:</strong> 강제 삭제는 일부 워크로드와 해당 파드에 대해서 잠재적으로 중단될 수 있다.
</div>
<p>기본적으로, 모든 삭제는 30초 이내에는 정상적으로 수행된다. <code>kubectl delete</code> 명령은
기본값을 재정의하고 사용자의 고유한 값을 지정할 수 있는 <code>--grace-period=&lt;seconds></code> 옵션을
지원한다.</p>
<p>유예 기간을 <code>0</code> 로 강제로 즉시 설정하면 API 서버에서 파드가
삭제된다. 파드가 노드에서 계속 실행 중인 경우, 강제 삭제는 kubelet을 트리거하여
즉시 정리를 시작한다.</p>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> 강제 삭제를 수행하려면 <code>--grace-period=0</code> 와 함께 추가 플래그 <code>--force</code> 를 지정해야 한다.
</div>
<p>강제 삭제가 수행되면, API 서버는 실행 중인 노드에서
파드가 종료되었다는 kubelet의 확인을 기다리지 않는다.
API에서 즉시 파드를 제거하므로 동일한 이름으로 새로운 파드를 생성할 수
있다. 노드에서 즉시 종료되도록 설정된 파드는 강제 종료되기 전에
작은 유예 기간이 계속 제공된다.</p>
<p>스테이트풀셋(StatefulSet)의 일부인 파드를 강제 삭제해야 하는 경우,
<a href=/ko/docs/tasks/run-application/force-delete-stateful-set-pod/>스테이트풀셋에서 파드를 삭제하기</a>에 대한
태스크 문서를 참고한다.</p>
<h3 id=pod-garbage-collection>실패한 파드의 가비지 콜렉션</h3>
<p>실패한 파드의 경우, API 오브젝트는 사람이나
<a class=glossary-tooltip title="API 서버를 통해 클러스터의 공유된 상태를 감시하고, 현재 상태를 원하는 상태로 이행시키는 컨트롤 루프." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/architecture/controller/ target=_blank aria-label=컨트롤러>컨트롤러</a> 프로세스가
명시적으로 파드를 제거할 때까지 클러스터의 API에 남아 있다.</p>
<p>컨트롤 플레인은 파드 수가 구성된 임계값(kube-controller-manager에서
<code>terminated-pod-gc-threshold</code> 에 의해 결정됨)을 초과할 때 종료된 파드(<code>Succeeded</code> 또는
<code>Failed</code> 단계 포함)를 정리한다.
이렇게 하면 시간이 지남에 따라 파드가 생성되고 종료될 때 리소스 유출이 방지된다.</p>
<h2 id=다음-내용>다음 내용</h2>
<ul>
<li>
<p><a href=/docs/tasks/configure-pod-container/attach-handler-lifecycle-event/>컨테이너 라이프사이클 이벤트에 핸들러를 연결</a>하는
핸즈온 연습을 해보자.</p>
</li>
<li>
<p><a href=/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/>활성, 준비성 및 스타트업 프로브 설정</a>하는
핸즈온 연습을 해보자.</p>
</li>
<li>
<p><a href=/ko/docs/concepts/containers/container-lifecycle-hooks/>컨테이너 라이프사이클 훅</a>에 대해 자세히 알아보자.</p>
</li>
<li>
<p>API의 파드와 컨테이너 상태에 대한 자세한 내용은
파드의 <a href=/docs/reference/kubernetes-api/workload-resources/pod-v1/#PodStatus><code>.status</code></a>에 대해 다루는
API 레퍼런스 문서를 참고한다.</p>
</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-1ccbd4eeded6ab138d98b59175bd557e>2 - 초기화 컨테이너</h1>
<p>이 페이지는 초기화 컨테이너에 대한 개요를 제공한다. 초기화 컨테이너는
<a class=glossary-tooltip title="파드는 클러스터에서 실행 중인 컨테이너의 집합을 나타낸다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/pods/ target=_blank aria-label=파드>파드</a>의 앱 컨테이너들이 실행되기 전에 실행되는 특수한 컨테이너이며, 앱 이미지에는 없는
유틸리티 또는 설정 스크립트 등을 포함할 수 있다.</p>
<p>초기화 컨테이너는 <code>containers</code> 배열(앱 컨테이너를 기술하는)과 나란히
파드 스펙에 명시할 수 있다.</p>
<h2 id=초기화-컨테이너-이해하기>초기화 컨테이너 이해하기</h2>
<p><a class=glossary-tooltip title="파드는 클러스터에서 실행 중인 컨테이너의 집합을 나타낸다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/pods/ target=_blank aria-label=파드>파드</a>는 앱들을 실행하는 다수의 컨테이너를
포함할 수 있고, 또한 앱 컨테이너 실행 전에 동작되는 하나 이상의
초기화 컨테이너도 포함할 수 있다.</p>
<p>다음의 경우를 제외하면, 초기화 컨테이너는 일반적인 컨테이너와 매우 유사하다.</p>
<ul>
<li>초기화 컨테이너는 항상 완료를 목표로 실행된다.</li>
<li>각 초기화 컨테이너는 다음 초기화 컨테이너가 시작되기 전에 성공적으로 완료되어야 한다.</li>
</ul>
<p>만약 파드의 초기화 컨테이너가 실패하면, kubelet은 초기화 컨테이너가 성공할 때까지 반복적으로 재시작한다.
그러나, 만약 파드의 <code>restartPolicy</code> 를 절대 하지 않음(Never)으로 설정하고, 해당 파드를 시작하는 동안 초기화 컨테이너가 실패하면, 쿠버네티스는 전체 파드를 실패한 것으로 처리한다.</p>
<p>컨테이너를 초기화 컨테이너로 지정하기 위해서는,
<a href=/docs/reference/kubernetes-api/workload-resources/pod-v1/#PodSpec>파드 스펙</a>에 <code>initContainers</code> 필드를
<code>container</code> 항목(앱 <code>container</code> 필드 및 내용과 유사한)들의 배열로서 추가한다.
<a href=/docs/reference/kubernetes-api/workload-resources/pod-v1/#Container>컨테이너</a>에 대한 더 상세한 사항은
API 레퍼런스를 참고한다.</p>
<p>초기화 컨테이너의 상태는 컨테이너
상태의 배열(<code>.status.containerStatuses</code> 필드와 유사)로 <code>.status.initContainerStatuses</code>
필드에 반환된다.</p>
<h3 id=일반적인-컨테이너와의-차이점>일반적인 컨테이너와의 차이점</h3>
<p>초기화 컨테이너는 앱 컨테이너의 리소스 상한(limit), 볼륨, 보안 세팅을 포함한
모든 필드와 기능을 지원한다.
그러나, 초기화 컨테이너를 위한 리소스 요청량과 상한은
<a href=#%EB%A6%AC%EC%86%8C%EC%8A%A4>리소스</a>에 문서화된 것처럼 다르게 처리된다.</p>
<p>또한, 초기화 컨테이너는 <code>lifecycle</code>, <code>livenessProbe</code>, <code>readinessProbe</code> 또는 <code>startupProbe</code> 를 지원하지 않는다.
왜냐하면 초기화 컨테이너는 파드가 준비 상태가 되기 전에 완료를 목표로 실행되어야 하기 때문이다.</p>
<p>만약 다수의 초기화 컨테이너가 파드에 지정되어 있다면, kubelet은 해당 초기화 컨테이너들을
한 번에 하나씩 실행한다. 각 초기화 컨테이너는 다음 컨테이너를 실행하기 전에 꼭 성공해야 한다.
모든 초기화 컨테이너들이 실행 완료되었을 때, kubelet은 파드의 애플리케이션 컨테이너들을
초기화하고 평소와 같이 실행한다.</p>
<h2 id=초기화-컨테이너-사용하기>초기화 컨테이너 사용하기</h2>
<p>초기화 컨테이너는 앱 컨테이너와는 별도의 이미지를 가지고 있기 때문에, 시동(start-up)에
관련된 코드로서 몇 가지 이점을 가진다.</p>
<ul>
<li>앱 이미지에는 없는 셋업을 위한 유틸리티 또는 맞춤 코드를 포함할 수 있다.
예를 들어, 셋업 중에 단지 <code>sed</code>, <code>awk</code>, <code>python</code>, 또는 <code>dig</code>와 같은 도구를 사용하기 위해서
다른 이미지로부터(<code>FROM</code>) 새로운 이미지를 만들 필요가 없다.</li>
<li>애플리케이션 이미지 빌더와 디플로이어 역할은 독립적으로 동작될 수 있어서
공동의 단일 앱 이미지 형태로 빌드될 필요가 없다.</li>
<li>초기화 컨테이너는 앱 컨테이너와 다른 파일 시스템 뷰를 가지도록 리눅스 네임스페이스를 사용한다.
결과적으로, 초기화 컨테이너에는 앱 컨테이너가 가질 수 없는
<a class=glossary-tooltip title="비밀번호, OAuth 토큰 및 ssh 키와 같은 민감한 정보를 저장한다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/configuration/secret/ target=_blank aria-label=시크릿>시크릿</a>에 접근 권한이 주어질 수 있다.</li>
<li>앱 컨테이너들은 병렬로 실행되는 반면, 초기화 컨테이너들은 어떠한 앱
컨테이너라도 시작되기 전에 실행 완료되어야 하므로, 초기화 컨테이너는 사전 조건들이
충족될 때까지 앱 컨테이너가 시동되는 것을 막거나 지연시키는 간편한 방법을 제공한다.</li>
<li>초기화 컨테이너는 앱 컨테이너 이미지의 보안성을 떨어뜨릴 수도 있는 유틸리티 혹은 커스텀 코드를 안전하게
실행할 수 있다. 불필요한 툴들을 분리한 채로 유지함으로써 앱 컨테이너 이미지의 공격에 대한
노출을 제한할 수 있다.</li>
</ul>
<h3 id=예제>예제</h3>
<p>초기화 컨테이너를 사용하는 방법에 대한 몇 가지 아이디어는 다음과 같다.</p>
<ul>
<li>
<p>다음과 같은 셸 커맨드로,
<a class=glossary-tooltip title="네트워크 서비스로 파드 집합에서 실행 중인 애플리케이션을 노출하는 방법" data-toggle=tooltip data-placement=top href=/ko/docs/concepts/services-networking/service/ target=_blank aria-label=서비스>서비스</a>가 생성될 때까지 기다리기.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#a2f;font-weight:700>for</span> i in <span style=color:#666>{</span>1..100<span style=color:#666>}</span>; <span style=color:#a2f;font-weight:700>do</span> sleep 1; <span style=color:#a2f;font-weight:700>if</span> dig myservice; <span style=color:#a2f;font-weight:700>then</span> <span style=color:#a2f>exit</span> 0; <span style=color:#a2f;font-weight:700>fi</span>; <span style=color:#a2f;font-weight:700>done</span>; <span style=color:#a2f>exit</span> <span style=color:#666>1</span>
</code></pre></div></li>
<li>
<p>다음과 같은 커맨드로, 다운워드 API(Downward API)를 통한 원격 서버에 해당 파드를 등록하기.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>curl -X POST http://<span style=color:#b8860b>$MANAGEMENT_SERVICE_HOST</span>:<span style=color:#b8860b>$MANAGEMENT_SERVICE_PORT</span>/register -d <span style=color:#b44>&#39;instance=$(&lt;POD_NAME&gt;)&amp;ip=$(&lt;POD_IP&gt;)&#39;</span>
</code></pre></div></li>
<li>
<p>다음과 같은 커맨드로 앱 컨테이너가 시작되기 전에 일정 시간 기다리기.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>sleep <span style=color:#666>60</span>
</code></pre></div></li>
<li>
<p>Git 저장소를 <a class=glossary-tooltip title="데이터를 포함하고 있는 디렉터리이며, 파드의 컨테이너에서 접근 가능하다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/storage/volumes/ target=_blank aria-label=볼륨>볼륨</a> 안에 클론하기.</p>
</li>
<li>
<p>설정 파일에 값을 지정하고
메인 앱 컨테이너를 위한 설정 파일을 동적으로 생성하기 위한 템플릿 도구를 실행하기.
예를 들어, 설정에 <code>POD_IP</code> 값을 지정하고
메인 앱 설정 파일을 Jinja를 통해서 생성.</p>
</li>
</ul>
<h3 id=사용-중인-초기화-컨테이너>사용 중인 초기화 컨테이너</h3>
<p>쿠버네티스 1.5에 대한 다음의 yaml 파일은 두 개의 초기화 컨테이너를 포함한 간단한 파드에 대한 개요를 보여준다.
첫 번째는 <code>myservice</code> 를 기다리고 두 번째는 <code>mydb</code> 를 기다린다. 두 컨테이너들이
완료되면, 파드가 시작될 것이다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>myapp-pod<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>myapp<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>myapp-container<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox:1.28<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#39;sh&#39;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#39;-c&#39;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#39;echo The app is running! &amp;&amp; sleep 3600&#39;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>initContainers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>init-myservice<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox:1.28<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#39;sh&#39;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#39;-c&#39;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;until nslookup myservice.$(cat /var/run/secrets/kubernetes.io/serviceaccount/namespace).svc.cluster.local; do echo waiting for myservice; sleep 2; done&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>init-mydb<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox:1.28<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#39;sh&#39;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#39;-c&#39;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;until nslookup mydb.$(cat /var/run/secrets/kubernetes.io/serviceaccount/namespace).svc.cluster.local; do echo waiting for mydb; sleep 2; done&#34;</span>]<span style=color:#bbb>
</span></code></pre></div><p>다음 커맨드들을 이용하여 파드를 시작하거나 디버깅할 수 있다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f myapp.yaml
</code></pre></div><p>출력 결과는 다음과 같다.</p>
<pre><code>pod/myapp-pod created
</code></pre><p>그리고 파드의 상태를 확인한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get -f myapp.yaml
</code></pre></div><p>출력 결과는 다음과 같다.</p>
<pre><code>NAME        READY     STATUS     RESTARTS   AGE
myapp-pod   0/1       Init:0/2   0          6m
</code></pre><p>혹은 좀 더 자세히 살펴본다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe -f myapp.yaml
</code></pre></div><p>출력 결과는 다음과 같다.</p>
<pre><code>Name:          myapp-pod
Namespace:     default
[...]
Labels:        app=myapp
Status:        Pending
[...]
Init Containers:
  init-myservice:
[...]
    State:         Running
[...]
  init-mydb:
[...]
    State:         Waiting
      Reason:      PodInitializing
    Ready:         False
[...]
Containers:
  myapp-container:
[...]
    State:         Waiting
      Reason:      PodInitializing
    Ready:         False
[...]
Events:
  FirstSeen    LastSeen    Count    From                      SubObjectPath                           Type          Reason        Message
  ---------    --------    -----    ----                      -------------                           --------      ------        -------
  16s          16s         1        {default-scheduler }                                              Normal        Scheduled     Successfully assigned myapp-pod to 172.17.4.201
  16s          16s         1        {kubelet 172.17.4.201}    spec.initContainers{init-myservice}     Normal        Pulling       pulling image &quot;busybox&quot;
  13s          13s         1        {kubelet 172.17.4.201}    spec.initContainers{init-myservice}     Normal        Pulled        Successfully pulled image &quot;busybox&quot;
  13s          13s         1        {kubelet 172.17.4.201}    spec.initContainers{init-myservice}     Normal        Created       Created container with docker id 5ced34a04634; Security:[seccomp=unconfined]
  13s          13s         1        {kubelet 172.17.4.201}    spec.initContainers{init-myservice}     Normal        Started       Started container with docker id 5ced34a04634
</code></pre><p>파드의 초기화 컨테이너의 상태를 보기 위해, 다음을 실행한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl logs myapp-pod -c init-myservice <span style=color:#080;font-style:italic># Inspect the first init container</span>
kubectl logs myapp-pod -c init-mydb      <span style=color:#080;font-style:italic># Inspect the second init container</span>
</code></pre></div><p><code>mydb</code> 및 <code>myservice</code> 서비스를 시작하고 나면, 초기화 컨테이너가 완료되고
<code>myapp-pod</code> 가 생성된 것을 볼 수 있다.</p>
<p>여기에 이 서비스를 보이기 위해 사용할 수 있는 구성이 있다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>myservice<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>9376</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mydb<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>9377</span><span style=color:#bbb>
</span></code></pre></div><p><code>mydb</code> 와 <code>myservice</code> 서비스 생성하기.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f services.yaml
</code></pre></div><p>출력 결과는 다음과 같다.</p>
<pre><code>service/myservice created
service/mydb created
</code></pre><p>초기화 컨테이너들이 완료되는 것과 <code>myapp-pod</code> 파드가 Running 상태로
변경되는 것을 볼 것이다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get -f myapp.yaml
</code></pre></div><p>출력 결과는 다음과 같다.</p>
<pre><code>NAME        READY     STATUS    RESTARTS   AGE
myapp-pod   1/1       Running   0          9m
</code></pre><p>이 간단한 예제는 사용자만의 초기화 컨테이너를 생성하는데
영감을 줄 것이다. <a href=#%EB%8B%A4%EC%9D%8C-%EB%82%B4%EC%9A%A9>다음 순서</a>에는 더 자세한 예제의 링크가 있다.</p>
<h2 id=자세한-동작>자세한 동작</h2>
<p>파드 시작 시에 kubelet은 네트워크와 스토리지가 준비될 때까지
초기화 컨테이너의 실행을 지연시킨다. 그런 다음 kubelet은 파드 사양에
나와있는 순서대로 파드의 초기화 컨테이너를 실행한다.</p>
<p>각 초기화 컨테이너는 다음 컨테이너가 시작되기 전에 성공적으로
종료되어야 한다. 만약 런타임 문제나 실패 상태로 종료되는 문제로인하여 초기화 컨테이너의 시작이
실패된다면, 초기화 컨테이너는 파드의 <code>restartPolicy</code> 에 따라서 재시도 된다. 다만,
파드의 <code>restartPolicy</code> 가 항상(Always)으로 설정된 경우, 해당 초기화 컨테이너는
<code>restartPolicy</code> 를 실패 시(OnFailure)로 사용한다.</p>
<p>파드는 모든 초기화 컨테이너가 성공되기 전까지 <code>Ready</code> 될 수 없다. 초기화 컨테이너의 포트는
서비스 하에 합쳐지지 않는다. 초기화 중인 파드는 <code>Pending</code> 상태이지만
<code>Initialized</code> 가 거짓이 되는 조건을 가져야 한다.</p>
<p>만약 파드가 <a href=#%ED%8C%8C%EB%93%9C-%EC%9E%AC%EC%8B%9C%EC%9E%91-%EC%9D%B4%EC%9C%A0>재시작</a>되었다면, 모든 초기화 컨테이너는
반드시 다시 실행된다.</p>
<p>초기화 컨테이너 스펙 변경은 컨테이너 이미지 필드에서만 한정적으로 가능하다.
초기화 컨테이너 이미지 필드를 변경하는 것은 파드를 재시작하는 것과 같다.</p>
<p>초기화 컨테이너는 재시작되거나, 재시도, 또는 재실행 될 수 있기 때문에, 초기화 컨테이너
코드는 멱등성(idempotent)을 유지해야 한다. 특히, <code>EmptyDirs</code> 에 있는 파일에 쓰기를 수행하는 코드는
출력 파일이 이미 존재할 가능성에 대비해야 한다.</p>
<p>초기화 컨테이너는 앱 컨테이너의 필드를 모두 가지고 있다. 그러나, 쿠버네티스는
<code>readinessProbe</code> 가 사용되는 것을 금지한다. 초기화 컨테이너가 완료 상태와 준비성을
구분해서 정의할 수 없기 때문이다. 이것은 유효성 검사 중에 시행된다.</p>
<p>초기화 컨테이너들이 실패를 영원히 지속하는 상황을 방지하기 위해서
파드의 <code>activeDeadlineSeconds</code>를 사용한다.
Active deadline은 초기화 컨테이너를 포함한다.
그러나 팀에서 애플리케이션을 잡(job)으로 배포한 경우에만 <code>activeDeadlineSeconds</code>를 사용하길 추천한다. 왜냐하면, <code>activeDeadlineSeconds</code>는 초기화 컨테이너가 완료된 이후에도 영향을 주기 때문이다.
이미 정상적으로 동작하고 있는 파드도 <code>activeDeadlineSeconds</code>를 설정한 경우 종료(killed)될 수 있다.</p>
<p>파드 내의 각 앱과 초기화 컨테이너의 이름은 유일해야 한다. 어떤
컨테이너가 다른 컨테이너와 같은 이름을 공유하는 경우 유효성 오류가 발생한다.</p>
<h3 id=리소스>리소스</h3>
<p>초기화 컨테이너에게 명령과 실행이 주어진 경우, 리소스 사용에 대한
다음의 규칙이 적용된다.</p>
<ul>
<li>모든 컨테이너에 정의된 특정 리소스 요청량 또는 상한 중
가장 높은 것은 <em>유효 초기화 요청량/상한</em> 이다. 리소스 제한이 지정되지 않은 리소스는
이 <em>유효 초기화 요청량/상한</em>을 가장 높은 요청량/상한으로 간주한다.</li>
<li>리소스를 위한 파드의 <em>유효한 초기화 요청량/상한</em> 은 다음 보다 더 높다.
<ul>
<li>모든 앱 컨테이너의 리소스에 대한 요청량/상한의 합계</li>
<li>리소스에 대한 유효한 초기화 요청량/상한</li>
</ul>
</li>
<li>스케줄링은 유효한 요청/상한에 따라 이루어진다. 즉,
초기화 컨테이너는 파드의 삶에서는 사용되지 않는 초기화를 위한 리소스를
예약할 수 있다.</li>
<li>파드의 <em>유효한 QoS 계층</em> 에서 QoS(서비스의 품질) 계층은 초기화 컨테이너들과
앱 컨테이너들의 QoS 계층과 같다.</li>
</ul>
<p>쿼터 및 상한은 유효한 파드의 요청량 및 상한에 따라
적용된다.</p>
<p>파드 레벨 cgroup은 유효한 파드 요청량 및 상한을 기반으로 한다.
이는 스케줄러와 같다.</p>
<h3 id=파드-재시작-이유>파드 재시작 이유</h3>
<p>파드는 다음과 같은 사유로, 초기화 컨테이너들의 재-실행을 일으키는, 재시작을 수행할 수
있다.</p>
<ul>
<li>파드 인프라스트럭처 컨테이너가 재시작된 상황. 이는 일반적인 상황이 아니며 노드에
대해서 root 접근 권한을 가진 누군가에 의해서 수행됐을 것이다.</li>
<li>초기화 컨테이너의 완료 기록이 가비지 수집 때문에 유실된 상태에서,
<code>restartPolicy</code>가 Always로 설정된 파드의 모든 컨테이너가 종료되어
모든 컨테이너를 재시작해야 하는 상황</li>
</ul>
<p>초기화 컨테이너 이미지가 변경되거나 초기화 컨테이너의 완료 기록이 가비지 수집
때문에 유실된 상태이면 파드는 재시작되지 않는다. 이는 쿠버네티스 버전 1.20 이상에
적용된다. 이전 버전의 쿠버네티스를 사용하는 경우 해당 쿠버네티스 버전의 문서를
참고한다.</p>
<h2 id=다음-내용>다음 내용</h2>
<ul>
<li><a href=/ko/docs/tasks/configure-pod-container/configure-pod-initialization/#%EC%B4%88%EA%B8%B0%ED%99%94-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88%EB%A5%BC-%EA%B0%96%EB%8A%94-%ED%8C%8C%EB%93%9C-%EC%83%9D%EC%84%B1>초기화 컨테이너를 가진 파드 생성하기</a></li>
<li><a href=/ko/docs/tasks/debug-application-cluster/debug-init-containers/>초기화 컨테이너 디버깅</a> 알아보기</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-c8d62295ca703fdcef1aaf89fb4c916a>3 - 파드 토폴로지 분배 제약 조건</h1>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.19 [stable]</code>
</div>
<p>사용자는 <em>토폴로지 분배 제약 조건</em> 을 사용해서 지역, 영역, 노드 그리고 기타 사용자-정의 토폴로지 도메인과 같이 장애-도메인으로 설정된 클러스터에 걸쳐 파드가 분산되는 방식을 제어할 수 있다. 이를 통해 고가용성뿐만 아니라, 효율적인 리소스 활용의 목적을 이루는 데 도움이 된다.</p>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> v1.18 이전 버전의 쿠버네티스에서는 파드 토폴로지 분배 제약조건을 사용하려면
<a href=/ko/docs/concepts/overview/components/#kube-apiserver>API 서버</a>와
<a href=/docs/reference/command-line-tools-reference/kube-scheduler/>스케줄러</a>에서
<code>EvenPodsSpread</code><a href=/ko/docs/reference/command-line-tools-reference/feature-gates/>기능 게이트</a>를
활성화해야 한다
</div>
<h2 id=필수-구성-요소>필수 구성 요소</h2>
<h3 id=노드-레이블>노드 레이블</h3>
<p>토폴로지 분배 제약 조건은 노드 레이블을 의지해서 각 노드가 속한 토폴로지 도메인(들)을 인식한다. 예를 들어, 노드에 다음과 같은 레이블을 가지고 있을 수 있다. <code>node=node1,zone=us-east-1a,region=us-east-1</code></p>
<p>다음 레이블이 있고, 4개 노드를 가지는 클러스터가 있다고 가정한다.</p>
<pre><code>NAME    STATUS   ROLES    AGE     VERSION   LABELS
node1   Ready    &lt;none&gt;   4m26s   v1.16.0   node=node1,zone=zoneA
node2   Ready    &lt;none&gt;   3m58s   v1.16.0   node=node2,zone=zoneA
node3   Ready    &lt;none&gt;   3m17s   v1.16.0   node=node3,zone=zoneB
node4   Ready    &lt;none&gt;   2m43s   v1.16.0   node=node4,zone=zoneB
</code></pre><p>그러면 클러스터는 논리적으로 다음과 같이 보이게 된다.</p>
<figure>
<div class=mermaid>
graph TB
subgraph "zoneB"
n3(Node3)
n4(Node4)
end
subgraph "zoneA"
n1(Node1)
n2(Node2)
end
classDef plain fill:#ddd,stroke:#fff,stroke-width:4px,color:#000;
classDef k8s fill:#326ce5,stroke:#fff,stroke-width:4px,color:#fff;
classDef cluster fill:#fff,stroke:#bbb,stroke-width:2px,color:#326ce5;
class n1,n2,n3,n4 k8s;
class zoneA,zoneB cluster;
</div>
</figure>
<noscript>
<div class="alert alert-secondary callout" role=alert>
<em class=javascript-required>JavaScript must be <a href=https://www.enable-javascript.com/>enabled</a> to view this content</em>
</div>
</noscript>
<p>레이블을 수동으로 적용하는 대신에, 사용자는 대부분의 클러스터에서 자동으로 생성되고 채워지는 <a href=/ko/docs/reference/labels-annotations-taints/>잘 알려진 레이블</a>을 재사용할 수 있다.</p>
<h2 id=파드의-분배-제약-조건>파드의 분배 제약 조건</h2>
<h3 id=api>API</h3>
<p>API 필드 <code>pod.spec.topologySpreadConstraints</code> 는 다음과 같이 정의된다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>topologySpreadConstraints</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>maxSkew</span>:<span style=color:#bbb> </span>&lt;integer&gt;<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>topologyKey</span>:<span style=color:#bbb> </span>&lt;string&gt;<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>whenUnsatisfiable</span>:<span style=color:#bbb> </span>&lt;string&gt;<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labelSelector</span>:<span style=color:#bbb> </span>&lt;object&gt;<span style=color:#bbb>
</span></code></pre></div><p>사용자는 하나 또는 다중 <code>topologySpreadConstraint</code> 를 정의해서 kube-scheduler 에게 클러스터에 걸쳐 있는 기존 파드와 시작하는 각각의 파드와 연관하여 배치하는 방법을 명령할 수 있다. 필드는 다음과 같다.</p>
<ul>
<li><strong>maxSkew</strong> 는 파드가 균등하지 않게 분산될 수 있는 정도를 나타낸다.
이것은 0보다는 커야 한다. 그 의미는 <code>whenUnsatisfiable</code> 의 값에 따라 다르다.
<ul>
<li><code>whenUnsatisfiable</code> 이 "DoNotSchedule"과 같을 때, <code>maxSkew</code> 는
대상 토폴로지에서 일치하는 파드 수와 전역 최솟값
(토폴로지 도메인에서 레이블 셀렉터와 일치하는 최소 파드 수. 예를 들어 3개의 영역에 각각 0, 2, 3개의 일치하는 파드가 있으면, 전역 최솟값은 0)
사이에 허용되는 최대 차이이다.</li>
<li><code>whenUnsatisfiable</code> 이 "ScheduleAnyway"와 같으면, 스케줄러는
왜곡을 줄이는데 도움이 되는 토폴로지에 더 높은 우선 순위를 부여한다.</li>
</ul>
</li>
<li><strong>topologyKey</strong> 는 노드 레이블의 키다. 만약 두 노드가 이 키로 레이블이 지정되고, 레이블이 동일한 값을 가진다면 스케줄러는 두 노드를 같은 토폴로지에 있는것으로 여기게 된다. 스케줄러는 각 토폴로지 도메인에 균형잡힌 수의 파드를 배치하려고 시도한다.</li>
<li><strong>whenUnsatisfiable</strong> 는 분산 제약 조건을 만족하지 않을 경우에 처리하는 방법을 나타낸다.
<ul>
<li><code>DoNotSchedule</code> (기본값)은 스케줄러에 스케줄링을 하지 말라고 알려준다.</li>
<li><code>ScheduleAnyway</code> 는 스케줄러에게 차이(skew)를 최소화하는 노드에 높은 우선 순위를 부여하면서, 스케줄링을 계속하도록 지시한다.</li>
</ul>
</li>
<li><strong>labelSelector</strong> 는 일치하는 파드를 찾는데 사용된다. 이 레이블 셀렉터와 일치하는 파드의 수를 계산하여 해당 토폴로지 도메인에 속할 파드의 수를 결정한다. 자세한 내용은 <a href=/ko/docs/concepts/overview/working-with-objects/labels/#%EB%A0%88%EC%9D%B4%EB%B8%94-%EC%85%80%EB%A0%89%ED%84%B0>레이블 셀렉터</a>를 참조한다.</li>
</ul>
<p>파드에 2개 이상의 <code>topologySpreadConstraint</code>가 정의되어 있으면, 각 제약 조건은 AND로 연결된다 - kube-scheduler는 새로운 파드의 모든 제약 조건을 만족하는 노드를 찾는다.</p>
<p>사용자는 <code>kubectl explain Pod.spec.topologySpreadConstraints</code> 를 실행해서 이 필드에 대한 자세한 내용을 알 수 있다.</p>
<h3 id=예시-단수-토폴로지-분배-제약-조건>예시: 단수 토폴로지 분배 제약 조건</h3>
<p>4개 노드를 가지는 클러스터에 <code>foo:bar</code> 가 레이블된 3개의 파드가 node1, node2 그리고 node3에 각각 위치한다고 가정한다.</p>
<figure>
<div class=mermaid>
graph BT
subgraph "zoneB"
p3(Pod) --> n3(Node3)
n4(Node4)
end
subgraph "zoneA"
p1(Pod) --> n1(Node1)
p2(Pod) --> n2(Node2)
end
classDef plain fill:#ddd,stroke:#fff,stroke-width:4px,color:#000;
classDef k8s fill:#326ce5,stroke:#fff,stroke-width:4px,color:#fff;
classDef cluster fill:#fff,stroke:#bbb,stroke-width:2px,color:#326ce5;
class n1,n2,n3,n4,p1,p2,p3 k8s;
class zoneA,zoneB cluster;
</div>
</figure>
<noscript>
<div class="alert alert-secondary callout" role=alert>
<em class=javascript-required>JavaScript must be <a href=https://www.enable-javascript.com/>enabled</a> to view this content</em>
</div>
</noscript>
<p>신규 파드가 기존 파드와 함께 영역에 걸쳐서 균등하게 분배되도록 하려면, 스펙(spec)은 다음과 같이 주어질 수 있다.</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/ko/examples/pods/topology-spread-constraints/one-constraint.yaml download=pods/topology-spread-constraints/one-constraint.yaml><code>pods/topology-spread-constraints/one-constraint.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-topology-spread-constraints-one-constraint-yaml')" title="Copy pods/topology-spread-constraints/one-constraint.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-topology-spread-constraints-one-constraint-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>foo</span>:<span style=color:#bbb> </span>bar<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>topologySpreadConstraints</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>maxSkew</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>topologyKey</span>:<span style=color:#bbb> </span>zone<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>whenUnsatisfiable</span>:<span style=color:#bbb> </span>DoNotSchedule<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>labelSelector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>foo</span>:<span style=color:#bbb> </span>bar<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pause<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/pause:3.1</code></pre></div>
</div>
</div>
<p><code>topologyKey: zone</code> 는 "zone:&lt;any value>" 레이블 쌍을 가지는 노드에 대해서만 균등한 분배를 적용하는 것을 의미한다. <code>whenUnsatisfiable: DoNotSchedule</code> 은 만약 들어오는 파드가 제약 조건을 만족시키지 못하면 스케줄러에게 pending 상태를 유지하도록 지시한다.</p>
<p>만약 스케줄러가 이 신규 파드를 "zoneA"에 배치하면 파드 분포는 [3, 1]이 되며, 따라서 실제 차이(skew)는 2 (3 - 1)가 되어 <code>maxSkew: 1</code> 를 위반하게 된다. 이 예시에서는 들어오는 파드는 오직 "zoneB"에만 배치할 수 있다.</p>
<figure>
<div class=mermaid>
graph BT
subgraph "zoneB"
p3(Pod) --> n3(Node3)
p4(mypod) --> n4(Node4)
end
subgraph "zoneA"
p1(Pod) --> n1(Node1)
p2(Pod) --> n2(Node2)
end
classDef plain fill:#ddd,stroke:#fff,stroke-width:4px,color:#000;
classDef k8s fill:#326ce5,stroke:#fff,stroke-width:4px,color:#fff;
classDef cluster fill:#fff,stroke:#bbb,stroke-width:2px,color:#326ce5;
class n1,n2,n3,n4,p1,p2,p3 k8s;
class p4 plain;
class zoneA,zoneB cluster;
</div>
</figure>
<noscript>
<div class="alert alert-secondary callout" role=alert>
<em class=javascript-required>JavaScript must be <a href=https://www.enable-javascript.com/>enabled</a> to view this content</em>
</div>
</noscript>
<p>OR</p>
<figure>
<div class=mermaid>
graph BT
subgraph "zoneB"
p3(Pod) --> n3(Node3)
p4(mypod) --> n3
n4(Node4)
end
subgraph "zoneA"
p1(Pod) --> n1(Node1)
p2(Pod) --> n2(Node2)
end
classDef plain fill:#ddd,stroke:#fff,stroke-width:4px,color:#000;
classDef k8s fill:#326ce5,stroke:#fff,stroke-width:4px,color:#fff;
classDef cluster fill:#fff,stroke:#bbb,stroke-width:2px,color:#326ce5;
class n1,n2,n3,n4,p1,p2,p3 k8s;
class p4 plain;
class zoneA,zoneB cluster;
</div>
</figure>
<noscript>
<div class="alert alert-secondary callout" role=alert>
<em class=javascript-required>JavaScript must be <a href=https://www.enable-javascript.com/>enabled</a> to view this content</em>
</div>
</noscript>
<p>사용자는 파드 스펙을 조정해서 다음과 같은 다양한 요구사항을 충족할 수 있다.</p>
<ul>
<li><code>maxSkew</code> 를 "2" 보다 큰 값으로 변경해서 들어오는 파드들이 "zoneA"에도 배치할 수 있도록 한다.</li>
<li><code>topologyKey</code> 를 "node"로 변경해서 파드가 영역이 아닌, 노드에 걸쳐 고르게 분산할 수 있게 한다. 위의 예시에서 만약 <code>maxSkew</code> 가 "1"로 유지되면 들어오는 파드는 오직 "node4"에만 배치할 수 있다.</li>
<li><code>whenUnsatisfiable: DoNotSchedule</code> 에서 <code>whenUnsatisfiable: ScheduleAnyway</code> 로 변경하면 들어오는 파드는 항상 다른 스케줄링 API를 충족한다는 가정하에 스케줄할 수 있도록 보장한다. 그러나 일치하는 파드가 적은 토폴로지 도메인에 배치되는 것이 좋다. (이 선호도는 리소스 사용 비율 등과 같은 다른 내부 스케줄링 우선순위와 공동으로 정규화 된다는 것을 알아두자.)</li>
</ul>
<h3 id=예시-다중-토폴로지-분배-제약-조건>예시: 다중 토폴로지 분배 제약 조건</h3>
<p>4개 노드를 가지는 클러스터에 <code>foo:bar</code> 가 레이블된 3개의 파드가 node1, node2 그리고 node3에 각각 위치한다고 가정한다.</p>
<figure>
<div class=mermaid>
graph BT
subgraph "zoneB"
p3(Pod) --> n3(Node3)
n4(Node4)
end
subgraph "zoneA"
p1(Pod) --> n1(Node1)
p2(Pod) --> n2(Node2)
end
classDef plain fill:#ddd,stroke:#fff,stroke-width:4px,color:#000;
classDef k8s fill:#326ce5,stroke:#fff,stroke-width:4px,color:#fff;
classDef cluster fill:#fff,stroke:#bbb,stroke-width:2px,color:#326ce5;
class n1,n2,n3,n4,p1,p2,p3 k8s;
class p4 plain;
class zoneA,zoneB cluster;
</div>
</figure>
<noscript>
<div class="alert alert-secondary callout" role=alert>
<em class=javascript-required>JavaScript must be <a href=https://www.enable-javascript.com/>enabled</a> to view this content</em>
</div>
</noscript>
<p>사용자는 2개의 TopologySpreadConstraints를 사용해서 영역과 노드에 파드를 분배하는 것을 제어할 수 있다.</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/ko/examples/pods/topology-spread-constraints/two-constraints.yaml download=pods/topology-spread-constraints/two-constraints.yaml><code>pods/topology-spread-constraints/two-constraints.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-topology-spread-constraints-two-constraints-yaml')" title="Copy pods/topology-spread-constraints/two-constraints.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-topology-spread-constraints-two-constraints-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>foo</span>:<span style=color:#bbb> </span>bar<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>topologySpreadConstraints</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>maxSkew</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>topologyKey</span>:<span style=color:#bbb> </span>zone<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>whenUnsatisfiable</span>:<span style=color:#bbb> </span>DoNotSchedule<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>labelSelector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>foo</span>:<span style=color:#bbb> </span>bar<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>maxSkew</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>topologyKey</span>:<span style=color:#bbb> </span>node<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>whenUnsatisfiable</span>:<span style=color:#bbb> </span>DoNotSchedule<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>labelSelector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>foo</span>:<span style=color:#bbb> </span>bar<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pause<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/pause:3.1</code></pre></div>
</div>
</div>
<p>이 경우에는, 첫 번째 제약 조건에 부합시키려면, 신규 파드는 오직 "zoneB"에만 배치할 수 있다. 두 번째 제약 조건에서는 신규 파드는 오직 "node4"에만 배치할 수 있다. 그런 다음 두 가지 제약 조건의 결과는 AND 가 되므로, 실행 가능한 유일한 옵션은 "node4"에 배치하는 것이다.</p>
<p>다중 제약 조건은 충돌로 이어질 수 있다. 3개의 노드를 가지는 클러스터 하나가 2개의 영역에 걸쳐 있다고 가정한다.</p>
<figure>
<div class=mermaid>
graph BT
subgraph "zoneB"
p4(Pod) --> n3(Node3)
p5(Pod) --> n3
end
subgraph "zoneA"
p1(Pod) --> n1(Node1)
p2(Pod) --> n1
p3(Pod) --> n2(Node2)
end
classDef plain fill:#ddd,stroke:#fff,stroke-width:4px,color:#000;
classDef k8s fill:#326ce5,stroke:#fff,stroke-width:4px,color:#fff;
classDef cluster fill:#fff,stroke:#bbb,stroke-width:2px,color:#326ce5;
class n1,n2,n3,n4,p1,p2,p3,p4,p5 k8s;
class zoneA,zoneB cluster;
</div>
</figure>
<noscript>
<div class="alert alert-secondary callout" role=alert>
<em class=javascript-required>JavaScript must be <a href=https://www.enable-javascript.com/>enabled</a> to view this content</em>
</div>
</noscript>
<p>만약 사용자가 "two-constraints.yaml" 을 이 클러스터에 적용하면, "mypod"가 <code>Pending</code> 상태로 유지되는 것을 알게 된다. 이러한 이유는, 첫 번째 제약 조건을 충족하기 위해 "mypod"는 오직 "zoneB"에만 놓을 수 있다. 두 번째 제약 조건에서는 "mypod"는 오직 "node2"에만 놓을 수 있다. 그러면 "zoneB"와 "node2"의 공동 결과는 아무것도 반환되지 않는다.</p>
<p>이 상황을 극복하기 위해서는 사용자가 <code>maxSkew</code> 의 증가 또는 <code>whenUnsatisfiable: ScheduleAnyway</code> 를 사용하도록 제약 조건 중 하나를 수정할 수 있다.</p>
<h3 id=노드-어피니티-affinity-및-노드-셀렉터-selector-와의-상호-작용>노드 어피니티(Affinity) 및 노드 셀렉터(Selector)와의 상호 작용</h3>
<p>스케줄러는 신규 파드에 <code>spec.nodeSelector</code> 또는 <code>spec.affinity.nodeAffinity</code>가 정의되어 있는 경우, 부합하지 않는 노드들을 차이(skew) 계산에서 생략한다.</p>
<h3 id=예시-topologyspreadconstraints와-노드-어피니티>예시: TopologySpreadConstraints와 노드 어피니티</h3>
<p>zoneA 에서 zoneC에 걸쳐있고, 5개의 노드를 가지는 클러스터가 있다고 가정한다.</p>
<figure>
<div class=mermaid>
graph BT
subgraph "zoneB"
p3(Pod) --> n3(Node3)
n4(Node4)
end
subgraph "zoneA"
p1(Pod) --> n1(Node1)
p2(Pod) --> n2(Node2)
end
classDef plain fill:#ddd,stroke:#fff,stroke-width:4px,color:#000;
classDef k8s fill:#326ce5,stroke:#fff,stroke-width:4px,color:#fff;
classDef cluster fill:#fff,stroke:#bbb,stroke-width:2px,color:#326ce5;
class n1,n2,n3,n4,p1,p2,p3 k8s;
class p4 plain;
class zoneA,zoneB cluster;
</div>
</figure>
<noscript>
<div class="alert alert-secondary callout" role=alert>
<em class=javascript-required>JavaScript must be <a href=https://www.enable-javascript.com/>enabled</a> to view this content</em>
</div>
</noscript>
<figure>
<div class=mermaid>
graph BT
subgraph "zoneC"
n5(Node5)
end
classDef plain fill:#ddd,stroke:#fff,stroke-width:4px,color:#000;
classDef k8s fill:#326ce5,stroke:#fff,stroke-width:4px,color:#fff;
classDef cluster fill:#fff,stroke:#bbb,stroke-width:2px,color:#326ce5;
class n5 k8s;
class zoneC cluster;
</div>
</figure>
<noscript>
<div class="alert alert-secondary callout" role=alert>
<em class=javascript-required>JavaScript must be <a href=https://www.enable-javascript.com/>enabled</a> to view this content</em>
</div>
</noscript>
<p>그리고 알다시피 "zoneC"는 제외해야 한다. 이 경우에, "mypod"가 "zoneC"가 아닌 "zoneB"에 배치되도록 yaml을 다음과 같이 구성할 수 있다. 마찬가지로 <code>spec.nodeSelector</code> 도 존중된다.</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/ko/examples/pods/topology-spread-constraints/one-constraint-with-nodeaffinity.yaml download=pods/topology-spread-constraints/one-constraint-with-nodeaffinity.yaml><code>pods/topology-spread-constraints/one-constraint-with-nodeaffinity.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-topology-spread-constraints-one-constraint-with-nodeaffinity-yaml')" title="Copy pods/topology-spread-constraints/one-constraint-with-nodeaffinity.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-topology-spread-constraints-one-constraint-with-nodeaffinity-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>foo</span>:<span style=color:#bbb> </span>bar<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>topologySpreadConstraints</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>maxSkew</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>topologyKey</span>:<span style=color:#bbb> </span>zone<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>whenUnsatisfiable</span>:<span style=color:#bbb> </span>DoNotSchedule<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>labelSelector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>foo</span>:<span style=color:#bbb> </span>bar<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>affinity</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>nodeAffinity</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requiredDuringSchedulingIgnoredDuringExecution</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>nodeSelectorTerms</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>zone<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span>NotIn<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>values</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span>- zoneC<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pause<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/pause:3.1</code></pre></div>
</div>
</div>
<p>스케줄러는 클러스터에 있는 모든 영역(zone) 또는 다른 토폴로지 도메인에 대한 사전 지식이 없다. 스케줄링은 클러스터의 기존 노드에서 결정된다. 노드 풀(또는 노드 그룹)이 0개의 노드로 스케일(scale)되고 사용자는 노드가 확장될 것으로 예상하는 경우, 자동 스케일되는 클러스터에서 문제가 발생할 수 있다. 이러한 토폴로지 도메인은 스케줄링에서 해당 도메인에 노드가 하나 이상 있을 때까지 고려되지 않을 것이기 때문이다.</p>
<h3 id=기타-눈에-띄는-의미-semantics>기타 눈에 띄는 의미(semantics)</h3>
<p>여기에 주목할만한 몇 가지 암묵적인 규칙이 있다.</p>
<ul>
<li>
<p>신규 파드와 같은 네임스페이스를 갖는 파드만이 매칭의 후보가 된다.</p>
</li>
<li>
<p><code>topologySpreadConstraints[*].topologyKey</code> 가 없는 노드는 무시된다. 이것은 다음을 의미한다.</p>
<ol>
<li>이러한 노드에 위치한 파드는 "maxSkew" 계산에 영향을 미치지 않는다. - 위의 예시에서, "node1"은 "zone" 레이블을 가지고 있지 않다고 가정하면, 파드 2개는 무시될 것이고, 이런 이유로 신규 파드는 "zoneA"로 스케줄된다.</li>
<li>신규 파드는 이런 종류의 노드에 스케줄 될 기회가 없다. - 위의 예시에서, 레이블로 <code>{zone-typo: zoneC}</code> 를 가지는 "node5"가 클러스터에 편입한다고 가정하면, 레이블 키에 "zone"이 없기 때문에 무시하게 된다.</li>
</ol>
</li>
<li>
<p>들어오는 파드의 <code>topologySpreadConstraints[*].labelSelector</code> 와 자체 레이블과 일치하지 않을 경우 어떻게 되는지 알고 있어야 한다. 위의 예시에서, 만약 들어오는 파드의 레이블을 제거하더라도 여전히 제약 조건이 충족하기 때문에 "zoneB"에 배치할 수 있다. 그러나, 배치 이후에도 클러스터의 불균형 정도는 변경되지 않는다. - 여전히 zoneA는 {foo:bar} 레이블을 가지고 있는 2개의 파드를 가지고 있고, zoneB 도 {foo:bar}를 레이블로 가지는 파드 1개를 가지고 있다. 따라서 만약 예상과 다르면, 워크로드의 <code>topologySpreadConstraints[*].labelSelector</code> 가 자체 레이블과 일치하도록 하는 것을 권장한다.</p>
</li>
</ul>
<h3 id=클러스터-수준의-기본-제약-조건>클러스터 수준의 기본 제약 조건</h3>
<p>클러스터에 대한 기본 토폴로지 분배 제약 조건을 설정할 수 있다. 기본
토폴로지 분배 제약 조건은 다음과 같은 경우에만 파드에 적용된다.</p>
<ul>
<li><code>.spec.topologySpreadConstraints</code> 에는 어떠한 제약도 정의되어 있지 않는 경우.</li>
<li>서비스, 레플리케이션컨트롤러(ReplicationController), 레플리카셋(ReplicaSet) 또는 스테이트풀셋(StatefulSet)에 속해있는 경우.</li>
</ul>
<p>기본 제약 조건은 <a href=/ko/docs/reference/scheduling/config/#%ED%94%84%EB%A1%9C%ED%8C%8C%EC%9D%BC>스케줄링 프로파일</a>에서
<code>PodTopologySpread</code> 플러그인의 일부로 설정할 수 있다.
제약 조건은 <code>labelSelector</code> 가 비어 있어야 한다는 점을 제외하고, <a href=#api>위와 동일한 API</a>로
제약 조건을 지정한다. 셀렉터는 파드가 속한 서비스, 레플리케이션 컨트롤러,
레플리카셋 또는 스테이트풀셋에서 계산한다.</p>
<p>예시 구성은 다음과 같다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>kubescheduler.config.k8s.io/v1beta1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>KubeSchedulerConfiguration<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>profiles</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>pluginConfig</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>PodTopologySpread<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>defaultConstraints</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span>- <span style=color:green;font-weight:700>maxSkew</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>topologyKey</span>:<span style=color:#bbb> </span>topology.kubernetes.io/zone<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>whenUnsatisfiable</span>:<span style=color:#bbb> </span>ScheduleAnyway<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>defaultingType</span>:<span style=color:#bbb> </span>List<span style=color:#bbb>
</span></code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> 기본 스케줄링 제약 조건에 의해 생성된 점수는
<a href=/ko/docs/reference/scheduling/config/#%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81-%ED%94%8C%EB%9F%AC%EA%B7%B8%EC%9D%B8><code>SelectorSpread</code> 플러그인</a>에
의해 생성된 점수와 충돌 할 수 있다.
<code>PodTopologySpread</code> 에 대한 기본 제약 조건을 사용할 때 스케줄링 프로파일에서
이 플러그인을 비활성화 하는 것을 권장한다.
</div>
<h4 id=내부-기본-제약>내부 기본 제약</h4>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.20 [beta]</code>
</div>
<p>기본적으로 활성화된 <code>DefaultPodTopologySpread</code> 기능 게이트를 사용하면, 기존
<code>SelectorSpread</code> 플러그인이 비활성화된다.
kube-scheduler는 <code>PodTopologySpread</code> 플러그인 구성에 다음과 같은
기본 토폴로지 제약 조건을 사용한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>defaultConstraints</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>maxSkew</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>topologyKey</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;kubernetes.io/hostname&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>whenUnsatisfiable</span>:<span style=color:#bbb> </span>ScheduleAnyway<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>maxSkew</span>:<span style=color:#bbb> </span><span style=color:#666>5</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>topologyKey</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;topology.kubernetes.io/zone&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>whenUnsatisfiable</span>:<span style=color:#bbb> </span>ScheduleAnyway<span style=color:#bbb>
</span></code></pre></div><p>또한, 같은 동작을 제공하는 레거시 <code>SelectorSpread</code> 플러그인이
비활성화된다.</p>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> <p><code>PodTopologySpread</code> 플러그인은 분배 제약 조건에 지정된 토폴로지 키가
없는 노드에 점수를 매기지 않는다.
이로 인해 기본 토폴로지 제약을 사용하는 경우의
레거시 <code>SelectorSpread</code> 플러그인과는 기본 정책이 다를 수 있다.</p>
<p>노드에 <code>kubernetes.io/hostname</code> 및 <code>topology.kubernetes.io/zone</code>
레이블 세트 <strong>둘 다</strong>가 설정되지 않을 것으로 예상되는 경우, 쿠버네티스 기본값을 사용하는
대신 자체 제약 조건을 정의한다.</p>
</div>
<p>클러스터에 기본 파드 분배 제약 조건을 사용하지 않으려면,
<code>PodTopologySpread</code> 플러그인 구성에서 <code>defaultingType</code> 을 <code>List</code> 로 설정하고
<code>defaultConstraints</code> 를 비워두어 기본값을 비활성화할 수 있다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>kubescheduler.config.k8s.io/v1beta1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>KubeSchedulerConfiguration<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>profiles</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>pluginConfig</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>PodTopologySpread<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>defaultConstraints</span>:<span style=color:#bbb> </span>[]<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>defaultingType</span>:<span style=color:#bbb> </span>List<span style=color:#bbb>
</span></code></pre></div><h2 id=파드어피니티-podaffinity-파드안티어피니티-podantiaffinity-와의-비교>파드어피니티(PodAffinity)/파드안티어피니티(PodAntiAffinity)와의 비교</h2>
<p>쿠버네티스에서 "어피니티(Affinity)"와 관련된 지침은 파드가
더 많이 채워지거나 더 많이 분산되는 방식으로 스케줄 되는 방법을 제어한다.</p>
<ul>
<li><code>PodAffinity</code> 는, 사용자가 자격이 충족되는 토폴로지 도메인에
원하는 수의 파드를 얼마든지 채울 수 있다.</li>
<li><code>PodAntiAffinity</code> 로는, 단일 토폴로지 도메인에
단 하나의 파드만 스케줄 될 수 있다.</li>
</ul>
<p>더 세밀한 제어를 위해, 토폴로지 분배 제약 조건을 지정하여 다양한 토폴로지 도메인에 파드를
분배해서 고 가용성 또는 비용 절감을 달성할 수 있는 유연한 옵션을
제공한다. 또한 워크로드의 롤링 업데이트와 레플리카의 원활한 스케일링 아웃에 도움이 될 수 있다.
더 자세한 내용은
<a href=https://github.com/kubernetes/enhancements/tree/master/keps/sig-scheduling/895-pod-topology-spread#motivation>모티베이션(Motivation)</a>를
참고한다.</p>
<h2 id=알려진-제한사항>알려진 제한사항</h2>
<ul>
<li>파드가 제거된 이후에도 제약 조건이 계속 충족된다는 보장은 없다. 예를 들어 디플로이먼트를 스케일링 다운하면 그 결과로 파드의 분포가 불균형해질 수 있다.
<a href=https://github.com/kubernetes-sigs/descheduler>Descheduler</a>를 사용하여 파드 분포를 다시 균형있게 만들 수 있다.</li>
<li>파드와 일치하는 테인트(taint)가 된 노드가 존중된다. <a href=https://github.com/kubernetes/kubernetes/issues/80921>이슈 80921</a>을 본다.</li>
</ul>
<h2 id=다음-내용>다음 내용</h2>
<ul>
<li><a href=https://kubernetes.io/blog/2020/05/introducing-podtopologyspread/>블로그: PodTopologySpread 소개</a>에서는
<code>maxSkew</code> 에 대해 자세히 설명하고, 몇 가지 고급 사용 예제를 제공한다.</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-4aaf43c715cd764bc8ed4436f3537e68>4 - 중단(disruption)</h1>
<p>이 가이드는 고가용성 애플리케이션을 구성하려는 소유자와
파드에서 발생하는 장애 유형을 이해하기
원하는 애플리케이션 소유자를 위한 것이다.</p>
<p>또한 클러스터의 업그레이드와 오토스케일링과 같은
클러스터의 자동화 작업을 하려는 관리자를 위한 것이다.</p>
<h2 id=자발적-중단과-비자발적-중단>자발적 중단과 비자발적 중단</h2>
<p>파드는 누군가(사람 또는 컨트롤러)가 파괴하거나
불가피한 하드웨어 오류 또는 시스템 소프트웨어 오류가 아니면 사라지지 않는다.</p>
<p>우리는 이런 불가피한 상황을 애플리케이션의 <em>비자발적 중단</em> 으로 부른다.
예시:</p>
<ul>
<li>노드를 지원하는 물리 머신의 하드웨어 오류</li>
<li>클러스터 관리자의 실수로 VM(인스턴스) 삭제</li>
<li>클라우드 공급자 또는 하이퍼바이저의 오류로 인한 VM 장애</li>
<li>커널 패닉</li>
<li>클러스터 네트워크 파티션의 발생으로 클러스터에서 노드가 사라짐</li>
<li>노드의 <a href=/ko/docs/concepts/scheduling-eviction/node-pressure-eviction/>리소스 부족</a>으로 파드가 축출됨</li>
</ul>
<p>리소스 부족을 제외한 나머지 조건은 대부분의 사용자가 익숙할 것이다.
왜냐하면
그 조건은 쿠버네티스에 국한되지 않기 때문이다.</p>
<p>우리는 다른 상황을 <em>자발적인 중단</em> 으로 부른다.
여기에는 애플리케이션 소유자의 작업과 클러스터 관리자의 작업이 모두 포함된다.
다음은 대표적인 애플리케이션 소유자의 작업이다.</p>
<ul>
<li>디플로이먼트 제거 또는 다른 파드를 관리하는 컨트롤러의 제거</li>
<li>재시작을 유발하는 디플로이먼트의 파드 템플릿 업데이트</li>
<li>파드를 직접 삭제(예: 우연히)</li>
</ul>
<p>클러스터 관리자의 작업은 다음을 포함한다.</p>
<ul>
<li>복구 또는 업그레이드를 위한 <a href=/docs/tasks/administer-cluster/safely-drain-node/>노드 드레이닝</a>.</li>
<li>클러스터의 스케일 축소를 위한
노드 드레이닝(<a href=https://github.com/kubernetes/autoscaler/#readme>클러스터 오토스케일링</a>에 대해 알아보기
).</li>
<li>노드에 다른 무언가를 추가하기 위해 파드를 제거.</li>
</ul>
<p>위 작업은 클러스터 관리자가 직접 수행하거나 자동화를 통해 수행하며,
클러스터 호스팅 공급자에 의해서도 수행된다.</p>
<p>클러스터에 자발적인 중단을 일으킬 수 있는 어떤 원인이 있는지
클러스터 관리자에게 문의하거나 클라우드 공급자에게 문의하고, 배포 문서를 참조해서 확인해야 한다.
만약 자발적인 중단을 일으킬 수 있는 원인이 없다면 Pod Disruption Budget의 생성을 넘길 수 있다.</p>
<div class="alert alert-warning caution callout" role=alert>
<strong>주의:</strong> 모든 자발적인 중단이 Pod Disruption Budget에 연관되는 것은 아니다.
예를 들어 디플로이먼트 또는 파드의 삭제는 Pod Disruption Budget을 무시한다.
</div>
<h2 id=중단-다루기>중단 다루기</h2>
<p>비자발적인 중단으로 인한 영향을 경감하기 위한 몇 가지 방법은 다음과 같다.</p>
<ul>
<li>파드가 필요로 하는 <a href=/ko/docs/tasks/configure-pod-container/assign-memory-resource/>리소스를 요청</a>하는지 확인한다.</li>
<li>고가용성이 필요한 경우 애플리케이션을 복제한다.
(복제된 <a href=/ko/docs/tasks/run-application/run-stateless-application-deployment/>스테이트리스</a> 및
<a href=/docs/tasks/run-application/run-replicated-stateful-application/>스테이트풀</a> 애플리케이션에 대해 알아보기.)</li>
<li>복제된 애플리케이션의 구동 시 훨씬 더 높은 가용성을 위해 랙 전체
(<a href=/ko/docs/concepts/scheduling-eviction/assign-pod-node/#%ED%8C%8C%EB%93%9C%EA%B0%84-%EC%96%B4%ED%94%BC%EB%8B%88%ED%8B%B0%EC%99%80-%EC%95%88%ED%8B%B0-%EC%96%B4%ED%94%BC%EB%8B%88%ED%8B%B0>안티-어피니티</a> 이용)
또는 영역 간
(<a href=/ko/docs/setup/best-practices/multiple-zones/>다중 영역 클러스터</a>를 이용한다면)에
애플리케이션을 분산해야 한다.</li>
</ul>
<p>자발적 중단의 빈도는 다양하다. 기본적인 쿠버네티스 클러스터에서는 자동화된 자발적 중단은 발생하지 않는다(사용자가 지시한 자발적 중단만 발생한다).
그러나 클러스터 관리자 또는 호스팅 공급자가 자발적 중단이 발생할 수 있는 일부 부가 서비스를 운영할 수 있다.
예를 들어 노드 소프트웨어의 업데이트를 출시하는 경우 자발적 중단이 발생할 수 있다.
또한 클러스터(노드) 오토스케일링의 일부 구현에서는
단편화를 제거하고 노드의 효율을 높이는 과정에서 자발적 중단을 야기할 수 있다.
클러스터 관리자 또는 호스팅 공급자는
예측 가능한 자발적 중단 수준에 대해 문서화해야 한다.
파드 스펙 안에 <a href=/ko/docs/concepts/scheduling-eviction/pod-priority-preemption/>프라이어리티클래스 사용하기</a>와 같은 특정 환경설정 옵션
또한 자발적(+ 비자발적) 중단을 유발할 수 있다.</p>
<h2 id=파드-disruption-budgets>파드 disruption budgets</h2>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.21 [stable]</code>
</div>
<p>쿠버네티스는 자발적인 중단이 자주 발생하는 경우에도 고 가용성 애플리케이션을
실행하는 데 도움이 되는 기능을 제공한다.</p>
<p>애플리케이션 소유자로써, 사용자는 각 애플리케이션에 대해 PodDisruptionBudget(PDB)을 만들 수 있다.
PDB는 자발적 중단으로
일시에 중지되는 복제된 애플리케이션 파드의 수를 제한한다.
예를 들어, 정족수 기반의 애플리케이션이
실행 중인 레플리카의 수가 정족수 이하로 떨어지지 않도록 한다.
웹 프런트 엔드는 부하를 처리하는 레플리카의 수가
일정 비율 이하로 떨어지지 않도록 보장할 수 있다.</p>
<p>클러스터 관리자와 호스팅 공급자는 직접적으로 파드나 디플로이먼트를 제거하는 대신
<a href=/docs/tasks/administer-cluster/safely-drain-node/#eviction-api>Eviction API</a>로
불리는 PodDisruptionBudget을 준수하는 도구를 이용해야 한다.</p>
<p>예를 들어, <code>kubectl drain</code> 하위 명령을 사용하면 노드를 서비스 중단으로 표시할 수
있다. <code>kubectl drain</code> 을 실행하면, 도구는 사용자가 서비스를 중단하는 노드의
모든 파드를 축출하려고 한다. <code>kubectl</code> 이 사용자를 대신하여 수행하는
축출 요청은 일시적으로 거부될 수 있으며,
도구는 대상 노드의 모든 파드가 종료되거나
설정 가능한 타임아웃이 도래할 때까지 주기적으로 모든 실패된 요청을 다시 시도한다.</p>
<p>PDB는 애플리케이션이 필요로 하는 레플리카의 수에 상대적으로, 용인할 수 있는 레플리카의 수를 지정한다.
예를 들어 <code>.spec.replicas: 5</code> 의 값을 갖는 디플로이먼트는 어느 시점에든 5개의 파드를 가져야 한다.
만약 해당 디플로이먼트의 PDB가 특정 시점에 파드를 4개 허용한다면,
Eviction API는 한 번에 1개(2개의 파드가 아닌)의 파드의 자발적인 중단을 허용한다.</p>
<p>파드 그룹은 레이블 셀렉터를 사용해서 지정한 애플리케이션으로 구성되며
애플리케이션 컨트롤러(디플로이먼트, 스테이트풀셋 등)를 사용한 것과 같다.</p>
<p>파드의 "의도"하는 수량은 해당 파드를 관리하는 워크로드 리소스의 <code>.spec.replicas</code> 를
기반으로 계산한다. 컨트롤 플레인은 파드의 <code>.metadata.ownerReferences</code> 를 검사하여
소유하는 워크로드 리소스를 발견한다.</p>
<p><a href=#%EC%9E%90%EB%B0%9C%EC%A0%81-%EC%A4%91%EB%8B%A8%EA%B3%BC-%EB%B9%84%EC%9E%90%EB%B0%9C%EC%A0%81-%EC%A4%91%EB%8B%A8>비자발적 중단</a>은 PDB로는 막을 수 없지만,
버짓은 차감된다.</p>
<p>애플리케이션의 롤링 업그레이드로 파드가 삭제되거나 사용할 수 없는 경우 중단 버짓에 영향을 준다.
그러나 워크로드 리소스(디플로이먼트, 스테이트풀셋과 같은)는
롤링 업데이트 시 PDB의 제한을 받지 않는다. 대신, 애플리케이션 업데이트 중
실패 처리는 특정 워크로드 리소스에 대한 명세에서 구성된다.</p>
<p>Eviction API를 사용하여 파드를 축출하면,
<a href=/docs/reference/generated/kubernetes-api/v1.23/#podspec-v1-core>PodSpec</a>의
<code>terminationGracePeriodSeconds</code> 설정을 준수하여 정상적으로 <a href=/ko/docs/concepts/workloads/pods/pod-lifecycle/#%ED%8C%8C%EB%93%9C%EC%9D%98-%EC%A2%85%EB%A3%8C>종료됨</a> 상태가 된다.</p>
<h2 id=pdb-example>PodDisruptionBudget 예시</h2>
<p><code>node-1</code> 부터 <code>node-3</code> 까지 3개의 노드가 있는 클러스터가 있다고 하자.
클러스터에는 여러 애플리케이션을 실행하고 있다.
여러 애플리케이션 중 하나는 <code>pod-a</code>, <code>pod-b</code>, <code>pod-c</code> 로 부르는 3개의 레플리카가 있다. 여기에 <code>pod-x</code> 라고 부르는 PDB와 무관한 파드가 보인다.
초기에 파드는 다음과 같이 배치된다.</p>
<table>
<thead>
<tr>
<th style=text-align:center>node-1</th>
<th style=text-align:center>node-2</th>
<th style=text-align:center>node-3</th>
</tr>
</thead>
<tbody>
<tr>
<td style=text-align:center>pod-a <em>available</em></td>
<td style=text-align:center>pod-b <em>available</em></td>
<td style=text-align:center>pod-c <em>available</em></td>
</tr>
<tr>
<td style=text-align:center>pod-x <em>available</em></td>
<td style=text-align:center></td>
<td style=text-align:center></td>
</tr>
</tbody>
</table>
<p>전체 3개 파드는 디플로이먼트의 일부분으로
전체적으로 항상 3개의 파드 중 최소 2개의 파드를 사용할 수 있도록 하는 PDB를 가지고 있다.</p>
<p>예를 들어, 클러스터 관리자가 커널 버그를 수정하기위해 새 커널 버전으로 재부팅하려는 경우를 가정해보자.
클러스터 관리자는 첫째로 <code>node-1</code> 을 <code>kubectl drain</code> 명령어를 사용해서 비우려 한다.
<code>kubectl</code> 은 <code>pod-a</code> 과 <code>pod-x</code> 를 축출하려고 한다. 이는 즉시 성공한다.
두 파드는 동시에 <code>terminating</code> 상태로 진입한다.
이렇게 하면 클러스터는 다음의 상태가 된다.</p>
<table>
<thead>
<tr>
<th style=text-align:center>node-1 <em>draining</em></th>
<th style=text-align:center>node-2</th>
<th style=text-align:center>node-3</th>
</tr>
</thead>
<tbody>
<tr>
<td style=text-align:center>pod-a <em>terminating</em></td>
<td style=text-align:center>pod-b <em>available</em></td>
<td style=text-align:center>pod-c <em>available</em></td>
</tr>
<tr>
<td style=text-align:center>pod-x <em>terminating</em></td>
<td style=text-align:center></td>
<td style=text-align:center></td>
</tr>
</tbody>
</table>
<p>디플로이먼트는 한 개의 파드가 중지되는 것을 알게되고, <code>pod-d</code> 라는 대체 파드를 생성한다.
<code>node-1</code> 은 차단되어 있어 다른 노드에 위치한다.
무언가가 <code>pod-x</code> 의 대체 파드로 <code>pod-y</code> 도 생성했다.</p>
<p>(참고: 스테이트풀셋은 <code>pod-0</code> 처럼 불릴, <code>pod-a</code> 를
교체하기 전에 완전히 중지해야 하며, <code>pod-0</code> 로 불리지만, 다른 UID로 생성된다.
그렇지 않으면 이 예시는 스테이트풀셋에도 적용된다.)</p>
<p>이제 클러스터는 다음과 같은 상태이다.</p>
<table>
<thead>
<tr>
<th style=text-align:center>node-1 <em>draining</em></th>
<th style=text-align:center>node-2</th>
<th style=text-align:center>node-3</th>
</tr>
</thead>
<tbody>
<tr>
<td style=text-align:center>pod-a <em>terminating</em></td>
<td style=text-align:center>pod-b <em>available</em></td>
<td style=text-align:center>pod-c <em>available</em></td>
</tr>
<tr>
<td style=text-align:center>pod-x <em>terminating</em></td>
<td style=text-align:center>pod-d <em>starting</em></td>
<td style=text-align:center>pod-y</td>
</tr>
</tbody>
</table>
<p>어느 순간 파드가 종료되고, 클러스터는 다음과 같은 상태가 된다.</p>
<table>
<thead>
<tr>
<th style=text-align:center>node-1 <em>drained</em></th>
<th style=text-align:center>node-2</th>
<th style=text-align:center>node-3</th>
</tr>
</thead>
<tbody>
<tr>
<td style=text-align:center></td>
<td style=text-align:center>pod-b <em>available</em></td>
<td style=text-align:center>pod-c <em>available</em></td>
</tr>
<tr>
<td style=text-align:center></td>
<td style=text-align:center>pod-d <em>starting</em></td>
<td style=text-align:center>pod-y</td>
</tr>
</tbody>
</table>
<p>이 시점에서 만약 성급한 클러스터 관리자가 <code>node-2</code> 또는 <code>node-3</code> 을
비우려고 하는 경우 디플로이먼트에 available 상태의 파드가 2개 뿐이고,
PDB에 필요한 최소 파드는 2개이기 때문에 drain 명령이 차단된다. 약간의 시간이 지나면 <code>pod-d</code> 가 available 상태가 된다.</p>
<p>이제 클러스터는 다음과 같은 상태이다.</p>
<table>
<thead>
<tr>
<th style=text-align:center>node-1 <em>drained</em></th>
<th style=text-align:center>node-2</th>
<th style=text-align:center>node-3</th>
</tr>
</thead>
<tbody>
<tr>
<td style=text-align:center></td>
<td style=text-align:center>pod-b <em>available</em></td>
<td style=text-align:center>pod-c <em>available</em></td>
</tr>
<tr>
<td style=text-align:center></td>
<td style=text-align:center>pod-d <em>available</em></td>
<td style=text-align:center>pod-y</td>
</tr>
</tbody>
</table>
<p>이제 클러스터 관리자는 <code>node-2</code> 를 비우려고 한다.
drain 커멘드는 <code>pod-b</code> 에서 <code>pod-d</code> 와 같이 어떤 순서대로 두 파드를 축출하려 할 것이다.
drain 커멘드는 <code>pod-b</code> 를 축출하는데 성공했다.
그러나 drain 커멘드가 <code>pod-d</code> 를 축출하려 하는 경우
디플로이먼트에 available 상태의 파드는 1개로 축출이 거부된다.</p>
<p>디플로이먼트는<code>pod-b</code> 를 대체할 <code>pod-e</code> 라는 파드를 생성한다.
클러스터에 <code>pod-e</code> 를 스케줄하기 위한 충분한 리소스가 없기 때문에
드레이닝 명령어는 차단된다.
클러스터는 다음 상태로 끝나게 된다.</p>
<table>
<thead>
<tr>
<th style=text-align:center>node-1 <em>drained</em></th>
<th style=text-align:center>node-2</th>
<th style=text-align:center>node-3</th>
<th style=text-align:center><em>no node</em></th>
</tr>
</thead>
<tbody>
<tr>
<td style=text-align:center></td>
<td style=text-align:center>pod-b <em>terminating</em></td>
<td style=text-align:center>pod-c <em>available</em></td>
<td style=text-align:center>pod-e <em>pending</em></td>
</tr>
<tr>
<td style=text-align:center></td>
<td style=text-align:center>pod-d <em>available</em></td>
<td style=text-align:center>pod-y</td>
<td style=text-align:center></td>
</tr>
</tbody>
</table>
<p>이 시점에서 클러스터 관리자는
클러스터에 노드를 추가해서 업그레이드를 진행해야 한다.</p>
<p>쿠버네티스에 중단이 발생할 수 있는 비율을 어떻게 변화시키는지
다음의 사례를 통해 알 수 있다.</p>
<ul>
<li>애플리케이션에 필요한 레플리카의 수</li>
<li>인스턴스를 정상적으로 종료하는데 소요되는 시간</li>
<li>새 인스턴스를 시작하는데 소요되는 시간</li>
<li>컨트롤러의 유형</li>
<li>클러스터의 리소스 용량</li>
</ul>
<h2 id=클러스터-소유자와-애플리케이션-소유자의-역할-분리>클러스터 소유자와 애플리케이션 소유자의 역할 분리</h2>
<p>보통 클러스터 매니저와 애플리케이션 소유자는
서로에 대한 지식이 부족한 별도의 역할로 생각하는 것이 유용하다.
이와 같은 책임의 분리는
다음의 시나리오에서 타당할 수 있다.</p>
<ul>
<li>쿠버네티스 클러스터를 공유하는 애플리케이션 팀이 많고, 자연스럽게 역할이 나누어진 경우</li>
<li>타사 도구 또는 타사 서비스를 이용해서
클러스터 관리를 자동화 하는 경우</li>
</ul>
<p>Pod Disruption Budget은 역할 분리에 따라
역할에 맞는 인터페이스를 제공한다.</p>
<p>만약 조직에 역할 분리에 따른 책임의 분리가 없다면
Pod Disruption Budget을 사용할 필요가 없다.</p>
<h2 id=클러스터에서-중단이-발생할-수-있는-작업을-하는-방법>클러스터에서 중단이 발생할 수 있는 작업을 하는 방법</h2>
<p>만약 클러스터 관리자라면, 그리고 클러스터 전체 노드에 노드 또는 시스템 소프트웨어 업그레이드와 같은
중단이 발생할 수 있는 작업을 수행하는 경우 다음과 같은 옵션을 선택한다.</p>
<ul>
<li>업그레이드 하는 동안 다운타임을 허용한다.</li>
<li>다른 레플리카 클러스터로 장애조치를 한다.
<ul>
<li>다운타임은 없지만, 노드 사본과
전환 작업을 조정하기 위한 인력 비용이 많이 발생할 수 있다.</li>
</ul>
</li>
<li>PDB를 이용해서 애플리케이션의 중단에 견디도록 작성한다.
<ul>
<li>다운타임 없음</li>
<li>최소한의 리소스 중복</li>
<li>클러스터 관리의 자동화 확대 적용</li>
<li>내결함성이 있는 애플리케이션의 작성은 까다롭지만
자발적 중단를 허용하는 작업의 대부분은 오토스케일링과
비자발적 중단를 지원하는 작업과 겹친다.</li>
</ul>
</li>
</ul>
<h2 id=다음-내용>다음 내용</h2>
<ul>
<li>
<p><a href=/docs/tasks/run-application/configure-pdb/>Pod Disruption Budget 설정하기</a>의 단계를 따라서 애플리케이션을 보호한다.</p>
</li>
<li>
<p><a href=/docs/tasks/administer-cluster/safely-drain-node/>노드 비우기</a>에 대해 자세히 알아보기</p>
</li>
<li>
<p>롤아웃 중에 가용성을 유지하는 단계를 포함하여
<a href=/ko/docs/concepts/workloads/controllers/deployment/#%EB%94%94%ED%94%8C%EB%A1%9C%EC%9D%B4%EB%A8%BC%ED%8A%B8-%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8>디플로이먼트 업데이트</a>에 대해 알아보기</p>
</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-53a1005011e1bda2ce81819aad7c8b32>5 - 임시(Ephemeral) 컨테이너</h1>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.23 [beta]</code>
</div>
<p>이 페이지는 임시 컨테이너에 대한 개요를 제공한다.
이 특별한 유형의 컨테이너는 트러블슈팅과 같은 사용자가 시작한 작업을 완료하기 위해
기존 <a class=glossary-tooltip title="파드는 클러스터에서 실행 중인 컨테이너의 집합을 나타낸다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/pods/ target=_blank aria-label=파드>파드</a>에서 임시적으로 실행된다.
임시 컨테이너는 애플리케이션을 빌드하는 경우보다는 서비스 점검과 같은 경우에 더 적합하다.</p>
<h2 id=임시-컨테이너-이해하기>임시 컨테이너 이해하기</h2>
<p><a class=glossary-tooltip title="파드는 클러스터에서 실행 중인 컨테이너의 집합을 나타낸다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/pods/ target=_blank aria-label=파드>파드</a> 는 쿠버네티스 애플리케이션의
기본 구성 요소이다. 파드는 일회용이고, 교체 가능한 것으로 의도되었기
때문에, 사용자는 파드가 한번 생성되면, 컨테이너를 추가할 수 없다.
대신, 사용자는 보통 <a class=glossary-tooltip title="클러스터에서 복제된 애플리케이션을 관리한다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/controllers/deployment/ target=_blank aria-label=디플로이먼트>디플로이먼트</a> 를
사용해서 제어하는 방식으로 파드를 삭제하고 교체한다.</p>
<p>그러나 때때로 재현하기 어려운 버그의 문제 해결을 위해
기존 파드의 상태를 검사해야 할 수 있다. 이 경우 사용자는
기존 파드에서 임시 컨테이너를 실행해서 상태를 검사하고, 임의의 명령을
실행할 수 있다.</p>
<h3 id=임시-컨테이너는-무엇인가>임시 컨테이너는 무엇인가?</h3>
<p>임시 컨테이너는 리소스 또는 실행에 대한 보증이 없다는 점에서
다른 컨테이너와 다르며, 결코 자동으로 재시작되지 않는다. 그래서
애플리케이션을 만드는데 적합하지 않다. 임시 컨테이너는
일반 컨테이너와 동일한 <code>ContainerSpec</code> 을 사용해서 명시하지만, 많은 필드가
호환되지 않으며 임시 컨테이너에는 허용되지 않는다.</p>
<ul>
<li>임시 컨테이너는 포트를 가지지 않을 수 있으므로, <code>ports</code>,
<code>livenessProbe</code>, <code>readinessProbe</code> 와 같은 필드는 허용되지 않는다.</li>
<li>파드에 할당된 리소스는 변경할 수 없으므로, <code>resources</code> 설정이 허용되지 않는다.</li>
<li>허용되는 필드의 전체 목록은 <a href=/docs/reference/generated/kubernetes-api/v1.23/#ephemeralcontainer-v1-core>임시컨테이너 참조
문서</a>를 본다.</li>
</ul>
<p>임시 컨테이너는 <code>pod.spec</code> 에 직접 추가하는 대신
API에서 특별한 <code>ephemeralcontainers</code> 핸들러를 사용해서 만들어지기 때문에
<code>kubectl edit</code>을 사용해서 임시 컨테이너를 추가할 수 없다.</p>
<p>일반 컨테이너와 마찬가지로, 사용자는 임시 컨테이너를 파드에 추가한
이후에 변경하거나 제거할 수 없다.</p>
<h2 id=임시-컨테이너의-사용>임시 컨테이너의 사용</h2>
<p>임시 컨테이너는 컨테이너가 충돌 되거나 또는 컨테이너 이미지에
디버깅 도구가 포함되지 않은 이유로 <code>kubectl exec</code> 이 불충분할 때
대화형 문제 해결에 유용하다.</p>
<p>특히, <a href=https://github.com/GoogleContainerTools/distroless>distroless 이미지</a>
를 사용하면 공격 표면(attack surface)과 버그 및 취약점의 노출을 줄이는 최소한의
컨테이너 이미지를 배포할 수 있다. distroless 이미지는 셸 또는 어떤 디버깅 도구를
포함하지 않기 때문에, <code>kubectl exec</code> 만으로는 distroless
이미지의 문제 해결이 어렵다.</p>
<p>임시 컨테이너 사용 시 <a href=/docs/tasks/configure-pod-container/share-process-namespace/>프로세스 네임스페이스
공유</a>를
활성화하면 다른 컨테이너 안의 프로세스를 보는 데 도움이 된다.</p>
<h2 id=다음-내용>다음 내용</h2>
<ul>
<li><a href=/ko/docs/tasks/debug-application-cluster/debug-running-pod/#ephemeral-container>임시 컨테이너 디버깅하기</a>에 대해 알아보기.</li>
</ul>
</div>
</main>
</div>
</div>
<footer class=d-print-none>
<div class=footer__links>
<nav>
<a class=text-white href=/ko/docs/home/>홈</a>
<a class=text-white href=/ko/blog/>블로그</a>
<a class=text-white href=/ko/training/>교육</a>
<a class=text-white href=/ko/partners/>파트너</a>
<a class=text-white href=/ko/community/>커뮤니티</a>
<a class=text-white href=/ko/case-studies/>사례 연구</a>
</nav>
</div>
<div class=container-fluid>
<div class=row>
<div class="col-6 col-sm-2 text-xs-center order-sm-2">
<ul class="list-inline mb-0">
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="User mailing list" aria-label="User mailing list">
<a class=text-white target=_blank href=https://discuss.kubernetes.io>
<i class="fa fa-envelope"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Twitter aria-label=Twitter>
<a class=text-white target=_blank href=https://twitter.com/kubernetesio>
<i class="fab fa-twitter"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Calendar aria-label=Calendar>
<a class=text-white target=_blank href="https://calendar.google.com/calendar/embed?src=calendar%40kubernetes.io">
<i class="fas fa-calendar-alt"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Youtube aria-label=Youtube>
<a class=text-white target=_blank href=https://youtube.com/kubernetescommunity>
<i class="fab fa-youtube"></i>
</a>
</li>
</ul>
</div>
<div class="col-6 col-sm-2 text-right text-xs-center order-sm-3">
<ul class="list-inline mb-0">
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub>
<a class=text-white target=_blank href=https://github.com/kubernetes/kubernetes>
<i class="fab fa-github"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Slack aria-label=Slack>
<a class=text-white target=_blank href=https://slack.k8s.io>
<i class="fab fa-slack"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Contribute aria-label=Contribute>
<a class=text-white target=_blank href=https://git.k8s.io/community/contributors/guide>
<i class="fas fa-edit"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Stack Overflow" aria-label="Stack Overflow">
<a class=text-white target=_blank href=https://stackoverflow.com/questions/tagged/kubernetes>
<i class="fab fa-stack-overflow"></i>
</a>
</li>
</ul>
</div>
<div class="col-12 col-sm-8 text-center order-sm-2">
<small class=text-white>&copy; 2023 The Kubernetes Authors | Documentation Distributed under <a href=https://git.k8s.io/website/LICENSE class=light-text>CC BY 4.0</a></small>
<br>
<small class=text-white>Copyright &copy; 2023 The Linux Foundation &reg;. All rights reserved. The Linux Foundation has registered trademarks and uses trademarks. For a list of trademarks of The Linux Foundation, please see our <a href=https://www.linuxfoundation.org/trademark-usage class=light-text>Trademark Usage page</a></small>
<br>
<small class=text-white>ICP license: 京ICP备17074266号-3</small>
</div>
</div>
</div>
</footer>
</div>
<script src=/js/popper-1.14.3.min.js integrity=sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49 crossorigin=anonymous></script>
<script src=/js/bootstrap-4.3.1.min.js integrity=sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM crossorigin=anonymous></script>
<script src=/js/main.min.40616251a9b6e4b689e7769be0340661efa4d7ebb73f957404e963e135b4ed52.js integrity="sha256-QGFiUam25LaJ53ab4DQGYe+k1+u3P5V0BOlj4TW07VI=" crossorigin=anonymous></script>
<script async src=/js/sweetalert-2.1.2.min.js></script>
<script type=text/javascript>function copyCode(c){var d,a,b;if(document.getElementById(c)){d="_hiddenCopyText_",a=document.getElementById(d),a||(a=document.createElement("textarea"),a.style.position="absolute",a.style.left="-9999px",a.style.top="0",a.id=d,document.body.appendChild(a)),a.value=document.getElementById(c).innerText,a.select();try{b=document.execCommand("copy")}catch(a){swal("Oh, no…","Sorry, your browser doesn't support copying this example to your clipboard."),b=!1}return b?(swal("Copied to clipboard: ",c),b):(swal("Oops!",c+" not found when trying to copy code"),!1)}}</script>
</body>
</html>