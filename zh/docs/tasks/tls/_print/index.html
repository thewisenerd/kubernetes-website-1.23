<!doctype html><html lang=zh class=no-js>
<head>
<meta name=ROBOTS content="NOINDEX, NOFOLLOW">
<script async src="https://www.googletagmanager.com/gtag/js?id=G-JPP6RFM2BP"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-JPP6RFM2BP')</script>
<link rel=alternate hreflang=en href=https://kubernetes.io/docs/tasks/tls/>
<link rel=alternate hreflang=ko href=https://kubernetes.io/ko/docs/tasks/tls/>
<link rel=alternate hreflang=ja href=https://kubernetes.io/ja/docs/tasks/tls/>
<link rel=alternate hreflang=fr href=https://kubernetes.io/fr/docs/tasks/tls/>
<link rel=alternate hreflang=de href=https://kubernetes.io/de/docs/tasks/tls/>
<link rel=alternate hreflang=es href=https://kubernetes.io/es/docs/tasks/tls/>
<link rel=alternate hreflang=id href=https://kubernetes.io/id/docs/tasks/tls/>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=generator content="Hugo 0.87.0">
<link rel=canonical type=text/html href=https://kubernetes.io/zh/docs/tasks/tls/>
<link rel="shortcut icon" type=image/png href=/images/favicon.png>
<link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180>
<link rel=manifest href=/manifest.webmanifest>
<link rel=apple-touch-icon href=/images/kubernetes-192x192.png>
<title>TLS | Kubernetes</title><meta property="og:title" content="TLS">
<meta property="og:description" content="了解如何使用传输层安全性（ TLS ）保护集群中的流量。">
<meta property="og:type" content="website">
<meta property="og:url" content="https://kubernetes.io/zh/docs/tasks/tls/"><meta property="og:site_name" content="Kubernetes">
<meta itemprop=name content="TLS">
<meta itemprop=description content="了解如何使用传输层安全性（ TLS ）保护集群中的流量。"><meta name=twitter:card content="summary">
<meta name=twitter:title content="TLS">
<meta name=twitter:description content="了解如何使用传输层安全性（ TLS ）保护集群中的流量。">
<link href=/scss/main.css rel=stylesheet>
<script src=/js/jquery-3.3.1.min.js integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin=anonymous></script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","url":"https://kubernetes.io","logo":"https://kubernetes.io/images/favicon.png"}</script>
<meta name=theme-color content="#326ce5">
<link rel=stylesheet href=/css/feature-states.css>
<meta name=description content="了解如何使用传输层安全性（ TLS ）保护集群中的流量。">
<meta property="og:description" content="了解如何使用传输层安全性（ TLS ）保护集群中的流量。">
<meta name=twitter:description content="了解如何使用传输层安全性（ TLS ）保护集群中的流量。">
<meta property="og:url" content="https://kubernetes.io/zh/docs/tasks/tls/">
<meta property="og:title" content="TLS">
<meta name=twitter:title content="TLS">
<meta name=twitter:image content="https://kubernetes.io/images/favicon.png">
<meta name=twitter:image:alt content="Kubernetes">
<meta property="og:image" content="/images/kubernetes-horizontal-color.png">
<meta property="og:type" content="article">
<script src=/js/script.js></script>
</head>
<body class=td-section>
<header>
<nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar" data-auto-burger=primary>
<a class=navbar-brand href=/zh/></a>
<div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar>
<ul class="navbar-nav mt-2 mt-lg-0">
<li class="nav-item mr-2 mb-lg-0">
<a class="nav-link active" href=/zh/docs/>文档</a>
</li>
<li class="nav-item mr-2 mb-lg-0">
<a class=nav-link href=/zh/blog/>Kubernetes 博客</a>
</li>
<li class="nav-item mr-2 mb-lg-0">
<a class=nav-link href=/zh/training/>培训</a>
</li>
<li class="nav-item mr-2 mb-lg-0">
<a class=nav-link href=/zh/partners/>合作伙伴</a>
</li>
<li class="nav-item mr-2 mb-lg-0">
<a class=nav-link href=/zh/community/>社区</a>
</li>
<li class="nav-item mr-2 mb-lg-0">
<a class=nav-link href=/zh/case-studies/>案例分析</a>
</li>
<li class="nav-item dropdown">
<a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>
Versions
</a>
<div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink>
<a class=dropdown-item href=/releases>Release Information</a>
<a class=dropdown-item href=https://kubernetes.io/zh/docs/tasks/tls/>v1.27</a>
<a class=dropdown-item href=https://v1-26.docs.kubernetes.io/zh/docs/tasks/tls/>v1.26</a>
<a class=dropdown-item href=https://v1-25.docs.kubernetes.io/zh/docs/tasks/tls/>v1.25</a>
<a class=dropdown-item href=https://v1-24.docs.kubernetes.io/zh/docs/tasks/tls/>v1.24</a>
<a class=dropdown-item href=https://v1-23.docs.kubernetes.io/zh/docs/tasks/tls/>v1.23</a>
</div>
</li>
<li class="nav-item dropdown">
<a class="nav-link dropdown-toggle" href=# id=navbarDropdownMenuLink role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>
中文 Chinese
</a>
<div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink>
<a class=dropdown-item href=/docs/tasks/tls/>English</a>
<a class=dropdown-item href=/ko/docs/tasks/tls/>한국어 Korean</a>
<a class=dropdown-item href=/ja/docs/tasks/tls/>日本語 Japanese</a>
<a class=dropdown-item href=/fr/docs/tasks/tls/>Français</a>
<a class=dropdown-item href=/de/docs/tasks/tls/>Deutsch</a>
<a class=dropdown-item href=/es/docs/tasks/tls/>Español</a>
<a class=dropdown-item href=/id/docs/tasks/tls/>Bahasa Indonesia</a>
</div>
</li>
</ul>
</div>
<button id=hamburger onclick=kub.toggleMenu() data-auto-burger-exclude><div></div></button>
</nav>
</header>
<div class="container-fluid td-outer">
<div class=td-main>
<div class="row flex-xl-nowrap">
<main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main>
<div class=td-content>
<div class="pageinfo pageinfo-primary d-print-none">
<p>
这是本节的多页打印视图。
<a href=# onclick="return print(),!1">点击此处打印</a>.
</p><p>
<a href=/zh/docs/tasks/tls/>返回本页常规视图</a>.
</p>
</div>
<h1 class=title>TLS</h1>
<div class=lead>了解如何使用传输层安全性（ TLS ）保护集群中的流量。</div>
<ul>
<li>1: <a href=#pg-1272b18ac0c008f6ffc2c62a29fa929f>为 kubelet 配置证书轮换</a></li>
<li>2: <a href=#pg-43d5e2b1fc2a7e104e66d481d08578dc>手动轮换 CA 证书</a></li>
<li>3: <a href=#pg-9a87de8ee8332cb487f34a05debb1125>管理集群中的 TLS 认证</a></li>
</ul>
<div class=content>
</div>
</div>
<div class=td-content>
<h1 id=pg-1272b18ac0c008f6ffc2c62a29fa929f>1 - 为 kubelet 配置证书轮换</h1>
<p>本文展示如何在 kubelet 中启用并配置证书轮换。</p>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.19 [stable]</code>
</div>
<h2 id=before-you-begin>Before you begin</h2>
<ul>
<li>要求 Kubernetes 1.8.0 或更高的版本</li>
</ul>
<h2 id=概述>概述</h2>
<p>Kubelet 使用证书进行 Kubernetes API 的认证。
默认情况下，这些证书的签发期限为一年，所以不需要太频繁地进行更新。</p>
<p>Kubernetes 包含特性
<a href=/zh/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/>kubelet 证书轮换</a>，
在当前证书即将过期时，
将自动生成新的秘钥，并从 Kubernetes API 申请新的证书。 一旦新的证书可用，它将被用于与
Kubernetes API 间的连接认证。</p>
<h2 id=启用客户端证书轮换>启用客户端证书轮换</h2>
<p><code>kubelet</code> 进程接收 <code>--rotate-certificates</code> 参数，该参数决定 kubelet 在当前使用的
证书即将到期时，是否会自动申请新的证书。</p>
<p><code>kube-controller-manager</code> 进程接收 <code>--cluster-signing-duration</code> 参数
（在 1.19 版本之前为 <code>--experimental-cluster-signing-duration</code>），用来
控制签发证书的有效期限。</p>
<h2 id=理解证书轮换配置>理解证书轮换配置</h2>
<p>当 kubelet 启动时，如被配置为自举（使用<code>--bootstrap-kubeconfig</code> 参数），kubelet
会使用其初始证书连接到 Kubernetes API ，并发送证书签名的请求。
可以通过以下方式查看证书签名请求的状态：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get csr
</code></pre></div>
<p>最初，来自节点上 kubelet 的证书签名请求处于 <code>Pending</code> 状态。 如果证书签名请求满足特定条件，
控制器管理器会自动批准，此时请求会处于 <code>Approved</code> 状态。 接下来，控制器管理器会签署证书，
证书的有效期限由 <code>--cluster-signing-duration</code> 参数指定，签署的证书会被附加到证书签名请求中。</p>
<p>Kubelet 会从 Kubernetes API 取回签署的证书，并将其写入磁盘，存储位置通过 <code>--cert-dir</code>
参数指定。
然后 kubelet 会使用新的证书连接到 Kubernetes API。</p>
<p>当签署的证书即将到期时，kubelet 会使用 Kubernetes API，自动发起新的证书签名请求。
该请求会发生在证书的有效时间剩下 30% 到 10% 之间的任意时间点。
同样地，控制器管理器会自动批准证书请求，并将签署的证书附加到证书签名请求中。 Kubelet
会从 Kubernetes API 取回签署的证书，并将其写入磁盘。 然后它会更新与 Kubernetes API
的连接，使用新的证书重新连接到 Kubernetes API。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-43d5e2b1fc2a7e104e66d481d08578dc>2 - 手动轮换 CA 证书</h1>
<p>本页展示如何手动轮换证书机构（CA）证书。</p>
<h2 id=before-you-begin>Before you begin</h2>
<p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li>
</ul>
Your Kubernetes server must be at or later than version v1.13.
To check the version, enter <code>kubectl version</code>.
</p>
<ul>
<li>要了解 Kubernetes 中用户认证的更多信息，参阅
<a href=/zh/docs/reference/access-authn-authz/authentication>认证</a>；</li>
<li>要了解与 CA 证书最佳实践有关的更多信息，参阅<a href=/zh/docs/setup/best-practices/certificates/#single-root-ca>单根 CA</a>。</li>
</ul>
<h2 id=rotate-the-ca-certificates-manually>手动轮换 CA 证书 </h2>
<div class="alert alert-warning caution callout" role=alert>
<strong>Caution:</strong> <p>确保备份你的证书目录、配置文件以及其他必要文件。</p>
<p>这里的方法假定 Kubernetes 的控制面通过运行多个 API 服务器以高可用配置模式运行。
另一假定是 API 服务器可体面地终止，因而客户端可以彻底地与一个 API 服务器断开
连接并连接到另一个 API 服务器。</p>
<p>如果集群中只有一个 API 服务器，则在 API 服务器重启期间会经历服务中断期。</p>
</div>
<ol>
<li>将新的 CA 证书和私钥（例如：<code>ca.crt</code>、<code>ca.key</code>、<code>front-proxy-ca.crt</code> 和
<code>front-proxy-client.key</code>）分发到所有控制面节点，放在其 Kubernetes 证书目录下。</li>
</ol>
<ol start=2>
<li>
<p>更新 <a class=glossary-tooltip title=主节点上运行控制器的组件。 data-toggle=tooltip data-placement=top href=/docs/reference/generated/kube-controller-manager/ target=_blank aria-label=kube-controller-manager>kube-controller-manager</a> 的
<code>--root-ca-file</code> 标志，使之同时包含老的和新的 CA，之后重启组件。</p>
<p>自此刻起，所创建的所有服务账号都会获得同时包含老的 CA 和新的 CA 的 Secret。</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> kube-controller-manager 标志 <code>--client-ca-file</code> 和 <code>--cluster-signing-cert-file</code> 所引用的文件
不能是 CA 证书包。如果这些标志和 <code>--root-ca-file</code> 指向同一个 <code>ca.crt</code> 包文件（包含老的和新的 CA 证书），
你将会收到出错信息。
要解决这个问题，可以将新的 CA 证书复制到单独的文件中，并将 <code>--client-ca-file</code> 和 <code>--cluster-signing-cert-file</code>
标志指向该副本。一旦 <code>ca.crt</code> 不再是证书包文件，就可以恢复有问题的标志指向 <code>ca.crt</code> 并删除该副本。
</div>
</li>
</ol>
<ol start=3>
<li>
<p>更新所有服务账号令牌，使之同时包含老的和新的 CA 证书。</p>
<p>如果在 API 服务器使用新的 CA 之前启动了新的 Pod，这些 Pod
也会获得此更新并且同时信任老的和新的 CA 证书。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#b8860b>base64_encoded_ca</span><span style=color:#666>=</span><span style=color:#b44>&#34;</span><span style=color:#a2f;font-weight:700>$(</span>base64 -w0 &lt;path to file containing both old and new CAs&gt;<span style=color:#a2f;font-weight:700>)</span><span style=color:#b44>&#34;</span>

<span style=color:#a2f;font-weight:700>for</span> namespace in <span style=color:#a2f;font-weight:700>$(</span>kubectl get ns --no-headers | awk <span style=color:#b44>&#39;{print $1}&#39;</span><span style=color:#a2f;font-weight:700>)</span>; <span style=color:#a2f;font-weight:700>do</span>
    <span style=color:#a2f;font-weight:700>for</span> token in <span style=color:#a2f;font-weight:700>$(</span>kubectl get secrets --namespace <span style=color:#b44>&#34;</span><span style=color:#b8860b>$namespace</span><span style=color:#b44>&#34;</span> --field-selector <span style=color:#b8860b>type</span><span style=color:#666>=</span>kubernetes.io/service-account-token -o name<span style=color:#a2f;font-weight:700>)</span>; <span style=color:#a2f;font-weight:700>do</span>
        kubectl get <span style=color:#b8860b>$token</span> --namespace <span style=color:#b44>&#34;</span><span style=color:#b8860b>$namespace</span><span style=color:#b44>&#34;</span> -o yaml | <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>          /bin/sed <span style=color:#b44>&#34;s/\(ca.crt:\).*/\1 </span><span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>base64_encoded_ca</span><span style=color:#b68;font-weight:700>}</span><span style=color:#b44>/&#34;</span> | <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>          kubectl apply -f -
    <span style=color:#a2f;font-weight:700>done</span>
<span style=color:#a2f;font-weight:700>done</span>
</code></pre></div></li>
</ol>
<ol start=4>
<li>
<p>重启所有使用集群内配置的 Pods（例如：<code>kube-proxy</code>、<code>coredns</code> 等），以便这些 Pod 能够使用
来自 <em>ServiceAccount</em> Secret 中的、已更新的证书机构数据。</p>
<ul>
<li>确保 <code>coredns</code>、<code>kube-proxy</code> 和其他使用集群内配置的 Pod 都正按预期方式工作。</li>
</ul>
</li>
<li>
<p>将老的和新的 CA 都追加到 <code>kube-apiserver</code> 配置的 <code>--client-ca-file</code> 和 <code>--kubelet-certificate-authority</code> 标志所指的文件。</p>
</li>
<li>
<p>将老的和新的 CA 都追加到 <code>kube-scheduler</code> 配置的 <code>--client-ca-file</code> 标志所指的文件。</p>
</li>
</ol>
<ol start=7>
<li>
<p>通过替换 <code>client-certificate-data</code> 和 <code>client-key-data</code>
中的内容，更新用户账号的证书。</p>
<p>有关为独立用户账号创建证书的更多信息，可参阅
<a href=/zh/docs/setup/best-practices/certificates/#configure-certificates-for-user-accounts>为用户帐号配置证书</a>。</p>
<p>另外，还要更新 kubeconfig 文件中的 <code>certificate-authority-data</code>
节，使之包含 Base64 编码的老的和新的证书机构数据。</p>
</li>
</ol>
<ol start=8>
<li>
<p>遵循下列步骤执行滚动更新</p>
<ol>
<li>
<p>重新启动所有其他 <em><a href=/zh/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/>被聚合的 API 服务器</a></em>
或者 <em>Webhook 处理程序</em>，使之信任新的 CA 证书。</p>
</li>
<li>
<p>在所有节点上更新 kubelet 配置中的 <code>clientCAFile</code> 所指文件以及 kubelet.conf 中的
<code>certificate-authority-data</code> 并重启 kubelet 以同时使用老的和新的 CA 证书。</p>
<p>如果你的 kubelet 并未使用客户端证书轮换，则在所有节点上更新 kubelet.conf 中
<code>client-certificate-data</code> 和 <code>client-key-data</code> 以及 kubelet
客户端证书文件（通常位于 <code>/var/lib/kubelet/pki</code> 目录下）</p>
</li>
</ol>
<ol start=3>
<li>
<p>使用用新的 CA 签名的证书
（<code>apiserver.crt</code>、<code>apiserver-kubelet-client.crt</code> 和 <code>front-proxy-client.crt</code>）
来重启 API 服务器。
你可以使用现有的私钥，也可以使用新的私钥。
如果你改变了私钥，则要将更新的私钥也放到 Kubernetes 证书目录下。</p>
<p>由于 Pod 既信任老的 CA 也信任新的 CA，Pod 中的客户端会经历短暂的连接断开状态，
之后再连接到使用新的 CA 所签名的证书的新的 API 服务器。</p>
<ul>
<li>重启调度器以使用新的 CA 证书。</li>
<li>确保控制面组件的日志中没有 TLS 相关的错误信息。</li>
</ul>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 要使用 <code>openssl</code> 命令行为集群生成新的证书和私钥，可参阅
<a href=/zh/docs/tasks/administer-cluster/certificates/#openssl>证书（<code>openssl</code>）</a>。
你也可以使用<a href=/zh/docs/tasks/administer-cluster/certificates/#cfssl><code>cfssl</code></a>.
</div>
</li>
</ol>
<ol start=4>
<li>
<p>为 Daemonset 和 Deployment 添加注解，从而触发较安全的滚动更新，替换 Pod。</p>
<p>示例：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#a2f;font-weight:700>for</span> namespace in <span style=color:#a2f;font-weight:700>$(</span>kubectl get namespace -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.items[*].metadata.name}&#39;</span><span style=color:#a2f;font-weight:700>)</span>; <span style=color:#a2f;font-weight:700>do</span>
    <span style=color:#a2f;font-weight:700>for</span> name in <span style=color:#a2f;font-weight:700>$(</span>kubectl get deployments -n <span style=color:#b8860b>$namespace</span> -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.items[*].metadata.name}&#39;</span><span style=color:#a2f;font-weight:700>)</span>; <span style=color:#a2f;font-weight:700>do</span>
        kubectl patch deployment -n <span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>namespace</span><span style=color:#b68;font-weight:700>}</span> <span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>name</span><span style=color:#b68;font-weight:700>}</span> -p <span style=color:#b44>&#39;{&#34;spec&#34;:{&#34;template&#34;:{&#34;metadata&#34;:{&#34;annotations&#34;:{&#34;ca-rotation&#34;: &#34;1&#34;}}}}}&#39;</span>;
    <span style=color:#a2f;font-weight:700>done</span>
    <span style=color:#a2f;font-weight:700>for</span> name in <span style=color:#a2f;font-weight:700>$(</span>kubectl get daemonset -n <span style=color:#b8860b>$namespace</span> -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.items[*].metadata.name}&#39;</span><span style=color:#a2f;font-weight:700>)</span>; <span style=color:#a2f;font-weight:700>do</span>
        kubectl patch daemonset -n <span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>namespace</span><span style=color:#b68;font-weight:700>}</span> <span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>name</span><span style=color:#b68;font-weight:700>}</span> -p <span style=color:#b44>&#39;{&#34;spec&#34;:{&#34;template&#34;:{&#34;metadata&#34;:{&#34;annotations&#34;:{&#34;ca-rotation&#34;: &#34;1&#34;}}}}}&#39;</span>;
    <span style=color:#a2f;font-weight:700>done</span>
<span style=color:#a2f;font-weight:700>done</span>
</code></pre></div>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 要限制应用可能受到的并发干扰数量，可以参阅
<a href=/zh/docs/tasks/run-application/configure-pdb/>配置 Pod 干扰预算</a>.
</div>
</li>
</ol>
</li>
</ol>
<ol start=9>
<li>
<p>如果你的集群使用启动引导令牌来添加节点，则需要更新 <code>kube-public</code> 名字空间下的
ConfigMap <code>cluster-info</code>，使之包含新的 CA 证书。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#b8860b>base64_encoded_ca</span><span style=color:#666>=</span><span style=color:#b44>&#34;</span><span style=color:#a2f;font-weight:700>$(</span>base64 -w0 /etc/kubernetes/pki/ca.crt<span style=color:#a2f;font-weight:700>)</span><span style=color:#b44>&#34;</span>

kubectl get cm/cluster-info --namespace kube-public -o yaml | <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>    /bin/sed <span style=color:#b44>&#34;s/\(certificate-authority-data:\).*/\1 </span><span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>base64_encoded_ca</span><span style=color:#b68;font-weight:700>}</span><span style=color:#b44>/&#34;</span> | <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>    kubectl apply -f -
</code></pre></div></li>
</ol>
<ol start=10>
<li>
<p>验证集群的功能正常</p>
<ol>
<li>
<p>验证控制面组件的日志，以及 <code>kubelet</code> 和 <code>kube-proxy</code> 的日志，确保其中没有
抛出 TLS 错误，参阅
<a href=/zh/docs/tasks/debug-application-cluster/debug-cluster/#looking-at-logs>查看日志</a>.</p>
</li>
<li>
<p>验证被聚合的 API 服务器的日志，以及所有使用集群内配置的 Pod 的日志。</p>
</li>
</ol>
</li>
</ol>
<ol start=11>
<li>
<p>完成集群功能的检查之后：</p>
<ol>
<li>
<p>更新所有的服务账号令牌，使之仅包含新的 CA 证书。</p>
<ul>
<li>使用集群内 kubeconfig 的 Pod 最终也需要被重启，以获得新的服务账号 Secret
数据，进而不再信任老的 CA 证书。</li>
</ul>
</li>
<li>
<p>从 kubeconfig 文件和 <code>--client-ca-file</code> 以及 <code>--root-ca-file</code> 标志所指向的文件
中去除老的 CA 数据，之后重启控制面组件。</p>
</li>
<li>
<p>重启 kubelet，移除 <code>clientCAFile</code> 标志所指向的文件以及 kubelet kubeconfig 文件中
的老的 CA 数据。</p>
</li>
</ol>
</li>
</ol>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-9a87de8ee8332cb487f34a05debb1125>3 - 管理集群中的 TLS 认证</h1>
<p>Kubernetes 提供 <code>certificates.k8s.io</code> API，可让你配置由你控制的证书颁发机构（CA）
签名的 TLS 证书。 你的工作负载可以使用这些 CA 和证书来建立信任。</p>
<p><code>certificates.k8s.io</code> API使用的协议类似于
<a href=https://github.com/ietf-wg-acme/acme/>ACME 草案</a>。</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong>
<p>使用 <code>certificates.k8s.io</code> API 创建的证书由指定 <a href=#a-note-to-cluster-administrators>CA</a> 颁发。
将集群配置为使用集群根目录 CA 可以达到这个目的，但是你永远不要依赖这一假定。
不要以为这些证书将针对群根目录 CA 进行验证。
</div>
<h2 id=before-you-begin>Before you begin</h2>
<p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li>
</ul>
<p>你需要 <code>cfssl</code> 工具。
你可以从 <a href=https://github.com/cloudflare/cfssl/releases>https://github.com/cloudflare/cfssl/releases</a>
下载 <code>cfssl</code>。</p>
<p>本文中某些步骤使用 <code>jq</code> 工具。如果你没有 <code>jq</code>，你可以通过操作系统的软件源安装，
或者从 <a href=https://stedolan.github.io/jq/>https://stedolan.github.io/jq/</a> 获取。</p>
<h2 id=集群中的-tls-信任>集群中的 TLS 信任</h2>
<p>信任 Pod 中运行的应用程序所提供的<a href=#a-note-to-cluster-administrators>自定义 CA</a> 通常需要一些额外的应用程序配置。
你需要将 CA 证书包添加到 TLS 客户端或服务器信任的 CA 证书列表中。
例如，你可以使用 Golang TLS 配置通过解析证书链并将解析的证书添加到
<a href=https://pkg.go.dev/crypto/tls#Config><code>tls.Config</code></a> 结构中的 <code>RootCAs</code>
字段中。</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong>
<p>即使自定义 CA 证书可能包含在文件系统中（在 ConfigMap <code>kube-root-ca.crt</code> 中），
除了验证内部 Kubernetes 端点之外，你不应将该证书颁发机构用于任何目的。
内部 Kubernetes 端点的一个示例是默认命名空间中名为 <code>kubernetes</code> 的服务。</p>
<p>如果你想为你的工作负载使用自定义证书颁发机构，你应该单独生成该 CA，
并使用你的 Pod 有读权限的 <a href=/zh/docs/tasks/configure-pod-container/configure-pod-configmap>ConfigMap</a>
分发该 CA 证书。</p>
</div>
<h2 id=请求证书>请求证书</h2>
<p>以下部分演示如何为通过 DNS 访问的 Kubernetes 服务创建 TLS 证书。</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 本教程使用 CFSSL：Cloudflare's PKI 和 TLS 工具包
<a href=https://blog.cloudflare.com/introducing-cfssl/>点击此处</a>了解更多信息。
</div>
<h2 id=创建证书签名请求>创建证书签名请求</h2>
<p>通过运行以下命令生成私钥和证书签名请求（或 CSR）:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>cat <span style=color:#b44>&lt;&lt;EOF | cfssl genkey - | cfssljson -bare server
</span><span style=color:#b44>{
</span><span style=color:#b44>  &#34;hosts&#34;: [
</span><span style=color:#b44>    &#34;my-svc.my-namespace.svc.cluster.local&#34;,
</span><span style=color:#b44>    &#34;my-pod.my-namespace.pod.cluster.local&#34;,
</span><span style=color:#b44>    &#34;192.0.2.24&#34;,
</span><span style=color:#b44>    &#34;10.0.34.2&#34;
</span><span style=color:#b44>  ],
</span><span style=color:#b44>  &#34;CN&#34;: &#34;my-pod.my-namespace.pod.cluster.local&#34;,
</span><span style=color:#b44>  &#34;key&#34;: {
</span><span style=color:#b44>    &#34;algo&#34;: &#34;ecdsa&#34;,
</span><span style=color:#b44>    &#34;size&#34;: 256
</span><span style=color:#b44>  }
</span><span style=color:#b44>}
</span><span style=color:#b44>EOF</span>
</code></pre></div>
<p>其中 <code>192.0.2.24</code> 是服务的集群 IP，<code>my-svc.my-namespace.svc.cluster.local</code>
是服务的 DNS 名称，<code>10.0.34.2</code> 是 Pod 的 IP，而
<code>my-pod.my-namespace.pod.cluster.local</code> 是 Pod 的 DNS 名称。
你能看到的输出类似于：</p>
<pre><code>2022/02/01 11:45:32 [INFO] generate received request
2022/02/01 11:45:32 [INFO] received CSR
2022/02/01 11:45:32 [INFO] generating key: ecdsa-256
2022/02/01 11:45:32 [INFO] encoded CSR
</code></pre>
<p>此命令生成两个文件；它生成包含 PEM 编码
<a href=https://tools.ietf.org/html/rfc2986>PKCS#10</a> 证书请求的 <code>server.csr</code>，
以及 PEM 编码密钥的 <code>server-key.pem</code>，用于待生成的证书。</p>
<h2 id=创建证书签名请求-csr-对象发送到-kubernetes-api>创建证书签名请求（CSR）对象发送到 Kubernetes API</h2>
<p>使用以下命令创建 CSR YAML 文件，并发送到 API 服务器：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>cat <span style=color:#b44>&lt;&lt;EOF | kubectl apply -f -
</span><span style=color:#b44>apiVersion: certificates.k8s.io/v1
</span><span style=color:#b44>kind: CertificateSigningRequest
</span><span style=color:#b44>metadata:
</span><span style=color:#b44>  name: my-svc.my-namespace
</span><span style=color:#b44>spec:
</span><span style=color:#b44>  request: $(cat server.csr | base64 | tr -d &#39;\n&#39;)
</span><span style=color:#b44>  signerName: example.com/serving
</span><span style=color:#b44>  usages:
</span><span style=color:#b44>  - digital signature
</span><span style=color:#b44>  - key encipherment
</span><span style=color:#b44>  - server auth
</span><span style=color:#b44>EOF</span>
</code></pre></div>
<p>请注意，在步骤 1 中创建的 <code>server.csr</code> 文件是 base64 编码并存储在
<code>.spec.request</code> 字段中的。你还要求提供 “digital signature（数字签名）”，
“密钥加密（key encipherment）” 和 “服务器身份验证（server auth）” 密钥用途，
由 <code>example.com/serving</code> 示例签名程序签名的证书。
你也可以要求使用特定的 <code>signerName</code>。更多信息可参阅
<a href=/zh/docs/reference/access-authn-authz/certificate-signing-requests/#signers>支持的签署者名称</a>。</p>
<p>在 API server 中可以看到这些 CSR 处于 Pending 状态。执行下面的命令你将可以看到：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe csr my-svc.my-namespace
</code></pre></div><pre><code class=language-none data-lang=none>Name:                   my-svc.my-namespace
Labels:                 &lt;none&gt;
Annotations:            &lt;none&gt;
CreationTimestamp:      Tue, 01 Feb 2022 11:49:15 -0500
Requesting User:        yourname@example.com
Signer:                 example.com/serving
Status:                 Pending
Subject:
        Common Name:    my-pod.my-namespace.pod.cluster.local
        Serial Number:
Subject Alternative Names:
        DNS Names:      my-pod.my-namespace.pod.cluster.local
                        my-svc.my-namespace.svc.cluster.local
        IP Addresses:   192.0.2.24
                        10.0.34.2
Events: &lt;none&gt;
</code></pre>
<h2 id=get-the-certificate-signing-request-approved>批准证书签名请求（CSR） </h2>
<p><a href=/zh/docs/reference/access-authn-authz/certificate-signing-requests/>证书签名请求</a>
的批准或者是通过自动批准过程完成的，或由集群管理员一次性完成。
如果你被授权批准证书请求，你可以使用 <code>kubectl</code> 来手动完成此操作；例如：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl certificate approve my-svc.my-namespace
</code></pre></div><pre><code class=language-none data-lang=none>certificatesigningrequest.certificates.k8s.io/my-svc.my-namespace approved
</code></pre>
<p>你现在应该能看到如下输出：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get csr
</code></pre></div><pre><code class=language-none data-lang=none>NAME                  AGE   SIGNERNAME            REQUESTOR              REQUESTEDDURATION   CONDITION
my-svc.my-namespace   10m   example.com/serving   yourname@example.com   &lt;none&gt;              Approved
</code></pre>
<p>这意味着证书请求已被批准，并正在等待请求的签名者对其签名。</p>
<h2 id=sign-the-certificate-signing-request>签名证书签名请求（CSR）</h2>
<p>接下来，你将扮演证书签署者的角色，颁发证书并将其上传到 API 服务器。</p>
<p>签名者通常会使用其 <code>signerName</code> 查看对象的 CertificateSigningRequest API，
检查它们是否已被批准，为这些请求签署证书，并使用已颁发的证书更新 API 对象状态。</p>
<h3 id=创建证书颁发机构>创建证书颁发机构</h3>
<p>你需要授权在新证书上提供数字签名。</p>
<p>首先，通过运行以下命令创建签名证书：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>cat <span style=color:#b44>&lt;&lt;EOF | cfssl gencert -initca - | cfssljson -bare ca
</span><span style=color:#b44>{
</span><span style=color:#b44>  &#34;CN&#34;: &#34;My Example Signer&#34;,
</span><span style=color:#b44>  &#34;key&#34;: {
</span><span style=color:#b44>    &#34;algo&#34;: &#34;rsa&#34;,
</span><span style=color:#b44>    &#34;size&#34;: 2048
</span><span style=color:#b44>  }
</span><span style=color:#b44>}
</span><span style=color:#b44>EOF</span>
</code></pre></div>
<p>你应该看到类似于以下的输出：</p>
<pre><code class=language-none data-lang=none>2022/02/01 11:50:39 [INFO] generating a new CA key and certificate from CSR
2022/02/01 11:50:39 [INFO] generate received request
2022/02/01 11:50:39 [INFO] received CSR
2022/02/01 11:50:39 [INFO] generating key: rsa-2048
2022/02/01 11:50:39 [INFO] encoded CSR
2022/02/01 11:50:39 [INFO] signed certificate with serial number 263983151013686720899716354349605500797834580472
</code></pre>
<p>这会产生一个证书颁发机构密钥文件（<code>ca-key.pem</code>）和证书（<code>ca.pem</code>）。</p>
<h3 id=颁发证书>颁发证书</h3>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/tls/server-signing-config.json download=tls/server-signing-config.json><code>tls/server-signing-config.json</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('tls-server-signing-config-json')" title="Copy tls/server-signing-config.json to clipboard">
</img>
</div>
<div class=includecode id=tls-server-signing-config-json>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
    <span style=color:green;font-weight:700>&#34;signing&#34;</span>: {
        <span style=color:green;font-weight:700>&#34;default&#34;</span>: {
            <span style=color:green;font-weight:700>&#34;usages&#34;</span>: [
                <span style=color:#b44>&#34;digital signature&#34;</span>,
                <span style=color:#b44>&#34;key encipherment&#34;</span>,
                <span style=color:#b44>&#34;server auth&#34;</span>
            ],
            <span style=color:green;font-weight:700>&#34;expiry&#34;</span>: <span style=color:#b44>&#34;876000h&#34;</span>,
            <span style=color:green;font-weight:700>&#34;ca_constraint&#34;</span>: {
                <span style=color:green;font-weight:700>&#34;is_ca&#34;</span>: <span style=color:#a2f;font-weight:700>false</span>
            }
        }
    }
}</code></pre></div>
</div>
</div>
<p>使用 <code>server-signing-config.json</code> 签名配置、证书颁发机构密钥文件和证书来签署证书请求：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get csr my-svc.my-namespace -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.spec.request}&#39;</span> | <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  base64 --decode | <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  cfssl sign -ca ca.pem -ca-key ca-key.pem -config server-signing-config.json - | <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  cfssljson -bare ca-signed-server
</code></pre></div>
<p>你应该看到类似于以下的输出：</p>
<pre><code>2022/02/01 11:52:26 [INFO] signed certificate with serial number 576048928624926584381415936700914530534472870337
</code></pre>
<p>这会生成一个签名的服务证书文件，<code>ca-signed-server.pem</code>。</p>
<h3 id=上传签名证书>上传签名证书</h3>
<p>最后，在 API 对象的状态中填充签名证书：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get csr my-svc.my-namespace -o json | <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  jq <span style=color:#b44>&#39;.status.certificate = &#34;&#39;</span><span style=color:#a2f;font-weight:700>$(</span>base64 ca-signed-server.pem | tr -d <span style=color:#b44>&#39;\n&#39;</span><span style=color:#a2f;font-weight:700>)</span><span style=color:#b44>&#39;&#34;&#39;</span> | <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  kubectl replace --raw /apis/certificates.k8s.io/v1/certificatesigningrequests/my-svc.my-namespace/status -f -
</code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>Note:</strong>
<p>这使用命令行工具 <a href=https://stedolan.github.io/jq/><code>jq</code></a>
在 <code>.status.certificate</code> 字段中填充 base64 编码的内容。
如果你没有 <code>jq</code> 工具，你还可以将 JSON 输出保存到文件中，手动填充此字段，然后上传结果文件。
</div>
<p>批准 CSR 并上传签名证书后，运行：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get csr
</code></pre></div>
<p>输入类似于：</p>
<pre><code class=language-none data-lang=none>NAME                  AGE   SIGNERNAME            REQUESTOR              REQUESTEDDURATION   CONDITION
my-svc.my-namespace   20m   example.com/serving   yourname@example.com   &lt;none&gt;              Approved,Issued
</code></pre>
<h2 id=下载证书并使用它>下载证书并使用它</h2>
<p>现在，作为请求用户，你可以通过运行以下命令下载颁发的证书并将其保存到 <code>server.crt</code> 文件中：</p>
<p>CSR 被签署并获得批准后，你应该看到以下内容：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get csr my-svc.my-namespace -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.status.certificate}&#39;</span> <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>    | base64 --decode &gt; server.crt
</code></pre></div>
<p>现在你可以将 <code>server.crt</code> 和 <code>server-key.pem</code> 填充到
<a class=glossary-tooltip title="Secret 用于存储敏感信息，如密码、 OAuth 令牌和 SSH 密钥。" data-toggle=tooltip data-placement=top href=/zh/docs/concepts/configuration/secret/ target=_blank aria-label=Secret>Secret</a> 中，
稍后你可以将其挂载到 Pod 中（例如，用于提供 HTTPS 的网络服务器）。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create secret tls server --cert server.crt --key server-key.pem
</code></pre></div><pre><code class=language-none data-lang=none>secret/server created
</code></pre>
<p>最后，你可以将 <code>ca.pem</code> 填充到
<a class=glossary-tooltip title="ConfigMap 是一种 API 对象，用来将非机密性的数据保存到键值对中。使用时可以用作环境变量、命令行参数或者存储卷中的配置文件。" data-toggle=tooltip data-placement=top href=/zh/docs/tasks/configure-pod-container/configure-pod-configmap/ target=_blank aria-label=ConfigMap>ConfigMap</a>
并将其用作信任根来验证服务证书：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create configmap example-serving-ca --from-file ca.crt<span style=color:#666>=</span>ca.pem
</code></pre></div><pre><code class=language-none data-lang=none>configmap/example-serving-ca created
</code></pre>
<h2 id=approving-certificate-signing-requests>批准证书签名请求（CSR） </h2>
<p>Kubernetes 管理员（具有适当权限）可以使用 <code>kubectl certificate approve</code> 和
<code>kubectl certificate deny</code> 命令手动批准（或拒绝）证书签名请求（CSR）。
但是，如果你打算大量使用此 API，则可以考虑编写自动化的证书控制器。</p>
<div class="alert alert-warning caution callout" role=alert>
<strong>Caution:</strong>
<p>批准证书 CSR 的能力决定了在你的环境中谁信任谁。
不应广泛或轻率地授予批准 CSR 的能力。</p>
<p>在授予 <code>approve</code> 权限之前，你应该确保自己充分了解批准人的验证要求<strong>和</strong>颁发特定证书的后果。</p>
</div>
<p>无论上述机器或人使用 kubectl，“批准者”的作用是验证 CSR 满足如下两个要求：</p>
<ol>
<li>CSR 的 subject 控制用于签署 CSR 的私钥。这解决了伪装成授权主体的第三方的威胁。
在上述示例中，此步骤将验证该 Pod 控制了用于生成 CSR 的私钥。</li>
<li>CSR 的 subject 被授权在请求的上下文中执行。
这点用于处理不期望的主体被加入集群的威胁。
在上述示例中，此步骤将是验证该 Pod 是否被允许加入到所请求的服务中。</li>
</ol>
<p>当且仅当满足这两个要求时，审批者应该批准 CSR，否则拒绝 CSR。</p>
<p>有关证书批准和访问控制的更多信息，
请阅读<a href=/zh/docs/reference/access-authn-authz/certificate-signing-requests/>证书签名请求</a>参考页。</p>
<h2 id=给集群管理员的一个建议>给集群管理员的一个建议</h2>
<p>本页面假设已经为 certificates API 配置了签名者。
Kubernetes 控制器管理器提供了一个签名者的默认实现。要启用它，请为控制器管理器设置
<code>--cluster-signing-cert-file</code> 和 <code>--cluster-signing-key-file</code> 参数，
使之取值为你的证书机构的密钥对的路径。</p>
</div>
</main>
</div>
</div>
<footer class=d-print-none>
<div class=footer__links>
<nav>
<a class=text-white href=/zh/docs/home/>主页</a>
<a class=text-white href=/zh/blog/>博客</a>
<a class=text-white href=/zh/training/>培训</a>
<a class=text-white href=/zh/partners/>合作伙伴</a>
<a class=text-white href=/zh/community/>社区</a>
<a class=text-white href=/zh/case-studies/>案例分析</a>
</nav>
</div>
<div class=container-fluid>
<div class=row>
<div class="col-6 col-sm-2 text-xs-center order-sm-2">
<ul class="list-inline mb-0">
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="User mailing list" aria-label="User mailing list">
<a class=text-white target=_blank href=https://discuss.kubernetes.io>
<i class="fa fa-envelope"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Twitter aria-label=Twitter>
<a class=text-white target=_blank href=https://twitter.com/kubernetesio>
<i class="fab fa-twitter"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Calendar aria-label=Calendar>
<a class=text-white target=_blank href="https://calendar.google.com/calendar/embed?src=calendar%40kubernetes.io">
<i class="fas fa-calendar-alt"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Youtube aria-label=Youtube>
<a class=text-white target=_blank href=https://youtube.com/kubernetescommunity>
<i class="fab fa-youtube"></i>
</a>
</li>
</ul>
</div>
<div class="col-6 col-sm-2 text-right text-xs-center order-sm-3">
<ul class="list-inline mb-0">
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub>
<a class=text-white target=_blank href=https://github.com/kubernetes/kubernetes>
<i class="fab fa-github"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Slack aria-label=Slack>
<a class=text-white target=_blank href=https://slack.k8s.io>
<i class="fab fa-slack"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Contribute aria-label=Contribute>
<a class=text-white target=_blank href=https://git.k8s.io/community/contributors/guide>
<i class="fas fa-edit"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Stack Overflow" aria-label="Stack Overflow">
<a class=text-white target=_blank href=https://stackoverflow.com/questions/tagged/kubernetes>
<i class="fab fa-stack-overflow"></i>
</a>
</li>
</ul>
</div>
<div class="col-12 col-sm-8 text-center order-sm-2">
<small class=text-white>&copy; 2023 The Kubernetes Authors | Documentation Distributed under <a href=https://git.k8s.io/website/LICENSE class=light-text>CC BY 4.0</a></small>
<br>
<small class=text-white>Copyright &copy; 2023 The Linux Foundation &reg;. All rights reserved. The Linux Foundation has registered trademarks and uses trademarks. For a list of trademarks of The Linux Foundation, please see our <a href=https://www.linuxfoundation.org/trademark-usage class=light-text>Trademark Usage page</a></small>
<br>
<small class=text-white>ICP license: 京ICP备17074266号-3</small>
</div>
</div>
</div>
</footer>
</div>
<script src=/js/popper-1.14.3.min.js integrity=sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49 crossorigin=anonymous></script>
<script src=/js/bootstrap-4.3.1.min.js integrity=sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM crossorigin=anonymous></script>
<script src=/js/main.min.40616251a9b6e4b689e7769be0340661efa4d7ebb73f957404e963e135b4ed52.js integrity="sha256-QGFiUam25LaJ53ab4DQGYe+k1+u3P5V0BOlj4TW07VI=" crossorigin=anonymous></script>
</body>
</html>