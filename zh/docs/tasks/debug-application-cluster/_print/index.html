<!doctype html><html lang=zh class=no-js>
<head>
<meta name=ROBOTS content="NOINDEX, NOFOLLOW">
<script async src="https://www.googletagmanager.com/gtag/js?id=G-JPP6RFM2BP"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-JPP6RFM2BP')</script>
<link rel=alternate hreflang=ko href=https://kubernetes.io/ko/docs/tasks/debug-application-cluster/>
<link rel=alternate hreflang=ja href=https://kubernetes.io/ja/docs/tasks/debug-application-cluster/>
<link rel=alternate hreflang=fr href=https://kubernetes.io/fr/docs/tasks/debug-application-cluster/>
<link rel=alternate hreflang=de href=https://kubernetes.io/de/docs/tasks/debug-application-cluster/>
<link rel=alternate hreflang=es href=https://kubernetes.io/es/docs/tasks/debug-application-cluster/>
<link rel=alternate hreflang=id href=https://kubernetes.io/id/docs/tasks/debug-application-cluster/>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=generator content="Hugo 0.87.0">
<link rel=canonical type=text/html href=https://kubernetes.io/zh/docs/tasks/debug-application-cluster/>
<link rel="shortcut icon" type=image/png href=/images/favicon.png>
<link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180>
<link rel=manifest href=/manifest.webmanifest>
<link rel=apple-touch-icon href=/images/kubernetes-192x192.png>
<title>监控、日志和排错 | Kubernetes</title><meta property="og:title" content="监控、日志和排错">
<meta property="og:description" content="设置监视和日志记录以对集群进行故障排除或调试容器化应用。">
<meta property="og:type" content="website">
<meta property="og:url" content="https://kubernetes.io/zh/docs/tasks/debug-application-cluster/"><meta property="og:site_name" content="Kubernetes">
<meta itemprop=name content="监控、日志和排错">
<meta itemprop=description content="设置监视和日志记录以对集群进行故障排除或调试容器化应用。"><meta name=twitter:card content="summary">
<meta name=twitter:title content="监控、日志和排错">
<meta name=twitter:description content="设置监视和日志记录以对集群进行故障排除或调试容器化应用。">
<link href=/scss/main.css rel=stylesheet>
<script src=/js/jquery-3.3.1.min.js integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin=anonymous></script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","url":"https://kubernetes.io","logo":"https://kubernetes.io/images/favicon.png"}</script>
<meta name=theme-color content="#326ce5">
<link rel=stylesheet href=/css/feature-states.css>
<meta name=description content="设置监视和日志记录以对集群进行故障排除或调试容器化应用。">
<meta property="og:description" content="设置监视和日志记录以对集群进行故障排除或调试容器化应用。">
<meta name=twitter:description content="设置监视和日志记录以对集群进行故障排除或调试容器化应用。">
<meta property="og:url" content="https://kubernetes.io/zh/docs/tasks/debug-application-cluster/">
<meta property="og:title" content="监控、日志和排错">
<meta name=twitter:title content="监控、日志和排错">
<meta name=twitter:image content="https://kubernetes.io/images/favicon.png">
<meta name=twitter:image:alt content="Kubernetes">
<meta property="og:image" content="/images/kubernetes-horizontal-color.png">
<meta property="og:type" content="article">
<script src=/js/script.js></script>
</head>
<body class=td-section>
<header>
<nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar" data-auto-burger=primary>
<a class=navbar-brand href=/zh/></a>
<div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar>
<ul class="navbar-nav mt-2 mt-lg-0">
<li class="nav-item mr-2 mb-lg-0">
<a class="nav-link active" href=/zh/docs/>文档</a>
</li>
<li class="nav-item mr-2 mb-lg-0">
<a class=nav-link href=/zh/blog/>Kubernetes 博客</a>
</li>
<li class="nav-item mr-2 mb-lg-0">
<a class=nav-link href=/zh/training/>培训</a>
</li>
<li class="nav-item mr-2 mb-lg-0">
<a class=nav-link href=/zh/partners/>合作伙伴</a>
</li>
<li class="nav-item mr-2 mb-lg-0">
<a class=nav-link href=/zh/community/>社区</a>
</li>
<li class="nav-item mr-2 mb-lg-0">
<a class=nav-link href=/zh/case-studies/>案例分析</a>
</li>
<li class="nav-item dropdown">
<a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>
Versions
</a>
<div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink>
<a class=dropdown-item href=/releases>Release Information</a>
<a class=dropdown-item href=https://kubernetes.io/zh/docs/tasks/debug-application-cluster/>v1.27</a>
<a class=dropdown-item href=https://v1-26.docs.kubernetes.io/zh/docs/tasks/debug-application-cluster/>v1.26</a>
<a class=dropdown-item href=https://v1-25.docs.kubernetes.io/zh/docs/tasks/debug-application-cluster/>v1.25</a>
<a class=dropdown-item href=https://v1-24.docs.kubernetes.io/zh/docs/tasks/debug-application-cluster/>v1.24</a>
<a class=dropdown-item href=https://v1-23.docs.kubernetes.io/zh/docs/tasks/debug-application-cluster/>v1.23</a>
</div>
</li>
<li class="nav-item dropdown">
<a class="nav-link dropdown-toggle" href=# id=navbarDropdownMenuLink role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>
中文 Chinese
</a>
<div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink>
<a class=dropdown-item href=/ko/docs/tasks/debug-application-cluster/>한국어 Korean</a>
<a class=dropdown-item href=/ja/docs/tasks/debug-application-cluster/>日本語 Japanese</a>
<a class=dropdown-item href=/fr/docs/tasks/debug-application-cluster/>Français</a>
<a class=dropdown-item href=/de/docs/tasks/debug-application-cluster/>Deutsch</a>
<a class=dropdown-item href=/es/docs/tasks/debug-application-cluster/>Español</a>
<a class=dropdown-item href=/id/docs/tasks/debug-application-cluster/>Bahasa Indonesia</a>
</div>
</li>
</ul>
</div>
<button id=hamburger onclick=kub.toggleMenu() data-auto-burger-exclude><div></div></button>
</nav>
</header>
<div class="container-fluid td-outer">
<div class=td-main>
<div class="row flex-xl-nowrap">
<main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main>
<div class=td-content>
<div class="pageinfo pageinfo-primary d-print-none">
<p>
这是本节的多页打印视图。
<a href=# onclick="return print(),!1">点击此处打印</a>.
</p><p>
<a href=/zh/docs/tasks/debug-application-cluster/>返回本页常规视图</a>.
</p>
</div>
<h1 class=title>监控、日志和排错</h1>
<div class=lead>设置监视和日志记录以对集群进行故障排除或调试容器化应用。</div>
<ul>
<li>1: <a href=#pg-731bb8b338c16aebfb9590ba2bd3fdd1></a></li>
<li>2: <a href=#pg-5e4a82f171ec2c11da7360a67efb4abf>使用 crictl 对 Kubernetes 节点进行调试</a></li>
<li>3: <a href=#pg-cbd33a50cc4779f855318a0dd00d7b06>审计</a></li>
<li>4: <a href=#pg-3556c4dbd027b9e90a5b3d72649003fb>应用故障排查</a></li>
<li>5: <a href=#pg-434e0133d71583a27478b10fc1d3d105>故障诊断</a></li>
<li>6: <a href=#pg-ef360b1f8e65236251826db478cfcab3>确定 Pod 失败的原因</a></li>
<li>7: <a href=#pg-9713ac27b6d9e3034033200d968221f2>获取正在运行容器的 Shell</a></li>
<li>8: <a href=#pg-06bb252f25983de12f635c806d180d30>调试 Init 容器</a></li>
<li>9: <a href=#pg-858517cd46a1b5a1fd2e650edd785cea>调试 Pods 和 ReplicationControllers</a></li>
<li>10: <a href=#pg-f79645981e310858111bd5673614cab6>调试 Service</a></li>
<li>11: <a href=#pg-a070b1250ee142402d492b505a56ca83>调试StatefulSet</a></li>
<li>12: <a href=#pg-c0ec963f381296ca26b839cdf0a6f242>调试运行中的 Pod</a></li>
<li>13: <a href=#pg-9e6e1b706f11386fe2c4b4ffda1409e4>资源监控工具</a></li>
<li>14: <a href=#pg-47290c80fb8b00accec6729f3da49734>集群故障排查</a></li>
</ul>
<div class=content>
</div>
</div>
<div class=td-content>
<h1 id=pg-731bb8b338c16aebfb9590ba2bd3fdd1>1 - </h1>
<p>:---
reviewers:</p>
<ul>
<li>janetkuo</li>
<li>thockin
content_type: concept
title: 应用自测与调试</li>
</ul>
<hr>
<p>运行应用时，不可避免的需要定位问题。
前面我们介绍了如何使用 <code>kubectl get pods</code> 来查询 pod 的简单信息。
除此之外，还有一系列的方法来获取应用的更详细信息。</p>
<h2 id=使用-kubectl-describe-pod-命令获取-pod-详情>使用 <code>kubectl describe pod</code> 命令获取 Pod 详情</h2>
<p>与之前的例子类似，我们使用一个 Deployment 来创建两个 Pod。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/application/nginx-with-request.yaml download=application/nginx-with-request.yaml><code>application/nginx-with-request.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('application-nginx-with-request-yaml')" title="Copy application/nginx-with-request.yaml to clipboard">
</img>
</div>
<div class=includecode id=application-nginx-with-request-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-deployment<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>2</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;128Mi&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;500m&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>使用如下命令创建 Deployment：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/application/nginx-with-request.yaml
</code></pre></div><pre><code>deployment.apps/nginx-deployment created
</code></pre>
<p>使用如下命令查看 Pod 状态：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods
</code></pre></div><pre><code>NAME                                READY     STATUS    RESTARTS   AGE
nginx-deployment-1006230814-6winp   1/1       Running   0          11s
nginx-deployment-1006230814-fmgu3   1/1       Running   0          11s
</code></pre>
<p>我们可以使用 <code>kubectl describe pod</code> 命令来查询每个 Pod 的更多信息，比如：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe pod nginx-deployment-1006230814-6winp
</code></pre></div><pre><code>Name:		nginx-deployment-1006230814-6winp
Namespace:	default
Node:		kubernetes-node-wul5/10.240.0.9
Start Time:	Thu, 24 Mar 2016 01:39:49 +0000
Labels:		app=nginx,pod-template-hash=1006230814
Annotations:    kubernetes.io/created-by={&quot;kind&quot;:&quot;SerializedReference&quot;,&quot;apiVersion&quot;:&quot;v1&quot;,&quot;reference&quot;:{&quot;kind&quot;:&quot;ReplicaSet&quot;,&quot;namespace&quot;:&quot;default&quot;,&quot;name&quot;:&quot;nginx-deployment-1956810328&quot;,&quot;uid&quot;:&quot;14e607e7-8ba1-11e7-b5cb-fa16&quot; ...
Status:		Running
IP:		10.244.0.6
Controllers:	ReplicaSet/nginx-deployment-1006230814
Containers:
  nginx:
    Container ID:	docker://90315cc9f513c724e9957a4788d3e625a078de84750f244a40f97ae355eb1149
    Image:		nginx
    Image ID:		docker://6f62f48c4e55d700cf3eb1b5e33fa051802986b77b874cc351cce539e5163707
    Port:		80/TCP
    QoS Tier:
      cpu:	Guaranteed
      memory:	Guaranteed
    Limits:
      cpu:	500m
      memory:	128Mi
    Requests:
      memory:		128Mi
      cpu:		500m
    State:		Running
      Started:		Thu, 24 Mar 2016 01:39:51 +0000
    Ready:		True
    Restart Count:	0
    Environment:        &lt;none&gt;
    Mounts:
      /var/run/secrets/kubernetes.io/serviceaccount from default-token-5kdvl (ro)
Conditions:
  Type          Status
  Initialized   True
  Ready         True
  PodScheduled  True
Volumes:
  default-token-4bcbi:
    Type:	Secret (a volume populated by a Secret)
    SecretName:	default-token-4bcbi
    Optional:   false
QoS Class:      Guaranteed
Node-Selectors: &lt;none&gt;
Tolerations:    &lt;none&gt;
Events:
  FirstSeen	LastSeen	Count	From					SubobjectPath		Type		Reason		Message
  ---------	--------	-----	----					-------------		--------	------		-------
  54s		54s		1	{default-scheduler }						Normal		Scheduled	Successfully assigned nginx-deployment-1006230814-6winp to kubernetes-node-wul5
  54s		54s		1	{kubelet kubernetes-node-wul5}	spec.containers{nginx}	Normal		Pulling		pulling image &quot;nginx&quot;
  53s		53s		1	{kubelet kubernetes-node-wul5}	spec.containers{nginx}	Normal		Pulled		Successfully pulled image &quot;nginx&quot;
  53s		53s		1	{kubelet kubernetes-node-wul5}	spec.containers{nginx}	Normal		Created		Created container with docker id 90315cc9f513
  53s		53s		1	{kubelet kubernetes-node-wul5}	spec.containers{nginx}	Normal		Started		Started container with docker id 90315cc9f513
</code></pre>
<p>这里可以看到容器和 Pod 的标签、资源需求等配置信息，还可以看到状态、就绪态、
重启次数、事件等状态信息。</p>
<p>容器状态是 Waiting、Running 和 Terminated 之一。
根据状态的不同，还有对应的额外的信息 —— 在这里你可以看到，
对于处于运行状态的容器，系统会告诉你容器的启动时间。</p>
<p>Ready 指示是否通过了最后一个就绪态探测。
(在本例中，容器没有配置就绪态探测；如果没有配置就绪态探测，则假定容器已经就绪。)</p>
<p>Restart Count 告诉你容器已重启的次数；
这些信息对于定位配置了 “Always” 重启策略的容器持续崩溃问题非常有用。</p>
<p>目前，唯一与 Pod 有关的状态是 Ready 状况，该状况表明 Pod 能够为请求提供服务，
并且应该添加到相应服务的负载均衡池中。</p>
<p>最后，你还可以看到与 Pod 相关的近期事件。
系统通过指示第一次和最后一次看到事件以及看到该事件的次数来压缩多个相同的事件。
“From” 标明记录事件的组件，
“SubobjectPath” 告诉你引用了哪个对象（例如 Pod 中的容器），
“Reason” 和 “Message” 告诉你发生了什么。</p>
<h2 id=例子-调试-pending-状态的-pod>例子: 调试 Pending 状态的 Pod</h2>
<p>可以使用事件来调试的一个常见的场景是，你创建 Pod 无法被调度到任何节点。
比如，Pod 请求的资源比较多，没有任何一个节点能够满足，或者它指定了一个标签，没有节点可匹配。
假定我们创建之前的 Deployment 时指定副本数是 5（不再是 2），并且请求 600 毫核（不再是 500），
对于一个 4 个节点的集群，若每个节点只有 1 个 CPU，这时至少有一个 Pod 不能被调度。
（需要注意的是，其他集群插件 Pod，比如 fluentd、skydns 等等会在每个节点上运行，
如果我们需求 1000 毫核，将不会有 Pod 会被调度。）</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods
</code></pre></div><pre><code>NAME                                READY     STATUS    RESTARTS   AGE
nginx-deployment-1006230814-6winp   1/1       Running   0          7m
nginx-deployment-1006230814-fmgu3   1/1       Running   0          7m
nginx-deployment-1370807587-6ekbw   1/1       Running   0          1m
nginx-deployment-1370807587-fg172   0/1       Pending   0          1m
nginx-deployment-1370807587-fz9sd   0/1       Pending   0          1m
</code></pre>
<p>为了查找 Pod nginx-deployment-1370807587-fz9sd 没有运行的原因，我们可以使用
<code>kubectl describe pod</code> 命令描述 Pod，查看其事件：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe pod nginx-deployment-1370807587-fz9sd
</code></pre></div><pre><code>  Name:		nginx-deployment-1370807587-fz9sd
  Namespace:	default
  Node:		/
  Labels:		app=nginx,pod-template-hash=1370807587
  Status:		Pending
  IP:
  Controllers:	ReplicaSet/nginx-deployment-1370807587
  Containers:
    nginx:
      Image:	nginx
      Port:	80/TCP
      QoS Tier:
        memory:	Guaranteed
        cpu:	Guaranteed
      Limits:
        cpu:	1
        memory:	128Mi
      Requests:
        cpu:	1
        memory:	128Mi
      Environment Variables:
  Volumes:
    default-token-4bcbi:
      Type:	Secret (a volume populated by a Secret)
      SecretName:	default-token-4bcbi
  Events:
    FirstSeen	LastSeen	Count	From			        SubobjectPath	Type		Reason			    Message
    ---------	--------	-----	----			        -------------	--------	------			    -------
    1m		    48s		    7	    {default-scheduler }			        Warning		FailedScheduling	pod (nginx-deployment-1370807587-fz9sd) failed to fit in any node
  fit failure on node (kubernetes-node-6ta5): Node didn't have enough resource: CPU, requested: 1000, used: 1420, capacity: 2000
  fit failure on node (kubernetes-node-wul5): Node didn't have enough resource: CPU, requested: 1000, used: 1100, capacity: 2000
</code></pre>
<p>这里你可以看到由调度器记录的事件，它表明了 Pod 不能被调度的原因是 <code>FailedScheduling</code>（也可能是其他值）。
其 message 部分表明没有任何节点拥有足够多的资源。</p>
<p>要纠正这种情况，可以使用 <code>kubectl scale</code> 更新 Deployment，以指定 4 个或更少的副本。
(或者你可以让 Pod 继续保持这个状态，这是无害的。)</p>
<p>你在 <code>kubectl describe pod</code> 结尾处看到的事件都保存在 etcd 中，
并提供关于集群中正在发生的事情的高级信息。
如果需要列出所有事件，可使用命令：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get events
</code></pre></div>
<p>但是，需要注意的是，事件是区分名字空间的。
如果你对某些名字空间域的对象（比如 <code>my-namespace</code> 名字下的 Pod）的事件感兴趣,
你需要显式地在命令行中指定名字空间：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get events --namespace<span style=color:#666>=</span>my-namespace
</code></pre></div>
<p>查看所有 namespace 的事件，可使用 <code>--all-namespaces</code> 参数。</p>
<p>除了 <code>kubectl describe pod</code> 以外，另一种获取 Pod 额外信息（除了 <code>kubectl get pod</code>）的方法
是给 <code>kubectl get pod</code> 增加 <code>-o yaml</code> 输出格式参数。
该命令将以 YAML 格式为你提供比 <code>kubectl describe pod</code> 更多的信息 —— 实际上是系统拥有的关于 Pod 的所有信息。
在这里，你将看到注解（没有标签限制的键值元数据，由 Kubernetes 系统组件在内部使用）、
重启策略、端口和卷等。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod nginx-deployment-1006230814-6winp -o yaml
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubernetes.io/created-by</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span><span style=color:#b44;font-style:italic>      </span><span style=color:#bbb>      </span>{<span style=color:#b44>&#34;kind&#34;</span>:<span style=color:#b44>&#34;SerializedReference&#34;</span>,<span style=color:#b44>&#34;apiVersion&#34;</span>:<span style=color:#b44>&#34;v1&#34;</span>,<span style=color:#b44>&#34;reference&#34;</span>:{<span style=color:#b44>&#34;kind&#34;</span>:<span style=color:#b44>&#34;ReplicaSet&#34;</span>,<span style=color:#b44>&#34;namespace&#34;</span>:<span style=color:#b44>&#34;default&#34;</span>,<span style=color:#b44>&#34;name&#34;</span>:<span style=color:#b44>&#34;nginx-deployment-1006230814&#34;</span>,<span style=color:#b44>&#34;uid&#34;</span>:<span style=color:#b44>&#34;4c84c175-f161-11e5-9a78-42010af00005&#34;</span>,<span style=color:#b44>&#34;apiVersion&#34;</span>:<span style=color:#b44>&#34;extensions&#34;</span>,<span style=color:#b44>&#34;resourceVersion&#34;</span>:<span style=color:#b44>&#34;133434&#34;</span>}}<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>creationTimestamp</span>:<span style=color:#bbb> </span>2016-03-24T01:39:50Z<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>generateName</span>:<span style=color:#bbb> </span>nginx-deployment-1006230814-<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>pod-template-hash</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;1006230814&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-deployment-1006230814-6winp<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resourceVersion</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;133447&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>uid</span>:<span style=color:#bbb> </span>4c879808-f161-11e5-9a78-42010af00005<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>imagePullPolicy</span>:<span style=color:#bbb> </span>Always<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span>500m<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>128Mi<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span>500m<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>128Mi<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>terminationMessagePath</span>:<span style=color:#bbb> </span>/dev/termination-log<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/var/run/secrets/kubernetes.io/serviceaccount<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>default-token-4bcbi<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>dnsPolicy</span>:<span style=color:#bbb> </span>ClusterFirst<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>nodeName</span>:<span style=color:#bbb> </span>kubernetes-node-wul5<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Always<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>securityContext</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>serviceAccount</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>serviceAccountName</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>terminationGracePeriodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>30</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>default-token-4bcbi<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>secret</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>secretName</span>:<span style=color:#bbb> </span>default-token-4bcbi<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>conditions</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>lastProbeTime</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>null</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>lastTransitionTime</span>:<span style=color:#bbb> </span>2016-03-24T01:39:51Z<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;True&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Ready<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containerStatuses</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>containerID</span>:<span style=color:#bbb> </span>docker://90315cc9f513c724e9957a4788d3e625a078de84750f244a40f97ae355eb1149<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>imageID</span>:<span style=color:#bbb> </span>docker://6f62f48c4e55d700cf3eb1b5e33fa051802986b77b874cc351cce539e5163707<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>lastState</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>ready</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>restartCount</span>:<span style=color:#bbb> </span><span style=color:#666>0</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>state</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>running</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>startedAt</span>:<span style=color:#bbb> </span>2016-03-24T01:39:51Z<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>hostIP</span>:<span style=color:#bbb> </span><span style=color:#666>10.240.0.9</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>phase</span>:<span style=color:#bbb> </span>Running<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>podIP</span>:<span style=color:#bbb> </span><span style=color:#666>10.244.0.6</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>startTime</span>:<span style=color:#bbb> </span>2016-03-24T01:39:49Z<span style=color:#bbb>
</span></code></pre></div>
<h2 id=示例-调试宕机或无法联系的节点>示例：调试宕机或无法联系的节点</h2>
<p>有时候，在调试时，查看节点的状态是很有用的 —— 例如，因为你已经注意到节点上运行的 Pod 的奇怪行为，
或者想了解为什么 Pod 不会调度到节点上。
与 Pod 一样，你可以使用 <code>kubectl describe node</code> 和 <code>kubectl get node -o yaml</code> 来查询节点的详细信息。
例如，如果某个节点宕机（与网络断开连接，或者 kubelet 挂掉无法重新启动等等），你将看到以下情况。
请注意显示节点未就绪的事件，也请注意 Pod 不再运行(它们在5分钟未就绪状态后被驱逐)。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get nodes
</code></pre></div><pre><code>NAME                     STATUS       ROLES     AGE     VERSION
kubernetes-node-861h     NotReady     &lt;none&gt;    1h      v1.13.0
kubernetes-node-bols     Ready        &lt;none&gt;    1h      v1.13.0
kubernetes-node-st6x     Ready        &lt;none&gt;    1h      v1.13.0
kubernetes-node-unaj     Ready        &lt;none&gt;    1h      v1.13.0
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe node kubernetes-node-861h
</code></pre></div><pre><code class=language-none data-lang=none>Name:			kubernetes-node-861h
Role
Labels:		 kubernetes.io/arch=amd64
           kubernetes.io/os=linux
           kubernetes.io/hostname=kubernetes-node-861h
Annotations:        node.alpha.kubernetes.io/ttl=0
                    volumes.kubernetes.io/controller-managed-attach-detach=true
Taints:             &lt;none&gt;
CreationTimestamp:	Mon, 04 Sep 2017 17:13:23 +0800
Phase:
Conditions:
  Type		Status		LastHeartbeatTime			LastTransitionTime			Reason					Message
  ----    ------    -----------------     ------------------      ------          -------
  OutOfDisk             Unknown         Fri, 08 Sep 2017 16:04:28 +0800         Fri, 08 Sep 2017 16:20:58 +0800         NodeStatusUnknown       Kubelet stopped posting node status.
  MemoryPressure        Unknown         Fri, 08 Sep 2017 16:04:28 +0800         Fri, 08 Sep 2017 16:20:58 +0800         NodeStatusUnknown       Kubelet stopped posting node status.
  DiskPressure          Unknown         Fri, 08 Sep 2017 16:04:28 +0800         Fri, 08 Sep 2017 16:20:58 +0800         NodeStatusUnknown       Kubelet stopped posting node status.
  Ready                 Unknown         Fri, 08 Sep 2017 16:04:28 +0800         Fri, 08 Sep 2017 16:20:58 +0800         NodeStatusUnknown       Kubelet stopped posting node status.
Addresses:	10.240.115.55,104.197.0.26
Capacity:
 cpu:           2
 hugePages:     0
 memory:        4046788Ki
 pods:          110
Allocatable:
 cpu:           1500m
 hugePages:     0
 memory:        1479263Ki
 pods:          110
System Info:
 Machine ID:                    8e025a21a4254e11b028584d9d8b12c4
 System UUID:                   349075D1-D169-4F25-9F2A-E886850C47E3
 Boot ID:                       5cd18b37-c5bd-4658-94e0-e436d3f110e0
 Kernel Version:                4.4.0-31-generic
 OS Image:                      Debian GNU/Linux 8 (jessie)
 Operating System:              linux
 Architecture:                  amd64
 Container Runtime Version:     docker://1.12.5
 Kubelet Version:               v1.6.9+a3d1dfa6f4335
 Kube-Proxy Version:            v1.6.9+a3d1dfa6f4335
ExternalID:                     15233045891481496305
Non-terminated Pods:            (9 in total)
  Namespace                     Name                                            CPU Requests    CPU Limits      Memory Requests Memory Limits
  ---------                     ----                                            ------------    ----------      --------------- -------------
......
Allocated resources:
  (Total limits may be over 100 percent, i.e., overcommitted.)
  CPU Requests  CPU Limits      Memory Requests         Memory Limits
  ------------  ----------      ---------------         -------------
  900m (60%)    2200m (146%)    1009286400 (66%)        5681286400 (375%)
Events:         &lt;none&gt;
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get node kubernetes-node-861h -o yaml
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Node<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>creationTimestamp</span>:<span style=color:#bbb> </span>2015-07-10T21:32:29Z<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubernetes.io/hostname</span>:<span style=color:#bbb> </span>kubernetes-node-861h<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>kubernetes-node-861h<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resourceVersion</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;757&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selfLink</span>:<span style=color:#bbb> </span>/api/v1/nodes/kubernetes-node-861h<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>uid</span>:<span style=color:#bbb> </span>2a69374e-274b-11e5-a234-42010af0d969<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>externalID</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;15233045891481496305&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>podCIDR</span>:<span style=color:#bbb> </span><span style=color:#666>10.244.0.0</span>/24<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>providerID</span>:<span style=color:#bbb> </span>gce://striped-torus-760/us-central1-b/kubernetes-node-861h<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>addresses</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>address</span>:<span style=color:#bbb> </span><span style=color:#666>10.240.115.55</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>InternalIP<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>address</span>:<span style=color:#bbb> </span><span style=color:#666>104.197.0.26</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>ExternalIP<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>capacity</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;1&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>3800808Ki<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>pods</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;100&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>conditions</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>lastHeartbeatTime</span>:<span style=color:#bbb> </span>2015-07-10T21:34:32Z<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>lastTransitionTime</span>:<span style=color:#bbb> </span>2015-07-10T21:35:15Z<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>reason</span>:<span style=color:#bbb> </span>Kubelet stopped posting node status.<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb> </span>Unknown<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Ready<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>nodeInfo</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>bootID</span>:<span style=color:#bbb> </span><span style=color:#666>4e316776</span>-b40d-4f78-a4ea-ab0d73390897<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>containerRuntimeVersion</span>:<span style=color:#bbb> </span>docker://Unknown<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kernelVersion</span>:<span style=color:#bbb> </span><span style=color:#666>3.16.0-0.</span>bpo.4-amd64<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubeProxyVersion</span>:<span style=color:#bbb> </span>v0.21.1-185-gffc5a86098dc01<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubeletVersion</span>:<span style=color:#bbb> </span>v0.21.1-185-gffc5a86098dc01<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>machineID</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>osImage</span>:<span style=color:#bbb> </span>Debian GNU/Linux 7 (wheezy)<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>systemUUID</span>:<span style=color:#bbb> </span>ABE5F6B4-D44B-108B-C46A-24CCE16C8B6E<span style=color:#bbb>
</span></code></pre></div><h2 id=what-s-next>What's next</h2>
<p>了解更多的调试工具：</p>
<ul>
<li><a href=/zh/docs/concepts/cluster-administration/logging/>日志</a></li>
<li><a href=/zh/docs/tasks/debug-application-cluster/resource-usage-monitoring/>监控</a></li>
<li><a href=/zh/docs/tasks/debug-application-cluster/get-shell-running-container/>使用 <code>exec</code> 进入容器</a></li>
<li><a href=/zh/docs/tasks/extend-kubernetes/http-proxy-access-api/>使用代理连接容器</a></li>
<li><a href=/zh/docs/tasks/access-application-cluster/port-forward-access-application-cluster/>使用端口转发连接容器</a></li>
<li><a href=/zh/docs/tasks/debug-application-cluster/crictl/>使用 crictl 检查节点</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-5e4a82f171ec2c11da7360a67efb4abf>2 - 使用 crictl 对 Kubernetes 节点进行调试</h1>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.11 [stable]</code>
</div>
<p><code>crictl</code> 是 CRI 兼容的容器运行时命令行接口。
你可以使用它来检查和调试 Kubernetes 节点上的容器运行时和应用程序。
<code>crictl</code> 和它的源代码在
<a href=https://github.com/kubernetes-sigs/cri-tools>cri-tools</a> 代码库。</p>
<h2 id=before-you-begin>Before you begin</h2>
<p><code>crictl</code> 需要带有 CRI 运行时的 Linux 操作系统。</p>
<h2 id=安装-crictl>安装 crictl</h2>
<p>你可以从 cri-tools <a href=https://github.com/kubernetes-sigs/cri-tools/releases>发布页面</a>
下载一个压缩的 <code>crictl</code> 归档文件，用于几种不同的架构。
下载与你的 kubernetes 版本相对应的版本。
提取它并将其移动到系统路径上的某个位置，例如<code>/usr/local/bin/</code>。</p>
<h2 id=一般用法>一般用法</h2>
<p><code>crictl</code> 命令有几个子命令和运行时参数。
有关详细信息，请使用 <code>crictl help</code> 或 <code>crictl &lt;subcommand> help</code> 获取帮助信息。</p>
<p>你可以用以下方法之一来为 <code>crictl</code> 设置端点：</p>
<ul>
<li>设置参数 <code>--runtime-endpoint</code> 和 <code>--image-endpoint</code>。</li>
<li>设置环境变量 <code>CONTAINER_RUNTIME_ENDPOINT</code> 和 <code>IMAGE_SERVICE_ENDPOINT</code>。</li>
<li>在配置文件 <code>--config=/etc/crictl.yaml</code> 中设置端点。
要设置不同的文件，可以在运行 <code>crictl</code> 时使用 <code>--config=PATH_TO_FILE</code> 标志。</li>
</ul>
<p>你还可以在连接到服务器并启用或禁用调试时指定超时值，方法是在配置文件中指定
<code>timeout</code> 或 <code>debug</code> 值，或者使用 <code>--timeout</code> 和 <code>--debug</code> 命令行参数。</p>
<p>要查看或编辑当前配置，请查看或编辑 <code>/etc/crictl.yaml</code> 的内容。
例如，使用 <code>containerd</code> 容器运行时的配置会类似于这样：</p>
<pre><code>runtime-endpoint: unix:///var/run/containerd/containerd.sock
image-endpoint: unix:///var/run/containerd/containerd.sock
timeout: 10
debug: true
</code></pre>
<p>要进一步了解 <code>crictl</code>，参阅
<a href=https://github.com/kubernetes-sigs/cri-tools/blob/master/docs/crictl.md><code>crictl</code> 文档</a>。</p>
<h2 id=crictl-命令示例>crictl 命令示例</h2>
<div class="alert alert-danger warning callout" role=alert>
<strong>Warning:</strong>
<p>如果使用 <code>crictl</code> 在正在运行的 Kubernetes 集群上创建 Pod 沙盒或容器，
kubelet 最终将删除它们。
<code>crictl</code> 不是一个通用的工作流工具，而是一个对调试有用的工具。
</div>
<h3 id=打印-pod-清单>打印 Pod 清单</h3>
<p>打印所有 Pod 的清单：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>crictl pods
</code></pre></div>
<p>输出类似于：</p>
<pre><code>POD ID              CREATED              STATE               NAME                         NAMESPACE           ATTEMPT
926f1b5a1d33a       About a minute ago   Ready               sh-84d7dcf559-4r2gq          default             0
4dccb216c4adb       About a minute ago   Ready               nginx-65899c769f-wv2gp       default             0
a86316e96fa89       17 hours ago         Ready               kube-proxy-gblk4             kube-system         0
919630b8f81f1       17 hours ago         Ready               nvidia-device-plugin-zgbbv   kube-system         0
</code></pre>
<p>根据名称打印 Pod 清单：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>crictl pods --name nginx-65899c769f-wv2gp
</code></pre></div>
<p>输出类似于这样：</p>
<pre><code>POD ID              CREATED             STATE               NAME                     NAMESPACE           ATTEMPT
4dccb216c4adb       2 minutes ago       Ready               nginx-65899c769f-wv2gp   default             0
</code></pre>
<p>根据标签打印 Pod 清单：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>crictl pods --label <span style=color:#b8860b>run</span><span style=color:#666>=</span>nginx
</code></pre></div>
<p>输出类似于这样：</p>
<pre><code class=language-none data-lang=none>POD ID              CREATED             STATE               NAME                     NAMESPACE           ATTEMPT
4dccb216c4adb       2 minutes ago       Ready               nginx-65899c769f-wv2gp   default             0
</code></pre>
<h3 id=打印镜像清单>打印镜像清单</h3>
<p>打印所有镜像清单：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>crictl images
</code></pre></div>
<p>输出类似于这样：</p>
<pre><code class=language-none data-lang=none>IMAGE                                     TAG                 IMAGE ID            SIZE
busybox                                   latest              8c811b4aec35f       1.15MB
k8s-gcrio.azureedge.net/hyperkube-amd64   v1.10.3             e179bbfe5d238       665MB
k8s-gcrio.azureedge.net/pause-amd64       3.1                 da86e6ba6ca19       742kB
nginx                                     latest              cd5239a0906a6       109MB
</code></pre>
<p>根据仓库打印镜像清单：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>crictl images nginx
</code></pre></div>
<p>输出类似于这样：</p>
<pre><code class=language-none data-lang=none>IMAGE               TAG                 IMAGE ID            SIZE
nginx               latest              cd5239a0906a6       109MB
</code></pre>
<p>只打印镜像 ID：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>crictl images -q
</code></pre></div>
<p>输出类似于这样：</p>
<pre><code class=language-none data-lang=none>sha256:8c811b4aec35f259572d0f79207bc0678df4c736eeec50bc9fec37ed936a472a
sha256:e179bbfe5d238de6069f3b03fccbecc3fb4f2019af741bfff1233c4d7b2970c5
sha256:da86e6ba6ca197bf6bc5e9d900febd906b133eaa4750e6bed647b0fbe50ed43e
sha256:cd5239a0906a6ccf0562354852fae04bc5b52d72a2aff9a871ddb6bd57553569
</code></pre>
<h3 id=打印容器清单>打印容器清单</h3>
<p>打印所有容器清单：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>crictl ps -a
</code></pre></div>
<p>输出类似于这样：</p>
<pre><code class=language-none data-lang=none>CONTAINER ID        IMAGE                                                                                                             CREATED             STATE               NAME                       ATTEMPT
1f73f2d81bf98       busybox@sha256:141c253bc4c3fd0a201d32dc1f493bcf3fff003b6df416dea4f41046e0f37d47                                   7 minutes ago       Running             sh                         1
9c5951df22c78       busybox@sha256:141c253bc4c3fd0a201d32dc1f493bcf3fff003b6df416dea4f41046e0f37d47                                   8 minutes ago       Exited              sh                         0
87d3992f84f74       nginx@sha256:d0a8828cccb73397acb0073bf34f4d7d8aa315263f1e7806bf8c55d8ac139d5f                                     8 minutes ago       Running             nginx                      0
1941fb4da154f       k8s-gcrio.azureedge.net/hyperkube-amd64@sha256:00d814b1f7763f4ab5be80c58e98140dfc69df107f253d7fdd714b30a714260a   18 hours ago        Running             kube-proxy                 0
</code></pre>
<p>打印正在运行的容器清单：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>crictl ps
</code></pre></div>
<p>输出类似于这样：</p>
<pre><code class=language-none data-lang=none>CONTAINER ID        IMAGE                                                                                                             CREATED             STATE               NAME                       ATTEMPT
1f73f2d81bf98       busybox@sha256:141c253bc4c3fd0a201d32dc1f493bcf3fff003b6df416dea4f41046e0f37d47                                   6 minutes ago       Running             sh                         1
87d3992f84f74       nginx@sha256:d0a8828cccb73397acb0073bf34f4d7d8aa315263f1e7806bf8c55d8ac139d5f                                     7 minutes ago       Running             nginx                      0
1941fb4da154f       k8s-gcrio.azureedge.net/hyperkube-amd64@sha256:00d814b1f7763f4ab5be80c58e98140dfc69df107f253d7fdd714b30a714260a   17 hours ago        Running             kube-proxy                 0
</code></pre>
<h3 id=在正在运行的容器上执行命令>在正在运行的容器上执行命令</h3>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>crictl <span style=color:#a2f>exec</span> -i -t 1f73f2d81bf98 ls
</code></pre></div>
<p>输出类似于这样：</p>
<pre><code class=language-none data-lang=none>bin   dev   etc   home  proc  root  sys   tmp   usr   var
</code></pre>
<h3 id=获取容器日志>获取容器日志</h3>
<p>获取容器的所有日志：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>crictl logs 87d3992f84f74
</code></pre></div>
<p>输出类似于这样：</p>
<pre><code class=language-none data-lang=none>10.240.0.96 - - [06/Jun/2018:02:45:49 +0000] &quot;GET / HTTP/1.1&quot; 200 612 &quot;-&quot; &quot;curl/7.47.0&quot; &quot;-&quot;
10.240.0.96 - - [06/Jun/2018:02:45:50 +0000] &quot;GET / HTTP/1.1&quot; 200 612 &quot;-&quot; &quot;curl/7.47.0&quot; &quot;-&quot;
10.240.0.96 - - [06/Jun/2018:02:45:51 +0000] &quot;GET / HTTP/1.1&quot; 200 612 &quot;-&quot; &quot;curl/7.47.0&quot; &quot;-&quot;
</code></pre>
<p>获取最近的 <code>N</code> 行日志：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>crictl logs --tail<span style=color:#666>=</span><span style=color:#666>1</span> 87d3992f84f74
</code></pre></div>
<p>输出类似于这样：</p>
<pre><code class=language-none data-lang=none>10.240.0.96 - - [06/Jun/2018:02:45:51 +0000] &quot;GET / HTTP/1.1&quot; 200 612 &quot;-&quot; &quot;curl/7.47.0&quot; &quot;-&quot;
</code></pre>
<h3 id=运行-pod-沙盒>运行 Pod 沙盒</h3>
<p>用 <code>crictl</code> 运行 Pod 沙盒对容器运行时排错很有帮助。
在运行的 Kubernetes 集群中，沙盒会随机地被 kubelet 停止和删除。</p>
<ol>
<li>
<p>编写下面的 JSON 文件：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
    <span style=color:green;font-weight:700>&#34;metadata&#34;</span>: {
        <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;nginx-sandbox&#34;</span>,
        <span style=color:green;font-weight:700>&#34;namespace&#34;</span>: <span style=color:#b44>&#34;default&#34;</span>,
        <span style=color:green;font-weight:700>&#34;attempt&#34;</span>: <span style=color:#666>1</span>,
        <span style=color:green;font-weight:700>&#34;uid&#34;</span>: <span style=color:#b44>&#34;hdishd83djaidwnduwk28bcsb&#34;</span>
    },
    <span style=color:green;font-weight:700>&#34;logDirectory&#34;</span>: <span style=color:#b44>&#34;/tmp&#34;</span>,
    <span style=color:green;font-weight:700>&#34;linux&#34;</span>: {
    }
}
</code></pre></div></li>
</ol>
<ol start=2>
<li>
<p>使用 <code>crictl runp</code> 命令应用 JSON 文件并运行沙盒。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>crictl runp pod-config.json
</code></pre></div>
<p>返回了沙盒的 ID。</p>
</li>
</ol>
<h3 id=创建容器>创建容器</h3>
<p>用 <code>crictl</code> 创建容器对容器运行时排错很有帮助。
在运行的 Kubernetes 集群中，沙盒会随机的被 kubelet 停止和删除。</p>
<ol>
<li>
<p>拉取 busybox 镜像</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>crictl pull busybox
</code></pre></div><pre><code class=language-none data-lang=none>Image is up to date for busybox@sha256:141c253bc4c3fd0a201d32dc1f493bcf3fff003b6df416dea4f41046e0f37d47
</code></pre></li>
</ol>
<ol start=2>
<li>
<p>创建 Pod 和容器的配置：</p>
<p><strong>Pod 配置</strong>：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
    <span style=color:green;font-weight:700>&#34;metadata&#34;</span>: {
        <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;nginx-sandbox&#34;</span>,
        <span style=color:green;font-weight:700>&#34;namespace&#34;</span>: <span style=color:#b44>&#34;default&#34;</span>,
        <span style=color:green;font-weight:700>&#34;attempt&#34;</span>: <span style=color:#666>1</span>,
        <span style=color:green;font-weight:700>&#34;uid&#34;</span>: <span style=color:#b44>&#34;hdishd83djaidwnduwk28bcsb&#34;</span>
    },
    <span style=color:green;font-weight:700>&#34;log_directory&#34;</span>: <span style=color:#b44>&#34;/tmp&#34;</span>,
    <span style=color:green;font-weight:700>&#34;linux&#34;</span>: {
    }
}
</code></pre></div>
<p><strong>容器配置</strong>：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
  <span style=color:green;font-weight:700>&#34;metadata&#34;</span>: {
      <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;busybox&#34;</span>
  },
  <span style=color:green;font-weight:700>&#34;image&#34;</span>:{
      <span style=color:green;font-weight:700>&#34;image&#34;</span>: <span style=color:#b44>&#34;busybox&#34;</span>
  },
  <span style=color:green;font-weight:700>&#34;command&#34;</span>: [
      <span style=color:#b44>&#34;top&#34;</span>
  ],
  <span style=color:green;font-weight:700>&#34;log_path&#34;</span>:<span style=color:#b44>&#34;busybox.log&#34;</span>,
  <span style=color:green;font-weight:700>&#34;linux&#34;</span>: {
  }
}
</code></pre></div></li>
</ol>
<ol start=3>
<li>
<p>创建容器，传递先前创建的 Pod 的 ID、容器配置文件和 Pod 配置文件。返回容器的 ID。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>crictl create f84dd361f8dc51518ed291fbadd6db537b0496536c1d2d6c05ff943ce8c9a54f container-config.json pod-config.json
</code></pre></div></li>
</ol>
<ol start=4>
<li>
<p>查询所有容器并确认新创建的容器状态为 <code>Created</code>。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>crictl ps -a
</code></pre></div>
<p>输出类似于这样：</p>
<pre><code class=language-none data-lang=none>CONTAINER ID        IMAGE               CREATED             STATE               NAME                ATTEMPT
3e025dd50a72d       busybox             32 seconds ago      Created             busybox             0
</code></pre></li>
</ol>
<h3 id=启动容器>启动容器</h3>
<p>要启动容器，要将容器 ID 传给 <code>crictl start</code>：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>crictl start 3e025dd50a72d956c4f14881fbb5b1080c9275674e95fb67f965f6478a957d60
</code></pre></div>
<p>输出类似于这样：</p>
<pre><code>3e025dd50a72d956c4f14881fbb5b1080c9275674e95fb67f965f6478a957d60
</code></pre>
<p>确认容器的状态为 <code>Running</code>。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>crictl ps
</code></pre></div>
<p>输出类似于这样：</p>
<pre><code>CONTAINER ID   IMAGE    CREATED              STATE    NAME     ATTEMPT
3e025dd50a72d  busybox  About a minute ago   Running  busybox  0
</code></pre><h2 id=what-s-next>What's next</h2>
<ul>
<li><a href=https://github.com/kubernetes-sigs/cri-tools>进一步了解 <code>crictl</code></a>.</li>
<li><a href=/zh/docs/reference/tools/map-crictl-dockercli/>将 <code>docker</code> CLI 命令映射到 <code>crictl</code></a>.</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-cbd33a50cc4779f855318a0dd00d7b06>3 - 审计</h1>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.23 [beta]</code>
</div>
<p>Kubernetes <em>审计（Auditing）</em> 功能提供了与安全相关的、按时间顺序排列的记录集，
记录每个用户、使用 Kubernetes API 的应用以及控制面自身引发的活动。</p>
<p>审计功能使得集群管理员能够回答以下问题：</p>
<ul>
<li>发生了什么？</li>
<li>什么时候发生的？</li>
<li>谁触发的？</li>
<li>活动发生在哪个（些）对象上？</li>
<li>在哪观察到的？</li>
<li>它从哪触发的？</li>
<li>活动的后续处理行为是什么？</li>
</ul>
<p>审计记录最初产生于
<a href=/zh/docs/reference/command-line-tools-reference/kube-apiserver/>kube-apiserver</a>
内部。每个请求在不同执行阶段都会生成审计事件；这些审计事件会根据特定策略
被预处理并写入后端。策略确定要记录的内容和用来存储记录的后端。
当前的后端支持日志文件和 webhook。</p>
<p>每个请求都可被记录其相关的 <em>阶段（stage）</em>。已定义的阶段有：</p>
<ul>
<li><code>RequestReceived</code> - 此阶段对应审计处理器接收到请求后，并且在委托给
其余处理器之前生成的事件。</li>
<li><code>ResponseStarted</code> - 在响应消息的头部发送后，响应消息体发送前生成的事件。
只有长时间运行的请求（例如 watch）才会生成这个阶段。</li>
<li><code>ResponseComplete</code> - 当响应消息体完成并且没有更多数据需要传输的时候。</li>
<li><code>Panic</code> - 当 panic 发生时生成。</li>
</ul>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> <a href=/zh/docs/reference/config-api/apiserver-audit.v1/#audit-k8s-io-v1-Event>审计事件配置</a>
的配置与 <a href=/zh/docs/reference/generated/kubernetes-api/v1.23/#event-v1-core>Event</a>
API 对象不同。
</div>
<p>审计日志记录功能会增加 API server 的内存消耗，因为需要为每个请求存储审计所需的某些上下文。
此外，内存消耗取决于审计日志记录的配置。</p>
<h2 id=audit-policy>审计策略 </h2>
<p>审计政策定义了关于应记录哪些事件以及应包含哪些数据的规则。
审计策略对象结构定义在
<a href=/zh/docs/reference/config-api/apiserver-audit.v1/#audit-k8s-io-v1-Policy><code>audit.k8s.io</code> API 组</a>
处理事件时，将按顺序与规则列表进行比较。第一个匹配规则设置事件的
<em>审计级别（Audit Level）</em>。已定义的审计级别有：</p>
<ul>
<li><code>None</code> - 符合这条规则的日志将不会记录。</li>
<li><code>Metadata</code> - 记录请求的元数据（请求的用户、时间戳、资源、动词等等），
但是不记录请求或者响应的消息体。</li>
<li><code>Request</code> - 记录事件的元数据和请求的消息体，但是不记录响应的消息体。
这不适用于非资源类型的请求。</li>
<li><code>RequestResponse</code> - 记录事件的元数据，请求和响应的消息体。这不适用于非资源类型的请求。</li>
</ul>
<p>你可以使用 <code>--audit-policy-file</code> 标志将包含策略的文件传递给 <code>kube-apiserver</code>。
如果不设置该标志，则不记录事件。
注意 <code>rules</code> 字段 <strong>必须</strong> 在审计策略文件中提供。没有（0）规则的策略将被视为非法配置。</p>
<p>以下是一个审计策略文件的示例：</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/audit/audit-policy.yaml download=audit/audit-policy.yaml><code>audit/audit-policy.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('audit-audit-policy-yaml')" title="Copy audit/audit-policy.yaml to clipboard">
</img>
</div>
<div class=includecode id=audit-audit-policy-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>audit.k8s.io/v1<span style=color:#bbb> </span><span style=color:#080;font-style:italic># This is required.</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Policy<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># Don&#39;t generate audit events for all requests in RequestReceived stage.</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>omitStages</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;RequestReceived&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># Log pod changes at RequestResponse level</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>level</span>:<span style=color:#bbb> </span>RequestResponse<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>group</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># Resource &#34;pods&#34; doesn&#39;t match requests to any subresource of pods,</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># which is consistent with the RBAC policy.</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;pods&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># Log &#34;pods/log&#34;, &#34;pods/status&#34; at Metadata level</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>level</span>:<span style=color:#bbb> </span>Metadata<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>group</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;pods/log&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;pods/status&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># Don&#39;t log requests to a configmap called &#34;controller-leader&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>level</span>:<span style=color:#bbb> </span>None<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>group</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;configmaps&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>resourceNames</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;controller-leader&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># Don&#39;t log watch requests by the &#34;system:kube-proxy&#34; on endpoints or services</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>level</span>:<span style=color:#bbb> </span>None<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>users</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;system:kube-proxy&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;watch&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>group</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&#34;</span><span style=color:#bbb> </span><span style=color:#080;font-style:italic># core API group</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;endpoints&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;services&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># Don&#39;t log authenticated requests to certain non-resource URL paths.</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>level</span>:<span style=color:#bbb> </span>None<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>userGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;system:authenticated&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>nonResourceURLs</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;/api*&#34;</span><span style=color:#bbb> </span><span style=color:#080;font-style:italic># Wildcard matching.</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;/version&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># Log the request body of configmap changes in kube-system.</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>level</span>:<span style=color:#bbb> </span>Request<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>group</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&#34;</span><span style=color:#bbb> </span><span style=color:#080;font-style:italic># core API group</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;configmaps&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># This rule only applies to resources in the &#34;kube-system&#34; namespace.</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># The empty string &#34;&#34; can be used to select non-namespaced resources.</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>namespaces</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;kube-system&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># Log configmap and secret changes in all other namespaces at the Metadata level.</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>level</span>:<span style=color:#bbb> </span>Metadata<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>group</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&#34;</span><span style=color:#bbb> </span><span style=color:#080;font-style:italic># core API group</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;secrets&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;configmaps&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># Log all other resources in core and extensions at the Request level.</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>level</span>:<span style=color:#bbb> </span>Request<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>group</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&#34;</span><span style=color:#bbb> </span><span style=color:#080;font-style:italic># core API group</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>group</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;extensions&#34;</span><span style=color:#bbb> </span><span style=color:#080;font-style:italic># Version of group should NOT be included.</span><span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># A catch-all rule to log all other requests at the Metadata level.</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>level</span>:<span style=color:#bbb> </span>Metadata<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># Long-running requests like watches that fall under this rule will not</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># generate an audit event in RequestReceived.</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>omitStages</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:#b44>&#34;RequestReceived&#34;</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>你可以使用最低限度的审计策略文件在 <code>Metadata</code> 级别记录所有请求：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#080;font-style:italic># 在 Metadata 级别为所有请求生成日志</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>audit.k8s.io/v1beta1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Policy<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>level</span>:<span style=color:#bbb> </span>Metadata<span style=color:#bbb>
</span></code></pre></div>
<p>如果你在打磨自己的审计配置文件，你可以使用为 Google Container-Optimized OS
设计的审计配置作为出发点。你可以参考
<a href=https://github.com/kubernetes/kubernetes/blob/master/cluster/gce/gci/configure-helper.sh>configure-helper.sh</a>
脚本，该脚本能够生成审计策略文件。你可以直接在脚本中看到审计策略的绝大部份内容。</p>
<p>你也可以参考 <a href=/zh/docs/reference/config-api/apiserver-audit.v1/#audit-k8s-io-v1-Policy><code>Policy</code> 配置参考</a>
以获取有关已定义字段的详细信息。</p>
<h2 id=audit-backends>审计后端 </h2>
<p>审计后端实现将审计事件导出到外部存储。<code>Kube-apiserver</code> 默认提供两个后端：</p>
<ul>
<li>Log 后端，将事件写入到文件系统</li>
<li>Webhook 后端，将事件发送到外部 HTTP API</li>
</ul>
<p>在这所有情况下，审计事件均遵循 Kubernetes API 在
<a href=/zh/docs/reference/config-api/apiserver-audit.v1/#audit-k8s-io-v1-Event><code>audit.k8s.io</code> API 组</a>
中定义的结构。</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> <p>对于 patch 请求，请求的消息体需要是设定 patch 操作的 JSON 所构成的一个串，
而不是一个完整的 Kubernetes API 对象 JSON 串。
例如，以下的示例是一个合法的 patch 请求消息体，该请求对应
<code>/apis/batch/v1/namespaces/some-namespace/jobs/some-job-name</code>。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>[
  {
    <span style=color:green;font-weight:700>&#34;op&#34;</span>: <span style=color:#b44>&#34;replace&#34;</span>,
    <span style=color:green;font-weight:700>&#34;path&#34;</span>: <span style=color:#b44>&#34;/spec/parallelism&#34;</span>,
    <span style=color:green;font-weight:700>&#34;value&#34;</span>: <span style=color:#666>0</span>
  },
  {
    <span style=color:green;font-weight:700>&#34;op&#34;</span>: <span style=color:#b44>&#34;remove&#34;</span>,
    <span style=color:green;font-weight:700>&#34;path&#34;</span>: <span style=color:#b44>&#34;/spec/template/spec/containers/0/terminationMessagePolicy&#34;</span>
  }
]
</code></pre></div>
</div>
<h3 id=log-后端>Log 后端</h3>
<p>Log 后端将审计事件写入 <a href=https://jsonlines.org/>JSONlines</a> 格式的文件。
你可以使用以下 <code>kube-apiserver</code> 标志配置 Log 审计后端：</p>
<ul>
<li><code>--audit-log-path</code> 指定用来写入审计事件的日志文件路径。不指定此标志会禁用日志后端。<code>-</code> 意味着标准化</li>
<li><code>--audit-log-maxage</code> 定义保留旧审计日志文件的最大天数</li>
<li><code>--audit-log-maxbackup</code> 定义要保留的审计日志文件的最大数量</li>
<li><code>--audit-log-maxsize</code> 定义审计日志文件的最大大小（兆字节）</li>
</ul>
<p>如果你的集群控制面以 Pod 的形式运行 kube-apiserver，记得要通过 <code>hostPath</code>
卷来访问策略文件和日志文件所在的目录，这样审计记录才会持久保存下来。例如：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>  --audit-policy-file<span style=color:#666>=</span>/etc/kubernetes/audit-policy.yaml
  --audit-log-path<span style=color:#666>=</span>/var/log/kubernetes/audit/audit.log
</code></pre></div><p>接下来挂载数据卷：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/etc/kubernetes/audit-policy.yaml<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>audit<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/var/log/kubernetes/audit/<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>audit-log<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>false</span><span style=color:#bbb>
</span></code></pre></div>
<p>最后配置 <code>hostPath</code>：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>audit<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>hostPath</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/etc/kubernetes/audit-policy.yaml<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>File<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>audit-log<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>hostPath</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/var/log/kubernetes/audit/<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>DirectoryOrCreate<span style=color:#bbb>
</span></code></pre></div>
<h3 id=webhook-backend>Webhook 后端 </h3>
<p>Webhook 后端将审计事件发送到远程 Web API，该远程 API 应该暴露与 <code>kube-apiserver</code>
形式相同的 API，包括其身份认证机制。你可以使用如下 kube-apiserver 标志来配置
Webhook 审计后端：</p>
<ul>
<li><code>--audit-webhook-config-file</code> 设置 Webhook 配置文件的路径。Webhook 配置文件实际上是一个
<a href=/zh/docs/concepts/configuration/organize-cluster-access-kubeconfig/>kubeconfig 文件</a>。</li>
<li><code>--audit-webhook-initial-backoff</code> 指定在第一次失败后重发请求等待的时间。随后的请求将以指数退避重试。</li>
</ul>
<p>Webhook 配置文件使用 kubeconfig 格式指定服务的远程地址和用于连接它的凭据。</p>
<h2 id=batching>事件批处理 </h2>
<p>日志和 Webhook 后端都支持批处理。以 Webhook 为例，以下是可用参数列表。要获取日志
后端的同样参数，请在参数名称中将 <code>webhook</code> 替换为 <code>log</code>。
默认情况下，在 <code>webhook</code> 中批处理是被启用的，在 <code>log</code> 中批处理是被禁用的。
同样，默认情况下，在 <code>webhook</code> 中启用带宽限制，在 <code>log</code> 中禁用带宽限制。</p>
<ul>
<li><code>--audit-webhook-mode</code> 定义缓存策略，可选值如下：
<ul>
<li><code>batch</code> - 以批处理缓存事件和异步的过程。这是默认值。</li>
<li><code>blocking</code> - 在 API 服务器处理每个单独事件时，阻塞其响应。</li>
<li><code>blocking-strict</code> - 与 <code>blocking</code> 相同，不过当审计日志在 RequestReceived 阶段
失败时，整个 API 服务请求会失效。</li>
</ul>
</li>
</ul>
<p>以下参数仅用于 <code>batch</code> 模式。</p>
<ul>
<li><code>--audit-webhook-batch-buffer-size</code> 定义 batch 之前要缓存的事件数。
如果传入事件的速率溢出缓存区，则会丢弃事件。</li>
<li><code>--audit-webhook-batch-max-size</code> 定义一个 batch 中的最大事件数。</li>
<li><code>--audit-webhook-batch-max-wait</code> 无条件 batch 队列中的事件前等待的最大事件。</li>
<li><code>--audit-webhook-batch-throttle-qps</code> 每秒生成的最大批次数。</li>
<li><code>--audit-webhook-batch-throttle-burst</code> 在达到允许的 QPS 前，同一时刻允许存在的最大 batch 生成数。</li>
</ul>
<h2 id=parameter-tuning>参数调整 </h2>
<p>需要设置参数以适应 API 服务器上的负载。</p>
<p>例如，如果 kube-apiserver 每秒收到 100 个请求，并且每个请求仅在 <code>ResponseStarted</code>
和 <code>ResponseComplete</code> 阶段进行审计，则应该考虑每秒生成约 200 个审计事件。
假设批处理中最多有 100 个事件，则应将限制级别设置为每秒至少 2 个查询。
假设后端最多需要 5 秒钟来写入事件，你应该设置缓冲区大小以容纳最多 5 秒的事件，
即 10 个 batch，即 1000 个事件。</p>
<p>但是，在大多数情况下，默认参数应该足够了，你不必手动设置它们。
你可以查看 kube-apiserver 公开的以下 Prometheus 指标，并在日志中监控审计子系统的状态。</p>
<ul>
<li><code>apiserver_audit_event_total</code> 包含所有暴露的审计事件数量的指标。</li>
<li><code>apiserver_audit_error_total</code> 在暴露时由于发生错误而被丢弃的事件的数量。</li>
</ul>
<h3 id=truncate>日志条目截断 </h3>
<p>日志后端和 Webhook 后端都支持限制所输出的事件的尺寸。
例如，下面是可以为日志后端配置的标志列表：</p>
<ul>
<li><code>audit-log-truncate-enabled</code>：是否弃用事件和批次的截断处理。</li>
<li><code>audit-log-truncate-max-batch-size</code>：向下层后端发送的各批次的最大尺寸字节数。</li>
<li><code>audit-log-truncate-max-event-size</code>：向下层后端发送的审计事件的最大尺寸字节数。</li>
</ul>
<p>默认情况下，截断操作在 <code>webhook</code> 和 <code>log</code> 后端都是被禁用的，集群管理员需要设置
<code>audit-log-truncate-enabled</code> 或 <code>audit-webhook-truncate-enabled</code> 标志来启用此操作。</p>
<h2 id=what-s-next>What's next</h2>
<ul>
<li>了解 <a href=/zh/docs/reference/access-authn-authz/extensible-admission-controllers/#mutating-webhook-auditing-annotations>Mutating webhook 审计注解</a>。</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-3556c4dbd027b9e90a5b3d72649003fb>4 - 应用故障排查</h1>
<p>本指南帮助用户调试那些部署到 Kubernetes 上后没有正常运行的应用。
本指南 <em>并非</em> 指导用户如何调试集群。
如果想调试集群的话，请参阅<a href=/zh/docs/tasks/debug-application-cluster/debug-cluster/>这里</a>。</p>
<h2 id=diagnosing-the-problem>诊断问题 </h2>
<p>故障排查的第一步是先给问题分类。问题是什么？是关于 Pods、Replication Controller 还是 Service？</p>
<ul>
<li><a href=#debugging-pods>调试 Pods</a></li>
<li><a href=#debugging-replication-controllers>调试副本控制器</a></li>
<li><a href=#debugging-services>调试服务</a></li>
</ul>
<h3 id=debugging-pods>调试 Pods </h3>
<p>调试 Pod 的第一步是查看 Pod 信息。用如下命令查看 Pod 的当前状态和最近的事件：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe pods <span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>POD_NAME</span><span style=color:#b68;font-weight:700>}</span>
</code></pre></div>
<p>查看一下 Pod 中的容器所处的状态。这些容器的状态都是 <code>Running</code> 吗？最近有没有重启过？</p>
<p>后面的调试都是要依靠 Pod 的状态的。</p>
<h4 id=pod-停滞在-pending-状态>Pod 停滞在 Pending 状态</h4>
<p>如果一个 Pod 停滞在 <code>Pending</code> 状态，表示 Pod 没有被调度到节点上。通常这是因为
某种类型的资源不足导致无法调度。
查看上面的 <code>kubectl describe ...</code> 命令的输出，其中应该显示了为什么没被调度的原因。
常见原因如下：</p>
<ul>
<li>
<p><strong>资源不足</strong>:
你可能耗尽了集群上所有的 CPU 或内存。此时，你需要删除 Pod、调整资源请求或者为集群添加节点。
更多信息请参阅<a href=/zh/docs/concepts/configuration/manage-resources-containers/>计算资源文档</a></p>
</li>
<li>
<p><strong>使用了 <code>hostPort</code></strong>:
如果绑定 Pod 到 <code>hostPort</code>，那么能够运行该 Pod 的节点就有限了。
多数情况下，<code>hostPort</code> 是非必要的，而应该采用 Service 对象来暴露 Pod。
如果确实需要使用 <code>hostPort</code>，那么集群中节点的个数就是所能创建的 Pod
的数量上限。</p>
</li>
</ul>
<h4 id=pod-停滞在-waiting-状态>Pod 停滞在 Waiting 状态</h4>
<p>如果 Pod 停滞在 <code>Waiting</code> 状态，则表示 Pod 已经被调度到某工作节点，但是无法在该节点上运行。
同样，<code>kubectl describe ...</code> 命令的输出可能很有用。
<code>Waiting</code> 状态的最常见原因是拉取镜像失败。要检查的有三个方面：</p>
<ul>
<li>确保镜像名字拼写正确</li>
<li>确保镜像已被推送到镜像仓库</li>
<li>尝试手动是否能拉取镜像。例如，如果你在你的 PC 上使用 Docker，请运行 <code>docker pull &lt;镜像></code>。</li>
</ul>
<h4 id=pod-处于-crashing-或别的不健康状态>Pod 处于 Crashing 或别的不健康状态</h4>
<p>一旦 Pod 被调度，就可以采用
<a href=/zh/docs/tasks/debug/debug-application/debug-running-pod/>调试运行中的 Pod</a>
中的方法来进一步调试。</p>
<h4 id=pod-处于-running-态但是没有正常工作>Pod 处于 Running 态但是没有正常工作</h4>
<p>如果 Pod 行为不符合预期，很可能 Pod 描述（例如你本地机器上的 <code>mypod.yaml</code>）中有问题，
并且该错误在创建 Pod 时被忽略掉，没有报错。
通常，Pod 的定义中节区嵌套关系错误、字段名字拼错的情况都会引起对应内容被忽略掉。
例如，如果你误将 <code>command</code> 写成 <code>commnd</code>，Pod 虽然可以创建，但它不会执行
你期望它执行的命令行。</p>
<p>可以做的第一件事是删除你的 Pod，并尝试带有 <code>--validate</code> 选项重新创建。
例如，运行 <code>kubectl apply --validate -f mypod.yaml</code>。
如果 <code>command</code> 被误拼成 <code>commnd</code>，你将会看到下面的错误信息：</p>
<pre><code>I0805 10:43:25.129850   46757 schema.go:126] unknown field: commnd
I0805 10:43:25.129973   46757 schema.go:129] this may be a false alarm, see https://github.com/kubernetes/kubernetes/issues/6842
pods/mypod
</code></pre>
<p>接下来就要检查的是 API 服务器上的 Pod 与你所期望创建的是否匹配
（例如，你原本使用本机上的一个 YAML 文件来创建 Pod）。
例如，运行 <code>kubectl get pods/mypod -o yaml > mypod-on-apiserver.yaml</code>，之后
手动比较 <code>mypod.yaml</code> 与从 API 服务器取回的 Pod 描述。
从 API 服务器处获得的 YAML 通常包含一些创建 Pod 所用的 YAML 中不存在的行，这是正常的。
不过，如果如果源文件中有些行在 API 服务器版本中不存在，则意味着
Pod 规约是有问题的。</p>
<h3 id=debugging-replication-controllers>调试副本控制器 </h3>
<p>副本控制器相对比较简单直接。它们要么能创建 Pod，要么不能。
如果不能创建 Pod，请参阅<a href=#debugging-pods>上述说明</a>调试 Pod。</p>
<p>你也可以使用 <code>kubectl describe rc ${CONTROLLER_NAME}</code> 命令来检视副本控制器相关的事件。</p>
<h3 id=debugging-services>调试服务 </h3>
<p>服务支持在多个 Pod 间负载均衡。
有一些常见的问题可以造成服务无法正常工作。
以下说明将有助于调试服务的问题。</p>
<p>首先，验证服务是否有端点。对于每一个 Service 对象，API 服务器为其提供
对应的 <code>endpoints</code> 资源。</p>
<p>通过如下命令可以查看 endpoints 资源：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get endpoints <span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>SERVICE_NAME</span><span style=color:#b68;font-weight:700>}</span>
</code></pre></div>
<p>确保 Endpoints 与服务成员 Pod 个数一致。
例如，如果你的 Service 用来运行 3 个副本的 nginx 容器，你应该会在服务的 Endpoints
中看到 3 个不同的 IP 地址。</p>
<h4 id=服务缺少-endpoints>服务缺少 Endpoints</h4>
<p>如果没有 Endpoints，请尝试使用 Service 所使用的标签列出 Pod。
假定你的服务包含如下标签选择算符：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span></code></pre></div>
<p>你可以使用如下命令列出与选择算符相匹配的 Pod，并验证这些 Pod 是否归属于创建的服务：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods --selector<span style=color:#666>=</span><span style=color:#b8860b>name</span><span style=color:#666>=</span>nginx,type<span style=color:#666>=</span>frontend
</code></pre></div>
<p>验证 Pod 的 <code>containerPort</code> 与服务的 <code>targetPort</code> 是否匹配。</p>
<h4 id=网络流量未被转发>网络流量未被转发</h4>
<p>请参阅<a href=/zh/docs/tasks/debug-application-cluster/debug-service/>调试 service</a> 了解更多信息。</p>
<h2 id=what-s-next>What's next</h2>
<p>如果上述方法都不能解决你的问题，请按照
<a href=/zh/docs/tasks/debug-application-cluster/debug-service/>调试服务文档</a>中的介绍，
确保你的 <code>Service</code> 处于 Running 态，有 <code>Endpoints</code> 被创建，<code>Pod</code> 真的在提供服务；
DNS 服务已配置并正常工作，iptables 规则也以安装并且 <code>kube-proxy</code> 也没有异常行为。</p>
<p>你也可以访问<a href=/zh/docs/tasks/debug-application-cluster/troubleshooting/>故障排查文档</a>来获取更多信息。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-434e0133d71583a27478b10fc1d3d105>5 - 故障诊断</h1>
<p>有时候事情会出错。本指南旨在解决这些问题。它包含两个部分：</p>
<ul>
<li><a href=/zh/docs/tasks/debug-application-cluster/debug-application/>应用排错</a> -
针对部署代码到 Kubernetes 并想知道代码为什么不能正常运行的用户。</li>
<li><a href=/zh/docs/tasks/debug-application-cluster/debug-cluster/>集群排错</a> -
针对集群管理员以及 Kubernetes 集群表现异常的用户。</li>
</ul>
<p>你也应该查看所用<a href=https://github.com/kubernetes/kubernetes/releases>发行版本</a>的已知问题。</p>
<h2 id=getting-help>获取帮助 </h2>
<p>如果你的问题在上述指南中没有得到答案，你还有另外几种方式从 Kubernetes 团队获得帮助。</p>
<h3 id=questions>问题 </h3>
<p>本网站上的文档针对回答各类问题进行了结构化组织和分类。
<a href=/zh/docs/concepts/>概念</a>部分解释 Kubernetes 体系结构以及每个组件的工作方式，
<a href=/zh/docs/setup/>安装</a>部分提供了安装的实用说明。
<a href=/zh/docs/tasks/>任务</a>部分展示了如何完成常用任务，
<a href=/zh/docs/tutorials/>教程</a>部分则提供对现实世界、特定行业或端到端开发场景的更全面的演练。
<a href=/zh/docs/reference/>参考</a>部分提供了详细的
<a href=/docs/reference/generated/kubernetes-api/v1.23/>Kubernetes API</a> 文档
和命令行 (CLI) 接口的文档，例如<a href=/zh/docs/reference/kubectl/><code>kubectl</code></a>。</p>
<h2 id=求救-我的问题还没有解决-我现在需要帮助>求救！我的问题还没有解决！我现在需要帮助！</h2>
<h3 id=stack-overflow>Stack Overflow </h3>
<p>社区中的其他人可能已经问过和你类似的问题，也可能能够帮助解决你的问题。
Kubernetes 团队还会监视<a href=https://stackoverflow.com/questions/tagged/kubernetes>带有 Kubernetes 标签的帖子</a>。
如果现有的问题对你没有帮助，在<a href="https://stackoverflow.com/questions/ask?tags=kubernetes">问一个新问题</a>
之前，<strong>请<a href=https://stackoverflow.com/help/on-topic>确保你的问题是关于 Stack Overflow 的主题</a>
并且你需要阅读关于<a href=https://stackoverflow.com/help/how-to-ask>如何提出新问题</a>
的指南。</strong></p>
<h3 id=slack>Slack</h3>
<p>Kubernetes 社区中有很多人在 <code>#kubernetes-users</code> 这一 Slack 频道聚集。
Slack 需要注册；你可以<a href=https://slack.kubernetes.io>请求一份邀请</a>，
并且注册是对所有人开放的。欢迎你随时来问任何问题。
一旦注册了，就可以访问通过 Web 浏览器或者 Slack 专用的应用访问
<a href=https://kubernetes.slack.com>Slack 上的 Kubernetes 组织</a>。</p>
<p>一旦你完成了注册，就可以浏览各种感兴趣主题的频道列表（一直在增长）。
例如，Kubernetes 新人可能还想加入
<a href=https://kubernetes.slack.com/messages/kubernetes-novice><code>#kubernetes-novice</code></a>
频道。又比如，开发人员应该加入
<a href=https://kubernetes.slack.com/messages/kubernetes-dev><code>#kubernetes-dev</code></a>
频道。</p>
<p>还有许多国家/地区语言频道。请随时加入这些频道以获得本地化支持和信息：</p>
<table><caption style=display:none>Country / language specific Slack channels</caption>
<thead>
<tr>
<th style=text-align:left>国家</th>
<th style=text-align:left>频道</th>
</tr>
</thead>
<tbody>
<tr>
<td style=text-align:left>中国</td>
<td style=text-align:left><a href=https://kubernetes.slack.com/messages/cn-users><code>#cn-users</code></a>, <a href=https://kubernetes.slack.com/messages/cn-events><code>#cn-events</code></a></td>
</tr>
<tr>
<td style=text-align:left>芬兰</td>
<td style=text-align:left><a href=https://kubernetes.slack.com/messages/fi-users><code>#fi-users</code></a></td>
</tr>
<tr>
<td style=text-align:left>法国</td>
<td style=text-align:left><a href=https://kubernetes.slack.com/messages/fr-users><code>#fr-users</code></a>, <a href=https://kubernetes.slack.com/messages/fr-events><code>#fr-events</code></a></td>
</tr>
<tr>
<td style=text-align:left>德国</td>
<td style=text-align:left><a href=https://kubernetes.slack.com/messages/de-users><code>#de-users</code></a>, <a href=https://kubernetes.slack.com/messages/de-events><code>#de-events</code></a></td>
</tr>
<tr>
<td style=text-align:left>印度</td>
<td style=text-align:left><a href=https://kubernetes.slack.com/messages/in-users><code>#in-users</code></a>, <a href=https://kubernetes.slack.com/messages/in-events><code>#in-events</code></a></td>
</tr>
<tr>
<td style=text-align:left>意大利</td>
<td style=text-align:left><a href=https://kubernetes.slack.com/messages/it-users><code>#it-users</code></a>, <a href=https://kubernetes.slack.com/messages/it-events><code>#it-events</code></a></td>
</tr>
<tr>
<td style=text-align:left>日本</td>
<td style=text-align:left><a href=https://kubernetes.slack.com/messages/jp-users><code>#jp-users</code></a>, <a href=https://kubernetes.slack.com/messages/jp-events><code>#jp-events</code></a></td>
</tr>
<tr>
<td style=text-align:left>韩国</td>
<td style=text-align:left><a href=https://kubernetes.slack.com/messages/kr-users><code>#kr-users</code></a></td>
</tr>
<tr>
<td style=text-align:left>荷兰</td>
<td style=text-align:left><a href=https://kubernetes.slack.com/messages/nl-users><code>#nl-users</code></a></td>
</tr>
<tr>
<td style=text-align:left>挪威</td>
<td style=text-align:left><a href=https://kubernetes.slack.com/messages/norw-users><code>#norw-users</code></a></td>
</tr>
<tr>
<td style=text-align:left>波兰</td>
<td style=text-align:left><a href=https://kubernetes.slack.com/messages/pl-users><code>#pl-users</code></a></td>
</tr>
<tr>
<td style=text-align:left>俄罗斯</td>
<td style=text-align:left><a href=https://kubernetes.slack.com/messages/ru-users><code>#ru-users</code></a></td>
</tr>
<tr>
<td style=text-align:left>西班牙</td>
<td style=text-align:left><a href=https://kubernetes.slack.com/messages/es-users><code>#es-users</code></a></td>
</tr>
<tr>
<td style=text-align:left>瑞典</td>
<td style=text-align:left><a href=https://kubernetes.slack.com/messages/se-users><code>#se-users</code></a></td>
</tr>
<tr>
<td style=text-align:left>土耳其</td>
<td style=text-align:left><a href=https://kubernetes.slack.com/messages/tr-users><code>#tr-users</code></a>, <a href=https://kubernetes.slack.com/messages/tr-events><code>#tr-events</code></a></td>
</tr>
</tbody>
</table>
<h3 id=forum>论坛 </h3>
<p>欢迎你加入 Kubernetes 官方论坛
<a href=https://discuss.kubernetes.io>discuss.kubernetes.io</a>。</p>
<h3 id=bugs-and-feature-requests>Bugs 和功能请求 </h3>
<p>如果你发现一个看起来像 Bug 的问题，或者你想提出一个功能请求，请使用
<a href=https://github.com/kubernetes/kubernetes/issues>Github 问题跟踪系统</a>。</p>
<p>在提交问题之前，请搜索现有问题列表以查看是否其中已涵盖你的问题。</p>
<p>如果提交 Bug，请提供如何重现问题的详细信息，例如：</p>
<ul>
<li>Kubernetes 版本：<code>kubectl version</code></li>
<li>云平台、OS 发行版、网络配置和 Docker 版本</li>
<li>重现问题的步骤</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-ef360b1f8e65236251826db478cfcab3>6 - 确定 Pod 失败的原因</h1>
<p>本文介绍如何编写和读取容器的终止消息。</p>
<p>终止消息为容器提供了一种方法，可以将有关致命事件的信息写入某个位置，
在该位置可以通过仪表板和监控软件等工具轻松检索和显示致命事件。
在大多数情况下，您放入终止消息中的信息也应该写入
<a href=/zh/docs/concepts/cluster-administration/logging/>常规 Kubernetes 日志</a>。</p>
<h2 id=before-you-begin>Before you begin</h2>
<p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li>
</ul>
To check the version, enter <code>kubectl version</code>.
</p>
<h2 id=读写终止消息>读写终止消息</h2>
<p>在本练习中，您将创建运行一个容器的 Pod。
配置文件指定在容器启动时要运行的命令。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/debug/termination.yaml download=debug/termination.yaml><code>debug/termination.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('debug-termination-yaml')" title="Copy debug/termination.yaml to clipboard">
</img>
</div>
<div class=includecode id=debug-termination-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>termination-demo<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>termination-demo-container<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>debian<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;/bin/sh&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;-c&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;sleep 10 &amp;&amp; echo Sleep expired &gt; /dev/termination-log&#34;</span>]<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<ol>
<li>
基于 YAML 配置文件创建 Pod：
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create -f https://k8s.io/examples/debug/termination.yaml
</code></pre></div>
<p>YAML 文件中，在 <code>command</code> 和 <code>args</code> 字段，你可以看到容器休眠 10 秒然后将 "Sleep expired"
写入 <code>/dev/termination-log</code> 文件。
容器写完 "Sleep expired" 消息后就终止了。</p>
</li>
<li>
显示 Pod 的信息：
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod termination-demo
</code></pre></div>
<p>重复前面的命令直到 Pod 不再运行。</p>
</li>
<li>
<p>显示 Pod 的详细信息：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod --output<span style=color:#666>=</span>yaml
</code></pre></div>输出结果包含 "Sleep expired" 消息：
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>lastState</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>terminated</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>containerID</span>:<span style=color:#bbb> </span>...<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>exitCode</span>:<span style=color:#bbb> </span><span style=color:#666>0</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>finishedAt</span>:<span style=color:#bbb> </span>...<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>message</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span><span style=color:#b44;font-style:italic>          </span><span style=color:#bbb>          </span>Sleep expired<span style=color:#bbb>
</span><span style=color:#bbb>        </span>...<span style=color:#bbb>
</span></code></pre></div></li>
<li>
<p>使用 Go 模板过滤输出结果，使其只含有终止消息：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod termination-demo -o go-template<span style=color:#666>=</span><span style=color:#b44>&#34;{{range .status.containerStatuses}}{{.lastState.terminated.message}}{{end}}&#34;</span>
</code></pre></div></li>
</ol>
<p>&lt;!
If you are running a multi-container pod, you can use a Go template to include the container's name. By doing so, you can discover which of the containers is failing:
-->
如果你正在运行多容器 Pod，则可以使用 Go 模板来包含容器的名称。这样，你可以发现哪些容器出现故障:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod multi-container-pod -o go-template<span style=color:#666>=</span><span style=color:#b44>&#39;{{range .status.containerStatuses}}{{printf &#34;%s:\n%s\n\n&#34; .name .lastState.terminated.message}}{{end}}&#39;</span>
</code></pre></div>
<h2 id=定制终止消息>定制终止消息</h2>
<p>Kubernetes 从容器的 <code>terminationMessagePath</code> 字段中指定的终止消息文件中检索终止消息，
默认值为 <code>/dev/termination-log</code>。
通过定制这个字段，您可以告诉 Kubernetes 使用不同的文件。
Kubernetes 使用指定文件中的内容在成功和失败时填充容器的状态消息。</p>
<p>在下例中，容器将终止消息写入 <code>/tmp/my-log</code> 给 Kubernetes 来接收：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>msg-path-demo<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>msg-path-demo-container<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>debian<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>terminationMessagePath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/tmp/my-log&#34;</span><span style=color:#bbb>
</span></code></pre></div>
<p>此外，用户可以设置容器的 <code>terminationMessagePolicy</code> 字段，以便进一步自定义。
此字段默认为 "<code>File</code>"，这意味着仅从终止消息文件中检索终止消息。
通过将 <code>terminationMessagePolicy</code> 设置为 "<code>FallbackToLogsOnError</code>"，你就可以告诉 Kubernetes，在容器因错误退出时，如果终止消息文件为空，则使用容器日志输出的最后一块作为终止消息。
日志输出限制为 2048 字节或 80 行，以较小者为准。</p>
<h2 id=what-s-next>What's next</h2>
<ul>
<li>参考 <a href=/docs/reference/generated/kubernetes-api/v1.23/#container-v1-core>Container</a>
资源的 <code>terminationMessagePath</code> 字段。</li>
<li>了解<a href=/zh/docs/concepts/cluster-administration/logging/>接收日志</a>。</li>
<li>了解 <a href=https://golang.org/pkg/text/template/>Go 模版</a>。</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-9713ac27b6d9e3034033200d968221f2>7 - 获取正在运行容器的 Shell</h1>
<p>本文介绍怎样使用 <code>kubectl exec</code> 命令获取正在运行容器的 Shell。</p>
<h2 id=before-you-begin>Before you begin</h2>
<p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li>
</ul>
To check the version, enter <code>kubectl version</code>.
</p>
<h2 id=获取容器的-shell>获取容器的 Shell</h2>
<p>在本练习中，你将创建包含一个容器的 Pod。容器运行 nginx 镜像。下面是 Pod 的配置文件：</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/application/shell-demo.yaml download=application/shell-demo.yaml><code>application/shell-demo.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('application-shell-demo-yaml')" title="Copy application/shell-demo.yaml to clipboard">
</img>
</div>
<div class=includecode id=application-shell-demo-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>shell-demo<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>shared-data<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>emptyDir</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>shared-data<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/usr/share/nginx/html<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>hostNetwork</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>dnsPolicy</span>:<span style=color:#bbb> </span>Default<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>创建 Pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create -f https://k8s.io/examples/application/shell-demo.yaml
</code></pre></div>
<p>检查容器是否运行正常：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod shell-demo
</code></pre></div>
<p>获取正在运行容器的 Shell：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#a2f>exec</span> -it shell-demo -- /bin/bash
</code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>Note:</strong>
<p>双破折号 "--" 用于将要传递给命令的参数与 kubectl 的参数分开。
</div>
<p>在 shell 中，打印根目录：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>root@shell-demo:/# ls /
</code></pre></div>
<p>在 shell 中，实验其他命令。下面是一些示例：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>root@shell-demo:/# ls /
root@shell-demo:/# cat /proc/mounts
root@shell-demo:/# cat /proc/1/maps
root@shell-demo:/# apt-get update
root@shell-demo:/# apt-get install -y tcpdump
root@shell-demo:/# tcpdump
root@shell-demo:/# apt-get install -y lsof
root@shell-demo:/# lsof
root@shell-demo:/# apt-get install -y procps
root@shell-demo:/# ps aux
root@shell-demo:/# ps aux | grep nginx
</code></pre></div>
<h2 id=编写-nginx-的根页面>编写 nginx 的根页面</h2>
<p>在看一下 Pod 的配置文件。该 Pod 有个 <code>emptyDir</code> 卷，容器将该卷挂载到了 <code>/usr/share/nginx/html</code>。</p>
<p>在 shell 中，在 <code>/usr/share/nginx/html</code> 目录创建一个 <code>index.html</code> 文件：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>root@shell-demo:/# <span style=color:#a2f>echo</span> Hello shell demo &gt; /usr/share/nginx/html/index.html
</code></pre></div>
<p>在 shell 中，向 nginx 服务器发送 GET 请求：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>root@shell-demo:/# apt-get update
root@shell-demo:/# apt-get install curl
root@shell-demo:/# curl localhost
</code></pre></div>
<p>输出结果显示了你在 <code>index.html</code> 中写入的文本。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>Hello shell demo
</code></pre></div>
<p>当用完 shell 后，输入 <code>exit</code> 退出。</p>
<h2 id=在容器中运行单个命令>在容器中运行单个命令</h2>
<p>在普通的命令窗口（而不是 shell）中，打印环境运行容器中的变量：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#a2f>exec</span> shell-demo env
</code></pre></div>
<p>实验运行其他命令。下面是一些示例：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#a2f>exec</span> shell-demo ps aux
kubectl <span style=color:#a2f>exec</span> shell-demo ls /
kubectl <span style=color:#a2f>exec</span> shell-demo cat /proc/1/mounts
</code></pre></div>
<h2 id=当-pod-包含多个容器时打开-shell>当 Pod 包含多个容器时打开 shell</h2>
<p>如果 Pod 有多个容器，<code>--container</code> 或者 <code>-c</code> 可以在 <code>kubectl exec</code> 命令中指定容器。
例如，您有个名为 my-pod 的容器，该 Pod 有两个容器分别为 main-app 和 healper-app。
下面的命令将会打开一个 shell 访问 main-app 容器。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#a2f>exec</span> -it my-pod --container main-app -- /bin/bash
</code></pre></div><h2 id=what-s-next>What's next</h2>
<ul>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands/#exec>kubectl exec</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-06bb252f25983de12f635c806d180d30>8 - 调试 Init 容器</h1>
<p>此页显示如何核查与 Init 容器执行相关的问题。
下面的示例命令行将 Pod 称为 <code>&lt;pod-name></code>，而 Init 容器称为 <code>&lt;init-container-1></code> 和
<code>&lt;init-container-2></code>。</p>
<h2 id=before-you-begin>Before you begin</h2>
<p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li>
</ul>
To check the version, enter <code>kubectl version</code>.
</p>
<ul>
<li>你应该熟悉 <a href=/zh/docs/concepts/workloads/pods/init-containers/>Init 容器</a>的基础知识。</li>
<li>你应该已经<a href=/zh/docs/tasks/configure-pod-container/configure-pod-initialization/#creating-a-pod-that-has-an-init-container/>配置好一个 Init 容器</a>。</li>
</ul>
<h2 id=检查-init-容器的状态>检查 Init 容器的状态</h2>
<p>显示你的 Pod 的状态：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod &lt;pod-name&gt;
</code></pre></div>
<p>例如，状态 <code>Init:1/2</code> 表明两个 Init 容器中的一个已经成功完成：</p>
<pre><code>NAME         READY     STATUS     RESTARTS   AGE
&lt;pod-name&gt;   0/1       Init:1/2   0          7s
</code></pre>
<p>更多状态值及其含义请参考<a href=#understanding-pod-status>理解 Pod 的状态</a>。</p>
<h2 id=getting-details-about-init-containers>获取 Init 容器详情 </h2>
<p>查看 Init 容器运行的更多详情：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe pod &lt;pod-name&gt;
</code></pre></div>
<p>例如，对于包含两个 Init 容器的 Pod 可能显示如下信息：</p>
<pre><code>Init Containers:
  &lt;init-container-1&gt;:
    Container ID:    ...
    ...
    State:           Terminated
      Reason:        Completed
      Exit Code:     0
      Started:       ...
      Finished:      ...
    Ready:           True
    Restart Count:   0
    ...
  &lt;init-container-2&gt;:
    Container ID:    ...
    ...
    State:           Waiting
      Reason:        CrashLoopBackOff
    Last State:      Terminated
      Reason:        Error
      Exit Code:     1
      Started:       ...
      Finished:      ...
    Ready:           False
    Restart Count:   3
    ...
</code></pre>
<p>你还可以通过编程方式读取 Pod Spec 上的 <code>status.initContainerStatuses</code> 字段，了解 Init 容器的状态：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod nginx --template <span style=color:#b44>&#39;{{.status.initContainerStatuses}}&#39;</span>
</code></pre></div>
<p>此命令将返回与原始 JSON 中相同的信息.</p>
<h2 id=accessing-logs-from-init-containers>通过 Init 容器访问日志 </h2>
<p>与 Pod 名称一起传递 Init 容器名称，以访问容器的日志。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl logs &lt;pod-name&gt; -c &lt;init-container-2&gt;
</code></pre></div>
<p>运行 Shell 脚本的 Init 容器在执行 Shell 脚本时输出命令本身。
例如，你可以在 Bash 中通过在脚本的开头运行 <code>set -x</code> 来实现。</p>
<h2 id=understanding-pod-status>理解 Pod 的状态 </h2>
<p>以 <code>Init:</code> 开头的 Pod 状态汇总了 Init 容器执行的状态。
下表介绍调试 Init 容器时可能看到的一些状态值示例。</p>
<table>
<thead>
<tr>
<th>状态</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Init:N/M</code></td>
<td>Pod 包含 <code>M</code> 个 Init 容器，其中 <code>N</code> 个已经运行完成。</td>
</tr>
<tr>
<td><code>Init:Error</code></td>
<td>Init 容器已执行失败。</td>
</tr>
<tr>
<td><code>Init:CrashLoopBackOff</code></td>
<td>Init 容器执行总是失败。</td>
</tr>
<tr>
<td><code>Pending</code></td>
<td>Pod 还没有开始执行 Init 容器。</td>
</tr>
<tr>
<td><code>PodInitializing</code> or <code>Running</code></td>
<td>Pod 已经完成执行 Init 容器。</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-858517cd46a1b5a1fd2e650edd785cea>9 - 调试 Pods 和 ReplicationControllers</h1>
<p>此页面展示如何调试 Pod 和 ReplicationController。</p>
<h2 id=before-you-begin>Before you begin</h2>
<p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li>
</ul>
To check the version, enter <code>kubectl version</code>.
</p>
<ul>
<li>你应该先熟悉 <a href=/zh/docs/concepts/workloads/pods/>Pods</a> 和
<a href=/zh/docs/concepts/workloads/pods/pod-lifecycle/>Pod 生命周期</a> 的基础概念。</li>
</ul>
<h2 id=debugging-pods>调试 Pod </h2>
<p>调试一个 pod 的第一步是观察它。使用下面的命令检查 Pod 的当前状态和最近事件：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe pods <span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>POD_NAME</span><span style=color:#b68;font-weight:700>}</span>
</code></pre></div>
<p>看看 Pod 中的容器的状态。它们都是 <code>Running</code> 吗？最近有重启吗？</p>
<p>根据 Pod 的状态继续调试。</p>
<h3 id=我的-pod-停滞在-pending-状态>我的 Pod 停滞在 Pending 状态</h3>
<p>如果 Pod 被卡在 <code>Pending</code> 状态，就意味着它不能调度在某个节点上。一般来说，这是因为某种类型的资源不足而
导致无法调度。 查看上面的命令 <code>kubectl describe ...</code> 的输出。调度器的消息中应该会包含无法调度 Pod 的原因。
原因包括：</p>
<h4 id=资源不足>资源不足</h4>
<p>你可能已经耗尽了集群中供应的 CPU 或内存。在这个情况下你可以尝试几件事情：</p>
<ul>
<li>
<p>向集群中添加节点。</p>
</li>
<li>
<p><a href=/zh/docs/concepts/workloads/pods/pod-lifecycle/#pod-termination>终止不需要的 Pod</a>
为 Pending 状态的 Pod 提供空间。</p>
</li>
<li>
<p>检查该 Pod 是否不大于你的节点。例如，如果全部节点具有 <code>cpu:1</code> 容量，那么具有
请求为 <code>cpu: 1.1</code> 的 Pod 永远不会被调度。</p>
<p>你可以使用 <code>kubectl get nodes -o &lt;format></code> 命令来检查节点容量。
下面是一些能够提取必要信息的命令示例：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get nodes -o yaml | egrep <span style=color:#b44>&#39;\sname:|cpu:|memory:&#39;</span>
kubectl get nodes -o json | jq <span style=color:#b44>&#39;.items[] | {name: .metadata.name, cap: .status.capacity}&#39;</span>
</code></pre></div></li>
</ul>
<p>可以考虑配置<a href=/zh/docs/concepts/policy/resource-quotas/>资源配额</a> 来限制可耗用的资源总量。
如果与命名空间一起使用，它可以防止一个团队吞噬所有的资源。</p>
<h4 id=使用-hostport>使用 hostPort</h4>
<p>当你将一个 Pod 绑定到某 <code>hostPort</code> 时，这个 Pod 能被调度的位置数量有限。
在大多数情况下，<code>hostPort</code> 是不必要的; 尝试使用服务对象来暴露你的 Pod。
如果你需要 <code>hostPort</code>，那么你可以调度的 Pod 数量不能超过集群的节点个数。</p>
<h3 id=我的-pod-一直在-waiting>我的 Pod 一直在 Waiting</h3>
<p>如果 Pod 一直停滞在 <code>Waiting</code> 状态，那么它已被调度在某个工作节点，但它不能在该机器上运行。
再次，来自 <code>kubectl describe ...</code> 的内容应该是可以是很有用的。
最常见的原因 <code>Waiting</code> 的 Pod 是无法拉取镜像。有三件事要检查：</p>
<ul>
<li>确保你的镜像的名称正确。</li>
<li>你是否将镜像推送到存储库？</li>
<li>尝试手动拉取镜像，看能否拉取。例如，如果你在 PC 上使用 Docker，运行 <code>docker pull &lt;image></code>。</li>
</ul>
<h3 id=我的-pod-一直-crashing-或者其他不健康状态>我的 Pod 一直 Crashing 或者其他不健康状态</h3>
<p>一旦 Pod 已经被调度，就可以依据
<a href=/zh/docs/tasks/debug/debug-application/debug-running-pod/>调试运行中的 Pod</a>
展开进一步的调试工作。</p>
<h2 id=调试-replication-controller>调试 Replication Controller</h2>
<p>Replication Controller 相当简单。它们或者能或者不能创建 Pod。如果它们无法创建 Pod，
请参考<a href=#debugging_pods>上面的说明</a> 来调试你的 Pod。</p>
<p>你也可以使用 <code>kubectl describe rc ${CONTROLLER_NAME}</code> 来检查和副本控制器有关的事件。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-f79645981e310858111bd5673614cab6>10 - 调试 Service</h1>
<p>对于新安装的 Kubernetes，经常出现的问题是 Service 无法正常运行。 你已经通过
Deployment（或其他工作负载控制器）运行了 Pod，并创建 Service ，但是
当你尝试访问它时，没有任何响应。此文档有望对你有所帮助并找出问题所在。</p>
<h2 id=在-pod-中运行命令>在 Pod 中运行命令</h2>
<p>对于这里的许多步骤，你可能希望知道运行在集群中的 Pod 看起来是什么样的。
最简单的方法是运行一个交互式的 busybox Pod：</p>
<pre><code class=language-none data-lang=none>kubectl run -it --rm --restart=Never busybox --image=gcr.io/google-containers/busybox sh
</code></pre>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 如果没有看到命令提示符，请按回车。
</div>
<p>如果你已经有了你想使用的正在运行的 Pod，则可以运行以下命令去进入：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#a2f>exec</span> &lt;POD-NAME&gt; -c &lt;CONTAINER-NAME&gt; -- &lt;COMMAND&gt;
</code></pre></div>
<h2 id=setup>设置 </h2>
<p>为了完成本次实践的任务，我们先运行几个 Pod。
由于你可能正在调试自己的 Service，所以，你可以使用自己的信息进行替换，
或者你也可以跟着教程并开始下面的步骤来获得第二个数据点。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl  create deployment hostnames --image<span style=color:#666>=</span>k8s.gcr.io/serve_hostname 
</code></pre></div><pre><code class=language-none data-lang=none>deployment.apps/hostnames created
</code></pre>
<p><code>kubectl</code> 命令将打印创建或变更的资源的类型和名称，它们可以在后续命令中使用。
让我们将这个 deployment 的副本数扩至 3。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl scale deployment hostnames --replicas<span style=color:#666>=</span><span style=color:#666>3</span>
</code></pre></div><pre><code class=language-none data-lang=none>deployment.apps/hostnames scaled
</code></pre>
<p>请注意这与你使用以下 YAML 方式启动 Deployment 类似：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>hostnames<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>hostnames<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>hostnames<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>hostnames<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>hostnames<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/serve_hostname<span style=color:#bbb>
</span></code></pre></div>
<p>"app" 标签是 <code>kubectl create deployment</code> 根据 Deployment 名称自动设置的。</p>
<p>确认你的 Pods 是运行状态:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>hostnames
</code></pre></div><pre><code class=language-none data-lang=none>NAME                        READY     STATUS    RESTARTS   AGE
hostnames-632524106-bbpiw   1/1       Running   0          2m
hostnames-632524106-ly40y   1/1       Running   0          2m
hostnames-632524106-tlaok   1/1       Running   0          2m
</code></pre>
<p>你还可以确认你的 Pod 是否正在提供服务。你可以获取 Pod IP 地址列表并直接对其进行测试。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>hostnames <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>    -o go-template<span style=color:#666>=</span><span style=color:#b44>&#39;{{range .items}}{{.status.podIP}}{{&#34;\n&#34;}}{{end}}&#39;</span>
</code></pre></div><pre><code class=language-none data-lang=none>10.244.0.5
10.244.0.6
10.244.0.7
</code></pre>
<p>用于本教程的示例容器通过 HTTP 在端口 9376 上提供其自己的主机名，
但是如果要调试自己的应用程序，则需要使用你的 Pod 正在侦听的端口号。</p>
<p>在 Pod 内运行：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#a2f;font-weight:700>for</span> ep in 10.244.0.5:9376 10.244.0.6:9376 10.244.0.7:9376; <span style=color:#a2f;font-weight:700>do</span>
    wget -qO- <span style=color:#b8860b>$ep</span>
<span style=color:#a2f;font-weight:700>done</span>
</code></pre></div>
<p>输出类似这样：</p>
<pre><code>hostnames-632524106-bbpiw
hostnames-632524106-ly40y
hostnames-632524106-tlaok
</code></pre>
<p>如果此时你没有收到期望的响应，则你的 Pod 状态可能不健康，或者可能没有在你认为正确的端口上进行监听。
你可能会发现 <code>kubectl logs</code> 命令对于查看正在发生的事情很有用，
或者你可能需要通过<code>kubectl exec</code> 直接进入 Pod 中并从那里进行调试。</p>
<p>假设到目前为止一切都已按计划进行，那么你可以开始调查为何你的 Service 无法正常工作。</p>
<h2 id=service-是否存在>Service 是否存在？</h2>
<p>细心的读者会注意到我们实际上尚未创建 Service -这是有意而为之。 这一步有时会被遗忘，这是首先要检查的步骤。</p>
<p>那么，如果我尝试访问不存在的 Service 会怎样？ 假设你有另一个 Pod 通过名称匹配到 Service ，你将得到类似结果：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>wget -O- hostnames
</code></pre></div><pre><code class=language-none data-lang=none>Resolving hostnames (hostnames)... failed: Name or service not known.
wget: unable to resolve host address 'hostnames'
</code></pre>
<p>首先要检查的是该 Service 是否真实存在：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get svc hostnames
</code></pre></div><pre><code class=language-none data-lang=none>No resources found.
Error from server (NotFound): services &quot;hostnames&quot; not found
</code></pre>
<p>让我们创建 Service。 和以前一样，在这次实践中 - 你可以在此处使用自己的 Service 的内容。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl expose deployment hostnames --port<span style=color:#666>=</span><span style=color:#666>80</span> --target-port<span style=color:#666>=</span><span style=color:#666>9376</span>
</code></pre></div><pre><code class=language-none data-lang=none>service/hostnames exposed
</code></pre>
<p>重新运行查询命令：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get svc hostnames
</code></pre></div><pre><code class=language-none data-lang=none>NAME        TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)   AGE
hostnames   ClusterIP   10.0.1.175   &lt;none&gt;        80/TCP    5s
</code></pre>
<p>现在你知道了 Service 确实存在。</p>
<p>同前，此步骤效果与通过 YAML 方式启动 'Service' 一样：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>hostnames<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>hostnames<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>9376</span><span style=color:#bbb>
</span></code></pre></div>
<p>为了突出配置范围的完整性，你在此处创建的 Service 使用的端口号与 Pods 不同。
对于许多真实的 Service，这些值可以是相同的。</p>
<h2 id=是否存在影响目标-pod-的网络策略入站规则>是否存在影响目标 Pod 的网络策略入站规则？</h2>
<p>如果你部署了任何可能影响到 <code>hostnames-*</code> Pod 的传入流量的网络策略入站规则，
则需要对其进行检查。</p>
<p>详细信息，请参阅<a href=/zh/docs/concepts/services-networking/network-policies/>网络策略</a>。</p>
<h2 id=service-是否可通过-dns-名字访问>Service 是否可通过 DNS 名字访问？</h2>
<p>通常客户端通过 DNS 名称来匹配到 Service。</p>
<p>从相同命名空间下的 Pod 中运行以下命令：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>nslookup hostnames
</code></pre></div><pre><code class=language-none data-lang=none>Address 1: 10.0.0.10 kube-dns.kube-system.svc.cluster.local

Name:      hostnames
Address 1: 10.0.1.175 hostnames.default.svc.cluster.local
</code></pre>
<p>如果失败，那么你的 Pod 和 Service 可能位于不同的命名空间中，
请尝试使用限定命名空间的名称（同样在 Pod 内运行）：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>nslookup hostnames.default
</code></pre></div><pre><code class=language-none data-lang=none>Address 1: 10.0.0.10 kube-dns.kube-system.svc.cluster.local

Name:      hostnames.default
Address 1: 10.0.1.175 hostnames.default.svc.cluster.local
</code></pre>
<p>如果成功，那么需要调整你的应用，使用跨命名空间的名称去访问它，
或者在相同的命名空间中运行应用和 Service。如果仍然失败，请尝试一个完全限定的名称：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>nslookup hostnames.default.svc.cluster.local
</code></pre></div><pre><code class=language-none data-lang=none>Address 1: 10.0.0.10 kube-dns.kube-system.svc.cluster.local

Name:      hostnames.default.svc.cluster.local
Address 1: 10.0.1.175 hostnames.default.svc.cluster.local
</code></pre>
<p>注意这里的后缀："default.svc.cluster.local"。"default" 是我们正在操作的命名空间。
"svc" 表示这是一个 Service。"cluster.local" 是你的集群域，在你自己的集群中可能会有所不同。</p>
<p>你也可以在集群中的节点上尝试此操作：</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 10.0.0.10 是集群的 DNS 服务 IP，你的可能有所不同。
</div>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>nslookup hostnames.default.svc.cluster.local 10.0.0.10
</code></pre></div><pre><code class=language-none data-lang=none>Server:         10.0.0.10
Address:        10.0.0.10#53

Name:   hostnames.default.svc.cluster.local
Address: 10.0.1.175
</code></pre>
<p>如果你能够使用完全限定的名称查找，但不能使用相对名称，则需要检查你 Pod 中的
<code>/etc/resolv.conf</code> 文件是否正确。在 Pod 中运行以下命令：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>cat /etc/resolv.conf
</code></pre></div>
<p>你应该可以看到类似这样的输出：</p>
<pre><code>nameserver 10.0.0.10
search default.svc.cluster.local svc.cluster.local cluster.local example.com
options ndots:5
</code></pre>
<p><code>nameserver</code> 行必须指示你的集群的 DNS Service，
它是通过 <code>--cluster-dns</code> 标志传递到 kubelet 的。</p>
<p><code>search</code> 行必须包含一个适当的后缀，以便查找 Service 名称。
在本例中，它查找本地命名空间（<code>default.svc.cluster.local</code>）中的服务和
所有命名空间（<code>svc.cluster.local</code>）中的服务，最后在集群（<code>cluster.local</code>）中查找
服务的名称。根据你自己的安装情况，可能会有额外的记录（最多 6 条）。
集群后缀是通过 <code>--cluster-domain</code> 标志传递给 <code>kubelet</code> 的。
本文中，我们假定后缀是 “cluster.local”。
你的集群配置可能不同，这种情况下，你应该在上面的所有命令中更改它。</p>
<p><code>options</code> 行必须设置足够高的 <code>ndots</code>，以便 DNS 客户端库考虑搜索路径。
在默认情况下，Kubernetes 将这个值设置为 5，这个值足够高，足以覆盖它生成的所有 DNS 名称。</p>
<h3 id=does-any-service-exist-in-dns>是否存在 Service 能通过 DNS 名称访问？</h3>
<p>如果上面的方式仍然失败，DNS 查找不到你需要的 Service ，你可以后退一步，
看看还有什么其它东西没有正常工作。
Kubernetes 主 Service 应该一直是工作的。在 Pod 中运行如下命令：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>nslookup kubernetes.default
</code></pre></div><pre><code class=language-none data-lang=none>Server:    10.0.0.10
Address 1: 10.0.0.10 kube-dns.kube-system.svc.cluster.local

Name:      kubernetes.default
Address 1: 10.0.0.1 kubernetes.default.svc.cluster.local
</code></pre>
<p>如果失败，你可能需要转到本文的 <a href=#is-the-kube-proxy-working>kube-proxy</a> 节，
或者甚至回到文档的顶部重新开始，但不是调试你自己的 Service ，而是调试 DNS Service。</p>
<h3 id=service-能够通过-ip-访问么>Service 能够通过 IP 访问么？</h3>
<p>假设你已经确认 DNS 工作正常，那么接下来要测试的是你的 Service 能否通过它的 IP 正常访问。
从集群中的一个 Pod，尝试访问 Service 的 IP（从上面的 <code>kubectl get</code> 命令获取）。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#a2f;font-weight:700>for</span> i in <span style=color:#a2f;font-weight:700>$(</span>seq <span style=color:#666>1</span> 3<span style=color:#a2f;font-weight:700>)</span>; <span style=color:#a2f;font-weight:700>do</span> 
    wget -qO- 10.0.1.175:80
<span style=color:#a2f;font-weight:700>done</span>
</code></pre></div>
<p>输出应该类似这样：</p>
<pre><code>hostnames-632524106-bbpiw
hostnames-632524106-ly40y
hostnames-632524106-tlaok
</code></pre>
<p>如果 Service 状态是正常的，你应该得到正确的响应。如果没有，有很多可能出错的地方，请继续阅读。</p>
<h2 id=service-的配置是否正确>Service 的配置是否正确？</h2>
<p>这听起来可能很愚蠢，但你应该两次甚至三次检查你的 Service 配置是否正确，并且与你的 Pod 匹配。
查看你的 Service 配置并验证它：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get service hostnames -o json
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
    <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;Service&#34;</span>,
    <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;v1&#34;</span>,
    <span style=color:green;font-weight:700>&#34;metadata&#34;</span>: {
        <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;hostnames&#34;</span>,
        <span style=color:green;font-weight:700>&#34;namespace&#34;</span>: <span style=color:#b44>&#34;default&#34;</span>,
        <span style=color:green;font-weight:700>&#34;uid&#34;</span>: <span style=color:#b44>&#34;428c8b6c-24bc-11e5-936d-42010af0a9bc&#34;</span>,
        <span style=color:green;font-weight:700>&#34;resourceVersion&#34;</span>: <span style=color:#b44>&#34;347189&#34;</span>,
        <span style=color:green;font-weight:700>&#34;creationTimestamp&#34;</span>: <span style=color:#b44>&#34;2015-07-07T15:24:29Z&#34;</span>,
        <span style=color:green;font-weight:700>&#34;labels&#34;</span>: {
            <span style=color:green;font-weight:700>&#34;app&#34;</span>: <span style=color:#b44>&#34;hostnames&#34;</span>
        }
    },
    <span style=color:green;font-weight:700>&#34;spec&#34;</span>: {
        <span style=color:green;font-weight:700>&#34;ports&#34;</span>: [
            {
                <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;default&#34;</span>,
                <span style=color:green;font-weight:700>&#34;protocol&#34;</span>: <span style=color:#b44>&#34;TCP&#34;</span>,
                <span style=color:green;font-weight:700>&#34;port&#34;</span>: <span style=color:#666>80</span>,
                <span style=color:green;font-weight:700>&#34;targetPort&#34;</span>: <span style=color:#666>9376</span>,
                <span style=color:green;font-weight:700>&#34;nodePort&#34;</span>: <span style=color:#666>0</span>
            }
        ],
        <span style=color:green;font-weight:700>&#34;selector&#34;</span>: {
            <span style=color:green;font-weight:700>&#34;app&#34;</span>: <span style=color:#b44>&#34;hostnames&#34;</span>
        },
        <span style=color:green;font-weight:700>&#34;clusterIP&#34;</span>: <span style=color:#b44>&#34;10.0.1.175&#34;</span>,
        <span style=color:green;font-weight:700>&#34;type&#34;</span>: <span style=color:#b44>&#34;ClusterIP&#34;</span>,
        <span style=color:green;font-weight:700>&#34;sessionAffinity&#34;</span>: <span style=color:#b44>&#34;None&#34;</span>
    },
    <span style=color:green;font-weight:700>&#34;status&#34;</span>: {
        <span style=color:green;font-weight:700>&#34;loadBalancer&#34;</span>: {}
    }
}
</code></pre></div>
<ul>
<li>你想要访问的 Service 端口是否在 <code>spec.ports[]</code> 中列出？</li>
<li><code>targetPort</code> 对你的 Pod 来说正确吗（许多 Pod 使用与 Service 不同的端口）？</li>
<li>如果你想使用数值型端口，那么它的类型是一个数值（9376）还是字符串 “9376”？</li>
<li>如果你想使用名称型端口，那么你的 Pod 是否暴露了一个同名端口？</li>
<li>端口的 <code>protocol</code> 和 Pod 的是否对应？</li>
</ul>
<h2 id=service-有-endpoints-吗>Service 有 Endpoints 吗？</h2>
<p>如果你已经走到了这一步，你已经确认你的 Service 被正确定义，并能通过 DNS 解析。
现在，让我们检查一下，你运行的 Pod 确实是被 Service 选中的。</p>
<p>早些时候，我们已经看到 Pod 是运行状态。我们可以再检查一下：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>hostnames
</code></pre></div><pre><code class=language-none data-lang=none>NAME                        READY     STATUS    RESTARTS   AGE
hostnames-632524106-bbpiw   1/1       Running   0          1h
hostnames-632524106-ly40y   1/1       Running   0          1h
hostnames-632524106-tlaok   1/1       Running   0          1h
</code></pre>
<p><code>-l app=hostnames</code> 参数是在 Service 上配置的标签选择器。</p>
<p>"AGE" 列表明这些 Pod 已经启动一个小时了，这意味着它们运行良好，而未崩溃。</p>
<p>"RESTARTS" 列表明 Pod 没有经常崩溃或重启。经常性崩溃可能导致间歇性连接问题。
如果重启次数过大，通过<a href=/zh/docs/tasks/debug-application-cluster/debug-application/#debugging-pods>调试 pod</a>
了解相关技术。</p>
<p>在 Kubernetes 系统中有一个控制回路，它评估每个 Service 的选择算符，并将结果保存到 Endpoints 对象中。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get endpoints hostnames
</code></pre></div><pre><code>NAME        ENDPOINTS
hostnames   10.244.0.5:9376,10.244.0.6:9376,10.244.0.7:9376
</code></pre>
<p>这证实 Endpoints 控制器已经为你的 Service 找到了正确的 Pods。
如果 <code>ENDPOINTS</code> 列的值为 <code>&lt;none></code>，则应检查 Service 的 <code>spec.selector</code> 字段，
以及你实际想选择的 Pod 的 <code>metadata.labels</code> 的值。
常见的错误是输入错误或其他错误，例如 Service 想选择 <code>app=hostnames</code>，但是
Deployment 指定的是 <code>run=hostnames</code>。在 1.18之前的版本中 <code>kubectl run</code>
也可以被用来创建 Deployment。</p>
<h2 id=pod-正常工作吗>Pod 正常工作吗？</h2>
<p>至此，你知道你的 Service 已存在，并且已匹配到你的Pod。在本实验的开始，你已经检查了 Pod 本身。
让我们再次检查 Pod 是否确实在工作 - 你可以绕过 Service 机制并直接转到 Pod，如上面的 Endpoint 所示。</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 这些命令使用的是 Pod 端口（9376），而不是 Service 端口（80）。
</div>
<p>在 Pod 中运行：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#a2f;font-weight:700>for</span> ep in 10.244.0.5:9376 10.244.0.6:9376 10.244.0.7:9376; <span style=color:#a2f;font-weight:700>do</span>
    wget -qO- <span style=color:#b8860b>$ep</span>
<span style=color:#a2f;font-weight:700>done</span>
</code></pre></div>
<p>输出应该类似这样：</p>
<pre><code>hostnames-632524106-bbpiw
hostnames-632524106-ly40y
hostnames-632524106-tlaok
</code></pre>
<p>你希望 Endpoint 列表中的每个 Pod 都返回自己的主机名。
如果情况并非如此（或你自己的 Pod 的正确行为是什么），你应调查发生了什么事情。</p>
<h2 id=kube-proxy-正常工作吗>kube-proxy 正常工作吗？</h2>
<p>如果你到达这里，则说明你的 Service 正在运行，拥有 Endpoints，Pod 真正在提供服务。
此时，整个 Service 代理机制是可疑的。让我们一步一步地确认它没问题。</p>
<p>Service 的默认实现（在大多数集群上应用的）是 kube-proxy。
这是一个在每个节点上运行的程序，负责配置用于提供 Service 抽象的机制之一。
如果你的集群不使用 kube-proxy，则以下各节将不适用，你将必须检查你正在使用的 Service 的实现方式。</p>
<h3 id=kube-proxy-正常运行吗>kube-proxy 正常运行吗？</h3>
<p>确认 <code>kube-proxy</code> 正在节点上运行。 在节点上直接运行，你将会得到类似以下的输出：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>ps auxw | grep kube-proxy
</code></pre></div><pre><code class=language-none data-lang=none>root  4194  0.4  0.1 101864 17696 ?    Sl Jul04  25:43 /usr/local/bin/kube-proxy --master=https://kubernetes-master --kubeconfig=/var/lib/kube-proxy/kubeconfig --v=2
</code></pre>
<p>下一步，确认它并没有出现明显的失败，比如连接主节点失败。要做到这一点，你必须查看日志。
访问日志的方式取决于你节点的操作系统。
在某些操作系统上日志是一个文件，如 /var/log/messages kube-proxy.log，
而其他操作系统使用 <code>journalctl</code> 访问日志。你应该看到输出类似于：</p>
<pre><code class=language-none data-lang=none>I1027 22:14:53.995134    5063 server.go:200] Running in resource-only container &quot;/kube-proxy&quot;
I1027 22:14:53.998163    5063 server.go:247] Using iptables Proxier.
I1027 22:14:53.999055    5063 server.go:255] Tearing down userspace rules. Errors here are acceptable.
I1027 22:14:54.038140    5063 proxier.go:352] Setting endpoints for &quot;kube-system/kube-dns:dns-tcp&quot; to [10.244.1.3:53]
I1027 22:14:54.038164    5063 proxier.go:352] Setting endpoints for &quot;kube-system/kube-dns:dns&quot; to [10.244.1.3:53]
I1027 22:14:54.038209    5063 proxier.go:352] Setting endpoints for &quot;default/kubernetes:https&quot; to [10.240.0.2:443]
I1027 22:14:54.038238    5063 proxier.go:429] Not syncing iptables until Services and Endpoints have been received from master
I1027 22:14:54.040048    5063 proxier.go:294] Adding new service &quot;default/kubernetes:https&quot; at 10.0.0.1:443/TCP
I1027 22:14:54.040154    5063 proxier.go:294] Adding new service &quot;kube-system/kube-dns:dns&quot; at 10.0.0.10:53/UDP
I1027 22:14:54.040223    5063 proxier.go:294] Adding new service &quot;kube-system/kube-dns:dns-tcp&quot; at 10.0.0.10:53/TCP
</code></pre>
<p>如果你看到有关无法连接主节点的错误消息，则应再次检查节点配置和安装步骤。</p>
<p><code>kube-proxy</code> 无法正确运行的可能原因之一是找不到所需的 <code>conntrack</code> 二进制文件。
在一些 Linux 系统上，这也是可能发生的，这取决于你如何安装集群，
例如，你是手动开始一步步安装 Kubernetes。如果是这样的话，你需要手动安装
<code>conntrack</code> 包（例如，在 Ubuntu 上使用 <code>sudo apt install conntrack</code>），然后重试。</p>
<p>Kube-proxy 可以以若干模式之一运行。在上述日志中，<code>Using iptables Proxier</code>
行表示 kube-proxy 在 "iptables" 模式下运行。
最常见的另一种模式是 "ipvs"。先前的 "userspace" 模式已经被这些所代替。</p>
<h4 id=iptables-模式>Iptables 模式</h4>
<p>在 "iptables" 模式中, 你应该可以在节点上看到如下输出:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>iptables-save | grep hostnames
</code></pre></div><pre><code class=language-none data-lang=none>-A KUBE-SEP-57KPRZ3JQVENLNBR -s 10.244.3.6/32 -m comment --comment &quot;default/hostnames:&quot; -j MARK --set-xmark 0x00004000/0x00004000
-A KUBE-SEP-57KPRZ3JQVENLNBR -p tcp -m comment --comment &quot;default/hostnames:&quot; -m tcp -j DNAT --to-destination 10.244.3.6:9376
-A KUBE-SEP-WNBA2IHDGP2BOBGZ -s 10.244.1.7/32 -m comment --comment &quot;default/hostnames:&quot; -j MARK --set-xmark 0x00004000/0x00004000
-A KUBE-SEP-WNBA2IHDGP2BOBGZ -p tcp -m comment --comment &quot;default/hostnames:&quot; -m tcp -j DNAT --to-destination 10.244.1.7:9376
-A KUBE-SEP-X3P2623AGDH6CDF3 -s 10.244.2.3/32 -m comment --comment &quot;default/hostnames:&quot; -j MARK --set-xmark 0x00004000/0x00004000
-A KUBE-SEP-X3P2623AGDH6CDF3 -p tcp -m comment --comment &quot;default/hostnames:&quot; -m tcp -j DNAT --to-destination 10.244.2.3:9376
-A KUBE-SERVICES -d 10.0.1.175/32 -p tcp -m comment --comment &quot;default/hostnames: cluster IP&quot; -m tcp --dport 80 -j KUBE-SVC-NWV5X2332I4OT4T3
-A KUBE-SVC-NWV5X2332I4OT4T3 -m comment --comment &quot;default/hostnames:&quot; -m statistic --mode random --probability 0.33332999982 -j KUBE-SEP-WNBA2IHDGP2BOBGZ
-A KUBE-SVC-NWV5X2332I4OT4T3 -m comment --comment &quot;default/hostnames:&quot; -m statistic --mode random --probability 0.50000000000 -j KUBE-SEP-X3P2623AGDH6CDF3
-A KUBE-SVC-NWV5X2332I4OT4T3 -m comment --comment &quot;default/hostnames:&quot; -j KUBE-SEP-57KPRZ3JQVENLNBR
</code></pre>
<p>对于每个 Service 的每个端口，应有 1 条 <code>KUBE-SERVICES</code> 规则、一个 <code>KUBE-SVC-&lt;hash></code> 链。
对于每个 Pod 末端，在那个 <code>KUBE-SVC-&lt;hash></code> 链中应该有一些规则与之对应，还应该
有一个 <code>KUBE-SEP-&lt;hash></code> 链与之对应，其中包含为数不多的几条规则。
实际的规则数量可能会根据你实际的配置（包括 NodePort 和 LoadBalancer 服务）有所不同。</p>
<h4 id=ipvs-模式>IPVS 模式</h4>
<p>在 "ipvs" 模式中, 你应该在节点下看到如下输出：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>ipvsadm -ln
</code></pre></div><pre><code class=language-none data-lang=none>Prot LocalAddress:Port Scheduler Flags
  -&gt; RemoteAddress:Port           Forward Weight ActiveConn InActConn
...
TCP  10.0.1.175:80 rr
  -&gt; 10.244.0.5:9376               Masq    1      0          0
  -&gt; 10.244.0.6:9376               Masq    1      0          0
  -&gt; 10.244.0.7:9376               Masq    1      0          0
...
</code></pre>
<p>对于每个 Service 的每个端口，还有 NodePort，External IP 和 LoadBalancer 类型服务
的 IP，kube-proxy 将创建一个虚拟服务器。
对于每个 Pod 末端，它将创建相应的真实服务器。
在此示例中，服务主机名（<code>10.0.1.175:80</code>）拥有 3 个末端（<code>10.244.0.5:9376</code>、
<code>10.244.0.6:9376</code> 和 <code>10.244.0.7:9376</code>）。</p>
<h4 id=userspace-模式>Userspace 模式</h4>
<p>在极少数情况下，你可能会用到 "userspace" 模式。在你的节点上运行：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>iptables-save | grep hostnames
</code></pre></div><pre><code class=language-none data-lang=none>-A KUBE-PORTALS-CONTAINER -d 10.0.1.175/32 -p tcp -m comment --comment &quot;default/hostnames:default&quot; -m tcp --dport 80 -j REDIRECT --to-ports 48577
-A KUBE-PORTALS-HOST -d 10.0.1.175/32 -p tcp -m comment --comment &quot;default/hostnames:default&quot; -m tcp --dport 80 -j DNAT --to-destination 10.240.115.247:48577
</code></pre>
<p>对于 Service （本例中只有一个）的每个端口，应当有 2 条规则：
一条 "KUBE-PORTALS-CONTAINER" 和一条 "KUBE-PORTALS-HOST" 规则。</p>
<p>几乎没有人应该再使用 "userspace" 模式，因此你在这里不会花更多的时间。</p>
<h3 id=kube-proxy-是否在运行>kube-proxy 是否在运行?</h3>
<p>假设你确实遇到上述情况之一，请重试从节点上通过 IP 访问你的 Service ：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>curl 10.0.1.175:80
</code></pre></div><pre><code class=language-none data-lang=none>hostnames-632524106-bbpiw
</code></pre>
<p>如果失败，并且你正在使用用户空间代理，则可以尝试直接访问代理。
如果你使用的是 iptables 代理，请跳过本节。</p>
<p>回顾上面的 <code>iptables-save</code> 输出，并提取 <code>kube-proxy</code> 为你的 Service 所使用的端口号。
在上面的例子中，端口号是 “48577”。现在试着连接它：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>curl localhost:48577
</code></pre></div><pre><code class=language-none data-lang=none>hostnames-632524106-tlaok
</code></pre>
<p>如果这步操作仍然失败，请查看 <code>kube-proxy</code> 日志中的特定行，如：</p>
<pre><code class=language-none data-lang=none>Setting endpoints for default/hostnames:default to [10.244.0.5:9376 10.244.0.6:9376 10.244.0.7:9376]
</code></pre>
<p>如果你没有看到这些，请尝试将 <code>-V</code> 标志设置为 4 并重新启动 <code>kube-proxy</code>，然后再查看日志。</p>
<h3 id=a-pod-fails-to-reach-itself-via-the-service-ip>边缘案例: Pod 无法通过 Service IP 连接到它本身 </h3>
<p>这听起来似乎不太可能，但是确实可能发生，并且应该可行。</p>
<p>如果网络没有为“发夹模式（Hairpin）”流量生成正确配置，
通常当 <code>kube-proxy</code> 以 <code>iptables</code> 模式运行，并且 Pod 与桥接网络连接时，就会发生这种情况。
<code>kubelet</code> 提供了 <code>hairpin-mode</code>
<a href=/zh/docs/reference/command-line-tools-reference/kubelet/>标志</a>。
如果 Service 的末端尝试访问自己的 Service VIP，则该端点可以把流量负载均衡回来到它们自身。
<code>hairpin-mode</code> 标志必须被设置为 <code>hairpin-veth</code> 或者 <code>promiscuous-bridge</code>。</p>
<p>诊断此类问题的常见步骤如下：</p>
<ul>
<li>
<p>确认 <code>hairpin-mode</code> 被设置为 <code>hairpin-veth</code> 或 <code>promiscuous-bridge</code>。
你应该可以看到下面这样。本例中 <code>hairpin-mode</code> 被设置为 <code>promiscuous-bridge</code>。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>ps auxw | grep kubelet
</code></pre></div><pre><code class=language-none data-lang=none>root      3392  1.1  0.8 186804 65208 ?        Sl   00:51  11:11 /usr/local/bin/kubelet --enable-debugging-handlers=true --config=/etc/kubernetes/manifests --allow-privileged=True --v=4 --cluster-dns=10.0.0.10 --cluster-domain=cluster.local --configure-cbr0=true --cgroup-root=/ --system-cgroups=/system --hairpin-mode=promiscuous-bridge --runtime-cgroups=/docker-daemon --kubelet-cgroups=/kubelet --babysit-daemons=true --max-pods=110 --serialize-image-pulls=false --outofdisk-transition-frequency=0
</code></pre></li>
</ul>
<ul>
<li>
<p>确认有效的 <code>hairpin-mode</code>。要做到这一点，你必须查看 kubelet 日志。
访问日志取决于节点的操作系统。在一些操作系统上，它是一个文件，如 /var/log/kubelet.log，
而其他操作系统则使用 <code>journalctl</code> 访问日志。请注意，由于兼容性，
有效的 <code>hairpin-mode</code> 可能不匹配 <code>--hairpin-mode</code> 标志。在 kubelet.log
中检查是否有带有关键字 <code>hairpin</code> 的日志行。应该有日志行指示有效的
<code>hairpin-mode</code>，就像下面这样。</p>
<pre><code class=language-none data-lang=none>I0629 00:51:43.648698    3252 kubelet.go:380] Hairpin mode set to &quot;promiscuous-bridge&quot;
</code></pre></li>
</ul>
<ul>
<li>
<p>如果有效的发夹模式是 <code>hairpin-veth</code>, 要保证 <code>Kubelet</code> 有操作节点上 <code>/sys</code> 的权限。
如果一切正常，你将会看到如下输出:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#a2f;font-weight:700>for</span> intf in /sys/devices/virtual/net/cbr0/brif/*; <span style=color:#a2f;font-weight:700>do</span> cat <span style=color:#b8860b>$intf</span>/hairpin_mode; <span style=color:#a2f;font-weight:700>done</span>
</code></pre></div><pre><code class=language-none data-lang=none>1
1
1
1
</code></pre></li>
</ul>
<ul>
<li>
<p>如果有效的发卡模式是 <code>promiscuous-bridge</code>, 要保证 <code>Kubelet</code> 有操作节点上
Linux 网桥的权限。如果 <code>cbr0</code> 桥正在被使用且被正确设置，你将会看到如下输出:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>ifconfig cbr0 |grep PROMISC
</code></pre></div><pre><code class=language-none data-lang=none>UP BROADCAST RUNNING PROMISC MULTICAST  MTU:1460  Metric:1
</code></pre></li>
</ul>
<ul>
<li>如果以上步骤都不能解决问题，请寻求帮助。</li>
</ul>
<h2 id=寻求帮助>寻求帮助</h2>
<p>如果你走到这一步，那么就真的是奇怪的事情发生了。你的 Service 正在运行，有 Endpoints 存在，
你的 Pods 也确实在提供服务。你的 DNS 正常，<code>iptables</code> 规则已经安装，<code>kube-proxy</code> 看起来也正常。
然而 Service 还是没有正常工作。这种情况下，请告诉我们，以便我们可以帮助调查！</p>
<p>通过
<a href=/zh/docs/tasks/debug-application-cluster/troubleshooting/#slack>Slack</a> 或者
<a href=https://discuss.kubernetes.io>Forum</a> 或者
<a href=https://github.com/kubernetes/kubernetes>GitHub</a>
联系我们。</p>
<h2 id=what-s-next>What's next</h2>
<p>访问<a href=/zh/docs/tasks/debug-application-cluster/troubleshooting/>故障排查文档</a> 获取更多信息。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-a070b1250ee142402d492b505a56ca83>11 - 调试StatefulSet</h1>
<p>此任务展示如何调试 StatefulSet。</p>
<h2 id=before-you-begin>Before you begin</h2>
<ul>
<li>你需要有一个 Kubernetes 集群，已配置好的 kubectl 命令行工具与你的集群进行通信。</li>
<li>你应该有一个运行中的 StatefulSet，以便用于调试。</li>
</ul>
<h2 id=debuggin-a-statefulset>调试 StatefulSet </h2>
<p>StatefulSet 在创建 Pod 时为其设置了 <code>app=myapp</code> 标签，列出仅属于某 StatefulSet
的所有 Pod 时，可以使用以下命令：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>myapp
</code></pre></div>
<p>如果你发现列出的任何 Pod 长时间处于 <code>Unknown</code> 或 <code>Terminating</code> 状态，请参阅
<a href=/zh/docs/tasks/run-application/delete-stateful-set/>删除 StatefulSet Pods</a>
了解如何处理它们的说明。
你可以参考<a href=/zh/docs/tasks/debug-application-cluster/debug-pod-replication-controller/>调试 Pods</a>
来调试 StatefulSet 中的各个 Pod。</p>
<h2 id=what-s-next>What's next</h2>
<ul>
<li>进一步了解如何<a href=/zh/docs/tasks/debug-application-cluster/debug-init-containers/>调试 Init 容器</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-c0ec963f381296ca26b839cdf0a6f242>12 - 调试运行中的 Pod</h1>
<p>本页解释如何在节点上调试运行中（或崩溃）的 Pod。</p>
<h2 id=before-you-begin>Before you begin</h2>
<ul>
<li>
<p>你的 <a class=glossary-tooltip title="Pod 表示您的集群上一组正在运行的容器。" data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a> 应该已经被调度并正在运行中，
如果你的 Pod 还没有运行，请参阅
<a href=/zh/docs/tasks/debug-application-cluster/debug-application/>应用问题排查</a>。</p>
</li>
<li>
<p>对于一些高级调试步骤，你应该知道 Pod 具体运行在哪个节点上，在该节点上有权限去运行一些命令。
你不需要任何访问权限就可以使用 <code>kubectl</code> 去运行一些标准调试步骤。</p>
</li>
</ul>
<h2 id=examine-pod-logs>检查 Pod 的日志</h2>
<p>首先，查看受到影响的容器的日志：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl logs <span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>POD_NAME</span><span style=color:#b68;font-weight:700>}</span> <span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>CONTAINER_NAME</span><span style=color:#b68;font-weight:700>}</span>
</code></pre></div><p>如果你的容器之前崩溃过，你可以通过下面命令访问之前容器的崩溃日志：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl logs --previous <span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>POD_NAME</span><span style=color:#b68;font-weight:700>}</span> <span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>CONTAINER_NAME</span><span style=color:#b68;font-weight:700>}</span>
</code></pre></div>
<h2 id=container-exec>使用容器 exec 进行调试</h2>
<p>如果 <a class=glossary-tooltip title=镜像是保存的容器实例，它打包了应用运行所需的一组软件。 data-toggle=tooltip data-placement=top href="/zh/docs/reference/glossary/?all=true#term-image" target=_blank aria-label=容器镜像>容器镜像</a> 包含调试程序，
比如从 Linux 和 Windows 操作系统基础镜像构建的镜像，你可以使用 <code>kubectl exec</code> 命令
在特定的容器中运行一些命令：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#a2f>exec</span> <span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>POD_NAME</span><span style=color:#b68;font-weight:700>}</span> -c <span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>CONTAINER_NAME</span><span style=color:#b68;font-weight:700>}</span> -- <span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>CMD</span><span style=color:#b68;font-weight:700>}</span> <span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>ARG1</span><span style=color:#b68;font-weight:700>}</span> <span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>ARG2</span><span style=color:#b68;font-weight:700>}</span> ... <span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>ARGN</span><span style=color:#b68;font-weight:700>}</span>
</code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> <code>-c ${CONTAINER_NAME}</code> 是可选择的。如果Pod中仅包含一个容器，就可以忽略它。
</div>
<p>例如，要查看正在运行的 Cassandra pod中的日志，可以运行：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#a2f>exec</span> cassandra -- cat /var/log/cassandra/system.log
</code></pre></div><p>你可以在 <code>kubectl exec</code> 命令后面加上 <code>-i</code> 和 <code>-t</code> 来运行一个连接到你的终端的 Shell，比如：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#a2f>exec</span> -it cassandra -- sh
</code></pre></div><p>若要了解更多内容，可查看<a href=/zh/docs/tasks/debug-application-cluster/get-shell-running-container/>获取正在运行容器的 Shell</a>。</p>
<h2 id=ephemeral-container>使用临时调试容器来进行调试</h2>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.23 [beta]</code>
</div>
<p>当由于容器崩溃或容器镜像不包含调试程序（例如<a href=https://github.com/GoogleContainerTools/distroless>无发行版镜像</a>等）
而导致 <code>kubectl exec</code> 无法运行时，<a class=glossary-tooltip title="您可以在 Pod 中临时运行的一种容器类型" data-toggle=tooltip data-placement=top href=/zh/docs/concepts/workloads/pods/ephemeral-containers/ target=_blank aria-label=临时容器>临时容器</a>对于排除交互式故障很有用。</p>
<h2 id=ephemeral-container-example>使用临时容器来调试的例子</h2>
<p>你可以使用 <code>kubectl debug</code> 命令来给正在运行中的 Pod 增加一个临时容器。
首先，像示例一样创建一个 pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl run ephemeral-demo --image<span style=color:#666>=</span>k8s.gcr.io/pause:3.1 --restart<span style=color:#666>=</span>Never
</code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 本节示例中使用 <code>pause</code> 容器镜像，因为它不包含调试程序，但是这个方法适用于所有容器镜像。
</div>
<p>如果你尝试使用 <code>kubectl exec</code> 来创建一个 shell，你将会看到一个错误，因为这个容器镜像中没有 shell。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#a2f>exec</span> -it ephemeral-demo -- sh
</code></pre></div><pre><code>OCI runtime exec failed: exec failed: container_linux.go:346: starting container process caused &quot;exec: \&quot;sh\&quot;: executable file not found in $PATH&quot;: unknown
</code></pre><p>你可以改为使用 <code>kubectl debug</code> 添加调试容器。
如果你指定 <code>-i</code> 或者 <code>--interactive</code> 参数，<code>kubectl</code> 将自动挂接到临时容器的控制台。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl debug -it ephemeral-demo --image<span style=color:#666>=</span>busybox:1.28 --target<span style=color:#666>=</span>ephemeral-demo
</code></pre></div><pre><code>Defaulting debug container name to debugger-8xzrl.
If you don't see a command prompt, try pressing enter.
/ #
</code></pre>
<p>此命令添加一个新的 busybox 容器并将其挂接到该容器。<code>--target</code> 参数指定另一个容器的进程命名空间。
这是必需的，因为 <code>kubectl run</code> 不能在它创建的pod中启用
<a href=/zh/docs/tasks/configure-pod-container/share-process-namespace/>共享进程命名空间</a>。</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> <a class=glossary-tooltip title=容器运行时是负责运行容器的软件。 data-toggle=tooltip data-placement=top href=/zh/docs/setup/production-environment/container-runtimes target=_blank aria-label=容器运行时>容器运行时</a>必须支持<code>--target</code>参数。
如果不支持，则临时容器可能不会启动，或者可能使用隔离的进程命名空间启动，
以便 <code>ps</code> 不显示其他容器内的进程。
</div>
<p>你可以使用 <code>kubectl describe</code> 查看新创建的临时容器的状态：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe pod ephemeral-demo
</code></pre></div><pre><code>...
Ephemeral Containers:
  debugger-8xzrl:
    Container ID:   docker://b888f9adfd15bd5739fefaa39e1df4dd3c617b9902082b1cfdc29c4028ffb2eb
    Image:          busybox
    Image ID:       docker-pullable://busybox@sha256:1828edd60c5efd34b2bf5dd3282ec0cc04d47b2ff9caa0b6d4f07a21d1c08084
    Port:           &lt;none&gt;
    Host Port:      &lt;none&gt;
    State:          Running
      Started:      Wed, 12 Feb 2020 14:25:42 +0100
    Ready:          False
    Restart Count:  0
    Environment:    &lt;none&gt;
    Mounts:         &lt;none&gt;
...
</code></pre>
<p>使用 <code>kubectl delete</code> 来移除已经结束掉的 Pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete pod ephemeral-demo
</code></pre></div>
<h2 id=通过-pod-副本调试>通过 Pod 副本调试</h2>
<p>有些时候 Pod 的配置参数使得在某些情况下很难执行故障排查。
例如，在容器镜像中不包含 shell 或者你的应用程序在启动时崩溃的情况下，
就不能通过运行 <code>kubectl exec</code> 来排查容器故障。
在这些情况下，你可以使用 <code>kubectl debug</code> 来创建 Pod 的副本，通过更改配置帮助调试。</p>
<h3 id=在添加新的容器时创建-pod-副本>在添加新的容器时创建 Pod 副本</h3>
<p>当应用程序正在运行但其表现不符合预期时，你会希望在 Pod 中添加额外的调试工具，
这时添加新容器是很有用的。</p>
<p>例如，应用的容器镜像是建立在 <code>busybox</code> 的基础上，
但是你需要 <code>busybox</code> 中并不包含的调试工具。
你可以使用 <code>kubectl run</code> 模拟这个场景:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl run myapp --image<span style=color:#666>=</span>busybox:1.28 --restart<span style=color:#666>=</span>Never -- sleep 1d
</code></pre></div>
<p>通过运行以下命令，建立 <code>myapp</code> 的一个名为 <code>myapp-debug</code> 的副本，
新增了一个用于调试的 Ubuntu 容器，</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl debug myapp -it --image<span style=color:#666>=</span>ubuntu --share-processes --copy-to<span style=color:#666>=</span>myapp-debug
</code></pre></div><pre><code>Defaulting debug container name to debugger-w7xmf.
If you don't see a command prompt, try pressing enter.
root@myapp-debug:/#
</code></pre>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> <ul>
<li>如果你没有使用 <code>--container</code> 指定新的容器名，<code>kubectl debug</code> 会自动生成的。</li>
<li>默认情况下，<code>-i</code> 标志使 <code>kubectl debug</code> 附加到新容器上。
你可以通过指定 <code>--attach=false</code> 来防止这种情况。
如果你的会话断开连接，你可以使用 <code>kubectl attach</code> 重新连接。</li>
<li><code>--share-processes</code> 允许在此 Pod 中的其他容器中查看该容器的进程。
参阅<a href=/zh/docs/tasks/configure-pod-container/share-process-namespace/>在 Pod 中的容器之间共享进程命名空间</a>
获取更多信息。</li>
</ul>
</div>
<p>不要忘了清理调试 Pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete pod myapp myapp-debug
</code></pre></div>
<h3 id=在改变-pod-命令时创建-pod-副本>在改变 Pod 命令时创建 Pod 副本</h3>
<p>有时更改容器的命令很有用，例如添加调试标志或因为应用崩溃。</p>
<p>为了模拟应用崩溃的场景，使用 <code>kubectl run</code> 命令创建一个立即退出的容器：</p>
<pre><code>kubectl run --image=busybox:1.28 myapp -- false
</code></pre>
<p>使用 <code>kubectl describe pod myapp</code> 命令，你可以看到容器崩溃了：</p>
<pre><code>Containers:
  myapp:
    Image:         busybox
    ...
    Args:
      false
    State:          Waiting
      Reason:       CrashLoopBackOff
    Last State:     Terminated
      Reason:       Error
      Exit Code:    1
</code></pre>
<p>你可以使用 <code>kubectl debug</code> 命令创建该 Pod 的一个副本，
在该副本中命令改变为交互式 shell：</p>
<pre><code>kubectl debug myapp -it --copy-to=myapp-debug --container=myapp -- sh
</code></pre><pre><code>If you don't see a command prompt, try pressing enter.
/ #
</code></pre>
<p>现在你有了一个可以执行类似检查文件系统路径或者手动运行容器命令的交互式 shell。</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> <ul>
<li>要更改指定容器的命令，你必须用 <code>--container</code> 命令指定容器的名字，
否则 <code>kubectl debug</code> 将建立一个新的容器运行你指定的命令。</li>
<li>默认情况下，标志 <code>-i</code> 使 <code>kubectl debug</code> 附加到容器。
你可通过指定 <code>--attach=false</code> 来防止这种情况。
如果你的断开连接，可以使用 <code>kubectl attach</code> 重新连接。</li>
</ul>
</div>
<p>不要忘了清理调试 Pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete pod myapp myapp-debug
</code></pre></div>
<h3 id=在更改容器镜像时创建-pod-副本>在更改容器镜像时创建 Pod 副本</h3>
<p>在某些情况下，你可能想从正常生产容器镜像中
把行为异常的 Pod 改变为包含调试版本或者附加应用的镜像。</p>
<p>下面的例子，用 <code>kubectl run</code>创建一个 Pod：</p>
<pre><code>kubectl run myapp --image=busybox:1.28 --restart=Never -- sleep 1d
</code></pre>
<p>现在可以使用 <code>kubectl debug</code> 创建一个副本
并改变容器镜像为 <code>ubuntu</code>：</p>
<pre><code>kubectl debug myapp --copy-to=myapp-debug --set-image=*=ubuntu
</code></pre>
<p><code>--set-image</code> 与 <code>container_name=image</code> 使用相同的 <code>kubectl set image</code> 语法。
<code>*=ubuntu</code> 表示把所有容器的镜像改为 <code>ubuntu</code>。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete pod myapp myapp-debug
</code></pre></div>
<h2 id=node-shell-session>在节点上通过 shell 来进行调试</h2>
<p>如果这些方法都不起作用，你可以找到运行 Pod 的节点，然后在节点上部署一个运行在宿主名字空间的特权 Pod。</p>
<p>你可以通过<code>kubectl debug</code> 在节点上创建一个交互式 shell：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl debug node/mynode -it --image<span style=color:#666>=</span>ubuntu
</code></pre></div><pre><code>Creating debugging pod node-debugger-mynode-pdx84 with container debugger on node mynode.
If you don't see a command prompt, try pressing enter.
root@ek8s:/#
</code></pre>
<p>当在节点上创建调试会话，注意以下要点：</p>
<ul>
<li><code>kubectl debug</code> 基于节点的名字自动生成新的 Pod 的名字。</li>
<li>新的调试容器运行在宿主命名空间里（IPC, 网络 还有PID命名空间）。</li>
<li>节点的根文件系统会被挂载在 <code>/host</code>。</li>
</ul>
<p>当你完成节点调试时，不要忘记清理调试 Pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete pod node-debugger-mynode-pdx84
</code></pre></div>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-9e6e1b706f11386fe2c4b4ffda1409e4>13 - 资源监控工具</h1>
<p>要扩展应用程序并提供可靠的服务，你需要了解应用程序在部署时的行为。
你可以通过检测容器检查 Kubernetes 集群中的应用程序性能，
<a href=/zh/docs/concepts/workloads/pods>Pods</a>,
<a href=/zh/docs/concepts/services-networking/service/>服务</a>
和整个集群的特征。
Kubernetes 在每个级别上提供有关应用程序资源使用情况的详细信息。
此信息使你可以评估应用程序的性能，以及在何处可以消除瓶颈以提高整体性能。</p>
<p>在 Kubernetes 中，应用程序监控不依赖单个监控解决方案。
在新集群上，你可以使用<a href=#resource-metrics-pipeline>资源度量</a>或
<a href=#full-metrics-pipeline>完整度量</a>管道来收集监视统计信息。</p>
<h2 id=resource-metrics-pipeline>资源度量管道 </h2>
<p>资源指标管道提供了一组与集群组件，例如
<a href=/zh/docs/tasks/run-application/horizontal-pod-autoscale/>Horizontal Pod Autoscaler</a>
控制器以及 <code>kubectl top</code> 实用程序相关的有限度量。
这些指标是由轻量级的、短期、内存存储的
<a href=https://github.com/kubernetes-sigs/metrics-server>metrics-server</a> 收集的，
通过 <code>metrics.k8s.io</code> 公开。</p>
<p>度量服务器发现集群中的所有节点，并且查询每个节点的
<a href=/zh/docs/reference/command-line-tools-reference/kubelet/>kubelet</a>
以获取 CPU 和内存使用情况。
Kubelet 充当 Kubernetes 主节点与节点之间的桥梁，管理机器上运行的 Pod 和容器。
kubelet 将每个 Pod 转换为其组成的容器，并在容器运行时通过容器运行时接口
获取各个容器使用情况统计信息。
kubelet 从集成的 cAdvisor 获取此信息，以进行旧式 Docker 集成。
然后，它通过 metrics-server Resource Metrics API 公开聚合的 pod 资源使用情况统计信息。
该 API 在 kubelet 的经过身份验证和只读的端口上的 <code>/metrics/resource/v1beta1</code> 中提供。</p>
<h2 id=full-metrics-pipeline>完整度量管道 </h2>
<p>一个完整度量管道可以让你访问更丰富的度量。
Kubernetes 还可以根据集群的当前状态，使用 Pod 水平自动扩缩器等机制，
通过自动调用扩展或调整集群来响应这些度量。
监控管道从 kubelet 获取度量值，然后通过适配器将它们公开给 Kubernetes，
方法是实现 <code>custom.metrics.k8s.io</code> 或 <code>external.metrics.k8s.io</code> API。</p>
<p><a href=https://prometheus.io>Prometheus</a> 是一个 CNCF 项目，可以原生监控 Kubernetes、
节点和 Prometheus 本身。
完整度量管道项目不属于 CNCF 的一部分，不在 Kubernetes 文档的范围之内。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-47290c80fb8b00accec6729f3da49734>14 - 集群故障排查</h1>
<p>本篇文档是介绍集群故障排查的；我们假设对于你碰到的问题，你已经排除了是由应用程序造成的。
对于应用的调试，请参阅
<a href=/zh/docs/tasks/debug-application-cluster/debug-application/>应用故障排查指南</a>。
你也可以访问<a href=/zh/docs/tasks/debug-application-cluster/troubleshooting/>故障排查</a>
来获取更多的信息。</p>
<h2 id=列举集群节点>列举集群节点</h2>
<p>调试的第一步是查看所有的节点是否都已正确注册。</p>
<p>运行</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get nodes
</code></pre></div>
<p>验证你所希望看见的所有节点都能够显示出来，并且都处于 <code>Ready</code> 状态。</p>
<p>为了了解你的集群的总体健康状况详情，你可以运行：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl cluster-info dump
</code></pre></div>
<h2 id=查看日志>查看日志</h2>
<p>到这里，挖掘出集群更深层的信息就需要登录到相关的机器上。下面是相关日志文件所在的位置。
（注意，对于基于 systemd 的系统，你可能需要使用<code>journalctl</code>）。</p>
<h3 id=主控节点>主控节点</h3>
<ul>
<li><code>/var/log/kube-apiserver.log</code> - API 服务器, 提供API服务</li>
<li><code>/var/log/kube-scheduler.log</code> - 调度器, 负责产生调度决策</li>
<li><code>/var/log/kube-controller-manager.log</code> - 管理副本控制器的控制器</li>
</ul>
<h3 id=工作节点>工作节点</h3>
<ul>
<li><code>/var/log/kubelet.log</code> - <code>kubelet</code>，负责在节点运行容器</li>
<li><code>/var/log/kube-proxy.log</code> - <code>kube-proxy</code>, 负责服务的负载均衡</li>
</ul>
<h2 id=集群故障模式的一般性概述>集群故障模式的一般性概述</h2>
<p>下面是一个不完整的列表，列举了一些可能的出错场景，以及通过调整集群配置来解决相关问题的方法。</p>
<h3 id=根本原因>根本原因</h3>
<ul>
<li>VM(s) 关机</li>
<li>集群之间，或者集群和用户之间网络分裂</li>
<li>Kubernetes 软件本身崩溃</li>
<li>数据丢失或者持久化存储不可用（如：GCE PD 或 AWS EBS 卷）</li>
<li>操作错误，如：Kubernetes 或者应用程序配置错误</li>
</ul>
<h3 id=具体情况>具体情况</h3>
<ul>
<li>API 服务器所在的 VM 关机或者 API 服务器崩溃
<ul>
<li>结果
<ul>
<li>不能停止、更新或者启动新的 Pod、服务或副本控制器</li>
<li>现有的 Pod 和服务在不依赖 Kubernetes API 的情况下应该能继续正常工作</li>
</ul>
</li>
</ul>
</li>
<li>API 服务器的后端存储丢失
<ul>
<li>结果
<ul>
<li>API 服务器应该不能启动</li>
<li>kubelet 将不能访问 API 服务器，但是能够继续运行之前的 Pod 和提供相同的服务代理</li>
<li>在 API 服务器重启之前，需要手动恢复或者重建 API 服务器的状态</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>Kubernetes 服务组件（节点控制器、副本控制器管理器、调度器等）所在的 VM 关机或者崩溃
<ul>
<li>当前，这些控制器是和 API 服务器在一起运行的，它们不可用的现象是与 API 服务器类似的</li>
<li>将来，这些控制器也会复制为多份，并且可能不在运行于同一节点上</li>
<li>它们没有自己的持久状态</li>
</ul>
</li>
<li>单个节点（VM 或者物理机）关机
<ul>
<li>结果
<ul>
<li>此节点上的所有 Pod 都停止运行</li>
</ul>
</li>
</ul>
</li>
<li>网络分裂
<ul>
<li>结果
<ul>
<li>分区 A 认为分区 B 中所有的节点都已宕机；分区 B 认为 API 服务器宕机
（假定主控节点所在的 VM 位于分区 A 内)。</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>kubelet 软件故障
<ul>
<li>结果
<ul>
<li>崩溃的 kubelet 就不能在其所在的节点上启动新的 Pod</li>
<li>kubelet 可能删掉 Pod 或者不删</li>
<li>节点被标识为非健康态</li>
<li>副本控制器会在其它的节点上启动新的 Pod</li>
</ul>
</li>
</ul>
</li>
<li>集群操作错误
<ul>
<li>结果
<ul>
<li>丢失 Pod 或服务等等</li>
<li>丢失 API 服务器的后端存储</li>
<li>用户无法读取API</li>
<li>等等</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id=缓解措施>缓解措施</h3>
<ul>
<li>
<p>措施：对于 IaaS 上的 VMs，使用 IaaS 的自动 VM 重启功能</p>
<ul>
<li>缓解：API 服务器 VM 关机或 API 服务器崩溃</li>
<li>缓解：Kubernetes 服务组件所在的 VM 关机或崩溃</li>
</ul>
</li>
<li>
<p>措施: 对于运行 API 服务器和 etcd 的 VM，使用 IaaS 提供的可靠的存储（例如 GCE PD 或者 AWS EBS 卷）</p>
<ul>
<li>缓解：API 服务器后端存储的丢失</li>
</ul>
</li>
<li>
<p>措施：使用<a href=/zh/docs/setup/production-environment/tools/kubeadm/high-availability/>高可用性</a>的配置</p>
<ul>
<li>缓解：主控节点 VM 关机或者主控节点组件（调度器、API 服务器、控制器管理器）崩馈
<ul>
<li>将容许一个或多个节点或组件同时出现故障</li>
</ul>
</li>
<li>缓解：API 服务器后端存储（例如 etcd 的数据目录）丢失
<ul>
<li>假定你使用了高可用的 etcd 配置</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>
<p>措施：定期对 API 服务器的 PDs/EBS 卷执行快照操作</p>
<ul>
<li>缓解：API 服务器后端存储丢失</li>
<li>缓解：一些操作错误的场景</li>
<li>缓解：一些 Kubernetes 软件本身故障的场景</li>
</ul>
</li>
<li>
<p>措施：在 Pod 的前面使用副本控制器或服务</p>
<ul>
<li>缓解：节点关机</li>
<li>缓解：kubelet 软件故障</li>
</ul>
</li>
<li>
<p>措施：应用（容器）设计成容许异常重启</p>
<ul>
<li>缓解：节点关机</li>
<li>缓解：kubelet 软件故障</li>
</ul>
</li>
</ul>
</div>
</main>
</div>
</div>
<footer class=d-print-none>
<div class=footer__links>
<nav>
<a class=text-white href=/zh/docs/home/>主页</a>
<a class=text-white href=/zh/blog/>博客</a>
<a class=text-white href=/zh/training/>培训</a>
<a class=text-white href=/zh/partners/>合作伙伴</a>
<a class=text-white href=/zh/community/>社区</a>
<a class=text-white href=/zh/case-studies/>案例分析</a>
</nav>
</div>
<div class=container-fluid>
<div class=row>
<div class="col-6 col-sm-2 text-xs-center order-sm-2">
<ul class="list-inline mb-0">
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="User mailing list" aria-label="User mailing list">
<a class=text-white target=_blank href=https://discuss.kubernetes.io>
<i class="fa fa-envelope"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Twitter aria-label=Twitter>
<a class=text-white target=_blank href=https://twitter.com/kubernetesio>
<i class="fab fa-twitter"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Calendar aria-label=Calendar>
<a class=text-white target=_blank href="https://calendar.google.com/calendar/embed?src=calendar%40kubernetes.io">
<i class="fas fa-calendar-alt"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Youtube aria-label=Youtube>
<a class=text-white target=_blank href=https://youtube.com/kubernetescommunity>
<i class="fab fa-youtube"></i>
</a>
</li>
</ul>
</div>
<div class="col-6 col-sm-2 text-right text-xs-center order-sm-3">
<ul class="list-inline mb-0">
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub>
<a class=text-white target=_blank href=https://github.com/kubernetes/kubernetes>
<i class="fab fa-github"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Slack aria-label=Slack>
<a class=text-white target=_blank href=https://slack.k8s.io>
<i class="fab fa-slack"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Contribute aria-label=Contribute>
<a class=text-white target=_blank href=https://git.k8s.io/community/contributors/guide>
<i class="fas fa-edit"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Stack Overflow" aria-label="Stack Overflow">
<a class=text-white target=_blank href=https://stackoverflow.com/questions/tagged/kubernetes>
<i class="fab fa-stack-overflow"></i>
</a>
</li>
</ul>
</div>
<div class="col-12 col-sm-8 text-center order-sm-2">
<small class=text-white>&copy; 2023 The Kubernetes Authors | Documentation Distributed under <a href=https://git.k8s.io/website/LICENSE class=light-text>CC BY 4.0</a></small>
<br>
<small class=text-white>Copyright &copy; 2023 The Linux Foundation &reg;. All rights reserved. The Linux Foundation has registered trademarks and uses trademarks. For a list of trademarks of The Linux Foundation, please see our <a href=https://www.linuxfoundation.org/trademark-usage class=light-text>Trademark Usage page</a></small>
<br>
<small class=text-white>ICP license: 京ICP备17074266号-3</small>
</div>
</div>
</div>
</footer>
</div>
<script src=/js/popper-1.14.3.min.js integrity=sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49 crossorigin=anonymous></script>
<script src=/js/bootstrap-4.3.1.min.js integrity=sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM crossorigin=anonymous></script>
<script src=/js/main.min.40616251a9b6e4b689e7769be0340661efa4d7ebb73f957404e963e135b4ed52.js integrity="sha256-QGFiUam25LaJ53ab4DQGYe+k1+u3P5V0BOlj4TW07VI=" crossorigin=anonymous></script>
</body>
</html>