<!doctype html><html lang=ko class=no-js>
<head>
<meta name=ROBOTS content="NOINDEX, NOFOLLOW">
<script async src="https://www.googletagmanager.com/gtag/js?id=G-JPP6RFM2BP"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-JPP6RFM2BP')</script>
<link rel=alternate hreflang=en href=https://kubernetes.io/docs/concepts/>
<link rel=alternate hreflang=zh href=https://kubernetes.io/zh/docs/concepts/>
<link rel=alternate hreflang=ja href=https://kubernetes.io/ja/docs/concepts/>
<link rel=alternate hreflang=fr href=https://kubernetes.io/fr/docs/concepts/>
<link rel=alternate hreflang=it href=https://kubernetes.io/it/docs/concepts/>
<link rel=alternate hreflang=de href=https://kubernetes.io/de/docs/concepts/>
<link rel=alternate hreflang=pt-br href=https://kubernetes.io/pt-br/docs/concepts/>
<link rel=alternate hreflang=es href=https://kubernetes.io/es/docs/concepts/>
<link rel=alternate hreflang=id href=https://kubernetes.io/id/docs/concepts/>
<link rel=alternate hreflang=ru href=https://kubernetes.io/ru/docs/concepts/>
<link rel=alternate hreflang=pl href=https://kubernetes.io/pl/docs/concepts/>
<link rel=alternate hreflang=uk href=https://kubernetes.io/uk/docs/concepts/>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=generator content="Hugo 0.87.0">
<link rel=canonical type=text/html href=https://kubernetes.io/ko/docs/concepts/>
<link rel="shortcut icon" type=image/png href=/images/favicon.png>
<link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180>
<link rel=manifest href=/manifest.webmanifest>
<link rel=apple-touch-icon href=/images/kubernetes-192x192.png>
<title>개념 | Kubernetes</title><meta property="og:title" content="개념">
<meta property="og:description" content="운영 수준의 컨테이너 오케스트레이션">
<meta property="og:type" content="website">
<meta property="og:url" content="https://kubernetes.io/ko/docs/concepts/"><meta property="og:site_name" content="Kubernetes">
<meta itemprop=name content="개념">
<meta itemprop=description content="운영 수준의 컨테이너 오케스트레이션"><meta name=twitter:card content="summary">
<meta name=twitter:title content="개념">
<meta name=twitter:description content="운영 수준의 컨테이너 오케스트레이션">
<link href=/scss/main.css rel=stylesheet>
<script src=/js/jquery-3.3.1.min.js integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin=anonymous></script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","url":"https://kubernetes.io","logo":"https://kubernetes.io/images/favicon.png"}</script>
<meta name=theme-color content="#326ce5">
<link rel=stylesheet href=/css/feature-states.css>
<meta name=description content="개념 섹션을 통해 쿠버네티스 시스템을 구성하는 요소와 클러스터를 표현하는데 사용되는 추상 개념에 대해 배우고 쿠버네티스가 작동하는 방식에 대해 보다 깊이 이해할 수 있다.">
<meta property="og:description" content="개념 섹션을 통해 쿠버네티스 시스템을 구성하는 요소와 클러스터를 표현하는데 사용되는 추상 개념에 대해 배우고 쿠버네티스가 작동하는 방식에 대해 보다 깊이 이해할 수 있다.">
<meta name=twitter:description content="개념 섹션을 통해 쿠버네티스 시스템을 구성하는 요소와 클러스터를 표현하는데 사용되는 추상 개념에 대해 배우고 쿠버네티스가 작동하는 방식에 대해 보다 깊이 이해할 수 있다.">
<meta property="og:url" content="https://kubernetes.io/ko/docs/concepts/">
<meta property="og:title" content="개념">
<meta name=twitter:title content="개념">
<meta name=twitter:image content="https://kubernetes.io/images/favicon.png">
<meta name=twitter:image:alt content="Kubernetes">
<meta property="og:image" content="/images/kubernetes-horizontal-color.png">
<meta property="og:type" content="article">
<script src=/js/script.js></script>
</head>
<body class=td-section>
<header>
<nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar" data-auto-burger=primary>
<a class=navbar-brand href=/ko/></a>
<div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar>
<ul class="navbar-nav mt-2 mt-lg-0">
<li class="nav-item mr-2 mb-lg-0">
<a class="nav-link active" href=/ko/docs/>문서</a>
</li>
<li class="nav-item mr-2 mb-lg-0">
<a class=nav-link href=/ko/blog/>쿠버네티스 블로그</a>
</li>
<li class="nav-item mr-2 mb-lg-0">
<a class=nav-link href=/ko/training/>교육</a>
</li>
<li class="nav-item mr-2 mb-lg-0">
<a class=nav-link href=/ko/partners/>파트너</a>
</li>
<li class="nav-item mr-2 mb-lg-0">
<a class=nav-link href=/ko/community/>커뮤니티</a>
</li>
<li class="nav-item mr-2 mb-lg-0">
<a class=nav-link href=/ko/case-studies/>사례 연구</a>
</li>
<li class="nav-item dropdown">
<a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>
버전
</a>
<div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink>
<a class=dropdown-item href=/releases>Release Information</a>
<a class=dropdown-item href=https://kubernetes.io/ko/docs/concepts/>v1.27</a>
<a class=dropdown-item href=https://v1-26.docs.kubernetes.io/ko/docs/concepts/>v1.26</a>
<a class=dropdown-item href=https://v1-25.docs.kubernetes.io/ko/docs/concepts/>v1.25</a>
<a class=dropdown-item href=https://v1-24.docs.kubernetes.io/ko/docs/concepts/>v1.24</a>
<a class=dropdown-item href=https://v1-23.docs.kubernetes.io/ko/docs/concepts/>v1.23</a>
</div>
</li>
<li class="nav-item dropdown">
<a class="nav-link dropdown-toggle" href=# id=navbarDropdownMenuLink role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>
한국어 Korean
</a>
<div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink>
<a class=dropdown-item href=/docs/concepts/>English</a>
<a class=dropdown-item href=/zh/docs/concepts/>中文 Chinese</a>
<a class=dropdown-item href=/ja/docs/concepts/>日本語 Japanese</a>
<a class=dropdown-item href=/fr/docs/concepts/>Français</a>
<a class=dropdown-item href=/it/docs/concepts/>Italiano</a>
<a class=dropdown-item href=/de/docs/concepts/>Deutsch</a>
<a class=dropdown-item href=/pt-br/docs/concepts/>Português</a>
<a class=dropdown-item href=/es/docs/concepts/>Español</a>
<a class=dropdown-item href=/id/docs/concepts/>Bahasa Indonesia</a>
<a class=dropdown-item href=/ru/docs/concepts/>Русский</a>
<a class=dropdown-item href=/pl/docs/concepts/>Polski</a>
<a class=dropdown-item href=/uk/docs/concepts/>Українська</a>
</div>
</li>
</ul>
</div>
<button id=hamburger onclick=kub.toggleMenu() data-auto-burger-exclude><div></div></button>
</nav>
</header>
<div class="container-fluid td-outer">
<div class=td-main>
<div class="row flex-xl-nowrap">
<main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main>
<div class=td-content>
<div class="pageinfo pageinfo-primary d-print-none">
<p>
이 섹션의 다중 페이지 출력 화면임.
<a href=# onclick="return print(),!1">여기를 클릭하여 프린트</a>.
</p><p>
<a href=/ko/docs/concepts/>이 페이지의 일반 화면으로 돌아가기</a>.
</p>
</div>
<h1 class=title>개념</h1>
<ul>
<li>1: <a href=#pg-0554ac387412eaf4e6e89b2f847dacde>개요</a></li>
<ul>
<li>1.1: <a href=#pg-45bdca6129cf540121623e903c18ba46>쿠버네티스란 무엇인가?</a></li>
<li>1.2: <a href=#pg-13b0f1dbe89228e3d76d2ac231e245f1>쿠버네티스 컴포넌트</a></li>
<li>1.3: <a href=#pg-0c745f42e623d2b70a53bc0e6db73d95>쿠버네티스 API</a></li>
<li>1.4: <a href=#pg-110f33530cf761140cb1dab536baef04>쿠버네티스 오브젝트로 작업하기</a></li>
<ul>
<li>1.4.1: <a href=#pg-9f5adfa77f48c50d5cc81155a3cecb98>쿠버네티스 오브젝트 이해하기</a></li>
<li>1.4.2: <a href=#pg-6751db8ff5409476de8225d17d6c42dd>쿠버네티스 오브젝트 관리</a></li>
<li>1.4.3: <a href=#pg-f37749a83c2916b63279ea60f3cfe53e>오브젝트 이름과 ID</a></li>
<li>1.4.4: <a href=#pg-1127165f472b7181b9c1d5a0b187d620>네임스페이스</a></li>
<li>1.4.5: <a href=#pg-f1dec4557fb8ffbac9f11390aaaf9fa4>레이블과 셀렉터</a></li>
<li>1.4.6: <a href=#pg-93cd7a1d4e1623e2bf01afc49a5af69c>어노테이션</a></li>
<li>1.4.7: <a href=#pg-046c03090d47bc4b89b818dc645c3865>필드 셀렉터</a></li>
<li>1.4.8: <a href=#pg-5dd62c6a4a481b4cf1ac50f6799eb581>권장 레이블</a></li>
</ul>
</ul>
<li>2: <a href=#pg-2bf36ccd6b3dbeafecf87c39761b07c7>클러스터 아키텍처</a></li>
<ul>
<li>2.1: <a href=#pg-9ef2890698e773b6c0d24fd2c20146f5>노드</a></li>
<li>2.2: <a href=#pg-c0251def6da29b30afebfb04549f1703>컨트롤 플레인-노드 간 통신</a></li>
<li>2.3: <a href=#pg-ca8819042a505291540e831283da66df>컨트롤러</a></li>
<li>2.4: <a href=#pg-bc804b02614d67025b4c788f1ca87fbc>클라우드 컨트롤러 매니저</a></li>
<li>2.5: <a href=#pg-44a2e2e592af0846101e970aff9243e5>가비지(Garbage) 수집</a></li>
<li>2.6: <a href=#pg-c0ea5310f52e22c5de34dc84d9ab5e0d>컨테이너 런타임 인터페이스(CRI)</a></li>
</ul>
<li>3: <a href=#pg-a5f7383c83ab9eb9cd0e3c4c020b3ae6>컨테이너</a></li>
<ul>
<li>3.1: <a href=#pg-16042b4652ad19e565c7263824029a43>이미지</a></li>
<li>3.2: <a href=#pg-a858027489648786a3b16264e451272b>런타임클래스(RuntimeClass)</a></li>
<li>3.3: <a href=#pg-643212488f778acf04bebed65ba34441>컨테이너 환경 변수</a></li>
<li>3.4: <a href=#pg-e6941d969d81540208a3e78bc56f43bc>컨테이너 라이프사이클 훅(Hook)</a></li>
</ul>
<li>4: <a href=#pg-d52aadda80edd9f8c514cfe2321363c2>워크로드</a></li>
<ul>
<li>4.1: <a href=#pg-4d68b0ccf9c683e6368ffdcc40c838d4>파드</a></li>
<ul>
<li>4.1.1: <a href=#pg-c3c2b9cf30915ec9d46c147201da3332>파드 라이프사이클</a></li>
<li>4.1.2: <a href=#pg-1ccbd4eeded6ab138d98b59175bd557e>초기화 컨테이너</a></li>
<li>4.1.3: <a href=#pg-c8d62295ca703fdcef1aaf89fb4c916a>파드 토폴로지 분배 제약 조건</a></li>
<li>4.1.4: <a href=#pg-4aaf43c715cd764bc8ed4436f3537e68>중단(disruption)</a></li>
<li>4.1.5: <a href=#pg-53a1005011e1bda2ce81819aad7c8b32>임시(Ephemeral) 컨테이너</a></li>
</ul>
<li>4.2: <a href=#pg-89637410cacae45a36ab1cc278c482eb>워크로드 리소스</a></li>
<ul>
<li>4.2.1: <a href=#pg-a2dc0393e0c4079e1c504b6429844e86>디플로이먼트</a></li>
<li>4.2.2: <a href=#pg-d459b930218774655fa7fd1620625539>레플리카셋</a></li>
<li>4.2.3: <a href=#pg-6d72299952c37ca8cc61b416e5bdbcd4>스테이트풀셋</a></li>
<li>4.2.4: <a href=#pg-41600eb8b6631c88848156f381e9d588>데몬셋</a></li>
<li>4.2.5: <a href=#pg-cc7cc3c4907039d9f863162e20bfbbef>잡</a></li>
<li>4.2.6: <a href=#pg-4de50a37ebb6f2340484192126cb7a04>완료된 잡 자동 정리</a></li>
<li>4.2.7: <a href=#pg-2e4cec01c525b45eccd6010e21cc76d9>크론잡</a></li>
<li>4.2.8: <a href=#pg-27f1331d515d95f76aa1156088b4ad91>레플리케이션 컨트롤러</a></li>
</ul>
</ul>
<li>5: <a href=#pg-0a0a7eca3e302a3c08f8c85e15d337fd>서비스, 로드밸런싱, 네트워킹</a></li>
<ul>
<li>5.1: <a href=#pg-5701136fd2ce258047b6ddc389112352>서비스</a></li>
<li>5.2: <a href=#pg-3a38878244d862dfdb8d7adb32f77584>토폴로지 키를 사용하여 토폴로지-인지 트래픽 라우팅</a></li>
<li>5.3: <a href=#pg-91cb8a4438b003df11bc1c426a81b756>서비스 및 파드용 DNS</a></li>
<li>5.4: <a href=#pg-f804ac0532fcade3966ea2e3769ca031>서비스와 애플리케이션 연결하기</a></li>
<li>5.5: <a href=#pg-5a8edeb1f2dc8e38cd6d561bb08b0d78>인그레스 컨트롤러</a></li>
<li>5.6: <a href=#pg-199bcc92443dbc9bed44819467d7eb75>인그레스(Ingress)</a></li>
<li>5.7: <a href=#pg-cd7657b1056ad32451974db57a951ba5>서비스 내부 트래픽 정책</a></li>
<li>5.8: <a href=#pg-f51db1097575de8072afe1f5b156a70c>엔드포인트슬라이스</a></li>
<li>5.9: <a href=#pg-374e5c954990aec58a0797adc70a5039>토폴로지 인지 힌트</a></li>
<li>5.10: <a href=#pg-ded1daafdcd293023ee333728007ca61>네트워크 정책</a></li>
<li>5.11: <a href=#pg-21f8d19c60c33914baab66224c3d46a7>IPv4/IPv6 이중 스택</a></li>
</ul>
<li>6: <a href=#pg-f018f568c6723865753f150c3c59bdda>스토리지</a></li>
<ul>
<li>6.1: <a href=#pg-27795584640a03bd2024f1fe3b3ab754>볼륨</a></li>
<li>6.2: <a href=#pg-ffd12528a12882b282e1bd19e29f9e75>퍼시스턴트 볼륨</a></li>
<li>6.3: <a href=#pg-f0276d05eef111249272a1c932a91e2c>스토리지 클래스</a></li>
<li>6.4: <a href=#pg-df33eab51202c17bb0fe551d1d5cc5d2>임시 볼륨</a></li>
<li>6.5: <a href=#pg-018f0a7fc6e2f6d16da37702fc39b4f3>동적 볼륨 프로비저닝</a></li>
<li>6.6: <a href=#pg-c262af210c6828dec445d2f55a1d877a>볼륨 스냅샷</a></li>
<li>6.7: <a href=#pg-4d00116c86dade62bdd5be7dc2afa1ca>볼륨 스냅샷 클래스</a></li>
<li>6.8: <a href=#pg-707ca81a34eb1ca202f34692e9917d1e>CSI 볼륨 복제하기</a></li>
<li>6.9: <a href=#pg-00cd24f4570b7acaac75c2551c948bc7>스토리지 용량</a></li>
<li>6.10: <a href=#pg-b2e4b16ac37988c678a3312a4a6639f8>노드 별 볼륨 한도</a></li>
<li>6.11: <a href=#pg-4f40cb95a671e51b4f0156a409d95c6d>볼륨 헬스 모니터링</a></li>
</ul>
<li>7: <a href=#pg-275bea454e1cf4c5adeca4058b5af988>구성</a></li>
<ul>
<li>7.1: <a href=#pg-ddef6fd0e47bb51c6f05e8e7fb11d2dd>구성 모범 사례</a></li>
<li>7.2: <a href=#pg-6b5ccadd699df0904e8e9917c5450c4b>컨피그맵(ConfigMap)</a></li>
<li>7.3: <a href=#pg-e511ed821ada65d0053341dbd8ad2bb5>시크릿(Secret)</a></li>
<li>7.4: <a href=#pg-436057b96151ecb8a4a9a9f456b5d0fc>파드 및 컨테이너 리소스 관리</a></li>
<li>7.5: <a href=#pg-ab6d20f33ad930a67ee7ef57bff6c75e>kubeconfig 파일을 사용하여 클러스터 접근 구성하기</a></li>
</ul>
<li>8: <a href=#pg-712cb3c03ff14a39e5a83a6d9b71d203>보안</a></li>
<ul>
<li>8.1: <a href=#pg-04eeb110d75afc8acb2cf7a3db743985>클라우드 네이티브 보안 개요</a></li>
<li>8.2: <a href=#pg-4d77d1ae4c06aa14f54b385191627881>쿠버네티스 API 접근 제어하기</a></li>
</ul>
<li>9: <a href=#pg-c21d05f31057c5bcd2ebdd01f4e62a0e>스케줄링, 선점(Preemption), 축출(Eviction)</a></li>
<ul>
<li>9.1: <a href=#pg-598f36d691ab197f9d995784574b0a12>쿠버네티스 스케줄러</a></li>
<li>9.2: <a href=#pg-21169f516071aea5d16734a4c27789a5>노드에 파드 할당하기</a></li>
<li>9.3: <a href=#pg-da22fe2278df236f71efbe672f392677>파드 오버헤드</a></li>
<li>9.4: <a href=#pg-ede4960b56a3529ee0bfe7c8fe2d09a5>테인트(Taints)와 톨러레이션(Tolerations)</a></li>
<li>9.5: <a href=#pg-78e0431b4b7516092662a7c289cbb304>노드-압박 축출</a></li>
<li>9.6: <a href=#pg-b87723bf81b079042860f0ebd37b0a64>API를 이용한 축출(Eviction)</a></li>
<li>9.7: <a href=#pg-60e5a2861609e0848d58ce8bf99c4a31>파드 우선순위(priority)와 선점(preemption)</a></li>
<li>9.8: <a href=#pg-961126cd43559012893979e568396a49>확장된 리소스를 위한 리소스 빈 패킹(bin packing)</a></li>
<li>9.9: <a href=#pg-d9574a30fcbc631b0d2a57850e161e89>스케줄러 성능 튜닝</a></li>
</ul>
<li>10: <a href=#pg-ac9161c6d952925b083ad9602b4e8e7f>정책</a></li>
<ul>
<li>10.1: <a href=#pg-a935ff8c59eb116b43494255cc67f69a>리밋 레인지(Limit Range)</a></li>
<li>10.2: <a href=#pg-94ddc6e901c30f256138db11d09f05a3>리소스 쿼터</a></li>
<li>10.3: <a href=#pg-59977cbac423e20437db079757cb03df>파드 시큐리티 폴리시</a></li>
<li>10.4: <a href=#pg-b528c4464c030f3f044124b38d778f04>노드 리소스 매니저</a></li>
</ul>
<li>11: <a href=#pg-285a3785fd3d20f437c28d87ca4dadca>클러스터 관리</a></li>
<ul>
<li>11.1: <a href=#pg-2bf9a93ab5ba014fb6ff70b22c29d432>인증서</a></li>
<li>11.2: <a href=#pg-3aeeecf7cdb2a21eb4b31db7a71c81e2>리소스 관리</a></li>
<li>11.3: <a href=#pg-d649067a69d8d5c7e71564b42b96909e>클러스터 네트워킹</a></li>
<li>11.4: <a href=#pg-c4b1e87a84441f8a90699a345ce48d68>로깅 아키텍처</a></li>
<li>11.5: <a href=#pg-5cc31ecfba86467f8884856412cfb6b2>시스템 로그</a></li>
<li>11.6: <a href=#pg-cbfd3654996eae9fcdef009f70fa83f0>쿠버네티스 시스템 컴포넌트에 대한 메트릭</a></li>
<li>11.7: <a href=#pg-08e94e6a480e0d6b2de72d84a1b97617>쿠버네티스에서 프락시(Proxy)</a></li>
<li>11.8: <a href=#pg-85d633ae590aa20ec024f1b7af1d74fc>애드온 설치</a></li>
</ul>
<li>12: <a href=#pg-7e0d97616b15e2c383c6a0a96ec442cb>쿠버네티스 확장</a></li>
<ul>
<li>12.1: <a href=#pg-0af41d3bd7c785621b58b7564793396a>쿠버네티스 API 확장하기</a></li>
<ul>
<li>12.1.1: <a href=#pg-342388440304e19ce30c0f8ada1c77ce>커스텀 리소스</a></li>
<li>12.1.2: <a href=#pg-1ea4977c0ebf97569bf54a477faa7fa5>쿠버네티스 API 애그리게이션 레이어(aggregation layer)</a></li>
</ul>
<li>12.2: <a href=#pg-3131452556176159fb269593c1a52012>오퍼레이터(operator) 패턴</a></li>
<li>12.3: <a href=#pg-c8937cdc9df96f3328becf04f8211292>컴퓨트, 스토리지 및 네트워킹 익스텐션</a></li>
<ul>
<li>12.3.1: <a href=#pg-1ac2260db9ecccbf0303a899bc27ce6d>네트워크 플러그인</a></li>
<li>12.3.2: <a href=#pg-53e1ea8892ceca307ba19e8d6a7b8d32>장치 플러그인</a></li>
</ul>
<li>12.4: <a href=#pg-b26fcf43d01abc16c8110766026dafed>서비스 카탈로그</a></li>
</ul>
</ul>
<div class=content>
<p>개념 섹션을 통해 쿠버네티스 시스템을 구성하는 요소와 <a class=glossary-tooltip title="컨테이너화된 애플리케이션을 실행하는 노드라고 하는 워커 머신의 집합. 모든 클러스터는 최소 한 개의 워커 노드를 가진다." data-toggle=tooltip data-placement=top href="/ko/docs/reference/glossary/?all=true#term-cluster" target=_blank aria-label=클러스터>클러스터</a>를 표현하는데 사용되는 추상 개념에 대해 배우고 쿠버네티스가 작동하는 방식에 대해 보다 깊이 이해할 수 있다.</p>
</div>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-0554ac387412eaf4e6e89b2f847dacde>1 - 개요</h1>
<div class=lead>쿠버네티스와 그 컴포넌트에 대한 하이-레벨(high-level) 개요를 제공한다.</div>
</div>
<div class=td-content>
<h1 id=pg-45bdca6129cf540121623e903c18ba46>1.1 - 쿠버네티스란 무엇인가?</h1>
<div class=lead>쿠버네티스는 컨테이너화된 워크로드와 서비스를 관리하기 위한 이식할 수 있고, 확장 가능한 오픈소스 플랫폼으로, 선언적 구성과 자동화를 모두 지원한다. 쿠버네티스는 크고 빠르게 성장하는 생태계를 가지고 있다. 쿠버네티스 서비스, 지원 그리고 도구들은 광범위하게 제공된다.</div>
<p>이 페이지에서는 쿠버네티스 개요를 설명한다.</p>
<p>쿠버네티스는 컨테이너화된 워크로드와 서비스를 관리하기 위한 이식성이 있고, 확장가능한 오픈소스 플랫폼이다. 쿠버네티스는 선언적 구성과 자동화를 모두 용이하게 해준다. 쿠버네티스는 크고, 빠르게 성장하는 생태계를 가지고 있다. 쿠버네티스 서비스, 기술 지원 및 도구는 어디서나 쉽게 이용할 수 있다.</p>
<p>쿠버네티스란 명칭은 키잡이(helmsman)나 파일럿을 뜻하는 그리스어에서 유래했다. K8s라는 표기는 "K"와 "s"와 그 사이에 있는 8글자를 나타내는 약식 표기이다. 구글이 2014년에 쿠버네티스 프로젝트를 오픈소스화했다. 쿠버네티스는 프로덕션 워크로드를 대규모로 운영하는 <a href=/blog/2015/04/borg-predecessor-to-kubernetes/>15년 이상의 구글 경험</a>과 커뮤니티의 최고의 아이디어와 적용 사례가 결합되어 있다.</p>
<h2 id=여정-돌아보기>여정 돌아보기</h2>
<p>시간이 지나면서 쿠버네티스가 왜 유용하게 되었는지 살펴보자.</p>
<p><img src=/images/docs/Container_Evolution.svg alt="배포 혁명"></p>
<p><strong>전통적인 배포 시대:</strong>
초기 조직은 애플리케이션을 물리 서버에서 실행했었다. 한 물리 서버에서 여러 애플리케이션의 리소스 한계를 정의할 방법이 없었기에, 리소스 할당의 문제가 발생했다. 예를 들어 물리 서버 하나에서 여러 애플리케이션을 실행하면, 리소스 전부를 차지하는 애플리케이션 인스턴스가 있을 수 있고, 결과적으로는 다른 애플리케이션의 성능이 저하될 수 있었다. 이에 대한 해결책은 서로 다른 여러 물리 서버에서 각 애플리케이션을 실행하는 것이 있다. 그러나 이는 리소스가 충분히 활용되지 않는다는 점에서 확장 가능하지 않았으므로, 물리 서버를 많이 유지하기 위해서 조직에게 많은 비용이 들었다.</p>
<p><strong>가상화된 배포 시대:</strong> 그 해결책으로 가상화가 도입되었다. 이는 단일 물리 서버의 CPU에서 여러 가상 시스템 (VM)을 실행할 수 있게 한다. 가상화를 사용하면 VM간에 애플리케이션을 격리하고 애플리케이션의 정보를 다른 애플리케이션에서 자유롭게 액세스 할 수 없으므로, 일정 수준의 보안성을 제공할 수 있다.</p>
<p>가상화를 사용하면 물리 서버에서 리소스를 보다 효율적으로 활용할 수 있으며, 쉽게 애플리케이션을 추가하거나 업데이트할 수 있고 하드웨어 비용을 절감할 수 있어 더 나은 확장성을 제공한다. 가상화를 통해 일련의 물리 리소스를 폐기 가능한(disposable) 가상 머신으로 구성된 클러스터로 만들 수 있다.</p>
<p>각 VM은 가상화된 하드웨어 상에서 자체 운영체제를 포함한 모든 구성 요소를 실행하는 하나의 완전한 머신이다.</p>
<p><strong>컨테이너 개발 시대:</strong> 컨테이너는 VM과 유사하지만 격리 속성을 완화하여 애플리케이션 간에 운영체제(OS)를 공유한다. 그러므로 컨테이너는 가볍다고 여겨진다. VM과 마찬가지로 컨테이너에는 자체 파일 시스템, CPU 점유율, 메모리, 프로세스 공간 등이 있다. 기본 인프라와의 종속성을 끊었기 때문에, 클라우드나 OS 배포본에 모두 이식할 수 있다.</p>
<p>컨테이너는 다음과 같은 추가적인 혜택을 제공하기 때문에 인기가 있다.</p>
<ul>
<li>기민한 애플리케이션 생성과 배포: VM 이미지를 사용하는 것에 비해 컨테이너 이미지 생성이 보다 쉽고 효율적임.</li>
<li>지속적인 개발, 통합 및 배포: 안정적이고 주기적으로 컨테이너 이미지를 빌드해서 배포할 수 있고 (이미지의 불변성 덕에) 빠르고 효율적으로 롤백할 수 있다.</li>
<li>개발과 운영의 관심사 분리: 배포 시점이 아닌 빌드/릴리스 시점에 애플리케이션 컨테이너 이미지를 만들기 때문에, 애플리케이션이 인프라스트럭처에서 분리된다.</li>
<li>가시성(observability): OS 수준의 정보와 메트릭에 머무르지 않고, 애플리케이션의 헬스와 그 밖의 시그널을 볼 수 있다.</li>
<li>개발, 테스팅 및 운영 환경에 걸친 일관성: 랩탑에서도 클라우드에서와 동일하게 구동된다.</li>
<li>클라우드 및 OS 배포판 간 이식성: Ubuntu, RHEL, CoreOS, 온-프레미스, 주요 퍼블릭 클라우드와 어디에서든 구동된다.</li>
<li>애플리케이션 중심 관리: 가상 하드웨어 상에서 OS를 실행하는 수준에서 논리적인 리소스를 사용하는 OS 상에서 애플리케이션을 실행하는 수준으로 추상화 수준이 높아진다.</li>
<li>느슨하게 커플되고, 분산되고, 유연하며, 자유로운 마이크로서비스: 애플리케이션은 단일 목적의 머신에서 모놀리식 스택으로 구동되지 않고 보다 작고 독립적인 단위로 쪼개져서 동적으로 배포되고 관리될 수 있다.</li>
<li>리소스 격리: 애플리케이션 성능을 예측할 수 있다.</li>
<li>자원 사용량: 리소스 사용량: 고효율 고집적.</li>
</ul>
<h2 id=why-you-need-kubernetes-and-what-can-it-do>쿠버네티스가 왜 필요하고 무엇을 할 수 있나</h2>
<p>컨테이너는 애플리케이션을 포장하고 실행하는 좋은 방법이다. 프로덕션 환경에서는 애플리케이션을 실행하는 컨테이너를 관리하고 가동 중지 시간이 없는지 확인해야 한다. 예를 들어 컨테이너가 다운되면 다른 컨테이너를 다시 시작해야 한다. 이 문제를 시스템에 의해 처리한다면 더 쉽지 않을까?</p>
<p>그것이 쿠버네티스가 필요한 이유이다! 쿠버네티스는 분산 시스템을 탄력적으로 실행하기 위한 프레임 워크를 제공한다. 애플리케이션의 확장과 장애 조치를 처리하고, 배포 패턴 등을 제공한다. 예를 들어, 쿠버네티스는 시스템의 카나리아 배포를 쉽게 관리 할 수 있다.</p>
<p>쿠버네티스는 다음을 제공한다.</p>
<ul>
<li><strong>서비스 디스커버리와 로드 밸런싱</strong>
쿠버네티스는 DNS 이름을 사용하거나 자체 IP 주소를 사용하여 컨테이너를 노출할 수 있다. 컨테이너에 대한 트래픽이 많으면, 쿠버네티스는 네트워크 트래픽을 로드밸런싱하고 배포하여 배포가 안정적으로 이루어질 수 있다.</li>
<li><strong>스토리지 오케스트레이션</strong>
쿠버네티스를 사용하면 로컬 저장소, 공용 클라우드 공급자 등과 같이 원하는 저장소 시스템을 자동으로 탑재 할 수 있다.</li>
<li><strong>자동화된 롤아웃과 롤백</strong>
쿠버네티스를 사용하여 배포된 컨테이너의 원하는 상태를 서술할 수 있으며 현재 상태를 원하는 상태로 설정한 속도에 따라 변경할 수 있다. 예를 들어 쿠버네티스를 자동화해서 배포용 새 컨테이너를 만들고, 기존 컨테이너를 제거하고, 모든 리소스를 새 컨테이너에 적용할 수 있다.</li>
<li><strong>자동화된 빈 패킹(bin packing)</strong>
컨테이너화된 작업을 실행하는데 사용할 수 있는 쿠버네티스 클러스터 노드를 제공한다. 각 컨테이너가 필요로 하는 CPU와 메모리(RAM)를 쿠버네티스에게 지시한다. 쿠버네티스는 컨테이너를 노드에 맞추어서 리소스를 가장 잘 사용할 수 있도록 해준다.</li>
<li><strong>자동화된 복구(self-healing)</strong>
쿠버네티스는 실패한 컨테이너를 다시 시작하고, 컨테이너를 교체하며, '사용자 정의 상태 검사'에 응답하지 않는 컨테이너를 죽이고, 서비스 준비가 끝날 때까지 그러한 과정을 클라이언트에 보여주지 않는다.</li>
<li><strong>시크릿과 구성 관리</strong>
쿠버네티스를 사용하면 암호, OAuth 토큰 및 SSH 키와 같은 중요한 정보를 저장하고 관리 할 수 있다. 컨테이너 이미지를 재구성하지 않고 스택 구성에 시크릿을 노출하지 않고도 시크릿 및 애플리케이션 구성을 배포 및 업데이트 할 수 있다.</li>
</ul>
<h2 id=쿠버네티스가-아닌-것>쿠버네티스가 아닌 것</h2>
<p>쿠버네티스는 전통적인, 모든 것이 포함된 Platform as a Service(PaaS)가 아니다. 쿠버네티스는 하드웨어 수준보다는 컨테이너 수준에서 운영되기 때문에, PaaS가 일반적으로 제공하는 배포, 스케일링, 로드 밸런싱과 같은 기능을 제공하며, 사용자가 로깅, 모니터링 및 알림 솔루션을 통합할 수 있다. 하지만, 쿠버네티스는 모놀리식(monolithic)이 아니어서, 이런 기본 솔루션이 선택적이며 추가나 제거가 용이하다. 쿠버네티스는 개발자 플랫폼을 만드는 구성 요소를 제공하지만, 필요한 경우 사용자의 선택권과 유연성을 지켜준다.</p>
<p>쿠버네티스는:</p>
<ul>
<li>지원하는 애플리케이션의 유형을 제약하지 않는다. 쿠버네티스는 상태 유지가 필요 없는(stateless) 워크로드, 상태 유지가 필요한(stateful) 워크로드, 데이터 처리를 위한 워크로드를 포함해서 극단적으로 다양한 워크로드를 지원하는 것을 목표로 한다. 애플리케이션이 컨테이너에서 구동될 수 있다면, 쿠버네티스에서도 잘 동작할 것이다.</li>
<li>소스 코드를 배포하지 않으며 애플리케이션을 빌드하지 않는다. 지속적인 통합과 전달과 배포, 곧 CI/CD 워크플로우는 조직 문화와 취향에 따를 뿐만 아니라 기술적인 요구사항으로 결정된다.</li>
<li>애플리케이션 레벨의 서비스를 제공하지 않는다. 애플리케이션 레벨의 서비스에는 미들웨어(예, 메시지 버스), 데이터 처리 프레임워크(예, Spark), 데이터베이스(예, MySQL), 캐시 또는 클러스터 스토리지 시스템(예, Ceph) 등이 있다. 이런 컴포넌트는 쿠버네티스 상에서 구동될 수 있고, 쿠버네티스 상에서 구동 중인 애플리케이션이 <a href=https://openservicebrokerapi.org/>Open Service Broker</a> 와 같은 이식 가능한 메커니즘을 통해 접근할 수도 있다.</li>
<li>로깅, 모니터링 또는 경보 솔루션을 포함하지 않는다. 개념 증명을 위한 일부 통합이나, 메트릭을 수집하고 노출하는 메커니즘을 제공한다.</li>
<li>기본 설정 언어/시스템(예, Jsonnet)을 제공하거나 요구하지 않는다. 선언적 명세의 임의적인 형식을 목적으로 하는 선언적 API를 제공한다.</li>
<li>포괄적인 머신 설정, 유지보수, 관리, 자동 복구 시스템을 제공하거나 채택하지 않는다.</li>
<li>추가로, 쿠버네티스는 단순한 오케스트레이션 시스템이 아니다. 사실, 쿠버네티스는 오케스트레이션의 필요성을 없애준다. 오케스트레이션의 기술적인 정의는 A를 먼저 한 다음, B를 하고, C를 하는 것과 같이 정의된 워크플로우를 수행하는 것이다. 반면에, 쿠버네티스는 독립적이고 조합 가능한 제어 프로세스들로 구성되어 있다. 이 프로세스는 지속적으로 현재 상태를 입력받은 의도한 상태로 나아가도록 한다. A에서 C로 어떻게 갔는지는 상관이 없다. 중앙화된 제어도 필요치 않다. 이로써 시스템이 보다 더 사용하기 쉬워지고, 강력해지며, 견고하고, 회복력을 갖추게 되며, 확장 가능해진다.</li>
</ul>
<h2 id=다음-내용>다음 내용</h2>
<ul>
<li><a href=/ko/docs/concepts/overview/components/>쿠버네티스 구성요소</a> 살펴보기</li>
<li><a href=/ko/docs/setup/>시작하기</a> 준비가 되었는가?</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-13b0f1dbe89228e3d76d2ac231e245f1>1.2 - 쿠버네티스 컴포넌트</h1>
<div class=lead>쿠버네티스 클러스터는 컴퓨터 집합인 노드 컴포넌트와 컨트롤 플레인 컴포넌트로 구성된다.</div>
<p>쿠버네티스를 배포하면 클러스터를 얻는다.
<p><p>쿠버네티스 클러스터는 컨테이너화된 애플리케이션을 실행하는 <a class=glossary-tooltip title="노드는 쿠버네티스의 작업 장비(worker machine)이다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/architecture/nodes/ target=_blank aria-label=노드>노드</a>라고
하는 워커 머신의 집합. 모든 클러스터는 최소 한 개의 워커 노드를 가진다.</p></p>
<p>워커 노드는 애플리케이션의 구성요소인
<a class=glossary-tooltip title="파드는 클러스터에서 실행 중인 컨테이너의 집합을 나타낸다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/pods/ target=_blank aria-label=파드>파드</a>를 호스트한다.
<a class=glossary-tooltip title="컨테이너의 라이프사이클을 정의, 배포, 관리하기 위한 API와 인터페이스들을 노출하는 컨테이너 오케스트레이션 레이어." data-toggle=tooltip data-placement=top href="/ko/docs/reference/glossary/?all=true#term-control-plane" target=_blank aria-label="컨트롤 플레인">컨트롤 플레인</a>은 워커 노드와
클러스터 내 파드를 관리한다. 프로덕션 환경에서는 일반적으로 컨트롤 플레인이
여러 컴퓨터에 걸쳐 실행되고, 클러스터는 일반적으로 여러 노드를
실행하므로 내결함성과 고가용성이 제공된다.</p></p>
<p>이 문서는 완전히 작동하는 쿠버네티스 클러스터를 갖기 위해 필요한
다양한 컴포넌트들에 대해 요약하고 정리한다.</p>
<figure class=diagram-large>
<img src=/images/docs/components-of-kubernetes.svg alt="쿠버네티스 구성 요소"> <figcaption>
<p>쿠버네티스 클러스터 구성 요소</p>
</figcaption>
</figure>
<h2 id=컨트롤-플레인-컴포넌트>컨트롤 플레인 컴포넌트</h2>
<p>컨트롤 플레인 컴포넌트는 클러스터에 관한 전반적인 결정(예를 들어, 스케줄링)을 수행하고 클러스터 이벤트(예를 들어, 디플로이먼트의 <code>replicas</code> 필드에 대한 요구 조건이 충족되지 않을 경우 새로운 <a class=glossary-tooltip title="파드는 클러스터에서 실행 중인 컨테이너의 집합을 나타낸다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/pods/ target=_blank aria-label=파드>파드</a>를 구동시키는 것)를 감지하고 반응한다.</p>
<p>컨트롤 플레인 컴포넌트는 클러스터 내 어떠한 머신에서든지 동작할 수 있다. 그러나
간결성을 위하여, 구성 스크립트는 보통 동일 머신 상에 모든 컨트롤 플레인 컴포넌트를 구동시키고,
사용자 컨테이너는 해당 머신 상에 동작시키지 않는다. 여러 VM에서
실행되는 컨트롤 플레인 설정의 예제를 보려면
<a href=/docs/setup/production-environment/tools/kubeadm/high-availability/>kubeadm을 사용하여 고가용성 클러스터 만들기</a>를 확인해본다.</p>
<h3 id=kube-apiserver>kube-apiserver</h3>
<p>API 서버는 쿠버네티스 API를
노출하는 쿠버네티스 <a class=glossary-tooltip title="컨테이너의 라이프사이클을 정의, 배포, 관리하기 위한 API와 인터페이스들을 노출하는 컨테이너 오케스트레이션 레이어." data-toggle=tooltip data-placement=top href="/ko/docs/reference/glossary/?all=true#term-control-plane" target=_blank aria-label="컨트롤 플레인">컨트롤 플레인</a> 컴포넌트이다.
API 서버는 쿠버네티스 컨트롤 플레인의 프론트 엔드이다.</p>
<p>쿠버네티스 API 서버의 주요 구현은 <a href=/docs/reference/generated/kube-apiserver/>kube-apiserver</a> 이다.
kube-apiserver는 수평으로 확장되도록 디자인되었다. 즉, 더 많은 인스턴스를 배포해서 확장할 수 있다.
여러 kube-apiserver 인스턴스를 실행하고, 인스턴스간의 트래픽을 균형있게 조절할 수 있다.</p>
<h3 id=etcd>etcd</h3>
<p>모든 클러스터 데이터를 담는 쿠버네티스 뒷단의 저장소로 사용되는 일관성·고가용성 키-값 저장소.</p>
<p>쿠버네티스 클러스터에서 etcd를 뒷단의 저장소로 사용한다면,
이 데이터를 <a href=/docs/tasks/administer-cluster/configure-upgrade-etcd/#backing-up-an-etcd-cluster>백업</a>하는 계획은
필수이다.</p>
<p>etcd에 대한 자세한 정보는, 공식 <a href=https://etcd.io/docs>문서</a>를 참고한다.</p>
<h3 id=kube-scheduler>kube-scheduler</h3>
<p><a class=glossary-tooltip title="노드는 쿠버네티스의 작업 장비(worker machine)이다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/architecture/nodes/ target=_blank aria-label=노드>노드</a>가 배정되지 않은 새로 생성된
<a class=glossary-tooltip title="파드는 클러스터에서 실행 중인 컨테이너의 집합을 나타낸다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/pods/ target=_blank aria-label=파드>파드</a> 를 감지하고,
실행할 노드를 선택하는 컨트롤
플레인 컴포넌트.</p>
<p>스케줄링 결정을 위해서 고려되는 요소는 리소스에 대한
개별 및 총체적 요구 사항, 하드웨어/소프트웨어/정책적 제약,
어피니티(affinity) 및 안티-어피니티(anti-affinity) 명세,
데이터 지역성, 워크로드-간 간섭, 데드라인을 포함한다.</p>
<h3 id=kube-controller-manager>kube-controller-manager</h3>
<p><a class=glossary-tooltip title="API 서버를 통해 클러스터의 공유된 상태를 감시하고, 현재 상태를 원하는 상태로 이행시키는 컨트롤 루프." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/architecture/controller/ target=_blank aria-label=컨트롤러>컨트롤러</a> 프로세스를 실행하는 컨트롤 플레인 컴포넌트.</p>
<p>논리적으로, 각 <a class=glossary-tooltip title="API 서버를 통해 클러스터의 공유된 상태를 감시하고, 현재 상태를 원하는 상태로 이행시키는 컨트롤 루프." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/architecture/controller/ target=_blank aria-label=컨트롤러>컨트롤러</a>는 분리된 프로세스이지만, 복잡성을 낮추기 위해 모두 단일 바이너리로 컴파일되고 단일 프로세스 내에서 실행된다.</p>
<p>이들 컨트롤러는 다음을 포함한다.</p>
<ul>
<li>노드 컨트롤러: 노드가 다운되었을 때 통지와 대응에 관한 책임을 가진다.</li>
<li>레플리케이션 컨트롤러: 시스템의 모든 레플리케이션 컨트롤러 오브젝트에 대해 알맞은 수의 파드들을
유지시켜 주는 책임을 가진다.</li>
<li>엔드포인트 컨트롤러: 엔드포인트 오브젝트를 채운다(즉, 서비스와 파드를 연결시킨다.)</li>
<li>서비스 어카운트 & 토큰 컨트롤러: 새로운 네임스페이스에 대한 기본 계정과 API 접근 토큰을 생성한다.</li>
</ul>
<h3 id=cloud-controller-manager>cloud-controller-manager</h3>
클라우드별 컨트롤 로직을 포함하는 쿠버네티스
<a class=glossary-tooltip title="컨테이너의 라이프사이클을 정의, 배포, 관리하기 위한 API와 인터페이스들을 노출하는 컨테이너 오케스트레이션 레이어." data-toggle=tooltip data-placement=top href="/ko/docs/reference/glossary/?all=true#term-control-plane" target=_blank aria-label="컨트롤 플레인">컨트롤 플레인</a> 컴포넌트이다.
클라우드 컨트롤러 매니저를 통해 클러스터를 클라우드 공급자의 API에 연결하고,
해당 클라우드 플랫폼과 상호 작용하는 컴포넌트와 클러스터와만 상호 작용하는 컴포넌트를 구분할 수 있게 해 준다.
<p>cloud-controller-manager는 클라우드 제공자 전용 컨트롤러만 실행한다.
자신의 사내 또는 PC 내부의 학습 환경에서 쿠버네티스를 실행 중인 경우
클러스터에는 클라우드 컨트롤러 매니저가 없다.</p>
<p>kube-controller-manager와 마찬가지로 cloud-controller-manager는 논리적으로
독립적인 여러 컨트롤 루프를 단일 프로세스로 실행하는 단일 바이너리로 결합한다.
수평으로 확장(두 개 이상의 복제 실행)해서 성능을 향상시키거나 장애를 견딜 수 있다.</p>
<p>다음 컨트롤러들은 클라우드 제공 사업자의 의존성을 가질 수 있다.</p>
<ul>
<li>노드 컨트롤러: 노드가 응답을 멈춘 후 클라우드 상에서 삭제되었는지 판별하기 위해 클라우드 제공 사업자에게 확인하는 것</li>
<li>라우트 컨트롤러: 기본 클라우드 인프라에 경로를 구성하는 것</li>
<li>서비스 컨트롤러: 클라우드 제공 사업자 로드밸런서를 생성, 업데이트 그리고 삭제하는 것</li>
</ul>
<h2 id=노드-컴포넌트>노드 컴포넌트</h2>
<p>노드 컴포넌트는 동작 중인 파드를 유지시키고 쿠버네티스 런타임 환경을 제공하며, 모든 노드 상에서 동작한다.</p>
<h3 id=kubelet>kubelet</h3>
<p>클러스터의 각 <a class=glossary-tooltip title="노드는 쿠버네티스의 작업 장비(worker machine)이다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/architecture/nodes/ target=_blank aria-label=노드>노드</a>에서 실행되는 에이전트. Kubelet은 <a class=glossary-tooltip title="파드는 클러스터에서 실행 중인 컨테이너의 집합을 나타낸다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/pods/ target=_blank aria-label=파드>파드</a>에서 <a class=glossary-tooltip title="소프트웨어와 그것에 종속된 모든 것을 포함한 가볍고 휴대성이 높은 실행 가능 이미지." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/containers/ target=_blank aria-label=컨테이너>컨테이너</a>가 확실하게 동작하도록 관리한다.</p>
<p>Kubelet은 다양한 메커니즘을 통해 제공된 파드 스펙(PodSpec)의 집합을 받아서 컨테이너가 해당 파드 스펙에 따라 건강하게 동작하는 것을 확실히 한다. Kubelet은 쿠버네티스를 통해 생성되지 않는 컨테이너는 관리하지 않는다.</p>
<h3 id=kube-proxy>kube-proxy</h3>
<p>kube-proxy는 클러스터의 각
<a class=glossary-tooltip title="노드는 쿠버네티스의 작업 장비(worker machine)이다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/architecture/nodes/ target=_blank aria-label=노드>노드</a>에서
실행되는 네트워크 프록시로, 쿠버네티스의
<a class=glossary-tooltip title="네트워크 서비스로 파드 집합에서 실행 중인 애플리케이션을 노출하는 방법" data-toggle=tooltip data-placement=top href=/ko/docs/concepts/services-networking/service/ target=_blank aria-label=서비스>서비스</a> 개념의 구현부이다.</p>
<p><a href=/ko/docs/reference/command-line-tools-reference/kube-proxy/>kube-proxy</a>는
노드의 네트워크 규칙을 유지 관리한다. 이 네트워크 규칙이 내부 네트워크
세션이나 클러스터 바깥에서 파드로 네트워크 통신을
할 수 있도록 해준다.</p>
<p>kube-proxy는 운영 체제에 가용한 패킷
필터링 계층이 있는 경우, 이를 사용한다. 그렇지 않으면, kube-proxy는 트래픽 자체를 포워드(forward)한다.</p>
<h3 id=컨테이너-런타임>컨테이너 런타임</h3>
<p>컨테이너 런타임은 컨테이너 실행을 담당하는 소프트웨어이다.</p>
<p>쿠버네티스는 <a class=glossary-tooltip title="A container runtime with an emphasis on simplicity, robustness and portability" data-toggle=tooltip data-placement=top href=https://containerd.io/docs/ target=_blank aria-label=containerd>containerd</a>,
<a class=glossary-tooltip title="A lightweight container runtime specifically for Kubernetes" data-toggle=tooltip data-placement=top href=https://cri-o.io/#what-is-cri-o target=_blank aria-label=CRI-O>CRI-O</a>와 같은 컨테이너 런타임 및
모든 <a href=https://github.com/kubernetes/community/blob/master/contributors/devel/sig-node/container-runtime-interface.md>Kubernetes CRI (컨테이너 런타임 인터페이스)</a>
구현체를 지원한다.</p>
<h2 id=애드온>애드온</h2>
<p>애드온은 쿠버네티스 리소스(<a class=glossary-tooltip title="파드의 복제본을 클러스터 노드 집합에서 동작하게 한다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/controllers/daemonset target=_blank aria-label=데몬셋>데몬셋</a>,
<a class=glossary-tooltip title="클러스터에서 복제된 애플리케이션을 관리한다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/controllers/deployment/ target=_blank aria-label=디플로이먼트>디플로이먼트</a> 등)를
이용하여 클러스터 기능을 구현한다. 이들은 클러스터 단위의 기능을 제공하기 때문에
애드온에 대한 네임스페이스 리소스는 <code>kube-system</code> 네임스페이스에 속한다.</p>
<p>선택된 일부 애드온은 아래에 설명하였고, 사용 가능한 전체 확장 애드온 리스트는
<a href=/ko/docs/concepts/cluster-administration/addons/>애드온</a>을 참조한다.</p>
<h3 id=dns>DNS</h3>
<p>여타 애드온들이 절대적으로 요구되지 않지만, 많은 예시에서 필요로 하기 때문에 모든 쿠버네티스 클러스터는 <a href=/ko/docs/concepts/services-networking/dns-pod-service/>클러스터 DNS</a>를 갖추어야만 한다.</p>
<p>클러스터 DNS는 구성환경 내 다른 DNS 서버와 더불어, 쿠버네티스 서비스를 위해 DNS 레코드를 제공해주는 DNS 서버다.</p>
<p>쿠버네티스에 의해 구동되는 컨테이너는 DNS 검색에서 이 DNS 서버를 자동으로 포함한다.</p>
<h3 id=웹-ui-대시보드>웹 UI (대시보드)</h3>
<p><a href=/ko/docs/tasks/access-application-cluster/web-ui-dashboard/>대시보드</a>는 쿠버네티스 클러스터를 위한 범용의 웹 기반 UI다. 사용자가 클러스터 자체뿐만 아니라, 클러스터에서 동작하는 애플리케이션에 대한 관리와 문제 해결을 할 수 있도록 해준다.</p>
<h3 id=컨테이너-리소스-모니터링>컨테이너 리소스 모니터링</h3>
<p><a href=/ko/docs/tasks/debug-application-cluster/resource-usage-monitoring/>컨테이너 리소스 모니터링</a>은
중앙 데이터베이스 내의 컨테이너들에 대한 포괄적인 시계열 매트릭스를 기록하고 그 데이터를 열람하기 위한 UI를 제공해 준다.</p>
<h3 id=클러스터-레벨-로깅>클러스터-레벨 로깅</h3>
<p><a href=/ko/docs/concepts/cluster-administration/logging/>클러스터-레벨 로깅</a> 메커니즘은
검색/열람 인터페이스와 함께 중앙 로그 저장소에 컨테이너 로그를 저장하는 책임을 진다.</p>
<h2 id=다음-내용>다음 내용</h2>
<ul>
<li><a href=/ko/docs/concepts/architecture/nodes/>노드</a>에 대해 더 배우기</li>
<li><a href=/ko/docs/concepts/architecture/controller/>컨트롤러</a>에 대해 더 배우기</li>
<li><a href=/ko/docs/concepts/scheduling-eviction/kube-scheduler/>kube-scheduler</a>에 대해 더 배우기</li>
<li>etcd의 공식 <a href=https://etcd.io/docs/>문서</a> 읽기</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-0c745f42e623d2b70a53bc0e6db73d95>1.3 - 쿠버네티스 API</h1>
<div class=lead>쿠버네티스 API를 사용하면 쿠버네티스 오브젝트들의 상태를 쿼리하고 조작할 수 있다. 쿠버네티스 컨트롤 플레인의 핵심은 API 서버와 그것이 노출하는 HTTP API이다. 사용자와 클러스터의 다른 부분 및 모든 외부 컴포넌트는 API 서버를 통해 서로 통신한다.</div>
<p>쿠버네티스 <a class=glossary-tooltip title="컨테이너의 라이프사이클을 정의, 배포, 관리하기 위한 API와 인터페이스들을 노출하는 컨테이너 오케스트레이션 레이어." data-toggle=tooltip data-placement=top href="/ko/docs/reference/glossary/?all=true#term-control-plane" target=_blank aria-label="컨트롤 플레인">컨트롤 플레인</a>의 핵심은
<a class=glossary-tooltip title="쿠버네티스 API를 제공하는 컨트롤 플레인 컴포넌트." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/overview/components/#kube-apiserver target=_blank aria-label="API 서버">API 서버</a>이다. API 서버는
최종 사용자, 클러스터의 다른 부분 그리고 외부 컴포넌트가 서로 통신할
수 있도록 HTTP API를 제공한다.</p>
<p>쿠버네티스 API를 사용하면 쿠버네티스의 API 오브젝트(예:
파드(Pod), 네임스페이스(Namespace), 컨피그맵(ConfigMap) 그리고 이벤트(Event))를 질의(query)하고 조작할 수 있다.</p>
<p>대부분의 작업은 <a href=/ko/docs/reference/kubectl/overview/>kubectl</a>
커맨드 라인 인터페이스 또는 API를 사용하는
<a href=/ko/docs/reference/setup-tools/kubeadm/>kubeadm</a>과
같은 다른 커맨드 라인 도구를 통해 수행할 수 있다.
그러나, REST 호출을 사용하여 API에 직접 접근할 수도 있다.</p>
<p>쿠버네티스 API를 사용하여 애플리케이션을 작성하는 경우
<a href=/ko/docs/reference/using-api/client-libraries/>클라이언트 라이브러리</a> 중 하나를 사용하는 것이 좋다.</p>
<h2 id=api-specification>OpenAPI 명세</h2>
<p>완전한 API 상세 내용은 <a href=https://www.openapis.org/>OpenAPI</a>를 활용해서 문서화했다.</p>
<h3 id=openapi-v2>OpenAPI V2</h3>
<p>쿠버네티스 API 서버는 <code>/openapi/v2</code> 엔드포인트를 통해
통합된(aggregated) OpenAPI v2 스펙을 제공한다.
요청 헤더에 다음과 같이 기재하여 응답 형식을 지정할 수 있다.</p>
<table>
<caption style=display:none> OpenAPI v2 질의에 사용할 수 있는 유효한 요청 헤더 값</caption>
<thead>
<tr>
<th>헤더</th>
<th style=min-width:50%>사용할 수 있는 값</th>
<th>참고</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Accept-Encoding</code></td>
<td><code>gzip</code></td>
<td><em>이 헤더를 제공하지 않는 것도 가능</em></td>
</tr>
<tr>
<td rowspan=3><code>Accept</code></td>
<td><code>application/com.github.proto-openapi.spec.v2@v1.0+protobuf</code></td>
<td><em>주로 클러스터 내부 용도로 사용</em></td>
</tr>
<tr>
<td><code>application/json</code></td>
<td><em>기본값</em></td>
</tr>
<tr>
<td><code>*</code></td>
<td><code>JSON으로 응답</em></td>
</tr>
</tbody>
</table>
<p>쿠버네티스는 주로 클러스터 내부 통신을 위해 대안적인
Protobuf에 기반한 직렬화 형식을 구현한다. 이 형식에 대한
자세한 내용은 <a href=https://github.com/kubernetes/community/blob/master/contributors/design-proposals/api-machinery/protobuf.md>쿠버네티스 Protobuf 직렬화</a> 디자인 제안과
API 오브젝트를 정의하는 Go 패키지에 들어있는 각각의 스키마에 대한
IDL(인터페이스 정의 언어) 파일을 참고한다.</p>
<h3 id=openapi-v3>OpenAPI V3</h3>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.23 [alpha]</code>
</div>
<p>쿠버네티스 v1.23은 OpenAPI v3 API 발행(publishing)에 대한 초기 지원을 제공한다.
이는 알파 기능이며 기본적으로 비활성화되어 있다.
kube-apiserver 구성 요소에
<code>OpenAPIV3</code> <a href=/ko/docs/reference/command-line-tools-reference/feature-gates/>기능 게이트</a>를 이용하여
이 알파 기능을 활성화할 수 있다.</p>
<p>이 기능이 활성화되면, 쿠버네티스 API 서버는
통합된(aggregated) OpenAPI v3 스펙을 쿠버네티스 그룹 버전별로
<code>/openapi/v3/apis/&lt;group>/&lt;version></code> 엔드포인트에 제공한다.
사용할 수 있는 요청 헤더는 아래의 표를 참고한다.</p>
<table>
<caption style=display:none> OpenAPI v3 질의에 사용할 수 있는 유효한 요청 헤더 값</caption>
<thead>
<tr>
<th>헤더</th>
<th style=min-width:50%>사용할 수 있는 값</th>
<th>참고</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Accept-Encoding</code></td>
<td><code>gzip</code></td>
<td><em>이 헤더를 제공하지 않는 것도 가능</em></td>
</tr>
<tr>
<td rowspan=3><code>Accept</code></td>
<td><code>application/com.github.proto-openapi.spec.v3@v1.0+protobuf</code></td>
<td><em>주로 클러스터 내부 용도로 사용</em></td>
</tr>
<tr>
<td><code>application/json</code></td>
<td><em>기본값</em></td>
</tr>
<tr>
<td><code>*</code></td>
<td><code>JSON으로 응답</em></td>
</tr>
</tbody>
</table>
<p><code>/openapi/v3</code> 디스커버리 엔드포인트는 사용 가능한 모든
그룹/버전의 목록을 제공한다. 이 엔드포인트는 JSON 만을 반환한다.</p>
<h2 id=지속성>지속성</h2>
<p>쿠버네티스는 오브젝트의 직렬화된 상태를
<a class=glossary-tooltip title="모든 클러스터 데이터를 담는 쿠버네티스 뒷단의 저장소로 사용되는 일관성·고가용성 키-값 저장소." data-toggle=tooltip data-placement=top href=/docs/tasks/administer-cluster/configure-upgrade-etcd/ target=_blank aria-label=etcd>etcd</a>에 기록하여 저장한다.</p>
<h2 id=api-그룹과-버전-규칙>API 그룹과 버전 규칙</h2>
<p>필드를 쉽게 제거하거나 리소스 표현을 재구성하기 위해,
쿠버네티스는 각각 <code>/api/v1</code> 또는 <code>/apis/rbac.authorization.k8s.io/v1alpha1</code> 과
같은 서로 다른 API 경로에서 여러 API 버전을 지원한다.</p>
<p>버전 규칙은 리소스나 필드 수준이 아닌 API 수준에서 수행되어
API가 시스템 리소스 및 동작에 대한 명확하고 일관된 보기를 제공하고
수명 종료 및/또는 실험적 API에 대한 접근을
제어할 수 있도록 한다.</p>
<p>보다 쉽게 발전하고 API를 확장하기 위해, 쿠버네티스는
<a href=/ko/docs/reference/using-api/#api-%EA%B7%B8%EB%A3%B9-%ED%99%9C%EC%84%B1%ED%99%94-%EB%98%90%EB%8A%94-%EB%B9%84%ED%99%9C%EC%84%B1%ED%99%94>활성화 또는 비활성화</a>가
가능한 <a href=/ko/docs/reference/using-api/#api-%EA%B7%B8%EB%A3%B9>API 그룹</a>을 구현한다.</p>
<p>API 리소스는 API 그룹, 리소스 유형, 네임스페이스
(네임스페이스 리소스용) 및 이름으로 구분된다. API 서버는 API 버전 간의
변환을 투명하게 처리한다. 서로 다른 모든 버전은 실제로
동일한 지속 데이터의 표현이다. API 서버는 여러 API 버전을 통해
동일한 기본 데이터를 제공할 수 있다.</p>
<p>예를 들어, 동일한 리소스에 대해 <code>v1</code> 과 <code>v1beta1</code> 이라는 두 가지 API 버전이
있다고 가정한다. 원래 API의 <code>v1beta1</code> 버전을 사용하여 오브젝트를
만든 경우, 나중에 <code>v1beta1</code> 또는 <code>v1</code> API 버전을 사용하여 해당 오브젝트를
읽거나, 업데이트하거나, 삭제할 수 있다.</p>
<h2 id=api-변경-사항>API 변경 사항</h2>
<p>성공적인 시스템은 새로운 유스케이스가 등장하거나 기존 사례가 변경됨에 따라 성장하고 변화해야 한다.
따라서, 쿠버네티스는 쿠버네티스 API가 지속적으로 변경되고 성장할 수 있도록 설계했다.
쿠버네티스 프로젝트는 기존 클라이언트와의 호환성을 깨지 <em>않고</em> 다른 프로젝트가
적응할 기회를 가질 수 있도록 장기간 해당 호환성을 유지하는 것을 목표로 한다.</p>
<p>일반적으로, 새 API 리소스와 새 리소스 필드는 자주 추가될 수 있다.
리소스 또는 필드를 제거하려면
<a href=/docs/reference/using-api/deprecation-policy/>API 지원 중단 정책</a>을 따라야 한다.</p>
<p>쿠버네티스는 일반적으로 API 버전 <code>v1</code> 에서 안정 버전(GA)에 도달하면, 공식 쿠버네티스 API에
대한 호환성 유지를 강력하게 이행한다. 또한,
쿠버네티스는 가능한 경우 <em>베타</em> API 버전에서도 호환성을 유지한다.
베타 API를 채택하면 기능이 안정된 후에도 해당 API를 사용하여 클러스터와
계속 상호 작용할 수 있다.</p>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> 쿠버네티스는 또한 <em>알파</em> API 버전에 대한 호환성을 유지하는 것을 목표로 하지만, 일부
상황에서는 호환성이 깨진다. 알파 API 버전을 사용하는 경우, API가 변경된 경우 클러스터를
업그레이드할 때 쿠버네티스에 대한 릴리스 정보를 확인한다.
</div>
<p>API 버전 수준 정의에 대한 자세한 내용은
<a href=/ko/docs/reference/using-api/#api-%EB%B2%84%EC%A0%84-%EA%B7%9C%EC%B9%99>API 버전 레퍼런스</a>를 참조한다.</p>
<h2 id=api-확장>API 확장</h2>
<p>쿠버네티스 API는 다음 두 가지 방법 중 하나로 확장할 수 있다.</p>
<ol>
<li><a href=/ko/docs/concepts/extend-kubernetes/api-extension/custom-resources/>커스텀 리소스</a>를
사용하면 API 서버가 선택한 리소스 API를 제공하는 방법을 선언적으로 정의할 수 있다.</li>
<li><a href=/ko/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/>애그리게이션 레이어(aggregation layer)</a>를
구현하여 쿠버네티스 API를 확장할 수도 있다.</li>
</ol>
<h2 id=다음-내용>다음 내용</h2>
<ul>
<li>자체 <a href=/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/>CustomResourceDefinition</a>을
추가하여 쿠버네티스 API를 확장하는 방법에 대해 배우기.</li>
<li><a href=/ko/docs/concepts/security/controlling-access/>쿠버네티스 API 접근 제어하기</a>는
클러스터가 API 접근을 위한 인증 및 권한을 관리하는 방법을 설명한다.</li>
<li><a href=/docs/reference/kubernetes-api/>API 레퍼런스</a>를
읽고 API 엔드포인트, 리소스 유형 및 샘플에 대해 배우기.</li>
<li><a href=https://git.k8s.io/community/contributors/devel/sig-architecture/api_changes.md#readme>API 변경 사항</a>에서
호환 가능한 변경 사항을 구성하고, API를 변경하는 방법에 대해 알아본다.</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-110f33530cf761140cb1dab536baef04>1.4 - 쿠버네티스 오브젝트로 작업하기</h1>
<div class=lead>쿠버네티스 오브젝트는 쿠버네티스 시스템의 영구 엔티티이다. 쿠버네티스는 이러한 엔티티들을 사용하여 클러스터의 상태를 나타낸다. 쿠버네티스 오브젝트 모델과 쿠버네티스 오브젝트를 사용하는 방법에 대해 학습한다.</div>
</div>
<div class=td-content>
<h1 id=pg-9f5adfa77f48c50d5cc81155a3cecb98>1.4.1 - 쿠버네티스 오브젝트 이해하기</h1>
<p>이 페이지에서는 쿠버네티스 오브젝트가 쿠버네티스 API에서 어떻게 표현되고, 그 오브젝트를 어떻게 <code>.yaml</code> 형식으로 표현할 수 있는지에 대해 설명한다.</p>
<h2 id=kubernetes-objects>쿠버네티스 오브젝트 이해하기</h2>
<p><em>쿠버네티스 오브젝트</em> 는 쿠버네티스 시스템에서 영속성을 가지는 오브젝트이다. 쿠버네티스는 클러스터의 상태를 나타내기 위해 이 오브젝트를 이용한다. 구체적으로 말하자면, 다음같이 기술할 수 있다.</p>
<ul>
<li>어떤 컨테이너화된 애플리케이션이 동작 중인지 (그리고 어느 노드에서 동작 중인지)</li>
<li>그 애플리케이션이 이용할 수 있는 리소스</li>
<li>그 애플리케이션이 어떻게 재구동 정책, 업그레이드, 그리고 내고장성과 같은 것에 동작해야 하는지에 대한 정책</li>
</ul>
<p>쿠버네티스 오브젝트는 하나의 "의도를 담은 레코드"이다. 오브젝트를 생성하게 되면, 쿠버네티스 시스템은 그 오브젝트 생성을 보장하기 위해 지속적으로 작동할 것이다. 오브젝트를 생성함으로써, 여러분이 클러스터의 워크로드를 어떤 형태로 보이고자 하는지에 대해 효과적으로 쿠버네티스 시스템에 전한다. 이것이 바로 여러분의 클러스터에 대해 <em>의도한 상태</em> 가 된다.</p>
<p>생성이든, 수정이든, 또는 삭제든 쿠버네티스 오브젝트를 동작시키려면, <a href=/ko/docs/concepts/overview/kubernetes-api/>쿠버네티스 API</a>를 이용해야 한다. 예를 들어, <code>kubectl</code> 커맨드-라인 인터페이스를 이용할 때, CLI는 여러분 대신 필요한 쿠버네티스 API를 호출해 준다. 또한, 여러분은 <a href=/ko/docs/reference/using-api/client-libraries/>클라이언트 라이브러리</a> 중 하나를 이용하여 여러분만의 프로그램에서 쿠버네티스 API를 직접 이용할 수도 있다.</p>
<h3 id=오브젝트-명세-spec-와-상태-status>오브젝트 명세(spec)와 상태(status)</h3>
<p>거의 모든 쿠버네티스 오브젝트는 오브젝트의 구성을 결정해주는
두 개의 중첩된 오브젝트 필드를 포함하는데 오브젝트 <em><code>spec</code></em> 과 오브젝트 <em><code>status</code></em> 이다.
<code>spec</code>을 가진 오브젝트는 오브젝트를 생성할 때 리소스에
원하는 특징(<em>의도한 상태</em>)에 대한 설명을
제공해서 설정한다.</p>
<p><code>status</code> 는 쿠버네티스 시스템과 컴포넌트에 의해 제공되고
업데이트된 오브젝트의 <em>현재 상태</em> 를 설명한다. 쿠버네티스
<a class=glossary-tooltip title="컨테이너의 라이프사이클을 정의, 배포, 관리하기 위한 API와 인터페이스들을 노출하는 컨테이너 오케스트레이션 레이어." data-toggle=tooltip data-placement=top href="/ko/docs/reference/glossary/?all=true#term-control-plane" target=_blank aria-label="컨트롤 플레인">컨트롤 플레인</a>은 모든 오브젝트의
실제 상태를 사용자가 의도한 상태와 일치시키기 위해 끊임없이 그리고
능동적으로 관리한다.</p>
<p>예를 들어, 쿠버네티스 디플로이먼트는 클러스터에서 동작하는 애플리케이션을
표현해줄 수 있는 오브젝트이다. 디플로이먼트를 생성할 때, 디플로이먼트
spec에 3개의 애플리케이션 레플리카가 동작되도록
설정할 수 있다. 쿠버네티스 시스템은 그 디플로이먼트 spec을 읽어
spec에 일치되도록 상태를 업데이트하여 3개의 의도한
애플리케이션 인스턴스를 구동시킨다. 만약, 그 인스턴스들 중 어느 하나가
어떤 문제로 인해 멈춘다면(상태 변화 발생), 쿠버네티스 시스템은 보정(이
경우에는 대체 인스턴스를 시작하여)을 통해
spec과 status간의 차이에 대응한다.</p>
<p>오브젝트 명세, 상태, 그리고 메타데이터에 대한 추가 정보는, <a href=https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md>Kubernetes API Conventions</a> 를 참조한다.</p>
<h3 id=쿠버네티스-오브젝트-기술하기>쿠버네티스 오브젝트 기술하기</h3>
<p>쿠버네티스에서 오브젝트를 생성할 때, (이름과 같은)오브젝트에 대한 기본적인 정보와 더불어, 의도한 상태를 기술한 오브젝트 spec을 제시해 줘야만 한다. 오브젝트를 생성하기 위해(직접이든 또는 <code>kubectl</code>을 통해서든) 쿠버네티스 API를 이용할 때, API 요청은 요청 내용 안에 JSON 형식으로 정보를 포함시켜 줘야만 한다. <strong>대부분의 경우 정보를 .yaml 파일로 <code>kubectl</code>에 제공한다.</strong> <code>kubectl</code>은 API 요청이 이루어질 때, JSON 형식으로 정보를 변환시켜 준다.</p>
<p>여기 쿠버네티스 디플로이먼트를 위한 필수 필드와 오브젝트 spec을 보여주는 <code>.yaml</code> 파일 예시가 있다.</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/ko/examples/application/deployment.yaml download=application/deployment.yaml><code>application/deployment.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('application-deployment-yaml')" title="Copy application/deployment.yaml to clipboard">
</img>
</div>
<div class=includecode id=application-deployment-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-deployment<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>2</span><span style=color:#bbb> </span><span style=color:#080;font-style:italic># tells deployment to run 2 pods matching the template</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.14.2<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>위 예시와 같이 .yaml 파일을 이용하여 디플로이먼트를 생성하기 위한 하나의 방식으로는
<code>kubectl</code> 커맨드-라인 인터페이스에 인자값으로 <code>.yaml</code> 파일을 건네
<a href=/docs/reference/generated/kubectl/kubectl-commands#apply><code>kubectl apply</code></a> 커맨드를 이용하는 것이다. 다음 예시와 같다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/application/deployment.yaml --record
</code></pre></div><p>그 출력 내용은 다음과 유사하다.</p>
<pre><code>deployment.apps/nginx-deployment created
</code></pre><h3 id=요구되는-필드>요구되는 필드</h3>
<p>생성하고자 하는 쿠버네티스 오브젝트에 대한 <code>.yaml</code> 파일 내, 다음 필드를 위한 값들을 설정해 줘야한다.</p>
<ul>
<li><code>apiVersion</code> - 이 오브젝트를 생성하기 위해 사용하고 있는 쿠버네티스 API 버전이 어떤 것인지</li>
<li><code>kind</code> - 어떤 종류의 오브젝트를 생성하고자 하는지</li>
<li><code>metadata</code> - <code>이름</code> 문자열, <code>UID</code>, 그리고 선택적인 <code>네임스페이스</code>를 포함하여 오브젝트를 유일하게 구분지어 줄 데이터</li>
<li><code>spec</code> - 오브젝트에 대해 어떤 상태를 의도하는지</li>
</ul>
<p>오브젝트 <code>spec</code>에 대한 정확한 포맷은 모든 쿠버네티스 오브젝트마다 다르고, 그 오브젝트 특유의 중첩된 필드를 포함한다. <a href=/docs/reference/generated/kubernetes-api/v1.23/>쿠버네티스 API 레퍼런스</a> 는 쿠버네티스를 이용하여 생성할 수 있는 오브젝트에 대한 모든 spec 포맷을 살펴볼 수 있도록 해준다.</p>
<p>예를 들어, API 내 파드에 대한 상세 정보는 <a href=/docs/reference/kubernetes-api/workload-resources/pod-v1/#PodSpec><code>spec</code> 필드</a>에 대한 레퍼런스에서,
디플로이먼트에 대한 상세 정보는 <a href=/docs/reference/kubernetes-api/workload-resources/deployment-v1/#DeploymentSpec><code>spec</code> 필드</a>에 대한 레퍼런스에서 확인할 수 있다.
해당 API 레퍼런스 페이지에서 PodSpec과 DeploymentSpec에 대해 언급된 내용을 볼 수 있다. 이 이름들은 쿠버네티스가 API를 구현하는데 사용한 Go 언어 코드 구현의 세부 내용이다.</p>
<h2 id=다음-내용>다음 내용</h2>
<ul>
<li><a href=/ko/docs/concepts/workloads/pods/>파드</a>와 같이, 가장 중요하고 기본적인 쿠버네티스 오브젝트에 대해 배운다.</li>
<li>쿠버네티스의 <a href=/ko/docs/concepts/architecture/controller/>컨트롤러</a>에 대해 배운다.</li>
<li>API 개념의 더 많은 설명은 <a href=/ko/docs/reference/using-api/>쿠버네티스 API 사용</a>을 본다.</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-6751db8ff5409476de8225d17d6c42dd>1.4.2 - 쿠버네티스 오브젝트 관리</h1>
<p><code>kubectl</code> 커맨드라인 툴은 쿠버네티스 오브젝트를 생성하고 관리하기 위한
몇 가지 상이한 방법을 지원한다. 이 문서는 여러가지 접근법에 대한 개요를
제공한다. Kubectl로 오브젝트 관리하기에 대한 자세한 설명은
<a href=https://kubectl.docs.kubernetes.io>Kubectl 서적</a>에서 확인한다.</p>
<h2 id=관리-기법>관리 기법</h2>
<div class="alert alert-danger warning callout" role=alert>
<strong>경고:</strong> 쿠버네티스 오브젝트는 하나의 기법만 사용하여 관리해야 한다. 동일한 오브젝트에
대해 여러 기법을 혼용하는 것은 예상치 못한 동작을 초래하게 된다.
</div>
<table>
<thead>
<tr>
<th>관리기법</th>
<th>대상</th>
<th>권장 환경</th>
<th>지원하는 작업자 수</th>
<th>학습 난이도</th>
</tr>
</thead>
<tbody>
<tr>
<td>명령형 커맨드</td>
<td>활성 오브젝트</td>
<td>개발 환경</td>
<td>1+</td>
<td>낮음</td>
</tr>
<tr>
<td>명령형 오브젝트 구성</td>
<td>개별 파일</td>
<td>프로덕션 환경</td>
<td>1</td>
<td>보통</td>
</tr>
<tr>
<td>선언형 오브젝트 구성</td>
<td>파일이 있는 디렉터리</td>
<td>프로덕션 환경</td>
<td>1+</td>
<td>높음</td>
</tr>
</tbody>
</table>
<h2 id=명령형-커맨드>명령형 커맨드</h2>
<p>명령형 커맨드를 사용할 경우, 사용자는 클러스터 내 활성 오브젝트를 대상으로
직접 동작시킨다. 사용자는 실행할 작업을 인수 또는 플래그로 <code>kubectl</code> 커맨드에
지정한다.</p>
<p>이것은 클러스터에서 일회성 작업을 개시시키거나 동작시키기 위한
추천 방법이다. 이 기법은 활성 오브젝트를 대상으로 직접적인
영향을 미치기 때문에, 이전 구성에 대한 이력을 제공해 주지 않는다.</p>
<h3 id=예시>예시</h3>
<p>디플로이먼트 오브젝트를 생성하여 nginx 컨테이너의 인스턴스를 구동시킨다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>kubectl create deployment nginx --image nginx
</code></pre></div><h3 id=트레이드-오프>트레이드 오프</h3>
<p>오브젝트 구성에 비해 장점은 다음과 같다.</p>
<ul>
<li>커맨드는 하나의 동작을 나타내는 단어로 표현된다.</li>
<li>커맨드는 클러스터를 수정하기 위해 단 하나의 단계만을 필요로 한다.</li>
</ul>
<p>오브젝트 구성에 비해 단점은 다음과 같다.</p>
<ul>
<li>커맨드는 변경 검토 프로세스와 통합되지 않는다.</li>
<li>커맨드는 변경에 관한 감사 추적(audit trail)을 제공하지 않는다.</li>
<li>커맨드는 활성 동작 중인 경우를 제외하고는 레코드의 소스를 제공하지 않는다.</li>
<li>커맨드는 새로운 오브젝트 생성을 위한 템플릿을 제공하지 않는다.</li>
</ul>
<h2 id=명령형-오브젝트-구성>명령형 오브젝트 구성</h2>
<p>명령형 오브젝트 구성에서는 kubectl 커맨드로 작업(생성, 교체 등),
선택적 플래그, 그리고 최소 하나의 파일 이름을 지정한다.
그 파일은 YAML 또는 JSON 형식으로 오브젝트의 완전한 정의를
포함해야만 한다.</p>
<p>오브젝트 정의에 대한 더 자세한 내용은 <a href=/docs/reference/generated/kubernetes-api/v1.23/>API 참조</a>를
참고한다.</p>
<div class="alert alert-danger warning callout" role=alert>
<strong>경고:</strong> 명령형 <code>replace</code> 커맨드는 기존 spec을 새로 제공된 spec으로 바꾸고
구성 파일에서 누락된 오브젝트의 모든 변경 사항을 삭제한다.
이 방법은 spec이 구성 파일과는 별개로 업데이트되는 리소스 유형에는
사용하지 말아야한다.
예를 들어 <code>LoadBalancer</code> 유형의 서비스는 클러스터의 구성과 별도로
<code>externalIPs</code> 필드가 업데이트된다.
</div>
<h3 id=예시-1>예시</h3>
<p>구성 파일에 정의된 오브젝트를 생성한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>kubectl create -f nginx.yaml
</code></pre></div><p>두 개의 구성 파일에 정의된 오브젝트를 삭제한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>kubectl delete -f nginx.yaml -f redis.yaml
</code></pre></div><p>활성 동작하는 구성을 덮어씀으로써 구성 파일에 정의된 오브젝트를
업데이트한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>kubectl replace -f nginx.yaml
</code></pre></div><h3 id=트레이드-오프-1>트레이드 오프</h3>
<p>명령형 커맨드에 비해 장점은 다음과 같다.</p>
<ul>
<li>오브젝트 구성은 Git과 같은 소스 컨트롤 시스템에 보관할 수 있다.</li>
<li>오브젝트 구성은 푸시와 감사 추적 전에 변경사항을 검토하는 것과 같은 프로세스들과 통합할 수 있다.</li>
<li>오브젝트 구성은 새로운 오브젝트 생성을 위한 템플릿을 제공한다.</li>
</ul>
<p>명령형 커맨드에 비해 단점은 다음과 같다.</p>
<ul>
<li>오브젝트 구성은 오브젝트 스키마에 대한 기본적인 이해를 필요로 한다.</li>
<li>오브젝트 구성은 YAML 파일을 기록하는 추가적인 과정을 필요로 한다.</li>
</ul>
<p>선언형 오브젝트 구성에 비해 장점은 다음과 같다.</p>
<ul>
<li>명령형 오브젝트 구성의 동작은 보다 간결하고 이해하기 쉽다.</li>
<li>쿠버네티스 버전 1.5 부터는 더 성숙한 명령형 오브젝트 구성을 제공한다.</li>
</ul>
<p>선언형 오브젝트 구성에 비해 단점은 다음과 같다.</p>
<ul>
<li>명령형 오브젝트 구성은 디렉터리가 아닌, 파일에 가장 적합하다.</li>
<li>활성 오브젝트에 대한 업데이트는 구성 파일에 반영되어야 한다. 그렇지 않으면 다음 교체 중에 손실된다.</li>
</ul>
<h2 id=선언형-오브젝트-구성>선언형 오브젝트 구성</h2>
<p>선언형 오브젝트 구성을 사용할 경우, 사용자는 로컬에 보관된 오브젝트
구성 파일을 대상으로 작동시키지만, 사용자는 파일에서 수행 할
작업을 정의하지 않는다. 생성, 업데이트, 그리고 삭제 작업은
<code>kubectl</code>에 의해 오브젝트마다 자동으로 감지된다. 이를 통해 다른 오브젝트에 대해
다른 조작이 필요할 수 있는 디렉터리에서 작업할 수 있다.</p>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> 선언형 오브젝트 구성은 변경 사항이 오브젝트 구성 파일에
다시 병합되지 않더라도 다른 작성자가 작성한 변경 사항을 유지한다.
이것은 전체 오브젝트 구성 변경을 위한 <code>replace</code> API를
사용하는 대신, <code>patch</code> API를 사용하여 인지되는 차이만
작성하기 때문에 가능하다.
</div>
<h3 id=예시-2>예시</h3>
<p><code>configs</code> 디렉터리 내 모든 오브젝트 구성 파일을 처리하고 활성 오브젝트를
생성 또는 패치한다. 먼저 어떠한 변경이 이루어지게 될지 알아보기 위해 <code>diff</code>
하고 나서 적용할 수 있다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>kubectl diff -f configs/
kubectl apply -f configs/
</code></pre></div><p>재귀적으로 디렉터리를 처리한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>kubectl diff -R -f configs/
kubectl apply -R -f configs/
</code></pre></div><h3 id=트레이드-오프-2>트레이드 오프</h3>
<p>명령형 오브젝트 구성에 비해 장점은 다음과 같다.</p>
<ul>
<li>활성 오브젝트에 직접 작성된 변경 사항은 구성 파일로 다시 병합되지 않더라도 유지된다.</li>
<li>선언형 오브젝트 구성은 디렉터리에서의 작업 및 오브젝트 별 작업 유형(생성, 패치, 삭제)의 자동 감지에 더 나은 지원을 제공한다.</li>
</ul>
<p>명령형 오브젝트 구성에 비해 단점은 다음과 같다.</p>
<ul>
<li>선언형 오브젝트 구성은 예상치 못한 결과를 디버깅하고 이해하기가 더 어렵다.</li>
<li>diff를 사용한 부분 업데이트는 복잡한 병합 및 패치 작업을 일으킨다.</li>
</ul>
<h2 id=다음-내용>다음 내용</h2>
<ul>
<li><a href=/ko/docs/tasks/manage-kubernetes-objects/imperative-command/>명령형 커맨드를 이용한 쿠버네티스 오브젝트 관리하기</a></li>
<li><a href=/ko/docs/tasks/manage-kubernetes-objects/imperative-config/>오브젝트 구성을 이용한 쿠버네티스 오브젝트 관리하기(명령형)</a></li>
<li><a href=/ko/docs/tasks/manage-kubernetes-objects/declarative-config/>오브젝트 구성을 이용한 쿠버네티스 오브젝트 관리하기(선언형)</a></li>
<li><a href=/ko/docs/tasks/manage-kubernetes-objects/kustomization/>Kustomize를 사용한 쿠버네티스 오브젝트 관리하기(선언형)</a></li>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands/>Kubectl 커맨드 참조</a></li>
<li><a href=https://kubectl.docs.kubernetes.io>Kubectl 서적</a></li>
<li><a href=/docs/reference/generated/kubernetes-api/v1.23/>쿠버네티스 API 참조</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-f37749a83c2916b63279ea60f3cfe53e>1.4.3 - 오브젝트 이름과 ID</h1>
<p>클러스터의 각 오브젝트는 해당 유형의 리소스에 대하여 고유한 <a href=#names><em>이름</em></a> 을 가지고 있다.
또한, 모든 쿠버네티스 오브젝트는 전체 클러스터에 걸쳐 고유한 <a href=#uids><em>UID</em></a> 를 가지고 있다.</p>
<p>예를 들어, 이름이 <code>myapp-1234</code>인 파드는 동일한 <a href=/ko/docs/concepts/overview/working-with-objects/namespaces/>네임스페이스</a> 내에서 하나만 존재할 수 있지만, 이름이 <code>myapp-1234</code>인 파드와 디플로이먼트는 각각 존재할 수 있다.</p>
<p>유일하지 않은 사용자 제공 속성의 경우 쿠버네티스는 <a href=/ko/docs/concepts/overview/working-with-objects/labels/>레이블</a>과 <a href=/ko/docs/concepts/overview/working-with-objects/annotations/>어노테이션</a>을 제공한다.</p>
<h2 id=names>이름</h2>
<p><code>/api/v1/pods/some-name</code>과 같이, 리소스 URL에서 오브젝트를 가리키는 클라이언트 제공 문자열.</p>
<p>특정 시점에 같은 종류(kind) 내에서는 하나의 이름은 하나의 오브젝트에만 지정될 수 있다. 하지만, 오브젝트를 삭제한 경우, 삭제된 오브젝트와 같은 이름을 새로운 오브젝트에 지정 가능하다.</p>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> 물리적 호스트를 나타내는 노드와 같이 오브젝트가 물리적 엔티티를 나타내는 경우, 노드를 삭제한 후 다시 생성하지 않은 채 동일한 이름으로 호스트를 다시 생성하면, 쿠버네티스는 새 호스트를 불일치로 이어질 수 있는 이전 호스트로 취급한다.
</div>
<p>다음은 리소스에 일반적으로 사용되는 네 가지 유형의 이름 제한 조건이다.</p>
<h3 id=dns-서브도메인-이름>DNS 서브도메인 이름</h3>
<p>대부분의 리소스 유형에는 <a href=https://tools.ietf.org/html/rfc1123>RFC 1123</a>에 정의된 대로
DNS 서브도메인 이름으로 사용할 수 있는 이름이 필요하다.
이것은 이름이 다음을 충족해야 한다는 것을 의미한다.</p>
<ul>
<li>253자를 넘지 말아야 한다.</li>
<li>소문자와 영숫자 <code>-</code> 또는 <code>.</code> 만 포함한다.</li>
<li>영숫자로 시작한다.</li>
<li>영숫자로 끝난다.</li>
</ul>
<h3 id=dns-label-names>RFC 1123 레이블 이름</h3>
<p>일부 리소스 유형은 <a href=https://tools.ietf.org/html/rfc1123>RFC 1123</a>에
정의된 대로 DNS 레이블 표준을 따라야 한다.
이것은 이름이 다음을 충족해야 한다는 것을 의미한다.</p>
<ul>
<li>최대 63자이다.</li>
<li>소문자와 영숫자 또는 <code>-</code> 만 포함한다.</li>
<li>영숫자로 시작한다.</li>
<li>영숫자로 끝난다.</li>
</ul>
<h3 id=rfc-1035-레이블-이름>RFC 1035 레이블 이름</h3>
<p>몇몇 리소스 타입은 자신의 이름을 <a href=https://tools.ietf.org/html/rfc1035>RFC 1035</a>에
정의된 DNS 레이블 표준을 따르도록 요구한다.
이것은 이름이 다음을 만족해야 한다는 의미이다.</p>
<ul>
<li>최대 63개 문자를 포함</li>
<li>소문자 영숫자 또는 '-'만 포함</li>
<li>알파벳 문자로 시작</li>
<li>영숫자로 끝남</li>
</ul>
<h3 id=경로-세그먼트-이름>경로 세그먼트 이름</h3>
<p>일부 리소스 유형에서는 이름을 경로 세그먼트로 안전하게 인코딩 할 수
있어야 한다. 즉 이름이 "." 또는 ".."이 아닐 수 있으며 이름에는
"/" 또는 "%"가 포함될 수 없다.</p>
<p>아래는 파드의 이름이 <code>nginx-demo</code>라는 매니페스트 예시이다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-demo<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.14.2<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> 일부 리소스 유형은 이름에 추가적인 제약이 있다.
</div>
<h2 id=uids>UID</h2>
<p>오브젝트를 중복 없이 식별하기 위해 쿠버네티스 시스템이 생성하는 문자열.</p>
<p>쿠버네티스 클러스터가 구동되는 전체 시간에 걸쳐 생성되는 모든 오브젝트는 서로 구분되는 UID를 갖는다. 이는 기록상 유사한 오브젝트의 출현을 서로 구분하기 위함이다.</p>
<p>쿠버네티스 UID는 보편적으로 고유한 식별자이다(또는 UUID라고 한다).
UUID는 ISO/IEC 9834-8 과 ITU-T X.667 로 표준화 되어 있다.</p>
<h2 id=다음-내용>다음 내용</h2>
<ul>
<li>쿠버네티스의 <a href=/ko/docs/concepts/overview/working-with-objects/labels/>레이블</a>에 대해 읽기.</li>
<li><a href=https://git.k8s.io/community/contributors/design-proposals/architecture/identifiers.md>쿠버네티스의 식별자와 이름</a> 디자인 문서 읽기.</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-1127165f472b7181b9c1d5a0b187d620>1.4.4 - 네임스페이스</h1>
<p>쿠버네티스에서, <em>네임스페이스</em> 는 단일 클러스터 내에서의 리소스 그룹 격리 메커니즘을 제공한다. 리소스의 이름은 네임스페이스 내에서 유일해야 하며, 네임스페이스 간에서 유일할 필요는 없다. 네임스페이스 기반 스코핑은 네임스페이스 기반 오브젝트 <em>(예: 디플로이먼트, 서비스 등)</em> 에만 적용 가능하며 클러스터 범위의 오브젝트 <em>(예: 스토리지클래스, 노드, 퍼시스턴트볼륨 등)</em> 에는 적용 불가능하다.</p>
<h2 id=여러-개의-네임스페이스를-사용하는-경우>여러 개의 네임스페이스를 사용하는 경우</h2>
<p>네임스페이스는 여러 개의 팀이나, 프로젝트에 걸쳐서 많은 사용자가 있는 환경에서 사용하도록
만들어졌다. 사용자가 거의 없거나, 수 십명 정도가 되는 경우에는
네임스페이스를 전혀 고려할 필요가 없다.
네임스페이스가 제공하는 기능이 필요할 때 사용하도록 하자.</p>
<p>네임스페이스는 이름의 범위를 제공한다. 리소스의 이름은 네임스페이스 내에서 유일해야하지만,
네임스페이스를 통틀어서 유일할 필요는 없다. 네임스페이스는 서로 중첩될 수 없으며,
각 쿠버네티스 리소스는 하나의 네임스페이스에만 있을 수 있다.</p>
<p>네임스페이스는 클러스터 자원을 (<a href=/ko/docs/concepts/policy/resource-quotas/>리소스 쿼터</a>를 통해) 여러 사용자 사이에서 나누는 방법이다.</p>
<p>동일한 소프트웨어의 다른 버전과 같이 약간 다른 리소스를 분리하기 위해
여러 네임스페이스를 사용할 필요는 없다. 동일한 네임스페이스 내에서 리소스를
구별하기 위해 <a class=glossary-tooltip title="사용자에게 의미 있고 관련성 높은 특징으로 식별할 수 있도록 오브젝트에 태그를 붙인다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/overview/working-with-objects/labels target=_blank aria-label=레이블>레이블</a>을
사용한다.</p>
<h2 id=네임스페이스-다루기>네임스페이스 다루기</h2>
<p>네임스페이스의 생성과 삭제는
<a href=/docs/tasks/administer-cluster/namespaces/>네임스페이스 관리자 가이드 문서</a>에 기술되어 있다.</p>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> <code>kube-</code> 접두사로 시작하는 네임스페이스는 쿠버네티스 시스템용으로 예약되어 있으므로, 사용자는 이러한 네임스페이스를 생성하지 않는다.
</div>
<h3 id=네임스페이스-조회>네임스페이스 조회</h3>
<p>사용 중인 클러스터의 현재 네임스페이스를 나열할 수 있다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get namespace
</code></pre></div><pre><code>NAME              STATUS   AGE
default           Active   1d
kube-node-lease   Active   1d
kube-public       Active   1d
kube-system       Active   1d
</code></pre><p>쿠버네티스는 처음에 네 개의 초기 네임스페이스를 갖는다.</p>
<ul>
<li><code>default</code> 다른 네임스페이스가 없는 오브젝트를 위한 기본 네임스페이스</li>
<li><code>kube-system</code> 쿠버네티스 시스템에서 생성한 오브젝트를 위한 네임스페이스</li>
<li><code>kube-public</code> 이 네임스페이스는 자동으로 생성되며 모든 사용자(인증되지 않은 사용자 포함)가 읽기 권한으로 접근할 수 있다. 이 네임스페이스는 주로 전체 클러스터 중에 공개적으로 드러나서 읽을 수 있는 리소스를 위해 예약되어 있다. 이 네임스페이스의 공개적인 성격은 단지 관례이지 요구 사항은 아니다.</li>
<li><code>kube-node-lease</code> 이 네임스페이스는 각 노드와 연관된 <a href=/docs/reference/kubernetes-api/cluster-resources/lease-v1/>리스</a>
오브젝트를 갖는다. 노드 리스는 kubelet이 <a href=/ko/docs/concepts/architecture/nodes/#%ED%95%98%ED%8A%B8%EB%B9%84%ED%8A%B8>하트비트</a>를
보내서 컨트롤 플레인이 노드의 장애를 탐지할 수 있게 한다.</li>
</ul>
<h3 id=요청에-네임스페이스-설정하기>요청에 네임스페이스 설정하기</h3>
<p>현재 요청에 대한 네임스페이스를 설정하기 위해서 <code>--namespace</code> 플래그를 사용한다.</p>
<p>예를 들면,</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl run nginx --image<span style=color:#666>=</span>nginx --namespace<span style=color:#666>=</span>&lt;insert-namespace-name-here&gt;
kubectl get pods --namespace<span style=color:#666>=</span>&lt;insert-namespace-name-here&gt;
</code></pre></div><h3 id=선호하는-네임스페이스-설정하기>선호하는 네임스페이스 설정하기</h3>
<p>이후 모든 kubectl 명령에서 사용하는 네임스페이스를 컨텍스트에
영구적으로 저장할 수 있다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl config set-context --current --namespace<span style=color:#666>=</span>&lt;insert-namespace-name-here&gt;
<span style=color:#080;font-style:italic># 확인하기</span>
kubectl config view --minify | grep namespace:
</code></pre></div><h2 id=네임스페이스와-dns>네임스페이스와 DNS</h2>
<p><a href=/ko/docs/concepts/services-networking/service/>서비스</a>를 생성하면 해당
<a href=/ko/docs/concepts/services-networking/dns-pod-service/>DNS 엔트리</a>가 생성된다.
이 엔트리는 <code>&lt;서비스-이름>.&lt;네임스페이스-이름>.svc.cluster.local</code>의 형식을 갖는데,
이는 컨테이너가 <code>&lt;서비스-이름></code>만 사용하는 경우, 네임스페이스 내에 국한된 서비스로 연결된다.
개발, 스테이징, 운영과 같이 여러 네임스페이스 내에서 동일한 설정을 사용하는 경우에 유용하다.
네임스페이스를 넘어서 접근하기 위해서는,
전체 주소 도메인 이름(FQDN)을 사용해야 한다.</p>
<p>그렇기 때문에, 모든 네임스페이스 이름은 유효한
<a href=/ko/docs/concepts/overview/working-with-objects/names/#dns-label-names>RFC 1123 DNS 레이블</a>이어야 한다.</p>
<div class="alert alert-danger warning callout" role=alert>
<strong>경고:</strong> <p>네임스페이스의 이름을 <a href=https://data.iana.org/TLD/tlds-alpha-by-domain.txt>공개 최상위 도메인</a> 중 하나와 동일하게 만들면,
해당 네임스페이스 내의 서비스의 짧은 DNS 이름이 공개 DNS 레코드와 겹칠 수 있다.
어떠한 네임스페이스 내의 워크로드가
<a href=https://datatracker.ietf.org/doc/html/rfc1034#page-8>접미점(trailing dot)</a> 없이 DNS 룩업을 수행하면
공개 DNS 레코드보다 우선하여 해당 서비스로 리다이렉트될 것이다.</p>
<p>이를 방지하기 위해, 신뢰하는 사용자만 네임스페이스를
생성할 수 있도록 권한을 제한한다.
필요한 경우, 추가적으로 써드파티 보안 컨트롤을 구성할 수 있으며,
예를 들어 <a href=/docs/reference/access-authn-authz/extensible-admission-controllers/>어드미션 웹훅</a>을 이용하여
<a href=https://data.iana.org/TLD/tlds-alpha-by-domain.txt>공개 TLD</a>와
동일한 이름의 네임스페이스 생성을 금지시킬 수 있다.</p>
</div>
<h2 id=모든-오브젝트가-네임스페이스에-속하지는-않음>모든 오브젝트가 네임스페이스에 속하지는 않음</h2>
<p>대부분의 쿠버네티스 리소스(예를 들어, 파드, 서비스, 레플리케이션 컨트롤러 외)는
네임스페이스에 속한다. 하지만 네임스페이스 리소스 자체는 네임스페이스에 속하지 않는다.
그리고 <a href=/ko/docs/concepts/architecture/nodes/>노드</a>나
퍼시스턴트 볼륨과 같은 저수준 리소스는 어느
네임스페이스에도 속하지 않는다.</p>
<p>다음은 네임스페이스에 속하지 않는 쿠버네티스 리소스를 조회하는 방법이다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># 네임스페이스에 속하는 리소스</span>
kubectl api-resources --namespaced<span style=color:#666>=</span><span style=color:#a2f>true</span>

<span style=color:#080;font-style:italic># 네임스페이스에 속하지 않는 리소스</span>
kubectl api-resources --namespaced<span style=color:#666>=</span><span style=color:#a2f>false</span>
</code></pre></div><h2 id=자동-레이블링>자동 레이블링</h2>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes 1.21 [beta]</code>
</div>
<p>쿠버네티스 컨트롤 플레인은 <code>NamespaceDefaultLabelName</code> <a href=/ko/docs/reference/command-line-tools-reference/feature-gates/>기능 게이트</a>가
활성화된 경우 모든 네임스페이스에 변경할 수 없는(immutable) <a class=glossary-tooltip title="사용자에게 의미 있고 관련성 높은 특징으로 식별할 수 있도록 오브젝트에 태그를 붙인다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/overview/working-with-objects/labels target=_blank aria-label=레이블>레이블</a>
<code>kubernetes.io / metadata.name</code> 을 설정한다.
레이블 값은 네임스페이스 이름이다.</p>
<h2 id=다음-내용>다음 내용</h2>
<ul>
<li><a href=/docs/tasks/administer-cluster/namespaces/#creating-a-new-namespace>신규 네임스페이스 생성</a>에 대해 더 배우기.</li>
<li><a href=/docs/tasks/administer-cluster/namespaces/#deleting-a-namespace>네임스페이스 삭제</a>에 대해 더 배우기.</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-f1dec4557fb8ffbac9f11390aaaf9fa4>1.4.5 - 레이블과 셀렉터</h1>
<p><em>레이블</em> 은 파드와 같은 오브젝트에 첨부된 키와 값의 쌍이다.
레이블은 오브젝트의 특성을 식별하는 데 사용되어 사용자에게 중요하지만, 코어 시스템에 직접적인 의미는 없다.
레이블로 오브젝트의 하위 집합을 선택하고, 구성하는데 사용할 수 있다. 레이블은 오브젝트를 생성할 때에 붙이거나 생성 이후에 붙이거나 언제든지 수정이 가능하다.
오브젝트마다 키와 값으로 레이블을 정의할 수 있다. 오브젝트의 키는 고유한 값이어야 한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=color:#b44>&#34;metadata&#34;</span><span>:</span> {
  <span style=color:green;font-weight:700>&#34;labels&#34;</span>: {
    <span style=color:green;font-weight:700>&#34;key1&#34;</span> : <span style=color:#b44>&#34;value1&#34;</span>,
    <span style=color:green;font-weight:700>&#34;key2&#34;</span> : <span style=color:#b44>&#34;value2&#34;</span>
  }
}
</code></pre></div><p>레이블은 UI와 CLI에서 효율적인 쿼리를 사용하고 검색에 사용하기에
적합하다. 식별되지 않는 정보는
<a href=/ko/docs/concepts/overview/working-with-objects/annotations/>어노테이션</a>으로 기록해야 한다.</p>
<h2 id=사용-동기>사용 동기</h2>
<p>레이블을 이용하면 사용자가 느슨하게 결합한 방식으로 조직 구조와 시스템 오브젝트를 매핑할 수 있으며, 클라이언트에 매핑 정보를 저장할 필요가 없다.</p>
<p>서비스 배포와 배치 프로세싱 파이프라인은 흔히 다차원의 엔티티들이다(예: 다중 파티션 또는 배포, 다중 릴리스 트랙, 다중 계층, 계층 속 여러 마이크로 서비스들). 관리에는 크로스-커팅 작업이 필요한 경우가 많은데 이 작업은 사용자보다는 인프라에 의해 결정된 엄격한 계층 표현인 캡슐화를 깨트린다.</p>
<p>레이블 예시:</p>
<ul>
<li><code>"release" : "stable"</code>, <code>"release" : "canary"</code></li>
<li><code>"environment" : "dev"</code>, <code>"environment" : "qa"</code>, <code>"environment" : "production"</code></li>
<li><code>"tier" : "frontend"</code>, <code>"tier" : "backend"</code>, <code>"tier" : "cache"</code></li>
<li><code>"partition" : "customerA"</code>, <code>"partition" : "customerB"</code></li>
<li><code>"track" : "daily"</code>, <code>"track" : "weekly"</code></li>
</ul>
<p>이 예시는 <a href=/ko/docs/concepts/overview/working-with-objects/common-labels/>일반적으로 사용하는 레이블</a>이며, 사용자는 자신만의 규칙(convention)에 따라 자유롭게 개발할 수 있다. 오브젝트에 붙여진 레이블 키는 고유해야 한다는 것을 기억해야 한다.</p>
<h2 id=구문과-캐릭터-셋>구문과 캐릭터 셋</h2>
<p><em>레이블</em> 은 키와 값의 쌍이다. 유효한 레이블 키에는 슬래시(<code>/</code>)로 구분되는 선택한 접두사와 이름이라는 2개의 세그먼트가 있다. 이름 세그먼트는 63자 미만으로 시작과 끝은 알파벳과 숫자(<code>[a-z0-9A-Z]</code>)이며, 대시(<code>-</code>), 밑줄(<code>_</code>), 점(<code>.</code>)과 함께 사용할 수 있다. 접두사는 선택이다. 만약 접두사를 지정한 경우 접두사는 DNS의 하위 도메인으로 해야 하며, 점(<code>.</code>)과 전체 253자 이하, 슬래시(<code>/</code>)로 구분되는 DNS 레이블이다.</p>
<p>접두사를 생략하면 키 레이블은 개인용으로 간주한다. 최종 사용자의 오브젝트에 자동화된 시스템 컴포넌트(예: <code>kube-scheduler</code>, <code>kube-controller-manager</code>, <code>kube-apiserver</code>, <code>kubectl</code> 또는 다른 타사의 자동화 구성 요소)의 접두사를 지정해야 한다.</p>
<p><code>kubernetes.io/</code>와 <code>k8s.io/</code> 접두사는 쿠버네티스의 핵심 컴포넌트로 <a href=/ko/docs/reference/labels-annotations-taints/>예약</a>되어 있다.</p>
<p>유효한 레이블 값은 다음과 같다.</p>
<ul>
<li>63 자 이하여야 하고 (공백일 수도 있음),</li>
<li>(공백이 아니라면) 시작과 끝은 알파벳과 숫자(<code>[a-z0-9A-Z]</code>)이며,</li>
<li>알파벳과 숫자, 대시(<code>-</code>), 밑줄(<code>_</code>), 점(<code>.</code>)을 중간에 포함할 수 있다.</li>
</ul>
<p>다음의 예시는 파드에 <code>environment: production</code> 과 <code>app: nginx</code> 2개의 레이블이 있는 구성 파일이다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>label-demo<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>environment</span>:<span style=color:#bbb> </span>production<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.14.2<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>
</span></code></pre></div><h2 id=레이블-셀렉터>레이블 셀렉터</h2>
<p><a href=/ko/docs/concepts/overview/working-with-objects/names/>이름과 UID</a>와 다르게 레이블은 고유하지 않다. 일반적으로 우리는 많은 오브젝트에 같은 레이블을 가질 것으로 예상한다.</p>
<p>레이블 셀렉터를 통해 클라이언트와 사용자는 오브젝트를 식별할 수 있다. 레이블 셀렉터는 쿠버네티스 코어 그룹의 기본이다.</p>
<p>API는 현재 <em>일치성 기준</em> 과 <em>집합성 기준</em> 이라는 두 종류의 셀렉터를 지원한다.
레이블 셀렉터는 쉼표로 구분된 다양한 <em>요구사항</em> 에 따라 만들 수 있다. 다양한 요구사항이 있는 경우 쉼표 기호가 AND(<code>&&</code>) 연산자로 구분되는 역할을 하도록 해야 한다.</p>
<p>비어있거나 지정되지 않은 셀렉터는 상황에 따라 달라진다.
셀렉터를 사용하는 API 유형은 유효성과 의미를
문서화해야 한다.</p>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> 레플리카셋(ReplicaSet)과 같은 일부 API 유형에서 두 인스턴스의 레이블 셀렉터는 네임스페이스 내에서 겹치지 않아야 한다. 그렇지 않으면 컨트롤러는 상충하는 명령으로 보고, 얼마나 많은 복제본이 필요한지 알 수 없다.
</div>
<div class="alert alert-warning caution callout" role=alert>
<strong>주의:</strong> 일치성 기준과 집합성 기준 조건 모두에 대해 논리적인 <em>OR</em> (<code>||</code>) 연산자가 없다. 필터 구문이 적절히 구성되어 있는지 확인해야 한다.
</div>
<h3 id=일치성-기준-요건><em>일치성 기준</em> 요건</h3>
<p><em>일치성 기준</em> 또는 <em>불일치 기준</em> 의 요구사항으로 레이블의 키와 값의 필터링을 허용한다. 일치하는 오브젝트는 추가 레이블을 가질 수 있지만, 레이블의 명시된 제약 조건을 모두 만족해야 한다.
<code>=</code>,<code>==</code>,<code>!=</code> 이 세 가지 연산자만 허용한다. 처음 두 개의 연산자의 <em>일치성</em>(그리고 동의어), 나머지는 <em>불일치</em> 를 의미한다. 예를 들면,</p>
<pre><code>environment = production
tier != frontend
</code></pre><p>전자는 <code>environment</code>를 키로 가지는 것과 <code>production</code>을 값으로 가지는 모든 리소스를 선택한다.
후자는 <code>tier</code>를 키로 가지고, 값을 <code>frontend</code>를 가지는 리소스를 제외한 모든 리소스를 선택하고, <code>tier</code>를 키로 가지며, 값을 공백으로 가지는 모든 리소스를 선택한다.
<code>environment=production,tier!=frontend</code> 처럼 쉼표를 통해 한 문장으로 <code>frontend</code>를 제외한 <code>production</code>을 필터링할 수 있다.</p>
<p>일치성 기준 레이블 요건에 대한 하나의 이용 시나리오는 파드가 노드를 선택하는 기준을 지정하는 것이다.
예를 들어, 아래 샘플 파드는 "<code>accelerator=nvidia-tesla-p100</code>"
레이블을 가진 노드를 선택한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cuda-test<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cuda-test<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;k8s.gcr.io/cuda-vector-add:v0.1&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>nvidia.com/gpu</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>nodeSelector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>accelerator</span>:<span style=color:#bbb> </span>nvidia-tesla-p100<span style=color:#bbb>
</span></code></pre></div><h3 id=집합성-기준-요건><em>집합성 기준</em> 요건</h3>
<p><em>집합성 기준</em> 레이블 요건에 따라 값 집합을 키로 필터링할 수 있다. <code>in</code>,<code>notin</code>과 <code>exists</code>(키 식별자만 해당)의 3개의 연산자를 지원한다. 예를 들면,</p>
<pre><code>environment in (production, qa)
tier notin (frontend, backend)
partition
!partition
</code></pre><ul>
<li>첫 번째 예시에서 키가 <code>environment</code>이고 값이 <code>production</code> 또는 <code>qa</code>인 모든 리소스를 선택한다.</li>
<li>두 번째 예시에서 키가 <code>tier</code>이고 값이 <code>frontend</code>와 <code>backend</code>를 가지는 리소스를 제외한 모든 리소스와 키로 <code>tier</code>를 가지고 값을 공백으로 가지는 모든 리소스를 선택한다.</li>
<li>세 번째 예시에서 레이블의 값에 상관없이 키가 <code>partition</code>을 포함하는 모든 리소스를 선택한다.</li>
<li>네 번째 예시에서 레이블의 값에 상관없이 키가 <code>partition</code>을 포함하지 않는 모든 리소스를 선택한다.</li>
</ul>
<p>마찬가지로 쉼표는 <em>AND</em> 연산자로 작동한다. 따라서 <code>partition,environment notin (qa)</code>와 같이 사용하면 값과 상관없이 키가 <code>partition</code>인 것과 키가 <code>environment</code>이고 값이 <code>qa</code>와 다른 리소스를 필터링할 수 있다.
<em>집합성 기준</em> 레이블 셀렉터는 일반적으로 <code>environment=production</code>과 <code>environment in (production)</code>을 같은 것으로 본다. 유사하게는 <code>!=</code>과 <code>notin</code>을 같은 것으로 본다.</p>
<p><em>집합성 기준</em> 요건은 <em>일치성 기준</em> 요건과 조합해서 사용할 수 있다. 예를 들어 <code>partition in (customerA, customerB),environment!=qa</code></p>
<h2 id=api>API</h2>
<h3 id=list와-watch-필터링>LIST와 WATCH 필터링</h3>
<p>LIST와 WATCH 작업은 쿼리 파라미터를 사용해서 반환되는 오브젝트 집합을 필터링하기 위해 레이블 셀렉터를 지정할 수 있다. 다음의 두 가지 요건 모두 허용된다(URL 쿼리 문자열을 그대로 표기함).</p>
<ul>
<li><em>일치성 기준</em> 요건: <code>?labelSelector=environment%3Dproduction,tier%3Dfrontend</code></li>
<li><em>집합성 기준</em> 요건: <code>?labelSelector=environment+in+%28production%2Cqa%29%2Ctier+in+%28frontend%29</code></li>
</ul>
<p>두 가지 레이블 셀렉터 스타일은 모두 REST 클라이언트를 통해 선택된 리소스를 확인하거나 목록을 볼 수 있다. 예를 들어, <code>kubectl</code>로 <code>apiserver</code>를 대상으로 <em>일치성 기준</em> 으로 하는 셀렉터를 다음과 같이 이용할 수 있다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods -l <span style=color:#b8860b>environment</span><span style=color:#666>=</span>production,tier<span style=color:#666>=</span>frontend
</code></pre></div><p>또는 <em>집합성 기준</em> 요건을 사용하면</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods -l <span style=color:#b44>&#39;environment in (production),tier in (frontend)&#39;</span>
</code></pre></div><p>앞서 안내한 것처럼 <em>집합성 기준</em> 요건은 더 보여준다. 예시에서 다음과 같이 OR 연산자를 구현할 수 있다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods -l <span style=color:#b44>&#39;environment in (production, qa)&#39;</span>
</code></pre></div><p>또는 <em>exists</em> 연산자에 불일치한 것으로 제한할 수 있다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods -l <span style=color:#b44>&#39;environment,environment notin (frontend)&#39;</span>
</code></pre></div><h3 id=api-오브젝트에서-참조-설정>API 오브젝트에서 참조 설정</h3>
<p><a href=/ko/docs/concepts/services-networking/service/><code>services</code></a> 와
<a href=/ko/docs/concepts/workloads/controllers/replicationcontroller/><code>replicationcontrollers</code></a>와 같은
일부 쿠버네티스 오브젝트는 레이블 셀렉터를 사용해서
<a href=/ko/docs/concepts/workloads/pods/>파드</a>와 같은 다른 리소스 집합을 선택한다.</p>
<h4 id=서비스와-레플리케이션-컨트롤러>서비스와 레플리케이션 컨트롤러</h4>
<p><code>services</code>에서 지정하는 파드 집합은 레이블 셀렉터로 정의한다. 마찬가지로 <code>replicationcontrollers</code>가 관리하는 파드의 오브젝트 그룹도 레이블 셀렉터로 정의한다.</p>
<p>서비스와 레플리케이션 컨트롤러의 레이블 셀렉터는 <code>json</code> 또는 <code>yaml</code> 파일에 매핑된 <em>일치성 기준</em> 요구사항의 셀렉터만 지원한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=color:#b44>&#34;selector&#34;</span><span>:</span> {
    <span style=color:green;font-weight:700>&#34;component&#34;</span> : <span style=color:#b44>&#34;redis&#34;</span>,
}
</code></pre></div><p>or</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>component</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span></code></pre></div><p><code>json</code> 또는 <code>yaml</code> 서식에서 셀렉터는 <code>component=redis</code> 또는 <code>component in (redis)</code> 모두 같은 것이다.</p>
<h4 id=세트-기반-요건을-지원하는-리소스>세트-기반 요건을 지원하는 리소스</h4>
<p><a href=/ko/docs/concepts/workloads/controllers/job/><code>Job</code></a>,
<a href=/ko/docs/concepts/workloads/controllers/deployment/><code>Deployment</code></a>,
<a href=/ko/docs/concepts/workloads/controllers/replicaset/><code>ReplicaSet</code></a> 그리고
<a href=/ko/docs/concepts/workloads/controllers/daemonset/><code>DaemonSet</code></a> 같은
새로운 리소스들은 <em>집합성 기준</em> 의 요건도 지원한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>component</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- {<span style=color:green;font-weight:700>key: tier, operator: In, values</span>:<span style=color:#bbb> </span>[cache]}<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- {<span style=color:green;font-weight:700>key: environment, operator: NotIn, values</span>:<span style=color:#bbb> </span>[dev]}<span style=color:#bbb>
</span></code></pre></div><p><code>matchLabels</code>는 <code>{key,value}</code>의 쌍과 매칭된다. <code>matchLabels</code>에 매칭된 단일 <code>{key,value}</code>는 <code>matchExpressions</code>의 요소와 같으며 <code>key</code> 필드는 "key"로, <code>operator</code>는 "In" 그리고 <code>values</code>에는 "value"만 나열되어 있다. <code>matchExpressions</code>는 파드 셀렉터의 요건 목록이다. 유효한 연산자에는 In, NotIn, Exists 및 DoNotExist가 포함된다. In 및 NotIn은 설정된 값이 있어야 한다. <code>matchLabels</code>와 <code>matchExpressions</code> 모두 AND로 되어 있어 일치하기 위해서는 모든 요건을 만족해야 한다.</p>
<h4 id=노드-셋-선택>노드 셋 선택</h4>
<p>레이블을 통해 선택하는 사용 사례 중 하나는 파드를 스케줄 할 수 있는 노드 셋을 제한하는 것이다.
자세한 내용은 <a href=/ko/docs/concepts/scheduling-eviction/assign-pod-node/>노드 선택</a> 문서를 참조한다.</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-93cd7a1d4e1623e2bf01afc49a5af69c>1.4.6 - 어노테이션</h1>
<p>쿠버네티스 어노테이션을 사용하여 임의의 비-식별 메타데이터를
오브젝트에 첨부할 수 있다. 도구 및 라이브러리와 같은 클라이언트는 이 메타데이터를 검색할 수 있다.</p>
<h2 id=오브젝트에-메타데이터-첨부>오브젝트에 메타데이터 첨부</h2>
<p>레이블이나 어노테이션을 사용하여 쿠버네티스
오브젝트에 메타데이터를 첨부할 수 있다. 레이블을 사용하여 오브젝트를 선택하고, 특정 조건을 만족하는 오브젝트
컬렉션을 찾을 수 있다. 반면에, 어노테이션은
오브젝트를 식별하고 선택하는데 사용되지 않는다. 어노테이션의 메타데이터는
작거나 크고, 구조적이거나 구조적이지 않을 수 있으며, 레이블에서
허용되지 않는 문자를 포함할 수 있다.</p>
<p>어노테이션은 레이블과 같이 키/값 맵이다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=color:#b44>&#34;metadata&#34;</span><span>:</span> {
  <span style=color:green;font-weight:700>&#34;annotations&#34;</span>: {
    <span style=color:green;font-weight:700>&#34;key1&#34;</span> : <span style=color:#b44>&#34;value1&#34;</span>,
    <span style=color:green;font-weight:700>&#34;key2&#34;</span> : <span style=color:#b44>&#34;value2&#34;</span>
  }
}
</code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> 맵의 키와 값은 문자열이어야 한다. 다르게 말해서, 숫자,
불리언(boolean), 리스트 등의 다른 형식을 키나 값에 사용할 수 없다.
</div>
<p>다음은 어노테이션에 기록할 수 있는 정보의 예제이다.</p>
<ul>
<li>
<p>필드는 선언적 구성 계층에 의해 관리된다. 이러한 필드를 어노테이션으로 첨부하는 것은
클라이언트 또는 서버가 설정한 기본 값,
자동 생성된 필드, 그리고
오토사이징 또는 오토스케일링 시스템에 의해 설정된 필드와 구분된다.</p>
</li>
<li>
<p>빌드, 릴리스, 또는 타임 스탬프, 릴리스 ID, git 브랜치,
PR 번호, 이미지 해시 및 레지스트리 주소와 같은 이미지 정보.</p>
</li>
<li>
<p>로깅, 모니터링, 분석 또는 감사 리포지터리에 대한 포인터.</p>
</li>
<li>
<p>디버깅 목적으로 사용될 수 있는 클라이언트 라이브러리 또는 도구 정보:
예를 들면, 이름, 버전, 그리고 빌드 정보.</p>
</li>
<li>
<p>다른 생태계 구성 요소의 관련 오브젝트 URL과 같은
사용자 또는 도구/시스템 출처 정보.</p>
</li>
<li>
<p>경량 롤아웃 도구 메타데이터. 예: 구성 또는 체크포인트</p>
</li>
<li>
<p>책임자의 전화번호 또는 호출기 번호, 또는 팀 웹 사이트 같은
해당 정보를 찾을 수 있는 디렉터리 진입점.</p>
</li>
<li>
<p>행동을 수정하거나 비표준 기능을 수행하기 위한
최종 사용자의 지시 사항.</p>
</li>
</ul>
<p>어노테이션을 사용하는 대신, 이 유형의 정보를
외부 데이터베이스 또는 디렉터리에 저장할 수 있지만, 이는 배포, 관리, 인트로스펙션(introspection) 등을 위한
공유 클라이언트 라이브러리와 도구 생성을
훨씬 더 어렵게 만들 수 있다.</p>
<h2 id=문법과-캐릭터-셋>문법과 캐릭터 셋</h2>
<p><em>어노테이션</em> 은 키/값 쌍이다. 유효한 어노테이션 키에는 두 개의 세그먼트가 있다. 두 개의 세그먼트는 선택적인 접두사와 이름(name)이며, 슬래시(<code>/</code>)로 구분된다. 이름 세그먼트는 필수이며, 영문 숫자(<code>[a-z0-9A-Z]</code>)로 시작하고 끝나는 63자 이하이어야 하고, 사이에 대시(<code>-</code>), 밑줄(<code>_</code>), 점(<code>.</code>)이 들어갈 수 있다. 접두사는 선택적이다. 지정된 경우, 접두사는 DNS 서브도메인이어야 한다. 점(<code>.</code>)으로 구분된 일련의 DNS 레이블은 총 253자를 넘지 않고, 뒤에 슬래시(<code>/</code>)가 붙는다.</p>
<p>접두사가 생략되면, 어노테이션 키는 사용자에게 비공개로 간주된다. 최종 사용자 오브젝트에 어노테이션을 추가하는 자동화된 시스템 구성 요소(예 :<code>kube-scheduler</code>, <code>kube-controller-manager</code>, <code>kube-apiserver</code>, <code>kubectl</code>, 또는 다른 써드파티 자동화)는 접두사를 지정해야 한다.</p>
<p><code>kubernetes.io/</code>와 <code>k8s.io/</code> 접두사는 쿠버네티스 핵심 구성 요소를 위해 예약되어 있다.</p>
<p>다음은 <code>imageregistry: https://hub.docker.com/</code> 어노테이션이 있는 파드의 구성 파일 예시이다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>annotations-demo<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>imageregistry</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;https://hub.docker.com/&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.14.2<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>
</span></code></pre></div><h2 id=다음-내용>다음 내용</h2>
<p><a href=/ko/docs/concepts/overview/working-with-objects/labels/>레이블과 셀렉터</a>에 대해 알아본다.</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-046c03090d47bc4b89b818dc645c3865>1.4.7 - 필드 셀렉터</h1>
<p><em>필드 셀렉터</em> 는 한 개 이상의 리소스 필드 값에 따라 <a href=/ko/docs/concepts/overview/working-with-objects/kubernetes-objects/>쿠버네티스 리소스를 선택</a>하기 위해 사용된다. 필드 셀렉터 쿼리의 예시는 다음과 같다.</p>
<ul>
<li><code>metadata.name=my-service</code></li>
<li><code>metadata.namespace!=default</code></li>
<li><code>status.phase=Pending</code></li>
</ul>
<p>다음의 <code>kubectl</code> 커맨드는 <a href=/ko/docs/concepts/workloads/pods/pod-lifecycle/#%ED%8C%8C%EB%93%9C%EC%9D%98-%EB%8B%A8%EA%B3%84-phase><code>status.phase</code></a> 필드의 값이 <code>Running</code> 인 모든 파드를 선택한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods --field-selector status.phase<span style=color:#666>=</span>Running
</code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> 필드 셀렉터는 본질적으로 리소스 <em>필터</em> 이다. 기본적으로 적용되는 셀렉터나 필드는 없으며, 이는 명시된 종류의 모든 리소스가 선택된다는 것을 의미한다. 여기에 따라오는 <code>kubectl</code> 쿼리인 <code>kubectl get pods</code> 와 <code>kubectl get pods --field-selector ""</code> 는 동일하다.
</div>
<h2 id=사용-가능한-필드>사용 가능한 필드</h2>
<p>사용 가능한 필드는 쿠버네티스의 리소스 종류에 따라서 다르다. 모든 리소스 종류는 <code>metadata.name</code> 과 <code>metadata.namespace</code> 필드 셀렉터를 사용할 수 있다. 사용할 수 없는 필드 셀렉터를 사용하면 다음과 같이 에러를 출력한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get ingress --field-selector foo.bar<span style=color:#666>=</span>baz
</code></pre></div><pre><code>Error from server (BadRequest): Unable to find &quot;ingresses&quot; that match label selector &quot;&quot;, field selector &quot;foo.bar=baz&quot;: &quot;foo.bar&quot; is not a known field selector: only &quot;metadata.name&quot;, &quot;metadata.namespace&quot;
</code></pre><h2 id=사용-가능한-연산자>사용 가능한 연산자</h2>
<p>필드 셀렉터에서 <code>=</code>, <code>==</code>, <code>!=</code> 연산자를 사용할 수 있다 (<code>=</code>와 <code>==</code>는 동일한 의미이다). 예를 들면, 다음의 <code>kubectl</code> 커맨드는 <code>default</code> 네임스페이스에 속해있지 않은 모든 쿠버네티스 서비스를 선택한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get services  --all-namespaces --field-selector metadata.namespace!<span style=color:#666>=</span>default
</code></pre></div><h2 id=연계되는-셀렉터>연계되는 셀렉터</h2>
<p><a href=/ko/docs/concepts/overview/working-with-objects/labels>레이블</a>을 비롯한 다른 셀렉터처럼, 쉼표로 구분되는 목록을 통해 필드 셀렉터를 연계해서 사용할 수 있다. 다음의 <code>kubectl</code> 커맨드는 <code>status.phase</code> 필드가 <code>Running</code> 이 아니고, <code>spec.restartPolicy</code> 필드가 <code>Always</code> 인 모든 파드를 선택한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods --field-selector<span style=color:#666>=</span>status.phase!<span style=color:#666>=</span>Running,spec.restartPolicy<span style=color:#666>=</span>Always
</code></pre></div><h2 id=여러-개의-리소스-종류>여러 개의 리소스 종류</h2>
<p>필드 셀렉터를 여러 개의 리소스 종류에 걸쳐 사용할 수 있다. 다음의 <code>kubectl</code> 커맨드는 <code>default</code> 네임스페이스에 속해있지 않은 모든 스테이트풀셋(StatefulSet)과 서비스를 선택한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get statefulsets,services --all-namespaces --field-selector metadata.namespace!<span style=color:#666>=</span>default
</code></pre></div>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-5dd62c6a4a481b4cf1ac50f6799eb581>1.4.8 - 권장 레이블</h1>
<p>kubectl과 대시보드와 같은 많은 도구들로 쿠버네티스 오브젝트를 시각화 하고 관리할 수 있다.
공통 레이블 셋은 모든 도구들이 이해할 수 있는 공통의 방식으로 오브젝트를 식별하고
도구들이 상호 운용적으로 작동할 수 있도록 한다.</p>
<p>권장 레이블은 지원 도구 외에도 쿼리하는 방식으로
애플리케이션을 식별하게 한다.</p>
<p>메타데이터는 <em>애플리케이션</em> 의 개념을 중심으로 정리된다.
쿠버네티스는 플랫폼 서비스(PaaS)가 아니며 애플리케이션에 대해 공식적인 개념이 없거나 강요하지 않는다.
대신 애플리케이션은 비공식적이며 메타데이터로 설명된다.
애플리케이션에 포함된 정의는 유연하다.</p>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> 메타데이터들은 권장하는 레이블이다. 애플리케이션을 보다 쉽게 관리할 수 있지만
코어 도구에는 필요하지 않다.
</div>
<p>공유 레이블과 주석에는 공통 접두사인 <code>app.kubernetes.io</code> 가 있다.
접두사가 없는 레이블은 사용자가 개인적으로 사용할 수 있다.
공유 접두사는 공유 레이블이 사용자 정의 레이블을 방해하지 않도록 한다.</p>
<h2 id=레이블>레이블</h2>
<p>레이블을 최대한 활용하려면 모든 리소스 오브젝트에
적용해야 한다.</p>
<table>
<thead>
<tr>
<th>키</th>
<th>설명</th>
<th>예시</th>
<th>타입</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>app.kubernetes.io/name</code></td>
<td>애플리케이션 이름</td>
<td><code>mysql</code></td>
<td>문자열</td>
</tr>
<tr>
<td><code>app.kubernetes.io/instance</code></td>
<td>애플리케이션의 인스턴스를 식별하는 고유한 이름</td>
<td><code>mysql-abcxzy</code></td>
<td>문자열</td>
</tr>
<tr>
<td><code>app.kubernetes.io/version</code></td>
<td>애플리케이션의 현재 버전 (예: a semantic version, revision hash 등.)</td>
<td><code>5.7.21</code></td>
<td>문자열</td>
</tr>
<tr>
<td><code>app.kubernetes.io/component</code></td>
<td>아키텍처 내 구성요소</td>
<td><code>database</code></td>
<td>문자열</td>
</tr>
<tr>
<td><code>app.kubernetes.io/part-of</code></td>
<td>이 애플리케이션의 전체 이름</td>
<td><code>wordpress</code></td>
<td>문자열</td>
</tr>
<tr>
<td><code>app.kubernetes.io/managed-by</code></td>
<td>애플리케이션의 작동을 관리하는 데 사용되는 도구</td>
<td><code>helm</code></td>
<td>문자열</td>
</tr>
<tr>
<td><code>app.kubernetes.io/created-by</code></td>
<td>이 리소스를 만든 컨트롤러/사용자</td>
<td><code>controller-manager</code></td>
<td>문자열</td>
</tr>
</tbody>
</table>
<p>위 레이블의 실제 예시는 다음 <a class=glossary-tooltip title="내구성이 있는 스토리지와 파드별로 지속성 식별자를 사용해서 파드 집합의 디플로이먼트와 스케일링을 관리한다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/controllers/statefulset/ target=_blank aria-label=스테이트풀셋>스테이트풀셋</a> 오브젝트를 고려한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#080;font-style:italic># 아래는 전체 명세의 일부분이다</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StatefulSet<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/name</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/instance</span>:<span style=color:#bbb> </span>mysql-abcxzy<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/version</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;5.7.21&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/component</span>:<span style=color:#bbb> </span>database<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/part-of</span>:<span style=color:#bbb> </span>wordpress<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/managed-by</span>:<span style=color:#bbb> </span>helm<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/created-by</span>:<span style=color:#bbb> </span>controller-manager<span style=color:#bbb>
</span></code></pre></div><h2 id=애플리케이션과-애플리케이션-인스턴스>애플리케이션과 애플리케이션 인스턴스</h2>
<p>애플리케이션은 동일한 쿠버네티스 클러스터에,
심지어는 동일한 네임스페이스에도 한번 또는 그 이상 설치될 수 있다. 예를 들어, 하나의 쿠버네티스 클러스터에
WordPress가 여러 번 설치되어 각각 서로 다른 웹사이트를 서비스할 수 있다.</p>
<p>애플리케이션의 이름과 애플리케이션 인스턴스 이름은 별도로 기록된다.
예를 들어 WordPress는 애플리케이션 이름으로 <code>app.kubernetes.io/name</code> 이라는 레이블에 <code>wordpress</code> 라는 값을 가지며,
애플리케이션 인스턴스 이름으로는 <code>app.kubernetes.io/instance</code> 라는 레이블에
<code>wordpress-abcxzy</code> 라는 값을 가진다. 이를 통해 애플리케이션과 애플리케이션 인스턴스를
식별할 수 있다. 모든 애플리케이션 인스턴스는 고유한 이름을 가져야 한다.</p>
<h2 id=예시>예시</h2>
<p>위 레이블을 사용하는 다른 방식에 대한 예시는 다양한 복잡성이 있다.</p>
<h3 id=단순한-스테이트리스-서비스>단순한 스테이트리스 서비스</h3>
<p><code>Deployment</code> 와 <code>Service</code> 오브젝트를 통해 배포된 단순한 스테이트리스 서비스의 경우를 보자. 다음 두 식별자는 레이블을 가장 간단한 형태로 사용하는 방법을 나타낸다.</p>
<p><code>Deployment</code> 는 애플리케이션을 실행하는 파드를 감시하는 데 사용한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/name</span>:<span style=color:#bbb> </span>myservice<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/instance</span>:<span style=color:#bbb> </span>myservice-abcxzy<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></code></pre></div><p><code>Service</code>는 애플리케이션을 노출하기 위해 사용한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/name</span>:<span style=color:#bbb> </span>myservice<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/instance</span>:<span style=color:#bbb> </span>myservice-abcxzy<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></code></pre></div><h3 id=데이터베이스가-있는-웹-애플리케이션>데이터베이스가 있는 웹 애플리케이션</h3>
<p>Helm을 이용해서 데이터베이스(MySQL)을 이용하는 웹 애플리케이션(WordPress)을
설치한 것과 같이 좀 더 복잡한 애플리케이션을 고려할 수 있다.
다음 식별자는 이 애플리케이션을 배포하는 데 사용하는 오브젝트의 시작을 보여준다.</p>
<p>WordPress를 배포하는 데 다음과 같이 <code>Deployment</code> 로 시작한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/name</span>:<span style=color:#bbb> </span>wordpress<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/instance</span>:<span style=color:#bbb> </span>wordpress-abcxzy<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/version</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;4.9.4&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/managed-by</span>:<span style=color:#bbb> </span>helm<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/component</span>:<span style=color:#bbb> </span>server<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/part-of</span>:<span style=color:#bbb> </span>wordpress<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></code></pre></div><p><code>Service</code> 는 애플리케이션을 노출하기 위해 사용한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/name</span>:<span style=color:#bbb> </span>wordpress<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/instance</span>:<span style=color:#bbb> </span>wordpress-abcxzy<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/version</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;4.9.4&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/managed-by</span>:<span style=color:#bbb> </span>helm<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/component</span>:<span style=color:#bbb> </span>server<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/part-of</span>:<span style=color:#bbb> </span>wordpress<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></code></pre></div><p>MySQL은 <code>StatefulSet</code> 에 MySQL의 소속과 상위 애플리케이션에 대한 메타데이터가 포함되어 노출된다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StatefulSet<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/name</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/instance</span>:<span style=color:#bbb> </span>mysql-abcxzy<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/version</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;5.7.21&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/managed-by</span>:<span style=color:#bbb> </span>helm<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/component</span>:<span style=color:#bbb> </span>database<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/part-of</span>:<span style=color:#bbb> </span>wordpress<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></code></pre></div><p><code>Service</code> 는 WordPress의 일부로 MySQL을 노출하는 데 이용한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/name</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/instance</span>:<span style=color:#bbb> </span>mysql-abcxzy<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/version</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;5.7.21&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/managed-by</span>:<span style=color:#bbb> </span>helm<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/component</span>:<span style=color:#bbb> </span>database<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/part-of</span>:<span style=color:#bbb> </span>wordpress<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></code></pre></div><p>MySQL <code>StatefulSet</code> 과 <code>Service</code> 로 MySQL과 WordPress가 더 큰 범위의 애플리케이션에 포함되어 있는 것을 알게 된다.</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-2bf36ccd6b3dbeafecf87c39761b07c7>2 - 클러스터 아키텍처</h1>
<div class=lead>쿠버네티스 뒤편의 구조와 설계 개념들</div>
</div>
<div class=td-content>
<h1 id=pg-9ef2890698e773b6c0d24fd2c20146f5>2.1 - 노드</h1>
<p>쿠버네티스는 컨테이너를 파드내에 배치하고 <em>노드</em> 에서 실행함으로 워크로드를 구동한다.
노드는 클러스터에 따라 가상 또는 물리적 머신일 수 있다. 각 노드는
<a class=glossary-tooltip title="컨테이너의 라이프사이클을 정의, 배포, 관리하기 위한 API와 인터페이스들을 노출하는 컨테이너 오케스트레이션 레이어." data-toggle=tooltip data-placement=top href="/ko/docs/reference/glossary/?all=true#term-control-plane" target=_blank aria-label="컨트롤 플레인">컨트롤 플레인</a>에
의해 관리되며
<a class=glossary-tooltip title="파드는 클러스터에서 실행 중인 컨테이너의 집합을 나타낸다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/pods/ target=_blank aria-label=파드>파드</a>를
실행하는 데 필요한 서비스를 포함한다.</p>
<p>일반적으로 클러스터에는 여러 개의 노드가 있으며, 학습 또는 리소스가 제한되는
환경에서는 하나만 있을 수도 있다.</p>
<p>노드의 <a href=/ko/docs/concepts/overview/components/#%EB%85%B8%EB%93%9C-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8>컴포넌트</a>에는
<a class=glossary-tooltip title="클러스터의 각 노드에서 실행되는 에이전트. Kubelet은 파드에서 컨테이너가 확실하게 동작하도록 관리한다." data-toggle=tooltip data-placement=top href=/docs/reference/generated/kubelet target=_blank aria-label=kubelet>kubelet</a>,
<a class=glossary-tooltip title="컨테이너 런타임은 컨테이너 실행을 담당하는 소프트웨어이다." data-toggle=tooltip data-placement=top href=/ko/docs/setup/production-environment/container-runtimes/ target=_blank aria-label="컨테이너 런타임">컨테이너 런타임</a>
그리고 <a class=glossary-tooltip title="kube-proxy는 클러스터의 각 노드에서 실행되는 네트워크 프록시이다." data-toggle=tooltip data-placement=top href=/ko/docs/reference/command-line-tools-reference/kube-proxy/ target=_blank aria-label=kube-proxy>kube-proxy</a>가 포함된다.</p>
<h2 id=관리>관리</h2>
<p><a class=glossary-tooltip title="쿠버네티스 API를 제공하는 컨트롤 플레인 컴포넌트." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/overview/components/#kube-apiserver target=_blank aria-label="API 서버">API 서버</a>에 노드를 추가하는 두가지 주요 방법이 있다.</p>
<ol>
<li>노드의 kubelet으로 컨트롤 플레인에 자체 등록</li>
<li>사용자(또는 다른 사용자)가 노드 오브젝트를 수동으로 추가</li>
</ol>
<p>노드 <a class=glossary-tooltip title="클러스터 상태의 일부를 나타내는 쿠버네티스 시스템의 엔티티이다." data-toggle=tooltip data-placement=top href=https://kubernetes.io/ko/docs/concepts/overview/working-with-objects/kubernetes-objects/#kubernetes-objects target=_blank aria-label=오브젝트>오브젝트</a> 또는 노드의 kubelet으로 자체 등록한 후
컨트롤 플레인은 새 노드 오브젝트가 유효한지 확인한다.
예를 들어 다음 JSON 매니페스트에서 노드를 만들려는 경우이다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;Node&#34;</span>,
  <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;v1&#34;</span>,
  <span style=color:green;font-weight:700>&#34;metadata&#34;</span>: {
    <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;10.240.79.157&#34;</span>,
    <span style=color:green;font-weight:700>&#34;labels&#34;</span>: {
      <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;my-first-k8s-node&#34;</span>
    }
  }
}
</code></pre></div><p>쿠버네티스는 내부적으로 노드 오브젝트를 생성한다(표시한다). 쿠버네티스는
kubelet이 노드의 <code>metadata.name</code> 필드와 일치하는 API 서버에 등록이 되어 있는지 확인한다.
노드가 정상이면(예를 들어 필요한 모든 서비스가 실행중인 경우) 파드를 실행할 수 있게 된다.
그렇지 않으면, 해당 노드는 정상이 될 때까지 모든 클러스터 활동에
대해 무시된다.</p>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> <p>쿠버네티스는 유효하지 않은 노드 오브젝트를 유지하고, 노드가
정상적인지 확인한다.</p>
<p>상태 확인을 중지하려면 사용자 또는 <a class=glossary-tooltip title="API 서버를 통해 클러스터의 공유된 상태를 감시하고, 현재 상태를 원하는 상태로 이행시키는 컨트롤 루프." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/architecture/controller/ target=_blank aria-label=컨트롤러>컨트롤러</a>에서
노드 오브젝트를 명시적으로 삭제해야 한다.</p>
</div>
<p>노드 오브젝트의 이름은 유효한
<a href=/ko/docs/concepts/overview/working-with-objects/names/#dns-%EC%84%9C%EB%B8%8C%EB%8F%84%EB%A9%94%EC%9D%B8-%EC%9D%B4%EB%A6%84>DNS 서브도메인 이름</a>이어야 한다.</p>
<h3 id=노드-이름-고유성>노드 이름 고유성</h3>
<p><a href=/ko/docs/concepts/overview/working-with-objects/names#names>이름</a>은 노드를 식별한다. 두 노드는
동시에 같은 이름을 가질 수 없다. 쿠버네티스는 또한 같은 이름의 리소스가
동일한 객체라고 가정한다. 노드의 경우, 동일한 이름을 사용하는 인스턴스가 동일한
상태(예: 네트워크 설정, 루트 디스크 내용)와 노드 레이블과 같은 동일한 속성(attribute)을
갖는다고 암시적으로 가정한다. 인스턴스가
이름을 변경하지 않고 수정된 경우 이로 인해 불일치가 발생할 수 있다. 노드를 대폭 교체하거나
업데이트해야 하는 경우, 기존 노드 오브젝트를 먼저 API 서버에서 제거하고
업데이트 후 다시 추가해야 한다.</p>
<h3 id=노드에-대한-자체-등록-self-registration>노드에 대한 자체-등록(self-registration)</h3>
<p>kubelet 플래그 <code>--register-node</code>가 참(기본값)일 경우, kubelet은 API 서버에
스스로 등록을 시도할 것이다. 이는 선호되는 패턴이며, 대부분의 배포판에서 사용된다.</p>
<p>자체-등록에 대해, kubelet은 다음 옵션과 함께 시작된다.</p>
<ul>
<li>
<p><code>--kubeconfig</code> - apiserver에 스스로 인증하기 위한 자격증명에 대한 경로.</p>
</li>
<li>
<p><code>--cloud-provider</code> - 자신에 대한 메터데이터를 읽기 위해 어떻게 <a class=glossary-tooltip title="클라우드 컴퓨팅 플랫폼을 제공하는 조직." data-toggle=tooltip data-placement=top href="/ko/docs/reference/glossary/?all=true#term-cloud-provider" target=_blank aria-label="클라우드 제공자">클라우드 제공자</a>와 소통할지에 대한 방법.</p>
</li>
<li>
<p><code>--register-node</code> - 자동으로 API 서버에 등록.</p>
</li>
<li>
<p><code>--register-with-taints</code> - 주어진 <a class=glossary-tooltip title="세 가지 필수 속성: 키(key), 값(value), 효과(effect)로 구성된 코어 오브젝트. 테인트는 파드가 노드나 노드 그룹에 스케줄링되는 것을 방지한다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/scheduling-eviction/taint-and-toleration/ target=_blank aria-label=테인트(taint)>테인트(taint)</a> 리스트(콤마로 분리된 <code>&lt;key>=&lt;value>:&lt;effect></code>)를 가진 노드 등록.</p>
<p><code>register-node</code>가 거짓이면 동작 안 함.</p>
</li>
<li>
<p><code>--node-ip</code> - 노드의 IP 주소.</p>
</li>
<li>
<p><code>--node-labels</code> - 클러스터에 노드를 등록할 때 추가 할 <a class=glossary-tooltip title="사용자에게 의미 있고 관련성 높은 특징으로 식별할 수 있도록 오브젝트에 태그를 붙인다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/overview/working-with-objects/labels target=_blank aria-label=레이블>레이블</a>(<a href=/docs/reference/access-authn-authz/admission-controllers/#noderestriction>NodeRestriction admission plugin</a>에 의해 적용되는 레이블 제한 사항 참고).</p>
</li>
<li>
<p><code>--node-status-update-frequency</code> - 얼마나 자주 kubelet이 마스터에 노드 상태를 게시할 지 정의.</p>
</li>
</ul>
<p><a href=/docs/reference/access-authn-authz/node/>Node authorization mode</a>와
<a href=/docs/reference/access-authn-authz/admission-controllers/#noderestriction>NodeRestriction admission plugin</a>이 활성화 되면,
각 kubelet은 자신이 속한 노드의 리소스에 대해서만 생성/수정할 권한을 가진다.</p>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> <p><a href=#%EB%85%B8%EB%93%9C-%EC%9D%B4%EB%A6%84-%EA%B3%A0%EC%9C%A0%EC%84%B1>노드 이름 고유성</a> 섹션에서 언급했듯이,
노드 구성을 업데이트해야 하는 경우 API 서버에 노드를
다시 등록하는 것이 좋다. 예를 들어 kubelet이 <code>--node-labels</code>의 새로운 구성으로
다시 시작되더라도, 동일한 노드 이름이 사용된 경우
레이블이 해당 노드의 등록에 설정되기 때문에 변경 사항이 적용되지 않는다.</p>
<p>노드에 이미 스케줄된 파드는 해당 노드 구성이 kubelet 재시작에 의해 변경된 경우
오작동하거나 문제를 일으킬 수 있다. 예를 들어 이미 실행 중인 파드가 노드에
할당된 새 레이블에 대해 테인트(taint)될 수 있는 반면 해당 파드와 호환되지 않는 다른 파드는
새 레이블을 기반으로 스케줄링된다. 노드 재등록(re-registration)은 모든 파드를
비우고(drain) 다시 적절하게 스케줄링되도록
한다.</p>
</div>
<h4 id=수동-노드-관리>수동 노드 관리</h4>
<p><a class=glossary-tooltip title="쿠버네티스 API 서버와 통신하기 위한 커맨드라인 툴." data-toggle=tooltip data-placement=top href=/docs/user-guide/kubectl-overview/ target=_blank aria-label=kubectl>kubectl</a>을
사용해서 노드 오브젝트를 생성하고 수정할 수 있다.</p>
<p>노드 오브젝트를 수동으로 생성하려면 kubelet 플래그를 <code>--register-node=false</code> 로 설정한다.</p>
<p><code>--register-node</code> 설정과 관계 없이 노드 오브젝트를 수정할 수 있다.
예를 들어 기존 노드에 레이블을 설정하거나, 스케줄 불가로 표시할 수 있다.</p>
<p>파드의 노드 셀렉터와 함께 노드의 레이블을 사용해서 스케줄링을 제어할 수 있다.
예를 들어, 사용 가능한 노드의 하위 집합에서만 실행되도록
파드를 제한할 수 있다.</p>
<p>노드를 스케줄 불가로 표시하면 스케줄러가 해당 노드에 새 파드를 배치할 수 없지만,
노드에 있는 기존 파드에는 영향을 미치지 않는다.
이는 노드 재부팅 또는 기타 유지보수 준비 단계에서 유용하다.</p>
<p>노드를 스케줄 불가로 표시하려면 다음을 실행한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl cordon <span style=color:#b8860b>$NODENAME</span>
</code></pre></div><p>보다 자세한 내용은 <a href=/docs/tasks/administer-cluster/safely-drain-node/>안전하게 노드를 드레인(drain)하기</a>
를 참고한다.</p>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> <a class=glossary-tooltip title="파드의 복제본을 클러스터 노드 집합에서 동작하게 한다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/controllers/daemonset target=_blank aria-label=데몬셋(DaemonSet)>데몬셋(DaemonSet)</a>에 포함되는 일부 파드는
스케줄 불가 노드에서 실행될 수 있다. 일반적으로 데몬셋은 워크로드 애플리케이션을
비우는 경우에도 노드에서 실행되어야 하는 노드 로컬 서비스를 제공한다.
</div>
<h2 id=노드-상태>노드 상태</h2>
<p>노드의 상태는 다음의 정보를 포함한다.</p>
<ul>
<li><a href=#addresses>주소</a></li>
<li><a href=#condition>컨디션</a></li>
<li><a href=#capacity>용량과 할당가능</a></li>
<li><a href=#info>정보</a></li>
</ul>
<p><code>kubectl</code> 을 사용해서 노드 상태와 기타 세부 정보를 볼수 있다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe node &lt;insert-node-name-here&gt;
</code></pre></div><p>출력되는 각 섹션은 아래에 설명되어 있다.</p>
<h3 id=addresses>주소</h3>
<p>이 필드의 용법은 클라우드 제공사업자 또는 베어메탈 구성에 따라 다양하다.</p>
<ul>
<li>HostName: 노드의 커널에 의해 알려진 호스트명이다. <code>--hostname-override</code> 파라미터를 통해 치환될 수 있다.</li>
<li>ExternalIP: 일반적으로 노드의 IP 주소는 외부로 라우트 가능 (클러스터 외부에서 이용 가능) 하다 .</li>
<li>InternalIP: 일반적으로 노드의 IP 주소는 클러스터 내에서만 라우트 가능하다.</li>
</ul>
<h3 id=condition>컨디션</h3>
<p><code>conditions</code> 필드는 모든 <code>Running</code> 노드의 상태를 기술한다. 컨디션의 예로 다음을 포함한다.</p>
<table><caption style=display:none>노드 컨디션과 각 컨디션이 적용되는 시기에 대한 설명들이다.</caption>
<thead>
<tr>
<th>노드 컨디션</th>
<th>설명</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Ready</code></td>
<td>노드가 상태 양호하며 파드를 수용할 준비가 되어 있는 경우 <code>True</code>, 노드의 상태가 불량하여 파드를 수용하지 못할 경우 <code>False</code>, 그리고 노드 컨트롤러가 마지막 <code>node-monitor-grace-period</code> (기본값 40 기간 동안 노드로부터 응답을 받지 못한 경우) <code>Unknown</code></td>
</tr>
<tr>
<td><code>DiskPressure</code></td>
<td>디스크 사이즈 상에 압박이 있는 경우, 즉 디스크 용량이 넉넉치 않은 경우 <code>True</code>, 반대의 경우 <code>False</code></td>
</tr>
<tr>
<td><code>MemoryPressure</code></td>
<td>노드 메모리 상에 압박이 있는 경우, 즉 노드 메모리가 넉넉치 않은 경우 <code>True</code>, 반대의 경우 <code>False</code></td>
</tr>
<tr>
<td><code>PIDPressure</code></td>
<td>프로세스 상에 압박이 있는 경우, 즉 노드 상에 많은 프로세스들이 존재하는 경우 <code>True</code>, 반대의 경우 <code>False</code></td>
</tr>
<tr>
<td><code>NetworkUnavailable</code></td>
<td>노드에 대해 네트워크가 올바르게 구성되지 않은 경우 <code>True</code>, 반대의 경우 <code>False</code></td>
</tr>
</tbody>
</table>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> 커맨드 라인 도구를 사용해서 코드화된 노드의 세부 정보를 출력하는 경우 조건에는
<code>SchedulingDisabled</code> 이 포함된다. <code>SchedulingDisabled</code> 은 쿠버네티스 API의 조건이 아니며,
대신 코드화된 노드는 사양에 스케줄 불가로 표시된다.
</div>
<p>쿠버네티스 API에서, 노드의 컨디션은 노드 리소스의 <code>.status</code> 부분에
표현된다. 예를 들어, 다음의 JSON 구조는 상태가 양호한 노드를 나타낸다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=color:#b44>&#34;conditions&#34;</span><span>:</span> [
  {
    <span style=color:green;font-weight:700>&#34;type&#34;</span>: <span style=color:#b44>&#34;Ready&#34;</span>,
    <span style=color:green;font-weight:700>&#34;status&#34;</span>: <span style=color:#b44>&#34;True&#34;</span>,
    <span style=color:green;font-weight:700>&#34;reason&#34;</span>: <span style=color:#b44>&#34;KubeletReady&#34;</span>,
    <span style=color:green;font-weight:700>&#34;message&#34;</span>: <span style=color:#b44>&#34;kubelet is posting ready status&#34;</span>,
    <span style=color:green;font-weight:700>&#34;lastHeartbeatTime&#34;</span>: <span style=color:#b44>&#34;2019-06-05T18:38:35Z&#34;</span>,
    <span style=color:green;font-weight:700>&#34;lastTransitionTime&#34;</span>: <span style=color:#b44>&#34;2019-06-05T11:41:27Z&#34;</span>
  }
]
</code></pre></div><p>ready 컨디션의 <code>status</code>가 <code>pod-eviction-timeout</code>
(<a class=glossary-tooltip title="컨트롤러 프로세스를 실행하는 컨트롤 플레인 컴포넌트." data-toggle=tooltip data-placement=top href=/docs/reference/command-line-tools-reference/kube-controller-manager/ target=_blank aria-label=kube-controller-manager>kube-controller-manager</a>에 전달된 인수)보다 더 길게 <code>Unknown</code> 또는 <code>False</code>로 유지되는 경우,
<a href=#node-controller>노드 컨트롤러</a>가 해당 노드에 할당된 전체 파드에 대해
<a class=glossary-tooltip title="API를 이용한 축출은 축출 API를 사용하여 파드의 정상 종료를 트리거하는 축출 오브젝트를 만드는 프로세스이다" data-toggle=tooltip data-placement=top href=/ko/docs/concepts/scheduling-eviction/api-eviction/ target=_blank aria-label="API를 이용한 축출">API를 이용한 축출</a>
을 트리거한다. 기본 축출 타임아웃 기간은
<strong>5분</strong> 이다.
노드에 접근이 불가할 때와 같은 경우, API 서버는 노드 상의 kubelet과 통신이 불가하다.
API 서버와의 통신이 재개될 때까지 파드 삭제에 대한 결정은 kubelet에 전해질 수 없다.
그 사이, 삭제되도록 스케줄 되어진 파드는 분할된 노드 상에서 계속 동작할 수도 있다.</p>
<p>노드 컨트롤러가 클러스터 내 동작 중지된 것을 확신할 때까지는 파드를 강제로 삭제하지 않는다.
파드가 <code>Terminating</code> 또는 <code>Unknown</code> 상태로 있을 때 접근 불가한 노드 상에서
동작되고 있는 것을 보게 될 수도 있다. 노드가 영구적으로 클러스터에서 삭제되었는지에
대한 여부를 쿠버네티스가 기반 인프라로부터 유추할 수 없는 경우, 노드가 클러스터를 영구적으로
탈퇴하게 되면, 클러스터 관리자는 손수 노드 오브젝트를 삭제해야 할 수도 있다.
쿠버네티스에서 노드 오브젝트를 삭제하면
노드 상에서 동작 중인 모든 파드 오브젝트가 API 서버로부터 삭제되며
파드가 사용하던 이름을 다시 사용할 수 있게 된다.</p>
<p>노드에서 문제가 발생하면, 쿠버네티스 컨트롤 플레인은 자동으로 노드 상태에 영향을 주는 조건과 일치하는
<a href=/ko/docs/concepts/scheduling-eviction/taint-and-toleration/>테인트(taints)</a>를
생성한다.
스케줄러는 파드를 노드에 할당할 때 노드의 테인트를 고려한다.
또한 파드는 노드에 특정 테인트가 있더라도 해당 노드에서 동작하도록
<a class=glossary-tooltip title="세 가지 필수 속성: 키(key), 값(value), 효과(effect)로 구성된 코어 오브젝트. 톨러레이션은 매칭되는 테인트(taint)를 가진 노드나 노드 그룹에 파드가 스케줄링되는 것을 활성화한다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/scheduling-eviction/taint-and-toleration/ target=_blank aria-label=톨러레이션(toleration)>톨러레이션(toleration)</a>을 가질 수 있다.</p>
<p>자세한 내용은
<a href=/ko/docs/concepts/scheduling-eviction/taint-and-toleration/#%EC%BB%A8%EB%94%94%EC%85%98%EB%B3%84-%EB%85%B8%EB%93%9C-%ED%85%8C%EC%9D%B8%ED%8A%B8%ED%95%98%EA%B8%B0>컨디션별 노드 테인트하기</a>를 참조한다.</p>
<h3 id=capacity>용량과 할당가능</h3>
<p>노드 상에 사용 가능한 리소스를 나타낸다. 리소스에는 CPU, 메모리 그리고
노드 상으로 스케줄 되어질 수 있는 최대 파드 수가 있다.</p>
<p>용량 블록의 필드는 노드에 있는 리소스의 총량을 나타낸다.
할당가능 블록은 일반 파드에서 사용할 수 있는
노드의 리소스 양을 나타낸다.</p>
<p>노드에서
<a href=/docs/tasks/administer-cluster/reserve-compute-resources/#node-allocatable>컴퓨팅 리소스 예약</a>하는 방법을
배우는 동안 용량 및 할당가능 리소스에 대해 자세히 읽어보자.</p>
<h3 id=정보>정보</h3>
<p>커널 버전, 쿠버네티스 버전 (kubelet과 kube-proxy 버전), 컨테이너
런타임 상세 정보 및 노드가 사용하는 운영 체제가 무엇인지와 같은
노드에 대한 일반적인 정보가 기술된다.
이 정보는 Kubelet이 노드에서 수집하여
쿠버네티스 API로 전송한다.</p>
<h2 id=하트비트>하트비트</h2>
<p>쿠버네티스 노드가 보내는 하트비트는 클러스터가 개별 노드가 가용한지를
판단할 수 있도록 도움을 주고, 장애가 발견된 경우 조치를 할 수 있게한다.</p>
<p>노드에는 두 가지 형태의 하트비트가 있다.</p>
<ul>
<li>노드의 <code>.status</code>에 대한 업데이트</li>
<li><code>kube-node-lease</code>
<a class=glossary-tooltip title="쿠버네티스에서 동일한 물리 클러스터에서 다중의 가상 클러스터를 지원하기 위해 사용하는 추상화." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/overview/working-with-objects/namespaces target=_blank aria-label=네임스페이스>네임스페이스</a>
내의 <a href=/docs/reference/kubernetes-api/cluster-resources/lease-v1/>리스(Lease)</a>
오브젝트. 각 노드는 연관된 리스 오브젝트를 갖는다.</li>
</ul>
<p>노드의 <code>.status</code>에 비하면, 리스는 경량의 리소스이다.
큰 규모의 클러스터에서는 리스를 하트비트에 사용하여
업데이트로 인한 성능 영향을 줄일 수 있다.</p>
<p>kubelet은 노드의 <code>.status</code> 생성과 업데이트 및
관련된 리스의 업데이트를 담당한다.</p>
<ul>
<li>kubelet은 상태가 변경되거나 설정된 인터벌보다 오래 업데이트가 없는 경우
노드의 <code>.status</code>를 업데이트한다. 노드의 <code>.status</code> 업데이트에 대한 기본
인터벌은 접근이 불가능한 노드에 대한 타임아웃인
40초 보다 훨씬 긴 5분이다.</li>
<li>kubelet은 리스 오브젝트를 (기본 업데이트 인터벌인) 매 10초마다
생성하고 업데이트한다. 리스 업데이트는 노드의 <code>.status</code> 업데이트와는 독립적이다.
만약 리스 업데이트가 실패하면, kubelet은 200밀리초에서 시작하고
7초의 상한을 갖는 지수적 백오프를 사용해서 재시도한다.</li>
</ul>
<h3 id=노드-컨트롤러>노드 컨트롤러</h3>
<p>노드 <a class=glossary-tooltip title="API 서버를 통해 클러스터의 공유된 상태를 감시하고, 현재 상태를 원하는 상태로 이행시키는 컨트롤 루프." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/architecture/controller/ target=_blank aria-label=컨트롤러>컨트롤러</a>는
노드의 다양한 측면을 관리하는 쿠버네티스 컨트롤 플레인 컴포넌트이다.</p>
<p>노드 컨트롤러는 노드가 생성되어 유지되는 동안 다양한 역할을 한다. 첫째는 등록 시점에
(CIDR 할당이 사용토록 설정된 경우) 노드에 CIDR 블럭을 할당하는 것이다.</p>
<p>두 번째는 노드 컨트롤러의 내부 노드 리스트를 클라우드 제공사업자의
사용 가능한 머신 리스트 정보를 근거로 최신상태로 유지하는 것이다. 클라우드 환경에서
동작 중일 경우, 노드상태가 불량할 때마다, 노드 컨트롤러는
해당 노드용 VM이 여전히 사용 가능한지에 대해 클라우드 제공사업자에게 묻는다. 사용 가능하지 않을 경우,
노드 컨트롤러는 노드 리스트로부터 그 노드를 삭제한다.</p>
<p>세 번째는 노드의 동작 상태를 모니터링하는 것이다. 노드 컨트롤러는
다음을 담당한다.</p>
<ul>
<li>노드가 접근 불가능(unreachable) 상태가 되는 경우, 노드의 <code>.status</code>
내에 있는 NodeReady 컨디션을 업데이트한다.
이 경우에는 노드 컨트롤러가 NodeReady 컨디션을 <code>ConditionUnknown</code>으로 설정한다.</li>
<li>노드가 계속 접근 불가능 상태로 남아있는 경우, 해당 노드의 모든 파드에 대해서
<a href=/ko/docs/concepts/scheduling-eviction/api-eviction/>API를 이용한 축출</a>을
트리거한다. 기본적으로, 노드 컨트롤러는 노드를
<code>ConditionUnknown</code>으로 마킹한 뒤 5분을 기다렸다가
최초의 축출 요청을 시작한다.</li>
</ul>
<p>노드 컨트롤러는 매 <code>--node-monitor-period</code> 초 마다 각 노드의 상태를 체크한다.</p>
<h4 id=축출-빈도-한계>축출 빈도 한계</h4>
<p>대부분의 경우, 노드 컨트롤러는 초당 <code>--node-eviction-rate</code>(기본값 0.1)로
축출 속도를 제한한다. 이 말은 10초당 1개의 노드를 초과하여
파드 축출을 하지 않는다는 의미가 된다.</p>
<p>노드 축출 행위는 주어진 가용성 영역 내 하나의 노드가 상태가 불량할
경우 변화한다. 노드 컨트롤러는 영역 내 동시에 상태가 불량한 노드의 퍼센티지가 얼마나 되는지
체크한다(NodeReady 컨디션은 <code>ConditionUnknown</code> 또는
<code>ConditionFalse</code> 다).</p>
<ul>
<li>상태가 불량한 노드의 비율이 최소 <code>--unhealthy-zone-threshold</code>
(기본값 0.55)가 되면 축출 속도가 감소한다.</li>
<li>클러스터가 작으면 (즉 <code>--large-cluster-size-threshold</code>
노드 이하면 - 기본값 50) 축출이 중지된다.</li>
<li>이외의 경우, 축출 속도는 초당
<code>--secondary-node-eviction-rate</code>(기본값 0.01)로 감소된다.</li>
</ul>
<p>이 정책들이 가용성 영역 단위로 실행되어지는 이유는 나머지가 연결되어 있는 동안
하나의 가용성 영역이 마스터로부터 분할되어 질 수도 있기 때문이다.
만약 클러스터가 여러 클라우드 제공사업자의 가용성 영역에 걸쳐 있지 않는 이상,
축출 매커니즘은 영역 별 가용성을 고려하지 않는다.</p>
<p>노드가 가용성 영역들에 걸쳐 퍼져 있는 주된 이유는 하나의 전체 영역이
장애가 발생할 경우 워크로드가 상태 양호한 영역으로 이전되어질 수 있도록 하기 위해서이다.
그러므로, 하나의 영역 내 모든 노드들이 상태가 불량하면 노드 컨트롤러는
<code>--node-eviction-rate</code> 의 정상 속도로 축출한다. 코너 케이스란 모든 영역이
완전히 상태불량(클러스터 내 양호한 노드가 없는 경우)한 경우이다.
이러한 경우, 노드 컨트롤러는 컨트롤 플레인과 노드 간 연결에 문제가
있는 것으로 간주하고 축출을 실행하지 않는다. (중단 이후 일부 노드가
다시 보이는 경우 노드 컨트롤러는 상태가 양호하지 않거나 접근이 불가능한
나머지 노드에서 파드를 축출한다.)</p>
<p>또한, 노드 컨트롤러는 파드가 테인트를 허용하지 않을 때 <code>NoExecute</code> 테인트 상태의
노드에서 동작하는 파드에 대한 축출 책임을 가지고 있다.
추가로, 노드 컨틀로러는 연결할 수 없거나, 준비되지 않은 노드와 같은 노드 문제에 상응하는
<a class=glossary-tooltip title="세 가지 필수 속성: 키(key), 값(value), 효과(effect)로 구성된 코어 오브젝트. 테인트는 파드가 노드나 노드 그룹에 스케줄링되는 것을 방지한다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/scheduling-eviction/taint-and-toleration/ target=_blank aria-label=테인트>테인트</a>를 추가한다.
이는 스케줄러가 비정상적인 노드에 파드를 배치하지 않게 된다.</p>
<h2 id=node-capacity>리소스 용량 추적</h2>
<p>노드 오브젝트는 노드 리소스 용량에 대한 정보: 예를 들어, 사용 가능한 메모리의
양과 CPU의 수를 추적한다.
노드의 <a href=#%EB%85%B8%EB%93%9C%EC%97%90-%EB%8C%80%ED%95%9C-%EC%9E%90%EC%B2%B4-%EB%93%B1%EB%A1%9D>자체 등록</a>은 등록하는 중에 용량을 보고한다.
<a href=#%EC%88%98%EB%8F%99-%EB%85%B8%EB%93%9C-%EA%B4%80%EB%A6%AC>수동</a>으로 노드를 추가하는 경우 추가할 때
노드의 용량 정보를 설정해야 한다.</p>
<p>쿠버네티스 <a class=glossary-tooltip title="노드가 배정되지 않은 새로 생성된 파드를 감지하고, 실행할 노드를 선택하는 컨트롤 플레인 컴포넌트." data-toggle=tooltip data-placement=top href=/docs/reference/command-line-tools-reference/kube-scheduler/ target=_blank aria-label=스케줄러>스케줄러</a>는
노드 상에 모든 노드에 대해 충분한 리소스가 존재하도록 보장한다. 스케줄러는 노드 상에
컨테이너에 대한 요청의 합이 노드 용량보다 더 크지 않도록 체크한다.
요청의 합은 kubelet에서 관리하는 모든 컨테이너를 포함하지만, 컨테이너 런타임에
의해 직접적으로 시작된 컨 테이너는 제외되고 kubelet의 컨트롤 범위
밖에서 실행되는 모든 프로세스도 제외된다.</p>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> 파드 형태가 아닌 프로세스에 대해 명시적으로 리소스를 확보하려면,
<a href=/docs/tasks/administer-cluster/reserve-compute-resources/#system-reserved>시스템 데몬에 사용할 리소스 예약하기</a>을 본다.
</div>
<h2 id=노드-토폴로지>노드 토폴로지</h2>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.16 [alpha]</code>
</div>
<p><code>TopologyManager</code>
<a href=/ko/docs/reference/command-line-tools-reference/feature-gates/>기능 게이트(feature gate)</a>를
활성화 시켜두면, kubelet이 리소스 할당 결정을 할 때 토폴로지 힌트를 사용할 수 있다.
자세한 내용은
<a href=/docs/tasks/administer-cluster/topology-manager/>노드의 컨트롤 토폴로지 관리 정책</a>을 본다.</p>
<h2 id=graceful-node-shutdown>그레이스풀(Graceful) 노드 셧다운(shutdown)</h2>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.21 [beta]</code>
</div>
<p>kubelet은 노드 시스템 셧다운을 감지하고 노드에서 실행 중인 파드를 종료하려고 시도한다.</p>
<p>Kubelet은 노드가 종료되는 동안 파드가 일반 <a href=/ko/docs/concepts/workloads/pods/pod-lifecycle/#pod-termination>파드 종료 프로세스</a>를 따르도록 한다.</p>
<p>그레이스풀 노드 셧다운 기능은
<a href=https://www.freedesktop.org/wiki/Software/systemd/inhibit/>systemd inhibitor locks</a>를
사용하여 주어진 기간 동안 노드 종료를 지연시키므로 systemd에 의존한다.</p>
<p>그레이스풀 노드 셧다운은 1.21에서 기본적으로 활성화된 <code>GracefulNodeShutdown</code>
<a href=/ko/docs/reference/command-line-tools-reference/feature-gates/>기능 게이트</a>로
제어된다.</p>
<p>기본적으로, 아래 설명된 두 구성 옵션,
<code>shutdownGracePeriod</code> 및 <code>shutdownGracePeriodCriticalPods</code> 는 모두 0으로 설정되어 있으므로,
그레이스풀 노드 셧다운 기능이 활성화되지 않는다.
기능을 활성화하려면, 두 개의 kubelet 구성 설정을 적절하게 구성하고 0이 아닌 값으로 설정해야 한다.</p>
<p>그레이스풀 셧다운 중에 kubelet은 다음의 두 단계로 파드를 종료한다.</p>
<ol>
<li>노드에서 실행 중인 일반 파드를 종료시킨다.</li>
<li>노드에서 실행 중인 <a href=/ko/docs/tasks/administer-cluster/guaranteed-scheduling-critical-addon-pods/#%ED%8C%8C%EB%93%9C%EB%A5%BC-%EC%A4%91%EC%9A%94-critical-%EB%A1%9C-%ED%91%9C%EC%8B%9C%ED%95%98%EA%B8%B0>중요(critical) 파드</a>를 종료시킨다.</li>
</ol>
<p>그레이스풀 노드 셧다운 기능은 두 개의 <a href=/docs/tasks/administer-cluster/kubelet-config-file/><code>KubeletConfiguration</code></a> 옵션으로 구성된다.</p>
<ul>
<li><code>shutdownGracePeriod</code>:
<ul>
<li>노드가 종료를 지연해야 하는 총 기간을 지정한다. 이것은 모든 일반 및 <a href=/ko/docs/tasks/administer-cluster/guaranteed-scheduling-critical-addon-pods/#%ED%8C%8C%EB%93%9C%EB%A5%BC-%EC%A4%91%EC%9A%94-critical-%EB%A1%9C-%ED%91%9C%EC%8B%9C%ED%95%98%EA%B8%B0>중요 파드</a>의 파드 종료에 필요한 총 유예 기간에 해당한다.</li>
</ul>
</li>
<li><code>shutdownGracePeriodCriticalPods</code>:
<ul>
<li>노드 종료 중에 <a href=/ko/docs/tasks/administer-cluster/guaranteed-scheduling-critical-addon-pods/#%ED%8C%8C%EB%93%9C%EB%A5%BC-%EC%A4%91%EC%9A%94-critical-%EB%A1%9C-%ED%91%9C%EC%8B%9C%ED%95%98%EA%B8%B0>중요 파드</a>를 종료하는 데 사용되는 기간을 지정한다. 이 값은 <code>shutdownGracePeriod</code> 보다 작아야 한다.</li>
</ul>
</li>
</ul>
<p>예를 들어, <code>shutdownGracePeriod=30s</code>,
<code>shutdownGracePeriodCriticalPods=10s</code> 인 경우, kubelet은 노드 종료를 30초까지
지연시킨다. 종료하는 동안 처음 20(30-10)초는 일반 파드의
유예 종료에 할당되고, 마지막 10초는
<a href=/ko/docs/tasks/administer-cluster/guaranteed-scheduling-critical-addon-pods/#%ED%8C%8C%EB%93%9C%EB%A5%BC-%EC%A4%91%EC%9A%94-critical-%EB%A1%9C-%ED%91%9C%EC%8B%9C%ED%95%98%EA%B8%B0>중요 파드</a>의 종료에 할당된다.</p>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> <p>그레이스풀 노드 셧다운 과정에서 축출된 파드는 셧다운(shutdown)된 것으로 표시된다.
<code>kubectl get pods</code> 명령을 실행하면 축출된 파드의 상태가 <code>Terminated</code>으로 표시된다.
그리고 <code>kubectl describe pod</code> 명령을 실행하면 노드 셧다운으로 인해 파드가 축출되었음을 알 수 있다.</p>
<pre><code>Reason:         Terminated
Message:        Pod was terminated in response to imminent node shutdown.
</code></pre>
</div>
<h3 id=pod-priority-graceful-node-shutdown>파드 우선순위 기반 그레이스풀 노드 셧다운</h3>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.23 [alpha]</code>
</div>
<p>그레이스풀 노드 셧다운 시 파드 셧다운 순서에 더 많은 유연성을 제공할 수 있도록,
클러스터에 프라이어리티클래스(PriorityClass) 기능이 활성화되어 있으면
그레이스풀 노드 셧다운 과정에서 파드의 프라이어리티클래스가 고려된다.
이 기능으로 그레이스풀 노드 셧다운 시 파드가 종료되는 순서를 클러스터 관리자가
<a href=/ko/docs/concepts/scheduling-eviction/pod-priority-preemption/#%ED%94%84%EB%9D%BC%EC%9D%B4%EC%96%B4%EB%A6%AC%ED%8B%B0%ED%81%B4%EB%9E%98%EC%8A%A4>프라이어리티클래스</a>
기반으로 명시적으로 정할 수 있다.</p>
<p>위에서 기술된 것처럼, <a href=#graceful-node-shutdown>그레이스풀 노드 셧다운</a> 기능은 파드를
중요하지 않은(non-critical) 파드와
중요한(critical) 파드 2단계(phase)로 구분하여 종료시킨다.
셧다운 시 파드가 종료되는 순서를 명시적으로 더 상세하게 정해야 한다면,
파드 우선순위 기반 그레이스풀 노드 셧다운을 사용할 수 있다.</p>
<p>그레이스풀 노드 셧다운 과정에서 파드 우선순위가 고려되기 때문에,
그레이스풀 노드 셧다운이 여러 단계로 일어날 수 있으며,
각 단계에서 특정 프라이어리티 클래스의 파드를 종료시킨다.
정확한 단계와 단계별 셧다운 시간은 kubelet에 설정할 수 있다.</p>
<p>다음과 같이 클러스터에 커스텀 파드
<a href=/ko/docs/concepts/scheduling-eviction/pod-priority-preemption/#%ED%94%84%EB%9D%BC%EC%9D%B4%EC%96%B4%EB%A6%AC%ED%8B%B0%ED%81%B4%EB%9E%98%EC%8A%A4>프라이어리티 클래스</a>가 있다고
가정하자.</p>
<table>
<thead>
<tr>
<th>파드 프라이어리티 클래스 이름</th>
<th>파드 프라이어리티 클래스 값</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>custom-class-a</code></td>
<td>100000</td>
</tr>
<tr>
<td><code>custom-class-b</code></td>
<td>10000</td>
</tr>
<tr>
<td><code>custom-class-c</code></td>
<td>1000</td>
</tr>
<tr>
<td><code>regular/unset</code></td>
<td>0</td>
</tr>
</tbody>
</table>
<p><a href=/docs/reference/config-api/kubelet-config.v1beta1/#kubelet-config-k8s-io-v1beta1-KubeletConfiguration>kubelet 환경 설정</a> 안의
<code>shutdownGracePeriodByPodPriority</code> 설정은 다음과 같을 수 있다.</p>
<table>
<thead>
<tr>
<th>파드 프라이어리티 클래스 값</th>
<th>종료 대기 시간</th>
</tr>
</thead>
<tbody>
<tr>
<td>100000</td>
<td>10 seconds</td>
</tr>
<tr>
<td>10000</td>
<td>180 seconds</td>
</tr>
<tr>
<td>1000</td>
<td>120 seconds</td>
</tr>
<tr>
<td>0</td>
<td>60 seconds</td>
</tr>
</tbody>
</table>
<p>이를 나타내는 kubelet 환경 설정 YAML은 다음과 같다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>shutdownGracePeriodByPodPriority</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>priority</span>:<span style=color:#bbb> </span><span style=color:#666>100000</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>shutdownGracePeriodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>10</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>priority</span>:<span style=color:#bbb> </span><span style=color:#666>10000</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>shutdownGracePeriodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>180</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>priority</span>:<span style=color:#bbb> </span><span style=color:#666>1000</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>shutdownGracePeriodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>120</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>priority</span>:<span style=color:#bbb> </span><span style=color:#666>0</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>shutdownGracePeriodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>60</span><span style=color:#bbb>
</span></code></pre></div><p>위의 표에 의하면 우선순위 값이 100000 이상인 파드는 종료까지 10초만 주어지며,
10000 이상 ~ 100000 미만이면 180초,
1000 이상 ~ 10000 미만이면 120초가 주어진다.
마지막으로, 다른 모든 파드는 종료까지 60초가 주어질 것이다.</p>
<p>모든 클래스에 대해 값을 명시할 필요는 없다.
예를 들어, 대신 다음과 같은 구성을 사용할 수도 있다.</p>
<table>
<thead>
<tr>
<th>파드 프라이어리티 클래스 값</th>
<th>종료 대기 시간</th>
</tr>
</thead>
<tbody>
<tr>
<td>100000</td>
<td>300 seconds</td>
</tr>
<tr>
<td>1000</td>
<td>120 seconds</td>
</tr>
<tr>
<td>0</td>
<td>60 seconds</td>
</tr>
</tbody>
</table>
<p>위의 경우, custom-class-b에 속하는 파드와 custom-class-c에 속하는 파드는
동일한 종료 대기 시간을 갖게 될 것이다.</p>
<p>특정 범위에 해당되는 파드가 없으면,
kubelet은 해당 범위에 해당되는 파드를 위해 기다려 주지 않는다.
대신, kubelet은 즉시 다음 프라이어리티 클래스 값 범위로 넘어간다.</p>
<p>기능이 활성화되어 있지만 환경 설정이 되어 있지 않으면,
순서 지정 동작이 수행되지 않을 것이다.</p>
<p>이 기능을 사용하려면 <code>GracefulNodeShutdownBasedOnPodPriority</code> 기능 게이트를 활성화해야 하고,
kubelet 환경 설정의 <code>ShutdownGracePeriodByPodPriority</code>를
파드 프라이어리티 클래스 값과
각 값에 대한 종료 대기 시간을 명시하여 지정해야 한다.</p>
<h2 id=swap-memory>스왑(swap) 메모리 관리</h2>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.22 [alpha]</code>
</div>
<p>쿠버네티스 1.22 이전에는 노드가 스왑 메모리를 지원하지 않았다. 그리고
kubelet은 노드에서 스왑을 발견하지 못한 경우 시작과 동시에 실패하도록 되어 있었다.
1.22부터는 스왑 메모리 지원을 노드 단위로 활성화할 수 있다.</p>
<p>노드에서 스왑을 활성화하려면, <code>NodeSwap</code> 기능 게이트가 kubelet에서
활성화되어야 하며, 명령줄 플래그 <code>--fail-swap-on</code> 또는
<a href=/docs/reference/config-api/kubelet-config.v1beta1/#kubelet-config-k8s-io-v1beta1-KubeletConfiguration>구성 설정</a>에서 <code>failSwapOn</code>가
false로 지정되어야 한다.</p>
<div class="alert alert-danger warning callout" role=alert>
<strong>경고:</strong> 메모리 스왑 기능이 활성화되면, 시크릿 오브젝트의 내용과 같은
tmpfs에 기록되었던 쿠버네티스 데이터가 디스크에 스왑될 수 있다.
</div>
<p>사용자는 또한 선택적으로 <code>memorySwap.swapBehavior</code>를 구성할 수 있으며,
이를 통해 노드가 스왑 메모리를 사용하는 방식을 명시한다. 예를 들면,</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>memorySwap</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>swapBehavior</span>:<span style=color:#bbb> </span>LimitedSwap<span style=color:#bbb>
</span></code></pre></div><p><code>swapBehavior</code>에 가용한 구성 옵션은 다음과 같다.</p>
<ul>
<li><code>LimitedSwap</code>: 쿠버네티스 워크로드는 스왑을 사용할 수 있는 만큼으로
제한된다. 쿠버네티스에 의해 관리되지 않는 노드의 워크로드는 여전히 스왑될 수 있다.</li>
<li><code>UnlimitedSwap</code>: 쿠버네티스 워크로드는 요청한 만큼 스왑 메모리를 사용할 수 있으며,
시스템의 최대치까지 사용 가능하다.</li>
</ul>
<p>만약 <code>memorySwap</code> 구성이 명시되지 않았고 기능 게이트가 활성화되어 있다면,
kubelet은 <code>LimitedSwap</code> 설정과 같은 행동을
기본적으로 적용한다.</p>
<p><code>LimitedSwap</code> 설정에 대한 행동은 노드가 ("cgroups"으로 알려진)
제어 그룹이 v1 또는 v2 중에서 무엇으로 동작하는가에 따라서 결정된다.</p>
<ul>
<li><strong>cgroupsv1:</strong> 쿠버네티스 워크로드는 메모리와 스왑의 조합을 사용할 수 있다.
파드의 메모리 제한이 설정되어 있다면 가용 상한이 된다.</li>
<li><strong>cgroupsv2:</strong> 쿠버네티스 워크로드는 스왑 메모리를 사용할 수 없다.</li>
</ul>
<p>테스트를 지원하고 피드벡을 제공하기 위한 정보는
<a href=https://github.com/kubernetes/enhancements/issues/2400>KEP-2400</a> 및
<a href=https://github.com/kubernetes/enhancements/blob/master/keps/sig-node/2400-node-swap/README.md>디자인 제안</a>에서 찾을 수 있다.</p>
<h2 id=다음-내용>다음 내용</h2>
<ul>
<li>노드를 구성하는 <a href=/ko/docs/concepts/overview/components/#%EB%85%B8%EB%93%9C-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8>컴포넌트</a>에 대해 알아본다.</li>
<li><a href=/docs/reference/generated/kubernetes-api/v1.23/#node-v1-core>노드에 대한 API 정의</a>를 읽어본다.</li>
<li>아키텍처 디자인 문서의 <a href=https://git.k8s.io/community/contributors/design-proposals/architecture/architecture.md#the-kubernetes-node>노드</a>
섹션을 읽어본다.</li>
<li><a href=/ko/docs/concepts/scheduling-eviction/taint-and-toleration/>테인트와 톨러레이션</a>을 읽어본다.</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-c0251def6da29b30afebfb04549f1703>2.2 - 컨트롤 플레인-노드 간 통신</h1>
<p>이 문서는 컨트롤 플레인(API 서버)과 쿠버네티스 클러스터 사이에 대한 통신 경로의 목록을 작성한다. 이는 사용자가 신뢰할 수 없는 네트워크(또는 클라우드 공급자의 완전한 퍼블릭 IP)에서 클러스터를 실행할 수 있도록 네트워크 구성을 강화하기 위한 맞춤 설치를 할 수 있도록 한다.</p>
<h2 id=노드에서-컨트롤-플레인으로의-통신>노드에서 컨트롤 플레인으로의 통신</h2>
<p>쿠버네티스에는 "허브 앤 스포크(hub-and-spoke)" API 패턴을 가지고 있다. 노드(또는 노드에서 실행되는 파드들)의 모든 API 사용은 API 서버에서 종료된다. 다른 컨트롤 플레인 컴포넌트 중 어느 것도 원격 서비스를 노출하도록 설계되지 않았다. API 서버는 하나 이상의 클라이언트 <a href=/docs/reference/access-authn-authz/authentication/>인증</a> 형식이 활성화된 보안 HTTPS 포트(일반적으로 443)에서 원격 연결을 수신하도록 구성된다.</p>
<p>특히 <a href=/docs/reference/access-authn-authz/authentication/#anonymous-requests>익명의 요청</a> 또는 <a href=/docs/reference/access-authn-authz/authentication/#service-account-tokens>서비스 어카운트 토큰</a>이 허용되는 경우, 하나 이상의 <a href=/ko/docs/reference/access-authn-authz/authorization/>권한 부여</a> 형식을 사용해야 한다.</p>
<p>노드는 유효한 클라이언트 자격 증명과 함께 API 서버에 안전하게 연결할 수 있도록 클러스터에 대한 공개 루트 인증서로 프로비전해야 한다. 예를 들어, 기본 GKE 배포에서, kubelet에 제공되는 클라이언트 자격 증명은 클라이언트 인증서 형식이다. kubelet 클라이언트 인증서의 자동 프로비저닝은 <a href=/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/>kubelet TLS 부트스트랩</a>을 참고한다.</p>
<p>API 서버에 연결하려는 파드는 쿠버네티스가 공개 루트 인증서와 유효한 베어러 토큰(bearer token)을 파드가 인스턴스화될 때 파드에 자동으로 주입하도록 서비스 어카운트를 활용하여 안전하게 연결할 수 있다.
<code>kubernetes</code> 서비스(<code>default</code> 네임스페이스의)는 API 서버의 HTTPS 엔드포인트로 리디렉션되는 가상 IP 주소(kube-proxy를 통해)로 구성되어 있다.</p>
<p>컨트롤 플레인 컴포넌트는 보안 포트를 통해 클러스터 API 서버와도 통신한다.</p>
<p>결과적으로, 노드 및 노드에서 실행되는 파드에서 컨트롤 플레인으로 연결하기 위한 기본 작동 모드는 기본적으로 보호되며 신뢰할 수 없는 네트워크 및/또는 공용 네트워크에서 실행될 수 있다.</p>
<h2 id=컨트롤-플레인에서-노드로의-통신>컨트롤 플레인에서 노드로의 통신</h2>
<p>컨트롤 플레인(API 서버)에서 노드로는 두 가지 기본 통신 경로가 있다. 첫 번째는 API 서버에서 클러스터의 각 노드에서 실행되는 kubelet 프로세스이다. 두 번째는 API 서버의 프록시 기능을 통해 API 서버에서 모든 노드, 파드 또는 서비스에 이르는 것이다.</p>
<h3 id=api-서버에서-kubelet으로의-통신>API 서버에서 kubelet으로의 통신</h3>
<p>API 서버에서 kubelet으로의 연결은 다음의 용도로 사용된다.</p>
<ul>
<li>파드에 대한 로그를 가져온다.</li>
<li>실행 중인 파드에 (kubectl을 통해) 연결한다.</li>
<li>kubelet의 포트-포워딩 기능을 제공한다.</li>
</ul>
<p>이 연결은 kubelet의 HTTPS 엔드포인트에서 종료된다. 기본적으로, API 서버는 kubelet의 서빙(serving) 인증서를 확인하지 않으므로, 연결이 중간자(man-in-the-middle) 공격의 대상이 되며, 신뢰할 수 없는 네트워크 및/또는 공용 네트워크에서 실행하기에 <strong>안전하지 않다</strong> .</p>
<p>이 연결을 확인하려면, <code>--kubelet-certificate-authority</code> 플래그를 사용하여 API 서버에 kubelet의 서빙 인증서를 확인하는 데 사용할 루트 인증서 번들을 제공한다.</p>
<p>이것이 가능하지 않은 경우, 신뢰할 수 없는 네트워크 또는 공용 네트워크를 통한 연결을 피하기 위해 필요한 경우 API 서버와 kubelet 사이에 <a href=#ssh-%ED%84%B0%EB%84%90>SSH 터널링</a>을
사용한다.</p>
<p>마지막으로, kubelet API를 보호하려면 <a href=/ko/docs/reference/command-line-tools-reference/kubelet-authentication-authorization/>Kubelet 인증 및/또는 권한 부여</a>를 활성화해야 한다.</p>
<h3 id=api-서버에서-노드-파드-및-서비스로의-통신>API 서버에서 노드, 파드 및 서비스로의 통신</h3>
<p>API 서버에서 노드, 파드 또는 서비스로의 연결은 기본적으로 일반 HTTP 연결로 연결되므로 인증되거나 암호화되지 않는다. API URL에서 노드, 파드 또는 서비스 이름을 접두어 <code>https:</code> 로 사용하여 보안 HTTPS 연결을 통해 실행될 수 있지만, HTTPS 엔드포인트가 제공한 인증서의 유효성을 검증하지 않거나 클라이언트 자격 증명을 제공하지 않는다. 그래서 연결이 암호화되는 동안 무결성을 보장하지 않는다. 이러한 연결은 신뢰할 수 없는 네트워크 및/또는 공용 네트워크에서 실행하기에 <strong>현재는 안전하지 않다</strong> .</p>
<h3 id=ssh-터널>SSH 터널</h3>
<p>쿠버네티스는 SSH 터널을 지원하여 컨트롤 플레인에서 노드로의 통신 경로를 보호한다. 이 구성에서, API 서버는 클러스터의 각 노드에 SSH 터널을 시작하고(포트 22에서 수신 대기하는 ssh 서버에 연결) 터널을 통해 kubelet, 노드, 파드 또는 서비스로 향하는 모든 트래픽을 전달한다.
이 터널은 트래픽이 노드가 실행 중인 네트워크 외부에 노출되지 않도록 한다.</p>
<p>SSH 터널은 현재 더 이상 사용되지 않으므로, 수행 중인 작업이 어떤 것인지 모른다면 사용하면 안된다. Konnectivity 서비스는 이 통신 채널을 대체한다.</p>
<h3 id=konnectivity-서비스>Konnectivity 서비스</h3>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.18 [beta]</code>
</div>
<p>SSH 터널을 대체하는 Konnectivity 서비스는 컨트롤 플레인에서 클러스터 통신에 TCP 레벨 프록시를 제공한다. Konnectivity 서비스는 컨트롤 플레인 네트워크의 Konnectivity 서버와 노드 네트워크의 Konnectivity 에이전트, 두 부분으로 구성된다. Konnectivity 에이전트는 Konnectivity 서버에 대한 연결을 시작하고 네트워크 연결을 유지한다.
Konnectivity 서비스를 활성화한 후, 모든 컨트롤 플레인에서 노드로의 트래픽은 이 연결을 통과한다.</p>
<p><a href=/ko/docs/tasks/extend-kubernetes/setup-konnectivity/>Konnectivity 서비스 태스크</a>에 따라 클러스터에서 Konnectivity 서비스를 설정한다.</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-ca8819042a505291540e831283da66df>2.3 - 컨트롤러</h1>
<p>로보틱스와 자동화에서 <em>컨트롤 루프</em> 는
시스템 상태를 조절하는 종료되지 않는 루프이다.</p>
<p>컨트롤 루프의 예시: 실내 온도 조절기</p>
<p>사용자는 온도를 설정해서, 사용자가 <em>의도한 상태</em> 를
온도 조절기에 알려준다.
<em>현재 상태</em> 이다. 온도 조절기는 장비를 켜거나 꺼서
현재 상태를 의도한 상태에 가깝게 만든다.</p>
쿠버네티스에서 컨트롤러는 <a class=glossary-tooltip title="컨테이너화된 애플리케이션을 실행하는 노드라고 하는 워커 머신의 집합. 모든 클러스터는 최소 한 개의 워커 노드를 가진다." data-toggle=tooltip data-placement=top href="/ko/docs/reference/glossary/?all=true#term-cluster" target=_blank aria-label=클러스터>클러스터</a>
의 상태를 관찰 한 다음, 필요한 경우에 생성 또는 변경을
요청하는 컨트롤 루프이다.
각 컨트롤러는 현재 클러스터 상태를 의도한 상태에 가깝게
이동한다.
<h2 id=컨트롤러-패턴>컨트롤러 패턴</h2>
<p>컨트롤러는 적어도 하나 이상의 쿠버네티스 리소스 유형을 추적한다.
이 <a href=/ko/docs/concepts/overview/working-with-objects/kubernetes-objects/#kubernetes-objects>오브젝트</a>
는 의도한 상태를 표현하는 사양 필드를 가지고 있다.
해당 리소스의 컨트롤러(들)은 현재 상태를 의도한
상태에 가깝게 만드는 역할을 한다.</p>
<p>컨트롤러는 스스로 작업을 수행할 수 있다. 보다 일반적으로,
쿠버네티스에서는 컨트롤러가
<a class=glossary-tooltip title="쿠버네티스 API를 제공하는 컨트롤 플레인 컴포넌트." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/overview/components/#kube-apiserver target=_blank aria-label="API 서버">API 서버</a> 로
유용한 부수적인 효과가 있는 메시지를 발송한다. 그 예시는 아래에서 볼 수 있다.</p>
<h3 id=api-서버를-통한-제어>API 서버를 통한 제어</h3>
<p><a class=glossary-tooltip title="완료를 목표로 실행되는 유한 또는 배치 작업." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/controllers/job/ target=_blank aria-label=잡(Job)>잡(Job)</a> 컨트롤러는 쿠버네티스
내장 컨트롤러의 예시이다. 내장 컨트롤러는 클러스터 API 서버와
상호 작용하며 상태를 관리한다.</p>
<p>잡은 단일 <a class=glossary-tooltip title="파드는 클러스터에서 실행 중인 컨테이너의 집합을 나타낸다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/pods/ target=_blank aria-label=파드>파드</a> 또는 여러 파드를 실행하고,
작업을 수행한 다음 중지하는
쿠버네티스 리소스 이다.</p>
<p>(일단 <a href=/ko/docs/concepts/scheduling-eviction/>스케줄되면</a>, 파드 오브젝트는 kubelet
의 의도한 상태 중 일부가 된다.)</p>
<p>잡 컨트롤러가 새로운 작업을 확인하면, 클러스터 어딘가에서
노드 집합의 kubelet이 작업을 수행하기에 적합한
수의 파드를 실행하게 한다.
잡 컨트롤러는 어떤 파드 또는 컨테이너를 스스로 실행하지 않는다.
대신, 잡 컨트롤러는 API 서버에 파드를 생성하거나 삭제하도록
지시한다.
<a class=glossary-tooltip title="컨테이너의 라이프사이클을 정의, 배포, 관리하기 위한 API와 인터페이스들을 노출하는 컨테이너 오케스트레이션 레이어." data-toggle=tooltip data-placement=top href="/ko/docs/reference/glossary/?all=true#term-control-plane" target=_blank aria-label="컨트롤 플레인">컨트롤 플레인</a>의
다른 컴포넌트는 신규 정보
(예약 및 실행해야 하는 새 파드가 있다는 정보)에 대응하여,
결국 해당 작업을 완료시킨다.</p>
<p>새 잡을 생성하고 나면, 의도한 상태는 해당 잡을 완료하는 것이 된다.
잡 컨트롤러는 현재 상태를 의도한 상태에 가깝게
만들며, 사용자가 원하는 잡을 수행하기 위해 파드를 생성해서
잡이 완료에 가까워 지도록 한다.</p>
<p>또한, 컨트롤러는 오브젝트의 설정을 업데이트 한다.
예시: 잡을 위한 작업이 종료된 경우, 잡 컨트롤러는
잡 오브젝트가 <code>Finished</code> 로 표시되도록 업데이트한다.</p>
<p>(이것은 지금 방 온도가 설정한 온도인 것을 표시하기
위해 실내 온도 조절기의 빛을 끄는 것과 약간 비슷하다).</p>
<h3 id=직접-제어>직접 제어</h3>
<p>잡과는 대조적으로, 일부 컨트롤러는 클러스터 외부의 것을
변경해야 할 필요가 있다.</p>
<p>예를 들어, 만약 컨트롤 루프를 사용해서
클러스터에 충분한 <a class=glossary-tooltip title="노드는 쿠버네티스의 작업 장비(worker machine)이다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/architecture/nodes/ target=_blank aria-label=노드들>노드들</a>이
있도록 만드는 경우, 해당 컨트롤러는 필요할 때 새 노드를 설정할 수 있도록
현재 클러스터 외부의 무언가를 필요로 한다.</p>
<p>외부 상태와 상호 작용하는 컨트롤러는 API 서버에서 의도한
상태를 찾은 다음, 외부 시스템과 직접 통신해서
현재 상태를 보다 가깝게 만든다.</p>
<p>(실제로 클러스터의 노드를 수평으로 확장하는
<a href=https://github.com/kubernetes/autoscaler/>컨트롤러</a>가 있다.)</p>
<p>여기서 중요한 점은 컨트롤러가 의도한 상태를 가져오기 위해 약간의 변화를 주고,
현재 상태를 클러스터의 API 서버에 다시 보고한다는 것이다.
다른 컨트롤 루프는 보고된 데이터를 관찰하고 자체 조치를 할 수 있다.</p>
<p>온도 조절기 예에서 방이 매우 추우면 다른 컨트롤러가
서리 방지 히터를 켤 수도 있다. 쿠버네티스 클러스터에서는
<a href=/ko/docs/concepts/extend-kubernetes/>쿠버네티스 확장</a>을 통해
IP 주소 관리 도구, 스토리지 서비스, 클라우드 제공자의 API 및
기타 서비스 등과 간접적으로 연동하여 이를 구현한다.</p>
<h2 id=desired-vs-current>의도한 상태와 현재 상태</h2>
<p>쿠버네티스는 클라우드-네이티브 관점에서 시스템을 관찰하며, 지속적인
변화에 대응할 수 있다.</p>
<p>작업이 발생함에 따라 어떤 시점에서든 클러스터가
변경 될 수 있으며 컨트롤 루프가 자동으로 실패를 바로잡는다. 이는 잠재적으로,
클러스터가 안정적인 상태에 도달하지 못하는 것을 의미한다.</p>
<p>클러스터의 컨트롤러가 실행 중이고 유용한 변경을 수행할 수 있는 한,
전체 상태가 안정적인지 아닌지는 중요하지 않다.</p>
<h2 id=디자인>디자인</h2>
<p>디자인 원리에 따라, 쿠버네티스는 클러스터 상태의 각 특정 측면을
관리하는 많은 컨트롤러를 사용한다. 가장 일반적으로, 특정 컨트롤 루프
(컨트롤러)는 의도한 상태로서 한 종류의 리소스를 사용하고, 의도한 상태로
만들기 위해 다른 종류의 리소스를 관리한다. 예를 들어, 잡 컨트롤러는
잡 오브젝트(새 작업을 발견하기 위해)와 파드 오브젝트(잡을 실행하고, 완료된 시기를
확인하기 위해)를 추적한다. 이 경우 파드는 잡 컨트롤러가 생성하는 반면,
잡은 다른 컨트롤러가 생성한다.</p>
<p>컨트롤 루프들로 연결 구성된 하나의 모놀리식(monolithic) 집합보다,
간단한 컨트롤러를 여러 개 사용하는 것이 유용하다. 컨트롤러는 실패할 수 있으므로, 쿠버네티스는 이를
허용하도록 디자인되었다.</p>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> <p>동일한 종류의 오브젝트를 만들거나 업데이트하는 여러 컨트롤러가 있을 수 있다.
이면에, 쿠버네티스 컨트롤러는 컨트롤 하고 있는 리소스에
연결된 리소스에만 주의를 기울인다.</p>
<p>예를 들어, 디플로이먼트와 잡을 가지고 있다. 이 두 가지 모두 파드를 생성한다.
잡 컨트롤러는 디플로이먼트가 생성한 파드를 삭제하지 않는다.
이는 컨트롤러가 해당 파드를 구별하기 위해 사용할 수 있는
정보(<a class=glossary-tooltip title="사용자에게 의미 있고 관련성 높은 특징으로 식별할 수 있도록 오브젝트에 태그를 붙인다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/overview/working-with-objects/labels target=_blank aria-label=레이블>레이블</a>)가 있기 때문이다.</p>
</div>
<h2 id=running-controllers>컨트롤러를 실행하는 방법</h2>
<p>쿠버네티스에는 <a class=glossary-tooltip title="컨트롤러 프로세스를 실행하는 컨트롤 플레인 컴포넌트." data-toggle=tooltip data-placement=top href=/docs/reference/command-line-tools-reference/kube-controller-manager/ target=_blank aria-label=kube-controller-manager>kube-controller-manager</a>
내부에서 실행되는 내장된 컨트롤러 집합이 있다. 이
내장 컨트롤러는 중요한 핵심 동작을 제공한다.</p>
<p>디플로이먼트 컨트롤러와 잡 컨트롤러는 쿠버네티스의
자체("내장" 컨트롤러)로 제공되는 컨트롤러 예시이다.
쿠버네티스를 사용하면 복원력이 뛰어난 컨트롤 플레인을 실행할 수 있으므로,
어떤 내장 컨트롤러가 실패하더라도 다른 컨트롤 플레인의 일부가 작업을 이어서 수행한다.</p>
<p>컨트롤 플레인의 외부에서 실행하는 컨트롤러를 찾아서 쿠버네티스를 확장할 수 있다.
또는, 원하는 경우 새 컨트롤러를 직접 작성할 수 있다.
소유하고 있는 컨트롤러를 파드 집합으로서 실행하거나,
또는 쿠버네티스 외부에서 실행할 수 있다. 가장 적합한 것은 특정 컨트롤러의 기능에
따라 달라진다.</p>
<h2 id=다음-내용>다음 내용</h2>
<ul>
<li><a href=/ko/docs/concepts/overview/components/#%EC%BB%A8%ED%8A%B8%EB%A1%A4-%ED%94%8C%EB%A0%88%EC%9D%B8-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8>쿠버네티스 컨트롤 플레인</a>에 대해 읽기</li>
<li><a href=/ko/docs/concepts/overview/working-with-objects/kubernetes-objects/>쿠버네티스 오브젝트</a>의 몇 가지 기본 사항을 알아보자.</li>
<li><a href=/ko/docs/concepts/overview/kubernetes-api/>쿠버네티스 API</a>에 대해 더 배워 보자.</li>
<li>만약 자신만의 컨트롤러를 작성하기 원한다면,
쿠버네티스 확장하기의 <a href=/ko/docs/concepts/extend-kubernetes/#%EC%9D%B5%EC%8A%A4%ED%85%90%EC%85%98-%ED%8C%A8%ED%84%B4>확장 패턴</a>을
본다.</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-bc804b02614d67025b4c788f1ca87fbc>2.4 - 클라우드 컨트롤러 매니저</h1>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.11 [beta]</code>
</div>
<p>클라우드 인프라스트럭쳐 기술을 통해 퍼블릭, 프라이빗 그리고 하이브리드 클라우드에서 쿠버네티스를 실행할 수 있다.
쿠버네티스는 컴포넌트간의 긴밀한 결합 없이 자동화된 API 기반의 인프라스트럭쳐를
신뢰한다.</p>
<p><p>클라우드 컨트롤러 매니저는 클라우드별 컨트롤 로직을 포함하는 쿠버네티스
<a class=glossary-tooltip title="컨테이너의 라이프사이클을 정의, 배포, 관리하기 위한 API와 인터페이스들을 노출하는 컨테이너 오케스트레이션 레이어." data-toggle=tooltip data-placement=top href="/ko/docs/reference/glossary/?all=true#term-control-plane" target=_blank aria-label="컨트롤 플레인">컨트롤 플레인</a> 컴포넌트이다.
클라우드 컨트롤러 매니저를 통해 클러스터를 클라우드 공급자의 API에 연결하고,
해당 클라우드 플랫폼과 상호 작용하는 컴포넌트와 클러스터와만 상호 작용하는 컴포넌트를 구분할 수 있게 해 준다.</p></p>
<p>쿠버네티스와 기본 클라우드 인프라스터럭처 간의 상호 운용성 로직을
분리함으로써, cloud-controller-manager 컴포넌트는 클라우드 공급자가
주요 쿠버네티스 프로젝트와 다른 속도로 기능들을 릴리스할 수 있도록 한다.</p>
<p>클라우드 컨트롤러 매니저는 다양한 클라우드 공급자가 자신의
플랫폼에 쿠버네티스를 통합할 수 있도록 하는 플러그인 메커니즘을 사용해서 구성된다.</p>
<h2 id=디자인>디자인</h2>
<p><img src=/images/docs/components-of-kubernetes.svg alt="쿠버네티스 컴포넌트"></p>
<p>클라우드 컨트롤러 매니저는 컨트롤 플레인에서 복제된 프로세스의 집합으로 실행된다(일반적으로,
파드의 컨테이너). 각 클라우드 컨트롤러 매니저는 단일
프로세스에 여러 <a class=glossary-tooltip title="API 서버를 통해 클러스터의 공유된 상태를 감시하고, 현재 상태를 원하는 상태로 이행시키는 컨트롤 루프." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/architecture/controller/ target=_blank aria-label=컨트롤러>컨트롤러</a>를
구현한다.</p>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> 또한 사용자는 클라우드 컨트롤러 매니저를 컨트롤 플레인의 일부가 아닌 쿠버네티스
<a class=glossary-tooltip title="Resources that extend the functionality of Kubernetes." data-toggle=tooltip data-placement=top href=/docs/concepts/cluster-administration/addons/ target=_blank aria-label=애드온>애드온</a>으로
실행할 수도 있다.
</div>
<h2 id=functions-of-the-ccm>클라우드 컨트롤러 매니저의 기능</h2>
<p>클라우드 컨틀롤러 매니저의 내부 컨트롤러에는 다음 컨트롤러들이 포함된다.</p>
<h3 id=노드-컨트롤러>노드 컨트롤러</h3>
<p>노드 컨트롤러는 클라우드 인프라스트럭처에 새 서버가 생성될 때 <a class=glossary-tooltip title="노드는 쿠버네티스의 작업 장비(worker machine)이다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/architecture/nodes/ target=_blank aria-label=노드>노드</a>
오브젝트를 업데이트하는 역할을 한다. 노드 컨트롤러는 클라우드 공급자의 사용자
테넌시 내에서 실행되는 호스트에 대한 정보를 가져온다. 노드 컨트롤러는 다음 기능들을 수행한다.</p>
<ol>
<li>클라우드 공급자 API를 통해 획득한 해당 서버의 고유 ID를 노드 오브젝트에 업데이트한다.</li>
<li>클라우드 관련 정보(예를 들어, 노드가 배포되는 지역과 사용 가능한 리소스(CPU, 메모리 등))를
사용해서 노드 오브젝트에 어노테이션과 레이블을 작성한다.</li>
<li>노드의 호스트 이름과 네트워크 주소를 가져온다.</li>
<li>노드의 상태를 확인한다. 노드가 응답하지 않는 경우, 이 컨트롤러는 사용자가
이용하는 클라우드 공급자의 API를 통해 서버가 비활성화됨 / 삭제됨 / 종료됨인지 확인한다.
노드가 클라우드에서 삭제된 경우, 컨트롤러는 사용자의 쿠버네티스 클러스터에서 노드
오브젝트를 삭제한다.</li>
</ol>
<p>일부 클라우드 공급자의 구현에서는 이를 노드 컨트롤러와 별도의 노드
라이프사이클 컨트롤러로 분리한다.</p>
<h3 id=라우트-컨트롤러>라우트 컨트롤러</h3>
<p>라우트 컨트롤러는 사용자의 쿠버네티스 클러스터의 다른 노드에
있는 각각의 컨테이너가 서로 통신할 수 있도록 클라우드에서
라우트를 적절히 구성해야 한다.</p>
<p>클라우드 공급자에 따라 라우트 컨트롤러는 파드 네트워크
IP 주소 블록을 할당할 수도 있다.</p>
<h3 id=서비스-컨트롤러>서비스 컨트롤러</h3>
<p><a class=glossary-tooltip title="네트워크 서비스로 파드 집합에서 실행 중인 애플리케이션을 노출하는 방법" data-toggle=tooltip data-placement=top href=/ko/docs/concepts/services-networking/service/ target=_blank aria-label=서비스>서비스</a> 는 관리형 로드 밸런서,
IP 주소, 네트워크 패킷 필터링 그리고 대상 상태 확인과 같은
클라우드 인프라스트럭처 컴포넌트와 통합된다. 서비스 컨트롤러는 사용자의 클라우드
공급자 API와 상호 작용해서 필요한 서비스 리소스를 선언할 때
로드 밸런서와 기타 인프라스트럭처 컴포넌트를 설정한다.</p>
<h2 id=인가>인가</h2>
<p>이 섹션에서는 클라우드 컨트롤러 매니저가 작업을 수행하기 위해
다양한 API 오브젝트에 필요한 접근 권한을 세분화한다.</p>
<h3 id=authorization-node-controller>노드 컨트롤러</h3>
<p>노드 컨트롤러는 노드 오브젝트에서만 작동한다. 노드 오브젝트를 읽고,
수정하려면 전체 접근 권한이 필요하다.</p>
<p><code>v1/Node</code>:</p>
<ul>
<li>Get</li>
<li>List</li>
<li>Create</li>
<li>Update</li>
<li>Patch</li>
<li>Watch</li>
<li>Delete</li>
</ul>
<h3 id=authorization-route-controller>라우트 컨트롤러</h3>
<p>라우트 컨트롤러가 노드 오브젝트의 생성을 수신하고 적절하게
라우트를 구성한다. 노드 오브젝트에 대한 접근 권한이 필요하다.</p>
<p><code>v1/Node</code>:</p>
<ul>
<li>Get</li>
</ul>
<h3 id=authorization-service-controller>서비스 컨트롤러</h3>
<p>서비스 컨트롤러는 서비스 오브젝트 생성, 업데이트 그리고 삭제 이벤트를 수신한 다음 해당 서비스에 대한 엔드포인트를 적절하게 구성한다.</p>
<p>서비스에 접근하려면, 목록과 감시 접근 권한이 필요하다. 서비스를 업데이트하려면, 패치와 업데이트 접근 권한이 필요하다.</p>
<p>서비스에 대한 엔드포인트 리소스를 설정하려면 생성, 목록, 가져오기, 감시 그리고 업데이트에 대한 접근 권한이 필요하다.</p>
<p><code>v1/Service</code>:</p>
<ul>
<li>List</li>
<li>Get</li>
<li>Watch</li>
<li>Patch</li>
<li>Update</li>
</ul>
<h3 id=authorization-miscellaneous>그 외의 것들</h3>
<p>클라우드 컨트롤러 매니저의 핵심 구현을 위해 이벤트 오브젝트를 생성하고, 안전한 작동을 보장하기 위해 서비스어카운트(ServiceAccounts)를 생성해야 한다.</p>
<p><code>v1/Event</code>:</p>
<ul>
<li>Create</li>
<li>Patch</li>
<li>Update</li>
</ul>
<p><code>v1/ServiceAccount</code>:</p>
<ul>
<li>Create</li>
</ul>
<p>클라우드 컨트롤러 매니저의 <a class=glossary-tooltip title="인가 결정을 관리하며, 운영자가 쿠버네티스 API를 통해서 동적으로 엑세스 정책을 설정하게 한다." data-toggle=tooltip data-placement=top href=/docs/reference/access-authn-authz/rbac/ target=_blank aria-label=RBAC>RBAC</a>
클러스터롤(ClusterRole)은 다음과 같다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cloud-controller-manager<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- events<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- create<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- patch<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- update<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- nodes<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:#b44>&#39;*&#39;</span><span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- nodes/status<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- patch<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- services<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- list<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- patch<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- update<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- watch<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- serviceaccounts<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- create<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- persistentvolumes<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- get<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- list<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- update<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- watch<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- endpoints<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- create<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- get<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- list<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- watch<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- update<span style=color:#bbb>
</span></code></pre></div><h2 id=다음-내용>다음 내용</h2>
<p><a href=/docs/tasks/administer-cluster/running-cloud-controller/#cloud-controller-manager>클라우드 컨트롤러 매니저 관리</a>에는
클라우드 컨트롤러 매니저의 실행과 관리에 대한 지침이 있다.</p>
<p>클라우드 컨트롤러 매니저를 사용하기 위해 HA 컨트롤 플레인을 업그레이드하려면, <a href=/docs/tasks/administer-cluster/controller-manager-leader-migration/>클라우드 컨트롤러 매니저를 사용하기 위해 복제된 컨트롤 플레인 마이그레이션 하기</a>를 참고한다.</p>
<p>자체 클라우드 컨트롤러 매니저를 구현하거나 기존 프로젝트를 확장하는 방법을 알고 싶은가?</p>
<p>클라우드 컨트롤러 매니저는 Go 인터페이스를 사용함으로써, 어떠한 클라우드에 대한 구현체(implementation)라도 플러그인 될 수 있도록 한다. 구체적으로는, <a href=https://github.com/kubernetes/cloud-provider>kubernetes/cloud-provider</a>의 <a href=https://github.com/kubernetes/cloud-provider/blob/release-1.21/cloud.go#L42-L69><code>cloud.go</code></a>에 정의된 <code>CloudProvider</code> 인터페이스를 사용한다.</p>
<p>이 문서(노드, 라우트와 서비스)에서 강조된 공유 컨트롤러의 구현과 공유 cloudprovider 인터페이스와 함께 일부 스캐폴딩(scaffolding)은 쿠버네티스 핵심의 일부이다. 클라우드 공급자 전용 구현은 쿠버네티스의 핵심 바깥에 있으며 <code>CloudProvider</code> 인터페이스를 구현한다.</p>
<p>플러그인 개발에 대한 자세한 내용은 <a href=/docs/tasks/administer-cluster/developing-cloud-controller-manager/>클라우드 컨트롤러 매니저 개발하기</a>를 참조한다.</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-44a2e2e592af0846101e970aff9243e5>2.5 - 가비지(Garbage) 수집</h1>
<p>쿠버네티스가 클러스터 자원을 정리하기 위해 사용하는 다양한 방법을 종합한 용어이다.
다음과 같은 리소스를 정리한다:</p>
<ul>
<li><a href=/ko/docs/concepts/workloads/pods/pod-lifecycle/#pod-garbage-collection>실패한 파드</a></li>
<li><a href=/ko/docs/concepts/workloads/controllers/ttlafterfinished/>종료된 잡</a></li>
<li><a href=#owners-dependents>소유자 참조가 없는 오브젝트</a></li>
<li><a href=#containers-images>사용되지 않는 컨테이너와 컨테이너 이미지</a></li>
<li><a href=/ko/docs/concepts/storage/persistent-volumes/#delete>반환 정책이 삭제인 스토리지클래스에 의해 동적으로 생성된 퍼시스턴트볼륨</a></li>
<li><a href=/docs/reference/access-authn-authz/certificate-signing-requests/#request-signing-process>Stale 또는 만료된 CertificateSigningRequests (CSRs)</a> </li>
<li><a class=glossary-tooltip title="노드는 쿠버네티스의 작업 장비(worker machine)이다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/architecture/nodes/ target=_blank aria-label=노드>노드</a> 는 다음과 같은 상황에서 삭제된다:
<ul>
<li>클러스터가 <a href=/ko/docs/concepts/architecture/cloud-controller/>클라우드 컨트롤러 매니저</a>를 사용하는 클라우드</li>
<li>클러스터가 클라우드 컨트롤러 매니저와 유사한 애드온을 사용하는 온프레미스</li>
</ul>
</li>
<li><a href=/ko/docs/concepts/architecture/nodes/#heartbeats>노드 리스(Lease) 오브젝트</a></li>
</ul>
<h2 id=owners-dependents>소유자(Owners)와 종속(dependents)</h2>
<p>쿠버네티스의 많은 오브젝트는 <a href=/docs/concepts/overview/working-with-objects/owners-dependents/><em>owner references</em></a>를 통해 서로 연결되어 있다.</p>
<p>소유자 참조(Owner references)는 컨트롤 플레인에게 어떤 오브젝트가 서로 종속적인지를 알려준다.
쿠버네티스는 소유자 참조를 사용하여 컨트롤 플레인과 다른 API 클라이언트에게 오브젝트를 삭제하기 전 관련 리소스를 정리하는 기회를 제공한다. 대부분의 경우, 쿠버네티스는 소유자 참조를 자동으로 관리한다.</p>
<p>소유권(Ownership)은 일부 리소스가 사용하는 <a href=/ko/docs/concepts/overview/working-with-objects/labels/>레이블과 셀렉터</a>
메커니즘과는 다르다. 예를 들어,
<code>EndpointSlice</code> 오브젝트를 생성하는 <a class=glossary-tooltip title="네트워크 서비스로 파드 집합에서 실행 중인 애플리케이션을 노출하는 방법" data-toggle=tooltip data-placement=top href=/ko/docs/concepts/services-networking/service/ target=_blank aria-label=서비스>서비스</a>를
생각해보자. 서비스는 <em>레이블</em>을 사용해 컨트롤 플레인이
어떤 <code>EndpointSlice</code> 오브젝트가 해당 서비스에 의해 사용되는지 판단하는 데 도움을 준다. 레이블과 더불어,
서비스를 대신해 관리되는 각 <code>EndpointSlice</code> 오브젝트는
소유자 참조를 가진다. 소유자 참조는 쿠버네티스의 다른 부분이 제어하지 않는
오브젝트를 방해하는 것을 방지하는 데 도움을 준다.</p>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> <p>교차 네임스페이스(cross-namespace)의 소유자 참조는 디자인상 허용되지 않는다.
네임스페이스 종속 오브젝트는 클러스터 범위 또는 네임스페이스 소유자를 지정할 수 있다.
네임스페이스 소유자는 <strong>반드시</strong> 종속 오브젝트와 동일한 네임스페이스에 존재해야 한다.
그렇지 않다면, 소유자 참조는 없는 것으로 간주되어, 종속 오브젝트는
모든 소유자가 없는 것으로 확인되면 삭제될 수 있다.</p>
<p>클러스터 범위의 종속 오브젝트는 클러스터 범위의 소유자만 지정할 수 있다.
v1.20 이상에서, 클러스터 범위의 종속 오브젝트가 네임스페이스 종류를 소유자로 지정하면,
확인할 수 없는 소유자 참조가 있는 것으로 간주되어 가비지 수집이 될 수 없다.</p>
<p>v1.20 이상에서, 가비지 수집기가 잘못된 교차 네임스페이스 <code>ownerReference</code>
또는 네임스페이스 종류를 참조하는 <code>ownerReference</code>가 있는 클러스터 범위의 종속 항목을 감지하면,
<code>OwnerRefInvalidNamespace</code>가 원인인 경고 이벤트와 유효하지 않은 종속 항목의 <code>involvedObject</code>가 보고된다.
<code>kubectl get events -A --field-selector=reason=OwnerRefInvalidNamespace</code>
를 실행하여 이러한 종류의 이벤트를 확인할 수 있다.</p>
</div>
<h2 id=cascading-deletion>캐스케이딩(Cascading) 삭제</h2>
<p>쿠버네티스는 오브젝트를 삭제할 때 더 이상 소유자 참조가 없는지,
예를 들어 레플리카셋을 삭제할 때, 남겨진 파드가 없는지 확인하고 삭제한다.
오브젝트를 삭제할 때 쿠버네티스가 오브젝트의 종속 오브젝트들을 자동으로 삭제할 지 여부를 제어할 수 있다.
이 과정을 <code>캐스케이딩 삭제</code>라고 한다.
캐스케이딩 삭제에는 다음과 같은 두 가지 종류가 있다.</p>
<ul>
<li>포그라운드 캐스케이딩 삭제(Foreground cascading deletion)</li>
<li>백그라운드 캐스케이딩 삭제(Background cascading deletion)</li>
</ul>
<p>또한 쿠버네티스의 <a class=glossary-tooltip title="A namespaced key that tells Kubernetes to wait until specific conditions are met before it fully deletes an object marked for deletion." data-toggle=tooltip data-placement=top href=/docs/concepts/overview/working-with-objects/finalizers/ target=_blank aria-label=finalizers>finalizers</a>를 사용하여 가비지 수집이 소유자 참조가 있는 자원을 언제 어떻게 삭제할 것인지 제어할 수 있다.</p>
<h3 id=foreground-deletion>포그라운드 캐스케이딩 삭제</h3>
<p>포그라운드 캐스케이딩 삭제에서는 삭제하려는 소유자 오브젝트가 먼저
<em>삭제 중</em> 상태가 된다. 이 상태에서는 소유자 오브젝트에게 다음과 같은 일이
일어난다:</p>
<ul>
<li>쿠버네티스 API 서버가 오브젝트의 <code>metadata.deletionTimestamp</code> 필드를
오브젝트가 삭제 표시된 시간으로 설정한다.</li>
<li>쿠버네티스 API 서버가 <code>metadata.finalizers</code> 필드를 <code>foregroundDeletion</code>로
설정한다.</li>
<li>오브젝트는 삭제 과정이 완료되기 전까지 쿠버네티스 API를 통해 조회할 수 있다.</li>
</ul>
<p>소유자 오브젝트가 삭제 중 상태가 된 이후, 컨트롤러는 종속 오브젝트들을 삭제한다.
모든 종속 오브젝트들이 삭제되고나면, 컨트롤러가 소유자 오브젝트를 삭제한다.
이 시점에서 오브젝트는 더 이상 쿠버네티스 API를 통해 조회할 수 없다.</p>
<p>포그라운드 캐스케이딩 삭제 중에 소유자 오브젝트의 삭제를 막는
종속 오브젝트는<code>ownerReference.blockOwnerDeletion=true</code>필드를 가진 오브젝트다.
더 자세한 내용은 <a href=/docs/tasks/administer-cluster/use-cascading-deletion/#use-foreground-cascading-deletion>Use foreground cascading deletion</a>를
참고한다.</p>
<h3 id=background-deletion>백그라운드 캐스케이딩 삭제</h3>
<p>백그라운드 캐스케이딩 삭제에서는 쿠버네티스 API 서버가 소유자 오브젝트를 즉시 삭제하고
백그라운드에서 컨트롤러가 종속 오브젝트들을 삭제한다.
쿠버네티스는 수동으로 포그라운드 삭제를 사용하거나 종속 오브젝트를 분리하지 않는다면, 기본적으로 백그라운드 캐스케이딩 삭제를 사용한다.</p>
<p>더 자세한 내용은 <a href=/docs/tasks/administer-cluster/use-cascading-deletion/#use-background-cascading-deletion>Use background cascading deletion</a>를
참고한다.</p>
<h3 id=분리된-종속-orphaned-dependents>분리된 종속 (Orphaned dependents)</h3>
<p>쿠버네티스가 소유자 오브젝트를 삭제할 때, 남은 종속 오브젝트는 <em>분리된</em> 오브젝트라고 부른다.
기본적으로 쿠버네티스는 종속 오브젝트를 삭제한다.
이 행동을 오버라이드하는 방법을 보려면,
다음 <a href=/docs/tasks/administer-cluster/use-cascading-deletion/#set-orphan-deletion-policy>Delete owner objects and orphan dependents</a>를 참고한다.</p>
<h2 id=containers-images>사용되지 않는 컨테이너와 이미지 가비지 수집</h2>
<p><a class=glossary-tooltip title="클러스터의 각 노드에서 실행되는 에이전트. Kubelet은 파드에서 컨테이너가 확실하게 동작하도록 관리한다." data-toggle=tooltip data-placement=top href=/docs/reference/generated/kubelet target=_blank aria-label=kubelet>kubelet</a>은
사용되지 않는 이미지에 대한 가비지 수집을 5분마다, 컨테이너에 대한 가비지 수집을 1분마다
수행한다. 외부 가비지 수집 도구는 Kubelet 의 행동을 중단시키고
존재해야만 하는 컨테이너를 삭제할 수 있으므로 사용을 피해야 한다.</p>
<p>사용되지 않는 컨테이너와 이미지에 대한 가비지 수집 옵션을 구성하려면,
<a href=/docs/tasks/administer-cluster/kubelet-config-file/>configuration file</a> 사용하여 Kubelet 을 수정하거나
<a href=/docs/reference/config-api/kubelet-config.v1beta1/#kubelet-config-k8s-io-v1beta1-KubeletConfiguration><code>KubeletConfiguration</code></a> 리소스 타입의
가비지 수집과 관련된 파라미터를 수정한다.</p>
<h3 id=컨테이너-이미지-라이프사이클>컨테이너 이미지 라이프사이클</h3>
<p>쿠버네티스는 Kubelet의 일부인 <em>이미지 관리자</em>가 <a class=glossary-tooltip title="Tool that provides understanding of the resource usage and performance characteristics for containers" data-toggle=tooltip data-placement=top href=https://github.com/google/cadvisor/ target=_blank aria-label=cadvisor>cadvisor</a>와 협동하여
모든 이미지의 라이프사이클을 관리한다.
Kubelet은 가비지 수집 결정을 내릴 때, 다음 디스크 사용량 제한을 고려한다.</p>
<ul>
<li><code>HighThresholdPercent</code></li>
<li><code>LowThresholdPercent</code></li>
</ul>
<p><code>HighThresholdPercent</code> 값을 초과한 디스크 사용량은
마지막으로 사용된 시간을 기준으로 오래된 이미지순서대로 이미지를 삭제하는
가비지 수집을 트리거한다. Kubelet은 디스크 사용량이 <code>LowThresholdPercent</code> 값에 도달할 때까지
이미지를 삭제한다.</p>
<h3 id=container-image-garbage-collection>컨테이너 이미지 가비지 수집</h3>
<p>Kubelet은 사용자가 정의할 수 있는 다음 변수들을 기반으로 사용되지 않는 컨테이너들을 삭제한다:</p>
<ul>
<li><code>MinAge</code>: Kubelet이 가비지 수집할 수 있는 최소 나이. <code>0</code>으로 세팅하여 비활성화할 수 있다.</li>
<li><code>MaxPerPodContainer</code>: 각 파드 쌍이 가질 수 있는 죽은 컨테이너의 최대 개수.
<code>0</code>으로 세팅하여 비활성화할 수 있다.</li>
<li><code>MaxContainers</code>: 클러스터가 가질 수 있는 죽은 컨테이너의 최대 개수
<code>0</code>으로 세팅하여 비활성화할 수 있다.</li>
</ul>
<p>위 변수와 더불어, Kubelet은 식별할 수 없고 삭제된 컨테이너들을 오래된 순서대로 가비지 수집한다.</p>
<p><code>MaxPerPodContainer</code>와 <code>MaxContainer</code>는
파드의 최대 컨테이너 개수(<code>MaxPerPodContainer</code>)를 유지하는 것이
전체 죽은 컨테이너의 개수 제한(<code>MaxContainers</code>)을 초과하게 될 때,
서로 충돌이 발생할 수 있다.
이 상황에서 Kubelet은 충돌을 해결하기 위해 <code>MaxPodPerContainer</code>를 조절한다.
최악의 시나리오에서는 <code>MaxPerPodContainer</code>를 <code>1</code>로 다운그레이드하고
가장 오래된 컨테이너들을 축출한다.
또한, 삭제된 파드가 소유한 컨테이너들은 <code>MinAge</code>보다 오래되었을 때 삭제된다.</p>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> Kubelet은 자신이 관리하는 컨테이너에 대한 가비지 수집만을 수행한다.
</div>
<h2 id=configuring-gc>가비지 수집 구성하기</h2>
<p>자원을 관리하는 컨트롤러의 옵션을 구성하여 가비지 컬렉션을 수정할 수 있다.
다음 페이지에서 어떻게 가비지 수집을 구성할 수 있는지 확인할 수 있다:</p>
<ul>
<li><a href=/docs/tasks/administer-cluster/use-cascading-deletion/>쿠버네티스 오브젝트의 캐스케이딩 삭제 구성하기</a></li>
<li><a href=/ko/docs/concepts/workloads/controllers/ttlafterfinished/>완료된 잡 자동 정리하기</a></li>
</ul>
<h2 id=다음-내용>다음 내용</h2>
<ul>
<li><a href=/docs/concepts/overview/working-with-objects/owners-dependents/>쿠버네티스 오브젝트의 소유권</a>에 대해 알아보자.</li>
<li>쿠버네티스 <a href=/docs/concepts/overview/working-with-objects/finalizers/>finalizers</a>에 대해 알아보자.</li>
<li>완료된 잡을 정리하는 <a href=/ko/docs/concepts/workloads/controllers/ttlafterfinished/>TTL 컨트롤러</a> (beta) 에 대해 알아보자.</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-c0ea5310f52e22c5de34dc84d9ab5e0d>2.6 - 컨테이너 런타임 인터페이스(CRI)</h1>
<p>컨테이너 런타임 인터페이스(CRI)는 클러스터 컴포넌트를 다시 컴파일하지 않아도 Kubelet이 다양한
컨테이너 런타임을 사용할 수 있도록 하는 플러그인 인터페이스다.</p>
<p>클러스터의 모든 노드에 동작 중인
<a class=glossary-tooltip title="컨테이너 런타임은 컨테이너 실행을 담당하는 소프트웨어이다." data-toggle=tooltip data-placement=top href=/ko/docs/setup/production-environment/container-runtimes/ target=_blank aria-label="컨테이너 런타임">컨테이너 런타임</a>이 존재해야,
<a class=glossary-tooltip title="클러스터의 각 노드에서 실행되는 에이전트. Kubelet은 파드에서 컨테이너가 확실하게 동작하도록 관리한다." data-toggle=tooltip data-placement=top href=/docs/reference/generated/kubelet target=_blank aria-label=kubelet>kubelet</a>이
<a class=glossary-tooltip title="파드는 클러스터에서 실행 중인 컨테이너의 집합을 나타낸다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/pods/ target=_blank aria-label=파드>파드</a>들과 컨테이너들을
구동할 수 있다.</p>
<p><p>컨테이너 런타임 인터페이스(CRI)는 kubelet과 컨테이너 런타임 사이의 통신을 위한 주요 프로토콜이다.</p></p>
<p>쿠버네티스 컨테이너 런타임 인터페이스(CRI)는
<a href=/ko/docs/concepts/overview/components/#%EB%85%B8%EB%93%9C-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8>클러스터 컴포넌트</a>
<a class=glossary-tooltip title="클러스터의 각 노드에서 실행되는 에이전트. Kubelet은 파드에서 컨테이너가 확실하게 동작하도록 관리한다." data-toggle=tooltip data-placement=top href=/docs/reference/generated/kubelet target=_blank aria-label=kubelet>kubelet</a>과
￼<a class=glossary-tooltip title="컨테이너 런타임은 컨테이너 실행을 담당하는 소프트웨어이다." data-toggle=tooltip data-placement=top href=/ko/docs/setup/production-environment/container-runtimes/ target=_blank aria-label="container runtime">container runtime</a> 사이의
통신을 위한 주요 <a href=https://grpc.io>gRPC</a> 프로토콜을 정의한다.</p>
<h2 id=api>API</h2>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.23 [stable]</code>
</div>
<p>Kubelet은 gRPC를 통해 컨테이너 런타임과 연결할 때 클라이언트의 역할을 수행한다.
런타임과 이미지 서비스 엔드포인트는 컨테이너 런타임 내에서 사용 가능해야 하며,
이는 각각 Kubelet 내에서 <code>--image-service-endpoint</code>와 <code>--container-runtime-endpoint</code>
<a href=/docs/reference/command-line-tools-reference/kubelet>커맨드라인 플래그</a>
를 통해 설정할 수 있다.</p>
<p>쿠버네티스 v1.23에서는, Kubelet은 CRI <code>v1</code>을 사용하는 것을 권장한다.
컨테이너 런타임이 CRI <code>v1</code> 버전을 지원하지 않는다면,
Kubelet은 지원 가능한 이전 지원 버전으로 협상을 시도한다.
또한 v1.23 Kubelet은 CRI <code>v1alpha2</code>버전도 협상할 수 있지만,
해당 버전은 사용 중단(deprecated)으로 간주한다.
Kubelet이 지원되는 CRI 버전을 협상할 수 없는 경우,
Kubelet은 협상을 포기하고 노드로 등록하지 않는다.</p>
<h2 id=업그레이드>업그레이드</h2>
<p>쿠버네티스를 업그레이드할 때, Kubelet은 컴포넌트의 재시작 시점에서 최신 CRI 버전을 자동으로 선택하려고 시도한다.
이 과정이 실패하면 위에서 언급한 대로 이전 버전을 선택하는 과정을 거친다.
컨테이너 런타임이 업그레이드되어 gRPC 재다이얼이 필요하다면,
컨테이너 런타임도 처음에 선택된 버전을 지원해야 하며,
그렇지 못한 경우 재다이얼은 실패하게 될 것이다. 이 과정은 Kubelet의 재시작이 필요하다.</p>
<h2 id=다음-내용>다음 내용</h2>
<ul>
<li>CRI <a href=https://github.com/kubernetes/cri-api/blob/c75ef5b/pkg/apis/runtime/v1/api.proto>프로토콜 정의</a>를 자세히 알아보자.</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-a5f7383c83ab9eb9cd0e3c4c020b3ae6>3 - 컨테이너</h1>
<div class=lead>런타임 의존성과 함께 애플리케이션을 패키징하는 기술</div>
<p>실행하는 각 컨테이너는 반복 가능하다. 의존성이 포함된 표준화는
어디에서 실행하던지 동일한 동작을 얻는다는 것을
의미한다.</p>
<p>컨테이너는 기본 호스트 인프라에서 애플리케이션을 분리한다.
따라서 다양한 클라우드 또는 OS 환경에서 보다 쉽게 배포할 수 있다.</p>
<h2 id=컨테이너-이미지>컨테이너 이미지</h2>
<p><a href=/ko/docs/concepts/containers/images/>컨테이너 이미지</a>는 애플리케이션을
실행하는 데 필요한 모든 것이 포함된 실행할 준비가 되어 있는(ready-to-run) 소프트웨어 패키지이다.
여기에는 실행하는 데 필요한 코드와 모든 런타임, 애플리케이션 및 시스템 라이브러리,
그리고 모든 필수 설정에 대한 기본값이 포함된다.</p>
<p>설계 상, 컨테이너는 변경할 수 없다. 이미 실행 중인 컨테이너의 코드를
변경할 수 없다. 컨테이너화된 애플리케이션이 있고
변경하려는 경우, 변경 사항이 포함된 새 이미지를 빌드한
다음, 업데이트된 이미지에서 시작하도록 컨테이너를 다시 생성해야 한다.</p>
<h2 id=컨테이너-런타임>컨테이너 런타임</h2>
<p>컨테이너 런타임은 컨테이너 실행을 담당하는 소프트웨어이다.</p>
<p>쿠버네티스는 <a class=glossary-tooltip title="A container runtime with an emphasis on simplicity, robustness and portability" data-toggle=tooltip data-placement=top href=https://containerd.io/docs/ target=_blank aria-label=containerd>containerd</a>,
<a class=glossary-tooltip title="A lightweight container runtime specifically for Kubernetes" data-toggle=tooltip data-placement=top href=https://cri-o.io/#what-is-cri-o target=_blank aria-label=CRI-O>CRI-O</a>와 같은 컨테이너 런타임 및
모든 <a href=https://github.com/kubernetes/community/blob/master/contributors/devel/sig-node/container-runtime-interface.md>Kubernetes CRI (컨테이너 런타임 인터페이스)</a>
구현체를 지원한다.</p>
<h2 id=다음-내용>다음 내용</h2>
<ul>
<li><a href=/ko/docs/concepts/containers/images/>컨테이너 이미지</a>에 대해 읽어보기</li>
<li><a href=/ko/docs/concepts/workloads/pods/>파드</a>에 대해 읽어보기</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-16042b4652ad19e565c7263824029a43>3.1 - 이미지</h1>
<p>컨테이너 이미지는 애플리케이션과 모든 소프트웨어 의존성을 캡슐화하는 바이너리 데이터를
나타낸다. 컨테이너 이미지는 독립적으로 실행할 수 있고 런타임 환경에 대해
잘 정의된 가정을 만드는 실행 가능한 소프트웨어 번들이다.</p>
<p>일반적으로 <a class=glossary-tooltip title="파드는 클러스터에서 실행 중인 컨테이너의 집합을 나타낸다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/pods/ target=_blank aria-label=파드>파드</a>에서
참조하기 전에 애플리케이션의 컨테이너 이미지를
생성해서 레지스트리로 푸시한다.</p>
<p>이 페이지는 컨테이너 이미지 개념의 개요를 제공한다.</p>
<h2 id=이미지-이름>이미지 이름</h2>
<p>컨테이너 이미지는 일반적으로 <code>pause</code>, <code>example/mycontainer</code> 또는 <code>kube-apiserver</code> 와 같은 이름을 부여한다.
이미지는 또한 레지스트리 호스트 이름을 포함할 수 있다. 예를 들면, <code>fictional.registry.example/imagename</code>
과 같다. 그리고 포트 번호도 포함할 수 있다. 예를 들면, <code>fictional.registry.example:10443/imagename</code> 과 같다.</p>
<p>레지스트리 호스트 이름을 지정하지 않으면, 쿠버네티스는 도커 퍼블릭 레지스트리를 의미한다고 가정한다.</p>
<p>이미지 이름 부분 다음에 <em>tag</em> 를 추가할 수 있다(<code>docker</code> 와 <code>podman</code>
등의 명령과 함께 사용).
태그를 사용하면 동일한 시리즈 이미지의 다른 버전을 식별할 수 있다.</p>
<p>이미지 태그는 소문자와 대문자, 숫자, 밑줄(<code>_</code>),
마침표(<code>.</code>) 및 대시(<code>-</code>)로 구성된다.
이미지 태그 안에서 구분 문자(<code>_</code>, <code>-</code> 그리고 <code>.</code>)를
배치할 수 있는 위치에 대한 추가 규칙이 있다.
태그를 지정하지 않으면, 쿠버네티스는 태그 <code>latest</code> 를 의미한다고 가정한다.</p>
<h2 id=이미지-업데이트>이미지 업데이트</h2>
<p><a class=glossary-tooltip title="클러스터에서 복제된 애플리케이션을 관리한다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/controllers/deployment/ target=_blank aria-label=디플로이먼트>디플로이먼트</a>,
<a class=glossary-tooltip title="내구성이 있는 스토리지와 파드별로 지속성 식별자를 사용해서 파드 집합의 디플로이먼트와 스케일링을 관리한다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/controllers/statefulset/ target=_blank aria-label=스테이트풀셋>스테이트풀셋</a>, 파드 또는 파드
템플릿은 포함하는 다른 오브젝트를 처음 만들 때 특별히 명시하지 않은 경우
기본적으로 해당 파드에 있는 모든 컨테이너의 풀(pull)
정책은 <code>IfNotPresent</code>로 설정된다. 이 정책은
<a class=glossary-tooltip title="클러스터의 각 노드에서 실행되는 에이전트. Kubelet은 파드에서 컨테이너가 확실하게 동작하도록 관리한다." data-toggle=tooltip data-placement=top href=/docs/reference/generated/kubelet target=_blank aria-label=kubelet>kubelet</a>이 이미 존재하는
이미지에 대한 풀을 생략하게 한다.</p>
<h3 id=이미지-풀-pull-정책>이미지 풀(pull) 정책</h3>
<p>컨테이너에 대한 <code>imagePullPolicy</code>와 이미지의 태그는
<a href=/docs/reference/command-line-tools-reference/kubelet/>kubelet</a>이 특정 이미지를 풀(다운로드)하려고 할 때 영향을 준다.</p>
<p>다음은 <code>imagePullPolicy</code>에 설정할 수 있는 값의 목록과
효과이다.</p>
<dl>
<dt><code>IfNotPresent</code></dt>
<dd>이미지가 로컬에 없는 경우에만 내려받는다.</dd>
<dt><code>Always</code></dt>
<dd>kubelet이 컨테이너를 기동할 때마다, kubelet이 컨테이너
이미지 레지스트리에 이름과 이미지의
<a href=https://docs.docker.com/engine/reference/commandline/pull/#pull-an-image-by-digest-immutable-identifier>다이제스트</a>가 있는지 질의한다.
일치하는 다이제스트를 가진 컨테이너 이미지가 로컬에 있는 경우, kubelet은 캐시된 이미지를 사용한다.
이외의 경우, kubelet은 검색된 다이제스트를 가진 이미지를 내려받아서
컨테이너를 기동할 때 사용한다.</dd>
<dt><code>Never</code></dt>
<dd>kubelet은 이미지를 가져오려고 시도하지 않는다. 이미지가 어쨌든 이미 로컬에 존재하는
경우, kubelet은 컨테이너 기동을 시도한다. 이외의 경우 기동은 실패한다.
보다 자세한 내용은 <a href=#pre-pulled-images>미리 내려받은 이미지</a>를 참조한다.</dd>
</dl>
<p>이미지 제공자에 앞서 깔린 캐시의 의미 체계는 레지스트리에 안정적으로 접근할 수 있는 한,
<code>imagePullPolicy: Always</code>인 경우 조차도 효율적이다.
컨테이너 런타임은 노드에 이미 존재하는 이미지 레이어를 알고
다시 내려받지 않는다.</p>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> <p>프로덕션 환경에서 컨테이너를 배포하는 경우 <code>:latest</code> 태그 사용을 지양해야 하는데,
이미지의 어떤 버전이 기동되고 있는지 추적이 어렵고
제대로 롤백하기 어렵게 되기 때문이다.</p>
<p>대신, <code>v1.42.0</code>과 같이 의미있는 태그를 명기한다.</p>
</div>
<p>파드가 항상 컨테이너 이미지의 같은 버전을 사용하는 것을 확실히 하려면,
이미지의 다이제스트를 명기할 수 있다.
<code>&lt;image-name>:&lt;tag></code>를 <code>&lt;image-name>@&lt;digest></code>로 교체한다.
(예를 들어, <code>image@sha256:45b23dee08af5e43a7fea6c4cf9c25ccf269ee113168c19722f87876677c5cb2</code>).</p>
<p>이미지 태그를 사용하는 경우, 이미지 레지스트리에서 한 이미지를 나타내는 태그에 코드를 변경하게 되면, 기존 코드와 신규 코드를 구동하는 파드가 섞이게 되고 만다. 이미지 다이제스트를 통해 이미지의 특정 버전을 유일하게 식별할 수 있기 때문에, 쿠버네티스는 매번 해당 이미지 이름과 다이제스트가 명시된 컨테이너를 기동해서 같은 코드를 구동한다. 이미지를 명시하는 것은 구동할 코드를 고정시켜서 레지스트리에서의 변경으로 인해 버전이 섞이는 일이 발생하지 않도록 해준다.</p>
<p>파드(및 파드 템플릿)가 생성될 때 구동 중인 워크로드가
태그가 아닌 이미지 다이제스트를 통해 정의되도록 조작해주는
서드-파티 <a href=/docs/reference/access-authn-authz/admission-controllers/>어드미션 컨트롤러</a>가 있다.
이는 레지스트리에서 태그가 변경되는 일이 발생해도
구동 중인 워크로드가 모두 같은 코드를 사용하고 있다는 것을 보장하기를 원하는 경우 유용할 것이다.</p>
<h4 id=imagepullpolicy-defaulting>기본 이미지 풀 정책</h4>
<p>사용자(또는 컨트롤러)가 신규 파드를 API 서버에 요청할 때,
특정 조건에 부합하면 클러스터가 <code>imagePullPolicy</code> 필드를 설정한다.</p>
<ul>
<li><code>imagePullPolicy</code> 필드를 생략하고 컨테이너 이미지의 태그가
<code>:latest</code>인 경우, <code>imagePullPolicy</code>는 자동으로 <code>Always</code>로 설정된다.</li>
<li><code>imagePullPolicy</code> 필드를 생략하고 컨테이너 이미지의 태그를 명기하지 않은 경우,
<code>imagePullPolicy</code>는 자동으로 <code>Always</code>로 설정된다.</li>
<li><code>imagePullPolicy</code> 필드를 생략하고,
명기한 컨테이너 이미지의 태그가 <code>:latest</code>가 아니면,
<code>imagePullPolicy</code>는 자동으로 <code>IfNotPresent</code>로 설정된다.</li>
</ul>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> <p>컨테이너의 <code>imagePullPolicy</code> 값은 오브젝트가 처음 <em>created</em> 일 때 항상
설정되고 나중에 이미지 태그가 변경되더라도 업데이트되지 않는다.</p>
<p>예를 들어, 태그가 <code>:latest</code>가 아닌 이미지로 디플로이먼트를 생성하고,
나중에 해당 디플로이먼트의 이미지를 <code>:latest</code> 태그로 업데이트하면
<code>imagePullPolicy</code> 필드가 <code>Always</code> 로 변경되지 않는다. 오브젝트를
처음 생성 한 후 모든 오브젝트의 풀 정책을 수동으로 변경해야 한다.</p>
</div>
<h4 id=이미지-풀-강제>이미지 풀 강제</h4>
<p>이미지를 내려받도록 강제하려면, 다음 중 한가지 방법을 사용한다.</p>
<ul>
<li>컨테이너의 <code>imagePullPolicy</code>를 <code>Always</code>로 설정한다.</li>
<li><code>imagePullPolicy</code>를 생략하고 사용할 이미지 태그로 <code>:latest</code>를 사용한다.
그러면 사용자가 파드를 요청할 때 쿠버네티스가 정책을 <code>Always</code>로 설정한다.</li>
<li><code>imagePullPolicy</code>와 사용할 이미지의 태그를 생략한다.
그러면 사용자가 파드를 요청할 때 쿠버네티스가 정책을 <code>Always</code>로 설정한다.</li>
<li><a href=/docs/reference/access-authn-authz/admission-controllers/#alwayspullimages>AlwaysPullImages</a> 어드미션 컨트롤러를 활성화 한다.</li>
</ul>
<h3 id=이미지풀백오프-imagepullbackoff>이미지풀백오프(ImagePullBackOff)</h3>
<p>kubelet이 컨테이너 런타임을 사용하여 파드의 컨테이너 생성을 시작할 때,
<code>ImagePullBackOff</code>로 인해 컨테이너가
<a href=/ko/docs/concepts/workloads/pods/pod-lifecycle/#container-state-waiting>Waiting</a> 상태에 있을 수 있다.</p>
<p><code>ImagePullBackOff</code>라는 상태는 (이미지 이름이 잘못됨, 또는 <code>imagePullSecret</code> 없이
비공개 레지스트리에서 풀링 시도 등의 이유로) 쿠버네티스가 컨테이너 이미지를
가져올 수 없기 때문에 컨테이너를 실행할 수 없음을 의미한다. <code>BackOff</code>라는 단어는
쿠버네티스가 백오프 딜레이를 증가시키면서 이미지 풀링을 계속 시도할 것임을 나타낸다.</p>
<p>쿠버네티스는 시간 간격을 늘려가면서 시도를 계속하며, 시간 간격의 상한은 쿠버네티스 코드에
300초(5분)로 정해져 있다.</p>
<h2 id=이미지-인덱스가-있는-다중-아키텍처-이미지>이미지 인덱스가 있는 다중 아키텍처 이미지</h2>
<p>바이너리 이미지를 제공할 뿐만 아니라, 컨테이너 레지스트리는 <a href=https://github.com/opencontainers/image-spec/blob/master/image-index.md>컨테이너 이미지 인덱스</a>를 제공할 수도 있다. 이미지 인덱스는 컨테이너의 아키텍처별 버전에 대한 여러 <a href=https://github.com/opencontainers/image-spec/blob/master/manifest.md>이미지 매니페스트</a>를 가리킬 수 있다. 아이디어는 이미지의 이름(예를 들어, <code>pause</code>, <code>example/mycontainer</code>, <code>kube-apiserver</code>)을 가질 수 있다는 것이다. 그래서 다른 시스템들이 사용하고 있는 컴퓨터 아키텍처에 적합한 바이너리 이미지를 가져올 수 있다.</p>
<p>쿠버네티스 자체는 일반적으로 <code>-$(ARCH)</code> 접미사로 컨테이너 이미지의 이름을 지정한다. 이전 버전과의 호환성을 위해, 접미사가 있는 오래된 이미지를 생성한다. 아이디어는 모든 아키텍처에 대한 매니페스트가 있는 <code>pause</code> 이미지와 이전 구성 또는 이전에 접미사로 이미지를 하드 코딩한 YAML 파일과 호환되는 <code>pause-amd64</code> 라고 하는 이미지를 생성한다.</p>
<h2 id=프라이빗-레지스트리-사용>프라이빗 레지스트리 사용</h2>
<p>프라이빗 레지스트리는 해당 레지스트리에서 이미지를 읽을 수 있는 키를 요구할 것이다.
자격 증명(credential)은 여러 가지 방법으로 제공될 수 있다.</p>
<ul>
<li>프라이빗 레지스트리에 대한 인증을 위한 노드 구성
<ul>
<li>모든 파드는 구성된 프라이빗 레지스트리를 읽을 수 있음</li>
<li>클러스터 관리자에 의한 노드 구성 필요</li>
</ul>
</li>
<li>미리 내려받은(pre-pulled) 이미지
<ul>
<li>모든 파드는 노드에 캐시된 모든 이미지를 사용 가능</li>
<li>셋업을 위해서는 모든 노드에 대해서 root 접근이 필요</li>
</ul>
</li>
<li>파드에 ImagePullSecrets을 명시
<ul>
<li>자신의 키를 제공하는 파드만 프라이빗 레지스트리에 접근 가능</li>
</ul>
</li>
<li>공급 업체별 또는 로컬 확장
<ul>
<li>사용자 정의 노드 구성을 사용하는 경우, 사용자(또는 클라우드
제공자)가 컨테이너 레지스트리에 대한 노드 인증 메커니즘을
구현할 수 있다.</li>
</ul>
</li>
</ul>
<p>이들 옵션은 아래에서 더 자세히 설명한다.</p>
<h3 id=프라이빗-레지스트리에-인증하도록-노드-구성>프라이빗 레지스트리에 인증하도록 노드 구성</h3>
<p>노드에서 도커를 실행하는 경우, 프라이빗 컨테이너 레지스트리를 인증하도록
도커 컨테이너 런타임을 구성할 수 있다.</p>
<p>이 방법은 노드 구성을 제어할 수 있는 경우에 적합하다.</p>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> 기본 쿠버네티스는 도커 구성에서 <code>auths</code> 와 <code>HttpHeaders</code> 섹션만 지원한다.
도커 자격 증명 도우미(<code>credHelpers</code> 또는 <code>credsStore</code>)는 지원되지 않는다.
</div>
<p>도커는 프라이빗 레지스트리를 위한 키를 <code>$HOME/.dockercfg</code> 또는 <code>$HOME/.docker/config.json</code> 파일에 저장한다. 만약 동일한 파일을
아래의 검색 경로 리스트에 넣으면, kubelet은 이미지를 풀 할 때 해당 파일을 자격 증명 공급자로 사용한다.</p>
<ul>
<li><code>{--root-dir:-/var/lib/kubelet}/config.json</code></li>
<li><code>{cwd of kubelet}/config.json</code></li>
<li><code>${HOME}/.docker/config.json</code></li>
<li><code>/.docker/config.json</code></li>
<li><code>{--root-dir:-/var/lib/kubelet}/.dockercfg</code></li>
<li><code>{cwd of kubelet}/.dockercfg</code></li>
<li><code>${HOME}/.dockercfg</code></li>
<li><code>/.dockercfg</code></li>
</ul>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> kubelet 프로세스의 환경 변수에서 <code>HOME=/root</code> 를 명시적으로 설정해야 할 수 있다.
</div>
<p>프라이빗 레지스트리를 사용도록 사용자의 노드를 구성하기 위해서 권장되는 단계는 다음과 같다. 이
예제의 경우, 사용자의 데스크탑/랩탑에서 아래 내용을 실행한다.</p>
<ol>
<li>사용하고 싶은 각 자격 증명 세트에 대해서 <code>docker login [서버]</code>를 실행한다. 이것은 여러분 PC의 <code>$HOME/.docker/config.json</code>를 업데이트한다.</li>
<li>편집기에서 <code>$HOME/.docker/config.json</code>를 보고 사용하고 싶은 자격 증명만 포함하고 있는지 확인한다.</li>
<li>노드의 리스트를 구한다. 예를 들면 다음과 같다.
<ul>
<li>이름을 원하는 경우: <code>nodes=$( kubectl get nodes -o jsonpath='{range.items[*].metadata}{.name} {end}' )</code></li>
<li>IP를 원하는 경우: <code>nodes=$( kubectl get nodes -o jsonpath='{range .items[*].status.addresses[?(@.type=="ExternalIP")]}{.address} {end}' )</code></li>
</ul>
</li>
<li>로컬의 <code>.docker/config.json</code>를 위의 검색 경로 리스트 중 하나에 복사한다.
<ul>
<li>이를 테스트하기 위한 예: <code>for n in $nodes; do scp ~/.docker/config.json root@"$n":/var/lib/kubelet/config.json; done</code></li>
</ul>
</li>
</ol>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> 프로덕션 클러스터의 경우, 이 설정을 필요한 모든 노드에 적용할 수 있도록
구성 관리 도구를 사용한다.
</div>
<p>프라이빗 이미지를 사용하는 파드를 생성하여 검증한다. 예를 들면 다음과 같다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f - <span style=color:#b44>&lt;&lt;EOF
</span><span style=color:#b44>apiVersion: v1
</span><span style=color:#b44>kind: Pod
</span><span style=color:#b44>metadata:
</span><span style=color:#b44>  name: private-image-test-1
</span><span style=color:#b44>spec:
</span><span style=color:#b44>  containers:
</span><span style=color:#b44>    - name: uses-private-image
</span><span style=color:#b44>      image: $PRIVATE_IMAGE_NAME
</span><span style=color:#b44>      imagePullPolicy: Always
</span><span style=color:#b44>      command: [ &#34;echo&#34;, &#34;SUCCESS&#34; ]
</span><span style=color:#b44>EOF</span>
</code></pre></div><pre><code>pod/private-image-test-1 created
</code></pre><p>만약 모든 것이 잘 작동한다면, 잠시 후에, 다음을 실행할 수 있다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl logs private-image-test-1
</code></pre></div><p>그리고 커맨드 출력을 본다.</p>
<pre><code>SUCCESS
</code></pre><p>명령이 실패한 것으로 의심되는 경우 다음을 실행할 수 있다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe pods/private-image-test-1 | grep <span style=color:#b44>&#39;Failed&#39;</span>
</code></pre></div><p>실패하는 케이스에는 출력이 다음과 유사하다.</p>
<pre><code>  Fri, 26 Jun 2015 15:36:13 -0700    Fri, 26 Jun 2015 15:39:13 -0700    19    {kubelet node-i2hq}    spec.containers{uses-private-image}    failed        Failed to pull image &quot;user/privaterepo:v1&quot;: Error: image user/privaterepo:v1 not found
</code></pre><p>클러스터의 모든 노드가 반드시 동일한 <code>.docker/config.json</code>를 가져야 한다. 그렇지 않으면, 파드가
일부 노드에서만 실행되고 다른 노드에서는 실패할 것이다. 예를 들어, 노드 오토스케일링을 사용한다면, 각 인스턴스
템플릿은 <code>.docker/config.json</code>을 포함하거나 그것을 포함한 드라이브를 마운트해야 한다.</p>
<p>프라이빗 레지스트리 키가 <code>.docker/config.json</code>에 추가되고 나면 모든 파드는
프라이빗 레지스트리의 이미지에 읽기 접근 권한을 가지게 될 것이다.</p>
<h3 id=config-json>config.json 파일 해석</h3>
<p><code>config.json</code> 파일의 해석에 있어서, 기존 도커의 구현과 쿠버네티스의 구현에 차이가 있다.
도커에서는 <code>auths</code> 키에 특정 루트 URL만 기재할 수 있으나,
쿠버네티스에서는 glob URL과 접두사-매칭 경로도 기재할 수 있다.
이는 곧 다음과 같은 <code>config.json</code>도 유효하다는 뜻이다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
    <span style=color:green;font-weight:700>&#34;auths&#34;</span>: {
        <span style=color:green;font-weight:700>&#34;*my-registry.io/images&#34;</span>: {
            <span style=color:green;font-weight:700>&#34;auth&#34;</span>: <span style=color:#b44>&#34;…&#34;</span>
        }
    }
}
</code></pre></div><p>루트 URL(<code>*my-registry.io</code>)은 다음 문법을 사용하여 매치된다.</p>
<pre><code>pattern:
    { term }

term:
    '*'         구분자가 아닌 모든 문자와 매치됨
    '?'         구분자가 아닌 문자 1개와 매치됨
    '[' [ '^' ] { character-range } ']'
                문자 클래스 (비어 있으면 안 됨))
    c           문자 c에 매치됨 (c != '*', '?', '\\', '[')
    '\\' c      문자 c에 매치됨

character-range:
    c           문자 c에 매치됨 (c != '\\', '-', ']')
    '\\' c      문자 c에 매치됨
    lo '-' hi   lo &lt;= c &lt;= hi 인 문자 c에 매치됨
</code></pre><p>이미지 풀 작업 시, 모든 유효한 패턴에 대해 크리덴셜을 CRI 컨테이너 런타임에 제공할 것이다.
예를 들어 다음과 같은 컨테이너 이미지 이름은
성공적으로 매치될 것이다.</p>
<ul>
<li><code>my-registry.io/images</code></li>
<li><code>my-registry.io/images/my-image</code></li>
<li><code>my-registry.io/images/another-image</code></li>
<li><code>sub.my-registry.io/images/my-image</code></li>
<li><code>a.sub.my-registry.io/images/my-image</code></li>
</ul>
<p>kubelet은 인식된 모든 크리덴셜을 순차적으로 이용하여 이미지 풀을 수행한다. 즉,
<code>config.json</code>에 다음과 같이 여러 항목을 기재할 수도 있다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
    <span style=color:green;font-weight:700>&#34;auths&#34;</span>: {
        <span style=color:green;font-weight:700>&#34;my-registry.io/images&#34;</span>: {
            <span style=color:green;font-weight:700>&#34;auth&#34;</span>: <span style=color:#b44>&#34;…&#34;</span>
        },
        <span style=color:green;font-weight:700>&#34;my-registry.io/images/subpath&#34;</span>: {
            <span style=color:green;font-weight:700>&#34;auth&#34;</span>: <span style=color:#b44>&#34;…&#34;</span>
        }
    }
}
</code></pre></div><p>이제 컨테이너가 <code>my-registry.io/images/subpath/my-image</code>
이미지를 풀 해야 한다고 명시하면,
kubelet은 크리덴셜을 순차적으로 사용하여 풀을 시도한다.</p>
<h3 id=pre-pulled-images>미리 내려받은 이미지</h3>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> 이 방법은 노드의 구성을 제어할 수 있는 경우에만 적합하다. 이 방법은
클라우드 제공자가 노드를 관리하고 자동으로 교체한다면 안정적으로
작동하지 않을 것이다.
</div>
<p>기본적으로, kubelet은 지정된 레지스트리에서 각 이미지를 풀 하려고 한다.
그러나, 컨테이너의 <code>imagePullPolicy</code> 속성이 <code>IfNotPresent</code> 또는 <code>Never</code>으로 설정되어 있다면,
로컬 이미지가 사용된다(우선적으로 또는 배타적으로).</p>
<p>레지스트리 인증의 대안으로 미리 풀 된 이미지에 의존하고 싶다면,
클러스터의 모든 노드가 동일한 미리 내려받은 이미지를 가지고 있는지 확인해야 한다.</p>
<p>이것은 특정 이미지를 속도를 위해 미리 로드하거나 프라이빗 레지스트리에 대한 인증의 대안으로 사용될 수 있다.</p>
<p>모든 파드는 미리 내려받은 이미지에 대해 읽기 접근 권한을 가질 것이다.</p>
<h3 id=파드에-imagepullsecrets-명시>파드에 ImagePullSecrets 명시</h3>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> 이 방법은 프라이빗 레지스트리의 이미지를 기반으로 컨테이너를 실행하는 데
권장된다.
</div>
<p>쿠버네티스는 파드에 컨테이너 이미지 레지스트리 키를 명시하는 것을 지원한다.</p>
<h4 id=도커-구성으로-시크릿-생성>도커 구성으로 시크릿 생성</h4>
<p>대문자 값을 적절히 대체하여, 다음 커맨드를 실행한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create secret docker-registry &lt;name&gt; --docker-server<span style=color:#666>=</span>DOCKER_REGISTRY_SERVER --docker-username<span style=color:#666>=</span>DOCKER_USER --docker-password<span style=color:#666>=</span>DOCKER_PASSWORD --docker-email<span style=color:#666>=</span>DOCKER_EMAIL
</code></pre></div><p>만약 도커 자격 증명 파일이 이미 존재한다면, 위의 명령을 사용하지 않고,
자격 증명 파일을 쿠버네티스 <a class=glossary-tooltip title="비밀번호, OAuth 토큰 및 ssh 키와 같은 민감한 정보를 저장한다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/configuration/secret/ target=_blank aria-label=시크릿>시크릿</a>으로
가져올 수 있다.
<a href=/ko/docs/tasks/configure-pod-container/pull-image-private-registry/#registry-secret-existing-credentials>기존 도커 자격 증명으로 시크릿 생성</a>에서 관련 방법을 설명하고 있다.</p>
<p><code>kubectl create secret docker-registry</code>는
하나의 프라이빗 레지스트리에서만 작동하는 시크릿을 생성하기 때문에,
여러 프라이빗 컨테이너 레지스트리를 사용하는 경우 특히 유용하다.</p>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> 파드는 이미지 풀 시크릿을 자신의 네임스페이스에서만 참조할 수 있다.
따라서 이 과정은 네임스페이스 당 한 번만 수행될 필요가 있다.
</div>
<h4 id=파드의-imagepullsecrets-참조>파드의 imagePullSecrets 참조</h4>
<p>이제, <code>imagePullSecrets</code> 섹션을 파드의 정의에 추가함으로써 해당 시크릿을
참조하는 파드를 생성할 수 있다.</p>
<p>예를 들면 다음과 같다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>cat <span style=color:#b44>&lt;&lt;EOF &gt; pod.yaml
</span><span style=color:#b44>apiVersion: v1
</span><span style=color:#b44>kind: Pod
</span><span style=color:#b44>metadata:
</span><span style=color:#b44>  name: foo
</span><span style=color:#b44>  namespace: awesomeapps
</span><span style=color:#b44>spec:
</span><span style=color:#b44>  containers:
</span><span style=color:#b44>    - name: foo
</span><span style=color:#b44>      image: janedoe/awesomeapp:v1
</span><span style=color:#b44>  imagePullSecrets:
</span><span style=color:#b44>    - name: myregistrykey
</span><span style=color:#b44>EOF</span>

cat <span style=color:#b44>&lt;&lt;EOF &gt;&gt; ./kustomization.yaml
</span><span style=color:#b44>resources:
</span><span style=color:#b44>- pod.yaml
</span><span style=color:#b44>EOF</span>
</code></pre></div><p>이것은 프라이빗 레지스트리를 사용하는 각 파드에 대해서 수행될 필요가 있다.</p>
<p>그러나, 이 필드의 셋팅은 <a href=/docs/tasks/configure-pod-container/configure-service-account/>서비스 어카운트</a> 리소스에
imagePullSecrets을 셋팅하여 자동화할 수 있다.</p>
<p>자세한 지침을 위해서는 <a href=/docs/tasks/configure-pod-container/configure-service-account/#add-imagepullsecrets-to-a-service-account>서비스 어카운트에 ImagePullSecrets 추가</a>를 확인한다.</p>
<p>이것은 노드 당 <code>.docker/config.json</code>와 함께 사용할 수 있다. 자격 증명은
병합될 것이다.</p>
<h2 id=유스케이스>유스케이스</h2>
<p>프라이빗 레지스트리를 구성하기 위한 많은 솔루션이 있다. 다음은 여러 가지
일반적인 유스케이스와 제안된 솔루션이다.</p>
<ol>
<li>비소유 이미지(예를 들어, 오픈소스)만 실행하는 클러스터의 경우. 이미지를 숨길 필요가 없다.
<ul>
<li>도커 허브의 퍼블릭 이미지를 사용한다.
<ul>
<li>설정이 필요 없다.</li>
<li>일부 클라우드 제공자는 퍼블릭 이미지를 자동으로 캐시하거나 미러링하므로, 가용성이 향상되고 이미지를 가져오는 시간이 줄어든다.</li>
</ul>
</li>
</ul>
</li>
<li>모든 클러스터 사용자에게는 보이지만, 회사 외부에는 숨겨야하는 일부 독점 이미지를
실행하는 클러스터의 경우.
<ul>
<li>호스트 된 프라이빗 <a href=https://docs.docker.com/registry/>도커 레지스트리</a>를 사용한다.
<ul>
<li>그것은 <a href=https://hub.docker.com/signup>도커 허브</a>에 호스트 되어 있거나, 다른 곳에 되어 있을 것이다.</li>
<li>위에 설명된 바와 같이 수동으로 .docker/config.json을 구성한다.</li>
</ul>
</li>
<li>또는, 방화벽 뒤에서 읽기 접근 권한을 가진 내부 프라이빗 레지스트리를 실행한다.
<ul>
<li>쿠버네티스 구성은 필요 없다.</li>
</ul>
</li>
<li>이미지 접근을 제어하는 호스팅된 컨테이너 이미지 레지스트리 서비스를 사용한다.
<ul>
<li>그것은 수동 노드 구성에 비해서 클러스터 오토스케일링과 더 잘 동작할 것이다.</li>
</ul>
</li>
<li>또는, 노드의 구성 변경이 불편한 클러스터에서는, <code>imagePullSecrets</code>를 사용한다.</li>
</ul>
</li>
<li>독점 이미지를 가진 클러스터로, 그 중 일부가 더 엄격한 접근 제어를 필요로 하는 경우.
<ul>
<li><a href=/docs/reference/access-authn-authz/admission-controllers/#alwayspullimages>AlwaysPullImages 어드미션 컨트롤러</a>가 활성화되어 있는지 확인한다. 그렇지 않으면, 모든 파드가 잠재적으로 모든 이미지에 접근 권한을 가진다.</li>
<li>민감한 데이터는 이미지 안에 포장하는 대신, "시크릿" 리소스로 이동한다.</li>
</ul>
</li>
<li>멀티-테넌트 클러스터에서 각 테넌트가 자신의 프라이빗 레지스트리를 필요로 하는 경우.
<ul>
<li><a href=/docs/reference/access-authn-authz/admission-controllers/#alwayspullimages>AlwaysPullImages 어드미션 컨트롤러</a>가 활성화되어 있는지 확인한다. 그렇지 않으면, 모든 파드가 잠재적으로 모든 이미지에 접근 권한을 가진다.</li>
<li>인가가 요구되도록 프라이빗 레지스트리를 실행한다.</li>
<li>각 테넌트에 대한 레지스트리 자격 증명을 생성하고, 시크릿에 넣고, 각 테넌트 네임스페이스에 시크릿을 채운다.</li>
<li>테넌트는 해당 시크릿을 각 네임스페이스의 imagePullSecrets에 추가한다.</li>
</ul>
</li>
</ol>
<p>다중 레지스트리에 접근해야 하는 경우, 각 레지스트리에 대해 하나의 시크릿을 생성할 수 있다.
Kubelet은 모든 <code>imagePullSecrets</code> 파일을 하나의 가상 <code>.docker/config.json</code> 파일로 병합한다.</p>
<h2 id=다음-내용>다음 내용</h2>
<ul>
<li><a href=https://github.com/opencontainers/image-spec/blob/master/manifest.md>OCI 이미지 매니페스트 명세</a> 읽어보기.</li>
<li><a href=/ko/docs/concepts/architecture/garbage-collection/#container-image-garbage-collection>컨테이너 이미지 가비지 수집(garbage collection)</a>에 대해 배우기.</li>
<li><a href=/ko/docs/tasks/configure-pod-container/pull-image-private-registry>프라이빗 레지스트리에서 이미지 받아오기</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-a858027489648786a3b16264e451272b>3.2 - 런타임클래스(RuntimeClass)</h1>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.20 [stable]</code>
</div>
<p>이 페이지는 런타임클래스 리소스와 런타임 선택 메커니즘에 대해서 설명한다.</p>
<p>런타임클래스는 컨테이너 런타임을 구성을 선택하는 기능이다. 컨테이너 런타임
구성은 파드의 컨테이너를 실행하는 데 사용된다.</p>
<h2 id=동기>동기</h2>
<p>서로 다른 파드간에 런타임클래스를 설정하여
성능과 보안의 균형을 유지할 수 있다.
예를 들어, 일부 작업에서 높은 수준의 정보 보안 보증이 요구되는 경우,
하드웨어 가상화를 이용하는 컨테이너 런타임으로 파드를 실행하도록 예약하는 선택을 할 수 있다.
그러면 몇가지 추가적인 오버헤드는 있지만
대체 런타임을 추가 분리하는 유익이 있다.</p>
<p>또한 런타임클래스를 사용하여 컨테이너 런타임이 같으나 설정이 다른
여러 파드를 실행할 수 있다.</p>
<h2 id=셋업>셋업</h2>
<ol>
<li>CRI 구현(implementation)을 노드에 설정(런타임에 따라서).</li>
<li>상응하는 런타임클래스 리소스 생성.</li>
</ol>
<h3 id=1-cri-구현을-노드에-설정>1. CRI 구현을 노드에 설정</h3>
<p>런타임클래스를 통한 가능한 구성은 컨테이너 런타임 인터페이스(CRI) 구현에 의존적이다.
사용자의 CRI 구현에 따른 설정 방법은
연관된 문서를 통해서 확인한다(<a href=#cri-configuration>아래</a>).</p>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> 런타임클래스는 기본적으로 클러스터 전체에 걸쳐 동질의 노드 설정
(모든 노드가 컨테이너 런타임에 준하는 동일한 방식으로 설정되었음을 의미)을 가정한다.
이종의(heterogeneous) 노드 설정을 지원하기 위해서는, 아래 <a href=#%EC%8A%A4%EC%BC%80%EC%A4%84>스케줄</a>을 참고한다.
</div>
<p>해당 설정은 상응하는 <code>handler</code> 이름을 가지며, 이는 런타임클래스에 의해서 참조된다.
런타임 핸들러는 유효한 DNS 1123 서브도메인(알파-숫자 + <code>-</code>와 <code>.</code>문자)을 가져야 한다.</p>
<h3 id=2-상응하는-런타임클래스-리소스-생성>2. 상응하는 런타임클래스 리소스 생성</h3>
<p>1단계에서 셋업 한 설정은 연관된 <code>handler</code> 이름을 가져야 하며, 이를 통해서 설정을 식별할 수 있다.
각 런타임 핸들러(그리고 선택적으로 비어있는 <code>""</code> 핸들러)에 대해서, 상응하는 런타임클래스 오브젝트를 생성한다.</p>
<p>현재 런타임클래스 리소스는 런타임클래스 이름(<code>metadata.name</code>)과 런타임 핸들러
(<code>handler</code>)로 단 2개의 중요 필드만 가지고 있다. 오브젝트 정의는 다음과 같은 형태이다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>node.k8s.io/v1 <span style=color:#bbb> </span><span style=color:#080;font-style:italic># 런타임클래스는 node.k8s.io API 그룹에 정의되어 있음</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>RuntimeClass<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>myclass <span style=color:#bbb> </span><span style=color:#080;font-style:italic># 런타임클래스는 해당 이름을 통해서 참조됨</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 런타임클래스는 네임스페이스가 없는 리소스임</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>handler</span>:<span style=color:#bbb> </span>myconfiguration <span style=color:#bbb> </span><span style=color:#080;font-style:italic># 상응하는 CRI 설정의 이름임</span><span style=color:#bbb>
</span></code></pre></div><p>런타임클래스 오브젝트의 이름은 유효한
<a href=/ko/docs/concepts/overview/working-with-objects/names/#dns-%EB%A0%88%EC%9D%B4%EB%B8%94-%EC%9D%B4%EB%A6%84>DNS 레이블 이름</a>어이야 한다.</p>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> 런타임클래스 쓰기 작업(create/update/patch/delete)은
클러스터 관리자로 제한할 것을 권장한다. 이것은 일반적으로 기본 설정이다.
더 자세한 정보는 <a href=/ko/docs/reference/access-authn-authz/authorization/>권한 개요</a>를 참고한다.
</div>
<h2 id=사용>사용</h2>
<p>클러스터를 위해서 런타임클래스를 설정하고 나면, 그것을 사용하는 것은 매우 간단하다. 파드 스펙에
<code>runtimeClassName</code>를 명시한다. 예를 들면 다음과 같다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>runtimeClassName</span>:<span style=color:#bbb> </span>myclass<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span></code></pre></div><p>이것은 kubelet이 지명된 런타임클래스를 사용하여 해당 파드를 실행하도록 지시할 것이다.
만약 지명된 런타임클래스가 없거나, CRI가 상응하는 핸들러를 실행할 수 없는 경우, 파드는
<code>Failed</code> 터미널 <a href=/ko/docs/concepts/workloads/pods/pod-lifecycle/#%ED%8C%8C%EB%93%9C%EC%9D%98-%EB%8B%A8%EA%B3%84-phase>단계</a>로 들어간다.
에러 메시지에 상응하는 <a href=/docs/tasks/debug-application-cluster/debug-application-introspection/>이벤트</a>를
확인한다.</p>
<p>만약 명시된 <code>runtimeClassName</code>가 없다면, 기본 런타임 핸들러가 사용되며,
런타임클래스 기능이 비활성화되었을 때와 동일하게 동작한다.</p>
<h3 id=cri-configuration>CRI 구성</h3>
<p>CRI 런타임 설치에 대한 자세한 내용은 <a href=/ko/docs/setup/production-environment/container-runtimes/>CRI 설치</a>를 확인한다.</p>
<h4 id=dockershim>dockershim</h4>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.20 [deprecated]</code>
</div>
<p>dockershim은 쿠버네티스 v1.20에서 사용 중단되었으며, v1.24에서 제거될 것이다. 상세 사항은
<a href=/blog/2020/12/08/kubernetes-1-20-release-announcement/#dockershim-deprecation>dockershim 사용 중단</a>을 참고한다.</p>
<p>dockershim을 사용하는 경우 RuntimeClass는 런타임 핸들러를 <code>docker</code>로 고정한다.
dockershim은 사용자 정의 런타임 핸들러를 지원하지 않는다.</p>
<h4 id=hahahugoshortcode-s4-hbhb><a class=glossary-tooltip title="A container runtime with an emphasis on simplicity, robustness and portability" data-toggle=tooltip data-placement=top href=https://containerd.io/docs/ target=_blank aria-label=containerd>containerd</a></h4>
<p>런타임 핸들러는 containerd의 구성 파일인 <code>/etc/containerd/config.toml</code> 통해 설정한다.
유효한 핸들러는 runtimes 단락 아래에서 설정한다.</p>
<pre><code>[plugins.&quot;io.containerd.grpc.v1.cri&quot;.containerd.runtimes.${HANDLER_NAME}]
</code></pre><p>더 자세한 containerd의 구성 문서를 살펴본다.
<a href=https://github.com/containerd/cri/blob/master/docs/config.md>https://github.com/containerd/cri/blob/master/docs/config.md</a></p>
<h4 id=hahahugoshortcode-s5-hbhb><a class=glossary-tooltip title="A lightweight container runtime specifically for Kubernetes" data-toggle=tooltip data-placement=top href=https://cri-o.io/#what-is-cri-o target=_blank aria-label=CRI-O>CRI-O</a></h4>
<p>런타임 핸들러는 CRI-O의 구성파일인 <code>/etc/crio/crio.conf</code>을 통해 설정한다.
<a href=https://github.com/cri-o/cri-o/blob/master/docs/crio.conf.5.md#crioruntime-table>crio.runtime 테이블</a> 아래에
유효한 핸들러를 설정한다.</p>
<pre><code>[crio.runtime.runtimes.${HANDLER_NAME}]
  runtime_path = &quot;${PATH_TO_BINARY}&quot;
</code></pre><p>더 자세한 것은 CRI-O의 <a href=https://github.com/cri-o/cri-o/blob/master/docs/crio.conf.5.md>설정 문서</a>를 본다.</p>
<h2 id=스케줄>스케줄</h2>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.16 [beta]</code>
</div>
<p>RuntimeClass에 <code>scheduling</code> 필드를 지정하면, 이 RuntimeClass로 실행되는 파드가
이를 지원하는 노드로 예약되도록 제약 조건을 설정할 수 있다.
<code>scheduling</code>이 설정되지 않은 경우 이 RuntimeClass는 모든 노드에서 지원되는 것으로 간주된다.</p>
<p>파드가 지정된 런타임클래스를 지원하는 노드에 안착한다는 것을 보장하려면,
해당 노드들은 <code>runtimeClass.scheduling.nodeSelector</code> 필드에서 선택되는 공통 레이블을 가져야한다.
런타임 클래스의 nodeSelector는 파드의 nodeSelector와 어드미션 시 병합되어서, 실질적으로
각각에 의해 선택된 노드의 교집합을 취한다. 충돌이 있는 경우,
파드는 거부된다.</p>
<p>지원되는 노드가 테인트(taint)되어서 다른 런타임클래스 파드가 노드에서 구동되는 것을 막고 있다면,
<code>tolerations</code>를 런타임클래스에 추가할 수 있다. <code>nodeSelector</code>를 사용하면, 어드미션 시
해당 톨러레이션(toleration)이 파드의 톨러레이션과 병합되어, 실질적으로 각각에 의해 선택된
노드의 합집합을 취한다.</p>
<p>노드 셀렉터와 톨러레이션 설정에 대해 더 배우려면
<a href=/ko/docs/concepts/scheduling-eviction/assign-pod-node/>노드에 파드 할당</a>을 참고한다.</p>
<h3 id=파드-오버헤드>파드 오버헤드</h3>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.18 [beta]</code>
</div>
<p>파드 실행과 연관되는 <em>오버헤드</em> 리소스를 지정할 수 있다. 오버헤드를 선언하면
클러스터(스케줄러 포함)가 파드와 리소스에 대한 결정을 내릴 때 처리를 할 수 있다.
PodOverhead를 사용하려면, PodOverhead <a href=/ko/docs/reference/command-line-tools-reference/feature-gates/>기능 게이트</a>
를 활성화 시켜야 한다. (기본으로 활성화 되어 있다.)</p>
<p>파드 오버헤드는 런타임 클래스에서 <code>overhead</code> 필드를 통해 정의된다. 이 필드를 사용하면,
해당 런타임 클래스를 사용해서 구동 중인 파드의 오버헤드를 특정할 수 있고 이 오버헤드가
쿠버네티스 내에서 처리된다는 것을 보장할 수 있다.</p>
<h2 id=다음-내용>다음 내용</h2>
<ul>
<li><a href=https://github.com/kubernetes/enhancements/blob/master/keps/sig-node/585-runtime-class/README.md>런타임클래스 설계</a></li>
<li><a href=https://github.com/kubernetes/enhancements/blob/master/keps/sig-node/585-runtime-class/README.md#runtimeclass-scheduling>런타임클래스 스케줄링 설계</a></li>
<li><a href=/ko/docs/concepts/scheduling-eviction/pod-overhead/>파드 오버헤드</a> 개념에 대해 읽기</li>
<li><a href=https://github.com/kubernetes/enhancements/tree/master/keps/sig-node/688-pod-overhead>파드 오버헤드 기능 설계</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-643212488f778acf04bebed65ba34441>3.3 - 컨테이너 환경 변수</h1>
<p>이 페이지는 컨테이너 환경에서 컨테이너에 가용한 리소스에 대해 설명한다.</p>
<h2 id=컨테이너-환경>컨테이너 환경</h2>
<p>쿠버네티스 컨테이너 환경은 컨테이너에 몇 가지 중요한 리소스를 제공한다.</p>
<ul>
<li>하나의 <a href=/ko/docs/concepts/containers/images/>이미지</a>와 하나 이상의 <a href=/ko/docs/concepts/storage/volumes/>볼륨</a>이 결합된 파일 시스템.</li>
<li>컨테이너 자신에 대한 정보.</li>
<li>클러스터 내의 다른 오브젝트에 대한 정보.</li>
</ul>
<h3 id=컨테이너-정보>컨테이너 정보</h3>
<p>컨테이너의 <em>호스트네임</em> 은 컨테이너가 동작 중인 파드의 이름과 같다.
그것은 <code>hostname</code> 커맨드 또는 libc의
<a href=https://man7.org/linux/man-pages/man2/gethostname.2.html><code>gethostname</code></a>
함수 호출을 통해서 구할 수 있다.</p>
<p>파드 이름과 네임스페이스는
<a href=/ko/docs/tasks/inject-data-application/downward-api-volume-expose-pod-information/>다운워드(Downward) API</a>를 통해 환경 변수로 구할 수 있다.</p>
<p>컨테이너 이미지에 정적으로 명시된 환경 변수와 마찬가지로,
파드 정의에서의 사용자 정의 환경 변수도 컨테이너가 사용할 수 있다.</p>
<h3 id=클러스터-정보>클러스터 정보</h3>
<p>컨테이너가 생성될 때 실행 중이던 모든 서비스의 목록은 환경 변수로 해당 컨테이너에서 사용할 수
있다.
이 목록은 새로운 컨테이너의 파드 및 쿠버네티스 컨트롤 플레인 서비스와 동일한 네임스페이스 내에 있는 서비스로 한정된다.</p>
<p><em>bar</em> 라는 이름의 컨테이너에 매핑되는 <em>foo</em> 라는 이름의 서비스에 대해서는,
다음의 형태로 변수가 정의된다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#b8860b>FOO_SERVICE_HOST</span><span style=color:#666>=</span>&lt;서비스가 동작 중인 호스트&gt;
<span style=color:#b8860b>FOO_SERVICE_PORT</span><span style=color:#666>=</span>&lt;서비스가 동작 중인 포트&gt;
</code></pre></div><p>서비스에 지정된 IP 주소가 있고 <a href=https://releases.k8s.io/v1.23.17/cluster/addons/dns/>DNS 애드온</a>이 활성화된 경우, DNS를 통해서 컨테이너가 서비스를 사용할 수 있다.</p>
<h2 id=다음-내용>다음 내용</h2>
<ul>
<li><a href=/ko/docs/concepts/containers/container-lifecycle-hooks/>컨테이너 라이프사이클 훅(hooks)</a>에 대해 더 배워 보기.</li>
<li><a href=/docs/tasks/configure-pod-container/attach-handler-lifecycle-event/>컨테이너 라이프사이클 이벤트에 핸들러 부착</a>
실제 경험 얻기.</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-e6941d969d81540208a3e78bc56f43bc>3.4 - 컨테이너 라이프사이클 훅(Hook)</h1>
<p>이 페이지는 kubelet이 관리하는 컨테이너가 관리 라이프사이클 동안의 이벤트에 의해 발동되는 코드를 실행하기 위해서
컨테이너 라이프사이클 훅 프레임워크를 사용하는 방법에 대해서 설명한다.</p>
<h2 id=개요>개요</h2>
<p>Angular와 같이, 컴포넌트 라이프사이클 훅을 가진 많은 프로그래밍 언어 프레임워크와 유사하게,
쿠버네티스도 컨테이너에 라이프사이클 훅을 제공한다.
훅은 컨테이너가 관리 라이프사이클의 이벤트를 인지하고 상응하는
라이프사이클 훅이 실행될 때 핸들러에 구현된 코드를 실행할 수 있게 한다.</p>
<h2 id=컨테이너-훅>컨테이너 훅</h2>
<p>컨테이너에 노출되는 훅은 두 가지가 있다.</p>
<p><code>PostStart</code></p>
<p>이 훅은 컨테이너가 생성된 직후에 실행된다.
그러나, 훅이 컨테이너 엔트리포인트에 앞서서 실행된다는 보장은 없다.
파라미터는 핸들러에 전달되지 않는다.</p>
<p><code>PreStop</code></p>
<p>이 훅은 API 요청이나 활성 프로브(liveness probe) 실패, 선점, 자원 경합
등의 관리 이벤트로 인해 컨테이너가 종료되기 직전에 호출된다. 컨테이너가 이미
terminated 또는 completed 상태인 경우에는 <code>PreStop</code> 훅 요청이 실패하며,
훅은 컨테이너를 중지하기 위한 TERM 신호가 보내지기 이전에 완료되어야 한다. 파드의 그레이스 종료
기간(termination grace period)의 초읽기는 <code>PreStop</code> 훅이 실행되기 전에 시작되어,
핸들러의 결과에 상관없이 컨테이너가 파드의 그레이스 종료 기간 내에 결국 종료되도록 한다.
어떠한 파라미터도 핸들러에게 전달되지 않는다.</p>
<p>종료 동작에 더 자세한 대한 설명은
<a href=/ko/docs/concepts/workloads/pods/pod-lifecycle/#%ED%8C%8C%EB%93%9C%EC%9D%98-%EC%A2%85%EB%A3%8C>파드의 종료</a>에서 찾을 수 있다.</p>
<h3 id=훅-핸들러-구현>훅 핸들러 구현</h3>
<p>컨테이너는 훅의 핸들러를 구현하고 등록함으로써 해당 훅에 접근할 수 있다.
구현될 수 있는 컨테이너의 훅 핸들러에는 두 가지 유형이 있다.</p>
<ul>
<li>Exec - 컨테이너의 cgroups와 네임스페이스 안에서, <code>pre-stop.sh</code>와 같은, 특정 커맨드를 실행.
커맨드에 의해 소비된 리소스는 해당 컨테이너에 대해 계산된다.</li>
<li>HTTP - 컨테이너의 특정 엔드포인트에 대해서 HTTP 요청을 실행.</li>
</ul>
<h3 id=훅-핸들러-실행>훅 핸들러 실행</h3>
<p>컨테이너 라이프사이클 관리 훅이 호출되면,
쿠버네티스 관리 시스템은 훅 동작에 따라 핸들러를 실행하고,
<code>httpGet</code> 와 <code>tcpSocket</code> 은 kubelet 프로세스에 의해 실행되고, <code>exec</code> 은 컨테이너에서 실행된다.</p>
<p>훅 핸들러 호출은 해당 컨테이너를 포함하고 있는 파드의 컨텍스트와 동기적으로 동작한다.
이것은 <code>PostStart</code> 훅에 대해서,
훅이 컨테이너 엔트리포인트와는 비동기적으로 동작함을 의미한다.
그러나, 만약 해당 훅이 너무 오래 동작하거나 어딘가에 걸려 있다면,
컨테이너는 <code>running</code> 상태에 이르지 못한다.</p>
<p><code>PreStop</code> 훅은 컨테이너 중지 신호에서 비동기적으로 실행되지 않는다. 훅은
TERM 신호를 보내기 전에 실행을 완료해야 한다. 실행 중에 <code>PreStop</code> 훅이 중단되면,
파드의 단계는 <code>Terminating</code> 이며 <code>terminationGracePeriodSeconds</code> 가
만료된 후 파드가 종료될 때까지 남아 있다. 이 유예 기간은 <code>PreStop</code> 훅이
실행되고 컨테이너가 정상적으로 중지되는 데 걸리는 총 시간에 적용된다. 예를 들어,
<code>terminationGracePeriodSeconds</code> 가 60이고, 훅이 완료되는 데 55초가 걸리고,
컨테이너가 신호를 수신한 후 정상적으로 중지하는 데 10초가 걸리면, <code>terminationGracePeriodSeconds</code> 이후
컨테이너가 정상적으로 중지되기 전에 종료된다. 이 두 가지 일이 발생하는 데
걸리는 총 시간(55+10)보다 적다.</p>
<p>만약 <code>PostStart</code> 또는 <code>PreStop</code> 훅이 실패하면,
그것은 컨테이너를 종료시킨다.</p>
<p>사용자는 훅 핸들러를 가능한 한 가볍게 만들어야 한다.
그러나, 컨테이너가 멈추기 전 상태를 저장하는 것과 같이,
오래 동작하는 커맨드가 의미 있는 경우도 있다.</p>
<h3 id=훅-전달-보장>훅 전달 보장</h3>
<p>훅 전달은 <em>한 번 이상</em> 으로 의도되어 있는데,
이는 <code>PostStart</code> 또는 <code>PreStop</code>와 같은 특정 이벤트에 대해서,
훅이 여러 번 호출될 수 있다는 것을 의미한다.
이것을 올바르게 처리하는 것은 훅의 구현에 달려 있다.</p>
<p>일반적으로, 전달은 단 한 번만 이루어진다.
예를 들어, HTTP 훅 수신기가 다운되어 트래픽을 받을 수 없는 경우에도,
재전송을 시도하지 않는다.
그러나, 드문 경우로, 이중 전달이 발생할 수 있다.
예를 들어, 훅을 전송하는 도중에 kubelet이 재시작된다면,
Kubelet이 구동된 후에 해당 훅은 재전송될 것이다.</p>
<h3 id=디버깅-훅-핸들러>디버깅 훅 핸들러</h3>
<p>훅 핸들러의 로그는 파드 이벤트로 노출되지 않는다.
만약 핸들러가 어떠한 이유로 실패하면, 핸들러는 이벤트를 방송한다.
<code>PostStart</code>의 경우, 이것은 <code>FailedPostStartHook</code> 이벤트이며,
<code>PreStop</code>의 경우, 이것은 <code>FailedPreStopHook</code> 이벤트이다.
이 이벤트는 <code>kubectl describe pod &lt;파드_이름></code>를 실행하면 볼 수 있다.
다음은 이 커맨드 실행을 통한 이벤트 출력의 몇 가지 예다.</p>
<pre><code>Events:
  FirstSeen  LastSeen  Count  From                                                   SubObjectPath          Type      Reason               Message
  ---------  --------  -----  ----                                                   -------------          --------  ------               -------
  1m         1m        1      {default-scheduler }                                                          Normal    Scheduled            Successfully assigned test-1730497541-cq1d2 to gke-test-cluster-default-pool-a07e5d30-siqd
  1m         1m        1      {kubelet gke-test-cluster-default-pool-a07e5d30-siqd}  spec.containers{main}  Normal    Pulling              pulling image &quot;test:1.0&quot;
  1m         1m        1      {kubelet gke-test-cluster-default-pool-a07e5d30-siqd}  spec.containers{main}  Normal    Created              Created container with docker id 5c6a256a2567; Security:[seccomp=unconfined]
  1m         1m        1      {kubelet gke-test-cluster-default-pool-a07e5d30-siqd}  spec.containers{main}  Normal    Pulled               Successfully pulled image &quot;test:1.0&quot;
  1m         1m        1      {kubelet gke-test-cluster-default-pool-a07e5d30-siqd}  spec.containers{main}  Normal    Started              Started container with docker id 5c6a256a2567
  38s        38s       1      {kubelet gke-test-cluster-default-pool-a07e5d30-siqd}  spec.containers{main}  Normal    Killing              Killing container with docker id 5c6a256a2567: PostStart handler: Error executing in Docker Container: 1
  37s        37s       1      {kubelet gke-test-cluster-default-pool-a07e5d30-siqd}  spec.containers{main}  Normal    Killing              Killing container with docker id 8df9fdfd7054: PostStart handler: Error executing in Docker Container: 1
  38s        37s       2      {kubelet gke-test-cluster-default-pool-a07e5d30-siqd}                         Warning   FailedSync           Error syncing pod, skipping: failed to &quot;StartContainer&quot; for &quot;main&quot; with RunContainerError: &quot;PostStart handler: Error executing in Docker Container: 1&quot;
  1m         22s       2      {kubelet gke-test-cluster-default-pool-a07e5d30-siqd}  spec.containers{main}  Warning   FailedPostStartHook
</code></pre><h2 id=다음-내용>다음 내용</h2>
<ul>
<li><a href=/ko/docs/concepts/containers/container-environment/>컨테이너 환경</a>에 대해 더 배우기.</li>
<li><a href=/docs/tasks/configure-pod-container/attach-handler-lifecycle-event/>컨테이너 라이프사이클 이벤트에 핸들러 부착</a>
실습 경험하기.</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-d52aadda80edd9f8c514cfe2321363c2>4 - 워크로드</h1>
<div class=lead>쿠버네티스에서 배포할 수 있는 가장 작은 컴퓨트 오브젝트인 파드와, 이를 실행하는 데 도움이 되는 하이-레벨(higher-level) 추상화</div>
<p>워크로드는 쿠버네티스에서 구동되는 애플리케이션이다.
워크로드가 단일 컴포넌트이거나 함께 작동하는 여러 컴포넌트이든 관계없이, 쿠버네티스에서는 워크로드를 일련의
<a href=/ko/docs/concepts/workloads/pods><em>파드</em></a> 집합 내에서 실행한다.
쿠버네티스에서 <code>Pod</code> 는 클러스터에서 실행 중인 <a class=glossary-tooltip title="소프트웨어와 그것에 종속된 모든 것을 포함한 가볍고 휴대성이 높은 실행 가능 이미지." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/containers/ target=_blank aria-label=컨테이너>컨테이너</a>
집합을 나타낸다.</p>
<p>쿠버네티스 파드에는 <a href=/ko/docs/concepts/workloads/pods/pod-lifecycle/>정의된 라이프사이클</a>이 있다.
예를 들어, 일단 파드가 클러스터에서 실행되고 나서
해당 파드가 동작 중인 <a class=glossary-tooltip title="노드는 쿠버네티스의 작업 장비(worker machine)이다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/architecture/nodes/ target=_blank aria-label=노드>노드</a>에
심각한 오류가 발생하면 해당 노드의 모든 파드가 실패한다. 쿠버네티스는 이 수준의 실패를
최종(final)으로 취급한다. 사용자는 향후 노드가 복구되는 것과 상관 없이 <code>Pod</code> 를 새로 생성해야 한다.</p>
<p>그러나, 작업이 훨씬 쉽도록, 각 <code>Pod</code> 를 직접 관리할 필요는 없도록 만들었다.
대신, 사용자를 대신하여 파드 집합을 관리하는 <em>워크로드 리소스</em> 를 사용할 수 있다.
이러한 리소스는 지정한 상태와 일치하도록 올바른 수의 올바른 파드 유형이
실행되고 있는지 확인하는 <a class=glossary-tooltip title="API 서버를 통해 클러스터의 공유된 상태를 감시하고, 현재 상태를 원하는 상태로 이행시키는 컨트롤 루프." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/architecture/controller/ target=_blank aria-label=컨트롤러>컨트롤러</a>를
구성한다.</p>
<p>쿠버네티스는 다음과 같이 여러 가지 빌트인(built-in) 워크로드 리소스를 제공한다.</p>
<ul>
<li><a href=/ko/docs/concepts/workloads/controllers/deployment/><code>Deployment</code></a> 및 <a href=/ko/docs/concepts/workloads/controllers/replicaset/><code>ReplicaSet</code></a>
(레거시 리소스
<a class=glossary-tooltip title="(사용 중단된) 복제된 애플리케이션을 관리하는 API 오브젝트" data-toggle=tooltip data-placement=top href="/ko/docs/reference/glossary/?all=true#term-replication-controller" target=_blank aria-label=레플리케이션컨트롤러(ReplicationController)>레플리케이션컨트롤러(ReplicationController)</a>를 대체).
<code>Deployment</code> 는 <code>Deployment</code> 의 모든 <code>Pod</code> 가 필요 시 교체 또는 상호 교체 가능한 경우,
클러스터의 스테이트리스 애플리케이션 워크로드를 관리하기에 적합하다.</li>
<li><a href=/ko/docs/concepts/workloads/controllers/statefulset/><code>StatefulSet</code></a>는
어떻게든 스테이트(state)를 추적하는 하나 이상의 파드를 동작하게 해준다. 예를 들면, 워크로드가
데이터를 지속적으로 기록하는 경우, 사용자는 <code>Pod</code> 와
<a href=/ko/docs/concepts/storage/persistent-volumes/><code>PersistentVolume</code></a>을 연계하는 <code>StatefulSet</code> 을 실행할 수 있다.
전체적인 회복력 향상을 위해서, <code>StatefulSet</code> 의 <code>Pods</code> 에서 동작 중인 코드는 동일한 <code>StatefulSet</code> 의
다른 <code>Pods</code> 로 데이터를 복제할 수 있다.</li>
<li><a href=/ko/docs/concepts/workloads/controllers/daemonset/><code>DaemonSet</code></a>은 노드-로컬 기능(node-local facilities)을 제공하는 <code>Pods</code> 를 정의한다.
이러한 기능들은 클러스터를 운용하는 데 기본적인 것일 것이다.
예를 들면, 네트워킹 지원 도구 또는
<a class=glossary-tooltip title="Resources that extend the functionality of Kubernetes." data-toggle=tooltip data-placement=top href=/docs/concepts/cluster-administration/addons/ target=_blank aria-label=add-on>add-on</a> 등이 있다.
<code>DaemonSet</code> 의 명세에 맞는 노드를 클러스터에 추가할 때마다,
컨트롤 플레인은 해당 신규 노드에 <code>DaemonSet</code> 을 위한 <code>Pod</code> 를 스케줄한다.</li>
<li><a href=/ko/docs/concepts/workloads/controllers/job/><code>Job</code></a> 및
<a href=/ko/docs/concepts/workloads/controllers/cron-jobs/><code>CronJob</code></a>은
실행 완료 후 중단되는 작업을 정의한다. <code>CronJobs</code> 이 스케줄에 따라 반복되는 반면,
잡은 단 한 번의 작업을 나타낸다.</li>
</ul>
<p>더 넓은 쿠버네티스 에코시스템 내에서는 추가적인 동작을 제공하는 제 3자의 워크로드
리소스도 찾을 수 있다.
<a href=/ko/docs/concepts/extend-kubernetes/api-extension/custom-resources/>커스텀 리소스 데피니션</a>을 사용하면,
쿠버네티스 코어에서 제공하지 않는 특별한 동작을 원하는 경우 제 3자의 워크로드 리소스를
추가할 수 있다. 예를 들어, 사용자 애플리케이션을 위한 <code>Pods</code> 의 그룹을 실행하되
<em>모든</em> 파드가 가용한 경우가 아닌 경우 멈추고 싶다면(아마도 높은 처리량의 분산 처리를 하는 상황 같은),
사용자는 해당 기능을 제공하는 확장을 구현하거나 설치할 수 있다.</p>
<h2 id=다음-내용>다음 내용</h2>
<p>각 리소스에 대해 읽을 수 있을 뿐만 아니라, 리소스와 관련된 특정 작업에 대해서도 알아볼 수 있다.</p>
<ul>
<li><a href=/ko/docs/tasks/run-application/run-stateless-application-deployment/><code>Deployment</code> 를 사용하여 스테이트리스(stateless) 애플리케이션 실행</a></li>
<li>스테이트풀(stateful) 애플리케이션을 <a href=/ko/docs/tasks/run-application/run-single-instance-stateful-application/>단일 인스턴스</a>
또는 <a href=/docs/tasks/run-application/run-replicated-stateful-application/>복제된 세트</a>로 실행</li>
<li><a href=/ko/docs/tasks/job/automated-tasks-with-cron-jobs/><code>CronJob</code> 을 사용하여 자동화된 작업 실행</a></li>
</ul>
<p>코드를 구성(configuration)에서 분리하는 쿠버네티스의 메커니즘을 배우기 위해서는,
<a href=/ko/docs/concepts/configuration/>구성</a>을 참고하길 바란다.</p>
<p>다음은 쿠버네티스가 애플리케이션의 파드를 어떻게 관리하는지를 알 수 있게 해주는
두 가지 개념이다.</p>
<ul>
<li><a href=/ko/docs/concepts/architecture/garbage-collection/>가비지(Garbage) 수집</a>은 <em>소유하는 리소스</em> 가
제거된 후 클러스터에서 오브젝트를 정리한다.</li>
<li><a href=/ko/docs/concepts/workloads/controllers/ttlafterfinished/><em>time-to-live after finished</em> 컨트롤러</a>는
잡이 완료된 이후에 정의된 시간이 경과되면 잡을 제거한다.</li>
</ul>
<p>일단 애플리케이션이 실행되면, 인터넷에서 <a href=/ko/docs/concepts/services-networking/service/>서비스</a>로
사용하거나, 웹 애플리케이션의 경우에만
<a href=/ko/docs/concepts/services-networking/ingress>인그레스(Ingress)</a>를 이용하여 사용할 수 있다.</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-4d68b0ccf9c683e6368ffdcc40c838d4>4.1 - 파드</h1>
<p><em>파드(Pod)</em> 는 쿠버네티스에서 생성하고 관리할 수 있는 배포 가능한 가장 작은 컴퓨팅 단위이다.</p>
<p><em>파드</em> (고래 떼(pod of whales)나 콩꼬투리(pea pod)와 마찬가지로)는 하나 이상의
<a href=/ko/docs/concepts/containers/>컨테이너</a>의 그룹이다. 이 그룹은 스토리지 및 네트워크를 공유하고, 해당 컨테이너를 구동하는 방식에 대한 명세를 갖는다. 파드의 콘텐츠는 항상 함께 배치되고,
함께 스케줄되며, 공유 콘텍스트에서 실행된다. 파드는
애플리케이션 별 "논리 호스트"를 모델링한다. 여기에는 상대적으로 밀접하게 결합된 하나 이상의
애플리케이션 컨테이너가 포함된다.
클라우드가 아닌 콘텍스트에서, 동일한 물리 또는 가상 머신에서 실행되는 애플리케이션은 동일한 논리 호스트에서 실행되는 클라우드 애플리케이션과 비슷하다.</p>
<p>애플리케이션 컨테이너와 마찬가지로, 파드에는
파드 시작 중에 실행되는 <a href=/ko/docs/concepts/workloads/pods/init-containers/>초기화 컨테이너</a>가
포함될 수 있다. 클러스터가 제공하는 경우, 디버깅을 위해
<a href=/ko/docs/concepts/workloads/pods/ephemeral-containers/>임시 컨테이너</a>를
삽입할 수도 있다.</p>
<h2 id=파드란-무엇인가>파드란 무엇인가?</h2>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> <a href=https://www.docker.com/>도커</a>가 가장 일반적으로 잘 알려진
<a class=glossary-tooltip title="컨테이너 런타임은 컨테이너 실행을 담당하는 소프트웨어이다." data-toggle=tooltip data-placement=top href=/ko/docs/setup/production-environment/container-runtimes/ target=_blank aria-label="컨테이너 런타임">컨테이너 런타임</a>이지만,
쿠버네티스는 도커 외에도 다양한 컨테이너 런타임을 지원하며,
파드를 설명할 때 도커 관련 용어를 사용하면 더 쉽게 설명할 수 있다.
</div>
<p>파드의 공유 콘텍스트는 리눅스 네임스페이스, 컨트롤 그룹(cgroup) 및
도커 컨테이너를 격리하는 것과 같이 잠재적으로 다른 격리 요소들이다.
파드의 콘텍스트 내에서 개별 애플리케이션은
추가적으로 하위 격리가 적용된다.</p>
<p>도커 개념 측면에서, 파드는 공유 네임스페이스와 공유 파일시스템 볼륨이
있는 도커 컨테이너 그룹과 비슷하다.</p>
<h2 id=파드의-사용>파드의 사용</h2>
<p>다음은 <code>nginx:1.14.2</code> 이미지를 실행하는 컨테이너로 구성되는 파드의 예시이다.</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/ko/examples/pods/simple-pod.yaml download=pods/simple-pod.yaml><code>pods/simple-pod.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-simple-pod-yaml')" title="Copy pods/simple-pod.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-simple-pod-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.14.2<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>위에서 설명한 파드를 생성하려면, 다음 명령을 실행한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/pods/simple-pod.yaml
</code></pre></div><p>일반적으로 파드는 직접 생성하지는 않으며, 대신 워크로드 리소스를 사용하여 생성한다.
<a href=#%ED%8C%8C%EB%93%9C-%EC%9E%91%EC%97%85>파드 작업</a> 섹션에서 파드와 워크로드 리소스의 관계에 대한
더 많은 정보를 확인한다.</p>
<h3 id=workload-resources-for-managing-pods>Workload resources for managing pods</h3>
<p>일반적으로 싱글톤(singleton) 파드를 포함하여 파드를 직접 만들 필요가 없다. 대신, <a class=glossary-tooltip title="클러스터에서 복제된 애플리케이션을 관리한다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/controllers/deployment/ target=_blank aria-label=디플로이먼트(Deployment)>디플로이먼트(Deployment)</a> 또는 <a class=glossary-tooltip title="완료를 목표로 실행되는 유한 또는 배치 작업." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/controllers/job/ target=_blank aria-label=잡(Job)>잡(Job)</a>과 같은 워크로드 리소스를 사용하여 생성한다.
파드가 상태를 추적해야 한다면,
<a class=glossary-tooltip title="내구성이 있는 스토리지와 파드별로 지속성 식별자를 사용해서 파드 집합의 디플로이먼트와 스케일링을 관리한다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/controllers/statefulset/ target=_blank aria-label=스테이트풀셋(StatefulSet)>스테이트풀셋(StatefulSet)</a> 리소스를 고려한다.</p>
<p>쿠버네티스 클러스터의 파드는 두 가지 주요 방식으로 사용된다.</p>
<ul>
<li>
<p><strong>단일 컨테이너를 실행하는 파드</strong>. "파드 당 하나의 컨테이너" 모델은
가장 일반적인 쿠버네티스 유스케이스이다. 이 경우, 파드를 단일 컨테이너를 둘러싼
래퍼(wrapper)로 생각할 수 있다. 쿠버네티스는 컨테이너를 직접 관리하는 대신
파드를 관리한다.</p>
</li>
<li>
<p><strong>함께 작동해야 하는 여러 컨테이너를 실행하는 파드</strong>. 파드는
밀접하게 결합되어 있고 리소스를 공유해야 하는 함께 배치된 여러 개의 컨테이너로
구성된 애플리케이션을 캡슐화할 수 있다. 이런 함께 배치된 컨테이너는
하나의 결합된 서비스 단위를 형성한다. 예를 들어, 하나의 컨테이너는 공유 볼륨에
저장된 데이터를 퍼블릭에 제공하는 반면, 별도의 <em>사이드카</em> 컨테이너는
해당 파일을 새로 고치거나 업데이트한다.
파드는 이러한 컨테이너, 스토리지 리소스, 임시 네트워크 ID를
단일 단위로 함께 래핑한다.</p>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> 단일 파드에서 함께 배치된 또는 함께 관리되는 여러 컨테이너를 그룹화하는 것은
비교적 고급 유스케이스이다. 이 패턴은 컨테이너가 밀접하게 결합된
특정 인스턴스에서만 사용해야 한다.
</div>
</li>
</ul>
<p>각 파드는 특정 애플리케이션의 단일 인스턴스를 실행하기 위한 것이다. 더 많은
인스턴스를 실행하여 더 많은 전체 리소스를 제공하기 위해 애플리케이션을
수평적으로 확장하려면, 각 인스턴스에 하나씩, 여러 파드를 사용해야 한다.
쿠버네티스에서는 이를 일반적으로 <em>레플리케이션</em> 이라고 한다.
복제된 파드는 일반적으로 워크로드 리소스와
해당 <a class=glossary-tooltip title="API 서버를 통해 클러스터의 공유된 상태를 감시하고, 현재 상태를 원하는 상태로 이행시키는 컨트롤 루프." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/architecture/controller/ target=_blank aria-label=컨트롤러>컨트롤러</a>에 의해 그룹으로 생성되고 관리된다.</p>
<p>쿠버네티스가 워크로드 리소스와 해당 컨트롤러를 사용하여 애플리케이션 스케일링과
자동 복구를 구현하는 방법에 대한 자세한 내용은
<a href=#%ED%8C%8C%EB%93%9C%EC%99%80-%EC%BB%A8%ED%8A%B8%EB%A1%A4%EB%9F%AC>파드와 컨트롤러</a>를 참고한다.</p>
<h3 id=파드가-여러-컨테이너를-관리하는-방법>파드가 여러 컨테이너를 관리하는 방법</h3>
<p>파드는 응집력있는 서비스 단위를 형성하는 여러 협력 프로세스(컨테이너)를
지원하도록 설계되었다. 파드의 컨테이너는 클러스터의 동일한 물리 또는 가상 머신에서
자동으로 같은 위치에 배치되고 함께 스케줄된다. 컨테이너는
리소스와 의존성을 공유하고, 서로 통신하고, 종료 시기와 방법을
조정할 수 있다.</p>
<p>예를 들어, 다음 다이어그램에서와 같이
공유 볼륨의 파일에 대한 웹 서버 역할을 하는 컨테이너와, 원격 소스에서 해당 파일을 업데이트하는
별도의 "사이드카" 컨테이너가 있을 수 있다.</p>
<figure class=diagram-medium>
<img src=/images/docs/pod.svg alt="파드 생성 다이어그램">
</figure>
<p>일부 파드에는 <a class=glossary-tooltip title="워크로드의 일부를 실행하는데 사용되는 컨테이너. 초기화 컨테이너와 비교된다." data-toggle=tooltip data-placement=top href="/ko/docs/reference/glossary/?all=true#term-app-container" target=_blank aria-label="앱 컨테이너">앱 컨테이너</a> 뿐만 아니라 <a class=glossary-tooltip title="앱 컨테이너가 동작하기 전에 완료되기 위해 실행되는 하나 이상의 초기화 컨테이너." data-toggle=tooltip data-placement=top href="/ko/docs/reference/glossary/?all=true#term-init-container" target=_blank aria-label="초기화 컨테이너">초기화 컨테이너</a>를 갖고 있다. 초기화 컨테이너는 앱 컨테이너가 시작되기 전에 실행되고 완료된다.</p>
<p>파드는 기본적으로 파드에 속한 컨테이너에 <a href=#%ED%8C%8C%EB%93%9C-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%82%B9>네트워킹</a>과 <a href=#pod-storage>스토리지</a>라는
두 가지 종류의 공유 리소스를 제공한다.</p>
<h2 id=파드-작업>파드 작업</h2>
<p>사용자가 쿠버네티스에서 직접 개별 파드를 만드는 경우는 거의 없다. 싱글톤 파드도 마찬가지이다. 이는
파드가 상대적으로 일시적인, 일회용 엔티티로 설계되었기 때문이다. 파드가
생성될 때(사용자가 직접 또는
<a class=glossary-tooltip title="API 서버를 통해 클러스터의 공유된 상태를 감시하고, 현재 상태를 원하는 상태로 이행시키는 컨트롤 루프." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/architecture/controller/ target=_blank aria-label=컨트롤러>컨트롤러</a>가 간접적으로), 새 파드는
클러스터의 <a class=glossary-tooltip title="노드는 쿠버네티스의 작업 장비(worker machine)이다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/architecture/nodes/ target=_blank aria-label=노드>노드</a>에서 실행되도록 스케줄된다.
파드는 파드 실행이 완료되거나, 파드 오브젝트가 삭제되거나,
리소스 부족으로 인해 파드가 <em>축출</em> 되거나, 노드가 실패할 때까지 해당 노드에 남아있다.</p>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> 파드에서 컨테이너를 다시 시작하는 것과 파드를 다시 시작하는 것을 혼동해서는 안된다. 파드는
프로세스가 아니라 컨테이너를 실행하기 위한 환경이다. 파드는
삭제될 때까지 유지된다.
</div>
<p>파드 오브젝트에 대한 매니페스트를 만들 때, 지정된 이름이 유효한
<a href=/ko/docs/concepts/overview/working-with-objects/names/#dns-%EC%84%9C%EB%B8%8C%EB%8F%84%EB%A9%94%EC%9D%B8-%EC%9D%B4%EB%A6%84>DNS 서브도메인 이름</a>인지 확인한다.</p>
<h3 id=파드와-컨트롤러>파드와 컨트롤러</h3>
<p>워크로드 리소스를 사용하여 여러 파드를 만들고 관리할 수 있다. 리소스에 대한 컨트롤러는
파드 장애 시 복제 및 롤아웃과 자동 복구를
처리한다. 예를 들어, 노드가 실패하면, 컨트롤러는 해당 노드의 파드가 작동을 중지했음을
인식하고 대체 파드를 생성한다. 스케줄러는
대체 파드를 정상 노드에 배치한다.</p>
<p>다음은 하나 이상의 파드를 관리하는 워크로드 리소스의 몇 가지 예시이다.</p>
<ul>
<li><a class=glossary-tooltip title="클러스터에서 복제된 애플리케이션을 관리한다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/controllers/deployment/ target=_blank aria-label=디플로이먼트>디플로이먼트</a></li>
<li><a class=glossary-tooltip title="내구성이 있는 스토리지와 파드별로 지속성 식별자를 사용해서 파드 집합의 디플로이먼트와 스케일링을 관리한다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/controllers/statefulset/ target=_blank aria-label=스테이트풀셋>스테이트풀셋</a></li>
<li><a class=glossary-tooltip title="파드의 복제본을 클러스터 노드 집합에서 동작하게 한다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/controllers/daemonset target=_blank aria-label=데몬셋(DaemonSet)>데몬셋(DaemonSet)</a></li>
</ul>
<h3 id=파드-템플릿>파드 템플릿</h3>
<p><a class=glossary-tooltip title="워크로드는 클러스터의 컨테이너를 동작시키고 관리하기 위해 사용하는 오브젝트이다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/ target=_blank aria-label=워크로드>워크로드</a> 리소스에 대한 컨트롤러는
<em>파드 템플릿</em> 에서 파드를 생성하고 사용자 대신 해당 파드를 관리한다.</p>
<p>파드템플릿(PodTemplate)은 파드를 생성하기 위한 명세이며,
<a href=/ko/docs/concepts/workloads/controllers/deployment/>디플로이먼트</a>,
<a href=/ko/docs/concepts/workloads/controllers/job/>잡</a> 및
<a href=/ko/docs/concepts/workloads/controllers/daemonset/>데몬셋</a>과 같은 워크로드 리소스에 포함된다.</p>
<p>워크로드 리소스의 각 컨트롤러는 워크로드 오브젝트 내부의 <code>PodTemplate</code> 을
사용하여 실제 파드를 생성한다. <code>PodTemplate</code> 은 앱을 실행하는 데 사용되는 워크로드 리소스가
무엇이든지 원하는 상태의 일부이다.</p>
<p>아래 샘플은 하나의 컨테이너를 시작하는 <code>template</code> 이 있는 간단한 잡의
매니페스트이다. 해당 파드의 컨테이너는 메시지를 출력한 다음 일시 중지한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>batch/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Job<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>hello<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 여기서부터 파드 템플릿이다</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>hello<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#39;sh&#39;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#39;-c&#39;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#39;echo &#34;Hello, Kubernetes!&#34; &amp;&amp; sleep 3600&#39;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>OnFailure<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 여기까지 파드 템플릿이다</span><span style=color:#bbb>
</span></code></pre></div><p>파드 템플릿을 수정하거나 새로운 파드 템플릿으로 바꿔도 이미 존재하는
파드에는 직접적인 영향을 주지 않는다. 워크로드 리소스의 파드 템플릿을
변경하는 경우, 해당 리소스는 수정된 템플릿을 사용하는 대체 파드를 생성해야 한다.</p>
<p>예를 들어, 스테이트풀셋 컨트롤러는 실행 중인 파드가 각 스테이트풀셋 오브젝트에 대한 현재
파드 템플릿과 일치하는지 확인한다. 스테이트풀셋을 수정하여 파드 템플릿을
변경하면, 스테이트풀셋이 업데이트된 템플릿을 기반으로 새로운 파드를 생성하기 시작한다.
결국, 모든 이전의 파드가 새로운 파드로 교체되고, 업데이트가 완료된다.</p>
<p>각 워크로드 리소스는 파드 템플릿의 변경 사항을 처리하기 위한 자체 규칙을 구현한다.
스테이트풀셋에 대해 자세히 알아 보려면,
스테이트풀셋 기본 튜토리얼에서 <a href=/ko/docs/tutorials/stateful-application/basic-stateful-set/#%EC%8A%A4%ED%85%8C%EC%9D%B4%ED%8A%B8%ED%92%80%EC%85%8B-%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8%ED%95%98%EA%B8%B0>업데이트 전략</a>을 읽어본다.</p>
<p>노드에서 <a class=glossary-tooltip title="클러스터의 각 노드에서 실행되는 에이전트. Kubelet은 파드에서 컨테이너가 확실하게 동작하도록 관리한다." data-toggle=tooltip data-placement=top href=/docs/reference/generated/kubelet target=_blank aria-label=kubelet>kubelet</a>은
파드 템플릿과 업데이트에 대한 상세 정보를 직접 관찰하거나 관리하지 않는다. 이러한
상세 내용은 추상화된다. 이러한 추상화와 관심사 분리(separation of concerns)는
시스템 시맨틱을 단순화하고, 기존 코드를 변경하지 않고도 클러스터의 동작을
확장할 수 있게 한다.</p>
<h2 id=파드-갱신-및-교체>파드 갱신 및 교체</h2>
<p>이전 섹션에서 언급한 바와 같이, 워크로드 리소스의 파드
템플릿이 바뀌면, 컨트롤러는 기존의 파드를 갱신하거나 패치하는 대신
갱신된 템플릿을 기반으로 신규 파드를 생성한다.</p>
<p>쿠버네티스는 사용자가 파드를 직접 관리하는 것을 막지는 않는다.
동작 중인 파드의 필드를 갱신하는 것도 가능하다.
그러나,
<a href=/docs/reference/generated/kubernetes-api/v1.23/#patch-pod-v1-core><code>patch</code></a> 및
<a href=/docs/reference/generated/kubernetes-api/v1.23/#replace-pod-v1-core><code>replace</code></a>와 같은
파드 갱신 작업에는 다음과 같은 제약이 있다.</p>
<ul>
<li>
<p>파드에 대한 대부분의 메타데이터는 불변(immutable)이다. 예를 들면, 사용자는
<code>namespace</code>, <code>name</code>, <code>uid</code>, 또는 <code>creationTimestamp</code> 필드를 변경할 수 없다.
그리고 <code>generation</code> 필드는 고유하다. 이 필드는 필드의 현재 값을 증가시키는
갱신만 허용한다.</p>
</li>
<li>
<p><code>metadata.deletionTimestamp</code> 가 설정된 경우,
<code>metadata.finalizers</code> 리스트에 새로운 항목이 추가될 수 없다.</p>
</li>
<li>
<p>파드 갱신은 <code>spec.containers[*].image</code>, <code>spec.initContainers[*].image</code>,
<code>spec.activeDeadlineSeconds</code>, 또는 <code>spec.tolerations</code> 이외의 필드는
변경하지 않을 것이다. <code>spec.tolerations</code> 에 대해서만 새로운 항목을 추가할 수 있다.</p>
</li>
<li>
<p><code>spec.activeDeadlineSeconds</code> 필드를 추가할 때는, 다음의 두 가지 형태의 갱신만
허용한다.</p>
<ol>
<li>지정되지 않은 필드를 양수로 설정;</li>
<li>필드의 양수를 음수가 아닌 더 작은 숫자로
갱신.</li>
</ol>
</li>
</ul>
<h2 id=리소스-공유와-통신>리소스 공유와 통신</h2>
<p>파드는 파드에 속한 컨테이너 간의 데이터 공유와 통신을
지원한다.</p>
<h3 id=pod-storage>파드 스토리지</h3>
<p>파드는 공유 스토리지 <a class=glossary-tooltip title="데이터를 포함하고 있는 디렉터리이며, 파드의 컨테이너에서 접근 가능하다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/storage/volumes/ target=_blank aria-label=볼륨>볼륨</a>의
집합을 지정할 수 있다. 파드의 모든 컨테이너는
공유 볼륨에 접근할 수 있으므로, 해당 컨테이너가 데이터를 공유할 수
있다. 또한 볼륨은 내부 컨테이너 중 하나를 다시
시작해야 하는 경우 파드의 영구 데이터를 유지하도록 허용한다.
쿠버네티스가 공유 스토리지를 구현하고 파드에서 사용할 수 있도록 하는 방법에 대한
자세한 내용은 <a href=/ko/docs/concepts/storage/>스토리지</a>를 참고한다.</p>
<h3 id=파드-네트워킹>파드 네트워킹</h3>
<p>각 파드에는 각 주소 패밀리에 대해 고유한 IP 주소가 할당된다. 파드의
모든 컨테이너는 IP 주소와 네트워크 포트를 포함하여 네트워크 네임스페이스를
공유한다. 파드 내부(그때 <strong>만</strong> 해당)에서, 파드에 속한
컨테이너는 <code>localhost</code> 를 사용하여 서로 통신할 수 있다. 파드의 컨테이너가
<em>파드 외부의</em> 엔티티와 통신할 때,
공유 네트워크 리소스(포트와 같은)를 사용하는 방법을 조정해야 한다.
파드 내에서 컨테이너는 IP 주소와 포트 공간을 공유하며,
<code>localhost</code> 를 통해 서로를 찾을 수 있다. 파드의 컨테이너는 SystemV 세마포어 또는
POSIX 공유 메모리와 같은 표준 프로세스 간 통신을 사용하여 서로
통신할 수도 있다. 다른 파드의 컨테이너는
고유한 IP 주소를 가지며
<a href=/ko/docs/concepts/policy/pod-security-policy/>특별한 구성</a> 없이 IPC로 통신할 수 없다.
다른 파드에서 실행되는 컨테이너와 상호 작용하려는 컨테이너는 IP 네트워킹을
사용하여 통신할 수 있다.</p>
<p>파드 내의 컨테이너는 시스템 호스트명이 파드에 대해 구성된
<code>name</code> 과 동일한 것으로 간주한다. <a href=/ko/docs/concepts/cluster-administration/networking/>네트워킹</a> 섹션에 이에 대한
자세한 내용이 있다.</p>
<h2 id=컨테이너에-대한-특권-모드>컨테이너에 대한 특권 모드</h2>
<p>리눅스에서, 파드의 모든 컨테이너는 컨테이너 명세의 <a href=/docs/tasks/configure-pod-container/security-context/>보안 컨텍스트</a>에 있는 <code>privileged</code> (리눅스) 플래그를 사용하여 특권 모드를 활성화할 수 있다. 이는 네트워크 스택 조작이나 하드웨어 장치 접근과 같은 운영 체제 관리 기능을 사용하려는 컨테이너에 유용하다.</p>
<p>클러스터가 <code>WindowsHostProcessContainers</code> 기능을 활성화하였다면, 파드 스펙의 보안 컨텍스트의 <code>windowsOptions.hostProcess</code> 에 의해 <a href=/docs/tasks/configure-pod-container/create-hostprocess-pod>윈도우 HostProcess 파드</a>를 생성할 수 있다. 이러한 모든 컨테이너는 윈도우 HostProcess 컨테이너로 실행해야 한다. HostProcess 파드는 직접적으로 호스트에서 실행하는 것으로, 리눅스 특권있는 컨테이너에서 수행되는 관리 태스크 수행에도 사용할 수 있다. 파드의 모든 컨테이너는 윈도우 HostProcess 컨테이너로 반드시 실행해야 한다. HostProcess 파드는 호스트에서 직접 실행되며 리눅스 특권있는 컨테이너에서 수행되는 것과 같은 관리 작업을 수행하는데도 사용할 수 있다.</p>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> 이 설정을 사용하려면 사용자의 <a class=glossary-tooltip title="컨테이너 런타임은 컨테이너 실행을 담당하는 소프트웨어이다." data-toggle=tooltip data-placement=top href=/ko/docs/setup/production-environment/container-runtimes/ target=_blank aria-label="컨테이너 런타임">컨테이너 런타임</a>이 특권이 있는 컨테이너의 개념을 지원해야 한다.
</div>
<h2 id=정적-파드>정적 파드</h2>
<p><em>정적 파드</em> 는 <a class=glossary-tooltip title="쿠버네티스 API를 제공하는 컨트롤 플레인 컴포넌트." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/overview/components/#kube-apiserver target=_blank aria-label="API 서버">API 서버</a>가
관찰하는 대신 특정 노드의 kubelet 데몬에 의해 직접
관리된다.
대부분의 파드는 컨트롤 플레인(예를 들어,
<a class=glossary-tooltip title="클러스터에서 복제된 애플리케이션을 관리한다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/controllers/deployment/ target=_blank aria-label=디플로이먼트>디플로이먼트</a>)에 의해 관리되고, 정적 파드의
경우, kubelet이 각 정적 파드를 직접 감독한다(실패하면 다시 시작한다).</p>
<p>정적 파드는 항상 특정 노드의 <a class=glossary-tooltip title="클러스터의 각 노드에서 실행되는 에이전트. Kubelet은 파드에서 컨테이너가 확실하게 동작하도록 관리한다." data-toggle=tooltip data-placement=top href=/docs/reference/generated/kubelet target=_blank aria-label=Kubelet>Kubelet</a> 하나에 바인딩된다.
정적 파드의 주요 용도는 자체 호스팅 컨트롤 플레인을 실행하는 것이다. 즉,
kubelet을 사용하여 개별 <a href=/ko/docs/concepts/overview/components/#%EC%BB%A8%ED%8A%B8%EB%A1%A4-%ED%94%8C%EB%A0%88%EC%9D%B8-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8>컨트롤 플레인 컴포넌트</a>를 감독한다.</p>
<p>kubelet은 자동으로 각 정적 파드에 대한 쿠버네티스 API 서버에서 <a class=glossary-tooltip title="Kubelet의 스태틱 파드(Static Pod)를 추적하는 API 서버 내부의 오브젝트." data-toggle=tooltip data-placement=top href="/ko/docs/reference/glossary/?all=true#term-mirror-pod" target=_blank aria-label="미러 파드">미러 파드</a>를
생성하려고 한다.
즉, 노드에서 실행되는 파드는 API 서버에서 보이지만,
여기에서 제어할 수는 없다는 의미이다.</p>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> 스태틱 파드의 <code>스펙(spec)</code>은 다른 API 오브젝트
(예를 들면, <a class=glossary-tooltip title="파드에서 실행 중인 프로세스를 위한 신원(identity)을 제공한다." data-toggle=tooltip data-placement=top href=/docs/tasks/configure-pod-container/configure-service-account/ target=_blank aria-label=서비스어카운트>서비스어카운트</a>,
<a class=glossary-tooltip title="키-값 쌍으로 기밀이 아닌 데이터를 저장하는 데 사용하는 API 오브젝트이다. 볼륨에서 환경 변수, 커맨드-라인 인수 또는 구성 파일로 사용될 수 있다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/configuration/configmap/ target=_blank aria-label=컨피그맵>컨피그맵</a>,
<a class=glossary-tooltip title="비밀번호, OAuth 토큰 및 ssh 키와 같은 민감한 정보를 저장한다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/configuration/secret/ target=_blank aria-label=시크릿>시크릿</a>, 등)가 참조할 수 없다.
</div>
<h2 id=컨테이너-프로브>컨테이너 프로브</h2>
<p>_프로브_는 컨테이너의 kubelet에 의해 주기적으로 실행되는 진단이다. 진단을 수행하기 위하여 kubelet은 다음과 같은 작업을 호출할 수 있다.</p>
<ul>
<li><code>ExecAction</code> (컨테이너 런타임의 도움을 받아 수행)</li>
<li><code>TCPSocketAction</code> (kubelet에 의해 직접 검사)</li>
<li><code>HTTPGetAction</code> (kubelet에 의해 직접 검사)</li>
</ul>
<p><a href=/ko/docs/concepts/workloads/pods/pod-lifecycle/#%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88-%ED%94%84%EB%A1%9C%EB%B8%8C-probe>프로브</a>에 대한 자세한 내용은
파드 라이프사이클 문서를 참고한다.</p>
<h2 id=다음-내용>다음 내용</h2>
<ul>
<li><a href=/ko/docs/concepts/workloads/pods/pod-lifecycle/>파드의 라이프사이클</a>에 대해 알아본다.</li>
<li><a href=/ko/docs/concepts/containers/runtime-class/>런타임클래스(RuntimeClass)</a>와 이를 사용하여
다양한 컨테이너 런타임 구성으로 다양한 파드를 설정하는 방법에 대해 알아본다.</li>
<li><a href=/ko/docs/concepts/workloads/pods/pod-topology-spread-constraints/>파드 토폴로지 분배 제약 조건</a>에 대해 읽어본다.</li>
<li><a href=/ko/docs/concepts/workloads/pods/disruptions/>PodDisruptionBudget</a>과 이를 사용하여 서비스 중단 중에 애플리케이션 가용성을 관리하는 방법에 대해 읽어본다.</li>
<li>파드는 쿠버네티스 REST API의 최상위 리소스이다.
<a href=/docs/reference/kubernetes-api/workload-resources/pod-v1/>Pod</a>
오브젝트 정의는 오브젝트를 상세히 설명한다.</li>
<li><a href=/blog/2015/06/the-distributed-system-toolkit-patterns/>분산 시스템 툴킷: 컴포지트 컨테이너에 대한 패턴</a>은 둘 이상의 컨테이너가 있는 파드의 일반적인 레이아웃을 설명한다.</li>
</ul>
<p>쿠버네티스가 다른 리소스(<a class=glossary-tooltip title="내구성이 있는 스토리지와 파드별로 지속성 식별자를 사용해서 파드 집합의 디플로이먼트와 스케일링을 관리한다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/controllers/statefulset/ target=_blank aria-label=스테이트풀셋>스테이트풀셋</a>이나 <a class=glossary-tooltip title="클러스터에서 복제된 애플리케이션을 관리한다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/controllers/deployment/ target=_blank aria-label=디플로이먼트>디플로이먼트</a>와 같은)에서 공통 파드 API를 래핑하는 이유에 대한 콘텍스트를 이해하기 위해서, 다음과 같은 선행 기술에 대해 읽어볼 수 있다.</p>
<ul>
<li><a href=https://aurora.apache.org/documentation/latest/reference/configuration/#job-schema>Aurora</a></li>
<li><a href=https://research.google.com/pubs/pub43438.html>Borg</a></li>
<li><a href=https://mesosphere.github.io/marathon/docs/rest-api.html>Marathon</a></li>
<li><a href=https://research.google/pubs/pub41684/>Omega</a></li>
<li><a href=https://engineering.fb.com/data-center-engineering/tupperware/>Tupperware</a>.</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-c3c2b9cf30915ec9d46c147201da3332>4.1.1 - 파드 라이프사이클</h1>
<p>이 페이지에서는 파드의 라이프사이클을 설명한다. 파드는 정의된 라이프사이클을 따른다.
<code>Pending</code> <a href=#%ED%8C%8C%EB%93%9C%EC%9D%98-%EB%8B%A8%EA%B3%84>단계</a>에서 시작해서, 기본 컨테이너 중 적어도 하나
이상이 OK로 시작하면 <code>Running</code> 단계를 통과하고, 그런 다음 파드의 컨테이너가
실패로 종료되었는지 여부에 따라 <code>Succeeded</code> 또는 <code>Failed</code> 단계로 이동한다.</p>
<p>파드가 실행되는 동안, kubelet은 일종의 오류를 처리하기 위해 컨테이너를 다시
시작할 수 있다. 파드 내에서, 쿠버네티스는 다양한 컨테이너
<a href=#%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88-%EC%83%81%ED%83%9C>상태</a>를 추적하고 파드를 다시 정상 상태로 만들기 위해 취할 조치를
결정한다.</p>
<p>쿠버네티스 API에서 파드는 명세와 실제 상태를 모두 가진다.
파드 오브젝트의 상태는 일련의 <a href=#%ED%8C%8C%EB%93%9C%EC%9D%98-%EC%BB%A8%EB%94%94%EC%85%98>파드 컨디션</a>으로 구성된다.
사용자의 애플리케이션에 유용한 경우, 파드의 컨디션 데이터에
<a href=#pod-readiness-gate>사용자 정의 준비성 정보</a>를 삽입할 수도 있다.</p>
<p>파드는 파드의 수명 중 한 번만 <a href=/ko/docs/concepts/scheduling-eviction/>스케줄</a>된다.
파드가 노드에 스케줄(할당)되면, 파드는 중지되거나 <a href=#pod-termination>종료</a>될 때까지
해당 노드에서 실행된다.</p>
<h2 id=파드의-수명>파드의 수명</h2>
<p>개별 애플리케이션 컨테이너와 마찬가지로, 파드는 비교적
임시(계속 이어지는 것이 아닌) 엔티티로 간주된다. 파드가 생성되고, 고유
ID(<a href=/ko/docs/concepts/overview/working-with-objects/names/#uids>UID</a>)가
할당되고, 종료(재시작 정책에 따라) 또는 삭제될 때까지 남아있는 노드에
스케줄된다.
만약 <a class=glossary-tooltip title="노드는 쿠버네티스의 작업 장비(worker machine)이다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/architecture/nodes/ target=_blank aria-label=노드>노드</a>가 종료되면, 해당 노드에 스케줄된 파드는
타임아웃 기간 후에 <a href=#pod-garbage-collection>삭제되도록 스케줄된다</a>.</p>
<p>파드는 자체적으로 자가 치유되지 않는다. 파드가
<a class=glossary-tooltip title="노드는 쿠버네티스의 작업 장비(worker machine)이다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/architecture/nodes/ target=_blank aria-label=노드>노드</a>에 스케줄된 후에 해당 노드가 실패하면, 파드는 삭제된다. 마찬가지로, 파드는
리소스 부족 또는 노드 유지 관리 작업으로 인한 축출에서 살아남지 못한다. 쿠버네티스는
<a class=glossary-tooltip title="API 서버를 통해 클러스터의 공유된 상태를 감시하고, 현재 상태를 원하는 상태로 이행시키는 컨트롤 루프." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/architecture/controller/ target=_blank aria-label=컨트롤러>컨트롤러</a>라
부르는 하이-레벨 추상화를 사용하여
상대적으로 일회용인 파드 인스턴스를 관리하는 작업을 처리한다.</p>
<p>UID로 정의된 특정 파드는 다른 노드로 절대 "다시 스케줄"되지 않는다. 대신,
해당 파드는 사용자가 원한다면 이름은 같지만, UID가 다른, 거의 동일한 새 파드로
대체될 수 있다.</p>
<p><a class=glossary-tooltip title="데이터를 포함하고 있는 디렉터리이며, 파드의 컨테이너에서 접근 가능하다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/storage/volumes/ target=_blank aria-label=볼륨>볼륨</a>과
같은 어떤 것이 파드와 동일한 수명을 갖는다는 것은,
특정 파드(정확한 UID 포함)가 존재하는 한 그것이 존재함을
의미한다. 어떤 이유로든 해당 파드가 삭제되고, 동일한 대체 파드가
생성되더라도, 관련된 그것(이 예에서는 볼륨)도 폐기되고
새로 생성된다.</p>
<figure class=diagram-medium>
<img src=/images/docs/pod.svg> <figcaption>
<h4>Pod diagram</h4>
</figcaption>
</figure>
<p><em>컨테이너 간의 공유 스토리지에 퍼시스턴트 볼륨을 사용하는 웹 서버와
파일 풀러(puller)가 포함된 다중 컨테이너 파드이다.</em></p>
<h2 id=파드의-단계>파드의 단계</h2>
<p>파드의 <code>status</code> 필드는
<code>phase</code> 필드를 포함하는
<a href=/docs/reference/generated/kubernetes-api/v1.23/#podstatus-v1-core>PodStatus</a> 오브젝트로 정의된다.</p>
<p>파드의 phase는 파드가 라이프사이클 중 어느 단계에 해당하는지 표현하는 간단한
고수준의 요약이다. Phase는 컨테이너나 파드의 관측 정보에 대한 포괄적인
롤업이나, 포괄적인 상태 머신을 표현하도록 의도되지는 않았다.</p>
<p>파드 phase 값에서 숫자와 의미는 엄격하게 지켜진다.
여기에 문서화된 내용 이외에는, 파드와 파드에 주어진 <code>phase</code> 값에 대해서
어떤 사항도 가정되어서는 안 된다.</p>
<p><code>phase</code>에 가능한 값은 다음과 같다.</p>
<table>
<thead>
<tr>
<th style=text-align:left>값</th>
<th style=text-align:left>의미</th>
</tr>
</thead>
<tbody>
<tr>
<td style=text-align:left><code>Pending</code></td>
<td style=text-align:left>파드가 쿠버네티스 클러스터에서 승인되었지만, 하나 이상의 컨테이너가 설정되지 않았고 실행할 준비가 되지 않았다. 여기에는 파드가 스케줄되기 이전까지의 시간 뿐만 아니라 네트워크를 통한 컨테이너 이미지 다운로드 시간도 포함된다.</td>
</tr>
<tr>
<td style=text-align:left><code>Running</code></td>
<td style=text-align:left>파드가 노드에 바인딩되었고, 모든 컨테이너가 생성되었다. 적어도 하나의 컨테이너가 아직 실행 중이거나, 시작 또는 재시작 중에 있다.</td>
</tr>
<tr>
<td style=text-align:left><code>Succeeded</code></td>
<td style=text-align:left>파드에 있는 모든 컨테이너들이 성공적으로 종료되었고, 재시작되지 않을 것이다.</td>
</tr>
<tr>
<td style=text-align:left><code>Failed</code></td>
<td style=text-align:left>파드에 있는 모든 컨테이너가 종료되었고, 적어도 하나 이상의 컨테이너가 실패로 종료되었다. 즉, 해당 컨테이너는 non-zero 상태로 빠져나왔거나(exited) 시스템에 의해서 종료(terminated)되었다.</td>
</tr>
<tr>
<td style=text-align:left><code>Unknown</code></td>
<td style=text-align:left>어떤 이유에 의해서 파드의 상태를 얻을 수 없다. 이 단계는 일반적으로 파드가 실행되어야 하는 노드와의 통신 오류로 인해 발생한다.</td>
</tr>
</tbody>
</table>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> 파드가 삭제될 때, 일부 kubectl 커맨드에서 <code>Terminating</code> 이 표시된다.
이 <code>Terminating</code> 상태는 파드의 단계에 해당하지 않는다.
파드에는 그레이스풀하게(gracefully) 종료되도록 기간이 부여되며, 그 기본값은 30초이다.
<a href=/ko/docs/concepts/workloads/pods/pod-lifecycle/#pod-termination-forced>강제로 파드를 종료</a>하려면 <code>--force</code> 플래그를 설정하면 된다.
</div>
<p>노드가 죽거나 클러스터의 나머지와의 연결이 끊어지면, 쿠버네티스는
손실된 노드의 모든 파드의 <code>phase</code> 를 Failed로 설정하는 정책을 적용한다.</p>
<h2 id=컨테이너-상태>컨테이너 상태</h2>
<p>전체 파드의 <a href=#%ED%8C%8C%EB%93%9C%EC%9D%98-%EB%8B%A8%EA%B3%84>단계</a>뿐 아니라, 쿠버네티스는 파드 내부의
각 컨테이너 상태를 추적한다.
<a href=/ko/docs/concepts/containers/container-lifecycle-hooks/>컨테이너 라이프사이클 훅(hook)</a>을
사용하여 컨테이너 라이프사이클의 특정 지점에서 실행할 이벤트를 트리거할 수 있다.</p>
<p>일단 <a class=glossary-tooltip title="노드가 배정되지 않은 새로 생성된 파드를 감지하고, 실행할 노드를 선택하는 컨트롤 플레인 컴포넌트." data-toggle=tooltip data-placement=top href=/docs/reference/command-line-tools-reference/kube-scheduler/ target=_blank aria-label=스케줄러>스케줄러</a>가
노드에 파드를 할당하면, kubelet은 <a class=glossary-tooltip title="컨테이너 런타임은 컨테이너 실행을 담당하는 소프트웨어이다." data-toggle=tooltip data-placement=top href=/ko/docs/setup/production-environment/container-runtimes/ target=_blank aria-label="컨테이너 런타임">컨테이너 런타임</a>을
사용하여 해당 파드에 대한 컨테이너 생성을 시작한다.
표시될 수 있는 세 가지 컨테이너 상태는 <code>Waiting</code>, <code>Running</code> 그리고 <code>Terminated</code> 이다.</p>
<p>파드의 컨테이너 상태를 확인하려면, <code>kubectl describe pod &lt;name-of-pod></code> 를
사용할 수 있다. 출력 결과는 해당 파드 내의 각 컨테이너 상태가
표시된다.</p>
<p>각 상태에는 특정한 의미가 있다.</p>
<h3 id=container-state-waiting><code>Waiting</code></h3>
<p>만약 컨테이너가 <code>Running</code> 또는 <code>Terminated</code> 상태가 아니면, <code>Waiting</code> 상태이다.
<code>Waiting</code> 상태의 컨테이너는 시작을 완료하는 데 필요한
작업(예를 들어, 컨테이너 이미지 레지스트리에서 컨테이너 이미지 가져오거나,
<a class=glossary-tooltip title="비밀번호, OAuth 토큰 및 ssh 키와 같은 민감한 정보를 저장한다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/configuration/secret/ target=_blank aria-label=시크릿(Secret)>시크릿(Secret)</a> 데이터를 적용하는 작업)을
계속 실행하고 있는 중이다.
<code>kubectl</code> 을 사용하여 컨테이너가 <code>Waiting</code> 인 파드를 쿼리하면, 컨테이너가
해당 상태에 있는 이유를 요약하는 Reason 필드도 표시된다.</p>
<h3 id=container-state-running><code>Running</code></h3>
<p><code>Running</code> 상태는 컨테이너가 문제없이 실행되고 있음을 나타낸다. <code>postStart</code> 훅이
구성되어 있었다면, 이미 실행되고 완료되었다. <code>kubectl</code> 을
사용하여 컨테이너가 <code>Running</code> 인 파드를 쿼리하면, 컨테이너가 <code>Running</code> 상태에 진입한 시기에 대한
정보도 볼 수 있다.</p>
<h3 id=container-state-terminated><code>Terminated</code></h3>
<p><code>Terminated</code> 상태의 컨테이너는 실행을 시작한 다음 완료될 때까지
실행되었거나 어떤 이유로 실패했다. <code>kubectl</code> 을 사용하여 컨테이너가 <code>Terminated</code> 인 파드를
쿼리하면, 이유와 종료 코드 그리고 해당 컨테이너의 실행 기간에 대한 시작과
종료 시간이 표시된다.</p>
<p>컨테이너에 구성된 <code>preStop</code> 훅이 있는 경우, 컨테이너가 <code>Terminated</code> 상태에 들어가기 전에
실행된다.</p>
<h2 id=restart-policy>컨테이너 재시작 정책</h2>
<p>파드의 <code>spec</code> 에는 <code>restartPolicy</code> 필드가 있다. 사용 가능한 값은 Always, OnFailure 그리고
Never이다. 기본값은 Always이다.</p>
<p><code>restartPolicy</code> 는 파드의 모든 컨테이너에 적용된다. <code>restartPolicy</code> 는
동일한 노드에서 kubelet에 의한 컨테이너 재시작만을 의미한다. 파드의 컨테이너가
종료된 후, kubelet은 5분으로 제한되는 지수 백오프 지연(10초, 20초, 40초, …)으로
컨테이너를 재시작한다. 컨테이너가 10분 동안 아무런 문제없이 실행되면,
kubelet은 해당 컨테이너의 재시작 백오프 타이머를 재설정한다.</p>
<h2 id=파드의-컨디션>파드의 컨디션</h2>
<p>파드는 하나의 PodStatus를 가지며,
그것은 파드가 통과했거나 통과하지 못한
<a href=/docs/reference/generated/kubernetes-api/v1.23/#podcondition-v1-core>PodConditions</a> 배열을 가진다.</p>
<ul>
<li><code>PodScheduled</code>: 파드가 노드에 스케줄되었다.</li>
<li><code>ContainersReady</code>: 파드의 모든 컨테이너가 준비되었다.</li>
<li><code>Initialized</code>: 모든 <a href=/ko/docs/concepts/workloads/pods/init-containers/>초기화 컨테이너</a>가
성공적으로 완료(completed)되었다.</li>
<li><code>Ready</code>: 파드는 요청을 처리할 수 있으며 일치하는 모든 서비스의 로드
밸런싱 풀에 추가되어야 한다.</li>
</ul>
<table>
<thead>
<tr>
<th style=text-align:left>필드 이름</th>
<th style=text-align:left>설명</th>
</tr>
</thead>
<tbody>
<tr>
<td style=text-align:left><code>type</code></td>
<td style=text-align:left>이 파드 컨디션의 이름이다.</td>
</tr>
<tr>
<td style=text-align:left><code>status</code></td>
<td style=text-align:left>가능한 값이 "<code>True</code>", "<code>False</code>", 또는 "<code>Unknown</code>"으로, 해당 컨디션이 적용 가능한지 여부를 나타낸다.</td>
</tr>
<tr>
<td style=text-align:left><code>lastProbeTime</code></td>
<td style=text-align:left>파드 컨디션이 마지막으로 프로브된 시간의 타임스탬프이다.</td>
</tr>
<tr>
<td style=text-align:left><code>lastTransitionTime</code></td>
<td style=text-align:left>파드가 한 상태에서 다른 상태로 전환된 마지막 시간에 대한 타임스탬프이다.</td>
</tr>
<tr>
<td style=text-align:left><code>reason</code></td>
<td style=text-align:left>컨디션의 마지막 전환에 대한 이유를 나타내는 기계가 판독 가능한 UpperCamelCase 텍스트이다.</td>
</tr>
<tr>
<td style=text-align:left><code>message</code></td>
<td style=text-align:left>마지막 상태 전환에 대한 세부 정보를 나타내는 사람이 읽을 수 있는 메시지이다.</td>
</tr>
</tbody>
</table>
<h2 id=pod-readiness-gate>파드의 준비성(readiness)</h2>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.14 [stable]</code>
</div>
<p>애플리케이션은 추가 피드백 또는 신호를 PodStatus: <em>Pod readiness</em>
와 같이 주입할 수 있다. 이를 사용하기 위해, kubelet이 파드의 준비성을 평가하기
위한 추가적인 컨디션들을 파드의 <code>spec</code> 내 <code>readinessGate</code> 필드를 통해서 지정할 수 있다.</p>
<p>준비성 게이트는 파드에 대한 <code>status.condition</code> 필드의 현재
상태에 따라 결정된다. 만약 쿠버네티스가 <code>status.conditions</code> 필드에서 해당하는
컨디션을 찾지 못한다면, 그 컨디션의 상태는
기본 값인 "<code>False</code>"가 된다.</p>
<p>여기 예제가 있다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>readinessGates</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>conditionType</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;www.example.com/feature-1&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>conditions</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Ready                             <span style=color:#bbb> </span><span style=color:#080;font-style:italic># 내장된 PodCondition이다</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;False&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>lastProbeTime</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>null</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>lastTransitionTime</span>:<span style=color:#bbb> </span>2018-01-01T00:00:00Z<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;www.example.com/feature-1&#34;</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># 추가적인 PodCondition</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;False&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>lastProbeTime</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>null</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>lastTransitionTime</span>:<span style=color:#bbb> </span>2018-01-01T00:00:00Z<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containerStatuses</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>containerID</span>:<span style=color:#bbb> </span>docker://abcd...<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>ready</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></code></pre></div><p>추가하는 파드 상태에는 쿠버네티스 <a href=/ko/docs/concepts/overview/working-with-objects/labels/#%EA%B5%AC%EB%AC%B8%EA%B3%BC-%EC%BA%90%EB%A6%AD%ED%84%B0-%EC%85%8B>레이블 키 포맷</a>을 충족하는 이름이 있어야 한다.</p>
<h3 id=pod-readiness-status>파드 준비성 상태</h3>
<p><code>kubectl patch</code> 명령어는 아직 오브젝트 상태 패치(patching)를 지원하지 않는다.
이러한 <code>status.conditions</code> 을 파드에 설정하려면 애플리케이션과
<a class=glossary-tooltip title="A specialized controller used to manage a custom resource" data-toggle=tooltip data-placement=top href=/docs/concepts/extend-kubernetes/operator/ target=_blank aria-label=오퍼레이터>오퍼레이터</a>의
<code>PATCH</code> 액션을 필요로 한다.
<a href=/ko/docs/reference/using-api/client-libraries/>쿠버네티스 클라이언트 라이브러리</a>를
사용해서 파드 준비성에 대한 사용자 지정 파드 컨디션을 설정하는 코드를 작성할 수 있다.</p>
<p>사용자 지정 컨디션을 사용하는 파드의 경우, 다음 두 컨디션이 모두 적용되는
경우에 <strong>만</strong> 해당 파드가 준비된 것으로 평가된다.</p>
<ul>
<li>파드 내의 모든 컨테이너들이 준비 상태이다.</li>
<li><code>readinessGates</code>에 지정된 모든 컨디션들이 <code>True</code> 이다.</li>
</ul>
<p>파드의 컨테이너가 Ready 이나 적어도 한 개의 사용자 지정 컨디션이 빠졌거나 <code>False</code> 이면,
kubelet은 파드의 <a href=#%ED%8C%8C%EB%93%9C%EC%9D%98-%EC%BB%A8%EB%94%94%EC%85%98>컨디션</a>을 <code>ContainerReady</code> 로 설정한다.</p>
<h2 id=컨테이너-프로브-probe>컨테이너 프로브(probe)</h2>
<p><em>프로브</em> 는
컨테이너에서 <a href=/docs/reference/command-line-tools-reference/kubelet/>kubelet</a>에 의해
주기적으로 수행되는 진단(diagnostic)이다.
진단을 수행하기 위해서,
kubelet은 컨테이너 안에서 코드를 실행하거나,
또는 네트워크 요청을 전송한다.</p>
<h3 id=probe-check-methods>체크 메커니즘</h3>
<p>프로브를 사용하여 컨테이너를 체크하는 방법에는 4가지가 있다.
각 프로브는 다음의 4가지 메커니즘 중 단 하나만을 정의해야 한다.</p>
<dl>
<dt><code>exec</code></dt>
<dd>컨테이너 내에서 지정된 명령어를 실행한다.
명령어가 상태 코드 0으로 종료되면 진단이 성공한 것으로 간주한다.</dd>
<dt><code>grpc</code></dt>
<dd><a href=https://grpc.io/>gRPC</a>를 사용하여
원격 프로시저 호출을 수행한다.
체크 대상이 <a href=https://grpc.io/grpc/core/md_doc_health-checking.html>gRPC 헬스 체크</a>를 구현해야 한다.
응답의 <code>status</code> 가 <code>SERVING</code> 이면
진단이 성공했다고 간주한다.
gRPC 프로브는 알파 기능이며
<code>GRPCContainerProbe</code> <a href=/ko/docs/reference/command-line-tools-reference/feature-gates/>기능 게이트</a>를
활성화해야 사용할 수 있다.</dd>
<dt><code>httpGet</code></dt>
<dd>지정한 포트 및 경로에서 컨테이너의 IP주소에 대한
HTTP <code>GET</code> 요청을 수행한다.
응답의 상태 코드가 200 이상 400 미만이면
진단이 성공한 것으로 간주한다.</dd>
<dt><code>tcpSocket</code></dt>
<dd>지정된 포트에서 컨테이너의 IP주소에 대해 TCP 검사를 수행한다.
포트가 활성화되어 있다면 진단이 성공한 것으로 간주한다.
원격 시스템(컨테이너)가 연결을 연 이후 즉시 닫는다면,
이 또한 진단이 성공한 것으로 간주한다.</dd>
</dl>
<h3 id=프로브-결과>프로브 결과</h3>
<p>각 probe는 다음 세 가지 결과 중 하나를 가진다.</p>
<dl>
<dt><code>Success</code></dt>
<dd>컨테이너가 진단을 통과함.</dd>
<dt><code>Failure</code></dt>
<dd>컨테이너가 진단에 실패함.</dd>
<dt><code>Unknown</code></dt>
<dd>진단 자체가 실패함(아무런 조치를 수행해서는 안 되며, kubelet이
추가 체크를 수행할 것이다)</dd>
</dl>
<h3 id=프로브-종류>프로브 종류</h3>
<p>kubelet은 실행 중인 컨테이너들에 대해서 선택적으로 세 가지 종류의 프로브를 수행하고
그에 반응할 수 있다.</p>
<dl>
<dt><code>livenessProbe</code></dt>
<dd>컨테이너가 동작 중인지 여부를 나타낸다. 만약
활성 프로브(liveness probe)에 실패한다면, kubelet은 컨테이너를 죽이고, 해당 컨테이너는
<a href=#restart-policy>재시작 정책</a>의 대상이 된다. 만약 컨테이너가
활성 프로브를 제공하지 않는 경우, 기본 상태는 <code>Success</code> 이다.</dd>
<dt><code>readinessProbe</code></dt>
<dd>컨테이너가 요청을 처리할 준비가 되었는지 여부를 나타낸다.
만약 준비성 프로브(readiness probe)가 실패한다면, 엔드포인트 컨트롤러는
파드에 연관된 모든 서비스들의 엔드포인트에서 파드의 IP주소를 제거한다. 준비성 프로브의
초기 지연 이전의 기본 상태는 <code>Failure</code> 이다. 만약 컨테이너가 준비성 프로브를
지원하지 않는다면, 기본 상태는 <code>Success</code> 이다.</dd>
<dt><code>startupProbe</code></dt>
<dd>컨테이너 내의 애플리케이션이 시작되었는지를 나타낸다.
스타트업 프로브(startup probe)가 주어진 경우, 성공할 때까지 다른 나머지 프로브는
활성화되지 않는다. 만약 스타트업 프로브가 실패하면, kubelet이 컨테이너를 죽이고,
컨테이너는 <a href=#restart-policy>재시작 정책</a>에 따라 처리된다. 컨테이너에 스타트업
프로브가 없는 경우, 기본 상태는 <code>Success</code> 이다.</dd>
</dl>
<p>활성, 준비성 및 스타트업 프로브를 설정하는 방법에 대한 추가적인 정보는,
<a href=/docs/tasks/configure-pod-container/configure-liveness-readiness-probes/>활성, 준비성 및 스타트업 프로브 설정하기</a>를 참조하면 된다.</p>
<h4 id=언제-활성-프로브를-사용해야-하는가>언제 활성 프로브를 사용해야 하는가?</h4>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.0 [stable]</code>
</div>
<p>만약 컨테이너 속 프로세스가 어떠한 이슈에 직면하거나 건강하지 못한
상태(unhealthy)가 되는 등 프로세스 자체의 문제로 중단될 수 있더라도, 활성 프로브가
반드시 필요한 것은 아니다. 그 경우에는 kubelet이 파드의 <code>restartPolicy</code>에
따라서 올바른 대처를 자동적으로 수행할 것이다.</p>
<p>프로브가 실패한 후 컨테이너가 종료되거나 재시작되길 원한다면, 활성 프로브를
지정하고, <code>restartPolicy</code>를 항상(Always) 또는 실패 시(OnFailure)로 지정한다.</p>
<h4 id=언제-준비성-프로브를-사용해야-하는가>언제 준비성 프로브를 사용해야 하는가?</h4>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.0 [stable]</code>
</div>
<p>프로브가 성공한 경우에만 파드에 트래픽 전송을 시작하려고 한다면,
준비성 프로브를 지정하길 바란다. 이 경우에서는, 준비성 프로브가 활성 프로브와 유사해
보일 수도 있지만, 스팩에 준비성 프로브가 존재한다는 것은 파드가
트래픽을 받지 않는 상태에서 시작되고 프로브가 성공하기 시작한 이후에만
트래픽을 받는다는 뜻이다.</p>
<p>만약 컨테이너가 유지 관리를 위해서 자체 중단되게 하려면,
준비성 프로브를 지정하길 바란다.
준비성 프로브는 활성 프로브와는 다르게 준비성에 특정된 엔드포인트를 확인한다.</p>
<p>만약 애플리케이션이 백엔드 서비스에 엄격한 의존성이 있다면,
활성 프로브와 준비성 프로브 모두 활용할 수도 있다. 활성 프로브는 애플리케이션 스스로가 건강한 상태면
통과하지만, 준비성 프로브는 추가적으로 요구되는 각 백-엔드 서비스가 가용한지 확인한다. 이를 이용하여,
오류 메시지만 응답하는 파드로
트래픽이 가는 것을 막을 수 있다.</p>
<p>만약 컨테이너가 시동 시 대량 데이터의 로딩, 구성 파일, 또는
마이그레이션에 대한 작업을
수행해야 한다면, <a href=#%EC%96%B8%EC%A0%9C-%EC%8A%A4%ED%83%80%ED%8A%B8%EC%97%85-%ED%94%84%EB%A1%9C%EB%B8%8C%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%B4%EC%95%BC-%ED%95%98%EB%8A%94%EA%B0%80>스타트업 프로브</a>를 사용하면 된다. 그러나, 만약
failed 애플리케이션과 시동 중에 아직 데이터를 처리하고 있는 애플리케이션을 구분하여 탐지하고
싶다면, 준비성 프로브를 사용하는 것이 더 적합할 것이다.</p>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> 파드가 삭제될 때 요청들을 흘려 보내기(drain) 위해
준비성 프로브가 꼭 필요한 것은 아니다. 삭제 시에, 파드는
프로브의 존재 여부와 무관하게 자동으로 스스로를 준비되지 않은 상태(unready)로 변경한다.
파드는 파드 내의 모든 컨테이너들이 중지될 때까지 준비되지 않은 상태로
남아 있다.
</div>
<h4 id=언제-스타트업-프로브를-사용해야-하는가>언제 스타트업 프로브를 사용해야 하는가?</h4>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.20 [stable]</code>
</div>
<p>스타트업 프로브는 서비스를 시작하는 데 오랜 시간이 걸리는 컨테이너가 있는
파드에 유용하다. 긴 활성 간격을 설정하는 대신, 컨테이너가 시작될 때
프로브를 위한 별도의 구성을 설정하여, 활성 간격보다
긴 시간을 허용할 수 있다.</p>
<p>컨테이너가 보통 <code>initialDelaySeconds + failureThreshold × periodSeconds</code>
이후에 기동된다면, 스타트업 프로브가
활성화 프로브와 같은 엔드포인트를 확인하도록 지정해야 한다.
<code>periodSeconds</code>의 기본값은 10s 이다. 이 때 컨테이너가 활성화 프로브의
기본값 변경 없이 기동되도록 하려면, <code>failureThreshold</code> 를 충분히 높게 설정해주어야
한다. 그래야 데드락(deadlocks)을 방지하는데 도움이 된다.</p>
<h2 id=pod-termination>파드의 종료</h2>
<p>파드는 클러스터의 노드에서 실행되는 프로세스를 나타내므로, 해당 프로세스가
더 이상 필요하지 않을 때 정상적으로 종료되도록 하는 것이 중요하다(<code>KILL</code>
시그널로 갑자기 중지되고 정리할 기회가 없는 것 보다).</p>
<p>디자인 목표는 삭제를 요청하고 프로세스가 종료되는 시기를 알 수
있을 뿐만 아니라, 삭제가 결국 완료되도록 하는 것이다.
사용자가 파드의 삭제를 요청하면, 클러스터는 파드가 강제로 종료되기 전에
의도한 유예 기간을 기록하고 추적한다. 강제 종료 추적이
적용되면, <a class=glossary-tooltip title="클러스터의 각 노드에서 실행되는 에이전트. Kubelet은 파드에서 컨테이너가 확실하게 동작하도록 관리한다." data-toggle=tooltip data-placement=top href=/docs/reference/generated/kubelet target=_blank aria-label=kubelet>kubelet</a>은 정상
종료를 시도한다.</p>
<p>일반적으로, 컨테이너 런타임은 각 컨테이너의 기본 프로세스에 TERM 신호를
전송한다. 많은 컨테이너 런타임은 컨테이너 이미지에 정의된 <code>STOPSIGNAL</code> 값을 존중하며
TERM 대신 이 값을 보낸다.
일단 유예 기간이 만료되면, KILL 시그널이 나머지 프로세스로
전송되고, 그런 다음 파드는
<a class=glossary-tooltip title="쿠버네티스 API를 제공하는 컨트롤 플레인 컴포넌트." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/overview/components/#kube-apiserver target=_blank aria-label="API 서버">API 서버</a>로부터 삭제된다. 프로세스가
종료될 때까지 기다리는 동안 kubelet 또는 컨테이너 런타임의 관리 서비스가 다시 시작되면, 클러스터는
전체 원래 유예 기간을 포함하여 처음부터 다시 시도한다.</p>
<p>플로우의 예는 다음과 같다.</p>
<ol>
<li>이 <code>kubectl</code> 도구를 사용하여 기본 유예 기간(30초)으로 특정 파드를 수동으로
삭제한다.</li>
<li>API 서버의 파드는 유예 기간과 함께 파드가 "dead"로 간주되는
시간으로 업데이트된다.
<code>kubectl describe</code> 를 사용하여 삭제하려는 파드를 확인하면, 해당 파드가 "Terminating"으로
표시된다.
파드가 실행 중인 노드에서, kubelet이 파드가 종료된 것(terminating)으로 표시되었음을
확인하는 즉시(정상적인 종료 기간이 설정됨), kubelet은 로컬 파드의 종료
프로세스를 시작한다.
<ol>
<li>파드의 컨테이너 중 하나가 <code>preStop</code>
<a href=/ko/docs/concepts/containers/container-lifecycle-hooks>훅</a>을 정의한 경우, kubelet은
컨테이너 내부에서 해당 훅을 실행한다. 유예 기간이 만료된 후 <code>preStop</code> 훅이
계속 실행되면, kubelet은 2초의 작은 일회성 유예 기간 연장을
요청한다.
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> <code>preStop</code> 훅을 완료하는 데 기본 유예 기간이 허용하는 것보다 오랜 시간이 필요한 경우,
이에 맞게 <code>terminationGracePeriodSeconds</code> 를 수정해야 한다.
</div></li>
<li>kubelet은 컨테이너 런타임을 트리거하여 각 컨테이너 내부의 프로세스 1에 TERM 시그널을
보낸다.
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> 파드의 컨테이너는 서로 다른 시간에 임의의 순서로 TERM 시그널을
수신한다. 종료 순서가 중요한 경우, <code>preStop</code> 훅을 사용하여 동기화하는 것이 좋다.
</div></li>
</ol>
</li>
<li>kubelet이 정상 종료를 시작하는 동시에, 컨트롤 플레인은
구성된 <a class=glossary-tooltip title="사용자가 레이블에 따라서 리소스 리스트를 필터할 수 있게 한다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/overview/working-with-objects/labels/ target=_blank aria-label=셀렉터>셀렉터</a>가 있는
<a class=glossary-tooltip title="네트워크 서비스로 파드 집합에서 실행 중인 애플리케이션을 노출하는 방법" data-toggle=tooltip data-placement=top href=/ko/docs/concepts/services-networking/service/ target=_blank aria-label=서비스>서비스</a>를 나타내는
엔드포인트(Endpoint)(그리고, 활성화된 경우, 엔드포인트슬라이스(EndpointSlice)) 오브젝트에서 종료된 파드를 제거한다.
<a class=glossary-tooltip title="레플리카셋은 지정된 수의 파드 레플리카가 동시에 실행이 되도록 보장한다" data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/controllers/replicaset/ target=_blank aria-label=레플리카셋(ReplicaSet)>레플리카셋(ReplicaSet)</a>과 기타 워크로드 리소스는
더 이상 종료된 파드를 유효한 서비스 내 복제본으로 취급하지 않는다. 로드 밸런서(서비스 프록시와 같은)가
종료 유예 기간이 <em>시작되는</em> 즉시 엔드포인트 목록에서 파드를 제거하므로 느리게 종료되는
파드는 트래픽을 계속 제공할 수 없다.</li>
<li>유예 기간이 만료되면, kubelet은 강제 종료를 트리거한다. 컨테이너 런타임은
<code>SIGKILL</code> 을 파드의 모든 컨테이너에서 여전히 실행 중인 모든 프로세스로 전송한다.
kubelet은 해당 컨테이너 런타임이 하나를 사용하는 경우 숨겨진 <code>pause</code> 컨테이너도 정리한다.</li>
<li>kubelet은 유예 기간을 0(즉시 삭제)으로 설정하여, API 서버에서 파드 오브젝트의
강제 삭제를 트리거한다.</li>
<li>API 서버가 파드의 API 오브젝트를 삭제하면, 더 이상 클라이언트에서 볼 수 없다.</li>
</ol>
<h3 id=pod-termination-forced>강제 파드 종료</h3>
<div class="alert alert-warning caution callout" role=alert>
<strong>주의:</strong> 강제 삭제는 일부 워크로드와 해당 파드에 대해서 잠재적으로 중단될 수 있다.
</div>
<p>기본적으로, 모든 삭제는 30초 이내에는 정상적으로 수행된다. <code>kubectl delete</code> 명령은
기본값을 재정의하고 사용자의 고유한 값을 지정할 수 있는 <code>--grace-period=&lt;seconds></code> 옵션을
지원한다.</p>
<p>유예 기간을 <code>0</code> 로 강제로 즉시 설정하면 API 서버에서 파드가
삭제된다. 파드가 노드에서 계속 실행 중인 경우, 강제 삭제는 kubelet을 트리거하여
즉시 정리를 시작한다.</p>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> 강제 삭제를 수행하려면 <code>--grace-period=0</code> 와 함께 추가 플래그 <code>--force</code> 를 지정해야 한다.
</div>
<p>강제 삭제가 수행되면, API 서버는 실행 중인 노드에서
파드가 종료되었다는 kubelet의 확인을 기다리지 않는다.
API에서 즉시 파드를 제거하므로 동일한 이름으로 새로운 파드를 생성할 수
있다. 노드에서 즉시 종료되도록 설정된 파드는 강제 종료되기 전에
작은 유예 기간이 계속 제공된다.</p>
<p>스테이트풀셋(StatefulSet)의 일부인 파드를 강제 삭제해야 하는 경우,
<a href=/ko/docs/tasks/run-application/force-delete-stateful-set-pod/>스테이트풀셋에서 파드를 삭제하기</a>에 대한
태스크 문서를 참고한다.</p>
<h3 id=pod-garbage-collection>실패한 파드의 가비지 콜렉션</h3>
<p>실패한 파드의 경우, API 오브젝트는 사람이나
<a class=glossary-tooltip title="API 서버를 통해 클러스터의 공유된 상태를 감시하고, 현재 상태를 원하는 상태로 이행시키는 컨트롤 루프." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/architecture/controller/ target=_blank aria-label=컨트롤러>컨트롤러</a> 프로세스가
명시적으로 파드를 제거할 때까지 클러스터의 API에 남아 있다.</p>
<p>컨트롤 플레인은 파드 수가 구성된 임계값(kube-controller-manager에서
<code>terminated-pod-gc-threshold</code> 에 의해 결정됨)을 초과할 때 종료된 파드(<code>Succeeded</code> 또는
<code>Failed</code> 단계 포함)를 정리한다.
이렇게 하면 시간이 지남에 따라 파드가 생성되고 종료될 때 리소스 유출이 방지된다.</p>
<h2 id=다음-내용>다음 내용</h2>
<ul>
<li>
<p><a href=/docs/tasks/configure-pod-container/attach-handler-lifecycle-event/>컨테이너 라이프사이클 이벤트에 핸들러를 연결</a>하는
핸즈온 연습을 해보자.</p>
</li>
<li>
<p><a href=/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/>활성, 준비성 및 스타트업 프로브 설정</a>하는
핸즈온 연습을 해보자.</p>
</li>
<li>
<p><a href=/ko/docs/concepts/containers/container-lifecycle-hooks/>컨테이너 라이프사이클 훅</a>에 대해 자세히 알아보자.</p>
</li>
<li>
<p>API의 파드와 컨테이너 상태에 대한 자세한 내용은
파드의 <a href=/docs/reference/kubernetes-api/workload-resources/pod-v1/#PodStatus><code>.status</code></a>에 대해 다루는
API 레퍼런스 문서를 참고한다.</p>
</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-1ccbd4eeded6ab138d98b59175bd557e>4.1.2 - 초기화 컨테이너</h1>
<p>이 페이지는 초기화 컨테이너에 대한 개요를 제공한다. 초기화 컨테이너는
<a class=glossary-tooltip title="파드는 클러스터에서 실행 중인 컨테이너의 집합을 나타낸다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/pods/ target=_blank aria-label=파드>파드</a>의 앱 컨테이너들이 실행되기 전에 실행되는 특수한 컨테이너이며, 앱 이미지에는 없는
유틸리티 또는 설정 스크립트 등을 포함할 수 있다.</p>
<p>초기화 컨테이너는 <code>containers</code> 배열(앱 컨테이너를 기술하는)과 나란히
파드 스펙에 명시할 수 있다.</p>
<h2 id=초기화-컨테이너-이해하기>초기화 컨테이너 이해하기</h2>
<p><a class=glossary-tooltip title="파드는 클러스터에서 실행 중인 컨테이너의 집합을 나타낸다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/pods/ target=_blank aria-label=파드>파드</a>는 앱들을 실행하는 다수의 컨테이너를
포함할 수 있고, 또한 앱 컨테이너 실행 전에 동작되는 하나 이상의
초기화 컨테이너도 포함할 수 있다.</p>
<p>다음의 경우를 제외하면, 초기화 컨테이너는 일반적인 컨테이너와 매우 유사하다.</p>
<ul>
<li>초기화 컨테이너는 항상 완료를 목표로 실행된다.</li>
<li>각 초기화 컨테이너는 다음 초기화 컨테이너가 시작되기 전에 성공적으로 완료되어야 한다.</li>
</ul>
<p>만약 파드의 초기화 컨테이너가 실패하면, kubelet은 초기화 컨테이너가 성공할 때까지 반복적으로 재시작한다.
그러나, 만약 파드의 <code>restartPolicy</code> 를 절대 하지 않음(Never)으로 설정하고, 해당 파드를 시작하는 동안 초기화 컨테이너가 실패하면, 쿠버네티스는 전체 파드를 실패한 것으로 처리한다.</p>
<p>컨테이너를 초기화 컨테이너로 지정하기 위해서는,
<a href=/docs/reference/kubernetes-api/workload-resources/pod-v1/#PodSpec>파드 스펙</a>에 <code>initContainers</code> 필드를
<code>container</code> 항목(앱 <code>container</code> 필드 및 내용과 유사한)들의 배열로서 추가한다.
<a href=/docs/reference/kubernetes-api/workload-resources/pod-v1/#Container>컨테이너</a>에 대한 더 상세한 사항은
API 레퍼런스를 참고한다.</p>
<p>초기화 컨테이너의 상태는 컨테이너
상태의 배열(<code>.status.containerStatuses</code> 필드와 유사)로 <code>.status.initContainerStatuses</code>
필드에 반환된다.</p>
<h3 id=일반적인-컨테이너와의-차이점>일반적인 컨테이너와의 차이점</h3>
<p>초기화 컨테이너는 앱 컨테이너의 리소스 상한(limit), 볼륨, 보안 세팅을 포함한
모든 필드와 기능을 지원한다.
그러나, 초기화 컨테이너를 위한 리소스 요청량과 상한은
<a href=#%EB%A6%AC%EC%86%8C%EC%8A%A4>리소스</a>에 문서화된 것처럼 다르게 처리된다.</p>
<p>또한, 초기화 컨테이너는 <code>lifecycle</code>, <code>livenessProbe</code>, <code>readinessProbe</code> 또는 <code>startupProbe</code> 를 지원하지 않는다.
왜냐하면 초기화 컨테이너는 파드가 준비 상태가 되기 전에 완료를 목표로 실행되어야 하기 때문이다.</p>
<p>만약 다수의 초기화 컨테이너가 파드에 지정되어 있다면, kubelet은 해당 초기화 컨테이너들을
한 번에 하나씩 실행한다. 각 초기화 컨테이너는 다음 컨테이너를 실행하기 전에 꼭 성공해야 한다.
모든 초기화 컨테이너들이 실행 완료되었을 때, kubelet은 파드의 애플리케이션 컨테이너들을
초기화하고 평소와 같이 실행한다.</p>
<h2 id=초기화-컨테이너-사용하기>초기화 컨테이너 사용하기</h2>
<p>초기화 컨테이너는 앱 컨테이너와는 별도의 이미지를 가지고 있기 때문에, 시동(start-up)에
관련된 코드로서 몇 가지 이점을 가진다.</p>
<ul>
<li>앱 이미지에는 없는 셋업을 위한 유틸리티 또는 맞춤 코드를 포함할 수 있다.
예를 들어, 셋업 중에 단지 <code>sed</code>, <code>awk</code>, <code>python</code>, 또는 <code>dig</code>와 같은 도구를 사용하기 위해서
다른 이미지로부터(<code>FROM</code>) 새로운 이미지를 만들 필요가 없다.</li>
<li>애플리케이션 이미지 빌더와 디플로이어 역할은 독립적으로 동작될 수 있어서
공동의 단일 앱 이미지 형태로 빌드될 필요가 없다.</li>
<li>초기화 컨테이너는 앱 컨테이너와 다른 파일 시스템 뷰를 가지도록 리눅스 네임스페이스를 사용한다.
결과적으로, 초기화 컨테이너에는 앱 컨테이너가 가질 수 없는
<a class=glossary-tooltip title="비밀번호, OAuth 토큰 및 ssh 키와 같은 민감한 정보를 저장한다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/configuration/secret/ target=_blank aria-label=시크릿>시크릿</a>에 접근 권한이 주어질 수 있다.</li>
<li>앱 컨테이너들은 병렬로 실행되는 반면, 초기화 컨테이너들은 어떠한 앱
컨테이너라도 시작되기 전에 실행 완료되어야 하므로, 초기화 컨테이너는 사전 조건들이
충족될 때까지 앱 컨테이너가 시동되는 것을 막거나 지연시키는 간편한 방법을 제공한다.</li>
<li>초기화 컨테이너는 앱 컨테이너 이미지의 보안성을 떨어뜨릴 수도 있는 유틸리티 혹은 커스텀 코드를 안전하게
실행할 수 있다. 불필요한 툴들을 분리한 채로 유지함으로써 앱 컨테이너 이미지의 공격에 대한
노출을 제한할 수 있다.</li>
</ul>
<h3 id=예제>예제</h3>
<p>초기화 컨테이너를 사용하는 방법에 대한 몇 가지 아이디어는 다음과 같다.</p>
<ul>
<li>
<p>다음과 같은 셸 커맨드로,
<a class=glossary-tooltip title="네트워크 서비스로 파드 집합에서 실행 중인 애플리케이션을 노출하는 방법" data-toggle=tooltip data-placement=top href=/ko/docs/concepts/services-networking/service/ target=_blank aria-label=서비스>서비스</a>가 생성될 때까지 기다리기.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#a2f;font-weight:700>for</span> i in <span style=color:#666>{</span>1..100<span style=color:#666>}</span>; <span style=color:#a2f;font-weight:700>do</span> sleep 1; <span style=color:#a2f;font-weight:700>if</span> dig myservice; <span style=color:#a2f;font-weight:700>then</span> <span style=color:#a2f>exit</span> 0; <span style=color:#a2f;font-weight:700>fi</span>; <span style=color:#a2f;font-weight:700>done</span>; <span style=color:#a2f>exit</span> <span style=color:#666>1</span>
</code></pre></div></li>
<li>
<p>다음과 같은 커맨드로, 다운워드 API(Downward API)를 통한 원격 서버에 해당 파드를 등록하기.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>curl -X POST http://<span style=color:#b8860b>$MANAGEMENT_SERVICE_HOST</span>:<span style=color:#b8860b>$MANAGEMENT_SERVICE_PORT</span>/register -d <span style=color:#b44>&#39;instance=$(&lt;POD_NAME&gt;)&amp;ip=$(&lt;POD_IP&gt;)&#39;</span>
</code></pre></div></li>
<li>
<p>다음과 같은 커맨드로 앱 컨테이너가 시작되기 전에 일정 시간 기다리기.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>sleep <span style=color:#666>60</span>
</code></pre></div></li>
<li>
<p>Git 저장소를 <a class=glossary-tooltip title="데이터를 포함하고 있는 디렉터리이며, 파드의 컨테이너에서 접근 가능하다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/storage/volumes/ target=_blank aria-label=볼륨>볼륨</a> 안에 클론하기.</p>
</li>
<li>
<p>설정 파일에 값을 지정하고
메인 앱 컨테이너를 위한 설정 파일을 동적으로 생성하기 위한 템플릿 도구를 실행하기.
예를 들어, 설정에 <code>POD_IP</code> 값을 지정하고
메인 앱 설정 파일을 Jinja를 통해서 생성.</p>
</li>
</ul>
<h3 id=사용-중인-초기화-컨테이너>사용 중인 초기화 컨테이너</h3>
<p>쿠버네티스 1.5에 대한 다음의 yaml 파일은 두 개의 초기화 컨테이너를 포함한 간단한 파드에 대한 개요를 보여준다.
첫 번째는 <code>myservice</code> 를 기다리고 두 번째는 <code>mydb</code> 를 기다린다. 두 컨테이너들이
완료되면, 파드가 시작될 것이다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>myapp-pod<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>myapp<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>myapp-container<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox:1.28<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#39;sh&#39;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#39;-c&#39;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#39;echo The app is running! &amp;&amp; sleep 3600&#39;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>initContainers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>init-myservice<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox:1.28<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#39;sh&#39;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#39;-c&#39;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;until nslookup myservice.$(cat /var/run/secrets/kubernetes.io/serviceaccount/namespace).svc.cluster.local; do echo waiting for myservice; sleep 2; done&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>init-mydb<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox:1.28<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#39;sh&#39;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#39;-c&#39;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;until nslookup mydb.$(cat /var/run/secrets/kubernetes.io/serviceaccount/namespace).svc.cluster.local; do echo waiting for mydb; sleep 2; done&#34;</span>]<span style=color:#bbb>
</span></code></pre></div><p>다음 커맨드들을 이용하여 파드를 시작하거나 디버깅할 수 있다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f myapp.yaml
</code></pre></div><p>출력 결과는 다음과 같다.</p>
<pre><code>pod/myapp-pod created
</code></pre><p>그리고 파드의 상태를 확인한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get -f myapp.yaml
</code></pre></div><p>출력 결과는 다음과 같다.</p>
<pre><code>NAME        READY     STATUS     RESTARTS   AGE
myapp-pod   0/1       Init:0/2   0          6m
</code></pre><p>혹은 좀 더 자세히 살펴본다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe -f myapp.yaml
</code></pre></div><p>출력 결과는 다음과 같다.</p>
<pre><code>Name:          myapp-pod
Namespace:     default
[...]
Labels:        app=myapp
Status:        Pending
[...]
Init Containers:
  init-myservice:
[...]
    State:         Running
[...]
  init-mydb:
[...]
    State:         Waiting
      Reason:      PodInitializing
    Ready:         False
[...]
Containers:
  myapp-container:
[...]
    State:         Waiting
      Reason:      PodInitializing
    Ready:         False
[...]
Events:
  FirstSeen    LastSeen    Count    From                      SubObjectPath                           Type          Reason        Message
  ---------    --------    -----    ----                      -------------                           --------      ------        -------
  16s          16s         1        {default-scheduler }                                              Normal        Scheduled     Successfully assigned myapp-pod to 172.17.4.201
  16s          16s         1        {kubelet 172.17.4.201}    spec.initContainers{init-myservice}     Normal        Pulling       pulling image &quot;busybox&quot;
  13s          13s         1        {kubelet 172.17.4.201}    spec.initContainers{init-myservice}     Normal        Pulled        Successfully pulled image &quot;busybox&quot;
  13s          13s         1        {kubelet 172.17.4.201}    spec.initContainers{init-myservice}     Normal        Created       Created container with docker id 5ced34a04634; Security:[seccomp=unconfined]
  13s          13s         1        {kubelet 172.17.4.201}    spec.initContainers{init-myservice}     Normal        Started       Started container with docker id 5ced34a04634
</code></pre><p>파드의 초기화 컨테이너의 상태를 보기 위해, 다음을 실행한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl logs myapp-pod -c init-myservice <span style=color:#080;font-style:italic># Inspect the first init container</span>
kubectl logs myapp-pod -c init-mydb      <span style=color:#080;font-style:italic># Inspect the second init container</span>
</code></pre></div><p><code>mydb</code> 및 <code>myservice</code> 서비스를 시작하고 나면, 초기화 컨테이너가 완료되고
<code>myapp-pod</code> 가 생성된 것을 볼 수 있다.</p>
<p>여기에 이 서비스를 보이기 위해 사용할 수 있는 구성이 있다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>myservice<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>9376</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mydb<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>9377</span><span style=color:#bbb>
</span></code></pre></div><p><code>mydb</code> 와 <code>myservice</code> 서비스 생성하기.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f services.yaml
</code></pre></div><p>출력 결과는 다음과 같다.</p>
<pre><code>service/myservice created
service/mydb created
</code></pre><p>초기화 컨테이너들이 완료되는 것과 <code>myapp-pod</code> 파드가 Running 상태로
변경되는 것을 볼 것이다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get -f myapp.yaml
</code></pre></div><p>출력 결과는 다음과 같다.</p>
<pre><code>NAME        READY     STATUS    RESTARTS   AGE
myapp-pod   1/1       Running   0          9m
</code></pre><p>이 간단한 예제는 사용자만의 초기화 컨테이너를 생성하는데
영감을 줄 것이다. <a href=#%EB%8B%A4%EC%9D%8C-%EB%82%B4%EC%9A%A9>다음 순서</a>에는 더 자세한 예제의 링크가 있다.</p>
<h2 id=자세한-동작>자세한 동작</h2>
<p>파드 시작 시에 kubelet은 네트워크와 스토리지가 준비될 때까지
초기화 컨테이너의 실행을 지연시킨다. 그런 다음 kubelet은 파드 사양에
나와있는 순서대로 파드의 초기화 컨테이너를 실행한다.</p>
<p>각 초기화 컨테이너는 다음 컨테이너가 시작되기 전에 성공적으로
종료되어야 한다. 만약 런타임 문제나 실패 상태로 종료되는 문제로인하여 초기화 컨테이너의 시작이
실패된다면, 초기화 컨테이너는 파드의 <code>restartPolicy</code> 에 따라서 재시도 된다. 다만,
파드의 <code>restartPolicy</code> 가 항상(Always)으로 설정된 경우, 해당 초기화 컨테이너는
<code>restartPolicy</code> 를 실패 시(OnFailure)로 사용한다.</p>
<p>파드는 모든 초기화 컨테이너가 성공되기 전까지 <code>Ready</code> 될 수 없다. 초기화 컨테이너의 포트는
서비스 하에 합쳐지지 않는다. 초기화 중인 파드는 <code>Pending</code> 상태이지만
<code>Initialized</code> 가 거짓이 되는 조건을 가져야 한다.</p>
<p>만약 파드가 <a href=#%ED%8C%8C%EB%93%9C-%EC%9E%AC%EC%8B%9C%EC%9E%91-%EC%9D%B4%EC%9C%A0>재시작</a>되었다면, 모든 초기화 컨테이너는
반드시 다시 실행된다.</p>
<p>초기화 컨테이너 스펙 변경은 컨테이너 이미지 필드에서만 한정적으로 가능하다.
초기화 컨테이너 이미지 필드를 변경하는 것은 파드를 재시작하는 것과 같다.</p>
<p>초기화 컨테이너는 재시작되거나, 재시도, 또는 재실행 될 수 있기 때문에, 초기화 컨테이너
코드는 멱등성(idempotent)을 유지해야 한다. 특히, <code>EmptyDirs</code> 에 있는 파일에 쓰기를 수행하는 코드는
출력 파일이 이미 존재할 가능성에 대비해야 한다.</p>
<p>초기화 컨테이너는 앱 컨테이너의 필드를 모두 가지고 있다. 그러나, 쿠버네티스는
<code>readinessProbe</code> 가 사용되는 것을 금지한다. 초기화 컨테이너가 완료 상태와 준비성을
구분해서 정의할 수 없기 때문이다. 이것은 유효성 검사 중에 시행된다.</p>
<p>초기화 컨테이너들이 실패를 영원히 지속하는 상황을 방지하기 위해서
파드의 <code>activeDeadlineSeconds</code>를 사용한다.
Active deadline은 초기화 컨테이너를 포함한다.
그러나 팀에서 애플리케이션을 잡(job)으로 배포한 경우에만 <code>activeDeadlineSeconds</code>를 사용하길 추천한다. 왜냐하면, <code>activeDeadlineSeconds</code>는 초기화 컨테이너가 완료된 이후에도 영향을 주기 때문이다.
이미 정상적으로 동작하고 있는 파드도 <code>activeDeadlineSeconds</code>를 설정한 경우 종료(killed)될 수 있다.</p>
<p>파드 내의 각 앱과 초기화 컨테이너의 이름은 유일해야 한다. 어떤
컨테이너가 다른 컨테이너와 같은 이름을 공유하는 경우 유효성 오류가 발생한다.</p>
<h3 id=리소스>리소스</h3>
<p>초기화 컨테이너에게 명령과 실행이 주어진 경우, 리소스 사용에 대한
다음의 규칙이 적용된다.</p>
<ul>
<li>모든 컨테이너에 정의된 특정 리소스 요청량 또는 상한 중
가장 높은 것은 <em>유효 초기화 요청량/상한</em> 이다. 리소스 제한이 지정되지 않은 리소스는
이 <em>유효 초기화 요청량/상한</em>을 가장 높은 요청량/상한으로 간주한다.</li>
<li>리소스를 위한 파드의 <em>유효한 초기화 요청량/상한</em> 은 다음 보다 더 높다.
<ul>
<li>모든 앱 컨테이너의 리소스에 대한 요청량/상한의 합계</li>
<li>리소스에 대한 유효한 초기화 요청량/상한</li>
</ul>
</li>
<li>스케줄링은 유효한 요청/상한에 따라 이루어진다. 즉,
초기화 컨테이너는 파드의 삶에서는 사용되지 않는 초기화를 위한 리소스를
예약할 수 있다.</li>
<li>파드의 <em>유효한 QoS 계층</em> 에서 QoS(서비스의 품질) 계층은 초기화 컨테이너들과
앱 컨테이너들의 QoS 계층과 같다.</li>
</ul>
<p>쿼터 및 상한은 유효한 파드의 요청량 및 상한에 따라
적용된다.</p>
<p>파드 레벨 cgroup은 유효한 파드 요청량 및 상한을 기반으로 한다.
이는 스케줄러와 같다.</p>
<h3 id=파드-재시작-이유>파드 재시작 이유</h3>
<p>파드는 다음과 같은 사유로, 초기화 컨테이너들의 재-실행을 일으키는, 재시작을 수행할 수
있다.</p>
<ul>
<li>파드 인프라스트럭처 컨테이너가 재시작된 상황. 이는 일반적인 상황이 아니며 노드에
대해서 root 접근 권한을 가진 누군가에 의해서 수행됐을 것이다.</li>
<li>초기화 컨테이너의 완료 기록이 가비지 수집 때문에 유실된 상태에서,
<code>restartPolicy</code>가 Always로 설정된 파드의 모든 컨테이너가 종료되어
모든 컨테이너를 재시작해야 하는 상황</li>
</ul>
<p>초기화 컨테이너 이미지가 변경되거나 초기화 컨테이너의 완료 기록이 가비지 수집
때문에 유실된 상태이면 파드는 재시작되지 않는다. 이는 쿠버네티스 버전 1.20 이상에
적용된다. 이전 버전의 쿠버네티스를 사용하는 경우 해당 쿠버네티스 버전의 문서를
참고한다.</p>
<h2 id=다음-내용>다음 내용</h2>
<ul>
<li><a href=/ko/docs/tasks/configure-pod-container/configure-pod-initialization/#%EC%B4%88%EA%B8%B0%ED%99%94-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88%EB%A5%BC-%EA%B0%96%EB%8A%94-%ED%8C%8C%EB%93%9C-%EC%83%9D%EC%84%B1>초기화 컨테이너를 가진 파드 생성하기</a></li>
<li><a href=/ko/docs/tasks/debug-application-cluster/debug-init-containers/>초기화 컨테이너 디버깅</a> 알아보기</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-c8d62295ca703fdcef1aaf89fb4c916a>4.1.3 - 파드 토폴로지 분배 제약 조건</h1>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.19 [stable]</code>
</div>
<p>사용자는 <em>토폴로지 분배 제약 조건</em> 을 사용해서 지역, 영역, 노드 그리고 기타 사용자-정의 토폴로지 도메인과 같이 장애-도메인으로 설정된 클러스터에 걸쳐 파드가 분산되는 방식을 제어할 수 있다. 이를 통해 고가용성뿐만 아니라, 효율적인 리소스 활용의 목적을 이루는 데 도움이 된다.</p>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> v1.18 이전 버전의 쿠버네티스에서는 파드 토폴로지 분배 제약조건을 사용하려면
<a href=/ko/docs/concepts/overview/components/#kube-apiserver>API 서버</a>와
<a href=/docs/reference/command-line-tools-reference/kube-scheduler/>스케줄러</a>에서
<code>EvenPodsSpread</code><a href=/ko/docs/reference/command-line-tools-reference/feature-gates/>기능 게이트</a>를
활성화해야 한다
</div>
<h2 id=필수-구성-요소>필수 구성 요소</h2>
<h3 id=노드-레이블>노드 레이블</h3>
<p>토폴로지 분배 제약 조건은 노드 레이블을 의지해서 각 노드가 속한 토폴로지 도메인(들)을 인식한다. 예를 들어, 노드에 다음과 같은 레이블을 가지고 있을 수 있다. <code>node=node1,zone=us-east-1a,region=us-east-1</code></p>
<p>다음 레이블이 있고, 4개 노드를 가지는 클러스터가 있다고 가정한다.</p>
<pre><code>NAME    STATUS   ROLES    AGE     VERSION   LABELS
node1   Ready    &lt;none&gt;   4m26s   v1.16.0   node=node1,zone=zoneA
node2   Ready    &lt;none&gt;   3m58s   v1.16.0   node=node2,zone=zoneA
node3   Ready    &lt;none&gt;   3m17s   v1.16.0   node=node3,zone=zoneB
node4   Ready    &lt;none&gt;   2m43s   v1.16.0   node=node4,zone=zoneB
</code></pre><p>그러면 클러스터는 논리적으로 다음과 같이 보이게 된다.</p>
<figure>
<div class=mermaid>
graph TB
subgraph "zoneB"
n3(Node3)
n4(Node4)
end
subgraph "zoneA"
n1(Node1)
n2(Node2)
end
classDef plain fill:#ddd,stroke:#fff,stroke-width:4px,color:#000;
classDef k8s fill:#326ce5,stroke:#fff,stroke-width:4px,color:#fff;
classDef cluster fill:#fff,stroke:#bbb,stroke-width:2px,color:#326ce5;
class n1,n2,n3,n4 k8s;
class zoneA,zoneB cluster;
</div>
</figure>
<noscript>
<div class="alert alert-secondary callout" role=alert>
<em class=javascript-required>JavaScript must be <a href=https://www.enable-javascript.com/>enabled</a> to view this content</em>
</div>
</noscript>
<p>레이블을 수동으로 적용하는 대신에, 사용자는 대부분의 클러스터에서 자동으로 생성되고 채워지는 <a href=/ko/docs/reference/labels-annotations-taints/>잘 알려진 레이블</a>을 재사용할 수 있다.</p>
<h2 id=파드의-분배-제약-조건>파드의 분배 제약 조건</h2>
<h3 id=api>API</h3>
<p>API 필드 <code>pod.spec.topologySpreadConstraints</code> 는 다음과 같이 정의된다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>topologySpreadConstraints</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>maxSkew</span>:<span style=color:#bbb> </span>&lt;integer&gt;<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>topologyKey</span>:<span style=color:#bbb> </span>&lt;string&gt;<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>whenUnsatisfiable</span>:<span style=color:#bbb> </span>&lt;string&gt;<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labelSelector</span>:<span style=color:#bbb> </span>&lt;object&gt;<span style=color:#bbb>
</span></code></pre></div><p>사용자는 하나 또는 다중 <code>topologySpreadConstraint</code> 를 정의해서 kube-scheduler 에게 클러스터에 걸쳐 있는 기존 파드와 시작하는 각각의 파드와 연관하여 배치하는 방법을 명령할 수 있다. 필드는 다음과 같다.</p>
<ul>
<li><strong>maxSkew</strong> 는 파드가 균등하지 않게 분산될 수 있는 정도를 나타낸다.
이것은 0보다는 커야 한다. 그 의미는 <code>whenUnsatisfiable</code> 의 값에 따라 다르다.
<ul>
<li><code>whenUnsatisfiable</code> 이 "DoNotSchedule"과 같을 때, <code>maxSkew</code> 는
대상 토폴로지에서 일치하는 파드 수와 전역 최솟값
(토폴로지 도메인에서 레이블 셀렉터와 일치하는 최소 파드 수. 예를 들어 3개의 영역에 각각 0, 2, 3개의 일치하는 파드가 있으면, 전역 최솟값은 0)
사이에 허용되는 최대 차이이다.</li>
<li><code>whenUnsatisfiable</code> 이 "ScheduleAnyway"와 같으면, 스케줄러는
왜곡을 줄이는데 도움이 되는 토폴로지에 더 높은 우선 순위를 부여한다.</li>
</ul>
</li>
<li><strong>topologyKey</strong> 는 노드 레이블의 키다. 만약 두 노드가 이 키로 레이블이 지정되고, 레이블이 동일한 값을 가진다면 스케줄러는 두 노드를 같은 토폴로지에 있는것으로 여기게 된다. 스케줄러는 각 토폴로지 도메인에 균형잡힌 수의 파드를 배치하려고 시도한다.</li>
<li><strong>whenUnsatisfiable</strong> 는 분산 제약 조건을 만족하지 않을 경우에 처리하는 방법을 나타낸다.
<ul>
<li><code>DoNotSchedule</code> (기본값)은 스케줄러에 스케줄링을 하지 말라고 알려준다.</li>
<li><code>ScheduleAnyway</code> 는 스케줄러에게 차이(skew)를 최소화하는 노드에 높은 우선 순위를 부여하면서, 스케줄링을 계속하도록 지시한다.</li>
</ul>
</li>
<li><strong>labelSelector</strong> 는 일치하는 파드를 찾는데 사용된다. 이 레이블 셀렉터와 일치하는 파드의 수를 계산하여 해당 토폴로지 도메인에 속할 파드의 수를 결정한다. 자세한 내용은 <a href=/ko/docs/concepts/overview/working-with-objects/labels/#%EB%A0%88%EC%9D%B4%EB%B8%94-%EC%85%80%EB%A0%89%ED%84%B0>레이블 셀렉터</a>를 참조한다.</li>
</ul>
<p>파드에 2개 이상의 <code>topologySpreadConstraint</code>가 정의되어 있으면, 각 제약 조건은 AND로 연결된다 - kube-scheduler는 새로운 파드의 모든 제약 조건을 만족하는 노드를 찾는다.</p>
<p>사용자는 <code>kubectl explain Pod.spec.topologySpreadConstraints</code> 를 실행해서 이 필드에 대한 자세한 내용을 알 수 있다.</p>
<h3 id=예시-단수-토폴로지-분배-제약-조건>예시: 단수 토폴로지 분배 제약 조건</h3>
<p>4개 노드를 가지는 클러스터에 <code>foo:bar</code> 가 레이블된 3개의 파드가 node1, node2 그리고 node3에 각각 위치한다고 가정한다.</p>
<figure>
<div class=mermaid>
graph BT
subgraph "zoneB"
p3(Pod) --> n3(Node3)
n4(Node4)
end
subgraph "zoneA"
p1(Pod) --> n1(Node1)
p2(Pod) --> n2(Node2)
end
classDef plain fill:#ddd,stroke:#fff,stroke-width:4px,color:#000;
classDef k8s fill:#326ce5,stroke:#fff,stroke-width:4px,color:#fff;
classDef cluster fill:#fff,stroke:#bbb,stroke-width:2px,color:#326ce5;
class n1,n2,n3,n4,p1,p2,p3 k8s;
class zoneA,zoneB cluster;
</div>
</figure>
<noscript>
<div class="alert alert-secondary callout" role=alert>
<em class=javascript-required>JavaScript must be <a href=https://www.enable-javascript.com/>enabled</a> to view this content</em>
</div>
</noscript>
<p>신규 파드가 기존 파드와 함께 영역에 걸쳐서 균등하게 분배되도록 하려면, 스펙(spec)은 다음과 같이 주어질 수 있다.</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/ko/examples/pods/topology-spread-constraints/one-constraint.yaml download=pods/topology-spread-constraints/one-constraint.yaml><code>pods/topology-spread-constraints/one-constraint.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-topology-spread-constraints-one-constraint-yaml')" title="Copy pods/topology-spread-constraints/one-constraint.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-topology-spread-constraints-one-constraint-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>foo</span>:<span style=color:#bbb> </span>bar<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>topologySpreadConstraints</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>maxSkew</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>topologyKey</span>:<span style=color:#bbb> </span>zone<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>whenUnsatisfiable</span>:<span style=color:#bbb> </span>DoNotSchedule<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>labelSelector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>foo</span>:<span style=color:#bbb> </span>bar<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pause<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/pause:3.1</code></pre></div>
</div>
</div>
<p><code>topologyKey: zone</code> 는 "zone:&lt;any value>" 레이블 쌍을 가지는 노드에 대해서만 균등한 분배를 적용하는 것을 의미한다. <code>whenUnsatisfiable: DoNotSchedule</code> 은 만약 들어오는 파드가 제약 조건을 만족시키지 못하면 스케줄러에게 pending 상태를 유지하도록 지시한다.</p>
<p>만약 스케줄러가 이 신규 파드를 "zoneA"에 배치하면 파드 분포는 [3, 1]이 되며, 따라서 실제 차이(skew)는 2 (3 - 1)가 되어 <code>maxSkew: 1</code> 를 위반하게 된다. 이 예시에서는 들어오는 파드는 오직 "zoneB"에만 배치할 수 있다.</p>
<figure>
<div class=mermaid>
graph BT
subgraph "zoneB"
p3(Pod) --> n3(Node3)
p4(mypod) --> n4(Node4)
end
subgraph "zoneA"
p1(Pod) --> n1(Node1)
p2(Pod) --> n2(Node2)
end
classDef plain fill:#ddd,stroke:#fff,stroke-width:4px,color:#000;
classDef k8s fill:#326ce5,stroke:#fff,stroke-width:4px,color:#fff;
classDef cluster fill:#fff,stroke:#bbb,stroke-width:2px,color:#326ce5;
class n1,n2,n3,n4,p1,p2,p3 k8s;
class p4 plain;
class zoneA,zoneB cluster;
</div>
</figure>
<noscript>
<div class="alert alert-secondary callout" role=alert>
<em class=javascript-required>JavaScript must be <a href=https://www.enable-javascript.com/>enabled</a> to view this content</em>
</div>
</noscript>
<p>OR</p>
<figure>
<div class=mermaid>
graph BT
subgraph "zoneB"
p3(Pod) --> n3(Node3)
p4(mypod) --> n3
n4(Node4)
end
subgraph "zoneA"
p1(Pod) --> n1(Node1)
p2(Pod) --> n2(Node2)
end
classDef plain fill:#ddd,stroke:#fff,stroke-width:4px,color:#000;
classDef k8s fill:#326ce5,stroke:#fff,stroke-width:4px,color:#fff;
classDef cluster fill:#fff,stroke:#bbb,stroke-width:2px,color:#326ce5;
class n1,n2,n3,n4,p1,p2,p3 k8s;
class p4 plain;
class zoneA,zoneB cluster;
</div>
</figure>
<noscript>
<div class="alert alert-secondary callout" role=alert>
<em class=javascript-required>JavaScript must be <a href=https://www.enable-javascript.com/>enabled</a> to view this content</em>
</div>
</noscript>
<p>사용자는 파드 스펙을 조정해서 다음과 같은 다양한 요구사항을 충족할 수 있다.</p>
<ul>
<li><code>maxSkew</code> 를 "2" 보다 큰 값으로 변경해서 들어오는 파드들이 "zoneA"에도 배치할 수 있도록 한다.</li>
<li><code>topologyKey</code> 를 "node"로 변경해서 파드가 영역이 아닌, 노드에 걸쳐 고르게 분산할 수 있게 한다. 위의 예시에서 만약 <code>maxSkew</code> 가 "1"로 유지되면 들어오는 파드는 오직 "node4"에만 배치할 수 있다.</li>
<li><code>whenUnsatisfiable: DoNotSchedule</code> 에서 <code>whenUnsatisfiable: ScheduleAnyway</code> 로 변경하면 들어오는 파드는 항상 다른 스케줄링 API를 충족한다는 가정하에 스케줄할 수 있도록 보장한다. 그러나 일치하는 파드가 적은 토폴로지 도메인에 배치되는 것이 좋다. (이 선호도는 리소스 사용 비율 등과 같은 다른 내부 스케줄링 우선순위와 공동으로 정규화 된다는 것을 알아두자.)</li>
</ul>
<h3 id=예시-다중-토폴로지-분배-제약-조건>예시: 다중 토폴로지 분배 제약 조건</h3>
<p>4개 노드를 가지는 클러스터에 <code>foo:bar</code> 가 레이블된 3개의 파드가 node1, node2 그리고 node3에 각각 위치한다고 가정한다.</p>
<figure>
<div class=mermaid>
graph BT
subgraph "zoneB"
p3(Pod) --> n3(Node3)
n4(Node4)
end
subgraph "zoneA"
p1(Pod) --> n1(Node1)
p2(Pod) --> n2(Node2)
end
classDef plain fill:#ddd,stroke:#fff,stroke-width:4px,color:#000;
classDef k8s fill:#326ce5,stroke:#fff,stroke-width:4px,color:#fff;
classDef cluster fill:#fff,stroke:#bbb,stroke-width:2px,color:#326ce5;
class n1,n2,n3,n4,p1,p2,p3 k8s;
class p4 plain;
class zoneA,zoneB cluster;
</div>
</figure>
<noscript>
<div class="alert alert-secondary callout" role=alert>
<em class=javascript-required>JavaScript must be <a href=https://www.enable-javascript.com/>enabled</a> to view this content</em>
</div>
</noscript>
<p>사용자는 2개의 TopologySpreadConstraints를 사용해서 영역과 노드에 파드를 분배하는 것을 제어할 수 있다.</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/ko/examples/pods/topology-spread-constraints/two-constraints.yaml download=pods/topology-spread-constraints/two-constraints.yaml><code>pods/topology-spread-constraints/two-constraints.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-topology-spread-constraints-two-constraints-yaml')" title="Copy pods/topology-spread-constraints/two-constraints.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-topology-spread-constraints-two-constraints-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>foo</span>:<span style=color:#bbb> </span>bar<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>topologySpreadConstraints</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>maxSkew</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>topologyKey</span>:<span style=color:#bbb> </span>zone<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>whenUnsatisfiable</span>:<span style=color:#bbb> </span>DoNotSchedule<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>labelSelector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>foo</span>:<span style=color:#bbb> </span>bar<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>maxSkew</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>topologyKey</span>:<span style=color:#bbb> </span>node<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>whenUnsatisfiable</span>:<span style=color:#bbb> </span>DoNotSchedule<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>labelSelector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>foo</span>:<span style=color:#bbb> </span>bar<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pause<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/pause:3.1</code></pre></div>
</div>
</div>
<p>이 경우에는, 첫 번째 제약 조건에 부합시키려면, 신규 파드는 오직 "zoneB"에만 배치할 수 있다. 두 번째 제약 조건에서는 신규 파드는 오직 "node4"에만 배치할 수 있다. 그런 다음 두 가지 제약 조건의 결과는 AND 가 되므로, 실행 가능한 유일한 옵션은 "node4"에 배치하는 것이다.</p>
<p>다중 제약 조건은 충돌로 이어질 수 있다. 3개의 노드를 가지는 클러스터 하나가 2개의 영역에 걸쳐 있다고 가정한다.</p>
<figure>
<div class=mermaid>
graph BT
subgraph "zoneB"
p4(Pod) --> n3(Node3)
p5(Pod) --> n3
end
subgraph "zoneA"
p1(Pod) --> n1(Node1)
p2(Pod) --> n1
p3(Pod) --> n2(Node2)
end
classDef plain fill:#ddd,stroke:#fff,stroke-width:4px,color:#000;
classDef k8s fill:#326ce5,stroke:#fff,stroke-width:4px,color:#fff;
classDef cluster fill:#fff,stroke:#bbb,stroke-width:2px,color:#326ce5;
class n1,n2,n3,n4,p1,p2,p3,p4,p5 k8s;
class zoneA,zoneB cluster;
</div>
</figure>
<noscript>
<div class="alert alert-secondary callout" role=alert>
<em class=javascript-required>JavaScript must be <a href=https://www.enable-javascript.com/>enabled</a> to view this content</em>
</div>
</noscript>
<p>만약 사용자가 "two-constraints.yaml" 을 이 클러스터에 적용하면, "mypod"가 <code>Pending</code> 상태로 유지되는 것을 알게 된다. 이러한 이유는, 첫 번째 제약 조건을 충족하기 위해 "mypod"는 오직 "zoneB"에만 놓을 수 있다. 두 번째 제약 조건에서는 "mypod"는 오직 "node2"에만 놓을 수 있다. 그러면 "zoneB"와 "node2"의 공동 결과는 아무것도 반환되지 않는다.</p>
<p>이 상황을 극복하기 위해서는 사용자가 <code>maxSkew</code> 의 증가 또는 <code>whenUnsatisfiable: ScheduleAnyway</code> 를 사용하도록 제약 조건 중 하나를 수정할 수 있다.</p>
<h3 id=노드-어피니티-affinity-및-노드-셀렉터-selector-와의-상호-작용>노드 어피니티(Affinity) 및 노드 셀렉터(Selector)와의 상호 작용</h3>
<p>스케줄러는 신규 파드에 <code>spec.nodeSelector</code> 또는 <code>spec.affinity.nodeAffinity</code>가 정의되어 있는 경우, 부합하지 않는 노드들을 차이(skew) 계산에서 생략한다.</p>
<h3 id=예시-topologyspreadconstraints와-노드-어피니티>예시: TopologySpreadConstraints와 노드 어피니티</h3>
<p>zoneA 에서 zoneC에 걸쳐있고, 5개의 노드를 가지는 클러스터가 있다고 가정한다.</p>
<figure>
<div class=mermaid>
graph BT
subgraph "zoneB"
p3(Pod) --> n3(Node3)
n4(Node4)
end
subgraph "zoneA"
p1(Pod) --> n1(Node1)
p2(Pod) --> n2(Node2)
end
classDef plain fill:#ddd,stroke:#fff,stroke-width:4px,color:#000;
classDef k8s fill:#326ce5,stroke:#fff,stroke-width:4px,color:#fff;
classDef cluster fill:#fff,stroke:#bbb,stroke-width:2px,color:#326ce5;
class n1,n2,n3,n4,p1,p2,p3 k8s;
class p4 plain;
class zoneA,zoneB cluster;
</div>
</figure>
<noscript>
<div class="alert alert-secondary callout" role=alert>
<em class=javascript-required>JavaScript must be <a href=https://www.enable-javascript.com/>enabled</a> to view this content</em>
</div>
</noscript>
<figure>
<div class=mermaid>
graph BT
subgraph "zoneC"
n5(Node5)
end
classDef plain fill:#ddd,stroke:#fff,stroke-width:4px,color:#000;
classDef k8s fill:#326ce5,stroke:#fff,stroke-width:4px,color:#fff;
classDef cluster fill:#fff,stroke:#bbb,stroke-width:2px,color:#326ce5;
class n5 k8s;
class zoneC cluster;
</div>
</figure>
<noscript>
<div class="alert alert-secondary callout" role=alert>
<em class=javascript-required>JavaScript must be <a href=https://www.enable-javascript.com/>enabled</a> to view this content</em>
</div>
</noscript>
<p>그리고 알다시피 "zoneC"는 제외해야 한다. 이 경우에, "mypod"가 "zoneC"가 아닌 "zoneB"에 배치되도록 yaml을 다음과 같이 구성할 수 있다. 마찬가지로 <code>spec.nodeSelector</code> 도 존중된다.</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/ko/examples/pods/topology-spread-constraints/one-constraint-with-nodeaffinity.yaml download=pods/topology-spread-constraints/one-constraint-with-nodeaffinity.yaml><code>pods/topology-spread-constraints/one-constraint-with-nodeaffinity.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-topology-spread-constraints-one-constraint-with-nodeaffinity-yaml')" title="Copy pods/topology-spread-constraints/one-constraint-with-nodeaffinity.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-topology-spread-constraints-one-constraint-with-nodeaffinity-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>foo</span>:<span style=color:#bbb> </span>bar<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>topologySpreadConstraints</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>maxSkew</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>topologyKey</span>:<span style=color:#bbb> </span>zone<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>whenUnsatisfiable</span>:<span style=color:#bbb> </span>DoNotSchedule<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>labelSelector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>foo</span>:<span style=color:#bbb> </span>bar<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>affinity</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>nodeAffinity</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requiredDuringSchedulingIgnoredDuringExecution</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>nodeSelectorTerms</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>zone<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span>NotIn<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>values</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span>- zoneC<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pause<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/pause:3.1</code></pre></div>
</div>
</div>
<p>스케줄러는 클러스터에 있는 모든 영역(zone) 또는 다른 토폴로지 도메인에 대한 사전 지식이 없다. 스케줄링은 클러스터의 기존 노드에서 결정된다. 노드 풀(또는 노드 그룹)이 0개의 노드로 스케일(scale)되고 사용자는 노드가 확장될 것으로 예상하는 경우, 자동 스케일되는 클러스터에서 문제가 발생할 수 있다. 이러한 토폴로지 도메인은 스케줄링에서 해당 도메인에 노드가 하나 이상 있을 때까지 고려되지 않을 것이기 때문이다.</p>
<h3 id=기타-눈에-띄는-의미-semantics>기타 눈에 띄는 의미(semantics)</h3>
<p>여기에 주목할만한 몇 가지 암묵적인 규칙이 있다.</p>
<ul>
<li>
<p>신규 파드와 같은 네임스페이스를 갖는 파드만이 매칭의 후보가 된다.</p>
</li>
<li>
<p><code>topologySpreadConstraints[*].topologyKey</code> 가 없는 노드는 무시된다. 이것은 다음을 의미한다.</p>
<ol>
<li>이러한 노드에 위치한 파드는 "maxSkew" 계산에 영향을 미치지 않는다. - 위의 예시에서, "node1"은 "zone" 레이블을 가지고 있지 않다고 가정하면, 파드 2개는 무시될 것이고, 이런 이유로 신규 파드는 "zoneA"로 스케줄된다.</li>
<li>신규 파드는 이런 종류의 노드에 스케줄 될 기회가 없다. - 위의 예시에서, 레이블로 <code>{zone-typo: zoneC}</code> 를 가지는 "node5"가 클러스터에 편입한다고 가정하면, 레이블 키에 "zone"이 없기 때문에 무시하게 된다.</li>
</ol>
</li>
<li>
<p>들어오는 파드의 <code>topologySpreadConstraints[*].labelSelector</code> 와 자체 레이블과 일치하지 않을 경우 어떻게 되는지 알고 있어야 한다. 위의 예시에서, 만약 들어오는 파드의 레이블을 제거하더라도 여전히 제약 조건이 충족하기 때문에 "zoneB"에 배치할 수 있다. 그러나, 배치 이후에도 클러스터의 불균형 정도는 변경되지 않는다. - 여전히 zoneA는 {foo:bar} 레이블을 가지고 있는 2개의 파드를 가지고 있고, zoneB 도 {foo:bar}를 레이블로 가지는 파드 1개를 가지고 있다. 따라서 만약 예상과 다르면, 워크로드의 <code>topologySpreadConstraints[*].labelSelector</code> 가 자체 레이블과 일치하도록 하는 것을 권장한다.</p>
</li>
</ul>
<h3 id=클러스터-수준의-기본-제약-조건>클러스터 수준의 기본 제약 조건</h3>
<p>클러스터에 대한 기본 토폴로지 분배 제약 조건을 설정할 수 있다. 기본
토폴로지 분배 제약 조건은 다음과 같은 경우에만 파드에 적용된다.</p>
<ul>
<li><code>.spec.topologySpreadConstraints</code> 에는 어떠한 제약도 정의되어 있지 않는 경우.</li>
<li>서비스, 레플리케이션컨트롤러(ReplicationController), 레플리카셋(ReplicaSet) 또는 스테이트풀셋(StatefulSet)에 속해있는 경우.</li>
</ul>
<p>기본 제약 조건은 <a href=/ko/docs/reference/scheduling/config/#%ED%94%84%EB%A1%9C%ED%8C%8C%EC%9D%BC>스케줄링 프로파일</a>에서
<code>PodTopologySpread</code> 플러그인의 일부로 설정할 수 있다.
제약 조건은 <code>labelSelector</code> 가 비어 있어야 한다는 점을 제외하고, <a href=#api>위와 동일한 API</a>로
제약 조건을 지정한다. 셀렉터는 파드가 속한 서비스, 레플리케이션 컨트롤러,
레플리카셋 또는 스테이트풀셋에서 계산한다.</p>
<p>예시 구성은 다음과 같다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>kubescheduler.config.k8s.io/v1beta1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>KubeSchedulerConfiguration<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>profiles</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>pluginConfig</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>PodTopologySpread<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>defaultConstraints</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span>- <span style=color:green;font-weight:700>maxSkew</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>topologyKey</span>:<span style=color:#bbb> </span>topology.kubernetes.io/zone<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>whenUnsatisfiable</span>:<span style=color:#bbb> </span>ScheduleAnyway<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>defaultingType</span>:<span style=color:#bbb> </span>List<span style=color:#bbb>
</span></code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> 기본 스케줄링 제약 조건에 의해 생성된 점수는
<a href=/ko/docs/reference/scheduling/config/#%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81-%ED%94%8C%EB%9F%AC%EA%B7%B8%EC%9D%B8><code>SelectorSpread</code> 플러그인</a>에
의해 생성된 점수와 충돌 할 수 있다.
<code>PodTopologySpread</code> 에 대한 기본 제약 조건을 사용할 때 스케줄링 프로파일에서
이 플러그인을 비활성화 하는 것을 권장한다.
</div>
<h4 id=내부-기본-제약>내부 기본 제약</h4>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.20 [beta]</code>
</div>
<p>기본적으로 활성화된 <code>DefaultPodTopologySpread</code> 기능 게이트를 사용하면, 기존
<code>SelectorSpread</code> 플러그인이 비활성화된다.
kube-scheduler는 <code>PodTopologySpread</code> 플러그인 구성에 다음과 같은
기본 토폴로지 제약 조건을 사용한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>defaultConstraints</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>maxSkew</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>topologyKey</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;kubernetes.io/hostname&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>whenUnsatisfiable</span>:<span style=color:#bbb> </span>ScheduleAnyway<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>maxSkew</span>:<span style=color:#bbb> </span><span style=color:#666>5</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>topologyKey</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;topology.kubernetes.io/zone&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>whenUnsatisfiable</span>:<span style=color:#bbb> </span>ScheduleAnyway<span style=color:#bbb>
</span></code></pre></div><p>또한, 같은 동작을 제공하는 레거시 <code>SelectorSpread</code> 플러그인이
비활성화된다.</p>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> <p><code>PodTopologySpread</code> 플러그인은 분배 제약 조건에 지정된 토폴로지 키가
없는 노드에 점수를 매기지 않는다.
이로 인해 기본 토폴로지 제약을 사용하는 경우의
레거시 <code>SelectorSpread</code> 플러그인과는 기본 정책이 다를 수 있다.</p>
<p>노드에 <code>kubernetes.io/hostname</code> 및 <code>topology.kubernetes.io/zone</code>
레이블 세트 <strong>둘 다</strong>가 설정되지 않을 것으로 예상되는 경우, 쿠버네티스 기본값을 사용하는
대신 자체 제약 조건을 정의한다.</p>
</div>
<p>클러스터에 기본 파드 분배 제약 조건을 사용하지 않으려면,
<code>PodTopologySpread</code> 플러그인 구성에서 <code>defaultingType</code> 을 <code>List</code> 로 설정하고
<code>defaultConstraints</code> 를 비워두어 기본값을 비활성화할 수 있다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>kubescheduler.config.k8s.io/v1beta1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>KubeSchedulerConfiguration<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>profiles</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>pluginConfig</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>PodTopologySpread<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>defaultConstraints</span>:<span style=color:#bbb> </span>[]<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>defaultingType</span>:<span style=color:#bbb> </span>List<span style=color:#bbb>
</span></code></pre></div><h2 id=파드어피니티-podaffinity-파드안티어피니티-podantiaffinity-와의-비교>파드어피니티(PodAffinity)/파드안티어피니티(PodAntiAffinity)와의 비교</h2>
<p>쿠버네티스에서 "어피니티(Affinity)"와 관련된 지침은 파드가
더 많이 채워지거나 더 많이 분산되는 방식으로 스케줄 되는 방법을 제어한다.</p>
<ul>
<li><code>PodAffinity</code> 는, 사용자가 자격이 충족되는 토폴로지 도메인에
원하는 수의 파드를 얼마든지 채울 수 있다.</li>
<li><code>PodAntiAffinity</code> 로는, 단일 토폴로지 도메인에
단 하나의 파드만 스케줄 될 수 있다.</li>
</ul>
<p>더 세밀한 제어를 위해, 토폴로지 분배 제약 조건을 지정하여 다양한 토폴로지 도메인에 파드를
분배해서 고 가용성 또는 비용 절감을 달성할 수 있는 유연한 옵션을
제공한다. 또한 워크로드의 롤링 업데이트와 레플리카의 원활한 스케일링 아웃에 도움이 될 수 있다.
더 자세한 내용은
<a href=https://github.com/kubernetes/enhancements/tree/master/keps/sig-scheduling/895-pod-topology-spread#motivation>모티베이션(Motivation)</a>를
참고한다.</p>
<h2 id=알려진-제한사항>알려진 제한사항</h2>
<ul>
<li>파드가 제거된 이후에도 제약 조건이 계속 충족된다는 보장은 없다. 예를 들어 디플로이먼트를 스케일링 다운하면 그 결과로 파드의 분포가 불균형해질 수 있다.
<a href=https://github.com/kubernetes-sigs/descheduler>Descheduler</a>를 사용하여 파드 분포를 다시 균형있게 만들 수 있다.</li>
<li>파드와 일치하는 테인트(taint)가 된 노드가 존중된다. <a href=https://github.com/kubernetes/kubernetes/issues/80921>이슈 80921</a>을 본다.</li>
</ul>
<h2 id=다음-내용>다음 내용</h2>
<ul>
<li><a href=https://kubernetes.io/blog/2020/05/introducing-podtopologyspread/>블로그: PodTopologySpread 소개</a>에서는
<code>maxSkew</code> 에 대해 자세히 설명하고, 몇 가지 고급 사용 예제를 제공한다.</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-4aaf43c715cd764bc8ed4436f3537e68>4.1.4 - 중단(disruption)</h1>
<p>이 가이드는 고가용성 애플리케이션을 구성하려는 소유자와
파드에서 발생하는 장애 유형을 이해하기
원하는 애플리케이션 소유자를 위한 것이다.</p>
<p>또한 클러스터의 업그레이드와 오토스케일링과 같은
클러스터의 자동화 작업을 하려는 관리자를 위한 것이다.</p>
<h2 id=자발적-중단과-비자발적-중단>자발적 중단과 비자발적 중단</h2>
<p>파드는 누군가(사람 또는 컨트롤러)가 파괴하거나
불가피한 하드웨어 오류 또는 시스템 소프트웨어 오류가 아니면 사라지지 않는다.</p>
<p>우리는 이런 불가피한 상황을 애플리케이션의 <em>비자발적 중단</em> 으로 부른다.
예시:</p>
<ul>
<li>노드를 지원하는 물리 머신의 하드웨어 오류</li>
<li>클러스터 관리자의 실수로 VM(인스턴스) 삭제</li>
<li>클라우드 공급자 또는 하이퍼바이저의 오류로 인한 VM 장애</li>
<li>커널 패닉</li>
<li>클러스터 네트워크 파티션의 발생으로 클러스터에서 노드가 사라짐</li>
<li>노드의 <a href=/ko/docs/concepts/scheduling-eviction/node-pressure-eviction/>리소스 부족</a>으로 파드가 축출됨</li>
</ul>
<p>리소스 부족을 제외한 나머지 조건은 대부분의 사용자가 익숙할 것이다.
왜냐하면
그 조건은 쿠버네티스에 국한되지 않기 때문이다.</p>
<p>우리는 다른 상황을 <em>자발적인 중단</em> 으로 부른다.
여기에는 애플리케이션 소유자의 작업과 클러스터 관리자의 작업이 모두 포함된다.
다음은 대표적인 애플리케이션 소유자의 작업이다.</p>
<ul>
<li>디플로이먼트 제거 또는 다른 파드를 관리하는 컨트롤러의 제거</li>
<li>재시작을 유발하는 디플로이먼트의 파드 템플릿 업데이트</li>
<li>파드를 직접 삭제(예: 우연히)</li>
</ul>
<p>클러스터 관리자의 작업은 다음을 포함한다.</p>
<ul>
<li>복구 또는 업그레이드를 위한 <a href=/docs/tasks/administer-cluster/safely-drain-node/>노드 드레이닝</a>.</li>
<li>클러스터의 스케일 축소를 위한
노드 드레이닝(<a href=https://github.com/kubernetes/autoscaler/#readme>클러스터 오토스케일링</a>에 대해 알아보기
).</li>
<li>노드에 다른 무언가를 추가하기 위해 파드를 제거.</li>
</ul>
<p>위 작업은 클러스터 관리자가 직접 수행하거나 자동화를 통해 수행하며,
클러스터 호스팅 공급자에 의해서도 수행된다.</p>
<p>클러스터에 자발적인 중단을 일으킬 수 있는 어떤 원인이 있는지
클러스터 관리자에게 문의하거나 클라우드 공급자에게 문의하고, 배포 문서를 참조해서 확인해야 한다.
만약 자발적인 중단을 일으킬 수 있는 원인이 없다면 Pod Disruption Budget의 생성을 넘길 수 있다.</p>
<div class="alert alert-warning caution callout" role=alert>
<strong>주의:</strong> 모든 자발적인 중단이 Pod Disruption Budget에 연관되는 것은 아니다.
예를 들어 디플로이먼트 또는 파드의 삭제는 Pod Disruption Budget을 무시한다.
</div>
<h2 id=중단-다루기>중단 다루기</h2>
<p>비자발적인 중단으로 인한 영향을 경감하기 위한 몇 가지 방법은 다음과 같다.</p>
<ul>
<li>파드가 필요로 하는 <a href=/ko/docs/tasks/configure-pod-container/assign-memory-resource/>리소스를 요청</a>하는지 확인한다.</li>
<li>고가용성이 필요한 경우 애플리케이션을 복제한다.
(복제된 <a href=/ko/docs/tasks/run-application/run-stateless-application-deployment/>스테이트리스</a> 및
<a href=/docs/tasks/run-application/run-replicated-stateful-application/>스테이트풀</a> 애플리케이션에 대해 알아보기.)</li>
<li>복제된 애플리케이션의 구동 시 훨씬 더 높은 가용성을 위해 랙 전체
(<a href=/ko/docs/concepts/scheduling-eviction/assign-pod-node/#%ED%8C%8C%EB%93%9C%EA%B0%84-%EC%96%B4%ED%94%BC%EB%8B%88%ED%8B%B0%EC%99%80-%EC%95%88%ED%8B%B0-%EC%96%B4%ED%94%BC%EB%8B%88%ED%8B%B0>안티-어피니티</a> 이용)
또는 영역 간
(<a href=/ko/docs/setup/best-practices/multiple-zones/>다중 영역 클러스터</a>를 이용한다면)에
애플리케이션을 분산해야 한다.</li>
</ul>
<p>자발적 중단의 빈도는 다양하다. 기본적인 쿠버네티스 클러스터에서는 자동화된 자발적 중단은 발생하지 않는다(사용자가 지시한 자발적 중단만 발생한다).
그러나 클러스터 관리자 또는 호스팅 공급자가 자발적 중단이 발생할 수 있는 일부 부가 서비스를 운영할 수 있다.
예를 들어 노드 소프트웨어의 업데이트를 출시하는 경우 자발적 중단이 발생할 수 있다.
또한 클러스터(노드) 오토스케일링의 일부 구현에서는
단편화를 제거하고 노드의 효율을 높이는 과정에서 자발적 중단을 야기할 수 있다.
클러스터 관리자 또는 호스팅 공급자는
예측 가능한 자발적 중단 수준에 대해 문서화해야 한다.
파드 스펙 안에 <a href=/ko/docs/concepts/scheduling-eviction/pod-priority-preemption/>프라이어리티클래스 사용하기</a>와 같은 특정 환경설정 옵션
또한 자발적(+ 비자발적) 중단을 유발할 수 있다.</p>
<h2 id=파드-disruption-budgets>파드 disruption budgets</h2>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.21 [stable]</code>
</div>
<p>쿠버네티스는 자발적인 중단이 자주 발생하는 경우에도 고 가용성 애플리케이션을
실행하는 데 도움이 되는 기능을 제공한다.</p>
<p>애플리케이션 소유자로써, 사용자는 각 애플리케이션에 대해 PodDisruptionBudget(PDB)을 만들 수 있다.
PDB는 자발적 중단으로
일시에 중지되는 복제된 애플리케이션 파드의 수를 제한한다.
예를 들어, 정족수 기반의 애플리케이션이
실행 중인 레플리카의 수가 정족수 이하로 떨어지지 않도록 한다.
웹 프런트 엔드는 부하를 처리하는 레플리카의 수가
일정 비율 이하로 떨어지지 않도록 보장할 수 있다.</p>
<p>클러스터 관리자와 호스팅 공급자는 직접적으로 파드나 디플로이먼트를 제거하는 대신
<a href=/docs/tasks/administer-cluster/safely-drain-node/#eviction-api>Eviction API</a>로
불리는 PodDisruptionBudget을 준수하는 도구를 이용해야 한다.</p>
<p>예를 들어, <code>kubectl drain</code> 하위 명령을 사용하면 노드를 서비스 중단으로 표시할 수
있다. <code>kubectl drain</code> 을 실행하면, 도구는 사용자가 서비스를 중단하는 노드의
모든 파드를 축출하려고 한다. <code>kubectl</code> 이 사용자를 대신하여 수행하는
축출 요청은 일시적으로 거부될 수 있으며,
도구는 대상 노드의 모든 파드가 종료되거나
설정 가능한 타임아웃이 도래할 때까지 주기적으로 모든 실패된 요청을 다시 시도한다.</p>
<p>PDB는 애플리케이션이 필요로 하는 레플리카의 수에 상대적으로, 용인할 수 있는 레플리카의 수를 지정한다.
예를 들어 <code>.spec.replicas: 5</code> 의 값을 갖는 디플로이먼트는 어느 시점에든 5개의 파드를 가져야 한다.
만약 해당 디플로이먼트의 PDB가 특정 시점에 파드를 4개 허용한다면,
Eviction API는 한 번에 1개(2개의 파드가 아닌)의 파드의 자발적인 중단을 허용한다.</p>
<p>파드 그룹은 레이블 셀렉터를 사용해서 지정한 애플리케이션으로 구성되며
애플리케이션 컨트롤러(디플로이먼트, 스테이트풀셋 등)를 사용한 것과 같다.</p>
<p>파드의 "의도"하는 수량은 해당 파드를 관리하는 워크로드 리소스의 <code>.spec.replicas</code> 를
기반으로 계산한다. 컨트롤 플레인은 파드의 <code>.metadata.ownerReferences</code> 를 검사하여
소유하는 워크로드 리소스를 발견한다.</p>
<p><a href=#%EC%9E%90%EB%B0%9C%EC%A0%81-%EC%A4%91%EB%8B%A8%EA%B3%BC-%EB%B9%84%EC%9E%90%EB%B0%9C%EC%A0%81-%EC%A4%91%EB%8B%A8>비자발적 중단</a>은 PDB로는 막을 수 없지만,
버짓은 차감된다.</p>
<p>애플리케이션의 롤링 업그레이드로 파드가 삭제되거나 사용할 수 없는 경우 중단 버짓에 영향을 준다.
그러나 워크로드 리소스(디플로이먼트, 스테이트풀셋과 같은)는
롤링 업데이트 시 PDB의 제한을 받지 않는다. 대신, 애플리케이션 업데이트 중
실패 처리는 특정 워크로드 리소스에 대한 명세에서 구성된다.</p>
<p>Eviction API를 사용하여 파드를 축출하면,
<a href=/docs/reference/generated/kubernetes-api/v1.23/#podspec-v1-core>PodSpec</a>의
<code>terminationGracePeriodSeconds</code> 설정을 준수하여 정상적으로 <a href=/ko/docs/concepts/workloads/pods/pod-lifecycle/#%ED%8C%8C%EB%93%9C%EC%9D%98-%EC%A2%85%EB%A3%8C>종료됨</a> 상태가 된다.</p>
<h2 id=pdb-example>PodDisruptionBudget 예시</h2>
<p><code>node-1</code> 부터 <code>node-3</code> 까지 3개의 노드가 있는 클러스터가 있다고 하자.
클러스터에는 여러 애플리케이션을 실행하고 있다.
여러 애플리케이션 중 하나는 <code>pod-a</code>, <code>pod-b</code>, <code>pod-c</code> 로 부르는 3개의 레플리카가 있다. 여기에 <code>pod-x</code> 라고 부르는 PDB와 무관한 파드가 보인다.
초기에 파드는 다음과 같이 배치된다.</p>
<table>
<thead>
<tr>
<th style=text-align:center>node-1</th>
<th style=text-align:center>node-2</th>
<th style=text-align:center>node-3</th>
</tr>
</thead>
<tbody>
<tr>
<td style=text-align:center>pod-a <em>available</em></td>
<td style=text-align:center>pod-b <em>available</em></td>
<td style=text-align:center>pod-c <em>available</em></td>
</tr>
<tr>
<td style=text-align:center>pod-x <em>available</em></td>
<td style=text-align:center></td>
<td style=text-align:center></td>
</tr>
</tbody>
</table>
<p>전체 3개 파드는 디플로이먼트의 일부분으로
전체적으로 항상 3개의 파드 중 최소 2개의 파드를 사용할 수 있도록 하는 PDB를 가지고 있다.</p>
<p>예를 들어, 클러스터 관리자가 커널 버그를 수정하기위해 새 커널 버전으로 재부팅하려는 경우를 가정해보자.
클러스터 관리자는 첫째로 <code>node-1</code> 을 <code>kubectl drain</code> 명령어를 사용해서 비우려 한다.
<code>kubectl</code> 은 <code>pod-a</code> 과 <code>pod-x</code> 를 축출하려고 한다. 이는 즉시 성공한다.
두 파드는 동시에 <code>terminating</code> 상태로 진입한다.
이렇게 하면 클러스터는 다음의 상태가 된다.</p>
<table>
<thead>
<tr>
<th style=text-align:center>node-1 <em>draining</em></th>
<th style=text-align:center>node-2</th>
<th style=text-align:center>node-3</th>
</tr>
</thead>
<tbody>
<tr>
<td style=text-align:center>pod-a <em>terminating</em></td>
<td style=text-align:center>pod-b <em>available</em></td>
<td style=text-align:center>pod-c <em>available</em></td>
</tr>
<tr>
<td style=text-align:center>pod-x <em>terminating</em></td>
<td style=text-align:center></td>
<td style=text-align:center></td>
</tr>
</tbody>
</table>
<p>디플로이먼트는 한 개의 파드가 중지되는 것을 알게되고, <code>pod-d</code> 라는 대체 파드를 생성한다.
<code>node-1</code> 은 차단되어 있어 다른 노드에 위치한다.
무언가가 <code>pod-x</code> 의 대체 파드로 <code>pod-y</code> 도 생성했다.</p>
<p>(참고: 스테이트풀셋은 <code>pod-0</code> 처럼 불릴, <code>pod-a</code> 를
교체하기 전에 완전히 중지해야 하며, <code>pod-0</code> 로 불리지만, 다른 UID로 생성된다.
그렇지 않으면 이 예시는 스테이트풀셋에도 적용된다.)</p>
<p>이제 클러스터는 다음과 같은 상태이다.</p>
<table>
<thead>
<tr>
<th style=text-align:center>node-1 <em>draining</em></th>
<th style=text-align:center>node-2</th>
<th style=text-align:center>node-3</th>
</tr>
</thead>
<tbody>
<tr>
<td style=text-align:center>pod-a <em>terminating</em></td>
<td style=text-align:center>pod-b <em>available</em></td>
<td style=text-align:center>pod-c <em>available</em></td>
</tr>
<tr>
<td style=text-align:center>pod-x <em>terminating</em></td>
<td style=text-align:center>pod-d <em>starting</em></td>
<td style=text-align:center>pod-y</td>
</tr>
</tbody>
</table>
<p>어느 순간 파드가 종료되고, 클러스터는 다음과 같은 상태가 된다.</p>
<table>
<thead>
<tr>
<th style=text-align:center>node-1 <em>drained</em></th>
<th style=text-align:center>node-2</th>
<th style=text-align:center>node-3</th>
</tr>
</thead>
<tbody>
<tr>
<td style=text-align:center></td>
<td style=text-align:center>pod-b <em>available</em></td>
<td style=text-align:center>pod-c <em>available</em></td>
</tr>
<tr>
<td style=text-align:center></td>
<td style=text-align:center>pod-d <em>starting</em></td>
<td style=text-align:center>pod-y</td>
</tr>
</tbody>
</table>
<p>이 시점에서 만약 성급한 클러스터 관리자가 <code>node-2</code> 또는 <code>node-3</code> 을
비우려고 하는 경우 디플로이먼트에 available 상태의 파드가 2개 뿐이고,
PDB에 필요한 최소 파드는 2개이기 때문에 drain 명령이 차단된다. 약간의 시간이 지나면 <code>pod-d</code> 가 available 상태가 된다.</p>
<p>이제 클러스터는 다음과 같은 상태이다.</p>
<table>
<thead>
<tr>
<th style=text-align:center>node-1 <em>drained</em></th>
<th style=text-align:center>node-2</th>
<th style=text-align:center>node-3</th>
</tr>
</thead>
<tbody>
<tr>
<td style=text-align:center></td>
<td style=text-align:center>pod-b <em>available</em></td>
<td style=text-align:center>pod-c <em>available</em></td>
</tr>
<tr>
<td style=text-align:center></td>
<td style=text-align:center>pod-d <em>available</em></td>
<td style=text-align:center>pod-y</td>
</tr>
</tbody>
</table>
<p>이제 클러스터 관리자는 <code>node-2</code> 를 비우려고 한다.
drain 커멘드는 <code>pod-b</code> 에서 <code>pod-d</code> 와 같이 어떤 순서대로 두 파드를 축출하려 할 것이다.
drain 커멘드는 <code>pod-b</code> 를 축출하는데 성공했다.
그러나 drain 커멘드가 <code>pod-d</code> 를 축출하려 하는 경우
디플로이먼트에 available 상태의 파드는 1개로 축출이 거부된다.</p>
<p>디플로이먼트는<code>pod-b</code> 를 대체할 <code>pod-e</code> 라는 파드를 생성한다.
클러스터에 <code>pod-e</code> 를 스케줄하기 위한 충분한 리소스가 없기 때문에
드레이닝 명령어는 차단된다.
클러스터는 다음 상태로 끝나게 된다.</p>
<table>
<thead>
<tr>
<th style=text-align:center>node-1 <em>drained</em></th>
<th style=text-align:center>node-2</th>
<th style=text-align:center>node-3</th>
<th style=text-align:center><em>no node</em></th>
</tr>
</thead>
<tbody>
<tr>
<td style=text-align:center></td>
<td style=text-align:center>pod-b <em>terminating</em></td>
<td style=text-align:center>pod-c <em>available</em></td>
<td style=text-align:center>pod-e <em>pending</em></td>
</tr>
<tr>
<td style=text-align:center></td>
<td style=text-align:center>pod-d <em>available</em></td>
<td style=text-align:center>pod-y</td>
<td style=text-align:center></td>
</tr>
</tbody>
</table>
<p>이 시점에서 클러스터 관리자는
클러스터에 노드를 추가해서 업그레이드를 진행해야 한다.</p>
<p>쿠버네티스에 중단이 발생할 수 있는 비율을 어떻게 변화시키는지
다음의 사례를 통해 알 수 있다.</p>
<ul>
<li>애플리케이션에 필요한 레플리카의 수</li>
<li>인스턴스를 정상적으로 종료하는데 소요되는 시간</li>
<li>새 인스턴스를 시작하는데 소요되는 시간</li>
<li>컨트롤러의 유형</li>
<li>클러스터의 리소스 용량</li>
</ul>
<h2 id=클러스터-소유자와-애플리케이션-소유자의-역할-분리>클러스터 소유자와 애플리케이션 소유자의 역할 분리</h2>
<p>보통 클러스터 매니저와 애플리케이션 소유자는
서로에 대한 지식이 부족한 별도의 역할로 생각하는 것이 유용하다.
이와 같은 책임의 분리는
다음의 시나리오에서 타당할 수 있다.</p>
<ul>
<li>쿠버네티스 클러스터를 공유하는 애플리케이션 팀이 많고, 자연스럽게 역할이 나누어진 경우</li>
<li>타사 도구 또는 타사 서비스를 이용해서
클러스터 관리를 자동화 하는 경우</li>
</ul>
<p>Pod Disruption Budget은 역할 분리에 따라
역할에 맞는 인터페이스를 제공한다.</p>
<p>만약 조직에 역할 분리에 따른 책임의 분리가 없다면
Pod Disruption Budget을 사용할 필요가 없다.</p>
<h2 id=클러스터에서-중단이-발생할-수-있는-작업을-하는-방법>클러스터에서 중단이 발생할 수 있는 작업을 하는 방법</h2>
<p>만약 클러스터 관리자라면, 그리고 클러스터 전체 노드에 노드 또는 시스템 소프트웨어 업그레이드와 같은
중단이 발생할 수 있는 작업을 수행하는 경우 다음과 같은 옵션을 선택한다.</p>
<ul>
<li>업그레이드 하는 동안 다운타임을 허용한다.</li>
<li>다른 레플리카 클러스터로 장애조치를 한다.
<ul>
<li>다운타임은 없지만, 노드 사본과
전환 작업을 조정하기 위한 인력 비용이 많이 발생할 수 있다.</li>
</ul>
</li>
<li>PDB를 이용해서 애플리케이션의 중단에 견디도록 작성한다.
<ul>
<li>다운타임 없음</li>
<li>최소한의 리소스 중복</li>
<li>클러스터 관리의 자동화 확대 적용</li>
<li>내결함성이 있는 애플리케이션의 작성은 까다롭지만
자발적 중단를 허용하는 작업의 대부분은 오토스케일링과
비자발적 중단를 지원하는 작업과 겹친다.</li>
</ul>
</li>
</ul>
<h2 id=다음-내용>다음 내용</h2>
<ul>
<li>
<p><a href=/docs/tasks/run-application/configure-pdb/>Pod Disruption Budget 설정하기</a>의 단계를 따라서 애플리케이션을 보호한다.</p>
</li>
<li>
<p><a href=/docs/tasks/administer-cluster/safely-drain-node/>노드 비우기</a>에 대해 자세히 알아보기</p>
</li>
<li>
<p>롤아웃 중에 가용성을 유지하는 단계를 포함하여
<a href=/ko/docs/concepts/workloads/controllers/deployment/#%EB%94%94%ED%94%8C%EB%A1%9C%EC%9D%B4%EB%A8%BC%ED%8A%B8-%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8>디플로이먼트 업데이트</a>에 대해 알아보기</p>
</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-53a1005011e1bda2ce81819aad7c8b32>4.1.5 - 임시(Ephemeral) 컨테이너</h1>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.23 [beta]</code>
</div>
<p>이 페이지는 임시 컨테이너에 대한 개요를 제공한다.
이 특별한 유형의 컨테이너는 트러블슈팅과 같은 사용자가 시작한 작업을 완료하기 위해
기존 <a class=glossary-tooltip title="파드는 클러스터에서 실행 중인 컨테이너의 집합을 나타낸다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/pods/ target=_blank aria-label=파드>파드</a>에서 임시적으로 실행된다.
임시 컨테이너는 애플리케이션을 빌드하는 경우보다는 서비스 점검과 같은 경우에 더 적합하다.</p>
<h2 id=임시-컨테이너-이해하기>임시 컨테이너 이해하기</h2>
<p><a class=glossary-tooltip title="파드는 클러스터에서 실행 중인 컨테이너의 집합을 나타낸다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/pods/ target=_blank aria-label=파드>파드</a> 는 쿠버네티스 애플리케이션의
기본 구성 요소이다. 파드는 일회용이고, 교체 가능한 것으로 의도되었기
때문에, 사용자는 파드가 한번 생성되면, 컨테이너를 추가할 수 없다.
대신, 사용자는 보통 <a class=glossary-tooltip title="클러스터에서 복제된 애플리케이션을 관리한다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/controllers/deployment/ target=_blank aria-label=디플로이먼트>디플로이먼트</a> 를
사용해서 제어하는 방식으로 파드를 삭제하고 교체한다.</p>
<p>그러나 때때로 재현하기 어려운 버그의 문제 해결을 위해
기존 파드의 상태를 검사해야 할 수 있다. 이 경우 사용자는
기존 파드에서 임시 컨테이너를 실행해서 상태를 검사하고, 임의의 명령을
실행할 수 있다.</p>
<h3 id=임시-컨테이너는-무엇인가>임시 컨테이너는 무엇인가?</h3>
<p>임시 컨테이너는 리소스 또는 실행에 대한 보증이 없다는 점에서
다른 컨테이너와 다르며, 결코 자동으로 재시작되지 않는다. 그래서
애플리케이션을 만드는데 적합하지 않다. 임시 컨테이너는
일반 컨테이너와 동일한 <code>ContainerSpec</code> 을 사용해서 명시하지만, 많은 필드가
호환되지 않으며 임시 컨테이너에는 허용되지 않는다.</p>
<ul>
<li>임시 컨테이너는 포트를 가지지 않을 수 있으므로, <code>ports</code>,
<code>livenessProbe</code>, <code>readinessProbe</code> 와 같은 필드는 허용되지 않는다.</li>
<li>파드에 할당된 리소스는 변경할 수 없으므로, <code>resources</code> 설정이 허용되지 않는다.</li>
<li>허용되는 필드의 전체 목록은 <a href=/docs/reference/generated/kubernetes-api/v1.23/#ephemeralcontainer-v1-core>임시컨테이너 참조
문서</a>를 본다.</li>
</ul>
<p>임시 컨테이너는 <code>pod.spec</code> 에 직접 추가하는 대신
API에서 특별한 <code>ephemeralcontainers</code> 핸들러를 사용해서 만들어지기 때문에
<code>kubectl edit</code>을 사용해서 임시 컨테이너를 추가할 수 없다.</p>
<p>일반 컨테이너와 마찬가지로, 사용자는 임시 컨테이너를 파드에 추가한
이후에 변경하거나 제거할 수 없다.</p>
<h2 id=임시-컨테이너의-사용>임시 컨테이너의 사용</h2>
<p>임시 컨테이너는 컨테이너가 충돌 되거나 또는 컨테이너 이미지에
디버깅 도구가 포함되지 않은 이유로 <code>kubectl exec</code> 이 불충분할 때
대화형 문제 해결에 유용하다.</p>
<p>특히, <a href=https://github.com/GoogleContainerTools/distroless>distroless 이미지</a>
를 사용하면 공격 표면(attack surface)과 버그 및 취약점의 노출을 줄이는 최소한의
컨테이너 이미지를 배포할 수 있다. distroless 이미지는 셸 또는 어떤 디버깅 도구를
포함하지 않기 때문에, <code>kubectl exec</code> 만으로는 distroless
이미지의 문제 해결이 어렵다.</p>
<p>임시 컨테이너 사용 시 <a href=/docs/tasks/configure-pod-container/share-process-namespace/>프로세스 네임스페이스
공유</a>를
활성화하면 다른 컨테이너 안의 프로세스를 보는 데 도움이 된다.</p>
<h2 id=다음-내용>다음 내용</h2>
<ul>
<li><a href=/ko/docs/tasks/debug-application-cluster/debug-running-pod/#ephemeral-container>임시 컨테이너 디버깅하기</a>에 대해 알아보기.</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-89637410cacae45a36ab1cc278c482eb>4.2 - 워크로드 리소스</h1>
</div>
<div class=td-content>
<h1 id=pg-a2dc0393e0c4079e1c504b6429844e86>4.2.1 - 디플로이먼트</h1>
<p><em>디플로이먼트(Deployment)</em> 는 <a class=glossary-tooltip title="파드는 클러스터에서 실행 중인 컨테이너의 집합을 나타낸다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/pods/ target=_blank aria-label=파드>파드</a>와
<a class=glossary-tooltip title="레플리카셋은 지정된 수의 파드 레플리카가 동시에 실행이 되도록 보장한다" data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/controllers/replicaset/ target=_blank aria-label=레플리카셋(ReplicaSet)>레플리카셋(ReplicaSet)</a>에 대한 선언적 업데이트를 제공한다.</p>
<p>디플로이먼트에서 <em>의도하는 상태</em> 를 설명하고, 디플로이먼트 <a class=glossary-tooltip title="API 서버를 통해 클러스터의 공유된 상태를 감시하고, 현재 상태를 원하는 상태로 이행시키는 컨트롤 루프." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/architecture/controller/ target=_blank aria-label=컨트롤러(Controller)>컨트롤러(Controller)</a>는 현재 상태에서 의도하는 상태로 비율을 조정하며 변경한다. 새 레플리카셋을 생성하는 디플로이먼트를 정의하거나 기존 디플로이먼트를 제거하고, 모든 리소스를 새 디플로이먼트에 적용할 수 있다.</p>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> 디플로이먼트가 소유하는 레플리카셋은 관리하지 말아야 한다. 사용자의 유스케이스가 다음에 포함되지 않는 경우 쿠버네티스 리포지터리에 이슈를 올릴 수 있다.
</div>
<h2 id=유스케이스>유스케이스</h2>
<p>다음은 디플로이먼트의 일반적인 유스케이스이다.</p>
<ul>
<li><a href=#%EB%94%94%ED%94%8C%EB%A1%9C%EC%9D%B4%EB%A8%BC%ED%8A%B8-%EC%83%9D%EC%84%B1>레플리카셋을 롤아웃 할 디플로이먼트 생성</a>. 레플리카셋은 백그라운드에서 파드를 생성한다. 롤아웃 상태를 체크해서 성공 여부를 확인한다.</li>
<li>디플로이먼트의 PodTemplateSpec을 업데이트해서 <a href=#%EB%94%94%ED%94%8C%EB%A1%9C%EC%9D%B4%EB%A8%BC%ED%8A%B8-%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8>파드의 새로운 상태를 선언한다</a>. 새 레플리카셋이 생성되면, 디플로이먼트는 파드를 기존 레플리카셋에서 새로운 레플리카셋으로 속도를 제어하며 이동하는 것을 관리한다. 각각의 새로운 레플리카셋은 디플로이먼트의 수정 버전에 따라 업데이트한다.</li>
<li>만약 디플로이먼트의 현재 상태가 안정적이지 않은 경우 <a href=#%EB%94%94%ED%94%8C%EB%A1%9C%EC%9D%B4%EB%A8%BC%ED%8A%B8-%EB%A1%A4%EB%B0%B1>디플로이먼트의 이전 버전으로 롤백</a>한다. 각 롤백은 디플로이먼트의 수정 버전에 따라 업데이트한다.</li>
<li><a href=#%EB%94%94%ED%94%8C%EB%A1%9C%EC%9D%B4%EB%A8%BC%ED%8A%B8-%EC%8A%A4%EC%BC%80%EC%9D%BC%EB%A7%81>더 많은 로드를 위해 디플로이먼트의 스케일 업</a>.</li>
<li><a href=#%EB%94%94%ED%94%8C%EB%A1%9C%EC%9D%B4%EB%A8%BC%ED%8A%B8%EC%9D%98-%EC%9D%BC%EC%8B%9C-%EC%A4%91%EC%A7%80%EC%99%80-%EC%9E%AC%EA%B0%9C>디플로이먼트 롤아웃 일시 중지</a>로 PodTemplateSpec에 여러 수정 사항을 적용하고, 재개하여 새로운 롤아웃을 시작한다.</li>
<li>롤아웃이 막혀있는지를 나타내는 <a href=#%EB%94%94%ED%94%8C%EB%A1%9C%EC%9D%B4%EB%A8%BC%ED%8A%B8-%EC%83%81%ED%83%9C>디플로이먼트 상태를 이용</a>.</li>
<li>더 이상 필요 없는 <a href=#%EC%A0%95%EC%B1%85-%EC%B4%88%EA%B8%B0%ED%99%94>이전 레플리카셋 정리</a>.</li>
</ul>
<h2 id=디플로이먼트-생성>디플로이먼트 생성</h2>
<p>다음은 디플로이먼트의 예시이다. 예시는 3개의 <code>nginx</code> 파드를 불러오기 위한 레플리카셋을 생성한다.</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/ko/examples/controllers/nginx-deployment.yaml download=controllers/nginx-deployment.yaml><code>controllers/nginx-deployment.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('controllers-nginx-deployment-yaml')" title="Copy controllers/nginx-deployment.yaml to clipboard">
</img>
</div>
<div class=includecode id=controllers-nginx-deployment-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-deployment<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.14.2<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>이 예시에 대한 설명은 다음과 같다.</p>
<ul>
<li>
<p><code>.metadata.name</code> 필드에 따라 <code>nginx-deployment</code> 이름으로 디플로이먼트가 생성된다.</p>
</li>
<li>
<p><code>.spec.replicas</code> 필드에 따라 디플로이먼트는 3개의 레플리카 파드를 생성한다.</p>
</li>
<li>
<p><code>.spec.selector</code> 필드는 디플로이먼트가 관리할 파드를 찾는 방법을 정의한다.
이 사례에서는 파드 템플릿에 정의된 레이블(<code>app: nginx</code>)을 선택한다.
그러나 파드 템플릿 자체의 규칙이 만족되는 한,
보다 정교한 선택 규칙의 적용이 가능하다.</p>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> <code>.spec.selector.matchLabels</code> 필드는 {key,value}의 쌍으로 매핑되어 있다. <code>matchLabels</code> 에 매핑된
단일 {key,value}은 <code>matchExpressions</code> 의 요소에 해당하며, <code>key</code> 필드는 "key"에 그리고 <code>operator</code>는 "In"에 대응되며
<code>value</code> 배열은 "value"만 포함한다.
매칭을 위해서는 <code>matchLabels</code> 와 <code>matchExpressions</code> 의 모든 요건이 충족되어야 한다.
</div>
</li>
<li>
<p><code>template</code> 필드에는 다음 하위 필드가 포함되어 있다.</p>
<ul>
<li>파드는 <code>.metadata.labels</code> 필드를 사용해서 <code>app: nginx</code> 라는 레이블을 붙인다.</li>
<li>파드 템플릿의 사양 또는 <code>.template.spec</code> 필드는
파드가 <a href=https://hub.docker.com/>도커 허브</a>의 <code>nginx</code> 1.14.2 버전 이미지를 실행하는
<code>nginx</code> 컨테이너 1개를 실행하는 것을 나타낸다.</li>
<li>컨테이너 1개를 생성하고, <code>.spec.template.spec.containers[0].name</code> 필드를 사용해서 <code>nginx</code> 이름을 붙인다.</li>
</ul>
</li>
</ul>
<p>시작하기 전에, 쿠버네티스 클러스터가 시작되고 실행 중인지 확인한다.
위의 디플로이먼트를 생성하려면 다음 단계를 따른다.</p>
<ol>
<li>다음 명령어를 실행해서 디플로이먼트를 생성한다.</li>
</ol>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/controllers/nginx-deployment.yaml
</code></pre></div><ol start=2>
<li><code>kubectl get deployments</code> 을 실행해서 디플로이먼트가 생성되었는지 확인한다.</li>
</ol>
<p>만약 디플로이먼트가 여전히 생성 중이면, 다음과 유사하게 출력된다.</p>
<pre><code>NAME               READY   UP-TO-DATE   AVAILABLE   AGE
nginx-deployment   0/3     0            0           1s
</code></pre><p>클러스터에서 디플로이먼트를 점검할 때, 다음 필드가 표시된다.</p>
<ul>
<li><code>NAME</code> 은 네임스페이스에 있는 디플로이먼트 이름의 목록이다.</li>
<li><code>READY</code> 는 사용자가 사용할 수 있는 애플리케이션의 레플리카의 수를 표시한다. ready/desired 패턴을 따른다.</li>
<li><code>UP-TO-DATE</code> 는 의도한 상태를 얻기 위해 업데이트된 레플리카의 수를 표시한다.</li>
<li><code>AVAILABLE</code> 은 사용자가 사용할 수 있는 애플리케이션 레플리카의 수를 표시한다.</li>
<li><code>AGE</code> 는 애플리케이션의 실행된 시간을 표시한다.</li>
</ul>
<p><code>.spec.replicas</code> 필드에 따라 의도한 레플리카의 수가 3개인지 알 수 있다.</p>
<ol start=3>
<li>
<p>디플로이먼트의 롤아웃 상태를 보려면, <code>kubectl rollout status deployment/nginx-deployment</code> 를 실행한다.</p>
<p>다음과 유사하게 출력된다.</p>
<pre><code>Waiting for rollout to finish: 2 out of 3 new replicas have been updated...
deployment &quot;nginx-deployment&quot; successfully rolled out
</code></pre></li>
<li>
<p>몇 초 후 <code>kubectl get deployments</code> 를 다시 실행한다.
다음과 유사하게 출력된다.</p>
<pre><code>NAME               READY   UP-TO-DATE   AVAILABLE   AGE
nginx-deployment   3/3     3            3           18s
</code></pre><p>디플로이먼트에서 3개의 레플리카가 생성되었고, 모든 레플리카는 최신 상태(최신 파드 템플릿을 포함)이며 사용 가능한 것을 알 수 있다.</p>
</li>
<li>
<p>디플로이먼트로 생성된 레플리카셋(<code>rs</code>)을 보려면, <code>kubectl get rs</code> 를 실행한다. 다음과 유사하게 출력된다.</p>
<pre><code>NAME                          DESIRED   CURRENT   READY   AGE
nginx-deployment-75675f5897   3         3         3       18s
</code></pre><p>레플리카셋의 출력에는 다음 필드가 표시된다.</p>
<ul>
<li><code>NAME</code> 은 네임스페이스에 있는 레플리카셋 이름의 목록이다.</li>
<li><code>DESIRED</code> 는 디플로이먼트의 생성 시 정의된 의도한 애플리케이션 <em>레플리카</em> 의 수를 표시한다. 이것이 <em>의도한 상태</em> 이다.</li>
<li><code>CURRENT</code> 는 현재 실행 중인 레플리카의 수를 표시한다.</li>
<li><code>READY</code> 는 사용자가 사용할 수 있는 애플리케이션의 레플리카의 수를 표시한다.</li>
<li><code>AGE</code> 는 애플리케이션의 실행된 시간을 표시한다.</li>
</ul>
<p>레플리카셋의 이름은 항상 <code>[DEPLOYMENT-NAME]-[RANDOM-STRING]</code> 형식으로 된 것을 알 수 있다. 무작위 문자열은
무작위로 생성되며, <code>pod-template-hash</code> 를 시드(seed)로 사용한다.</p>
</li>
<li>
<p>각 파드에 자동으로 생성된 레이블을 보려면, <code>kubectl get pods --show-labels</code> 를 실행한다.
다음과 유사하게 출력된다.</p>
<pre><code>NAME                                READY     STATUS    RESTARTS   AGE       LABELS
nginx-deployment-75675f5897-7ci7o   1/1       Running   0          18s       app=nginx,pod-template-hash=3123191453
nginx-deployment-75675f5897-kzszj   1/1       Running   0          18s       app=nginx,pod-template-hash=3123191453
nginx-deployment-75675f5897-qqcnn   1/1       Running   0          18s       app=nginx,pod-template-hash=3123191453
</code></pre><p>만들어진 레플리카셋은 실행 중인 3개의 <code>nginx</code> 파드를 보장한다.</p>
</li>
</ol>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> <p>디플로이먼트에는 파드 템플릿 레이블과 적절한 셀렉터를 반드시 명시해야 한다
(이 예시에서는 <code>app: nginx</code>).</p>
<p>레이블 또는 셀렉터는 다른 컨트롤러(다른 디플로이먼트와 스테이트풀셋(StatefulSet) 포함)와 겹치지 않아야 한다. 쿠버네티스는 겹치는 것을 막지 않으며, 만약 다중 컨트롤러가 겹치는 셀렉터를 가지는 경우 해당 컨트롤러의 충돌 또는 예기치 않은 동작을 야기할 수 있다.</p>
</div>
<h3 id=pod-template-hash-레이블>Pod-template-hash 레이블</h3>
<div class="alert alert-warning caution callout" role=alert>
<strong>주의:</strong> 이 레이블은 변경하면 안 된다.
</div>
<p><code>pod-template-hash</code> 레이블은 디플로이먼트 컨트롤러에 의해서 디플로이먼트가 생성 또는 채택한 모든 레플리카셋에 추가된다.</p>
<p>이 레이블은 디플로이먼트의 자식 레플리카셋이 겹치지 않도록 보장한다. 레플리카셋의 <code>PodTemplate</code> 을 해싱하고, 해시 결과를 레플리카셋 셀렉터,
파드 템플릿 레이블 및 레플리카셋 이 가질 수 있는 기존의 모든 파드에 레이블 값으로 추가해서 사용하도록 생성한다.</p>
<h2 id=디플로이먼트-업데이트>디플로이먼트 업데이트</h2>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> 디플로이먼트의 파드 템플릿(즉, <code>.spec.template</code>)이 변경된 경우에만 디플로이먼트의 롤아웃이 트리거(trigger) 된다.
예를 들면 템플릿의 레이블이나 컨테이너 이미지가 업데이트된 경우이다. 디플로이먼트의 스케일링과 같은 다른 업데이트는 롤아웃을 트리거하지 말아야 한다.
</div>
<p>다음 단계에 따라 디플로이먼트를 업데이트한다.</p>
<ol>
<li>
<p><code>nginx:1.14.2</code> 이미지 대신 <code>nginx:1.16.1</code> 이미지를 사용하도록 nginx 파드를 업데이트 한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#a2f>set</span> image deployment.v1.apps/nginx-deployment <span style=color:#b8860b>nginx</span><span style=color:#666>=</span>nginx:1.16.1
</code></pre></div><p>또는 다음의 명령어를 사용한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#a2f>set</span> image deployment/nginx-deployment <span style=color:#b8860b>nginx</span><span style=color:#666>=</span>nginx:1.16.1
</code></pre></div><p>다음과 유사하게 출력된다.</p>
<pre><code>deployment.apps/nginx-deployment image updated
</code></pre><p>대안으로 디플로이먼트를 <code>edit</code> 해서 <code>.spec.template.spec.containers[0].image</code> 를 <code>nginx:1.14.2</code> 에서 <code>nginx:1.16.1</code> 로 변경한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl edit deployment/nginx-deployment
</code></pre></div><p>다음과 유사하게 출력된다.</p>
<pre><code>deployment.apps/nginx-deployment edited
</code></pre></li>
<li>
<p>롤아웃 상태를 보려면 다음을 실행한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl rollout status deployment/nginx-deployment
</code></pre></div><p>이와 유사하게 출력된다.</p>
<pre><code>Waiting for rollout to finish: 2 out of 3 new replicas have been updated...
</code></pre><p>또는</p>
<pre><code>deployment &quot;nginx-deployment&quot; successfully rolled out
</code></pre></li>
</ol>
<p>업데이트된 디플로이먼트에 대해 자세한 정보 보기</p>
<ul>
<li>
<p>롤아웃이 성공하면 <code>kubectl get deployments</code> 를 실행해서 디플로이먼트를 볼 수 있다.
이와 유사하게 출력된다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ini data-lang=ini><span style=color:#b44>NAME               READY   UP-TO-DATE   AVAILABLE   AGE</span>
<span style=color:#b44>nginx-deployment   3/3     3            3           36s</span>
</code></pre></div></li>
<li>
<p><code>kubectl get rs</code> 를 실행해서 디플로이먼트가 새 레플리카셋을 생성해서 파드를 업데이트 했는지 볼 수 있고,
새 레플리카셋을 최대 3개의 레플리카로 스케일 업, 이전 레플리카셋을 0개의 레플리카로 스케일 다운한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get rs
</code></pre></div><p>이와 유사하게 출력된다.</p>
<pre><code>NAME                          DESIRED   CURRENT   READY   AGE
nginx-deployment-1564180365   3         3         3       6s
nginx-deployment-2035384211   0         0         0       36s
</code></pre></li>
<li>
<p><code>get pods</code> 를 실행하면 새 파드만 표시된다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods
</code></pre></div><p>이와 유사하게 출력된다.</p>
<pre><code>NAME                                READY     STATUS    RESTARTS   AGE
nginx-deployment-1564180365-khku8   1/1       Running   0          14s
nginx-deployment-1564180365-nacti   1/1       Running   0          14s
nginx-deployment-1564180365-z9gth   1/1       Running   0          14s
</code></pre><p>다음에 이러한 파드를 업데이트 하려면 디플로이먼트의 파드 템플릿만 다시 업데이트 하면 된다.</p>
<p>디플로이먼트는 업데이트되는 동안 일정한 수의 파드만 중단되도록 보장한다. 기본적으로
적어도 의도한 파드 수의 75% 이상이 동작하도록 보장한다(최대 25% 불가).</p>
<p>또한 디플로이먼트는 의도한 파드 수 보다 더 많이 생성되는 파드의 수를 제한한다.
기본적으로, 의도한 파드의 수 기준 최대 125%까지만 추가 파드가 동작할 수 있도록 제한한다(최대 25% 까지).</p>
<p>예를 들어, 위 디플로이먼트를 자세히 살펴보면 먼저 새로운 파드를 생성한 다음
이전 파드를 삭제하고, 새로운 파드를 만든 것을 볼 수 있다. 충분한 수의 새로운 파드가 나올 때까지 이전 파드를 죽이지 않으며,
충분한 수의 이전 파드들이 죽기 전까지 새로운 파드를 만들지 않는다.
이것은 최소 2개의 파드를 사용할 수 있게 하고, 최대 4개의 파드를 사용할 수 있게 한다.</p>
</li>
<li>
<p>디플로이먼트의 세부 정보 가져오기</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe deployments
</code></pre></div><p>이와 유사하게 출력된다.</p>
<pre><code>Name:                   nginx-deployment
Namespace:              default
CreationTimestamp:      Thu, 30 Nov 2017 10:56:25 +0000
Labels:                 app=nginx
Annotations:            deployment.kubernetes.io/revision=2
Selector:               app=nginx
Replicas:               3 desired | 3 updated | 3 total | 3 available | 0 unavailable
StrategyType:           RollingUpdate
MinReadySeconds:        0
RollingUpdateStrategy:  25% max unavailable, 25% max surge
Pod Template:
  Labels:  app=nginx
   Containers:
    nginx:
      Image:        nginx:1.16.1
      Port:         80/TCP
      Environment:  &lt;none&gt;
      Mounts:       &lt;none&gt;
    Volumes:        &lt;none&gt;
  Conditions:
    Type           Status  Reason
    ----           ------  ------
    Available      True    MinimumReplicasAvailable
    Progressing    True    NewReplicaSetAvailable
  OldReplicaSets:  &lt;none&gt;
  NewReplicaSet:   nginx-deployment-1564180365 (3/3 replicas created)
  Events:
    Type    Reason             Age   From                   Message
    ----    ------             ----  ----                   -------
    Normal  ScalingReplicaSet  2m    deployment-controller  Scaled up replica set nginx-deployment-2035384211 to 3
    Normal  ScalingReplicaSet  24s   deployment-controller  Scaled up replica set nginx-deployment-1564180365 to 1
    Normal  ScalingReplicaSet  22s   deployment-controller  Scaled down replica set nginx-deployment-2035384211 to 2
    Normal  ScalingReplicaSet  22s   deployment-controller  Scaled up replica set nginx-deployment-1564180365 to 2
    Normal  ScalingReplicaSet  19s   deployment-controller  Scaled down replica set nginx-deployment-2035384211 to 1
    Normal  ScalingReplicaSet  19s   deployment-controller  Scaled up replica set nginx-deployment-1564180365 to 3
    Normal  ScalingReplicaSet  14s   deployment-controller  Scaled down replica set nginx-deployment-2035384211 to 0
</code></pre><p>처음 디플로이먼트를 생성했을 때, 디플로이먼트가 레플리카셋(nginx-deployment-2035384211)을 생성해서
3개의 레플리카로 직접 스케일 업한 것을 볼 수 있다.
디플로이먼트를 업데이트할 때 새 레플리카셋(nginx-deployment-1564180365)을 생성하고, 1개로 스케일 업한 다음
이전 레플리카셋을 2개로 스케일 다운해서, 최소 2개의 파드를 사용할 수 있고 최대 4개의 파드가 항상 생성되어 있도록 하였다.
이후 지속해서 같은 롤링 업데이트 정책으로 새 레플리카셋은 스케일 업하고 이전 레플리카셋은 스케일 다운한다.
마지막으로 새로운 레플리카셋에 3개의 사용 가능한 레플리카가 구성되며, 이전 레플리카셋은 0개로 스케일 다운된다.</p>
</li>
</ul>
<h3 id=롤오버-일명-인-플라이트-다중-업데이트>롤오버(일명 인-플라이트 다중 업데이트)</h3>
<p>디플로이먼트 컨트롤러는 각 시간마다 새로운 디플로이먼트에서 레플리카셋이
의도한 파드를 생성하고 띄우는 것을 주시한다. 만약 디플로이먼트가 업데이트되면, 기존 레플리카셋에서
<code>.spec.selector</code> 레이블과 일치하는 파드를 컨트롤 하지만, 템플릿과 <code>.spec.template</code> 이 불일치하면 스케일 다운이 된다.
결국 새로운 레플리카셋은 <code>.spec.replicas</code> 로 스케일되고, 모든 기존 레플리카셋은 0개로 스케일된다.</p>
<p>만약 기존 롤아웃이 진행되는 중에 디플로이먼트를 업데이트하는 경우 디플로이먼트가 업데이트에 따라 새 레플리카셋을 생성하고,
스케일 업하기 시작한다. 그리고 이전에 스케일 업 하던 레플리카셋에 롤오버 한다.
--이것은 기존 레플리카셋 목록에 추가하고 스케일 다운을 할 것이다.</p>
<p>예를 들어 디플로이먼트로 <code>nginx:1.14.2</code> 레플리카를 5개 생성을 한다.
하지만 <code>nginx:1.14.2</code> 레플리카 3개가 생성되었을 때 디플로이먼트를 업데이트해서 <code>nginx:1.16.1</code>
레플리카 5개를 생성성하도록 업데이트를 한다고 가정한다. 이 경우 디플로이먼트는 즉시 생성된 3개의
<code>nginx:1.14.2</code> 파드 3개를 죽이기 시작하고 <code>nginx:1.16.1</code> 파드를 생성하기 시작한다.
이것은 과정이 변경되기 전 <code>nginx:1.14.2</code> 레플리카 5개가
생성되는 것을 기다리지 않는다.</p>
<h3 id=레이블-셀렉터-업데이트>레이블 셀렉터 업데이트</h3>
<p>일반적으로 레이블 셀렉터를 업데이트 하는 것을 권장하지 않으며 셀렉터를 미리 계획하는 것을 권장한다.
어떤 경우든 레이블 셀렉터의 업데이트를 해야하는 경우 매우 주의하고,
모든 영향을 파악했는지 확인해야 한다.</p>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> API 버전 <code>apps/v1</code> 에서 디플로이먼트의 레이블 셀렉터는 생성 이후에는 변경할 수 없다.
</div>
<ul>
<li>셀렉터 추가 시 디플로이먼트의 사양에 있는 파드 템플릿 레이블도 새 레이블로 업데이트해야 한다.
그렇지 않으면 유효성 검사 오류가 반환된다. 이 변경은 겹치지 않는 변경으로 새 셀렉터가
이전 셀렉터로 만든 레플리카셋과 파드를 선택하지 않게 되고, 그 결과로 모든 기존 레플리카셋은 고아가 되며,
새로운 레플리카셋을 생성하게 된다.</li>
<li>셀렉터 업데이트는 기존 셀렉터 키 값을 변경하며, 결과적으로 추가와 동일한 동작을 한다.</li>
<li>셀렉터 삭제는 디플로이먼트 셀렉터의 기존 키를 삭제하며 파드 템플릿 레이블의 변경을 필요로 하지 않는다.
기존 레플리카셋은 고아가 아니고, 새 레플리카셋은 생성되지 않는다.
그러나 제거된 레이블은 기존 파드와 레플리카셋에 여전히 존재한다는 점을 참고해야 한다.</li>
</ul>
<h2 id=디플로이먼트-롤백>디플로이먼트 롤백</h2>
<p>때때로 디플로이먼트의 롤백을 원할 수도 있다. 예를 들어 디플로이먼트가 지속적인 충돌로 안정적이지 않은 경우.
기본적으로 모든 디플로이먼트의 롤아웃 기록은 시스템에 남아있어 언제든지 원할 때 롤백이 가능하다
(이 사항은 수정 기록에 대한 상한 수정을 통해서 변경할 수 있다).</p>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> 디플로이먼트의 수정 버전은 디플로이먼트 롤아웃시 생성된다. 이는 디플로이먼트 파드 템플릿
(<code>.spec.template</code>)이 변경되는 경우에만 새로운 수정 버전이 생성된다는 것을 의미한다.
예를 들어 템플릿의 레이블 또는 컨테이너 이미지를 업데이트 하는 경우.
디플로이먼트의 스케일링과 같은 다른 업데이트시 디플로이먼트 수정 버전은 생성되지 않으며 수동-스케일링 또는 자동-스케일링을 동시에 수행할 수 있다.
이는 이전 수정 버전으로 롤백을 하는 경우에 디플로이먼트 파드 템플릿 부분만
롤백된다는 것을 의미한다.
</div>
<ul>
<li>
<p>디플로이먼트를 업데이트하는 동안 이미지 이름을 <code>nginx:1.16.1</code> 이 아닌 <code>nginx:1.161</code> 로 입력해서 오타를 냈다고 가정한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#a2f>set</span> image deployment/nginx-deployment <span style=color:#b8860b>nginx</span><span style=color:#666>=</span>nginx:1.161 
</code></pre></div><p>이와 유사하게 출력된다.</p>
<pre><code>deployment.apps/nginx-deployment image updated
</code></pre></li>
<li>
<p>롤아웃이 고착 된다. 고착된 롤아웃 상태를 확인할 수 있다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl rollout status deployment/nginx-deployment
</code></pre></div><p>이와 유사하게 출력된다.</p>
<pre><code>Waiting for rollout to finish: 1 out of 3 new replicas have been updated...
</code></pre></li>
<li>
<p>Ctrl-C 를 눌러 위의 롤아웃 상태 보기를 중지한다. 고착된 롤아웃 상태에 대한 자세한 정보는 <a href=#%EB%94%94%ED%94%8C%EB%A1%9C%EC%9D%B4%EB%A8%BC%ED%8A%B8-%EC%83%81%ED%83%9C>이 것을 더 읽어본다</a>.</p>
</li>
<li>
<p>이전 레플리카는 2개(<code>nginx-deployment-1564180365</code> 과 <code>nginx-deployment-2035384211</code>), 새 레플리카는 1개(nginx-deployment-3066724191)임을 알 수 있다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get rs
</code></pre></div><p>이와 유사하게 출력된다.</p>
<pre><code>NAME                          DESIRED   CURRENT   READY   AGE
nginx-deployment-1564180365   3         3         3       25s
nginx-deployment-2035384211   0         0         0       36s
nginx-deployment-3066724191   1         1         0       6s
</code></pre></li>
<li>
<p>생성된 파드를 보면, 새로운 레플리카셋에 생성된 1개의 파드가 이미지 풀 루프(pull loop)에서 고착된 것을 볼 수 있다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods
</code></pre></div><p>이와 유사하게 출력된다.</p>
<pre><code>NAME                                READY     STATUS             RESTARTS   AGE
nginx-deployment-1564180365-70iae   1/1       Running            0          25s
nginx-deployment-1564180365-jbqqo   1/1       Running            0          25s
nginx-deployment-1564180365-hysrc   1/1       Running            0          25s
nginx-deployment-3066724191-08mng   0/1       ImagePullBackOff   0          6s
</code></pre><div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> 디플로이먼트 컨트롤러가 잘못된 롤아웃을 자동으로 중지하고, 새로운 레플리카셋의 스케일 업을 중지한다. 이는 지정한 롤링 업데이트의 파라미터(구체적으로 <code>maxUnavailable</code>)에 따라 달라진다. 쿠버네티스는 기본값으로 25%를 설정한다.
</div>
</li>
<li>
<p>디플로이먼트에 대한 설명 보기</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe deployment
</code></pre></div><p>이와 유사하게 출력된다.</p>
<pre><code>Name:           nginx-deployment
Namespace:      default
CreationTimestamp:  Tue, 15 Mar 2016 14:48:04 -0700
Labels:         app=nginx
Selector:       app=nginx
Replicas:       3 desired | 1 updated | 4 total | 3 available | 1 unavailable
StrategyType:       RollingUpdate
MinReadySeconds:    0
RollingUpdateStrategy:  25% max unavailable, 25% max surge
Pod Template:
  Labels:  app=nginx
  Containers:
   nginx:
    Image:        nginx:1.161
    Port:         80/TCP
    Host Port:    0/TCP
    Environment:  &lt;none&gt;
    Mounts:       &lt;none&gt;
  Volumes:        &lt;none&gt;
Conditions:
  Type           Status  Reason
  ----           ------  ------
  Available      True    MinimumReplicasAvailable
  Progressing    True    ReplicaSetUpdated
OldReplicaSets:     nginx-deployment-1564180365 (3/3 replicas created)
NewReplicaSet:      nginx-deployment-3066724191 (1/1 replicas created)
Events:
  FirstSeen LastSeen    Count   From                    SubObjectPath   Type        Reason              Message
  --------- --------    -----   ----                    -------------   --------    ------              -------
  1m        1m          1       {deployment-controller }                Normal      ScalingReplicaSet   Scaled up replica set nginx-deployment-2035384211 to 3
  22s       22s         1       {deployment-controller }                Normal      ScalingReplicaSet   Scaled up replica set nginx-deployment-1564180365 to 1
  22s       22s         1       {deployment-controller }                Normal      ScalingReplicaSet   Scaled down replica set nginx-deployment-2035384211 to 2
  22s       22s         1       {deployment-controller }                Normal      ScalingReplicaSet   Scaled up replica set nginx-deployment-1564180365 to 2
  21s       21s         1       {deployment-controller }                Normal      ScalingReplicaSet   Scaled down replica set nginx-deployment-2035384211 to 1
  21s       21s         1       {deployment-controller }                Normal      ScalingReplicaSet   Scaled up replica set nginx-deployment-1564180365 to 3
  13s       13s         1       {deployment-controller }                Normal      ScalingReplicaSet   Scaled down replica set nginx-deployment-2035384211 to 0
  13s       13s         1       {deployment-controller }                Normal      ScalingReplicaSet   Scaled up replica set nginx-deployment-3066724191 to 1
</code></pre><p>이 문제를 해결하려면 디플로이먼트를 안정적인 이전 수정 버전으로 롤백해야 한다.</p>
</li>
</ul>
<h3 id=디플로이먼트의-롤아웃-기록-확인>디플로이먼트의 롤아웃 기록 확인</h3>
<p>다음 순서에 따라 롤아웃 기록을 확인한다.</p>
<ol>
<li>
<p>먼저 이 디플로이먼트의 수정 사항을 확인한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl rollout <span style=color:#a2f>history</span> deployment/nginx-deployment
</code></pre></div><p>이와 유사하게 출력된다.</p>
<pre><code>deployments &quot;nginx-deployment&quot;
REVISION    CHANGE-CAUSE
1           kubectl apply --filename=https://k8s.io/examples/controllers/nginx-deployment.yaml
2           kubectl set image deployment/nginx-deployment nginx=nginx:1.16.1
3           kubectl set image deployment/nginx-deployment nginx=nginx:1.161
</code></pre><p><code>CHANGE-CAUSE</code> 는 수정 생성시 디플로이먼트 주석인 <code>kubernetes.io/change-cause</code> 에서 복사한다. 다음에 대해 <code>CHANGE-CAUSE</code> 메시지를 지정할 수 있다.</p>
<ul>
<li>디플로이먼트에 <code>kubectl annotate deployment/nginx-deployment kubernetes.io/change-cause="image updated to 1.16.1"</code> 로 주석을 단다.</li>
<li>수동으로 리소스 매니페스트 편집.</li>
</ul>
</li>
<li>
<p>각 수정 버전의 세부 정보를 보려면 다음을 실행한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl rollout <span style=color:#a2f>history</span> deployment/nginx-deployment --revision<span style=color:#666>=</span><span style=color:#666>2</span>
</code></pre></div><p>이와 유사하게 출력된다.</p>
<pre><code>deployments &quot;nginx-deployment&quot; revision 2
  Labels:       app=nginx
          pod-template-hash=1159050644
  Annotations:  kubernetes.io/change-cause=kubectl set image deployment/nginx-deployment nginx=nginx:1.16.1
  Containers:
   nginx:
    Image:      nginx:1.16.1
    Port:       80/TCP
     QoS Tier:
        cpu:      BestEffort
        memory:   BestEffort
    Environment Variables:      &lt;none&gt;
  No volumes.
</code></pre></li>
</ol>
<h3 id=이전-수정-버전으로-롤백>이전 수정 버전으로 롤백</h3>
<p>다음 단계에 따라 디플로이먼트를 현재 버전에서 이전 버전인 버전 2로 롤백한다.</p>
<ol>
<li>
<p>이제 현재 롤아웃의 실행 취소 및 이전 수정 버전으로 롤백 하기로 결정했다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl rollout undo deployment/nginx-deployment
</code></pre></div><p>이와 유사하게 출력된다.</p>
<pre><code>deployment.apps/nginx-deployment rolled back
</code></pre><p>Alternatively, you can rollback to a specific revision by specifying it with <code>--to-revision</code>:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl rollout undo deployment/nginx-deployment --to-revision<span style=color:#666>=</span><span style=color:#666>2</span>
</code></pre></div><p>이와 유사하게 출력된다.</p>
<pre><code>deployment.apps/nginx-deployment rolled back
</code></pre><p>롤아웃 관련 명령에 대한 자세한 내용은 <a href=/docs/reference/generated/kubectl/kubectl-commands#rollout><code>kubectl rollout</code></a>을 참조한다.</p>
<p>이제 디플로이먼트가 이전 안정 수정 버전으로 롤백 된다. 버전 2로 롤백하기 위해 <code>DeploymentRollback</code> 이벤트가
디플로이먼트 컨트롤러에서 생성되는 것을 볼 수 있다.</p>
</li>
<li>
<p>만약 롤백에 성공하고, 디플로이먼트가 예상대로 실행되는지 확인하려면 다음을 실행한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get deployment nginx-deployment
</code></pre></div><p>이와 유사하게 출력된다.</p>
<pre><code>NAME               READY   UP-TO-DATE   AVAILABLE   AGE
nginx-deployment   3/3     3            3           30m
</code></pre></li>
<li>
<p>디플로이먼트의 설명 가져오기.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe deployment nginx-deployment
</code></pre></div><p>이와 유사하게 출력된다.</p>
<pre><code>Name:                   nginx-deployment
Namespace:              default
CreationTimestamp:      Sun, 02 Sep 2018 18:17:55 -0500
Labels:                 app=nginx
Annotations:            deployment.kubernetes.io/revision=4
                        kubernetes.io/change-cause=kubectl set image deployment/nginx-deployment nginx=nginx:1.16.1
Selector:               app=nginx
Replicas:               3 desired | 3 updated | 3 total | 3 available | 0 unavailable
StrategyType:           RollingUpdate
MinReadySeconds:        0
RollingUpdateStrategy:  25% max unavailable, 25% max surge
Pod Template:
  Labels:  app=nginx
  Containers:
   nginx:
    Image:        nginx:1.16.1
    Port:         80/TCP
    Host Port:    0/TCP
    Environment:  &lt;none&gt;
    Mounts:       &lt;none&gt;
  Volumes:        &lt;none&gt;
Conditions:
  Type           Status  Reason
  ----           ------  ------
  Available      True    MinimumReplicasAvailable
  Progressing    True    NewReplicaSetAvailable
OldReplicaSets:  &lt;none&gt;
NewReplicaSet:   nginx-deployment-c4747d96c (3/3 replicas created)
Events:
  Type    Reason              Age   From                   Message
  ----    ------              ----  ----                   -------
  Normal  ScalingReplicaSet   12m   deployment-controller  Scaled up replica set nginx-deployment-75675f5897 to 3
  Normal  ScalingReplicaSet   11m   deployment-controller  Scaled up replica set nginx-deployment-c4747d96c to 1
  Normal  ScalingReplicaSet   11m   deployment-controller  Scaled down replica set nginx-deployment-75675f5897 to 2
  Normal  ScalingReplicaSet   11m   deployment-controller  Scaled up replica set nginx-deployment-c4747d96c to 2
  Normal  ScalingReplicaSet   11m   deployment-controller  Scaled down replica set nginx-deployment-75675f5897 to 1
  Normal  ScalingReplicaSet   11m   deployment-controller  Scaled up replica set nginx-deployment-c4747d96c to 3
  Normal  ScalingReplicaSet   11m   deployment-controller  Scaled down replica set nginx-deployment-75675f5897 to 0
  Normal  ScalingReplicaSet   11m   deployment-controller  Scaled up replica set nginx-deployment-595696685f to 1
  Normal  DeploymentRollback  15s   deployment-controller  Rolled back deployment &quot;nginx-deployment&quot; to revision 2
  Normal  ScalingReplicaSet   15s   deployment-controller  Scaled down replica set nginx-deployment-595696685f to 0
</code></pre></li>
</ol>
<h2 id=디플로이먼트-스케일링>디플로이먼트 스케일링</h2>
<p>다음 명령어를 사용해서 디플로이먼트의 스케일을 할 수 있다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl scale deployment/nginx-deployment --replicas<span style=color:#666>=</span><span style=color:#666>10</span>
</code></pre></div><p>이와 유사하게 출력된다.</p>
<pre><code>deployment.apps/nginx-deployment scaled
</code></pre><p>가령 클러스터에서 <a href=/ko/docs/tasks/run-application/horizontal-pod-autoscale-walkthrough/>horizontal Pod autoscaling</a>를 설정
한 경우 디플로이먼트에 대한 오토스케일러를 설정할 수 있다. 그리고 기존 파드의 CPU 사용률을 기준으로
실행할 최소 파드 및 최대 파드의 수를 선택할 수 있다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl autoscale deployment/nginx-deployment --min<span style=color:#666>=</span><span style=color:#666>10</span> --max<span style=color:#666>=</span><span style=color:#666>15</span> --cpu-percent<span style=color:#666>=</span><span style=color:#666>80</span>
</code></pre></div><p>이와 유사하게 출력된다.</p>
<pre><code>deployment.apps/nginx-deployment scaled
</code></pre><h3 id=비례적-스케일링-proportional-scaling>비례적 스케일링(Proportional Scaling)</h3>
<p>디플로이먼트 롤링업데이트는 여러 버전의 애플리케이션을 동시에 실행할 수 있도록 지원한다.
사용자 또는 오토스케일러가 롤아웃 중에 있는 디플로이먼트 롤링 업데이트를 스케일링 하는 경우(진행중 또는 일시 중지 중),
디플로이먼트 컨트롤러는 위험을 줄이기 위해 기존 활성화된 레플리카셋(파드와 레플리카셋)의 추가 레플리카의 균형을 조절 한다.
이것을 <em>proportional scaling</em> 라 부른다.</p>
<p>예를 들어, 10개의 레플리카를 디플로이먼트로 <a href=#%EC%B5%9C%EB%8C%80-%EC%84%9C%EC%A7%80-max-surge>maxSurge</a>=3, 그리고 <a href=#%EC%B5%9C%EB%8C%80-%EB%B6%88%EA%B0%80-max-unavailable>maxUnavailable</a>=2 로 실행 한다.</p>
<ul>
<li>
<p>디플로이먼트에 있는 10개의 레플리카가 실행되는지 확인한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get deploy
</code></pre></div><p>이와 유사하게 출력된다.</p>
<pre><code>NAME                 DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
nginx-deployment     10        10        10           10          50s
</code></pre></li>
<li>
<p>클러스터 내부에서 확인할 수 없는 새 이미지로 업데이트 된다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#a2f>set</span> image deployment/nginx-deployment <span style=color:#b8860b>nginx</span><span style=color:#666>=</span>nginx:sometag
</code></pre></div><p>이와 유사하게 출력된다.</p>
<pre><code>deployment.apps/nginx-deployment image updated
</code></pre></li>
<li>
<p>이미지 업데이트는 레플리카셋 nginx-deployment-1989198191 으로 새로운 롤 아웃이 시작하지만,
위에서 언급한 <code>maxUnavailable</code> 의 요구 사항으로 인해 차단된다. 롤아웃 상태를 확인한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get rs
</code></pre></div><pre><code>이와 유사하게 출력된다.
</code></pre>
<pre><code>NAME                          DESIRED   CURRENT   READY     AGE
nginx-deployment-1989198191   5         5         0         9s
nginx-deployment-618515232    8         8         8         1m
</code></pre></li>
<li>
<p>그 다음 디플로이먼트에 대한 새로운 스케일링 요청이 함께 따라온다. 오토스케일러는 디플로이먼트 레플리카를 15로 증가시킨다.
디플로이먼트 컨트롤러는 새로운 5개의 레플리카의 추가를 위한 위치를 결정해야 한다.
만약 비례적 스케일링을 사용하지 않으면 5개 모두 새 레플리카셋에 추가된다.
비례적 스케일링으로 추가 레플리카를 모든 레플리카셋에 걸쳐 분산할 수 있다.
비율이 높을수록 가장 많은 레플리카가 있는 레플리카셋으로 이동하고, 비율이 낮을 수록 적은 레플리카가 있는 레플리카셋으로 이동한다.
남은 것들은 대부분의 레플리카가 있는 레플리카셋에 추가된다. 0개의 레플리카가 있는 레플리카셋은 스케일 업 되지 않는다.</p>
</li>
</ul>
<p>위의 예시에서 기존 레플리카셋에 3개의 레플리카가 추가되고, 2개의 레플리카는 새 레플리카에 추가된다.
결국 롤아웃 프로세스는 새 레플리카가 정상이라고 가정하면 모든 레플리카를 새 레플리카셋으로 이동시킨다.
이를 확인하려면 다음을 실행한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get deploy
</code></pre></div><p>이와 유사하게 출력된다.</p>
<pre><code>NAME                 DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
nginx-deployment     15        18        7            8           7m
</code></pre><p>롤아웃 상태는 레플리카가 각 레플리카셋에 어떻게 추가되었는지 확인한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get rs
</code></pre></div><p>이와 유사하게 출력된다.</p>
<pre><code>NAME                          DESIRED   CURRENT   READY     AGE
nginx-deployment-1989198191   7         7         0         7m
nginx-deployment-618515232    11        11        11        7m
</code></pre><h2 id=pausing-and-resuming-a-deployment>디플로이먼트 롤아웃 일시 중지와 재개</h2>
<p>디플로이먼트를 업데이트할 때 (또는 계획할 때),
하나 이상의 업데이트를 트리거하기 전에 해당 디플로이먼트에 대한 롤아웃을 일시 중지할 수 있다.
변경 사항을 적용할 준비가 되면, 디플로이먼트 롤아웃을 재개한다.
이러한 방법으로, 불필요한 롤아웃을 트리거하지 않고
롤아웃 일시 중지와 재개 사이에 여러 수정 사항을 적용할 수 있다.</p>
<ul>
<li>
<p>예를 들어, 생성된 디플로이먼트의 경우</p>
<p>디플로이먼트 상세 정보를 가져온다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get deploy
</code></pre></div><p>이와 유사하게 출력된다.</p>
<pre><code>NAME      DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
nginx     3         3         3            3           1m
</code></pre><p>롤아웃 상태를 가져온다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get rs
</code></pre></div><p>이와 유사하게 출력된다.</p>
<pre><code>NAME               DESIRED   CURRENT   READY     AGE
nginx-2142116321   3         3         3         1m
</code></pre></li>
<li>
<p>다음 명령을 사용해서 일시 중지한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl rollout pause deployment/nginx-deployment
</code></pre></div><p>이와 유사하게 출력된다.</p>
<pre><code>deployment.apps/nginx-deployment paused
</code></pre></li>
<li>
<p>그런 다음 디플로이먼트의 이미지를 업데이트 한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#a2f>set</span> image deployment/nginx-deployment <span style=color:#b8860b>nginx</span><span style=color:#666>=</span>nginx:1.16.1
</code></pre></div><p>이와 유사하게 출력된다.</p>
<pre><code>deployment.apps/nginx-deployment image updated
</code></pre></li>
<li>
<p>새로운 롤아웃이 시작되지 않는다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl rollout <span style=color:#a2f>history</span> deployment/nginx-deployment
</code></pre></div><p>이와 유사하게 출력된다.</p>
<pre><code>deployments &quot;nginx&quot;
REVISION  CHANGE-CAUSE
1   &lt;none&gt;
</code></pre></li>
<li>
<p>기존 레플리카셋이 변경되지 않았는지 확인하기 위해 롤아웃 상태를 출력한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get rs
</code></pre></div><p>이와 유사하게 출력된다.</p>
<pre><code>NAME               DESIRED   CURRENT   READY     AGE
nginx-2142116321   3         3         3         2m
</code></pre></li>
<li>
<p>예를 들어 사용할 리소스를 업데이트하는 것처럼 원하는 만큼 업데이트할 수 있다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#a2f>set</span> resources deployment/nginx-deployment -c<span style=color:#666>=</span>nginx --limits<span style=color:#666>=</span><span style=color:#b8860b>cpu</span><span style=color:#666>=</span>200m,memory<span style=color:#666>=</span>512Mi
</code></pre></div><p>이와 유사하게 출력된다.</p>
<pre><code>deployment.apps/nginx-deployment resource requirements updated
</code></pre><p>디플로이먼트 롤아웃을 일시 중지하기 전 디플로이먼트의 초기 상태는 해당 기능을 지속한다.
그러나 디플로이먼트 롤아웃이 일시 중지한 상태에서는 디플로이먼트의 새 업데이트에 영향을 주지 않는다.</p>
</li>
<li>
<p>결국, 디플로이먼트 롤아웃을 재개하고 새로운 레플리카셋이 새로운 업데이트를 제공하는 것을 관찰한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl rollout resume deployment/nginx-deployment
</code></pre></div><p>이와 유사하게 출력된다.</p>
<pre><code>deployment.apps/nginx-deployment resumed
</code></pre></li>
<li>
<p>롤아웃이 완료될 때까지 상태를 관찰한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get rs -w
</code></pre></div><p>이와 유사하게 출력된다.</p>
<pre><code>NAME               DESIRED   CURRENT   READY     AGE
nginx-2142116321   2         2         2         2m
nginx-3926361531   2         2         0         6s
nginx-3926361531   2         2         1         18s
nginx-2142116321   1         2         2         2m
nginx-2142116321   1         2         2         2m
nginx-3926361531   3         2         1         18s
nginx-3926361531   3         2         1         18s
nginx-2142116321   1         1         1         2m
nginx-3926361531   3         3         1         18s
nginx-3926361531   3         3         2         19s
nginx-2142116321   0         1         1         2m
nginx-2142116321   0         1         1         2m
nginx-2142116321   0         0         0         2m
nginx-3926361531   3         3         3         20s
</code></pre></li>
<li>
<p>롤아웃 최신 상태를 가져온다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get rs
</code></pre></div><p>이와 유사하게 출력된다.</p>
<pre><code>NAME               DESIRED   CURRENT   READY     AGE
nginx-2142116321   0         0         0         2m
nginx-3926361531   3         3         3         28s
</code></pre></li>
</ul>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> 일시 중지된 디플로이먼트를 재개할 때까지 롤백할 수 없다.
</div>
<h2 id=디플로이먼트-상태>디플로이먼트 상태</h2>
<p>디플로이먼트는 라이프사이클 동안 다양한 상태로 전환된다.
이는 새 레플리카셋을 롤아웃하는 동안 <a href=#%EB%94%94%ED%94%8C%EB%A1%9C%EC%9D%B4%EB%A8%BC%ED%8A%B8-%EC%A7%84%ED%96%89-%EC%A4%91>진행 중</a>이 될 수 있고, <a href=#%EB%94%94%ED%94%8C%EB%A1%9C%EC%9D%B4%EB%A8%BC%ED%8A%B8-%EC%99%84%EB%A3%8C>완료</a>이거나 <a href=#%EB%94%94%ED%94%8C%EB%A1%9C%EC%9D%B4%EB%A8%BC%ED%8A%B8-%EC%8B%A4%ED%8C%A8>진행 실패</a>일 수 있다.</p>
<h3 id=디플로이먼트-진행-중>디플로이먼트 진행 중</h3>
<p>쿠버네티스는 다음 작업중 하나를 수행할 때 디플로이먼트를 <em>진행 중</em> 으로 표시한다.</p>
<ul>
<li>디플로이먼트로 새 레플리카셋을 생성.</li>
<li>디플로이먼트로 새로운 레플리카셋을 스케일 업.</li>
<li>디플로이먼트로 기존 레플리카셋을 스케일 다운.</li>
<li>새 파드가 준비되거나 이용할 수 있음(최소 <a href=#%EC%B5%9C%EC%86%8C-%EB%8C%80%EA%B8%B0-%EC%8B%9C%EA%B0%84-%EC%B4%88>준비 시간(초)</a> 동안 준비됨).</li>
</ul>
<p>롤아웃이 "진행 중" 상태가 되면,
디플로이먼트 컨트롤러는 디플로이먼트의 <code>.status.conditions</code>에 다음 속성을 포함하는 컨디션을 추가한다.</p>
<ul>
<li><code>type: Progressing</code></li>
<li><code>status: "True"</code></li>
<li><code>reason: NewReplicaSetCreated</code> | <code>reason: FoundNewReplicaSet</code> | <code>reason: ReplicaSetUpdated</code></li>
</ul>
<p><code>kubectl rollout status</code> 를 사용해서 디플로이먼트의 진행사황을 모니터할 수 있다.</p>
<h3 id=디플로이먼트-완료>디플로이먼트 완료</h3>
<p>쿠버네티스는 다음과 같은 특성을 가지게 되면 디플로이먼트를 <em>완료</em> 로 표시한다.</p>
<ul>
<li>디플로이먼트과 관련된 모든 레플리카가 지정된 최신 버전으로 업데이트 되었을 때.
즉, 요청한 모든 업데이트가 완료되었을 때.</li>
<li>디플로이먼트와 관련한 모든 레플리카를 사용할 수 있을 때.</li>
<li>디플로이먼트에 대해 이전 복제본이 실행되고 있지 않을 때.</li>
</ul>
<p>롤아웃이 "완료" 상태가 되면,
디플로이먼트 컨트롤러는 디플로이먼트의 <code>.status.conditions</code>에 다음 속성을 포함하는 컨디션을 추가한다.</p>
<ul>
<li><code>type: Progressing</code></li>
<li><code>status: "True"</code></li>
<li><code>reason: NewReplicaSetAvailable</code></li>
</ul>
<p>이 <code>Progressing</code> 컨디션은 새로운 롤아웃이 시작되기 전까지는 <code>"True"</code> 상태값을 유지할 것이다.
레플리카의 가용성이 변경되는 경우에도(이 경우 <code>Available</code> 컨디션에 영향을 미침)
컨디션은 유지된다.</p>
<p><code>kubectl rollout status</code> 를 사용해서 디플로이먼트가 완료되었는지 확인할 수 있다.
만약 롤아웃이 성공적으로 완료되면 <code>kubectl rollout status</code> 는 종료 코드로 0이 반환된다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl rollout status deployment/nginx-deployment
</code></pre></div><p>이와 유사하게 출력된다.</p>
<pre><code>Waiting for rollout to finish: 2 of 3 updated replicas are available...
deployment &quot;nginx-deployment&quot; successfully rolled out
</code></pre><p>그리고 <code>kubectl rollout</code> 의 종료 상태는 0(success)이다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#a2f>echo</span> <span style=color:#b8860b>$?</span>
</code></pre></div><pre><code>0
</code></pre><h3 id=디플로이먼트-실패>디플로이먼트 실패</h3>
<p>디플로이먼트시 새 레플리카셋인 완료되지 않은 상태에서는 배포를 시도하면 고착될 수 있다.
이 문제는 다음 몇 가지 요인으로 인해 발생한다.</p>
<ul>
<li>할당량 부족</li>
<li>준비성 프로브(readiness probe)의 실패</li>
<li>이미지 풀 에러</li>
<li>권한 부족</li>
<li>범위 제한</li>
<li>애플리케이션 런타임의 잘못된 구성</li>
</ul>
<p>이 조건을 찾을 수 있는 한 가지 방법은 디플로이먼트 스펙에서 데드라인 파라미터를 지정하는 것이다
(<a href=#%EC%A7%84%ED%96%89-%EA%B8%B0%ED%95%9C-%EC%8B%9C%EA%B0%84-%EC%B4%88><code>.spec.progressDeadlineSeconds</code></a>). <code>.spec.progressDeadlineSeconds</code> 는
(디플로이먼트 상태에서) 디플로이먼트의 진행이 정지되었음을 나타내는 디플로이먼트 컨트롤러가
대기하는 시간(초)를 나타낸다.</p>
<p>다음 <code>kubectl</code> 명령어로 <code>progressDeadlineSeconds</code> 를 설정해서 컨트롤러가
10분 후 디플로이먼트 롤아웃에 대한 진행 상태의 부족에 대한 리포트를 수행하게 한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl patch deployment/nginx-deployment -p <span style=color:#b44>&#39;{&#34;spec&#34;:{&#34;progressDeadlineSeconds&#34;:600}}&#39;</span>
</code></pre></div><p>이와 유사하게 출력된다.</p>
<pre><code>deployment.apps/nginx-deployment patched
</code></pre><p>만약 데드라인을 넘어서면 디플로이먼트 컨트롤러는 디플로이먼트의 <code>.status.conditions</code> 속성에 다음의
디플로이먼트 컨디션(DeploymentCondition)을 추가한다.</p>
<ul>
<li><code>type: Progressing</code></li>
<li><code>status: "False"</code></li>
<li><code>reason: ProgressDeadlineExceeded</code></li>
</ul>
<p>이 컨디션은 일찍 실패할 수도 있으며 이러한 경우 <code>ReplicaSetCreateError</code>를 이유로 상태값을 <code>"False"</code>로 설정한다.
또한, 디플로이먼트 롤아웃이 완료되면 데드라인은 더 이상 고려되지 않는다.</p>
<p>컨디션 상태에 대한 자세한 내용은 <a href=https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#typical-status-properties>쿠버네티스 API 규칙</a>을 참고한다.</p>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> 쿠버네티스는 <code>reason: ProgressDeadlineExceeded</code> 과 같은 상태 조건을
보고하는 것 이외에 정지된 디플로이먼트에 대해 조치를 취하지 않는다. 더 높은 수준의 오케스트레이터는 이를 활용할 수 있으며,
예를 들어 디플로이먼트를 이전 버전으로 롤백할 수 있다.
</div>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> 만약 디플로이먼트 롤아웃을 일시 중지하면 쿠버네티스는 지정된 데드라인과 비교하여 진행 상황을 확인하지 않는다.
롤아웃 중에 디플로이먼트 롤아웃을 안전하게 일시 중지하고, 데드라인을 넘기도록 하는 조건을 트리거하지 않고
재개할 수 있다.
</div>
<p>설정한 타임아웃이 낮거나 일시적으로 처리될 수 있는 다른 종료의 에러로 인해 디플로이먼트에 일시적인 에러가 발생할 수 있다.
예를 들어, 할당량이 부족하다고 가정해보자.
만약 디플로이먼트를 설명하려면 다음 섹션을 확인한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe deployment nginx-deployment
</code></pre></div><p>이와 유사하게 출력된다.</p>
<pre><code>&lt;...&gt;
Conditions:
  Type            Status  Reason
  ----            ------  ------
  Available       True    MinimumReplicasAvailable
  Progressing     True    ReplicaSetUpdated
  ReplicaFailure  True    FailedCreate
&lt;...&gt;
</code></pre><p>만약 <code>kubectl get deployment nginx-deployment -o yaml</code> 을 실행하면 디플로이먼트 상태는 다음과 유사하다.</p>
<pre><code>status:
  availableReplicas: 2
  conditions:
  - lastTransitionTime: 2016-10-04T12:25:39Z
    lastUpdateTime: 2016-10-04T12:25:39Z
    message: Replica set &quot;nginx-deployment-4262182780&quot; is progressing.
    reason: ReplicaSetUpdated
    status: &quot;True&quot;
    type: Progressing
  - lastTransitionTime: 2016-10-04T12:25:42Z
    lastUpdateTime: 2016-10-04T12:25:42Z
    message: Deployment has minimum availability.
    reason: MinimumReplicasAvailable
    status: &quot;True&quot;
    type: Available
  - lastTransitionTime: 2016-10-04T12:25:39Z
    lastUpdateTime: 2016-10-04T12:25:39Z
    message: 'Error creating: pods &quot;nginx-deployment-4262182780-&quot; is forbidden: exceeded quota:
      object-counts, requested: pods=1, used: pods=3, limited: pods=2'
    reason: FailedCreate
    status: &quot;True&quot;
    type: ReplicaFailure
  observedGeneration: 3
  replicas: 2
  unavailableReplicas: 2
</code></pre><p>결국, 디플로이먼트 진행 데드라인을 넘어서면, 쿠버네티스는 진행 컨디션의
상태와 이유를 업데이트한다.</p>
<pre><code>Conditions:
  Type            Status  Reason
  ----            ------  ------
  Available       True    MinimumReplicasAvailable
  Progressing     False   ProgressDeadlineExceeded
  ReplicaFailure  True    FailedCreate
</code></pre><p>디플로이먼트를 스케일 다운하거나, 실행 중인 다른 컨트롤러를 스케일 다운하거나,
네임스페이스에서 할당량을 늘려서 할당량이 부족한 문제를 해결할 수 있다.
만약 할당량 컨디션과 디플로이먼트 롤아웃이 완료되어 디플로이먼트 컨트롤러를 만족한다면
성공한 컨디션의 디플로이먼트 상태가 업데이트를 볼 수 있다(<code>status: "True"</code> 와 <code>reason: NewReplicaSetAvailable</code>).</p>
<pre><code>Conditions:
  Type          Status  Reason
  ----          ------  ------
  Available     True    MinimumReplicasAvailable
  Progressing   True    NewReplicaSetAvailable
</code></pre><p><code>type: Available</code> 과 <code>status: "True"</code> 는 디플로이먼트가 최소한의 가용성을 가지고 있는 것을 의미한다.
최소한의 가용성은 디플로이먼트 계획에 명시된 파라미터에 의해 결정된다. <code>type: Progressing</code> 과 <code>status: "True"</code> 는 디플로이먼트가
롤아웃 도중에 진행 중 이거나, 성공적으로 완료되었으며, 진행 중 최소한으로 필요한 새로운 레플리카를 이용 가능하다는 것이다.
(자세한 내용은 특정 조건의 이유를 참조한다.
이 경우 <code>reason: NewReplicaSetAvailable</code> 는 배포가 완료되었음을 의미한다.)</p>
<p><code>kubectl rollout status</code> 를 사용해서 디플로이먼트의 진행이 실패되었는지 확인할 수 있다.
<code>kubectl rollout status</code> 는 디플로이먼트의 진행 데드라인을 초과하면 0이 아닌 종료 코드를 반환한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl rollout status deployment/nginx-deployment
</code></pre></div><p>이와 유사하게 출력된다.</p>
<pre><code>Waiting for rollout to finish: 2 out of 3 new replicas have been updated...
error: deployment &quot;nginx&quot; exceeded its progress deadline
</code></pre><p>그리고 <code>kubectl rollout</code> 의 종료 상태는 1(error를 의미함)이다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#a2f>echo</span> <span style=color:#b8860b>$?</span>
</code></pre></div><pre><code>1
</code></pre><h3 id=실패한-디플로이먼트에서의-운영>실패한 디플로이먼트에서의 운영</h3>
<p>완료된 디플로이먼트에 적용되는 모든 행동은 실패한 디플로이먼트에도 적용된다.
디플로이먼트 파드 템플릿에서 여러 개의 수정사항을 적용해야하는 경우 스케일 업/다운 하거나, 이전 수정 버전으로 롤백하거나, 일시 중지할 수 있다.</p>
<h2 id=정책-초기화>정책 초기화</h2>
<p>디플로이먼트의 <code>.spec.revisionHistoryLimit</code> 필드를 설정해서
디플로이먼트에서 유지해야 하는 이전 레플리카셋의 수를 명시할 수 있다. 나머지는 백그라운드에서 가비지-수집이 진행된다.
기본적으로 10으로 되어 있다.</p>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> 명시적으로 이 필드를 0으로 설정하면 그 결과로 디플로이먼트의 기록을 전부 초기화를 하고,
디플로이먼트는 롤백할 수 없게 된다.
</div>
<h2 id=카나리-디플로이먼트>카나리 디플로이먼트</h2>
<p>만약 디플로이먼트를 이용해서 일부 사용자 또는 서버에 릴리스를 롤아웃 하기 위해서는
<a href=/ko/docs/concepts/cluster-administration/manage-deployment/#%EC%B9%B4%EB%82%98%EB%A6%AC-canary-%EB%94%94%ED%94%8C%EB%A1%9C%EC%9D%B4%EB%A8%BC%ED%8A%B8>리소스 관리</a>에
설명된 카나리 패던에 따라 각 릴리스 마다 하나씩 여러 디플로이먼트를 생성할 수 있다.</p>
<h2 id=디플로이먼트-사양-작성>디플로이먼트 사양 작성</h2>
<p>다른 모든 쿠버네티스 설정과 마찬가지로 디플로이먼트에는 <code>.apiVersion</code>, <code>.kind</code> 그리고 <code>.metadata</code> 필드가 필요하다.
설정 파일 작업에 대한 일반적인 내용은
<a href=/ko/docs/tasks/run-application/run-stateless-application-deployment/>애플리케이션 배포하기</a>,
컨테이너 구성하기 그리고 <a href=/ko/docs/concepts/overview/working-with-objects/object-management/>kubectl을 사용해서 리소스 관리하기</a> 문서를 참조한다.
디플로이먼트 오브젝트의 이름은 유효한
<a href=/ko/docs/concepts/overview/working-with-objects/names/#dns-%EC%84%9C%EB%B8%8C%EB%8F%84%EB%A9%94%EC%9D%B8-%EC%9D%B4%EB%A6%84>DNS 서브도메인 이름</a>이어야 한다.</p>
<p>디플로이먼트에는 <a href=https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status><code>.spec</code> 섹션</a>도 필요하다.</p>
<h3 id=파드-템플릿>파드 템플릿</h3>
<p><code>.spec.template</code> 과 <code>.spec.selector</code> 은 <code>.spec</code> 에서 유일한 필수 필드이다.</p>
<p><code>.spec.template</code> 는 <a href=/ko/docs/concepts/workloads/pods/#%ED%8C%8C%EB%93%9C-%ED%85%9C%ED%94%8C%EB%A6%BF>파드 템플릿</a>이다. 이것은 <a class=glossary-tooltip title="파드는 클러스터에서 실행 중인 컨테이너의 집합을 나타낸다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/pods/ target=_blank aria-label=파드>파드</a>와 정확하게 동일한 스키마를 가지고 있고, 중첩된 것을 제외하면 <code>apiVersion</code> 과 <code>kind</code> 를 가지고 있지 않는다.</p>
<p>파드에 필요한 필드 외에 디플로이먼트 파드 템플릿은 적절한 레이블과 적절한 재시작 정책을 명시해야 한다.
레이블의 경우 다른 컨트롤러와 겹치지 않도록 해야 한다. 자세한 것은 <a href=#%EC%85%80%EB%A0%89%ED%84%B0>셀렉터</a>를 참조한다.</p>
<p><a href=/ko/docs/concepts/workloads/pods/pod-lifecycle/#%EC%9E%AC%EC%8B%9C%EC%9E%91-%EC%A0%95%EC%B1%85><code>.spec.template.spec.restartPolicy</code></a> 에는 오직 <code>Always</code> 만 허용되고,
명시되지 않으면 기본값이 된다.</p>
<h3 id=레플리카>레플리카</h3>
<p><code>.spec.replicas</code> 은 필요한 파드의 수를 지정하는 선택적 필드이다. 이것의 기본값은 1이다.</p>
<p>예를 들어 <code>kubectl scale deployment deployment --replicas=X</code> 명령으로
디플로이먼트의 크기를 수동으로 조정한 뒤,
매니페스트를 이용하여 디플로이먼트를 업데이트하면(예: <code>kubectl apply -f deployment.yaml</code> 실행),
수동으로 설정했던 디플로이먼트의 크기가 오버라이드된다.</p>
<p><a href=/ko/docs/tasks/run-application/horizontal-pod-autoscale/>HorizontalPodAutoscaler</a>(또는 수평 스케일링을 위한 유사 API)가
디플로이먼트 크기를 관리하고 있다면, <code>.spec.replicas</code> 를 설정해서는 안 된다.</p>
<p>대신, 쿠버네티스
<a class=glossary-tooltip title="컨테이너의 라이프사이클을 정의, 배포, 관리하기 위한 API와 인터페이스들을 노출하는 컨테이너 오케스트레이션 레이어." data-toggle=tooltip data-placement=top href="/ko/docs/reference/glossary/?all=true#term-control-plane" target=_blank aria-label="컨트롤 플레인">컨트롤 플레인</a>이
<code>.spec.replicas</code> 필드를 자동으로 관리한다.</p>
<h3 id=셀렉터>셀렉터</h3>
<p><code>.spec.selector</code> 는 디플로이먼트의 대상이 되는 파드에 대해 <a href=/ko/docs/concepts/overview/working-with-objects/labels/>레이블 셀렉터</a>를
지정하는 필수 필드이다.</p>
<p><code>.spec.selector</code> 는 <code>.spec.template.metadata.labels</code> 과 일치해야 하며, 그렇지 않으면 API에 의해 거부된다.</p>
<p>API 버전 <code>apps/v1</code> 에서는 <code>.spec.selector</code> 와 <code>.metadata.labels</code> 이 설정되지 않으면 <code>.spec.template.metadata.labels</code> 은 기본 설정되지 않는다. 그래서 이것들은 명시적으로 설정되어야 한다. 또한 <code>apps/v1</code> 에서는 디플로이먼트를 생성한 후에는 <code>.spec.selector</code> 이 변경되지 않는 점을 참고한다.</p>
<p>디플로이먼트는 템플릿의 <code>.spec.template</code> 와 다르거나 파드의 수가 <code>.spec.replicas</code> 를 초과할 경우
셀렉터와 일치하는 레이블을 가진 파드를 종료할 수 있다.
파드의 수가 의도한 수량보다 적을 경우 <code>.spec.template</code> 에 맞는 새 파드를 띄운다.</p>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> 다른 디플로이먼트를 생성하거나, 레플리카셋 또는 레플리케이션컨트롤러와 같은 다른 컨트롤러를 사용해서 직접적으로 레이블과 셀렉터가 일치하는 다른 파드를 생성하지 말아야 한다.
만약 이렇게 하면 첫 번째 디플로이먼트는 다른 파드를 만들었다고 생각한다.
쿠버네티스는 이 일을 막지 않는다.
</div>
<p>만약 셀렉터가 겹치는 컨트롤러가 어러 개 있는 경우, 컨트롤러는 서로 싸우고
올바르게 작동하지 않는다.</p>
<h3 id=전략>전략</h3>
<p><code>.spec.strategy</code> 는 이전 파드를 새로운 파드로 대체하는 전략을 명시한다.
<code>.spec.strategy.type</code> 은 "재생성" 또는 "롤링업데이트"가 될 수 있다.
"롤링업데이트"가 기본값이다.</p>
<h4 id=디플로이먼트-재생성>디플로이먼트 재생성</h4>
<p>기존의 모든 파드는 <code>.spec.strategy.type==Recreate</code> 이면 새 파드가 생성되기 전에 죽는다.</p>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> 이렇게 하면 업그레이드를 생성하기 전에 파드 종료를 보장할 수 있다. 디플로이먼트를 업그레이드하면,
이전 버전의 모든 파드가 즉시 종료된다. 신규 버전의 파드가 생성되기 전에 성공적으로 제거가
완료되기를 대기한다. 파드를 수동으로 삭제하면, 라이프사이클은 레플리카셋에 의해
제어되며(이전 파드가 여전히 종료 상태에 있는 경우에도) 교체용 파드가 즉시 생성된다. 파드에
대해 "최대" 보장이 필요한 경우
<a href=/ko/docs/concepts/workloads/controllers/statefulset/>스테이트풀셋</a>의 사용을 고려해야 한다.
</div>
<h4 id=디플로이먼트-롤링-업데이트>디플로이먼트 롤링 업데이트</h4>
<p>디플로이먼트는 <code>.spec.strategy.type==RollingUpdate</code> 이면 파드를 롤링 업데이트
방식으로 업데이트 한다. <code>maxUnavailable</code> 와 <code>maxSurge</code> 를 명시해서
롤링 업데이트 프로세스를 제어할 수 있다.</p>
<h5 id=최대-불가-max-unavailable>최대 불가(Max Unavailable)</h5>
<p><code>.spec.strategy.rollingUpdate.maxUnavailable</code> 은 업데이트 프로세스 중에 사용할 수 없는 최대 파드의 수를 지정하는 선택적 필드이다.
이 값은 절대 숫자(예: 5) 또는 의도한 파드 비율(예: 10%)이 될 수 있다.
절대 값은 내림해서 백분율로 계산한다.
만약 <code>.spec.strategy.rollingUpdate.maxSurge</code> 가 0이면 값이 0이 될 수 없다. 기본 값은 25% 이다.</p>
<p>예를 들어 이 값을 30%로 설정하면 롤링업데이트 시작시 즉각 이전 레플리카셋의 크기를
의도한 파드 중 70%를 스케일 다운할 수 있다. 새 파드가 준비되면 기존 레플리카셋을 스케일 다운할 수 있으며,
업데이트 중에 항상 사용 가능한 전체 파드의 수는
의도한 파드의 수의 70% 이상이 되도록 새 레플리카셋을 스케일 업할 수 있다.</p>
<h5 id=최대-서지-max-surge>최대 서지(Max Surge)</h5>
<p><code>.spec.strategy.rollingUpdate.maxSurge</code> 는 의도한 파드의 수에 대해 생성할 수 있는 최대 파드의 수를 지정하는 선택적 필드이다.
이 값은 절대 숫자(예: 5) 또는 의도한 파드 비율(예: 10%)이 될 수 있다.
<code>MaxUnavailable</code> 값이 0이면 이 값은 0이 될 수 없다.
절대 값은 올림해서 백분율로 계산한다. 기본 값은 25% 이다.</p>
<p>예를 들어 이 값을 30%로 설정하면 롤링업데이트 시작시 새 레플리카셋의 크기를 즉시 조정해서
기존 및 새 파드의 전체 갯수를 의도한 파드의 130%를 넘지 않도록 한다.
기존 파드가 죽으면 새로운 래플리카셋은 스케일 업할 수 있으며,
업데이트하는 동안 항상 실행하는 총 파드의 수는 최대 의도한 파드의 수의 130%가 되도록 보장한다.</p>
<h3 id=진행-기한-시간-초>진행 기한 시간(초)</h3>
<p><code>.spec.progressDeadlineSeconds</code> 는 디플로어먼트가 표면적으로 <code>type: Progressing</code>, <code>status: "False"</code>의
상태 그리고 리소스가 <code>reason: ProgressDeadlineExceeded</code> 상태로 <a href=#%EB%94%94%ED%94%8C%EB%A1%9C%EC%9D%B4%EB%A8%BC%ED%8A%B8-%EC%8B%A4%ED%8C%A8>진행 실패</a>를 보고하기 전에
디플로이먼트가 진행되는 것을 대기시키는 시간(초)를 명시하는 선택적 필드이다.
디플로이먼트 컨트롤러는 디플로이먼트를 계속 재시도 한다. 기본값은 600(초)이다.
미래에 자동화된 롤백이 구현된다면 디플로이먼트 컨트롤러는 상태를 관찰하고,
그 즉시 디플로이먼트를 롤백할 것이다.</p>
<p>만약 명시된다면 이 필드는 <code>.spec.minReadySeconds</code> 보다 커야 한다.</p>
<h3 id=최소-대기-시간-초>최소 대기 시간(초)</h3>
<p><code>.spec.minReadySeconds</code> 는 새롭게 생성된 파드의 컨테이너가 어떤 것과도 충돌하지 않고 사
용할 수 있도록 준비되어야 하는 최소 시간(초)을 지정하는 선택적 필드이다.
이 기본 값은 0이다(파드는 준비되는 즉시 사용할 수 있는 것으로 간주됨).
파드가 준비되었다고 간주되는 시기에 대한 자세한 내용은 <a href=/ko/docs/concepts/workloads/pods/pod-lifecycle/#%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88-%ED%94%84%EB%A1%9C%EB%B8%8C-probe>컨테이너 프로브</a>를 참조한다.</p>
<h3 id=수정-버전-기록-제한>수정 버전 기록 제한</h3>
<p>디플로이먼트의 수정 버전 기록은 자신이 컨트롤하는 레플리카셋에 저장된다.</p>
<p><code>.spec.revisionHistoryLimit</code> 은 롤백을 허용하기 위해 보존할 이전 레플리카셋의 수를 지정하는 선택적 필드이다.
이 이전 레플리카셋은 <code>etcd</code> 의 리소스를 소비하고, <code>kubectl get rs</code> 의 결과를 가득차게 만든다. 각 디플로이먼트의 구성은 디플로이먼트의 레플리카셋에 저장된다. 이전 레플리카셋이 삭제되면 해당 디플로이먼트 수정 버전으로 롤백할 수 있는 기능이 사라진다. 기본적으로 10개의 기존 레플리카셋이 유지되지만 이상적인 값은 새로운 디플로이먼트의 빈도와 안정성에 따라 달라진다.</p>
<p>더욱 구체적으로 이 필드를 0으로 설정하면 레플리카가 0이 되며 이전 레플리카셋이 정리된다.
이 경우, 새로운 디플로이먼트 롤아웃을 취소할 수 없다. 새로운 디플로이먼트 롤아웃은 수정 버전 이력이 정리되기 때문이다.</p>
<h3 id=일시-정지>일시 정지</h3>
<p><code>.spec.paused</code> 는 디플로이먼트를 일시 중지나 재개하기 위한 선택적 부울 필드이다.
일시 중지 된 디플로이먼트와 일시 중지 되지 않은 디플로이먼트 사이의 유일한 차이점은
일시 중지된 디플로이먼트는 PodTemplateSpec에 대한 변경 사항이 일시중지 된 경우 새 롤아웃을 트리거 하지 않는다.
디플로이먼트는 생성시 기본적으로 일시 중지되지 않는다.</p>
<h2 id=다음-내용>다음 내용</h2>
<ul>
<li><a href=/ko/docs/concepts/workloads/pods>파드</a>에 대해 배운다.</li>
<li><a href=/ko/docs/tasks/run-application/run-stateless-application-deployment/>디플로이먼트를 사용해서 상태를 유지하지 않는 애플리케이션을 구동한다</a>.</li>
<li><code>Deployment</code>는 쿠버네티스 REST API에서 상위-수준 리소스이다.
디플로이먼트 API를 이해하기 위해서
<a href=/docs/reference/kubernetes-api/workload-resources/deployment-v1/>Deployment</a>
오브젝트 정의를 읽는다.</li>
<li><a href=/ko/docs/concepts/workloads/pods/disruptions/>PodDisruptionBudget</a>과
이를 사용해서 어떻게 중단 중에 애플리케이션 가용성을 관리할 수 있는지에 대해 읽는다.</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-d459b930218774655fa7fd1620625539>4.2.2 - 레플리카셋</h1>
<p>레플리카셋의 목적은 레플리카 파드 집합의 실행을 항상 안정적으로 유지하는 것이다.
이처럼 레플리카셋은 보통 명시된 동일 파드 개수에 대한 가용성을 보증하는데 사용한다.</p>
<h2 id=레플리카셋의-작동-방식>레플리카셋의 작동 방식</h2>
<p>레플리카셋을 정의하는 필드는 획득 가능한 파드를 식별하는 방법이 명시된 셀렉터, 유지해야 하는 파드 개수를 명시하는 레플리카의 개수,
그리고 레플리카 수 유지를 위해 생성하는 신규 파드에 대한 데이터를 명시하는 파드 템플릿을 포함한다.
그러면 레플리카셋은 필드에 지정된 설정을 충족하기 위해 필요한 만큼 파드를 만들고 삭제한다.
레플리카셋이 새로운 파드를 생성해야 할 경우, 명시된 파드 템플릿을
사용한다.</p>
<p>레플리카셋은 파드의 <a href=/ko/docs/concepts/architecture/garbage-collection/#%EC%86%8C%EC%9C%A0%EC%9E%90-owner-%EC%99%80-%EC%A2%85%EC%86%8D-dependent>metadata.ownerReferences</a>
필드를 통해 파드에 연결되며, 이는 현재 오브젝트가 소유한 리소스를 명시한다.
레플리카셋이 가지고 있는 모든 파드의 ownerReferences 필드는 해당 파드를 소유한 레플리카셋을 식별하기 위한 소유자 정보를 가진다.
이 링크를 통해 레플리카셋은 자신이 유지하는 파드의 상태를 확인하고 이에 따라 관리 한다.</p>
<p>레플리카셋은 셀렉터를 이용해서 필요한 새 파드를 식별한다. 만약 파드에 OwnerReference이 없거나
OwnerReference가 <a class=glossary-tooltip title="API 서버를 통해 클러스터의 공유된 상태를 감시하고, 현재 상태를 원하는 상태로 이행시키는 컨트롤 루프." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/architecture/controller/ target=_blank aria-label=컨트롤러(Controller)>컨트롤러(Controller)</a> 가 아니고 레플리카셋의 셀렉터와 일치한다면 레플리카셋이 즉각 파드를
가지게 될 것이다.</p>
<h2 id=레플리카셋을-사용하는-시기>레플리카셋을 사용하는 시기</h2>
<p>레플리카셋은 지정된 수의 파드 레플리카가 항상 실행되도록 보장한다.
그러나 디플로이먼트는 레플리카셋을 관리하고 다른 유용한 기능과 함께
파드에 대한 선언적 업데이트를 제공하는 상위 개념이다.
따라서 우리는 사용자 지정 오케스트레이션이 필요하거나 업데이트가 전혀 필요하지 않은 경우라면
레플리카셋을 직접적으로 사용하기 보다는 디플로이먼트를 사용하는 것을 권장한다.</p>
<p>이는 레플리카셋 오브젝트를 직접 조작할 필요가 없다는 것을 의미한다.
대신 디플로이먼트를 이용하고 사양 부분에서 애플리케이션을 정의하면 된다.</p>
<h2 id=예시>예시</h2>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/ko/examples/controllers/frontend.yaml download=controllers/frontend.yaml><code>controllers/frontend.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('controllers-frontend-yaml')" title="Copy controllers/frontend.yaml to clipboard">
</img>
</div>
<div class=includecode id=controllers-frontend-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ReplicaSet<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>guestbook<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>tier</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 케이스에 따라 레플리카를 수정한다.</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>tier</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>tier</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>php-redis<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>gcr.io/google_samples/gb-frontend:v3<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>이 매니페스트를 <code>frontend.yaml</code>에 저장하고 쿠버네티스 클러스터에 적용하면 정의되어 있는 레플리카셋이
생성되고 레플리카셋이 관리하는 파드가 생성된다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://kubernetes.io/examples/controllers/frontend.yaml
</code></pre></div><p>현재 배포된 레플리카셋을 확인할 수 있다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get rs
</code></pre></div><p>그리고 생성된 프런트엔드를 볼 수 있다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>NAME       DESIRED   CURRENT   READY   AGE
frontend   <span style=color:#666>3</span>         <span style=color:#666>3</span>         <span style=color:#666>3</span>       6s
</code></pre></div><p>또한 레플리카셋의 상태를 확인할 수 있다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe rs/frontend
</code></pre></div><p>출력은 다음과 유사할 것이다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>Name:         frontend
Namespace:    default
Selector:     <span style=color:#b8860b>tier</span><span style=color:#666>=</span>frontend
Labels:       <span style=color:#b8860b>app</span><span style=color:#666>=</span>guestbook
              <span style=color:#b8860b>tier</span><span style=color:#666>=</span>frontend
Annotations:  kubectl.kubernetes.io/last-applied-configuration:
                <span style=color:#666>{</span><span style=color:#b44>&#34;apiVersion&#34;</span>:<span style=color:#b44>&#34;apps/v1&#34;</span>,<span style=color:#b44>&#34;kind&#34;</span>:<span style=color:#b44>&#34;ReplicaSet&#34;</span>,<span style=color:#b44>&#34;metadata&#34;</span>:<span style=color:#666>{</span><span style=color:#b44>&#34;annotations&#34;</span>:<span style=color:#666>{}</span>,<span style=color:#b44>&#34;labels&#34;</span>:<span style=color:#666>{</span><span style=color:#b44>&#34;app&#34;</span>:<span style=color:#b44>&#34;guestbook&#34;</span>,<span style=color:#b44>&#34;tier&#34;</span>:<span style=color:#b44>&#34;frontend&#34;</span><span style=color:#666>}</span>,<span style=color:#b44>&#34;name&#34;</span>:<span style=color:#b44>&#34;frontend&#34;</span>,...
Replicas:     <span style=color:#666>3</span> current / <span style=color:#666>3</span> desired
Pods Status:  <span style=color:#666>3</span> Running / <span style=color:#666>0</span> Waiting / <span style=color:#666>0</span> Succeeded / <span style=color:#666>0</span> Failed
Pod Template:
  Labels:  <span style=color:#b8860b>tier</span><span style=color:#666>=</span>frontend
  Containers:
   php-redis:
    Image:        gcr.io/google_samples/gb-frontend:v3
    Port:         &lt;none&gt;
    Host Port:    &lt;none&gt;
    Environment:  &lt;none&gt;
    Mounts:       &lt;none&gt;
  Volumes:        &lt;none&gt;
Events:
  Type    Reason            Age   From                   Message
  ----    ------            ----  ----                   -------
  Normal  SuccessfulCreate  117s  replicaset-controller  Created pod: frontend-wtsmm
  Normal  SuccessfulCreate  116s  replicaset-controller  Created pod: frontend-b2zdv
  Normal  SuccessfulCreate  116s  replicaset-controller  Created pod: frontend-vcmts
</code></pre></div><p>마지막으로 파드가 올라왔는지 확인할 수 있다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods
</code></pre></div><p>다음과 유사한 파드 정보를 볼 수 있다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>NAME             READY   STATUS    RESTARTS   AGE
frontend-b2zdv   1/1     Running   <span style=color:#666>0</span>          6m36s
frontend-vcmts   1/1     Running   <span style=color:#666>0</span>          6m36s
frontend-wtsmm   1/1     Running   <span style=color:#666>0</span>          6m36s
</code></pre></div><p>또한 파드들의 소유자 참조 정보가 해당 프런트엔드 레플리카셋으로 설정되어 있는지 확인할 수 있다.
확인을 위해서는 실행 중인 파드 중 하나의 yaml을 확인한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods frontend-b2zdv -o yaml
</code></pre></div><p>메타데이터의 ownerReferences 필드에 설정되어 있는 프런트엔드 레플리카셋의 정보가 다음과 유사하게 나오는 것을 볼 수 있다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>apiVersion: v1
kind: Pod
metadata:
  creationTimestamp: <span style=color:#b44>&#34;2020-02-12T07:06:16Z&#34;</span>
  generateName: frontend-
  labels:
    tier: frontend
  name: frontend-b2zdv
  namespace: default
  ownerReferences:
  - apiVersion: apps/v1
    blockOwnerDeletion: <span style=color:#a2f>true</span>
    controller: <span style=color:#a2f>true</span>
    kind: ReplicaSet
    name: frontend
    uid: f391f6db-bb9b-4c09-ae74-6a1f77f3d5cf
...
</code></pre></div><h2 id=템플릿을-사용하지-않는-파드의-획득>템플릿을 사용하지 않는 파드의 획득</h2>
<p>단독(bare) 파드를 생성하는 것에는 문제가 없지만, 단독 파드가 레플리카셋의 셀렉터와 일치하는 레이블을 가지지
않도록 하는 것을 강력하게 권장한다. 그 이유는 레플리카셋이 소유하는 파드가 템플릿에 명시된 파드에만 국한되지 않고,
이전 섹션에서 명시된 방식에 의해서도 다른 파드의 획득이 가능하기 때문이다.</p>
<p>이전 프런트엔드 레플리카셋 예제와 다음의 매니페스트에 명시된 파드를 가져와 참조한다.</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/ko/examples/pods/pod-rs.yaml download=pods/pod-rs.yaml><code>pods/pod-rs.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-pod-rs-yaml')" title="Copy pods/pod-rs.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-pod-rs-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pod1<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>tier</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>hello1<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>gcr.io/google-samples/hello-app:2.0<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pod2<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>tier</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>hello2<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>gcr.io/google-samples/hello-app:1.0<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>기본 파드는 소유자 관련 정보에 컨트롤러(또는 오브젝트)를 가지지 않기 때문에 프런트엔드
레플리카셋의 셀렉터와 일치하면 즉시 레플리카셋에 소유된다.</p>
<p>프런트엔드 레플리카셋이 배치되고 초기 파드 레플리카가 셋업된 이후에, 레플리카 수 요구 사항을 충족시키기 위해서
신규 파드를 생성한다고 가정해보자.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://kubernetes.io/examples/pods/pod-rs.yaml
</code></pre></div><p>새로운 파드는 레플리카셋에 의해 인식되며 레플리카셋이 필요한 수량을 초과하면
즉시 종료된다.</p>
<p>파드를 가져온다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods
</code></pre></div><p>결과에는 새로운 파드가 이미 종료되었거나 종료가 진행 중인 것을 보여준다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>NAME             READY   STATUS        RESTARTS   AGE
frontend-b2zdv   1/1     Running       <span style=color:#666>0</span>          10m
frontend-vcmts   1/1     Running       <span style=color:#666>0</span>          10m
frontend-wtsmm   1/1     Running       <span style=color:#666>0</span>          10m
pod1             0/1     Terminating   <span style=color:#666>0</span>          1s
pod2             0/1     Terminating   <span style=color:#666>0</span>          1s
</code></pre></div><p>파드를 먼저 생성한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://kubernetes.io/examples/pods/pod-rs.yaml
</code></pre></div><p>그 다음 레플리카셋을 생성한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://kubernetes.io/examples/controllers/frontend.yaml
</code></pre></div><p>레플리카셋이 해당 파드를 소유한 것을 볼 수 있으며 새 파드 및 기존 파드의 수가
레플리카셋이 필요로 하는 수와 일치할 때까지 사양에 따라 신규 파드만 생성한다. 파드를 가져온다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods
</code></pre></div><p>다음 출력에서 볼 수 있다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>NAME             READY   STATUS    RESTARTS   AGE
frontend-hmmj2   1/1     Running   <span style=color:#666>0</span>          9s
pod1             1/1     Running   <span style=color:#666>0</span>          36s
pod2             1/1     Running   <span style=color:#666>0</span>          36s
</code></pre></div><p>이러한 방식으로 레플리카셋은 템플릿을 사용하지 않는 파드를 소유하게 된다.</p>
<h2 id=레플리카셋-매니페스트-작성하기>레플리카셋 매니페스트 작성하기</h2>
<p>레플리카셋은 모든 쿠버네티스 API 오브젝트와 마찬가지로 <code>apiVersion</code>, <code>kind</code>, <code>metadata</code> 필드가 필요하다.
레플리카셋에 대한 <code>kind</code> 필드의 값은 항상 레플리카셋이다.
쿠버네티스 1.9에서의 레플리카셋의 kind에 있는 API 버전 <code>apps/v1</code>은 현재 버전이며, 기본으로 활성화 되어 있다. API 버전 <code>apps/v1beta2</code>은 사용 중단(deprecated)되었다.
API 버전에 대해서는 <code>frontend.yaml</code> 예제의 첫 번째 줄을 참고한다.</p>
<p>레플리카셋 오브젝트의 이름은 유효한
<a href=/ko/docs/concepts/overview/working-with-objects/names/#dns-%EC%84%9C%EB%B8%8C%EB%8F%84%EB%A9%94%EC%9D%B8-%EC%9D%B4%EB%A6%84>DNS 서브도메인 이름</a>이어야 한다.</p>
<p>레플리카셋도 <a href=https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status><code>.spec</code> 섹션</a>이 필요하다.</p>
<h3 id=파드-템플릿>파드 템플릿</h3>
<p><code>.spec.template</code>은 레이블을 붙이도록 되어 있는 <a href=/ko/docs/concepts/workloads/pods/#%ED%8C%8C%EB%93%9C-%ED%85%9C%ED%94%8C%EB%A6%BF>파드 템플릿</a>이다.
우리는 <code>frontend.yaml</code> 예제에서 <code>tier: frontend</code>이라는 레이블을 하나 가지고 있다.
이 파드를 다른 컨트롤러가 취하지 않도록 다른 컨트롤러의 셀렉터와 겹치지 않도록 주의해야 한다.</p>
<p>템플릿의 <a href=/ko/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy>재시작 정책</a> 필드인
<code>.spec.template.spec.restartPolicy</code>는 기본값인 <code>Always</code>만 허용된다.</p>
<h3 id=파드-셀렉터>파드 셀렉터</h3>
<p><code>.spec.selector</code> 필드는 <a href=/ko/docs/concepts/overview/working-with-objects/labels/>레이블 셀렉터</a>이다.
<a href=#%EB%A0%88%ED%94%8C%EB%A6%AC%EC%B9%B4-%EC%85%8B%EC%9D%98-%EC%9E%91%EB%8F%99-%EB%B0%A9%EC%8B%9D>앞서</a> 논의한 것처럼 이 레이블은 소유될 가능성이 있는 파드를 식별하는데 사용된다.
우리 <code>frontend.yaml</code> 예제에서의 셀렉터는 다음과 같다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>tier</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span></code></pre></div><p>레플리카셋에서 <code>.spec.template.metadata.labels</code>는 <code>spec.selector</code>과 일치해야 하며
그렇지 않으면 API에 의해 거부된다.</p>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> 2개의 레플리카셋이 동일한 <code>.spec.selector</code>필드를 지정한 반면, 다른 <code>.spec.template.metadata.labels</code>와 <code>.spec.template.spec</code> 필드를 명시한 경우, 각 레플리카셋은 다른 레플리카셋이 생성한 파드를 무시한다.
</div>
<h3 id=레플리카>레플리카</h3>
<p><code>.spec.replicas</code>를 설정해서 동시에 동작하는 파드의 수를 지정할 수 있다.
레플리카셋은 파드의 수가 일치하도록 생성 및 삭제한다.</p>
<p>만약 <code>.spec.replicas</code>를 지정하지 않으면 기본값은 1이다.</p>
<h2 id=레플리카셋-작업>레플리카셋 작업</h2>
<h3 id=레플리카셋과-해당-파드-삭제>레플리카셋과 해당 파드 삭제</h3>
<p>레플리카셋 및 모든 파드를 삭제하려면 <a href=/docs/reference/generated/kubectl/kubectl-commands#delete><code>kubectl delete</code></a>를 사용한다. <a href=/ko/docs/concepts/architecture/garbage-collection/>가비지 수집기</a>는 기본적으로 종속되어 있는 모든 파드를 자동으로 삭제한다.</p>
<p>REST API또는 <code>client-go</code> 라이브러리를 이용할 때는 -d 옵션으로 <code>propagationPolicy</code>를 <code>Background</code>또는 <code>Foreground</code>로
설정해야 한다.
예시:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl proxy --port<span style=color:#666>=</span><span style=color:#666>8080</span>
curl -X DELETE  <span style=color:#b44>&#39;localhost:8080/apis/apps/v1/namespaces/default/replicasets/frontend&#39;</span> <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>&gt; -d <span style=color:#b44>&#39;{&#34;kind&#34;:&#34;DeleteOptions&#34;,&#34;apiVersion&#34;:&#34;v1&#34;,&#34;propagationPolicy&#34;:&#34;Foreground&#34;}&#39;</span> <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>&gt; -H <span style=color:#b44>&#34;Content-Type: application/json&#34;</span>
</code></pre></div><h3 id=레플리카셋만-삭제하기>레플리카셋만 삭제하기</h3>
<p>레플리카셋을 <code>--cascade=orphan</code> 옵션과 함께 <a href=/docs/reference/generated/kubectl/kubectl-commands#delete><code>kubectl delete</code></a>를 사용하면 연관 파드에 영향을 주지 않고 삭제할 수 있다.
REST API 또는 <code>client-go</code> 라이브러리를 이용할 때는 <code>propagationPolicy</code>에 <code>Orphan</code>을 설정해야 한다.
예시:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl proxy --port<span style=color:#666>=</span><span style=color:#666>8080</span>
curl -X DELETE  <span style=color:#b44>&#39;localhost:8080/apis/apps/v1/namespaces/default/replicasets/frontend&#39;</span> <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>&gt; -d <span style=color:#b44>&#39;{&#34;kind&#34;:&#34;DeleteOptions&#34;,&#34;apiVersion&#34;:&#34;v1&#34;,&#34;propagationPolicy&#34;:&#34;Orphan&#34;}&#39;</span> <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>&gt; -H <span style=color:#b44>&#34;Content-Type: application/json&#34;</span>
</code></pre></div><p>원본이 삭제되면 새 레플리카셋을 생성해서 대체할 수 있다.
기존 <code>.spec.selector</code>와 신규 <code>.spec.selector</code>가 같으면 새 레플리카셋은 기존 파드를 선택한다.
하지만 신규 레플리카셋은 기존 파드를 신규 레플리카셋의 새롭고 다른 파드 템플릿에 일치시키는 작업을 수행하지는 않는다.
컨트롤 방식으로 파드를 새로운 사양으로 업데이트 하기 위해서는 <a href=/ko/docs/concepts/workloads/controllers/deployment/#%EB%94%94%ED%94%8C%EB%A1%9C%EC%9D%B4%EB%A8%BC%ED%8A%B8-%EC%83%9D%EC%84%B1>디플로이먼트</a>를 이용하면 된다.
이는 레플리카셋이 롤링 업데이트를 직접적으로 지원하지 않기 때문이다.</p>
<h3 id=레플리카셋에서-파드-격리>레플리카셋에서 파드 격리</h3>
<p>레이블을 변경하면 레플리카셋에서 파드를 제거할 수 있다. 이 방식은 디버깅과 데이터 복구 등을
위해 서비스에서 파드를 제거하는 데 사용할 수 있다. 이 방식으로 제거된 파드는 자동으로 교체된다(
레플리카의 수가 변경되지 않는다고 가정한다).</p>
<h3 id=레플리카셋의-스케일링>레플리카셋의 스케일링</h3>
<p>레플리카셋을 손쉽게 스케일 업 또는 다운하는 방법은 단순히 <code>.spec.replicas</code> 필드를 업데이트하면 된다.
레플리카셋 컨트롤러는 일치하는 레이블 셀렉터가 있는 파드가 의도한 수 만큼 가용하고 운영 가능하도록 보장한다.</p>
<p>스케일 다운할 때, 레플리카셋 컨트롤러는 스케일 다운할 파드의
우선순위를 정하기 위해 다음의 기준으로 가용 파드를 정렬하여 삭제할 파드를 결정한다.</p>
<ol>
<li>Pending 상태인 (+ 스케줄링할 수 없는) 파드가 먼저 스케일 다운된다.</li>
<li><code>controller.kubernetes.io/pod-deletion-cost</code> 어노테이션이 설정되어 있는
파드에 대해서는, 낮은 값을 갖는 파드가 먼저 스케일 다운된다.</li>
<li>더 많은 레플리카가 있는 노드의 파드가 더 적은 레플리카가 있는 노드의 파드보다 먼저 스케일 다운된다.</li>
<li>파드 생성 시간이 다르면, 더 최근에 생성된 파드가
이전에 생성된 파드보다 먼저 스케일 다운된다.
(<code>LogarithmicScaleDown</code> <a href=/ko/docs/reference/command-line-tools-reference/feature-gates/>기능 게이트</a>가 활성화되어 있으면 생성 시간이 정수 로그 스케일로 버킷화된다)</li>
</ol>
<p>모든 기준에 대해 동등하다면, 스케일 다운할 파드가 임의로 선택된다.</p>
<h3 id=파드-삭제-비용>파드 삭제 비용</h3>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.22 [beta]</code>
</div>
<p><a href=/ko/docs/reference/labels-annotations-taints/#pod-deletion-cost><code>controller.kubernetes.io/pod-deletion-cost</code></a> 어노테이션을 이용하여,
레플리카셋을 스케일 다운할 때 어떤 파드부터 먼저 삭제할지에 대한 우선순위를 설정할 수 있다.</p>
<p>이 어노테이션은 파드에 설정되어야 하며, [-2147483647, 2147483647] 범위를 갖는다.
이 어노테이션은 하나의 레플리카셋에 있는 다른 파드와의 상대적 삭제 비용을 나타낸다.
삭제 비용이 낮은 파드는 삭제 비용이 높은 파드보다 삭제 우선순위가 높다.</p>
<p>파드에 대해 이 값을 명시하지 않으면 기본값은 0이다. 음수로도 설정할 수 있다.
유효하지 않은 값은 API 서버가 거부한다.</p>
<p>이 기능은 베타 상태이며 기본적으로 활성화되어 있다.
kube-apiserver와 kube-controller-manager에 대해 <code>PodDeletionCost</code>
<a href=/ko/docs/reference/command-line-tools-reference/feature-gates/>기능 게이트</a>를 이용하여 비활성화할 수 있다.</p>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> <ul>
<li>이 기능은 best-effort 방식으로 동작하므로, 파드 삭제 순서를 보장하지는 않는다.</li>
<li>이 값을 자주 바꾸는 것은 피해야 한다 (예: 메트릭 값에 따라 변경).
apiserver에서 많은 양의 파드 업데이트를 동반하기 때문이다.</li>
</ul>
</div>
<h4 id=사용-예시>사용 예시</h4>
<p>한 애플리케이션 내의 여러 파드는 각각 사용률이 다를 수 있다. 스케일 다운 시,
애플리케이션은 사용률이 낮은 파드를 먼저 삭제하고 싶을 수 있다. 파드를 자주
업데이트하는 것을 피하기 위해, 애플리케이션은 <code>controller.kubernetes.io/pod-deletion-cost</code> 값을
스케일 다운하기 전에 1회만 업데이트해야 한다 (파드 사용률에 비례하는 값으로 설정).
이 방식은 Spark 애플리케이션의 드라이버 파드처럼 애플리케이션이 스스로 다운스케일링을 수행하는 경우에 유효하다.</p>
<h3 id=레플리카셋을-horizontal-pod-autoscaler-대상으로-설정>레플리카셋을 Horizontal Pod Autoscaler 대상으로 설정</h3>
<p>레플리카셋은
<a href=/ko/docs/tasks/run-application/horizontal-pod-autoscale/>Horizontal Pod Autoscalers (HPA)</a>의 대상이 될 수 있다.
즉, 레플리카셋은 HPA에 의해 오토스케일될 수 있다.
다음은 이전에 만든 예시에서 만든 레플리카셋을 대상으로 하는 HPA 예시이다.</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/ko/examples/controllers/hpa-rs.yaml download=controllers/hpa-rs.yaml><code>controllers/hpa-rs.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('controllers-hpa-rs-yaml')" title="Copy controllers/hpa-rs.yaml to clipboard">
</img>
</div>
<div class=includecode id=controllers-hpa-rs-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>autoscaling/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>HorizontalPodAutoscaler<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>frontend-scaler<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>scaleTargetRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ReplicaSet<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>minReplicas</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>maxReplicas</span>:<span style=color:#bbb> </span><span style=color:#666>10</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>targetCPUUtilizationPercentage</span>:<span style=color:#bbb> </span><span style=color:#666>50</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>이 매니페스트를 <code>hpa-rs.yaml</code>로 저장한 다음 쿠버네티스
클러스터에 적용하면 CPU 사용량에 따라 파드가 복제되는
오토스케일 레플리카셋 HPA가 생성된다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/controllers/hpa-rs.yaml
</code></pre></div><p>또는 <code>kubectl autoscale</code> 커맨드을 사용해서 동일한 작업을 할 수 있다.
(그리고 더 쉽다!)</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl autoscale rs frontend --max<span style=color:#666>=</span><span style=color:#666>10</span> --min<span style=color:#666>=</span><span style=color:#666>3</span> --cpu-percent<span style=color:#666>=</span><span style=color:#666>50</span>
</code></pre></div><h2 id=레플리카셋의-대안>레플리카셋의 대안</h2>
<h3 id=디플로이먼트-권장>디플로이먼트(권장)</h3>
<p><a href=/ko/docs/concepts/workloads/controllers/deployment/><code>디플로이먼트</code></a>는 레플리카셋을 소유하거나 업데이트를 하고,
파드의 선언적인 업데이트와 서버측 롤링 업데이트를 할 수 있는 오브젝트이다.
레플리카셋은 단독으로 사용할 수 있지만, 오늘날에는 주로 디플로이먼트로 파드의 생성과 삭제 그리고 업데이트를 오케스트레이션하는 메커니즘으로 사용한다.
디플로이먼트를 이용해서 배포할 때 생성되는 레플리카셋을 관리하는 것에 대해 걱정하지 않아도 된다.
디플로이먼트는 레플리카셋을 소유하거나 관리한다.
따라서 레플리카셋을 원한다면 디플로이먼트를 사용하는 것을 권장한다.</p>
<h3 id=기본-파드>기본 파드</h3>
<p>사용자가 직접 파드를 생성하는 경우와는 다르게, 레플리카셋은 노드 장애 또는 노드의 커널 업그레이드와 같은 관리 목적의 중단 등 어떤 이유로든 종료되거나 삭제된 파드를 교체한다. 이런 이유로 애플리케이션이 단일 파드가 필요하더라도 레플리카셋을 이용하는 것을 권장한다. 레플리카셋을 프로세스 관리자와 비교해서 생각해본다면, 레플리카셋은 단일 노드에서의 개별 프로세스들이 아닌 다수의 노드에 걸쳐있는 다수의 파드를 관리하는 것이다. 레플리카셋은 로컬 컨테이너의 재시작을 노드에 있는 어떤 에이전트에게 위임한다(예를들어 Kubelet 또는 도커).</p>
<h3 id=잡>잡</h3>
<p>스스로 종료되는 것이 예상되는 파드의 경우에는 레플리카셋 대신 <a href=/ko/docs/concepts/workloads/controllers/job/><code>잡</code></a>을 이용한다
(즉, 배치 잡).</p>
<h3 id=데몬셋>데몬셋</h3>
<p>머신 모니터링 또는 머신 로깅과 같은 머신-레벨의 기능을 제공하는 파드를 위해서는 레플리카셋 대신
<a href=/ko/docs/concepts/workloads/controllers/daemonset/><code>데몬셋</code></a>을 사용한다.
이러한 파드의 수명은 머신의 수명과 연관되어 있고, 머신에서 다른 파드가 시작하기 전에 실행되어야 하며,
머신의 재부팅/종료가 준비되었을 때, 해당 파드를 종료하는 것이 안전하다.</p>
<h3 id=레플리케이션-컨트롤러>레플리케이션 컨트롤러</h3>
<p>레플리카셋은 <a href=/ko/docs/concepts/workloads/controllers/replicationcontroller/><em>레플리케이션 컨트롤러</em></a>를 계승하였다.
이 두 개의 용도는 동일하고, 유사하게 동작하며, 레플리케이션 컨트롤러가 <a href=/ko/docs/concepts/overview/working-with-objects/labels/#%EB%A0%88%EC%9D%B4%EB%B8%94-%EC%85%80%EB%A0%89%ED%84%B0>레이블 사용자 가이드</a>에
설명된 설정-기반의 셀렉터의 요건을 지원하지 않는다는 점을 제외하면 유사하다.
따라서 레플리카셋이 레플리케이션 컨트롤러보다 선호된다.</p>
<h2 id=다음-내용>다음 내용</h2>
<ul>
<li><a href=/ko/docs/concepts/workloads/pods>파드</a>에 대해 배운다.</li>
<li><a href=/ko/docs/concepts/workloads/controllers/deployment/>디플로이먼트</a>에 대해 배운다.</li>
<li>레플리카셋에 의존해서 동작하는 <a href=/ko/docs/tasks/run-application/run-stateless-application-deployment/>디플로이먼트로 스테이트리스 애플리케이션을 실행한다</a>.</li>
<li><code>ReplicaSet</code>는 쿠버네티스 REST API의 상위-수준 리소스이다.
레플리카셋 API에 대해 이해하기 위해
<a href=/docs/reference/kubernetes-api/workload-resources/replica-set-v1/>ReplicaSet</a>
오브젝트 정의를 읽는다.</li>
<li><a href=/ko/docs/concepts/workloads/pods/disruptions/>PodDisruptionBudget</a>과
이를 사용해서 어떻게 중단 중에 애플리케이션 가용성을 관리할 수 있는지에 대해 읽는다.</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-6d72299952c37ca8cc61b416e5bdbcd4>4.2.3 - 스테이트풀셋</h1>
<p>스테이트풀셋은 애플리케이션의 스테이트풀을 관리하는데 사용하는 워크로드 API 오브젝트이다.</p>
<p><a class=glossary-tooltip title="파드는 클러스터에서 실행 중인 컨테이너의 집합을 나타낸다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/pods/ target=_blank aria-label=파드>파드</a> 집합의 디플로이먼트와 스케일링을 관리하며, 파드들의 <em>순서 및 고유성을 보장한다</em> .</p>
<p><a class=glossary-tooltip title="클러스터에서 복제된 애플리케이션을 관리한다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/controllers/deployment/ target=_blank aria-label=디플로이먼트>디플로이먼트</a>와 유사하게, 스테이트풀셋은 동일한 컨테이너 스펙을 기반으로 둔 파드들을 관리한다. 디플로이먼트와는 다르게, 스테이트풀셋은 각 파드의 독자성을 유지한다. 이 파드들은 동일한 스팩으로 생성되었지만, 서로 교체는 불가능하다. 다시 말해, 각각은 재스케줄링 간에도 지속적으로 유지되는 식별자를 가진다.</p>
<p>스토리지 볼륨을 사용해서 워크로드에 지속성을 제공하려는 경우, 솔루션의 일부로 스테이트풀셋을 사용할 수 있다. 스테이트풀셋의 개별 파드는 장애에 취약하지만, 퍼시스턴트 파드 식별자는 기존 볼륨을 실패한 볼륨을 대체하는 새 파드에 더 쉽게 일치시킬 수 있다.</p>
<h2 id=스테이트풀셋-사용>스테이트풀셋 사용</h2>
<p>스테이트풀셋은 다음 중 하나 또는 이상이 필요한 애플리케이션에
유용하다.</p>
<ul>
<li>안정된, 고유한 네트워크 식별자.</li>
<li>안정된, 지속성을 갖는 스토리지.</li>
<li>순차적인, 정상 배포(graceful deployment)와 스케일링.</li>
<li>순차적인, 자동 롤링 업데이트.</li>
</ul>
<p>위의 안정은 파드의 (재)스케줄링 전반에 걸친 지속성과 같은 의미이다.
만약 애플리케이션이 안정적인 식별자 또는 순차적인 배포,
삭제 또는 스케일링이 필요하지 않으면, 스테이트리스 레플리카셋(ReplicaSet)을
제공하는 워크로드 오브젝트를 사용해서 애플리케이션을 배포해야 한다.
<a href=/ko/docs/concepts/workloads/controllers/deployment/>디플로이먼트</a> 또는
<a href=/ko/docs/concepts/workloads/controllers/replicaset/>레플리카셋</a>과 같은 컨트롤러가 스테이트리스 요구에 더 적합할 수 있다.</p>
<h2 id=제한사항>제한사항</h2>
<ul>
<li>파드에 지정된 스토리지는 관리자에 의해 <a href=https://github.com/kubernetes/examples/tree/master/staging/persistent-volume-provisioning/README.md>퍼시스턴트 볼륨 프로비저너</a>를 기반으로 하는 <code>storage class</code> 를 요청해서 프로비전하거나 사전에 프로비전이 되어야 한다.</li>
<li>스테이트풀셋을 삭제 또는 스케일 다운해도 스테이트풀셋과 연관된 볼륨이 <em>삭제되지 않는다</em>. 이는 일반적으로 스테이트풀셋과 연관된 모든 리소스를 자동으로 제거하는 것보다 더 중요한 데이터의 안전을 보장하기 위함이다.</li>
<li>스테이트풀셋은 현재 파드의 네트워크 신원을 책임지고 있는 <a href=/ko/docs/concepts/services-networking/service/#%ED%97%A4%EB%93%9C%EB%A6%AC%EC%8A%A4-headless-%EC%84%9C%EB%B9%84%EC%8A%A4>헤드리스 서비스</a>가 필요하다. 사용자가 이 서비스를 생성할 책임이 있다.</li>
<li>스테이트풀셋은 스테이트풀셋의 삭제 시 파드의 종료에 대해 어떠한 보증을 제공하지 않는다. 스테이트풀셋에서는 파드가 순차적이고 정상적으로 종료(graceful termination)되도록 하려면, 삭제 전 스테이트풀셋의 스케일을 0으로 축소할 수 있다.</li>
<li><a href=#%EB%A1%A4%EB%A7%81-%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8>롤링 업데이트</a>와 기본
<a href=#%ED%8C%8C%EB%93%9C-%EB%A7%A4%EB%8B%88%EC%A7%80%EB%A8%BC%ED%8A%B8-%ED%8F%B4%EB%A6%AC%EC%8B%9C>파드 매니지먼트 폴리시</a> (<code>OrderedReady</code>)를
함께 사용시 <a href=#%EA%B0%95%EC%A0%9C-%EB%A1%A4%EB%B0%B1>복구를 위한 수동 개입</a>이
필요한 파손 상태로 빠질 수 있다.</li>
</ul>
<h2 id=구성-요소>구성 요소</h2>
<p>아래의 예시에서는 스테이트풀셋의 구성요소를 보여 준다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>web<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>clusterIP</span>:<span style=color:#bbb> </span>None<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StatefulSet<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>web<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb> </span><span style=color:#080;font-style:italic># .spec.template.metadata.labels 와 일치해야 한다</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>serviceName</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;nginx&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb> </span><span style=color:#080;font-style:italic># 기본값은 1</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>minReadySeconds</span>:<span style=color:#bbb> </span><span style=color:#666>10</span><span style=color:#bbb> </span><span style=color:#080;font-style:italic># 기본값은 0</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb> </span><span style=color:#080;font-style:italic># .spec.selector.matchLabels 와 일치해야 한다</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>terminationGracePeriodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>10</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/nginx-slim:0.8<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>web<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>www<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/usr/share/nginx/html<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumeClaimTemplates</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>www<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb> </span>[<span style=color:#bbb> </span><span style=color:#b44>&#34;ReadWriteOnce&#34;</span><span style=color:#bbb> </span>]<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>storageClassName</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;my-storage-class&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>1Gi<span style=color:#bbb>
</span></code></pre></div><p>위의 예시에서:</p>
<ul>
<li>이름이 nginx라는 헤드리스 서비스는 네트워크 도메인을 컨트롤하는데 사용 한다.</li>
<li>이름이 web인 스테이트풀셋은 3개의 nginx 컨테이너의 레플리카가 고유의 파드에서 구동될 것이라 지시하는 Spec을 갖는다.</li>
<li>volumeClaimTemplates은 퍼시스턴트 볼륨 프로비저너에서 프로비전한 <a href=/ko/docs/concepts/storage/persistent-volumes/>퍼시스턴트 볼륨</a>을 사용해서 안정적인 스토리지를 제공한다.</li>
</ul>
<p>스테이트풀셋 오브젝트의 이름은 유효한
<a href=/ko/docs/concepts/overview/working-with-objects/names/#dns-%EC%84%9C%EB%B8%8C%EB%8F%84%EB%A9%94%EC%9D%B8-%EC%9D%B4%EB%A6%84>DNS 서브도메인 이름</a>이어야 한다.</p>
<h3 id=파드-셀렉터>파드 셀렉터</h3>
<p>스테이트풀셋의 <code>.spec.selector</code> 필드는 <code>.spec.template.metadata.labels</code> 레이블과 일치하도록 설정해야 한다. 1.8 버전 이상에서는, 해당되는 파드 셀렉터를 찾지 못하면 스테이트풀셋 생성 과정에서 검증 오류가 발생한다.</p>
<h3 id=볼륨-클레임-템플릿>볼륨 클레임 템플릿</h3>
<p><code>.spec.volumeClaimTemplates</code> 를 설정하여, 퍼시스턴트볼륨 프로비저너에 의해 프로비전된 <a href=/ko/docs/concepts/storage/persistent-volumes/>퍼시스턴트볼륨</a>을 이용하는 안정적인 스토리지를 제공할 수 있다.</p>
<h3 id=minimum-ready-seconds>최소 준비 시간 초</h3>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.23 [beta]</code>
</div>
<p><code>.spec.minReadySeconds</code> 는 파드가 '사용 가능(available)'이라고 간주될 수 있도록 파드의 모든 컨테이너가
문제 없이 실행되어야 하는 최소 시간(초)을 나타내는 선택적인 필드이다. 이 기능은 베타이며 기본적으로 활성화되어
있음에 유의한다. 이 기능을 사용하지 않으려면 StatefulSetMinReadySeconds 플래그를 설정 해제한다.
이 필드의 기본값은 0이다(이 경우, 파드가 Ready 상태가 되면 바로 사용 가능하다고 간주된다.)
파드가 언제 사용 가능하다고 간주되는지에 대한 자세한 정보는 <a href=/ko/docs/concepts/workloads/pods/pod-lifecycle/#%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88-%ED%94%84%EB%A1%9C%EB%B8%8C-probe>컨테이너 프로브(probe)</a>를 참고한다.</p>
<h2 id=파드-신원>파드 신원</h2>
<p>스테이트풀셋 파드는 순서, 안정적인 네트워크 신원
그리고 안정적인 스토리지로 구성되는 고유한 신원을 가진다.
신원은 파드가 어떤 노드에 있고, (재)스케줄과도 상관없이 파드에 붙어있다.</p>
<h3 id=순서-색인>순서 색인</h3>
<p>N개의 레플리카가 있는 스테이트풀셋은 스테이트풀셋에 있는
각 파드에 0에서 N-1 까지의 정수가 순서대로 할당되며 해당 스테이트풀셋 내에서 고유 하다.</p>
<h3 id=안정적인-네트워크-신원>안정적인 네트워크 신원</h3>
<p>스테이트풀셋의 각 파드는 스테이트풀셋의 이름과 파드의 순번에서
호스트 이름을 얻는다. 호스트 이름을 구성하는 패턴은
<code>$(statefulset name)-$(ordinal)</code> 이다. 위의 예시에서 생성된 3개 파드의 이름은
<code>web-0,web-1,web-2</code> 이다.
스테이트풀셋은 스테이트풀셋에 있는 파드의 도메인을 제어하기위해
<a href=/ko/docs/concepts/services-networking/service/#%ED%97%A4%EB%93%9C%EB%A6%AC%EC%8A%A4-headless-%EC%84%9C%EB%B9%84%EC%8A%A4>헤드리스 서비스</a>를 사용할 수 있다.
이 서비스가 관리하는 도메인은 <code>$(service name).$(namespace).svc.cluster.local</code> 의 형식을 가지며,
여기서 "cluster.local"은 클러스터 도메인이다.
각 파드는 생성되면 <code>$(podname).$(governing service domain)</code> 형식을 가지고
일치되는 DNS 서브도메인을 가지며, 여기서 거버닝 서비스(governing service)는
스테이트풀셋의 <code>serviceName</code> 필드에 의해 정의된다.</p>
<p>클러스터에서 DNS가 구성된 방식에 따라, 새로 실행된 파드의 DNS 이름을
즉시 찾지 못할 수 있다. 이 동작은 클러스터의 다른 클라이언트가
파드가 생성되기 전에 파드의 호스트 이름에 대한 쿼리를 이미 보낸 경우에 발생할 수 있다.
네거티브 캐싱(DNS에서 일반적)은 이전에 실패한 조회 결과가
파드가 실행된 후에도 적어도 몇 초 동안 기억되고 재사용됨을 의미한다.</p>
<p>파드를 생성한 후 즉시 파드를 검색해야 하는 경우, 몇 가지 옵션이 있다.</p>
<ul>
<li>DNS 조회에 의존하지 않고 쿠버네티스 API를 직접(예를 들어 watch 사용) 쿼리한다.</li>
<li>쿠버네티스 DNS 공급자의 캐싱 시간(일반적으로 CoreDNS의 컨피그맵을 편집하는 것을 의미하며, 현재 30초 동안 캐시함)을 줄인다.</li>
</ul>
<p><a href=#%EC%A0%9C%ED%95%9C%EC%82%AC%ED%95%AD>제한사항</a> 섹션에서 언급한 것처럼 사용자는
파드의 네트워크 신원을 책임지는
<a href=/ko/docs/concepts/services-networking/service/#%ED%97%A4%EB%93%9C%EB%A6%AC%EC%8A%A4-headless-%EC%84%9C%EB%B9%84%EC%8A%A4>헤드리스 서비스</a>를 생성할 책임이 있다.</p>
<p>여기 클러스터 도메인, 서비스 이름, 스테이트풀셋 이름을 선택을 하고,
그 선택이 스테이트풀셋 파드의 DNS이름에 어떻게 영향을 주는지에 대한 약간의 예시가 있다.</p>
<table>
<thead>
<tr>
<th>클러스터 도메인</th>
<th>서비스 (ns/이름)</th>
<th>스테이트풀셋 (ns/이름)</th>
<th>스테이트풀셋 도메인</th>
<th>파드 DNS</th>
<th>파드 호스트 이름</th>
</tr>
</thead>
<tbody>
<tr>
<td>cluster.local</td>
<td>default/nginx</td>
<td>default/web</td>
<td>nginx.default.svc.cluster.local</td>
<td>web-{0..N-1}.nginx.default.svc.cluster.local</td>
<td>web-{0..N-1}</td>
</tr>
<tr>
<td>cluster.local</td>
<td>foo/nginx</td>
<td>foo/web</td>
<td>nginx.foo.svc.cluster.local</td>
<td>web-{0..N-1}.nginx.foo.svc.cluster.local</td>
<td>web-{0..N-1}</td>
</tr>
<tr>
<td>kube.local</td>
<td>foo/nginx</td>
<td>foo/web</td>
<td>nginx.foo.svc.kube.local</td>
<td>web-{0..N-1}.nginx.foo.svc.kube.local</td>
<td>web-{0..N-1}</td>
</tr>
</tbody>
</table>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> 클러스터 도메인이 달리 <a href=/ko/docs/concepts/services-networking/dns-pod-service/>구성된 경우</a>가
아니라면 <code>cluster.local</code>로 설정된다.
</div>
<h3 id=안정된-스토리지>안정된 스토리지</h3>
<p>쿠버네티스는 각 VolumeClaimTemplate마다 하나의 <a href=/ko/docs/concepts/storage/persistent-volumes/>퍼시스턴트 볼륨</a>을 생성한다. 위의 nginx 예시에서 각 파드는 <code>my-storage-class</code> 라는 스토리지 클래스와 1 Gib의 프로비전된 스토리지를 가지는 단일 퍼시스턴트 볼륨을 받게 된다. 만약 스토리지 클래스가
명시되지 않은 경우, 기본 스토리지 클래스가 사용된다. 파드가 노드에서 스케줄 혹은 재스케줄이 되면
파드의 <code>volumeMounts</code> 는 퍼시스턴트 볼륨 클레임과 관련된 퍼시스턴트 볼륨이 마운트 된다.
참고로, 파드 퍼시스턴트 볼륨 클레임과 관련된 퍼시스턴트 볼륨은
파드 또는 스테이트풀셋이 삭제되더라도 삭제되지 않는다.
이것은 반드시 수동으로 해야 한다.</p>
<h3 id=파드-이름-레이블>파드 이름 레이블</h3>
<p>스테이트풀셋 <a class=glossary-tooltip title="API 서버를 통해 클러스터의 공유된 상태를 감시하고, 현재 상태를 원하는 상태로 이행시키는 컨트롤 루프." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/architecture/controller/ target=_blank aria-label=컨트롤러(Controller)>컨트롤러(Controller)</a>
가 파드를 생성할 때 파드 이름으로 <code>statefulset.kubernetes.io/pod-name</code>
레이블이 추가된다. 이 레이블로 스테이트풀셋의 특정 파드에 서비스를
연결할 수 있다.</p>
<h2 id=디플로이먼트와-스케일링-보증>디플로이먼트와 스케일링 보증</h2>
<ul>
<li>N개의 레플리카가 있는 스테이트풀셋이 파드를 배포할 때 연속해서 {0..N-1}의 순서로 생성한다.</li>
<li>파드가 삭제될 때는 {N-1..0}의 순서인 역순으로 종료된다.</li>
<li>파드에 스케일링 작업을 적용하기 전에 모든 선행 파드가 Running 및 Ready 상태여야 한다.</li>
<li>파드가 종료되기 전에 모든 후속 파드가 완전히 종료 되어야 한다.</li>
</ul>
<p>스테이트풀셋은 <code>pod.Spec.TerminationGracePeriodSeconds</code> 을 0으로 명시해서는 안된다. 이 방법은 안전하지 않으며, 사용하지 않기를 강권한다. 자세한 설명은 <a href=/ko/docs/tasks/run-application/force-delete-stateful-set-pod/>스테이트풀셋 파드 강제 삭제</a>를 참고한다.</p>
<p>위의 nginx 예시가 생성될 때 web-0, web-1, web-2 순서로 3개 파드가
배포된다. web-1은 web-0이
<a href=/ko/docs/concepts/workloads/pods/pod-lifecycle/>Running 및 Ready</a> 상태가 되기 전에는 배포되지 않으며,
web-2 도 web-1이 Running 및 Ready 상태가 되기 전에는 배포되지 않는다. 만약 web-1이 Running 및 Ready 상태가 된 이후,
web-2가 시작되기 전에 web-0이 실패하게 된다면, web-2는 web-0이 성공적으로 재시작이되고,
Running 및 Ready 상태가 되기 전까지 시작되지 않는다.</p>
<p>만약 사용자가 배포된 예제의 스테이트풀셋을 <code>replicas=1</code> 으로 패치해서
스케일한 경우 web-2가 먼저 종료된다. web-1은 web-2가 완전히 종료 및 삭제되기
전까지 정지되지 않는다. 만약 web-2의 종료 및 완전히 중지되고, web-1이 종료되기 전에
web-0이 실패할 경우 web-1은 web-0이 Running 및 Ready 상태가
되기 전까지 종료되지 않는다.</p>
<h3 id=파드-관리-정책>파드 관리 정책</h3>
<p>쿠버네티스 1.7 및 이후에는 스테이트풀셋의 <code>.spec.podManagementPolicy</code> 필드를
통해 고유성 및 신원 보증을 유지하면서 순차 보증을 완화한다.</p>
<h4 id=orderedready-파드-관리>OrderedReady 파드 관리</h4>
<p><code>OrderedReady</code> 파드 관리는 스테이트풀셋의 기본이다.
이것은 <a href=#%EB%94%94%ED%94%8C%EB%A1%9C%EC%9D%B4%EB%A8%BC%ED%8A%B8%EC%99%80-%EC%8A%A4%EC%BC%80%EC%9D%BC-%EB%B3%B4%EC%A6%9D>위에서</a> 설명한 행위를 구현한다.</p>
<h4 id=parallel-파드-관리>Parallel 파드 관리</h4>
<p><code>Parallel</code> 파드 관리는 스테이트풀셋 컨트롤러에게 모든 파드를
병렬로 실행 또는 종료하게 한다. 그리고 다른 파드의 실행이나
종료에 앞서 파드가 Running 및 Ready 상태가 되거나 완전히 종료되기를 기다리지 않는다.
이 옵션은 오직 스케일링 작업에 대한 동작에만 영향을 미친다. 업데이트는 영향을
받지 않는다.</p>
<h2 id=업데이트-전략>업데이트 전략</h2>
<p>스테이트풀셋의 <code>.spec.updateStrategy</code> 필드는 스테이트풀셋의
파드에 대한 컨테이너, 레이블, 리소스의 요청/제한 그리고 주석에 대한 자동화된 롤링 업데이트를
구성하거나 비활성화할 수 있다. 두 가지 가능한 전략이 있다.</p>
<dl>
<dt><code>OnDelete</code>(삭제시)</dt>
<dd>스테이트풀셋의 <code>.spec.updateStrategy.type</code> 은 <code>OnDelete</code> 를 설정하며,
스테이트풀셋 컨트롤러는 스테이트풀셋의 파드를 자동으로 업데이트하지 않는다.
사용자는 컨트롤러가 스테이트풀셋의
<code>.spec.template</code>를 반영하는 수정된 새로운 파드를 생성하도록 수동으로 파드를 삭제해야 한다.</dd>
<dt><code>RollingUpdate</code>(롤링 업데이트)</dt>
<dd><code>롤링 업데이트</code> 의 업데이트 전략은 스테이트풀셋의 파드에 대한 롤링 업데이트를
구현한다. 롤링 업데이트는 <code>.spec.updateStrategy</code> 가 지정되지 않으면 기본 전략이 된다.</dd>
</dl>
<h2 id=롤링-업데이트>롤링 업데이트</h2>
<p>스테이트풀셋에 <code>롤링 업데이트</code> 가 <code>.spec.updateStrategy.type</code> 에 설정되면
스테이트풀셋 컨트롤러는 스테이트풀셋의 각 파드를 삭제 및 재생성한다. 이 과정에서 똑같이
순차적으로 파드가 종료되고(가장 큰 순서 색인에서부터에서 작은 순서 색인쪽으로),
각 파드의 업데이트는 한 번에 하나씩 한다.</p>
<p>쿠버네티스 컨트롤 플레인은 이전 버전을 업데이트 하기 전에, 업데이트된 파드가 실행 및 준비될 때까지 기다린다.
<code>.spec.minReadySeconds</code>(<a href=#minimum-ready-seconds>최소 준비 시간 초</a> 참조)를 설정한 경우, 컨트롤 플레인은 파드가 준비 상태로 전환된 후 해당 시간을 추가로 기다린 후 이동한다.</p>
<h3 id=partitions>파티션 롤링 업데이트</h3>
<p><code>롤링 업데이트</code> 의 업데이트 전략은 <code>.spec.updateStrategy.rollingUpdate.partition</code>
를 명시해서 파티션 할 수 있다. 만약 파티션을 명시하면 스테이트풀셋의 <code>.spec.template</code> 가
업데이트 될 때 부여된 수가 파티션보다 크거나 같은 모든 파드가 업데이트 된다.
파티션보다 작은 수를 가진 모든 파드는 업데이트 되지 않으며,
삭제 된 경우라도 이전 버전에서 재생성된다.
만약 스테이트풀셋의 <code>.spec.updateStrategy.rollingUpdate.partition</code> 이
<code>.spec.replicas</code> 보다 큰 경우 <code>.spec.template</code> 의 업데이트는 해당 파드에 전달하지 않는다.
대부분의 케이스는 파티션을 사용할 필요가 없지만 업데이트를 준비하거나,
카나리의 롤 아웃 또는 단계적인 롤 아웃을 행하려는 경우에는 유용하다.</p>
<h3 id=강제-롤백>강제 롤백</h3>
<p>기본 <a href=#%ED%8C%8C%EB%93%9C-%EA%B4%80%EB%A6%AC-%EC%A0%95%EC%B1%85>파드 관리 정책</a> (<code>OrderedReady</code>)과
함께 <a href=#%EB%A1%A4%EB%A7%81-%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8>롤링 업데이트</a>를 사용할 경우
직접 수동으로 복구를 해야하는 고장난 상태가 될 수 있다.</p>
<p>만약 파드 템플릿을 Running 및 Ready 상태가 되지 않는 구성으로 업데이트하는
경우(예시: 잘못된 바이너리 또는 애플리케이션-레벨 구성 오류로 인한)
스테이트풀셋은 롤아웃을 중지하고 기다린다.</p>
<p>이 상태에서는 파드 템플릿을 올바른 구성으로 되돌리는 것으로 충분하지 않다.
<a href=https://github.com/kubernetes/kubernetes/issues/67250>알려진 이슈</a>로
인해 스테이트풀셋은 손상된 파드가 준비(절대 되지 않음)될 때까지 기다리며
작동하는 구성으로 되돌아가는 시도를 하기
전까지 기다린다.</p>
<p>템플릿을 되돌린 이후에는 스테이트풀셋이 이미 잘못된 구성으로
실행하려고 시도한 모든 파드를 삭제해야 한다.
그러면 스테이트풀셋은 되돌린 템플릿을 사용해서 파드를 다시 생성하기 시작한다.</p>
<h2 id=퍼시스턴트볼륨클레임-유보>퍼시스턴트볼륨클레임 유보</h2>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.23 [alpha]</code>
</div>
<p>선택적 필드인 <code>.spec.persistentVolumeClaimRetentionPolicy</code> 는
스테이트풀셋의 생애주기동안 PVC를 삭제할 것인지,
삭제한다면 어떻게 삭제하는지를 관리한다.
이 필드를 사용하려면 <code>StatefulSetAutoDeletePVC</code> <a href=/ko/docs/reference/command-line-tools-reference/feature-gates/>기능 게이트</a>를 활성화해야 한다.
활성화 시, 각 스테이트풀셋에 대해 두 가지 정책을 설정할 수 있다.</p>
<dl>
<dt><code>whenDeleted</code></dt>
<dd>스테이트풀셋이 삭제될 때 적용될 볼륨 유보 동작을 설정한다.</dd>
<dt><code>whenScaled</code></dt>
<dd>스테이트풀셋의 레플리카 수가 줄어들 때, 예를 들면 스테이트풀셋을 스케일 다운할 때
적용될 볼륨 유보 동작을 설정한다.</dd>
</dl>
<p>설정 가능한 각 정책에 대해, 그 값을 <code>Delete</code> 또는 <code>Retain</code> 으로 설정할 수 있다.</p>
<dl>
<dt><code>Delete</code></dt>
<dd><code>volumeClaimTemplate</code> 스테이트풀셋으로부터 생성된 PVC는 정책에 영향을 받는 각 파드에 대해 삭제된다.
<code>whenDeleted</code> 가 이 값으로 설정되어 있으면
<code>volumeClaimTemplate</code> 으로부터 생성된 모든 PVC는 파드가 삭제된 뒤에 삭제된다.
<code>whenScaled</code> 가 이 값으로 설정되어 있으면
스케일 다운된 파드 레플리카가 삭제된 뒤, 삭제된 파드에 해당되는 PVC만 삭제된다.</dd>
<dt><code>Retain</code> (기본값)</dt>
<dd>파드가 삭제되어도 <code>volumeClaimTemplate</code> 으로부터 생성된 PVC는 영향을 받지 않는다.
이는 이 신기능이 도입되기 전의 기본 동작이다.</dd>
</dl>
<p>이러한 정책은 파드의 삭제가 스테이트풀셋 삭제 또는 스케일 다운으로 인한 것일 때<strong>에만</strong> 적용됨에 유의한다.
예를 들어, 스테이트풀셋의 파드가 노드 실패로 인해 실패했고,
컨트롤 플레인이 대체 파드를 생성했다면, 스테이트풀셋은 기존 PVC를 유지한다.
기존 볼륨은 영향을 받지 않으며,
새 파드가 실행될 노드에 클러스터가 볼륨을 연결(attach)한다.</p>
<p>정책의 기본값은 <code>Retain</code> 이며, 이는 이 신기능이 도입되기 전의 스테이트풀셋 기본 동작이다.</p>
<p>다음은 정책 예시이다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StatefulSet<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>persistentVolumeClaimRetentionPolicy</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>whenDeleted</span>:<span style=color:#bbb> </span>Retain<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>whenScaled</span>:<span style=color:#bbb> </span>Delete<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></code></pre></div><p>스테이트풀셋 <a class=glossary-tooltip title="API 서버를 통해 클러스터의 공유된 상태를 감시하고, 현재 상태를 원하는 상태로 이행시키는 컨트롤 루프." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/architecture/controller/ target=_blank aria-label=컨트롤러>컨트롤러</a>는 자신이 소유한 PVC에
<a href=/docs/concepts/overview/working-with-objects/owners-dependents/#owner-references-in-object-specifications>소유자 정보(reference)</a>를
추가하며, 파드가 종료된 이후에는 <a class=glossary-tooltip title="쿠버네티스가 클러스터 자원을 정리하기 위해 사용하는 다양한 방법을 종합한 용어이다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/architecture/garbage-collection/ target=_blank aria-label="가비지 콜렉터">가비지 콜렉터</a>가 이 정보를 삭제한다.
이로 인해 PVC가 삭제되기 전에
(그리고 유보 정책에 따라, 매칭되는 기반 PV와 볼륨이 삭제되기 전에)
파드가 모든 볼륨을 깨끗하게 언마운트할 수 있다.
<code>whenDeleted</code> 정책을 <code>Delete</code> 로 설정하면,
해당 스테이트풀셋에 연결된 모든 PVC에 스테이트풀셋 인스턴스의 소유자 정보가 기록된다.</p>
<p><code>whenScaled</code> 정책은 파드가 스케일 다운되었을 때에만 PVC를 삭제하며,
파드가 다른 원인으로 삭제되면 PVC를 삭제하지 않는다.
조정 상황 발생 시, 스테이트풀셋 컨트롤러는 목표 레플리카 수와 클러스터 상의 실제 파드 수를 비교한다.
레플리카 카운트보다 큰 ID를 갖는 스테이트풀셋 파드는 부적격 판정을 받으며 삭제 대상으로 표시된다.
<code>whenScaled</code> 정책이 <code>Delete</code> 이면, 부적격 파드는 삭제되기 전에,
연결된 스테이트풀셋 템플릿 PVC의 소유자로 지정된다.
이로 인해, 부적격 파드가 종료된 이후에만 PVC가 가비지 콜렉트된다.</p>
<p>이는 곧 만약 컨트롤러가 강제 종료되어 재시작되면,
파드의 소유자 정보가 정책에 적합하게 업데이트되기 전에는 어떤 파드도 삭제되지 않을 것임을 의미한다.
만약 컨트롤러가 다운된 동안 부적격 파드가 강제로 삭제되면,
컨트롤러가 강제 종료된 시점에 따라 소유자 정보가 설정되었을 수도 있고 설정되지 않았을 수도 있다.
소유자 정보가 업데이트되기까지 몇 번의 조정 절차가 필요할 수 있으며,
따라서 일부 부적격 파드는 소유자 정보 설정을 완료하고 나머지는 그러지 못했을 수 있다.
이러한 이유로, 컨트롤러가 다시 켜져서 파드를 종료하기 전에
소유자 정보를 검증할 때까지 기다리는 것을 추천한다.
이것이 불가능하다면, 관리자는 PVC의 소유자 정보를 확인하여 파드가 강제 삭제되었을 때 해당되는 오브젝트가 삭제되도록 해야 한다.</p>
<h3 id=레플리카>레플리카</h3>
<p><code>.spec.replicas</code> 은 필요한 파드의 수를 지정하는 선택적 필드이다. 기본값은 1이다.</p>
<p>예를 들어 <code>kubectl scale deployment deployment --replicas=X</code> 명령으로
디플로이먼트의 크기를 수동으로 조정한 뒤,
매니페스트를 이용하여 디플로이먼트를 업데이트하면(예: <code>kubectl apply -f deployment.yaml</code> 실행),
수동으로 설정했던 디플로이먼트의 크기가
오버라이드된다.</p>
<p><a href=/ko/docs/tasks/run-application/horizontal-pod-autoscale/>HorizontalPodAutoscaler</a>(또는 수평 스케일링을 위한 유사 API)가
디플로이먼트 크기를 관리하고 있다면, <code>.spec.replicas</code> 를 설정해서는 안 된다.
대신, 쿠버네티스
<a class=glossary-tooltip title="컨테이너의 라이프사이클을 정의, 배포, 관리하기 위한 API와 인터페이스들을 노출하는 컨테이너 오케스트레이션 레이어." data-toggle=tooltip data-placement=top href="/ko/docs/reference/glossary/?all=true#term-control-plane" target=_blank aria-label="컨트롤 플레인">컨트롤 플레인</a>이
<code>.spec.replicas</code> 필드를 자동으로 관리한다.</p>
<h2 id=다음-내용>다음 내용</h2>
<ul>
<li><a href=/ko/docs/concepts/workloads/pods>파드</a>에 대해 배운다.</li>
<li>스테이트풀셋을 사용하는 방법을 알아본다.
<ul>
<li><a href=/ko/docs/tutorials/stateful-application/basic-stateful-set/>스테이트풀셋 애플리케이션 배포</a> 예제를 따라한다.</li>
<li><a href=/ko/docs/tutorials/stateful-application/cassandra/>스테이트풀셋으로 카산드라 배포</a> 예제를 따라한다.</li>
<li><a href=/docs/tasks/run-application/run-replicated-stateful-application/>복제된 스테이트풀셋 애플리케이션 구동하기</a> 예제를 따라한다.</li>
<li><a href=/ko/docs/tasks/run-application/scale-stateful-set/>스테이트풀셋 확장하기</a>에 대해 배운다.</li>
<li><a href=/ko/docs/tasks/run-application/delete-stateful-set/>스테이트풀셋을 삭제하면</a> 어떤 일이 수반되는지를 배운다.</li>
<li><a href=/ko/docs/tasks/configure-pod-container/configure-volume-storage/>스토리지의 볼륨을 사용하는 파드 구성</a>을 하는 방법을 배운다.</li>
<li><a href=/ko/docs/tasks/configure-pod-container/configure-persistent-volume-storage/>스토리지로 퍼시스턴트볼륨(PersistentVolume)을 사용하도록 파드 설정</a>하는 방법을 배운다.</li>
</ul>
</li>
<li><code>StatefulSet</code>은 쿠버네티스 REST API의 상위-수준 리소스이다.
스테이트풀셋 API에 대해 이해하기 위해
<a href=/docs/reference/kubernetes-api/workload-resources/stateful-set-v1/>StatefulSet</a> 오브젝트 정의를 읽는다.</li>
<li><a href=/ko/docs/concepts/workloads/pods/disruptions/>PodDisruptionBudget</a>과
이를 사용해서 어떻게 중단 중에 애플리케이션 가용성을 관리할 수 있는지에 대해 읽는다.</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-41600eb8b6631c88848156f381e9d588>4.2.4 - 데몬셋</h1>
<p><em>데몬셋</em> 은 모든(또는 일부) 노드가 파드의 사본을 실행하도록 한다. 노드가 클러스터에 추가되면
파드도 추가된다. 노드가 클러스터에서 제거되면 해당 파드는 가비지(garbage)로
수집된다. 데몬셋을 삭제하면 데몬셋이 생성한 파드들이 정리된다.</p>
<p>데몬셋의 일부 대표적인 용도는 다음과 같다.</p>
<ul>
<li>모든 노드에서 클러스터 스토리지 데몬 실행</li>
<li>모든 노드에서 로그 수집 데몬 실행</li>
<li>모든 노드에서 노드 모니터링 데몬 실행</li>
</ul>
<p>단순한 케이스에서는, 각 데몬 유형의 처리를 위해서 모든 노드를 커버하는 하나의 데몬셋이 사용된다.
더 복잡한 구성에서는 단일 유형의 데몬에 여러 데몬셋을 사용할 수 있지만,
각기 다른 하드웨어 유형에 따라 서로 다른 플래그, 메모리, CPU 요구가 달라진다.</p>
<h2 id=데몬셋-사양-작성>데몬셋 사양 작성</h2>
<h3 id=데몬셋-생성>데몬셋 생성</h3>
<p>YAML 파일에 데몬셋 명세를 작성할 수 있다. 예를 들어 아래 <code>daemonset.yaml</code> 파일은
fluentd-elasticsearch 도커 이미지를 실행하는 데몬셋을 설명한다.</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/ko/examples/controllers/daemonset.yaml download=controllers/daemonset.yaml><code>controllers/daemonset.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('controllers-daemonset-yaml')" title="Copy controllers/daemonset.yaml to clipboard">
</img>
</div>
<div class=includecode id=controllers-daemonset-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>DaemonSet<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>fluentd-elasticsearch<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>kube-system<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>k8s-app</span>:<span style=color:#bbb> </span>fluentd-logging<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>fluentd-elasticsearch<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>fluentd-elasticsearch<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>tolerations</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># this toleration is to have the daemonset runnable on master nodes</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># remove it if your masters can&#39;t run pods</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>node-role.kubernetes.io/master<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span>Exists<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>effect</span>:<span style=color:#bbb> </span>NoSchedule<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>fluentd-elasticsearch<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>quay.io/fluentd_elasticsearch/fluentd:v2.5.2<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>200Mi<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span>100m<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>200Mi<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>varlog<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/var/log<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>varlibdockercontainers<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/var/lib/docker/containers<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>terminationGracePeriodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>30</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>varlog<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>hostPath</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/var/log<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>varlibdockercontainers<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>hostPath</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/var/lib/docker/containers<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>YAML 파일을 기반으로 데몬셋을 생성한다.</p>
<pre><code>kubectl apply -f https://k8s.io/examples/controllers/daemonset.yaml
</code></pre><h3 id=필수-필드>필수 필드</h3>
<p>다른 모든 쿠버네티스 설정과 마찬가지로 데몬셋에는 <code>apiVersion</code>, <code>kind</code> 그리고 <code>metadata</code> 필드가 필요하다.
일반적인 설정파일 작업에 대한 정보는
<a href=/ko/docs/tasks/run-application/run-stateless-application-deployment/>스테이트리스 애플리케이션 실행하기</a>와
<a href=/ko/docs/concepts/overview/working-with-objects/object-management/>kubectl을 사용한 오브젝트 관리</a>를 참고한다.</p>
<p>데몬셋 오브젝트의 이름은 유효한
<a href=/ko/docs/concepts/overview/working-with-objects/names/#dns-%EC%84%9C%EB%B8%8C%EB%8F%84%EB%A9%94%EC%9D%B8-%EC%9D%B4%EB%A6%84>DNS 서브도메인 이름</a>이어야 한다.</p>
<p>데몬셋에는
<a href=https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status><code>.spec</code></a>
섹션도 필요하다.</p>
<h3 id=파드-템플릿>파드 템플릿</h3>
<p><code>.spec.template</code> 는 <code>.spec</code> 의 필수 필드 중 하나이다.</p>
<p><code>.spec.template</code> 는 <a href=/ko/docs/concepts/workloads/pods/#%ED%8C%8C%EB%93%9C-%ED%85%9C%ED%94%8C%EB%A6%BF>파드 템플릿</a>이다.
이것은 중첩되어 있다는 점과 <code>apiVersion</code> 또는 <code>kind</code> 를 가지지 않는 것을 제외하면
<a class=glossary-tooltip title="파드는 클러스터에서 실행 중인 컨테이너의 집합을 나타낸다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/pods/ target=_blank aria-label=파드>파드</a>와 정확히 같은 스키마를 가진다.</p>
<p>데몬셋의 파드 템플릿에는 파드의 필수 필드 외에도 적절한 레이블이 명시되어야
한다(<a href=#%ED%8C%8C%EB%93%9C-%EC%85%80%EB%A0%89%ED%84%B0>파드 셀렉터</a>를 본다).</p>
<p>데몬셋의 파드 템플릿의 <a href=/ko/docs/concepts/workloads/pods/pod-lifecycle/#%EC%9E%AC%EC%8B%9C%EC%9E%91-%EC%A0%95%EC%B1%85><code>RestartPolicy</code></a>는 <code>Always</code> 를 가져야 하며,
명시되지 않은 경우 기본으로 <code>Always</code>가 된다.</p>
<h3 id=파드-셀렉터>파드 셀렉터</h3>
<p><code>.spec.selector</code> 필드는 파드 셀렉터이다. 이것은
<a href=/ko/docs/concepts/workloads/controllers/job/>잡</a>의 <code>.spec.selector</code> 와 같은 동작을 한다.</p>
<p>쿠버네티스 1.8 부터는 레이블이 <code>.spec.template</code> 와 일치하는 파드 셀렉터를 명시해야 한다.
파드 셀렉터는 비워두면 더 이상 기본 값이 설정이 되지 않는다.
셀렉터의 기본 값은 <code>kubectl apply</code> 과 호환되지 않는다.
또한, 한 번 데몬셋이 만들어지면 <code>.spec.selector</code> 의 변형은 가능하지 않다.
파드 셀렉터를 변형하면 의도하지 않게 파드는 고아가 되거나 사용자에게 혼란을 주는 것으로 밝혀졌다.</p>
<p><code>.spec.selector</code> 는 다음 2개의 필드로 구성된 오브젝트이다.</p>
<ul>
<li><code>matchLabels</code> - <a href=/ko/docs/concepts/workloads/controllers/replicationcontroller/>레플리케이션 컨트롤러</a>의
<code>.spec.selector</code> 와 동일하게 작동한다.</li>
<li><code>matchExpressions</code> - 키, 값 목록 그리고 키 및 값에 관련된 연산자를
명시해서 보다 정교한 셀렉터를 만들 수 있다.</li>
</ul>
<p>2개의 필드가 명시되면 두 필드를 모두 만족하는 것(ANDed)이 결과가 된다.</p>
<p>만약 <code>.spec.selector</code> 를 명시하면, 이것은 <code>.spec.template.metadata.labels</code> 와 일치해야 한다.
일치하지 않는 구성은 API에 의해 거부된다.</p>
<h3 id=오직-일부-노드에서만-파드-실행>오직 일부 노드에서만 파드 실행</h3>
<p>만약 <code>.spec.template.spec.nodeSelector</code> 를 명시하면 데몬셋 컨트롤러는
<a href=/ko/docs/concepts/scheduling-eviction/assign-pod-node/#%EB%85%B8%EB%93%9C-%EC%85%80%EB%A0%89%ED%84%B0-nodeselector>노드 셀렉터</a>와
일치하는 노드에 파드를 생성한다.
마찬가지로 <code>.spec.template.spec.affinity</code> 를 명시하면
데몬셋 컨트롤러는 <a href=/ko/docs/concepts/scheduling-eviction/assign-pod-node/#%EB%85%B8%EB%93%9C-%EC%96%B4%ED%94%BC%EB%8B%88%ED%8B%B0>노드 어피니티</a>와 일치하는 노드에 파드를 생성한다.
만약 둘 중 하나를 명시하지 않으면 데몬셋 컨트롤러는 모든 노드에서 파드를 생성한다.</p>
<h2 id=데몬-파드가-스케줄-되는-방법>데몬 파드가 스케줄 되는 방법</h2>
<h3 id=기본-스케줄러로-스케줄>기본 스케줄러로 스케줄</h3>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.23 [stable]</code>
</div>
<p>데몬셋은 자격이 되는 모든 노드에서 파드 사본이 실행하도록 보장한다. 일반적으로
쿠버네티스 스케줄러에 의해 파드가 실행되는 노드가 선택된다. 그러나
데몬셋 파드는 데몬셋 컨트롤러에 의해 생성되고 스케줄된다.
이에 대한 이슈를 소개한다.</p>
<ul>
<li>파드 동작의 불일치: 스케줄 되기 위해서 대기 중인 일반 파드는 <code>Pending</code> 상태로 생성된다.
그러나 데몬셋 파드는 <code>Pending</code> 상태로 생성되지 않는다.
이것은 사용자에게 혼란을 준다.</li>
<li><a href=/ko/docs/concepts/scheduling-eviction/pod-priority-preemption/>파드 선점</a>은
기본 스케줄러에서 처리한다. 선점이 활성화되면 데몬셋 컨트롤러는
파드 우선순위와 선점을 고려하지 않고 스케줄 한다.</li>
</ul>
<p><code>ScheduleDaemonSetPods</code> 로 데몬셋 파드에 <code>.spec.nodeName</code> 용어 대신
<code>NodeAffinity</code> 용어를 추가해서 데몬셋 컨트롤러 대신 기본
스케줄러를 사용해서 데몬셋을 스케줄할 수 있다. 이후에 기본
스케줄러를 사용해서 대상 호스트에 파드를 바인딩한다. 만약 데몬셋 파드에
이미 노드 선호도가 존재한다면 교체한다(대상 호스트를 선택하기 전에
원래 노드의 어피니티가 고려된다). 데몬셋 컨트롤러는
데몬셋 파드를 만들거나 수정할 때만 이런 작업을 수행하며,
데몬셋의 <code>spec.template</code> 은 변경되지 않는다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>nodeAffinity</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>requiredDuringSchedulingIgnoredDuringExecution</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>nodeSelectorTerms</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>matchFields</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>metadata.name<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span>In<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>values</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- target-host-name<span style=color:#bbb>
</span></code></pre></div><p>또한, 데몬셋 파드에 <code>node.kubernetes.io/unschedulable:NoSchedule</code> 이 톨러레이션(toleration)으로
자동으로 추가된다. 기본 스케줄러는 데몬셋 파드를
스케줄링시 <code>unschedulable</code> 노드를 무시한다.</p>
<h3 id=테인트-taints-와-톨러레이션-tolerations>테인트(taints)와 톨러레이션(tolerations)</h3>
<p>데몬 파드는
<a href=/ko/docs/concepts/scheduling-eviction/taint-and-toleration/>테인트와 톨러레이션</a>을 존중하지만,
다음과 같이 관련 기능에 따라 자동적으로 데몬셋 파드에
톨러레이션을 추가한다.</p>
<table>
<thead>
<tr>
<th>톨러레이션 키</th>
<th>영향</th>
<th>버전</th>
<th>설명</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>node.kubernetes.io/not-ready</code></td>
<td>NoExecute</td>
<td>1.13+</td>
<td>네트워크 파티션과 같은 노드 문제가 발생해도 데몬셋 파드는 축출되지 않는다.</td>
</tr>
<tr>
<td><code>node.kubernetes.io/unreachable</code></td>
<td>NoExecute</td>
<td>1.13+</td>
<td>네트워크 파티션과 같은 노드 문제가 발생해도 데몬셋 파드는 축출되지 않는다.</td>
</tr>
<tr>
<td><code>node.kubernetes.io/disk-pressure</code></td>
<td>NoSchedule</td>
<td>1.8+</td>
<td>데몬셋 파드는 기본 스케줄러에서 디스크-압박(disk-pressure) 속성을 허용한다.</td>
</tr>
<tr>
<td><code>node.kubernetes.io/memory-pressure</code></td>
<td>NoSchedule</td>
<td>1.8+</td>
<td>데몬셋 파드는 기본 스케줄러에서 메모리-압박(memory-pressure) 속성을 허용한다.</td>
</tr>
<tr>
<td><code>node.kubernetes.io/unschedulable</code></td>
<td>NoSchedule</td>
<td>1.12+</td>
<td>데몬셋 파드는 기본 스케줄러의 스케줄할 수 없는(unschedulable) 속성을 극복한다.</td>
</tr>
<tr>
<td><code>node.kubernetes.io/network-unavailable</code></td>
<td>NoSchedule</td>
<td>1.12+</td>
<td>호스트 네트워크를 사용하는 데몬셋 파드는 기본 스케줄러에 의해 이용할 수 없는 네트워크(network-unavailable) 속성을 극복한다.</td>
</tr>
</tbody>
</table>
<h2 id=데몬-파드와-통신>데몬 파드와 통신</h2>
<p>데몬셋의 파드와 통신할 수 있는 몇 가지 패턴은 다음과 같다.</p>
<ul>
<li><strong>푸시(Push)</strong>: 데몬셋의 파드는 통계 데이터베이스와 같은 다른 서비스로 업데이트를 보내도록
구성되어 있다. 그들은 클라이언트들을 가지지 않는다.</li>
<li><strong>노드IP와 알려진 포트</strong>: 데몬셋의 파드는 <code>호스트 포트</code>를 사용할 수 있으며,
노드IP를 통해 파드에 접근할 수 있다.
클라이언트는 노드IP를 어떻게든지 알고 있으며, 관례에 따라 포트를 알고 있다.</li>
<li><strong>DNS</strong>: 동일한 파드 셀렉터로 <a href=/ko/docs/concepts/services-networking/service/#%ED%97%A4%EB%93%9C%EB%A6%AC%EC%8A%A4-headless-%EC%84%9C%EB%B9%84%EC%8A%A4>헤드리스 서비스</a>를 만들고,
그 다음에 <code>엔드포인트</code> 리소스를 사용해서 데몬셋을 찾거나
DNS에서 여러 A레코드를 검색한다.</li>
<li><strong>서비스</strong>: 동일한 파드 셀렉터로 서비스를 생성하고, 서비스를 사용해서
임의의 노드의 데몬에 도달한다(특정 노드에 도달할 방법이 없다).</li>
</ul>
<h2 id=데몬셋-업데이트>데몬셋 업데이트</h2>
<p>만약 노드 레이블이 변경되면, 데몬셋은 새로 일치하는 노드에 즉시 파드를 추가하고, 새로
일치하지 않는 노드에서 파드를 삭제한다.</p>
<p>사용자는 데몬셋이 생성하는 파드를 수정할 수 있다. 그러나 파드는 모든
필드가 업데이트 되는 것을 허용하지 않는다. 또한 데몬셋 컨트롤러는
다음에 노드(동일한 이름으로)가 생성될 때 원본 템플릿을 사용한다.</p>
<p>사용자는 데몬셋을 삭제할 수 있다. 만약 <code>kubectl</code> 에서 <code>--cascade=orphan</code> 를 명시하면
파드는 노드에 남게 된다. 이후에 동일한 셀렉터로 새 데몬셋을 생성하면,
새 데몬셋은 기존 파드를 채택한다. 만약 파드를 교체해야 하는 경우 데몬셋은
<code>updateStrategy</code> 에 따라 파드를 교체한다.</p>
<p>사용자는 데몬셋에서 <a href=/ko/docs/tasks/manage-daemon/update-daemon-set/>롤링 업데이트를 수행</a>할 수 있다.</p>
<h2 id=데몬셋의-대안>데몬셋의 대안</h2>
<h3 id=초기화-스크립트>초기화 스크립트</h3>
<p>데몬 프로세스를 직접 노드에서 시작해서 실행하는 것도 당연히 가능하다.
(예: <code>init</code>, <code>upstartd</code> 또는 <code>systemd</code> 를 사용). 이 방법도 문제는 전혀 없다. 그러나 데몬셋을 통해 데몬
프로세스를 실행하면 몇 가지 이점 있다.</p>
<ul>
<li>애플리케이션과 동일한 방법으로 데몬을 모니터링하고 로그 관리를 할 수 있다.</li>
<li>데몬 및 애플리케이션과 동일한 구성 언어와 도구(예: 파드 템플릿, <code>kubectl</code>).</li>
<li>리소스 제한이 있는 컨테이너에서 데몬을 실행하면 앱 컨테이너에서
데몬간의 격리를 증가시킨다. 그러나 이것은 파드가 아닌 컨테이너에서 데몬을 실행해서 이루어진다
(예: 도커에서 직접적으로 시작).</li>
</ul>
<h3 id=베어-bare-파드>베어(Bare) 파드</h3>
<p>직접적으로 파드를 실행할 특정한 노드를 명시해서 파드를 생성할 수 있다. 그러나
데몬셋은 노드 장애 또는 커널 업그레이드와 같이 변경사항이 많은 노드 유지보수의 경우를 비롯하여
어떠한 이유로든 삭제되거나 종료된 파드를 교체한다. 따라서 개별 파드를
생성하는 것보다는 데몬 셋을 사용해야 한다.</p>
<h3 id=static-pods>스태틱(static) 파드</h3>
<p>Kubelet이 감시하는 특정 디렉터리에 파일을 작성하는 파드를 생성할 수 있다. 이것을
<a href=/ko/docs/tasks/configure-pod-container/static-pod/>스태틱 파드</a>라고 부른다.
데몬셋과는 다르게 스태틱 파드는 kubectl
또는 다른 쿠버네티스 API 클라이언트로 관리할 수 없다. 스태틱 파드는 API 서버에 의존하지
않기 때문에 클러스터 부트스트랩(bootstraping)하는 경우에 유용하다. 또한 스태틱 파드는 향후에 사용 중단될 수 있다.</p>
<h3 id=디플로이먼트>디플로이먼트</h3>
<p>데몬셋은 파드를 생성한다는 점에서 <a href=/ko/docs/concepts/workloads/controllers/deployment/>디플로이먼트</a>와 유사하고,
해당 파드에서는 프로세스가 종료되지 않을 것으로
예상한다(예: 웹 서버).</p>
<p>파드가 실행되는 호스트를 정확하게 제어하는 것보다 레플리카의 수를 스케일링 업 및 다운 하고,
업데이트 롤아웃이 더 중요한 프런트 엔드와 같은 것은 스테이트리스 서비스의
디플로이먼트를 사용한다. 데몬셋이 특정 노드에서 다른 파드가 올바르게 실행되도록 하는 노드 수준 기능을 제공한다면,
파드 사본이 항상 모든 호스트 또는 특정 호스트에서 실행되는 것이 중요한 경우에 데몬셋을 사용한다.</p>
<p>예를 들어, <a href=/ko/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/>네트워크 플러그인</a>은 데몬셋으로 실행되는 컴포넌트를 포함할 수 있다. 데몬셋 컴포넌트는 작동 중인 노드가 정상적인 클러스터 네트워킹을 할 수 있도록 한다.</p>
<h2 id=다음-내용>다음 내용</h2>
<ul>
<li><a href=/ko/docs/concepts/workloads/pods/>파드</a>에 대해 배운다.
<ul>
<li>쿠버네티스 <a class=glossary-tooltip title="컨테이너의 라이프사이클을 정의, 배포, 관리하기 위한 API와 인터페이스들을 노출하는 컨테이너 오케스트레이션 레이어." data-toggle=tooltip data-placement=top href="/ko/docs/reference/glossary/?all=true#term-control-plane" target=_blank aria-label="컨트롤 플레인">컨트롤 플레인</a>
컴포넌트를 기동하는데 유용한
<a href=#static-pods>스태틱 파드</a>에 대해 배운다.</li>
</ul>
</li>
<li>데몬셋을 어떻게 사용하는지 알아본다.
<ul>
<li><a href=/ko/docs/tasks/manage-daemon/update-daemon-set/>데몬셋 롤링 업데이트 수행하기</a></li>
<li><a href=/ko/docs/tasks/manage-daemon/rollback-daemon-set/>데몬셋 롤백하기</a>
(예를 들어, 롤 아웃이 예상대로 동작하지 않은 경우).</li>
</ul>
</li>
<li><a href=/ko/docs/concepts/scheduling-eviction/assign-pod-node/>쿠버네티스가 파드를 노드에 할당하는 방법</a>을 이해한다.</li>
<li>데몬셋으로 구동되곤 하는, <a href=/ko/docs/concepts/extend-kubernetes/compute-storage-net/device-plugins/>디바이스 플러그인</a>과
<a href=/ko/docs/concepts/cluster-administration/addons/>애드온</a>에 대해 배운다.</li>
<li><code>DaemonSet</code>은 쿠버네티스 REST API에서 상위-수준 리소스이다.
데몬셋 API에 대해 이해하기 위해
<a href=/docs/reference/kubernetes-api/workload-resources/daemon-set-v1/>DaemonSet</a>
오브젝트 정의를 읽는다.</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-cc7cc3c4907039d9f863162e20bfbbef>4.2.5 - 잡</h1>
<p>잡에서 하나 이상의 파드를 생성하고 지정된 수의 파드가 성공적으로 종료될 때까지 계속해서 파드의 실행을 재시도한다.
파드가 성공적으로 완료되면, 성공적으로 완료된 잡을 추적한다. 지정된 수의
성공 완료에 도달하면, 작업(즉, 잡)이 완료된다. 잡을 삭제하면 잡이 생성한
파드가 정리된다. 작업을 일시 중지하면 작업이 다시 재개될 때까지 활성 파드가
삭제된다.</p>
<p>간단한 사례는 잡 오브젝트를 하나 생성해서 파드 하나를 안정적으로 실행하고 완료하는 것이다.
첫 번째 파드가 실패 또는 삭제된 경우(예로는 노드 하드웨어의 실패 또는
노드 재부팅) 잡 오브젝트는 새로운 파드를 기동시킨다.</p>
<p>잡을 사용하면 여러 파드를 병렬로 실행할 수도 있다.</p>
<p>잡을 스케줄에 따라 구동하고 싶은 경우(단일 작업이든, 여러 작업의 병렬 수행이든),
<a href=/ko/docs/concepts/workloads/controllers/cron-jobs/>크론잡(CronJob)</a>을 참고한다.</p>
<h2 id=예시-잡-실행하기>예시 잡 실행하기</h2>
<p>다음은 잡 설정 예시이다. 예시는 파이(π)의 2000 자리까지 계산해서 출력한다.
이를 완료하는 데 약 10초가 소요된다.</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/ko/examples/controllers/job.yaml download=controllers/job.yaml><code>controllers/job.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('controllers-job-yaml')" title="Copy controllers/job.yaml to clipboard">
</img>
</div>
<div class=includecode id=controllers-job-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>batch/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Job<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pi<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pi<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>perl<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;perl&#34;</span>,<span style=color:#bbb>  </span><span style=color:#b44>&#34;-Mbignum=bpi&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;-wle&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;print bpi(2000)&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>backoffLimit</span>:<span style=color:#bbb> </span><span style=color:#666>4</span><span style=color:#bbb>
</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>이 명령으로 예시를 실행할 수 있다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://kubernetes.io/examples/controllers/job.yaml
</code></pre></div><p>출력 결과는 다음과 같다.</p>
<pre><code>job.batch/pi created
</code></pre><p><code>kubectl</code> 을 사용해서 잡 상태를 확인한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe jobs/pi
</code></pre></div><p>출력 결과는 다음과 같다.</p>
<pre><code>Name:           pi
Namespace:      default
Selector:       controller-uid=c9948307-e56d-4b5d-8302-ae2d7b7da67c
Labels:         controller-uid=c9948307-e56d-4b5d-8302-ae2d7b7da67c
                job-name=pi
Annotations:    kubectl.kubernetes.io/last-applied-configuration:
                  {&quot;apiVersion&quot;:&quot;batch/v1&quot;,&quot;kind&quot;:&quot;Job&quot;,&quot;metadata&quot;:{&quot;annotations&quot;:{},&quot;name&quot;:&quot;pi&quot;,&quot;namespace&quot;:&quot;default&quot;},&quot;spec&quot;:{&quot;backoffLimit&quot;:4,&quot;template&quot;:...
Parallelism:    1
Completions:    1
Start Time:     Mon, 02 Dec 2019 15:20:11 +0200
Completed At:   Mon, 02 Dec 2019 15:21:16 +0200
Duration:       65s
Pods Statuses:  0 Running / 1 Succeeded / 0 Failed
Pod Template:
  Labels:  controller-uid=c9948307-e56d-4b5d-8302-ae2d7b7da67c
           job-name=pi
  Containers:
   pi:
    Image:      perl
    Port:       &lt;none&gt;
    Host Port:  &lt;none&gt;
    Command:
      perl
      -Mbignum=bpi
      -wle
      print bpi(2000)
    Environment:  &lt;none&gt;
    Mounts:       &lt;none&gt;
  Volumes:        &lt;none&gt;
Events:
  Type    Reason            Age   From            Message
  ----    ------            ----  ----            -------
  Normal  SuccessfulCreate  14m   job-controller  Created pod: pi-5rwd7
</code></pre><p><code>kubectl get pods</code> 를 사용해서 잡의 완료된 파드를 본다.</p>
<p>잡에 속하는 모든 파드를 기계적으로 읽을 수 있는 양식으로 나열하려면, 다음과 같은 명령을 사용할 수 있다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#b8860b>pods</span><span style=color:#666>=</span><span style=color:#a2f;font-weight:700>$(</span>kubectl get pods --selector<span style=color:#666>=</span>job-name<span style=color:#666>=</span>pi --output<span style=color:#666>=</span><span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.items[*].metadata.name}&#39;</span><span style=color:#a2f;font-weight:700>)</span>
<span style=color:#a2f>echo</span> <span style=color:#b8860b>$pods</span>
</code></pre></div><p>출력 결과는 다음과 같다.</p>
<pre><code>pi-5rwd7
</code></pre><p>여기서 셀렉터는 잡의 셀렉터와 동일하다. <code>--output=jsonpath</code> 옵션은 반환된
목록에 있는 각 파드의 이름으로 표현식을 지정한다.</p>
<p>파드 중 하나를 표준 출력으로 본다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl logs <span style=color:#b8860b>$pods</span>
</code></pre></div><p>출력 결과는 다음과 같다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632788659361533818279682303019520353018529689957736225994138912497217752834791315155748572424541506959508295331168617278558890750983817546374649393192550604009277016711390098488240128583616035637076601047101819429555961989467678374494482553797747268471040475346462080466842590694912933136770289891521047521620569660240580381501935112533824300355876402474964732639141992726042699227967823547816360093417216412199245863150302861829745557067498385054945885869269956909272107975093029553211653449872027559602364806654991198818347977535663698074265425278625518184175746728909777727938000816470600161452491921732172147723501414419735685481613611573525521334757418494684385233239073941433345477624168625189835694855620992192221842725502542568876717904946016534668049886272327917860857843838279679766814541009538837863609506800642251252051173929848960841284886269456042419652850222106611863067442786220391949450471237137869609563643719172874677646575739624138908658326459958133904780275901
</code></pre></div><h2 id=잡-사양-작성하기>잡 사양 작성하기</h2>
<p>다른 쿠버네티스의 설정과 마찬가지로 잡에는 <code>apiVersion</code>, <code>kind</code> 그리고 <code>metadata</code> 필드가 필요하다.
잡의 이름은 유효한 <a href=/ko/docs/concepts/overview/working-with-objects/names/#dns-%EC%84%9C%EB%B8%8C%EB%8F%84%EB%A9%94%EC%9D%B8-%EC%9D%B4%EB%A6%84>DNS 서브도메인 이름</a>이어야 한다.</p>
<p>잡에는 <a href=https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status><code>.spec</code> 섹션</a>도 필요하다.</p>
<h3 id=파드-템플릿>파드 템플릿</h3>
<p><code>.spec.template</code> 은 <code>.spec</code> 의 유일한 필수 필드이다.</p>
<p><code>.spec.template</code> 은 <a href=/ko/docs/concepts/workloads/pods/#%ED%8C%8C%EB%93%9C-%ED%85%9C%ED%94%8C%EB%A6%BF>파드 템플릿</a>이다. 이것은 <code>apiVersion</code> 또는 <code>kind</code> 가 없다는 것을 제외한다면 <a class=glossary-tooltip title="파드는 클러스터에서 실행 중인 컨테이너의 집합을 나타낸다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/pods/ target=_blank aria-label=파드>파드</a>와 정확하게 같은 스키마를 가지고 있다.</p>
<p>추가로 파드의 필수 필드 외에도 잡의 파드 템플릿은 적절한
레이블(<a href=#%ED%8C%8C%EB%93%9C-%EC%85%80%EB%A0%89%ED%84%B0>파드 셀렉터</a>를 본다)과 적절한 재시작 정책을 명시해야 한다.</p>
<p><code>Never</code> 또는 <code>OnFailure</code> 와 같은 <a href=/ko/docs/concepts/workloads/pods/pod-lifecycle/#%EC%9E%AC%EC%8B%9C%EC%9E%91-%EC%A0%95%EC%B1%85><code>RestartPolicy</code></a>만 허용된다.</p>
<h3 id=파드-셀렉터>파드 셀렉터</h3>
<p><code>.spec.selector</code> 필드는 선택 사항이다. 대부분의 케이스에서 지정해서는 안된다.
<a href=#%EC%9E%90%EC%8B%A0%EC%9D%98-%ED%8C%8C%EB%93%9C-%EC%85%80%EB%A0%89%ED%84%B0%EB%A5%BC-%EC%A7%80%EC%A0%95%ED%95%98%EA%B8%B0>자신의 파드 셀렉터를 지정하기</a> 섹션을 참고한다.</p>
<h3 id=parallel-jobs>잡에 대한 병렬 실행</h3>
<p>잡으로 실행하기에 적합한 작업 유형은 크게 세 가지가 있다.</p>
<ol>
<li>비-병렬(Non-parallel) 잡:
<ul>
<li>일반적으로, 파드가 실패하지 않은 한, 하나의 파드만 시작된다.</li>
<li>파드가 성공적으로 종료하자마자 즉시 잡이 완료된다.</li>
</ul>
</li>
<li><em>고정적(fixed)인 완료 횟수</em> 를 가진 병렬 잡:
<ul>
<li><code>.spec.completions</code> 에 0이 아닌 양수 값을 지정한다.</li>
<li>잡은 전체 작업을 나타내며, <code>.spec.completions</code> 성공한 파드가 있을 때 완료된다.</li>
<li><code>.spec.completionMode="Indexed"</code> 를 사용할 때, 각 파드는 0에서 <code>.spec.completions-1</code> 범위 내의 서로 다른 인덱스를 가져온다.</li>
</ul>
</li>
<li><em>작업 큐(queue)</em> 가 있는 병렬 잡:
<ul>
<li><code>.spec.completions</code> 를 지정하지 않고, <code>.spec.parallelism</code> 를 기본으로 한다.</li>
<li>파드는 각자 또는 외부 서비스 간에 조정을 통해 각각의 작업을 결정해야 한다. 예를 들어 파드는 작업 큐에서 최대 N 개의 항목을 일괄로 가져올(fetch) 수 있다.</li>
<li>각 파드는 모든 피어들의 작업이 완료되었는지 여부를 독립적으로 판단할 수 있으며, 결과적으로 전체 잡이 완료되게 한다.</li>
<li>잡의 <em>모든</em> 파드가 성공적으로 종료되면, 새로운 파드는 생성되지 않는다.</li>
<li>하나 이상의 파드가 성공적으로 종료되고, 모든 파드가 종료되면 잡은 성공적으로 완료된다.</li>
<li>성공적으로 종료된 파드가 하나라도 생긴 경우, 다른 파드들은 해당 작업을 지속하지 않아야 하며 어떠한 출력도 작성하면 안 된다. 파드들은 모두 종료되는 과정에 있어야 한다.</li>
</ul>
</li>
</ol>
<p><em>비-병렬</em> 잡은 <code>.spec.completions</code> 와 <code>.spec.parallelism</code> 모두를 설정하지 않은 채로 둘 수 있다. 이때 둘 다
설정하지 않은 경우 1이 기본으로 설정된다.</p>
<p><em>고정적인 완료 횟수</em> 잡은 <code>.spec.completions</code> 을 필요한 완료 횟수로 설정해야 한다.
<code>.spec.parallelism</code> 을 설정할 수 있고, 설정하지 않으면 1이 기본으로 설정된다.</p>
<p><em>작업 큐</em> 잡은 <code>.spec.completions</code> 를 설정하지 않은 상태로 두고, <code>.spec.parallelism</code> 을
음수가 아닌 정수로 설정해야 한다.</p>
<p>다른 유형의 잡을 사용하는 방법에 대한 더 자세한 정보는 <a href=#%EC%9E%A1-%ED%8C%A8%ED%84%B4>잡 패턴</a> 섹션을 본다.</p>
<h4 id=병렬-처리-제어하기>병렬 처리 제어하기</h4>
<p>요청된 병렬 처리(<code>.spec.parallelism</code>)는 음수가 아닌 값으로 설정할 수 있다.
만약 지정되지 않은 경우에는 1이 기본이 된다.
만약 0으로 지정되면 병렬 처리가 증가할 때까지 사실상 일시 중지된다.</p>
<p>실제 병렬 처리(모든 인스턴스에서 실행되는 파드의 수)는 여러가지 이유로 요청된
병렬 처리보다 많거나 적을 수 있다.</p>
<ul>
<li><em>고정적인 완료 횟수(fixed completion count)</em> 잡의 경우, 병렬로 실행 중인 파드의 수는 남은 완료 수를
초과하지 않는다. <code>.spec.parallelism</code> 의 더 큰 값은 사실상 무시된다.</li>
<li><em>작업 큐</em> 잡은 파드가 성공한 이후에 새로운 파드가 시작되지 않는다. 그러나 나머지 파드는 완료될 수 있다.</li>
<li>만약 잡 <a class=glossary-tooltip title="API 서버를 통해 클러스터의 공유된 상태를 감시하고, 현재 상태를 원하는 상태로 이행시키는 컨트롤 루프." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/architecture/controller/ target=_blank aria-label=컨트롤러>컨트롤러</a> 가 반응할 시간이 없는 경우</li>
<li>만약 잡 컨트롤러가 어떤 이유(<code>ResourceQuota</code> 의 부족, 권한 부족 등)로든 파드 생성에 실패한 경우,
요청한 것보다 적은 수의 파드가 있을 수 있다.</li>
<li>잡 컨트롤러는 동일한 잡에서 과도하게 실패한 이전 파드들로 인해 새로운 파드의 생성을 조절할 수 있다.</li>
<li>파드가 정상적으로(gracefully) 종료되면, 중지하는데 시간이 소요된다.</li>
</ul>
<h3 id=완료-모드>완료 모드</h3>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.22 [beta]</code>
</div>
<p>완료 횟수가 <em>고정적인 완료 횟수</em> 즉, null이 아닌 <code>.spec.completions</code> 가 있는 잡은
<code>.spec.completionMode</code> 에 지정된 완료 모드를 가질 수 있다.</p>
<ul>
<li>
<p><code>NonIndexed</code> (기본값): <code>.spec.completions</code> 가 성공적으로
완료된 파드가 있는 경우 작업이 완료된 것으로 간주된다. 즉, 각 파드
완료는 서로 상동하다(homologous). null <code>.spec.completions</code> 가 있는
잡은 암시적으로 <code>NonIndexed</code> 이다.</p>
</li>
<li>
<p><code>Indexed</code>: 잡의 파드는 연결된 완료 인덱스를 0에서 <code>.spec.completions-1</code> 까지
가져온다. 이 인덱스는 다음의 세 가지 메카니즘으로 얻을 수 있다.</p>
<ul>
<li>파드 어노테이션 <code>batch.kubernetes.io/job-completion-index</code>.</li>
<li>파드 호스트네임 중 일부(<code>$(job-name)-$(index)</code> 형태). 인덱스된(Indexed) 잡과
<a class=glossary-tooltip title="네트워크 서비스로 파드 집합에서 실행 중인 애플리케이션을 노출하는 방법" data-toggle=tooltip data-placement=top href=/ko/docs/concepts/services-networking/service/ target=_blank aria-label=서비스>서비스</a>를 결합하여 사용하고
있다면, 잡에 속한 파드는 DNS를 이용하여 서로를 디스커버 하기 위해 사전에 결정된
호스트네임을 사용할 수 있다.</li>
<li>컨테이너화된 태스크의 경우, <code>JOB_COMPLETION_INDEX</code> 환경 변수.</li>
</ul>
<p>각 인덱스에 대해 성공적으로 완료된 파드가 하나 있으면 작업이 완료된 것으로
간주된다. 이 모드를 사용하는 방법에 대한 자세한 내용은
<a href=/docs/tasks/job/indexed-parallel-processing-static/>정적 작업 할당을 사용한 병렬 처리를 위해 인덱싱된 잡</a>을 참고한다.
참고로, 드물기는 하지만, 동일한 인덱스에 대해 둘 이상의 파드를 시작할 수
있지만, 그 중 하나만 완료 횟수에 포함된다.</p>
</li>
</ul>
<h2 id=파드와-컨테이너-장애-처리하기>파드와 컨테이너 장애 처리하기</h2>
<p>파드내 컨테이너의 프로세스가 0이 아닌 종료 코드로 종료되었거나 컨테이너 메모리 제한을
초과해서 죽는 등의 여러가지 이유로 실패할 수 있다. 만약 이런 일이
발생하고 <code>.spec.template.spec.restartPolicy = "OnFailure"</code> 라면 파드는
노드에 그대로 유지되지만, 컨테이너는 다시 실행된다. 따라서 프로그램은 로컬에서 재시작될 때의
케이스를 다루거나 <code>.spec.template.spec.restartPolicy = "Never"</code> 로 지정해야 한다.
더 자세한 정보는 <a href=/ko/docs/concepts/workloads/pods/pod-lifecycle/#%EC%83%81%ED%83%9C-%EC%98%88%EC%A0%9C>파드 라이프사이클</a>의 <code>restartPolicy</code> 를 본다.</p>
<p>파드가 노드에서 내보내지는 경우(노드 업그레이드, 재부팅, 삭제 등) 또는 파드의 컨테이너가 실패
되고 <code>.spec.template.spec.restartPolicy = "Never"</code> 로 설정됨과 같은 여러 이유로
전체 파드가 실패할 수 있다. 파드가 실패하면 잡 컨트롤러는
새 파드를 시작한다. 이 의미는 애플리케이션이 새 파드에서 재시작될 때 이 케이스를 처리해야
한다는 점이다. 특히, 이전 실행으로 인한 임시파일, 잠금, 불완전한 출력 그리고 이와 유사한
것들을 처리해야 한다.</p>
<p><code>.spec.parallelism = 1</code>, <code>.spec.completions = 1</code> 그리고
<code>.spec.template.spec.restartPolicy = "Never"</code> 를 지정하더라도 같은 프로그램을
두 번 시작하는 경우가 있다는 점을 참고한다.</p>
<p><code>.spec.parallelism</code> 그리고 <code>.spec.completions</code> 를 모두 1보다 크게 지정한다면 한번에
여러 개의 파드가 실행될 수 있다. 따라서 파드는 동시성에 대해서도 관대(tolerant)해야 한다.</p>
<h3 id=파드-백오프-backoff-실패-정책>파드 백오프(backoff) 실패 정책</h3>
<p>구성 등의 논리적 오류로 인해 약간의 재시도 이후에
잡을 실패하게 만들려는 경우가 있다.
이렇게 하려면 <code>.spec.backoffLimit</code> 에 잡을 실패로 간주하기 이전에
재시도할 횟수를 설정한다. 백오프 제한은 기본적으로 6으로 설정되어 있다. 잡과
관련한 실패한 파드는 최대 6분안에서 기하급수적으로 증가하는 백-오프 지연 (10초, 20초, 40초 ...)
한도가 되어 잡 컨트롤러에 의해 재생성된다. 잡의 파드가 삭제되거나
해당 시간 동안 잡에 대한 다른 파드가 실패 없이 성공했을 때 백 오프
카운트가 재설정된다.</p>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> 만약 잡에 <code>restartPolicy = "OnFailure"</code> 가 있는 경우 잡 백오프 한계에
도달하면 잡을 실행 중인 파드가 종료된다. 이로 인해 잡 실행 파일의 디버깅이
더 어려워질 수 있다. 디버깅하거나 로깅 시스템을 사용해서 실패한 작업의 결과를 실수로 손실되지 않도록
하려면 <code>restartPolicy = "Never"</code> 로 설정하는 것을 권장한다.
</div>
<h2 id=잡의-종료와-정리>잡의 종료와 정리</h2>
<p>잡이 완료되면 파드가 더 이상 생성되지도 않지만, <a href=#pod-backoff-failure-policy>일반적으로는</a> 삭제되지도 않는다.<br>
이를 유지하면
완료된 파드의 로그를 계속 보며 에러, 경고 또는 다른 기타 진단 출력을 확인할 수 있다.
잡 오브젝트는 완료된 후에도 상태를 볼 수 있도록 남아 있다. 상태를 확인한 후 이전 잡을 삭제하는 것은 사용자의 몫이다.
<code>kubectl</code> 로 잡을 삭제할 수 있다 (예: <code>kubectl delete jobs/pi</code> 또는 <code>kubectl delete -f ./job.yaml</code>). <code>kubectl</code> 을 사용해서 잡을 삭제하면 생성된 모든 파드도 함께 삭제된다.</p>
<p>기본적으로 파드의 실패(<code>restartPolicy=Never</code>) 또는 컨테이너가 오류(<code>restartPolicy=OnFailure</code>)로 종료되지 않는 한, 잡은 중단되지 않고 실행되고
이때 위에서 설명했던 <code>.spec.backoffLimit</code> 까지 연기된다. <code>.spec.backoffLimit</code> 에 도달하면 잡은 실패로 표기되고 실행 중인 모든 파드는 종료된다.</p>
<p>잡을 종료하는 또 다른 방법은 유효 데드라인을 설정하는 것이다.
잡의 <code>.spec.activeDeadlineSeconds</code> 필드를 초 단위로 설정하면 된다.
<code>activeDeadlineSeconds</code> 는 생성된 파드의 수에 관계 없이 잡의 기간에 적용된다.
잡이 <code>activeDeadlineSeconds</code> 에 도달하면, 실행 중인 모든 파드가 종료되고 잡의 상태는 <code>reason: DeadlineExceeded</code> 와 함께 <code>type: Failed</code> 가 된다.</p>
<p>잡의 <code>.spec.activeDeadlineSeconds</code> 는 <code>.spec.backoffLimit</code> 보다 우선한다는 점을 참고한다. 따라서 하나 이상 실패한 파드를 재시도하는 잡은 <code>backoffLimit</code> 에 도달하지 않은 경우에도 <code>activeDeadlineSeconds</code> 에 지정된 시간 제한에 도달하면 추가 파드를 배포하지 않는다.</p>
<p>예시:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>batch/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Job<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pi-with-timeout<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>backoffLimit</span>:<span style=color:#bbb> </span><span style=color:#666>5</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>activeDeadlineSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>100</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pi<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>perl<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;perl&#34;</span>,<span style=color:#bbb>  </span><span style=color:#b44>&#34;-Mbignum=bpi&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;-wle&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;print bpi(2000)&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
</span></code></pre></div><p>잡의 사양과 잡의 <a href=/ko/docs/concepts/workloads/pods/init-containers/#%EC%9E%90%EC%84%B8%ED%95%9C-%EB%8F%99%EC%9E%91>파드 템플릿 사양</a>에는 모두 <code>activeDeadlineSeconds</code> 필드가 있다는 점을 참고한다. 이 필드를 적절한 레벨로 설정해야 한다.</p>
<p><code>restartPolicy</code> 는 잡 자체에 적용되는 것이 아니라 파드에 적용된다는 점을 유념한다. 잡의 상태가 <code>type: Failed</code> 이 되면, 잡의 자동 재시작은 없다.
즉, <code>.spec.activeDeadlineSeconds</code> 와 <code>.spec.backoffLimit</code> 로 활성화된 잡의 종료 메커니즘은 영구적인 잡의 실패를 유발하며 이를 해결하기 위해 수동 개입이 필요하다.</p>
<h2 id=clean-up-finished-jobs-automatically>완료된 잡을 자동으로 정리</h2>
<p>완료된 잡은 일반적으로 시스템에서 더 이상 필요로 하지 않는다. 시스템 내에
이를 유지한다면 API 서버에 부담이 된다.
만약 <a href=/ko/docs/concepts/workloads/controllers/cron-jobs/>크론잡</a>과
같은 상위 레벨 컨트롤러가 잡을 직접 관리하는 경우,
지정된 용량 기반 정리 정책에 따라 크론잡이 잡을 정리할 수 있다.</p>
<h3 id=완료된-잡을-위한-ttl-메커니즘>완료된 잡을 위한 TTL 메커니즘</h3>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.21 [beta]</code>
</div>
<p>완료된 잡 (<code>Complete</code> 또는 <code>Failed</code>)을 자동으로 정리하는 또 다른 방법은
잡의 <code>.spec.ttlSecondsAfterFinished</code> 필드를 지정해서 완료된 리소스에 대해
<a href=/ko/docs/concepts/workloads/controllers/ttlafterfinished/>TTL 컨트롤러</a>에서
제공하는 TTL 메커니즘을 사용하는
것이다.</p>
<p>TTL 컨트롤러는 잡을 정리하면 잡을 계단식으로 삭제한다.
즉, 잡과 함께 파드와 같은 종속 오브젝트를 삭제한다. 잡을
삭제하면 finalizer와 같은 라이프사이클 보증이 보장되는 것을
참고한다.</p>
<p>예시:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>batch/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Job<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pi-with-ttl<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ttlSecondsAfterFinished</span>:<span style=color:#bbb> </span><span style=color:#666>100</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pi<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>perl<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;perl&#34;</span>,<span style=color:#bbb>  </span><span style=color:#b44>&#34;-Mbignum=bpi&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;-wle&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;print bpi(2000)&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
</span></code></pre></div><p><code>pi-with-ttl</code> 잡은 완료 후 <code>100</code> 초 이후에
자동으로 삭제될 수 있다.</p>
<p>만약 필드를 <code>0</code> 으로 설정하면, 잡이 완료된 직후에 자동으로
삭제되도록 할 수 있다. 만약 필드를 설정하지 않으면, 이 잡이 완료된
후에 TTL 컨트롤러에 의해 정리되지 않는다.</p>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> <p><code>ttlSecondsAfterFinished</code> 필드를 설정하는 것을 권장하는데,
이는 관리되지 않는 잡(직접 생성한,
크론잡 등 다른 워크로드 API를 통해 간접적으로 생성하지 않은 잡)의
기본 삭제 정책이 <code>orphanDependents</code>(관리되지 않는 잡이 완전히 삭제되어도
해당 잡에 의해 생성된 파드를 남겨둠)이기 때문이다.
삭제된 잡의 파드가 실패하거나 완료된 뒤
<a class=glossary-tooltip title="컨테이너의 라이프사이클을 정의, 배포, 관리하기 위한 API와 인터페이스들을 노출하는 컨테이너 오케스트레이션 레이어." data-toggle=tooltip data-placement=top href="/ko/docs/reference/glossary/?all=true#term-control-plane" target=_blank aria-label="컨트롤 플레인">컨트롤 플레인</a>이 언젠가
<a href=/ko/docs/concepts/workloads/pods/pod-lifecycle/#pod-garbage-collection>가비지 콜렉션</a>을 한다고 해도,
이렇게 남아 있는 파드는 클러스터의 성능을 저하시키거나
최악의 경우에는 이 성능 저하로 인해 클러스터가 중단될 수도 있다.</p>
<p><a href=/ko/docs/concepts/policy/limit-range/>리밋 레인지(Limit Range)</a>와
<a href=/ko/docs/concepts/policy/resource-quotas/>리소스 쿼터</a>를 사용하여
특정 네임스페이스가 사용할 수 있는 자원량을 제한할 수
있다.</p>
</div>
<h2 id=잡-패턴>잡 패턴</h2>
<p>잡 오브젝트를 사용해서 신뢰할 수 있는 파드의 병렬 실행을 지원할 수 있다. 잡 오브젝트는 과학
컴퓨팅(scientific computing)에서 일반적으로 사용되는 밀접하게 통신하는 병렬 프로세스를 지원하도록
설계되지 않았다. 잡 오브젝트는 독립적이지만 관련된 <em>작업 항목</em> 집합의 병렬 처리를 지원한다.
여기에는 전송할 이메일들, 렌더링할 프레임, 코드 변환이 필요한 파일, NoSQL 데이터베이스에서의
키 범위 스캔 등이 있다.</p>
<p>복잡한 시스템에는 여러 개의 다른 작업 항목 집합이 있을 수 있다. 여기서는 사용자와
함께 관리하려는 하나의 작업 항목 집합 — <em>배치 잡</em> 을 고려하고 있다.</p>
<p>병렬 계산에는 몇몇 다른 패턴이 있으며 각각의 장단점이 있다.
트레이드오프는 다음과 같다.</p>
<ul>
<li>각 작업 항목에 대한 하나의 잡 오브젝트 vs 모든 작업 항목에 대한 단일 잡 오브젝트. 후자는
작업 항목 수가 많은 경우 더 적합하다. 전자는 사용자와 시스템이 많은 수의 잡 오브젝트를
관리해야 하는 약간의 오버헤드를 만든다.</li>
<li>작업 항목과 동일한 개수의 파드 생성 vs 각 파드에서 다수의 작업 항목을 처리.
전자는 일반적으로 기존 코드와 컨테이너를 거의 수정할 필요가 없다. 후자는
이전 글 머리표(-)와 비슷한 이유로 많은 수의 작업 항목에 적합하다.</li>
<li>여러 접근 방식이 작업 큐를 사용한다. 이를 위해서는 큐 서비스를 실행하고,
작업 큐를 사용하도록 기존 프로그램이나 컨테이너를 수정해야 한다.
다른 접근 방식들은 기존에 컨테이너화된 애플리케이션에 보다 쉽게 적용할 수 있다.</li>
</ul>
<p>여기에 트레이드오프가 요약되어 있고, 2열에서 4열까지가 위의 트레이드오프에 해당한다.
패턴 이름은 예시와 더 자세한 설명을 위한 링크이다.</p>
<table>
<thead>
<tr>
<th>패턴</th>
<th style=text-align:center>단일 잡 오브젝트</th>
<th style=text-align:center>작업 항목보다 파드가 적은가?</th>
<th style=text-align:center>수정되지 않은 앱을 사용하는가?</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href=/ko/docs/tasks/job/coarse-parallel-processing-work-queue/>작업 항목 당 파드가 있는 큐</a></td>
<td style=text-align:center>✓</td>
<td style=text-align:center></td>
<td style=text-align:center>때때로</td>
</tr>
<tr>
<td><a href=/ko/docs/tasks/job/fine-parallel-processing-work-queue/>가변 파드 수를 가진 큐</a></td>
<td style=text-align:center>✓</td>
<td style=text-align:center>✓</td>
<td style=text-align:center></td>
</tr>
<tr>
<td><a href=/docs/tasks/job/indexed-parallel-processing-static/>정적 작업 할당을 사용한 인덱싱된 잡</a></td>
<td style=text-align:center>✓</td>
<td style=text-align:center></td>
<td style=text-align:center>✓</td>
</tr>
<tr>
<td><a href=/ko/docs/tasks/job/parallel-processing-expansion/>잡 템플릿 확장</a></td>
<td style=text-align:center></td>
<td style=text-align:center></td>
<td style=text-align:center>✓</td>
</tr>
</tbody>
</table>
<p><code>.spec.completions</code> 로 완료를 지정할 때, 잡 컨트롤러에 의해 생성된 각 파드는
동일한 <a href=https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status><code>사양</code></a>을 갖는다. 이 의미는
작업의 모든 파드는 동일한 명령 줄과 동일한 이미지,
동일한 볼륨, (거의) 동일한 환경 변수를 가진다는 점이다. 이 패턴은
파드가 다른 작업을 수행하도록 배열하는 다른 방법이다.</p>
<p>이 표는 각 패턴에 필요한 <code>.spec.parallelism</code> 그리고 <code>.spec.completions</code> 설정을 보여준다.
여기서 <code>W</code> 는 작업 항목의 수이다.</p>
<table>
<thead>
<tr>
<th>패턴</th>
<th style=text-align:center><code>.spec.completions</code></th>
<th style=text-align:center><code>.spec.parallelism</code></th>
</tr>
</thead>
<tbody>
<tr>
<td><a href=/ko/docs/tasks/job/coarse-parallel-processing-work-queue/>작업 항목 당 파드가 있는 큐</a></td>
<td style=text-align:center>W</td>
<td style=text-align:center>any</td>
</tr>
<tr>
<td><a href=/ko/docs/tasks/job/fine-parallel-processing-work-queue/>가변 파드 수를 가진 큐</a></td>
<td style=text-align:center>null</td>
<td style=text-align:center>any</td>
</tr>
<tr>
<td><a href=/docs/tasks/job/indexed-parallel-processing-static/>정적 작업 할당을 사용한 인덱싱된 잡</a></td>
<td style=text-align:center>W</td>
<td style=text-align:center>any</td>
</tr>
<tr>
<td><a href=/ko/docs/tasks/job/parallel-processing-expansion/>잡 템플릿 확장</a></td>
<td style=text-align:center>1</td>
<td style=text-align:center>1이어야 함</td>
</tr>
</tbody>
</table>
<h2 id=고급-사용법>고급 사용법</h2>
<h3 id=잡-일시-중지>잡 일시 중지</h3>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.22 [beta]</code>
</div>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> 이 기능은 쿠버네티스 버전 1.21에서는 알파 상태였으며,
이 때문에 이 기능을 활성화하기 위해서는 추가적인 단계를 진행해야 한다.
<a href=/ko/docs/home/supported-doc-versions/>현재 사용 중인 쿠버네티스 버전과 맞는 문서</a>를 읽고 있는 것이 맞는지 다시 한번 확인한다.
</div>
<p>잡이 생성되면, 잡 컨트롤러는 잡의 요구 사항을 충족하기 위해
즉시 파드 생성을 시작하고 잡이 완료될 때까지
계속한다. 그러나, 잡의 실행을 일시적으로 중단하고 나중에
재개하거나, 잡을 중단 상태로 생성하고 언제 시작할지를
커스텀 컨트롤러가 나중에 결정하도록 하고 싶을 수도 있다.</p>
<p>잡을 일시 중지하려면, 잡의 <code>.spec.suspend</code> 필드를 true로
업데이트할 수 있다. 이후에, 다시 재개하려면, false로 업데이트한다.
<code>.spec.suspend</code> 로 설정된 잡을 생성하면 일시 중지된 상태로
생성된다.</p>
<p>잡이 일시 중지에서 재개되면, 해당 <code>.status.startTime</code> 필드가
현재 시간으로 재설정된다. 즉, 잡이 일시 중지 및 재개되면 <code>.spec.activeDeadlineSeconds</code>
타이머가 중지되고 재설정된다.</p>
<p>잡을 일시 중지하면 모든 활성 파드가 삭제된다. 잡이
일시 중지되면, SIGTERM 시그널로 <a href=/ko/docs/concepts/workloads/pods/pod-lifecycle/#pod-termination>파드가 종료된다</a>.
파드의 정상 종료 기간이 적용되며 사용자의 파드는 이 기간 동안에
이 시그널을 처리해야 한다. 나중에 진행 상황을 저장하거나
변경 사항을 취소하는 작업이 포함될 수 있다. 이 방법으로 종료된 파드는
잡의 <code>completions</code> 수에 포함되지 않는다.</p>
<p>일시 중지된 상태의 잡 정의 예시는 다음과 같다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get job myjob -o yaml
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>batch/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Job<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>myjob<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>suspend</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>parallelism</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>completions</span>:<span style=color:#bbb> </span><span style=color:#666>5</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>...<span style=color:#bbb>
</span></code></pre></div><p>잡의 상태를 사용하여 잡이 일시 중지되었는지 또는 과거에 일시 중지되었는지
확인할 수 있다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get jobs/myjob -o yaml
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span>apiVersion:</span> <span>batch/v</span><span style=color:#666>1</span>
<span>kind:</span> <span>Job</span>
<span>#</span> <span>.metadata</span> <span>and</span> <span>.spec</span> <span>omitted</span>
<span>status:</span>
  <span>conditions:</span>
  <span>-</span> <span>lastProbeTime:</span> <span style=color:#b44>&#34;2021-02-05T13:14:33Z&#34;</span>
    <span>lastTransitionTime:</span> <span style=color:#b44>&#34;2021-02-05T13:14:33Z&#34;</span>
    <span>status:</span> <span style=color:#b44>&#34;True&#34;</span>
    <span>type:</span> <span>Suspended</span>
  <span>startTime:</span> <span style=color:#b44>&#34;2021-02-05T13:13:48Z&#34;</span>
</code></pre></div><p>"True" 상태인 "Suspended" 유형의 잡의 컨디션은 잡이
일시 중지되었음을 의미한다. 이 <code>lastTransitionTime</code> 필드는 잡이 일시 중지된
기간을 결정하는 데 사용할 수 있다. 해당 컨디션의 상태가 "False"이면, 잡이
이전에 일시 중지되었다가 현재 실행 중이다. 이러한 컨디션이
잡의 상태에 없으면, 잡이 중지되지 않은 것이다.</p>
<p>잡이 일시 중지 및 재개될 때에도 이벤트가 생성된다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe jobs/myjob
</code></pre></div><pre><code>Name:           myjob
...
Events:
  Type    Reason            Age   From            Message
  ----    ------            ----  ----            -------
  Normal  SuccessfulCreate  12m   job-controller  Created pod: myjob-hlrpl
  Normal  SuccessfulDelete  11m   job-controller  Deleted pod: myjob-hlrpl
  Normal  Suspended         11m   job-controller  Job suspended
  Normal  SuccessfulCreate  3s    job-controller  Created pod: myjob-jvb44
  Normal  Resumed           3s    job-controller  Job resumed
</code></pre><p>마지막 4개의 이벤트, 특히 "Suspended" 및 "Resumed" 이벤트는
<code>.spec.suspend</code> 필드를 전환한 결과이다. 이 두 이벤트 사이의 시간동안
파드가 생성되지 않았지만, 잡이 재개되자마자 파드 생성이 다시
시작되었음을 알 수 있다.</p>
<h3 id=가변적-스케줄링-지시>가변적 스케줄링 지시</h3>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.23 [beta]</code>
</div>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> 이 기능을 사용하려면,
<a href=/docs/reference/command-line-tools-reference/kube-apiserver/>API 서버</a>에
<code>JobMutableNodeSchedulingDirectives</code> <a href=/ko/docs/reference/command-line-tools-reference/feature-gates/>기능 게이트</a>를 활성화해야 한다.
이 기능은 기본적으로 활성화되어 있다.
</div>
<p>병렬 잡에서 대부분의 경우 파드를 특정 제약 조건 하에서 실행하고 싶을 것이다.
(예를 들면 동일 존에서 실행하거나, 또는 GPU 모델 x 또는 y를 사용하지만 둘을 혼합하지는 않는 등)</p>
<p><a href=#suspending-a-job>suspend</a> 필드는 이러한 목적을 달성하기 위한 첫 번째 단계이다.
이 필드를 사용하면 커스텀 큐(queue) 컨트롤러가 잡이 언제 시작될지를 결정할 수 있다.
그러나, 잡이 재개된 이후에는, 커스텀 큐 컨트롤러는 잡의 파드가 실제로 어디에 할당되는지에 대해서는 영향을 주지 않는다.</p>
<p>이 기능을 이용하여 잡이 실행되기 전에 잡의 스케줄링 지시를 업데이트할 수 있으며,
이를 통해 커스텀 큐 컨트롤러가 파드 배치에 영향을 줌과 동시에
노드로의 파드 실제 할당 작업을 kube-scheduler로부터 경감시켜 줄 수 있도록 한다.
이는 이전에 재개된 적이 없는 중지된 잡에 대해서만 허용된다.</p>
<p>잡의 파드 템플릿 필드 중, 노드 어피니티(node affinity), 노드 셀렉터(node selector),
톨러레이션(toleration), 레이블(label), 어노테이션(annotation)은 업데이트가 가능하다.</p>
<h3 id=자신의-파드-셀렉터를-지정하기>자신의 파드 셀렉터를 지정하기</h3>
<p>일반적으로 잡 오브젝트를 생성할 때 <code>.spec.selector</code> 를 지정하지 않는다.
시스템의 기본적인 로직은 잡이 생성될 때 이 필드를 추가한다.
이것은 다른 잡과 겹치지 않는 셀렉터 값을 선택한다.</p>
<p>그러나, 일부 케이스에서는 이 자동화된 설정 셀렉터를 재정의해야 할 수도 있다.
이를 위해 잡의 <code>.spec.selector</code> 를 설정할 수 있다.</p>
<p>이 것을 할 때는 매우 주의해야 한다. 만약 해당 잡의 파드에 고유하지
않고 연관이 없는 파드와 일치하는 레이블 셀렉터를 지정하면, 연관이 없는 잡의 파드가 삭제되거나,
해당 잡이 다른 파드가 완료한 것으로 수를 세거나, 하나 또는
양쪽 잡 모두 파드 생성이나 실행 완료를 거부할 수도 있다. 만약 고유하지 않은 셀렉터가
선택된 경우, 다른 컨트롤러(예: 레플리케이션 컨트롤러)와 해당 파드는
예측할 수 없는 방식으로 작동할 수 있다. 쿠버네티스는 당신이 <code>.spec.selector</code> 를 지정할 때
발생하는 실수를 막을 수 없을 것이다.</p>
<p>다음은 이 기능을 사용하려는 경우의 예시이다.</p>
<p>잡 <code>old</code> 가 이미 실행 중이다. 기존 파드가 계속
실행되기를 원하지만, 잡이 생성한 나머지 파드에는 다른
파드 템플릿을 사용하고 잡으로 하여금 새 이름을 부여하기를 원한다.
그러나 관련된 필드들은 업데이트가 불가능하기 때문에 잡을 업데이트할 수 없다.
따라서 <code>kubectl delete jobs/old --cascade=orphan</code> 명령을 사용해서
잡 <code>old</code> 를 삭제하지만, <em>파드를 실행 상태로 둔다</em>.
삭제하기 전에 어떤 셀렉터를 사용하는지 기록한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get job old -o yaml
</code></pre></div><p>출력 결과는 다음과 같다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Job<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>old<span style=color:#bbb>
</span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>controller-uid</span>:<span style=color:#bbb> </span>a8f3d00d-c6d2-11e5-9f87-42010af00002<span style=color:#bbb>
</span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></code></pre></div><p>그런 이후에 이름이 <code>new</code> 인 새 잡을 생성하고, 동일한 셀렉터를 명시적으로 지정한다.
기존 파드에는 <code>controller-uid=a8f3d00d-c6d2-11e5-9f87-42010af00002</code>
레이블이 있기에 잡 <code>new</code> 에 의해서도 제어된다.</p>
<p>시스템이 일반적으로 자동 생성하는 셀렉터를 사용하지 않도록 하기 위해
새 잡에서 <code>manualSelector: true</code> 를 지정해야 한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Job<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>new<span style=color:#bbb>
</span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>manualSelector</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>controller-uid</span>:<span style=color:#bbb> </span>a8f3d00d-c6d2-11e5-9f87-42010af00002<span style=color:#bbb>
</span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></code></pre></div><p>새 잡 자체는 <code>a8f3d00d-c6d2-11e5-9f87-42010af00002</code> 와 다른 uid 를 가지게 될 것이다.
<code>manualSelector: true</code> 를 설정하면 시스템에게 사용자가 무엇을 하는지 알고 있으며
이런 불일치를 허용한다고 알릴 수 있다.</p>
<h3 id=종료자-finalizers-를-이용한-잡-추적>종료자(finalizers)를 이용한 잡 추적</h3>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.23 [beta]</code>
</div>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> <p>이 기능을 이용하기 위해서는
<a href=/docs/reference/command-line-tools-reference/kube-apiserver/>API 서버</a>와
<a href=/docs/reference/command-line-tools-reference/kube-controller-manager/>컨트롤러 매니저</a>에 대해
<code>JobTrackingWithFinalizers</code> <a href=/ko/docs/reference/command-line-tools-reference/feature-gates/>기능 게이트</a>를 활성화해야 한다.
기본적으로는 활성화되어 있다.</p>
<p>이 기능이 활성화되면, 컨트롤 플레인은 아래에 설명할 동작을 이용하여 새로운 잡이 생성되는지 추적한다.
이 기능이 활성화되기 이전에 생성된 잡은 영향을 받지 않는다.
사용자가 느낄 수 있는 유일한 차이점은 컨트롤 플레인이 잡 종료를 좀 더 정확하게 추적할 수 있다는 것이다.</p>
</div>
<p>이 기능이 활성화되지 않으면, 잡
<a class=glossary-tooltip title="API 서버를 통해 클러스터의 공유된 상태를 감시하고, 현재 상태를 원하는 상태로 이행시키는 컨트롤 루프." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/architecture/controller/ target=_blank aria-label=컨트롤러>컨트롤러</a>는
<code>succeeded</code>와 <code>failed</code> 파드의 수를 세어 잡 상태를 추적한다.
그런데, 파드는 다음과 같은 이유로 제거될 수 있다.</p>
<ul>
<li>노드가 다운되었을 때 가비지 콜렉터가 버려진(orphan) 파드를 제거</li>
<li>가비지 콜렉터가 (<code>Succeeded</code> 또는 <code>Failed</code> 단계에 있는) 완료된 파드를
일정 임계값 이후에 제거</li>
<li>잡에 속한 파드를 사용자가 임의로 제거</li>
<li>(쿠버네티스에 속하지 않는) 외부 컨트롤러가 파드를 제거하거나
교체</li>
</ul>
<p>클러스터에서 <code>JobTrackingWithFinalizers</code> 기능을 활성화하면,
컨트롤 플레인은 잡에 속하는 파드의 상태를 추적하고
API 서버에서 파드가 제거되면 이를 알아챈다.
이를 위해, 잡 컨트롤러는 <code>batch.kubernetes.io/job-tracking</code> 종료자를 갖는 파드를 생성한다.
컨트롤러는 파드의 상태 변화가 잡 상태에 반영된 후에만 종료자를 제거하므로,
이후 다른 컨트롤러나 사용자가 파드를 제거할 수 있다.</p>
<p>잡 컨트롤러는 새로운 잡에 대해서만 새로운 알고리즘을 적용한다.
이 기능이 활성화되기 전에 생성된 잡은 영향을 받지 않는다.
잡에 <code>batch.kubernetes.io/job-tracking</code> 어노테이션이 있는지 확인하여,
잡 컨트롤러가 파드 종료자를 이용하여 잡을 추적하고 있는지 여부를 확인할 수 있다.
이 어노테이션을 잡에 수동으로 추가하거나 제거해서는 <strong>안 된다</strong>.</p>
<h2 id=대안>대안</h2>
<h3 id=베어-bare-파드>베어(Bare) 파드</h3>
<p>파드가 실행 중인 노드가 재부팅되거나 실패하면 파드가 종료되고
다시 시작되지 않는다. 그러나 잡은 종료된 항목을 대체하기 위해 새 파드를 생성한다.
따라서, 애플리케이션에 단일 파드만 필요한 경우에도 베어 파드 대신
잡을 사용하는 것을 권장한다.</p>
<h3 id=레플리케이션-컨트롤러>레플리케이션 컨트롤러</h3>
<p>잡은 <a href=/ko/docs/concepts/workloads/controllers/replicationcontroller/>레플리케이션 컨트롤러</a>를 보완한다.
레플리케이션 컨트롤러는 종료하지 않을 파드(예: 웹 서버)를 관리하고, 잡은 종료될 것으로
예상되는 파드(예: 배치 작업)를 관리한다.</p>
<p><a href=/ko/docs/concepts/workloads/pods/pod-lifecycle/>파드 라이프사이클</a>에서 설명한 것처럼, <code>잡</code> 은 <em>오직</em>
<code>OnFailure</code> 또는 <code>Never</code> 와 같은 <code>RestartPolicy</code> 를 사용하는 파드에만 적절하다.
(참고: <code>RestartPolicy</code> 가 설정되지 않은 경우에는 기본값은 <code>Always</code> 이다.)</p>
<h3 id=단일-잡으로-컨트롤러-파드-시작>단일 잡으로 컨트롤러 파드 시작</h3>
<p>또 다른 패턴은 단일 잡이 파드를 생성한 후 다른 파드들을 생성해서 해당 파드들에
일종의 사용자 정의 컨트롤러 역할을 하는 것이다. 이를 통해 최대한의 유연성을 얻을 수 있지만,
시작하기에는 다소 복잡할 수 있으며 쿠버네티스와의 통합성이 낮아진다.</p>
<p>이 패턴의 한 예시는 파드를 시작하는 잡이다. 파드는 스크립트를 실행해서
스파크(Spark) 마스터 컨트롤러 (<a href=https://github.com/kubernetes/examples/tree/master/staging/spark/README.md>스파크 예시</a>를 본다)를 시작하고,
스파크 드라이버를 실행한 다음, 정리한다.</p>
<p>이 접근 방식의 장점은 전체 프로세스가 잡 오브젝트의 완료를 보장하면서도,
파드 생성과 작업 할당 방법을 완전히 제어하고 유지한다는 것이다.</p>
<h2 id=다음-내용>다음 내용</h2>
<ul>
<li><a href=/ko/docs/concepts/workloads/pods>파드</a>에 대해 배운다.</li>
<li>다른 방식으로 잡을 구동하는 방법에 대해서 읽는다.
<ul>
<li><a href=/ko/docs/tasks/job/coarse-parallel-processing-work-queue/>작업 대기열을 사용한 거친 병렬 처리</a></li>
<li><a href=/ko/docs/tasks/job/fine-parallel-processing-work-queue/>작업 대기열을 사용한 정밀 병렬 처리</a></li>
<li><a href=/docs/tasks/job/indexed-parallel-processing-static/>병렬 처리를 위한 정적 작업 할당으로 인덱스된 잡</a>(베타) 사용</li>
<li>템플릿 기반으로 복수의 잡 생성: <a href=/ko/docs/tasks/job/parallel-processing-expansion/>확장을 사용한 병렬 처리</a></li>
</ul>
</li>
<li><a href=#clean-up-finished-jobs-automatically>완료된 잡을 자동으로 정리</a> 섹션 내 링크를 따라서
클러스터가 완료되거나 실패된 태스크를 어떻게 정리하는지에 대해 더 배운다.</li>
<li><code>Job</code>은 쿠버네티스 REST API의 일부이다.
잡 API에 대해 이해하기 위해
<a href=/docs/reference/kubernetes-api/workload-resources/job-v1/>Job</a>
오브젝트 정의를 읽은다.</li>
<li>스케줄을 기반으로 실행되는 일련의 잡을 정의하는데 사용할 수 있고, 유닉스 툴 <code>cron</code>과 유사한
<a href=/ko/docs/concepts/workloads/controllers/cron-jobs/><code>CronJob</code></a>에 대해 읽는다.</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-4de50a37ebb6f2340484192126cb7a04>4.2.6 - 완료된 잡 자동 정리</h1>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.23 [stable]</code>
</div>
<p>완료-이후-TTL(TTL-after-finished) <a class=glossary-tooltip title="API 서버를 통해 클러스터의 공유된 상태를 감시하고, 현재 상태를 원하는 상태로 이행시키는 컨트롤 루프." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/architecture/controller/ target=_blank aria-label=컨트롤러>컨트롤러</a>는
실행이 완료된 리소스 오브젝트의 수명을 제한하는
TTL (time to live) 메커니즘을 제공한다.
TTL 컨트롤러는 <a class=glossary-tooltip title="완료를 목표로 실행되는 유한 또는 배치 작업." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/controllers/job/ target=_blank aria-label=잡>잡</a>만을 제어한다.</p>
<h2 id=완료-이후-ttl-컨트롤러>완료-이후-TTL 컨트롤러</h2>
<p>완료-이후-TTL 컨트롤러는 잡만을 지원한다. 클러스터 운영자는
<a href=/ko/docs/concepts/workloads/controllers/job/#%EC%99%84%EB%A3%8C%EB%90%9C-%EC%9E%A1%EC%9D%84-%EC%9E%90%EB%8F%99%EC%9C%BC%EB%A1%9C-%EC%A0%95%EB%A6%AC>예시</a>
와 같이 <code>.spec.ttlSecondsAfterFinished</code> 필드를 명시하여
완료된 잡(<code>완료</code> 또는 <code>실패</code>)을 자동으로 정리하기 위해 이 기능을 사용할 수 있다.
잡의 작업이 완료된 TTL 초(sec) 후 (다른 말로는, TTL이 만료되었을 때),
완료-이후-TTL 컨트롤러는 해당 잡이 정리될 수 있다고 가정한다.
완료-이후-TTL 컨트롤러가 잡을 정리할때 잡을 연속적으로 삭제한다. 이는
의존하는 오브젝트도 해당 잡과 함께 삭제되는 것을 의미한다. 잡이 삭제되면 완료자(finalizers)와
같은 라이프 사이클 보증이 적용 된다.</p>
<p>TTL 초(sec)는 언제든지 설정이 가능하다. 여기에 잡 필드 중
<code>.spec.ttlSecondsAfterFinished</code> 를 설정하는 몇 가지 예시가 있다.</p>
<ul>
<li>작업이 완료된 다음, 일정 시간 후에 자동으로 잡이 정리될 수 있도록
잡 메니페스트에 이 필드를 지정한다.</li>
<li>이미 완료된 기존 잡에 이 새 기능을 적용하기 위해서 이 필드를
설정한다.</li>
<li><a href=/docs/reference/access-authn-authz/extensible-admission-controllers/#admission-webhooks>어드미션 웹후크 변형</a>
을 사용해서
잡 생성시 이 필드를 동적으로 설정 한다. 클러스터 관리자는 이것을
사용해서 완료된 잡에 대해 TTL 정책을 적용할 수 있다.</li>
<li>잡이 완료된 이후에
<a href=/docs/reference/access-authn-authz/extensible-admission-controllers/#admission-webhooks>어드미션 웹후크 변형</a>
을 사용해서 이 필드를 동적으로 설정하고, 잡의 상태,
레이블 등에 따라 다른 TTL 값을 선택한다.</li>
</ul>
<h2 id=경고>경고</h2>
<h3 id=ttl-초-sec-업데이트>TTL 초(sec) 업데이트</h3>
<p>TTL 기간은, 예를 들어 잡의 <code>.spec.ttlSecondsAfterFinished</code> 필드는
잡을 생성하거나 완료한 후에 수정할 수 있다. 그러나, 잡을
삭제할 수 있게 되면(TTL이 만료된 경우) 시스템은 TTL을 연장하기
위한 업데이트가 성공적인 API 응답을 리턴하더라도
작업이 유지되도록 보장하지 않는다.</p>
<h3 id=시간-차이-skew>시간 차이(Skew)</h3>
<p>완료-이후-TTL 컨트롤러는 쿠버네티스 잡에
저장된 타임스탬프를 사용해서 TTL의 만료 여부를 결정하기 때문에, 이 기능은 클러스터 간의
시간 차이에 민감하며, 시간 차이에 의해서 완료-이후-TTL 컨트롤러가 잘못된 시간에 잡
오브젝트를 정리하게 될 수 있다.</p>
<p>시계가 항상 정확한 것은 아니지만, 그 차이는
아주 작아야 한다. 0이 아닌 TTL을 설정할때는 이 위험에 대해 유의해야 한다.</p>
<h2 id=다음-내용>다음 내용</h2>
<ul>
<li>
<p><a href=/ko/docs/concepts/workloads/controllers/job/#%EC%99%84%EB%A3%8C%EB%90%9C-%EC%9E%A1%EC%9D%84-%EC%9E%90%EB%8F%99%EC%9C%BC%EB%A1%9C-%EC%A0%95%EB%A6%AC>자동으로 잡 정리</a></p>
</li>
<li>
<p><a href=https://github.com/kubernetes/enhancements/blob/master/keps/sig-apps/592-ttl-after-finish/README.md>디자인 문서</a></p>
</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-2e4cec01c525b45eccd6010e21cc76d9>4.2.7 - 크론잡</h1>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.21 [stable]</code>
</div>
<p><em>크론잡은</em> 반복 일정에 따라 <a class=glossary-tooltip title="완료를 목표로 실행되는 유한 또는 배치 작업." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/controllers/job/ target=_blank aria-label=잡>잡</a>을 만든다.</p>
<p>하나의 크론잡 오브젝트는 <em>크론탭</em> (크론 테이블) 파일의 한 줄과 같다.
크론잡은 잡을 <a href=https://ko.wikipedia.org/wiki/Cron>크론</a> 형식으로 쓰여진 주어진 일정에 따라 주기적으로 동작시킨다.</p>
<div class="alert alert-warning caution callout" role=alert>
<strong>주의:</strong> <p>모든 <strong>크론잡</strong> <code>일정:</code> 시간은
<a class=glossary-tooltip title="컨트롤러 프로세스를 실행하는 컨트롤 플레인 컴포넌트." data-toggle=tooltip data-placement=top href=/docs/reference/command-line-tools-reference/kube-controller-manager/ target=_blank aria-label=kube-controller-manager>kube-controller-manager</a>의 시간대를 기준으로 한다.</p>
<p>컨트롤 플레인이 파드 또는 베어 컨테이너에서 kube-controller-manager를 실행하는 경우,
kube-controller-manager 컨테이너에 설정된 시간대는
크론잡 컨트롤러가 사용하는 시간대로 결정한다.</p>
</div>
<div class="alert alert-warning caution callout" role=alert>
<strong>주의:</strong> <p><a href=/docs/reference/kubernetes-api/workload-resources/cron-job-v1/>v1 CronJob API</a>은
위에서 설명한 타임존 설정을 공식적으로 지원하지는 않는다.</p>
<p><code>CRON_TZ</code> 또는 <code>TZ</code> 와 같은 변수를 설정하는 것은 쿠버네티스 프로젝트에서 공식적으로 지원하지는 않는다.
<code>CRON_TZ</code> 또는 <code>TZ</code> 와 같은 변수를 설정하는 것은
크론탭을 파싱하고 다음 잡 생성 시간을 계산하는 내부 라이브러리의 구현 상세사항이다.
프로덕션 클러스터에서는 사용을 권장하지 않는다.</p>
</div>
<p>크론잡 리소스에 대한 매니페스트를 생성할 때에는 제공하는 이름이
유효한 <a href=/ko/docs/concepts/overview/working-with-objects/names/#dns-%EC%84%9C%EB%B8%8C%EB%8F%84%EB%A9%94%EC%9D%B8-%EC%9D%B4%EB%A6%84>DNS 서브도메인 이름</a>이어야 한다.
이름은 52자 이하여야 한다. 이는 크론잡 컨트롤러는 제공된 잡 이름에
11자를 자동으로 추가하고, 작업 이름의 최대 길이는
63자라는 제약 조건이 있기 때문이다.</p>
<h2 id=크론잡>크론잡</h2>
<p>크론잡은 백업, 리포트 생성 등의 정기적 작업을 수행하기 위해 사용된다.
각 작업은 무기한 반복되도록 구성해야 한다(예:
1일/1주/1달마다 1회).
작업을 시작해야 하는 해당 간격 내 특정 시점을 정의할 수 있다.</p>
<h3 id=예시>예시</h3>
<p>이 크론잡 매니페스트 예제는 현재 시간과 hello 메시지를 1분마다 출력한다.</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/ko/examples/application/job/cronjob.yaml download=application/job/cronjob.yaml><code>application/job/cronjob.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('application-job-cronjob-yaml')" title="Copy application/job/cronjob.yaml to clipboard">
</img>
</div>
<div class=includecode id=application-job-cronjob-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>batch/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>CronJob<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>hello<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>schedule</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;* * * * *&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>jobTemplate</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>hello<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>imagePullPolicy</span>:<span style=color:#bbb> </span>IfNotPresent<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span>- /bin/sh<span style=color:#bbb>
</span><span style=color:#bbb>            </span>- -c<span style=color:#bbb>
</span><span style=color:#bbb>            </span>- date; echo Hello from the Kubernetes cluster<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>OnFailure<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>(<a href=/ko/docs/tasks/job/automated-tasks-with-cron-jobs/>크론잡으로 자동화된 작업 실행하기</a>는
이 예시를 더 자세히 설명한다.)</p>
<h3 id=크론-스케줄-문법>크론 스케줄 문법</h3>
<pre><code># ┌───────────── 분 (0 - 59)
# │ ┌───────────── 시 (0 - 23)
# │ │ ┌───────────── 일 (1 - 31)
# │ │ │ ┌───────────── 월 (1 - 12)
# │ │ │ │ ┌───────────── 요일 (0 - 6) (일요일부터 토요일까지;
# │ │ │ │ │                                   특정 시스템에서는 7도 일요일)
# │ │ │ │ │
# │ │ │ │ │
# * * * * *
</code></pre><table>
<thead>
<tr>
<th>항목</th>
<th>설명</th>
<th>상응 표현</th>
</tr>
</thead>
<tbody>
<tr>
<td>@yearly (or @annually)</td>
<td>매년 1월 1일 자정에 실행</td>
<td>0 0 1 1 *</td>
</tr>
<tr>
<td>@monthly</td>
<td>매월 1일 자정에 실행</td>
<td>0 0 1 * *</td>
</tr>
<tr>
<td>@weekly</td>
<td>매주 일요일 자정에 실행</td>
<td>0 0 * * 0</td>
</tr>
<tr>
<td>@daily (or @midnight)</td>
<td>매일 자정에 실행</td>
<td>0 0 * * *</td>
</tr>
<tr>
<td>@hourly</td>
<td>매시 0분에 시작</td>
<td>0 * * * *</td>
</tr>
</tbody>
</table>
<p>예를 들면, 다음은 해당 작업이 매주 금요일 자정에 시작되어야 하고, 매월 13일 자정에도 시작되어야 한다는 뜻이다.</p>
<p><code>0 0 13 * 5</code></p>
<p>크론잡 스케줄 표현을 생성하기 위해서 <a href=https://crontab.guru/>crontab.guru</a>와 같은 웹 도구를 사용할 수도 있다.</p>
<h2 id=cron-job-limitations>크론잡의 한계</h2>
<p>크론잡은 일정의 실행시간 마다 <em>약</em> 한 번의 잡 오브젝트를 생성한다. "약" 이라고 하는 이유는
특정 환경에서는 두 개의 잡이 만들어지거나, 잡이 생성되지 않기도 하기 때문이다. 보통 이렇게 하지
않도록 해야겠지만, 완벽히 그럴 수는 없다. 따라서 잡은 <em>멱등원</em> 이 된다.</p>
<p>만약 <code>startingDeadlineSeconds</code> 가 큰 값으로 설정되거나, 설정되지 않고(디폴트 값),
<code>concurrencyPolicy</code> 가 <code>Allow</code> 로 설정될 경우, 잡은 항상 적어도 한 번은
실행될 것이다.</p>
<div class="alert alert-warning caution callout" role=alert>
<strong>주의:</strong> <code>startingDeadlineSeconds</code> 가 10초 미만의 값으로 설정되면, 크론잡이 스케줄되지 않을 수 있다. 이는 크론잡 컨트롤러가 10초마다 항목을 확인하기 때문이다.
</div>
<p>모든 크론잡에 대해 크론잡 <a class=glossary-tooltip title="API 서버를 통해 클러스터의 공유된 상태를 감시하고, 현재 상태를 원하는 상태로 이행시키는 컨트롤 루프." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/architecture/controller/ target=_blank aria-label=컨트롤러>컨트롤러</a> 는 마지막 일정부터 지금까지 얼마나 많은 일정이 누락되었는지 확인한다. 만약 100회 이상의 일정이 누락되었다면, 잡을 실행하지 않고 아래와 같은 에러 로그를 남긴다.</p>
<pre><code>Cannot determine if job needs to be started. Too many missed start time (&gt; 100). Set or decrease .spec.startingDeadlineSeconds or check clock skew.
</code></pre><p>중요한 것은 만약 <code>startingDeadlineSeconds</code> 필드가 설정이 되면(<code>nil</code> 이 아닌 값으로), 컨트롤러는 마지막 일정부터 지금까지 대신 <code>startingDeadlineSeconds</code> 값에서 몇 개의 잡이 누락되었는지 카운팅한다. 예를 들면, <code>startingDeadlineSeconds</code> 가 <code>200</code> 이면, 컨트롤러는 최근 200초 내 몇 개의 잡이 누락되었는지 카운팅한다.</p>
<p>크론잡은 정해진 일정에 잡 실행을 실패하면 놓쳤다고 카운팅된다. 예를 들면, <code>concurrencyPolicy</code> 가 <code>Forbid</code> 로 설정되었고, 크론잡이 이전 일정이 스케줄되어 여전히 시도하고 있을 때, 그 때 누락되었다고 판단한다.</p>
<p>즉, 크론잡이 <code>08:30:00</code> 에 시작하여 매 분마다 새로운 잡을 실행하도록 설정이 되었고,
<code>startingDeadlineSeconds</code> 값이 설정되어 있지 않는다고 가정해보자. 만약 크론잡 컨트롤러가
<code>08:29:00</code> 부터 <code>10:21:00</code> 까지 고장이 나면, 일정을 놓친 작업 수가 100개를 초과하여 잡이 실행되지 않을 것이다.</p>
<p>이 개념을 더 자세히 설명하자면, 크론잡이 <code>08:30:00</code> 부터 매 분 실행되는 일정으로 설정되고,
<code>startingDeadlineSeconds</code> 이 200이라고 가정한다. 크론잡 컨트롤러가
전의 예시와 같이 고장났다고 하면 (<code>08:29:00</code> 부터 <code>10:21:00</code> 까지), 잡은 10:22:00 부터 시작될 것이다. 이 경우, 컨트롤러가 마지막 일정부터 지금까지가 아니라, 최근 200초 안에 얼마나 놓쳤는지 체크하기 때문이다. (여기서는 3번 놓쳤다고 체크함)</p>
<p>크론잡은 오직 그 일정에 맞는 잡 생성에 책임이 있고,
잡은 그 잡이 대표하는 파드 관리에 책임이 있다.</p>
<h2 id=new-controller>컨트롤러 버전</h2>
<p>쿠버네티스 v1.21부터 크론잡 컨트롤러의 두 번째 버전이
기본 구현이다. 기본 크론잡 컨트롤러를 비활성화하고
대신 원래 크론잡 컨트롤러를 사용하려면, <code>CronJobControllerV2</code>
<a href=/ko/docs/reference/command-line-tools-reference/feature-gates/>기능 게이트</a>
플래그를 <a class=glossary-tooltip title="컨트롤러 프로세스를 실행하는 컨트롤 플레인 컴포넌트." data-toggle=tooltip data-placement=top href=/docs/reference/command-line-tools-reference/kube-controller-manager/ target=_blank aria-label=kube-controller-manager>kube-controller-manager</a>에 전달하고,
이 플래그를 <code>false</code> 로 설정한다. 예를 들면, 다음과 같다.</p>
<pre><code>--feature-gates=&quot;CronJobControllerV2=false&quot;
</code></pre><h2 id=다음-내용>다음 내용</h2>
<ul>
<li>크론잡이 의존하고 있는 <a href=/ko/docs/concepts/workloads/pods/>파드</a>와
<a href=/ko/docs/concepts/workloads/controllers/job/>잡</a> 두 개념에
대해 배운다.</li>
<li>크론잡 <code>.spec.schedule</code> 필드의 <a href=https://pkg.go.dev/github.com/robfig/cron/v3#hdr-CRON_Expression_Format>형식</a>에
대해서 읽는다.</li>
<li>크론잡을 생성하고 다루기 위한 지침 및
크론잡 매니페스트의 예제로
<a href=/ko/docs/tasks/job/automated-tasks-with-cron-jobs/>크론잡으로 자동화된 작업 실행</a>를 읽는다.</li>
<li>실패했거나 완료된 잡을 자동으로 정리하도록 하려면,
<a href=/ko/docs/concepts/workloads/controllers/job/#clean-up-finished-jobs-automatically>완료된 잡을 자동으로 정리</a>를 확인한다.</li>
<li><code>CronJob</code>은 쿠버네티스 REST API의 일부이다.
<a href=/docs/reference/kubernetes-api/workload-resources/cron-job-v1/>CronJob</a>
오브젝트 정의를 읽고 쿠버네티스 크론잡 API에 대해 이해한다.</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-27f1331d515d95f76aa1156088b4ad91>4.2.8 - 레플리케이션 컨트롤러</h1>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> <a href=/ko/docs/concepts/workloads/controllers/replicaset/><code>ReplicaSet</code></a>을 구성하는 <a href=/ko/docs/concepts/workloads/controllers/deployment/><code>Deployment</code></a>가 현재 권장하는 레플리케이션 설정 방법이다.
</div>
<p><em>레플리케이션컨트롤러</em> 는 언제든지 지정된 수의 파드 레플리카가
실행 중임을 보장한다.
다시 말하면, 레플리케이션 컨트롤러는 파드 또는 동일 종류의 파드의 셋이 항상 기동되고 사용 가능한지 확인한다.</p>
<h2 id=레플리케이션-컨트롤러의-동작방식>레플리케이션 컨트롤러의 동작방식</h2>
<p>파드가 너무 많으면 레플리케이션 컨트롤러가 추가적인 파드를 제거한다.
너무 적으면 레플리케이션 컨트롤러는 더 많은 파드를 시작한다.
수동으로 생성된 파드와 달리 레플리케이션 컨트롤러가 유지 관리하는 파드는 실패하거나 삭제되거나 종료되는 경우 자동으로 교체된다.
예를 들어, 커널 업그레이드와 같이 파괴적인 유지 보수 작업을 하고 난 이후의 노드에서 파드가 다시 생성된다.
따라서 애플리케이션에 하나의 파드만 필요한 경우에도 레플리케이션 컨트롤러를 사용해야 한다.
레플리케이션 컨트롤러는 프로세스 감시자(supervisor)와 유사하지만
단일 노드에서 개별 프로세스를 감시하는 대신 레플리케이션 컨트롤러는
여러 노드에서 여러 파드를 감시한다.</p>
<p>레플리케이션 컨트롤러는 디스커션에서 종종 "rc"로 축약되며
kubectl 명령에서 숏컷으로 사용된다.</p>
<p>간단한 경우는 하나의 레플리케이션 컨트롤러 오브젝트를 생성하여
한 개의 파드 인스턴스를 영구히 안정적으로 실행하는 것이다.
보다 복잡한 사용 사례는 웹 서버와 같이 복제된 서비스의 동일한 레플리카를 여러 개 실행하는 것이다.</p>
<h2 id=레플리케이션-컨트롤러-예제-실행>레플리케이션 컨트롤러 예제 실행</h2>
<p>레플리케이션 컨트롤러 예제의 config는 nginx 웹서버의 복사본 세 개를 실행한다.</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/ko/examples/controllers/replication.yaml download=controllers/replication.yaml><code>controllers/replication.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('controllers-replication-yaml')" title="Copy controllers/replication.yaml to clipboard">
</img>
</div>
<div class=includecode id=controllers-replication-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ReplicationController<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>예제 파일을 다운로드한 후 다음 명령을 실행하여 예제 작업을 실행하라.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/controllers/replication.yaml
</code></pre></div><p>출력 결과는 다음과 같다.</p>
<pre><code>replicationcontroller/nginx created
</code></pre><p>다음 명령을 사용하여 레플리케이션 컨트롤러의 상태를 확인하자.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe replicationcontrollers/nginx
</code></pre></div><p>출력 결과는 다음과 같다.</p>
<pre><code>Name:        nginx
Namespace:   default
Selector:    app=nginx
Labels:      app=nginx
Annotations:    &lt;none&gt;
Replicas:    3 current / 3 desired
Pods Status: 0 Running / 3 Waiting / 0 Succeeded / 0 Failed
Pod Template:
  Labels:       app=nginx
  Containers:
   nginx:
    Image:              nginx
    Port:               80/TCP
    Environment:        &lt;none&gt;
    Mounts:             &lt;none&gt;
  Volumes:              &lt;none&gt;
Events:
  FirstSeen       LastSeen     Count    From                        SubobjectPath    Type      Reason              Message
  ---------       --------     -----    ----                        -------------    ----      ------              -------
  20s             20s          1        {replication-controller }                    Normal    SuccessfulCreate    Created pod: nginx-qrm3m
  20s             20s          1        {replication-controller }                    Normal    SuccessfulCreate    Created pod: nginx-3ntk0
  20s             20s          1        {replication-controller }                    Normal    SuccessfulCreate    Created pod: nginx-4ok8v
</code></pre><p>이제 세 개의 파드가 생성되었으나 아직 이미지가 풀(pull)되지 않아서 어떤 파드도 시작되지 않았다.
조금 지난 후에 같은 명령이 다음과 같이 보일 것이다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>Pods Status:    <span style=color:#666>3</span> Running / <span style=color:#666>0</span> Waiting / <span style=color:#666>0</span> Succeeded / <span style=color:#666>0</span> Failed
</code></pre></div><p>레플리케이션 컨트롤러에 속한 모든 파드를 머신이 읽을 수 있는 형식으로 나열하기 위해 다음과 같은 명령을 사용할 수 있다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#b8860b>pods</span><span style=color:#666>=</span><span style=color:#a2f;font-weight:700>$(</span>kubectl get pods --selector<span style=color:#666>=</span><span style=color:#b8860b>app</span><span style=color:#666>=</span>nginx --output<span style=color:#666>=</span><span style=color:#b8860b>jsonpath</span><span style=color:#666>={</span>.items..metadata.name<span style=color:#666>}</span><span style=color:#a2f;font-weight:700>)</span>
<span style=color:#a2f>echo</span> <span style=color:#b8860b>$pods</span>
</code></pre></div><p>출력 결과는 다음과 같다.</p>
<pre><code>nginx-3ntk0 nginx-4ok8v nginx-qrm3m
</code></pre><p>여기서 셀렉터는 레플리케이션컨트롤러(<code>kubectl describe</code> 의 출력에서 보인)의 셀렉터와 같고,
다른 형식의 파일인 <code>replication.yaml</code> 의 것과 동일하다. <code>--output=jsonpath</code> 은
반환된 목록의 각 파드의 이름을 출력하도록 하는 옵션이다.</p>
<h2 id=레플리케이션-컨트롤러의-spec-작성>레플리케이션 컨트롤러의 Spec 작성</h2>
<p>다른 모든 쿠버네티스 컨피그와 마찬가지로 레플리케이션 컨트롤러는 <code>apiVersion</code>, <code>kind</code>, <code>metadata</code> 와 같은 필드가 필요하다.
레플리케이션 컨트롤러 오브젝트의 이름은 유효한
<a href=/ko/docs/concepts/overview/working-with-objects/names/#dns-%EC%84%9C%EB%B8%8C%EB%8F%84%EB%A9%94%EC%9D%B8-%EC%9D%B4%EB%A6%84>DNS 서브도메인 이름</a>이어야 한다.
환경설정 파일의 동작에 관련된 일반적인 정보는 <a href=/ko/docs/concepts/overview/working-with-objects/object-management/>쿠버네티스 오브젝트 관리</a>를 참고한다.</p>
<p>레플리케이션 컨트롤러는 또한 <a href=https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status><code>.spec</code> section</a>도 필요하다.</p>
<h3 id=파드-템플릿>파드 템플릿</h3>
<p><code>.spec.template</code> 는 오직 <code>.spec</code> 필드에서 요구되는 것이다.</p>
<p><code>.spec.template</code> 는 <a href=/ko/docs/concepts/workloads/pods/#%ED%8C%8C%EB%93%9C-%ED%85%9C%ED%94%8C%EB%A6%BF>파드 템플릿</a>이다. 정확하게 <a class=glossary-tooltip title="파드는 클러스터에서 실행 중인 컨테이너의 집합을 나타낸다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/pods/ target=_blank aria-label=파드>파드</a> 스키마와 동일하나, 중첩되어 있고 <code>apiVersion</code> 혹은 <code>kind</code>를 갖지 않는다.</p>
<p>파드에 필요한 필드 외에도 레플리케이션 컨트롤러의 파드 템플릿은 적절한 레이블과 적절한 재시작 정책을 지정해야 한다. 레이블의 경우 다른 컨트롤러와
중첩되지 않도록 하라. <a href=#%ED%8C%8C%EB%93%9C-%EC%85%80%EB%A0%89%ED%84%B0>파드 셀렉터</a>를 참조하라.</p>
<p>오직 <code>Always</code> 와 동일한 <a href=/ko/docs/concepts/workloads/pods/pod-lifecycle/#%EC%9E%AC%EC%8B%9C%EC%9E%91-%EC%A0%95%EC%B1%85><code>.spec.template.spec.restartPolicy</code></a>만 허용되며, 특별히 지정되지 않으면 기본값이다.</p>
<p>로컬 컨테이너의 재시작의 경우, 레플리케이션 컨트롤러는 노드의 에이전트에게 위임한다.
예를 들어 <a href=/docs/reference/command-line-tools-reference/kubelet/>Kubelet</a> 혹은 도커이다.</p>
<h3 id=레플리케이션-컨트롤러에서-레이블>레플리케이션 컨트롤러에서 레이블</h3>
<p>레플리케이션 컨트롤러 자체는 레이블 (<code>.metadata.labels</code>) 을 가질 수 있다. 일반적으로 이것을 <code>.spec.template.metadata.labels</code> 와 동일하게 설정할 것이다. <code>.metadata.labels</code> 가 지정되어 있지 않은 경우,
기본은 <code>.spec.template.metadata.labels</code> 이다. 하지만 레이블은
다른 것이 허용되며, <code>.metadata.labels</code> 라벨은 레플리케이션 컨트롤러의
동작에 영향을 미치지 않는다.</p>
<h3 id=파드-셀렉터>파드 셀렉터</h3>
<p><code>.spec.selector</code> 필드는 <a href=/ko/docs/concepts/overview/working-with-objects/labels/#%EB%A0%88%EC%9D%B4%EB%B8%94-%EC%85%80%EB%A0%89%ED%84%B0>레이블 셀렉터</a>이다. 레플리케이션 컨트롤러는 셀렉터와 일치하는 레이블이 있는 모든 파드를 관리한다.
직접 생성하거나 삭제된 파드와 다른 사람이나 프로세스가 생성하거나
삭제한 파드를 구분하지 않는다. 이렇게 하면 실행중인 파드에 영향을 주지 않고
레플리케이션 컨트롤러를 교체할 수 있다.</p>
<p>지정된 경우 <code>.spec.template.metadata.labels</code> 은
<code>.spec.selector</code> 와 동일해야 하며 그렇지 않으면 API에 의해 거부된다. <code>.spec.selector</code> 가 지정되지 않은 경우 기본값은
<code>.spec.template.metadata.labels</code> 이다.</p>
<p>또한 일반적으로 이 셀렉터와 레이블이 일치하는 파드를 직접
다른 레플리케이션 컨트롤러 또는 잡과 같은 다른 컨트롤러로 작성해서는 안된다.
그렇게 하면 레플리케이션 컨트롤러는 다른 파드를 생성했다고 생각한다.
쿠버네티스는 이런 작업을 중단해 주지 않는다.</p>
<p>중첩된 셀렉터들을 갖는 다수의 컨트롤러들을 종료하게 되면, 삭제된 것들은 스스로 관리를 해야 한다
(<a href=#%EB%A0%88%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98-%EC%BB%A8%ED%8A%B8%EB%A1%A4%EB%9F%AC-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0>아래</a>를 참조).</p>
<h3 id=다수의-레플리카>다수의 레플리카</h3>
<p><code>.spec.replicas</code> 를 동시에 실행하고 싶은 파드의 수로 설정함으로써
실행할 파드의 수를 지정할 수 있다. 레플리카가 증가 또는 감소한 경우 또는
파드가 정상적으로 종료되고 교체가 일찍 시작되는 경우라면
언제든지 실행중인 수가 더 높거나 낮을 수 있다.</p>
<p><code>.spec.replicas</code> 를 지정하지 않으면 기본값은 1이다.</p>
<h2 id=레플리케이션-컨트롤러-사용하기>레플리케이션 컨트롤러 사용하기</h2>
<h3 id=레플리케이션-컨트롤러와-레플리케이션-컨트롤러의-파드-삭제>레플리케이션 컨트롤러와 레플리케이션 컨트롤러의 파드 삭제</h3>
<p>레플리케이션 컨트롤러와 레플리케이션의 모든 파드를 삭제하려면 <a href=/docs/reference/generated/kubectl/kubectl-commands#delete><code>kubectl delete</code></a> 를 사용하라.
Kubectl은 레플리케이션 컨트롤러를 0으로 스케일하고 레플리케이션 컨트롤러 자체를
삭제하기 전에 각 파드를 삭제하기를 기다린다. 이 kubectl 명령이 인터럽트되면 다시 시작할 수 있다.</p>
<p>REST API나 Go 클라이언트 라이브러리를 사용하는 경우 명시적으로 단계를 수행해야 한다(레플리카를 0으로 스케일하고 파드의 삭제를 기다린 이후,
레플리케이션 컨트롤러를 삭제).</p>
<h3 id=레플리케이션-컨트롤러만-삭제>레플리케이션 컨트롤러만 삭제</h3>
<p>해당 파드에 영향을 주지 않고 레플리케이션 컨트롤러를 삭제할 수 있다.</p>
<p>kubectl을 사용하여, <a href=/docs/reference/generated/kubectl/kubectl-commands#delete><code>kubectl delete</code></a>에 옵션으로 <code>--cascade=orphan</code>을 지정하라.</p>
<p>REST API나 Go 클라이언트 라이브러리를 사용하는 경우 레플리케이션 컨트롤러 오브젝트를 삭제하라.</p>
<p>원본이 삭제되면 대체할 새로운 레플리케이션 컨트롤러를 생성하여 교체할 수 있다. 오래된 파드와 새로운 파드의 <code>.spec.selector</code> 가 동일하다면,
새로운 레플리케이션 컨트롤러는 오래된 파드를 채택할 것이다. 그러나 기존 파드를
새로운 파드 템플릿과 일치시키려는 노력은 하지 않을 것이다.
새로운 spec에 대한 파드를 제어된 방법으로 업데이트하려면 <a href=#%EB%A1%A4%EB%A7%81-%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8>롤링 업데이트</a>를 사용하라.</p>
<h3 id=레플리케이션-컨트롤러에서-파드-격리>레플리케이션 컨트롤러에서 파드 격리</h3>
<p>파드는 레이블을 변경하여 레플리케이션 컨트롤러의 대상 셋에서 제거될 수 있다. 이 기술은 디버깅과 데이터 복구를 위해 서비스에서 파드를 제거하는 데 사용될 수 있다. 이 방법으로 제거된 파드는 자동으로 교체된다 (레플리카 수가 변경되지 않는다고 가정).</p>
<h2 id=일반적인-사용법-패턴>일반적인 사용법 패턴</h2>
<h3 id=다시-스케줄하기>다시 스케줄하기</h3>
<p>위에서 언급했듯이, 실행하려는 파드가 한 개 혹은 1000개이든 관계없이 레플리케이션 컨트롤러는 노드 실패 또는 파드 종료시 지정된 수의 파드가 존재하도록 보장한다 (예 : 다른 제어 에이전트에 의한 동작으로 인해).</p>
<h3 id=스케일링>스케일링</h3>
<p>레플리케이션컨트롤러는 <code>replicas</code> 필드를 업데이트하여, 수동으로 또는 오토 스케일링 제어 에이전트를 통해, 레플리카의 수를 늘리거나 줄일 수 있다.</p>
<h3 id=롤링-업데이트>롤링 업데이트</h3>
<p>레플리케이션 컨트롤러는 파드를 하나씩 교체함으로써 서비스에 대한 롤링 업데이트를 쉽게 하도록 설계되었다.</p>
<p><a href=https://issue.k8s.io/1353>#1353</a>에서 설명한 것처럼, 권장되는 접근법은 1 개의 레플리카를 가진 새로운 레플리케이션 컨트롤러를 생성하고 새로운 (+1) 컨트롤러 및 이전 (-1) 컨트롤러를 차례대로 스케일한 후 0개의 레플리카가 되면 이전 컨트롤러를 삭제하는 것이다. 예상치 못한 오류와 상관없이 파드 세트를 예측 가능하게 업데이트한다.</p>
<p>이상적으로 롤링 업데이트 컨트롤러는 애플리케이션 준비 상태를 고려하며 주어진 시간에 충분한 수의 파드가 생산적으로 제공되도록 보장할 것이다.</p>
<p>두 레플리케이션 컨트롤러는 일반적으로 롤링 업데이트를 동기화 하는 이미지 업데이트이기 때문에 파드의 기본 컨테이너 이미지 태그와 같이 적어도 하나의 차별화된 레이블로 파드를 생성해야 한다.</p>
<h3 id=다수의-릴리스-트랙>다수의 릴리스 트랙</h3>
<p>롤링 업데이트가 진행되는 동안 다수의 애플리케이션 릴리스를 실행하는 것 외에도 다수의 릴리스 트랙을 사용하여 장기간에 걸쳐 또는 연속적으로 실행하는 것이 일반적이다. 트랙은 레이블 별로 구분된다.</p>
<p>예를 들어, 서비스는 <code>tier in (frontend), environment in (prod)</code> 이 있는 모든 파드를 대상으로 할 수 있다. 이제 이 계층을 구성하는 10 개의 복제된 파드가 있다고 가정해 보자. 하지만 이 구성 요소의 새로운 버전을 '카나리' 하기를 원한다. 대량의 레플리카에 대해 <code>replicas</code> 를 9로 설정하고 <code>tier=frontend, environment=prod, track=stable</code> 레이블을 설정한 레플리케이션 컨트롤러와, 카나리에 <code>replicas</code> 가 1로 설정된 다른 레플리케이션 컨트롤러에 <code>tier=frontend, environment=prod, track=canary</code> 라는 레이블을 설정할 수 있다. 이제 이 서비스는 카나리와 카나리 이외의 파드 모두를 포함한다. 그러나 레플리케이션 컨트롤러를 별도로 조작하여 테스트하고 결과를 모니터링하는 등의 작업이 혼란스러울 수 있다.</p>
<h3 id=서비스와-레플리케이션컨트롤러-사용>서비스와 레플리케이션컨트롤러 사용</h3>
<p>하나의 서비스 뒤에 여러 개의 레플리케이션컨트롤러가 있을 수 있다.
예를 들어 일부 트래픽은 이전 버전으로 이동하고 일부는 새 버전으로 이동한다.</p>
<p>레플리케이션컨트롤러는 자체적으로 종료되지 않지만, 서비스만큼 오래 지속될 것으로 기대되지는 않는다. 서비스는 여러 레플리케이션컨트롤러에 의해 제어되는 파드로 구성될 수 있으며, 서비스 라이프사이클 동안(예를 들어, 서비스를 실행하는 파드 업데이트 수행을 위해) 많은 레플리케이션컨트롤러가 생성 및 제거될 것으로 예상된다. 서비스 자체와 클라이언트 모두 파드를 유지하는 레플리케이션컨트롤러를 의식하지 않는 상태로 남아 있어야 한다.</p>
<h2 id=레플리케이션을-위한-프로그램-작성>레플리케이션을 위한 프로그램 작성</h2>
<p>레플리케이션 컨트롤러에 의해 생성된 파드는 해당 구성이 시간이 지남에 따라 이질적이 될 수 있지만 균일하고 의미상 동일하도록 설계되었다. 이는 레플리카된 상태 스테이트리스 서버에 적합하지만 레플리케이션 컨트롤러를 사용하여 마스터 선출, 샤드 및 워크-풀 애플리케이션의 가용성을 유지할 수도 있다. <a href=https://www.rabbitmq.com/tutorials/tutorial-two-python.html>RabbitMQ work queues</a>와 같은 애플리케이션은 안티패턴으로 간주되는 각 파드의 구성에 대한 정적/일회성 사용자 정의와 반대로 동적 작업 할당 메커니즘을 사용해야 한다. 리소스의 수직 자동 크기 조정 (예 : CPU 또는 메모리)과 같은 수행된 모든 파드 사용자 정의는 레플리케이션 컨트롤러 자체와 달리 다른 온라인 컨트롤러 프로세스에 의해 수행되어야 한다.</p>
<h2 id=레플리케이션-컨트롤러의-책임>레플리케이션 컨트롤러의 책임</h2>
<p>레플리케이션 컨트롤러는 의도한 수의 파드가 해당 레이블 셀렉터와 일치하고 동작하는지를 확인한다. 현재, 종료된 파드만 해당 파드의 수에서 제외된다. 향후 시스템에서 사용할 수 있는 <a href=https://issue.k8s.io/620>readiness</a> 및 기타 정보가 고려될 수 있으며 교체 정책에 대한 통제를 더 추가 할 수 있고 외부 클라이언트가 임의로 정교한 교체 또는 스케일 다운 정책을 구현하기 위해 사용할 수 있는 이벤트를 내보낼 계획이다.</p>
<p>레플리케이션 컨트롤러는 이 좁은 책임에 영원히 제약을 받는다. 그 자체로는 준비성 또는 활성 프로브를 실행하지 않을 것이다. 오토 스케일링을 수행하는 대신, 외부 오토 스케일러 (<a href=https://issue.k8s.io/492>#492</a>에서 논의된)가 레플리케이션 컨트롤러의 <code>replicas</code> 필드를 변경함으로써 제어되도록 의도되었다. 레플리케이션 컨트롤러에 스케줄링 정책 (예를 들어 <a href=https://issue.k8s.io/367#issuecomment-48428019>spreading</a>)을 추가하지 않을 것이다. 오토사이징 및 기타 자동화 된 프로세스를 방해할 수 있으므로 제어된 파드가 현재 지정된 템플릿과 일치하는지 확인해야 한다. 마찬가지로 기한 완료, 순서 종속성, 구성 확장 및 기타 기능은 다른 곳에 속한다. 대량의 파드 생성 메커니즘 (<a href=https://issue.k8s.io/170>#170</a>)까지도 고려해야 한다.</p>
<p>레플리케이션 컨트롤러는 조합 가능한 빌딩-블록 프리미티브가 되도록 고안되었다. 향후 사용자의 편의를 위해 더 상위 수준의 API 및/또는 도구와 그리고 다른 보완적인 기본 요소가 그 위에 구축 될 것으로 기대한다. 현재 kubectl이 지원하는 "매크로" 작업 (실행, 스케일)은 개념 증명의 예시이다. 예를 들어 <a href=https://netflixtechblog.com/asgard-web-based-cloud-management-and-deployment-2c9fc4e4d3a1>Asgard</a>와 같이 레플리케이션 컨트롤러, 오토 스케일러, 서비스, 정책 스케줄링, 카나리 등을 관리할 수 있다.</p>
<h2 id=api-오브젝트>API 오브젝트</h2>
<p>레플리케이션 컨트롤러는 쿠버네티스 REST API의 최상위 수준의 리소스이다.
API 오브젝트에 대한 더 자세한 것은
<a href=/docs/reference/generated/kubernetes-api/v1.23/#replicationcontroller-v1-core>ReplicationController API object</a> 에서 찾을 수 있다.</p>
<h2 id=레플리케이션-컨트롤러의-대안>레플리케이션 컨트롤러의 대안</h2>
<h3 id=레플리카셋>레플리카셋</h3>
<p><a href=/ko/docs/concepts/workloads/controllers/replicaset/><code>ReplicaSet</code></a>은 새로운 <a href=/ko/docs/concepts/overview/working-with-objects/labels/#%EC%A7%91%ED%95%A9%EC%84%B1-%EA%B8%B0%EC%A4%80-%EC%9A%94%EA%B1%B4>집합성 기준 레이블 셀렉터</a>이다.
이것은 주로 <a href=/ko/docs/concepts/workloads/controllers/deployment/>디플로이먼트</a>에 의해 파드의 생성, 삭제 및 업데이트를 오케스트레이션 하는 메커니즘으로 사용된다.
사용자 지정 업데이트 조정이 필요하거나 업데이트가 필요하지 않은 경우가 아니면 레플리카셋을 직접 사용하는 대신 디플로이먼트를 사용하는 것이 좋다.</p>
<h3 id=디플로이먼트-권장됨>디플로이먼트 (권장됨)</h3>
<p><a href=/ko/docs/concepts/workloads/controllers/deployment/><code>Deployment</code></a>는 기본 레플리카셋과 그 파드를 업데이트하는 상위 수준의 API 오브젝트이다. 선언적이며, 서버 사이드이고, 추가 기능이 있기 때문에 롤링 업데이트 기능을 원한다면 디플로이먼트를 권장한다.</p>
<h3 id=베어-파드>베어 파드</h3>
<p>사용자가 직접 파드를 만든 경우와 달리 레플리케이션 컨트롤러는 노드 오류 또는 커널 업그레이드와 같은 장애가 발생하는 노드 유지 관리의 경우와 같이 어떤 이유로든 삭제되거나 종료된 파드를 대체한다. 따라서 애플리케이션에 하나의 파드만 필요한 경우에도 레플리케이션 컨트롤러를 사용하는 것이 좋다. 프로세스 관리자와 비슷하게 생각하면, 단지 단일 노드의 개별 프로세스가 아닌 여러 노드에서 여러 파드를 감독하는 것이다. 레플리케이션 컨트롤러는 로컬 컨테이너가 노드의 에이전트로 (예를 들어 Kubelet 또는 도커 ) 재시작하도록 위임한다.</p>
<h3 id=잡>잡</h3>
<p>자체적으로 제거될 것으로 예상되는 파드 (즉, 배치 잡)의 경우
레플리케이션 컨트롤러 대신 <a href=/ko/docs/concepts/workloads/controllers/job/><code>Job</code></a>을 사용하라.</p>
<h3 id=데몬셋>데몬셋</h3>
<p>머신 모니터링이나 머신 로깅과 같은 머신 레벨 기능을 제공하는 파드에는 레플리케이션 컨트롤러 대신
<a href=/ko/docs/concepts/workloads/controllers/daemonset/><code>DaemonSet</code></a>을 사용하라. 이런 파드들의 수명은 머신의 수명에 달려 있다.
다른 파드가 시작되기 전에 파드가 머신에서 실행되어야 하며,
머신이 재부팅/종료 준비가 되어 있을 때 안전하게 종료된다.</p>
<h2 id=다음-내용>다음 내용</h2>
<ul>
<li><a href=/ko/docs/concepts/workloads/pods>파드</a>에 대해 배운다.</li>
<li>레플리케이션 컨트롤러를 대신하는 <a href=/ko/docs/concepts/workloads/controllers/deployment/>디플로이먼트</a>에 대해 배운다.</li>
<li><code>ReplicationController</code>는 쿠버네티스 REST API의 일부이다.
레플리케이션 컨트롤러 API에 대해 이해하기 위해
<a href=/docs/reference/kubernetes-api/workload-resources/replication-controller-v1/>ReplicationController</a>
오브젝트 정의를 읽는다.</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-0a0a7eca3e302a3c08f8c85e15d337fd>5 - 서비스, 로드밸런싱, 네트워킹</h1>
<div class=lead>쿠버네티스의 네트워킹에 대한 개념과 리소스에 대해 설명한다.</div>
<h2 id=쿠버네티스-네트워크-모델>쿠버네티스 네트워크 모델</h2>
<p>모든 <a href=/ko/docs/concepts/workloads/pods/><code>파드</code></a>는 고유한 IP 주소를 갖는다.
이는 즉 <code>파드</code>간 연결을 명시적으로 만들 필요가 없으며
또한 컨테이너 포트를 호스트 포트에 매핑할 필요가 거의 없음을 의미한다.
이로 인해 포트 할당, 네이밍, 서비스 디스커버리,
<a href=/ko/docs/concepts/services-networking/ingress/#load-balancing>로드 밸런싱</a>,
애플리케이션 구성, 마이그레이션 관점에서 <code>파드</code>를
VM 또는 물리 호스트처럼 다룰 수 있는 깔끔하고 하위 호환성을 갖는 모델이 제시된다.</p>
<p>쿠버네티스는 모든 네트워킹 구현에 대해 다음과 같은 근본적인 요구사항을 만족할 것을 요구한다
(이로 인해 모든 의도적인 네트워크 분할 정책이 방지된다)</p>
<ul>
<li><a href=/ko/docs/concepts/architecture/nodes/>노드</a> 상의 파드가 NAT 없이 모든 노드의 모든 파드와 통신할 수 있다</li>
<li>노드 상의 에이전트(예: 시스템 데몬, kubelet)가 해당 노드의 모든
파드와 통신할 수 있다</li>
</ul>
<p>참고: <code>파드</code>를 호스트 네트워크에서 구동하는 것도 지원하는 플랫폼(예: 리눅스)에 대해서는
다음의 요구사항도 존재한다.</p>
<ul>
<li>한 노드의 호스트 네트워크에 있는 파드는
NAT 없이 모든 노드의 모든 파드와 통신할 수 있다</li>
</ul>
<p>이 모델은 전반적으로 덜 복잡할 뿐만 아니라,
무엇보다도 VM에 있던 앱을 컨테이너로 손쉽게 포팅하려는 쿠버네티스 요구사항을 만족시킬 수 있다.
작업을 기존에는 VM에서 실행했었다면, VM은 IP주소를 가지며 프로젝트 내의 다른 VM과 통신할 수 있었을 것이다.
이는 동일한 기본 모델이다.</p>
<p>쿠버네티스 IP 주소는 <code>파드</code> 범주에 존재하며,
<code>파드</code> 내의 컨테이너들은 IP 주소, MAC 주소를 포함하는 네트워크 네임스페이스를 공유한다.
이는 곧 <code>파드</code> 내의 컨테이너들이 각자의 포트에 <code>localhost</code>로 접근할 수 있음을 의미한다.
또한 <code>파드</code> 내의 컨테이너들이 포트 사용에 있어 서로 협조해야 하는데,
이는 VM 내 프로세스 간에도 마찬가지이다.
이러한 모델은 "파드 별 IP" 모델로 불린다.</p>
<p>이것이 어떻게 구현되는지는 사용하는 컨테이너 런타임의 상세사항이다.</p>
<p><code>노드</code> 자체의 포트를 <code>파드</code>로 포워드하도록 요청하는 것도 가능하지만(호스트 포트라고 불림),
이는 매우 비주류적인(niche) 동작이다.
포워딩이 어떻게 구현되는지도 컨테이너 런타임의 상세사항이다.
<code>파드</code> 자체는 호스트 포트 존재 유무를 인지할 수 없다.</p>
<p>쿠버네티스 네트워킹은 다음의 네 가지 문제를 해결한다.</p>
<ul>
<li>파드 내의 컨테이너는 루프백(loopback)을 통한 <a href=/ko/docs/concepts/services-networking/dns-pod-service/>네트워킹을 사용하여 통신</a>한다.</li>
<li>클러스터 네트워킹은 서로 다른 파드 간의 통신을 제공한다.</li>
<li><a href=/ko/docs/concepts/services-networking/service/>서비스 리소스</a>를 사용하면 <a href=/ko/docs/concepts/services-networking/connect-applications-service/>파드에서 실행 중인 애플리케이션을 클러스터 외부에서 접근</a>할 수 있다.</li>
<li>또한 서비스를 사용하여 <a href=/ko/docs/concepts/services-networking/service-traffic-policy/>서비스를 클러스터 내부에서만 사용할 수 있도록 게시</a>할 수 있다.</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-5701136fd2ce258047b6ddc389112352>5.1 - 서비스</h1>
<a class=glossary-tooltip title="파드는 클러스터에서 실행 중인 컨테이너의 집합을 나타낸다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/pods/ target=_blank aria-label=파드>파드</a> 집합에서 실행중인 애플리케이션을 네트워크 서비스로 노출하는 추상화 방법
<p>쿠버네티스를 사용하면 익숙하지 않은 서비스 디스커버리 메커니즘을 사용하기 위해 애플리케이션을 수정할 필요가 없다.
쿠버네티스는 파드에게 고유한 IP 주소와 파드 집합에 대한 단일 DNS 명을 부여하고,
그것들 간에 로드-밸런스를 수행할 수 있다.</p>
<h2 id=동기>동기</h2>
<p>쿠버네티스 <a class=glossary-tooltip title="파드는 클러스터에서 실행 중인 컨테이너의 집합을 나타낸다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/pods/ target=_blank aria-label=파드>파드</a>는 클러스터 상태와
일치하도록 생성되고 삭제된다. 파드는 비영구적 리소스이다.
만약 앱을 실행하기 위해 <a class=glossary-tooltip title="클러스터에서 복제된 애플리케이션을 관리한다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/controllers/deployment/ target=_blank aria-label=디플로이먼트>디플로이먼트</a>를 사용한다면,
동적으로 파드를 생성하고 제거할 수 있다.</p>
<p>각 파드는 고유한 IP 주소를 갖지만, 디플로이먼트에서는
한 시점에 실행되는 파드 집합이
잠시 후 실행되는 해당 파드 집합과 다를 수 있다.</p>
<p>이는 다음과 같은 문제를 야기한다. ("백엔드"라 불리는) 일부 파드 집합이
클러스터의 ("프론트엔드"라 불리는) 다른 파드에 기능을 제공하는 경우,
프론트엔드가 워크로드의 백엔드를 사용하기 위해,
프론트엔드가 어떻게 연결할 IP 주소를 찾아서 추적할 수 있는가?</p>
<p><em>서비스</em> 로 들어가보자.</p>
<h2 id=service-resource>서비스 리소스</h2>
<p>쿠버네티스에서 서비스는 파드의 논리적 집합과 그것들에 접근할 수 있는
정책을 정의하는 추상적 개념이다. (때로는 이 패턴을
마이크로-서비스라고 한다.) 서비스가 대상으로 하는 파드 집합은 일반적으로
<a class=glossary-tooltip title="사용자가 레이블에 따라서 리소스 리스트를 필터할 수 있게 한다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/overview/working-with-objects/labels/ target=_blank aria-label=셀렉터>셀렉터</a>가 결정한다.
서비스 엔드포인트를 정의하는 다른 방법에 대한 자세한 내용은
<a href=#%EC%85%80%EB%A0%89%ED%84%B0%EA%B0%80-%EC%97%86%EB%8A%94-%EC%84%9C%EB%B9%84%EC%8A%A4>셀렉터가 <em>없는</em> 서비스</a>를 참고한다.</p>
<p>예를 들어, 3개의 레플리카로 실행되는 스테이트리스 이미지-처리 백엔드를
생각해보자. 이러한 레플리카는 대체 가능하다. 즉, 프론트엔드는 그것들이 사용하는 백엔드를
신경쓰지 않는다. 백엔드 세트를 구성하는 실제 파드는 변경될 수 있지만,
프론트엔드 클라이언트는 이를 인식할 필요가 없으며, 백엔드 세트 자체를 추적해야 할 필요도
없다.</p>
<p>서비스 추상화는 이러한 디커플링을 가능하게 한다.</p>
<h3 id=클라우드-네이티브-서비스-디스커버리>클라우드-네이티브 서비스 디스커버리</h3>
<p>애플리케이션에서 서비스 디스커버리를 위해 쿠버네티스 API를 사용할 수 있는 경우,
서비스 내 파드 세트가 변경될 때마다 업데이트되는 엔드포인트를 <a class=glossary-tooltip title="쿠버네티스 API를 제공하는 컨트롤 플레인 컴포넌트." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/overview/components/#kube-apiserver target=_blank aria-label="API 서버">API 서버</a>에
질의할 수 있다.</p>
<p>네이티브 애플리케이션이 아닌 (non-native applications) 경우, 쿠버네티스는 애플리케이션과 백엔드 파드 사이에 네트워크 포트 또는 로드
밸런서를 배치할 수 있는 방법을 제공한다.</p>
<h2 id=서비스-정의>서비스 정의</h2>
<p>쿠버네티스의 서비스는 파드와 비슷한 REST 오브젝트이다. 모든 REST 오브젝트와
마찬가지로, 서비스 정의를 API 서버에 <code>POST</code>하여
새 인스턴스를 생성할 수 있다.
서비스 오브젝트의 이름은 유효한
<a href=/ko/docs/concepts/overview/working-with-objects/names/#rfc-1035-label-names>RFC 1035 레이블 이름</a>이어야 한다.</p>
<p>예를 들어, 각각 TCP 포트 9376에서 수신하고
<code>app=MyApp</code> 레이블을 가지고 있는 파드 세트가 있다고 가정해 보자.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>MyApp<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>9376</span><span style=color:#bbb>
</span></code></pre></div><p>이 명세는 "my-service"라는 새로운 서비스 오브젝트를 생성하고,
<code>app=MyApp</code> 레이블을 가진 파드의 TCP 9376 포트를 대상으로 한다.</p>
<p>쿠버네티스는 이 서비스에 서비스 프록시가 사용하는 IP 주소 ("cluster IP"라고도 함)
를 할당한다.
(이하 <a href=#%EA%B0%80%EC%83%81-ip%EC%99%80-%EC%84%9C%EB%B9%84%EC%8A%A4-%ED%94%84%EB%A1%9D%EC%8B%9C>가상 IP와 서비스 프록시</a> 참고)</p>
<p>서비스 셀렉터의 컨트롤러는 셀렉터와 일치하는 파드를 지속적으로 검색하고,
"my-service"라는 엔드포인트 오브젝트에 대한
모든 업데이트를 POST한다.</p>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> 서비스는 <em>모든</em> 수신 <code>port</code>를 <code>targetPort</code>에 매핑할 수 있다. 기본적으로 그리고
편의상, <code>targetPort</code>는 <code>port</code>
필드와 같은 값으로 설정된다.
</div>
<p>파드의 포트 정의에는 이름이 있고, 서비스의 <code>targetPort</code> 속성에서 이 이름을
참조할 수 있다. 이것은 다른 포트 번호를 통한 가용한 동일 네트워크 프로토콜이 있고,
단일 구성 이름을 사용하는 서비스 내에
혼합된 파드가 존재해도 가능하다.
이를 통해 서비스를 배포하고 진전시키는데 많은 유연성을 제공한다.
예를 들어, 클라이언트를 망가뜨리지 않고, 백엔드 소프트웨어의 다음
버전에서 파드가 노출시키는 포트 번호를 변경할 수 있다.</p>
<p>서비스의 기본 프로토콜은 TCP이다. 다른
<a href=#protocol-support>지원되는 프로토콜</a>을 사용할 수도 있다.</p>
<p>많은 서비스가 하나 이상의 포트를 노출해야 하기 때문에, 쿠버네티스는 서비스 오브젝트에서 다중
포트 정의를 지원한다.
각 포트는 동일한 <code>프로토콜</code> 또는 다른 프로토콜로 정의될 수 있다.</p>
<h3 id=셀렉터가-없는-서비스>셀렉터가 없는 서비스</h3>
<p>서비스는 일반적으로 쿠버네티스 파드에 대한 접근을 추상화하지만,
다른 종류의 백엔드를 추상화할 수도 있다.
예를 들면</p>
<ul>
<li>프로덕션 환경에서는 외부 데이터베이스 클러스터를 사용하려고 하지만,
테스트 환경에서는 자체 데이터베이스를 사용한다.</li>
<li>한 서비스에서 다른
<a class=glossary-tooltip title="쿠버네티스에서 동일한 물리 클러스터에서 다중의 가상 클러스터를 지원하기 위해 사용하는 추상화." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/overview/working-with-objects/namespaces target=_blank aria-label=네임스페이스>네임스페이스</a> 또는 다른 클러스터의 서비스를 지정하려고 한다.</li>
<li>워크로드를 쿠버네티스로 마이그레이션하고 있다. 해당 방식을 평가하는 동안,
쿠버네티스에서는 백엔드의 일부만 실행한다.</li>
</ul>
<p>이러한 시나리오 중에서 파드 셀렉터 <em>없이</em> 서비스를 정의 할 수 있다.
예를 들면</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>9376</span><span style=color:#bbb>
</span></code></pre></div><p>이 서비스에는 셀렉터가 없으므로, 해당 엔드포인트 오브젝트가 자동으로
생성되지 않는다. 엔드포인트 오브젝트를 수동으로 추가하여, 서비스를 실행 중인 네트워크 주소 및 포트에
서비스를 수동으로 매핑할 수 있다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Endpoints<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>subsets</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>addresses</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>ip</span>:<span style=color:#bbb> </span><span style=color:#666>192.0.2.42</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>9376</span><span style=color:#bbb>
</span></code></pre></div><p>엔드포인트 오브젝트의 이름은 유효한
<a href=/ko/docs/concepts/overview/working-with-objects/names/#dns-%EC%84%9C%EB%B8%8C%EB%8F%84%EB%A9%94%EC%9D%B8-%EC%9D%B4%EB%A6%84>DNS 서브도메인 이름</a>이어야 한다.</p>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> <p>엔드포인트 IP는 루프백(loopback) (IPv4의 경우 127.0.0.0/8, IPv6의 경우 ::1/128), 또는
링크-로컬 (IPv4의 경우 169.254.0.0/16와 224.0.0.0/24, IPv6의 경우 fe80::/64)이 <em>되어서는 안된다</em>.</p>
<p>엔드포인트 IP 주소는 다른 쿠버네티스 서비스의 클러스터 IP일 수 없는데,
<a class=glossary-tooltip title="kube-proxy는 클러스터의 각 노드에서 실행되는 네트워크 프록시이다." data-toggle=tooltip data-placement=top href=/ko/docs/reference/command-line-tools-reference/kube-proxy/ target=_blank aria-label=kube-proxy>kube-proxy</a>는 가상 IP를
목적지(destination)로 지원하지 않기 때문이다.</p>
</div>
<p>셀렉터가 없는 서비스에 접근하면 셀렉터가 있는 것처럼 동일하게 작동한다.
위의 예에서, 트래픽은 YAML에 정의된 단일 엔드 포인트로
라우팅된다. <code>192.0.2.42:9376</code> (TCP)</p>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> 쿠버네티스 API 서버는 파드에 매핑되지 않은 엔드포인트를 프록시하는 것을 허용하지 않는다.
셀렉터가 없는 서비스에 대해서 <code>kubectl proxy &lt;service-name></code>과 같은 행위는
이런 제약으로 인해 실패할 것이다. 이는 사용자가 쿠버네티스 API 서버를
프록시로 사용하여 허가받지 않은 엔드포인트에 접근하는 것을 막아준다.
</div>
<p>ExternalName 서비스는 셀렉터가 없고
DNS명을 대신 사용하는 특수한 상황의 서비스이다. 자세한 내용은
이 문서 뒷부분의 <a href=#externalname>ExternalName</a> 섹션을 참조한다.</p>
<h3 id=초과-용량-엔드포인트>초과 용량 엔드포인트</h3>
<p>엔드포인트 리소스에 1,000개가 넘는 엔드포인트가 있는 경우 쿠버네티스 v1.22(또는 그 이상)
클러스터는 해당 엔드포인트에 <code>endpoints.kubernetes.io/over-capacity: truncated</code> 어노테이션을 추가한다.
이 어노테이션은 영향을 받는 엔드포인트 오브젝트가 용량을 초과했으며
엔드포인트 컨트롤러가 엔드포인트의 수를 1000으로 줄였음을 나타낸다.</p>
<h3 id=엔드포인트슬라이스>엔드포인트슬라이스</h3>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.21 [stable]</code>
</div>
<p>엔드포인트슬라이스는 엔드포인트에 보다 확장 가능한 대안을 제공할 수 있는
API 리소스이다. 개념적으로 엔드포인트와 매우 유사하지만, 엔드포인트슬라이스를
사용하면 여러 리소스에 네트워크 엔드포인트를 분산시킬 수 있다. 기본적으로,
엔드포인트슬라이스는 100개의 엔드포인트에 도달하면 "가득찬 것"로 간주되며,
추가 엔드포인트를 저장하기 위해서는 추가 엔드포인트슬라이스가
생성된다.</p>
<p>엔드포인트슬라이스는 <a href=/ko/docs/concepts/services-networking/endpoint-slices/>엔드포인트슬라이스</a>에서
자세하게 설명된 추가적인 속성 및 기능을 제공한다.</p>
<h3 id=애플리케이션-프로토콜>애플리케이션 프로토콜</h3>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.20 [stable]</code>
</div>
<p><code>appProtocol</code> 필드는 각 서비스 포트에 대한 애플리케이션 프로토콜을 지정하는 방법을 제공한다.
이 필드의 값은 해당 엔드포인트와 엔드포인트슬라이스
오브젝트에 의해 미러링된다.</p>
<p>이 필드는 표준 쿠버네티스 레이블 구문을 따른다. 값은
<a href=https://www.iana.org/assignments/service-names>IANA 표준 서비스 이름</a> 또는
<code>mycompany.com/my-custom-protocol</code>과 같은 도메인 접두사 이름 중 하나여야 한다.</p>
<h2 id=가상-ip와-서비스-프록시>가상 IP와 서비스 프록시</h2>
<p>쿠버네티스 클러스터의 모든 노드는 <code>kube-proxy</code>를 실행한다. <code>kube-proxy</code>는
<a href=#externalname><code>ExternalName</code></a> 이외의 유형의 <code>서비스</code>에 대한
가상 IP 형식을 구현한다.</p>
<h3 id=라운드-로빈-dns를-사용하지-않는-이유>라운드-로빈 DNS를 사용하지 않는 이유</h3>
<p>항상 발생하는 질문은 왜 쿠버네티스가 인바운드 트래픽을 백엔드로 전달하기 위해 프록시에
의존하는가 하는 점이다. 다른 접근법이
있는가? 예를 들어, 여러 A 값 (또는 IPv6의 경우 AAAA)을 가진
DNS 레코드를 구성하고, 라운드-로빈 이름 확인 방식을
취할 수 있는가?</p>
<p>서비스에 프록시를 사용하는 데는 몇 가지 이유가 있다.</p>
<ul>
<li>레코드 TTL을 고려하지 않고, 만료된 이름 검색 결과를
캐싱하는 DNS 구현에 대한 오래된 역사가 있다.</li>
<li>일부 앱은 DNS 검색을 한 번만 수행하고 결과를 무기한으로 캐시한다.</li>
<li>앱과 라이브러리가 적절히 재-확인을 했다고 하더라도, DNS 레코드의 TTL이
낮거나 0이면 DNS에 부하가 높아 관리하기가
어려워 질 수 있다.</li>
</ul>
<p>본 페이지의 뒷 부분에서 다양한 kube-proxy 구현의 동작에 대해 읽을 수 있다.
우선 알아두어야 할 것은, <code>kube-proxy</code>를 구동할 때, 커널 수준의 규칙이
수정(예를 들어, iptables 규칙이 생성될 수 있음)될 수 있고,
이는 때로는 리부트 전까지 정리되지 않을 수도 있다.
그래서, kube-proxy는 컴퓨터에서 저수준의, 특권을 가진(privileged) 네트워킹
프록시 서비스가 구동됨으로써 발생하는 결과를 이해하고 있는 관리자에 의해서만 구동되어야 한다.
비록 <code>kube-proxy</code> 실행 파일이 <code>cleanup</code> 기능을 지원하기는 하지만, 이 기능은 공식적인 기능이
아니기 때문에 구현된 그대로만 사용할 수 있다.</p>
<h3 id=구성>구성</h3>
<p>kube-proxy는 구성에 따라 결정되는 여러 모드에서 기동될 수 있다.</p>
<ul>
<li>kube-proxy의 구성은 컨피그맵(ConfigMap)을 통해 이루어진다. 그리고 해당 kube-proxy를 위한 컨피그맵은 실효성있게 거의 대부분의 kube-proxy의 플래그의 행위를 더 이상 사용하지 않도록 한다.</li>
<li>kube-proxy를 위한 해당 컨피그맵은 기동 중 구성의 재적용(live reloading)은 지원하지 않는다.</li>
<li>kube-proxy를 위한 컨피그맵 파라미터는 기동 시에 검증이나 확인을 하지 않는다. 예를 들어, 운영 체계가 iptables 명령을 허용하지 않을 경우, 표준 커널 kube-proxy 구현체는 작동하지 않을 것이다. 마찬가지로, <code>netsh</code>을 지원하지 않는 운영 체계에서는, 윈도우 유저스페이스 모드로는 기동하지 않을 것이다.</li>
</ul>
<h3 id=proxy-mode-userspace>유저 스페이스(User space) 프록시 모드</h3>
<p>이 모드에서는, kube-proxy는 쿠버네티스 컨트롤 플레인의 서비스 및 엔드포인트 오브젝트의
추가와 제거를 감시한다. 각 서비스는 로컬 노드에서
포트(임의로 선택됨)를 연다. 이 "프록시 포트"에 대한 모든
연결은 (엔드포인트를 통해 보고된 대로) 서비스의 백엔드 파드 중 하나로 프록시된다.
kube-proxy는 사용할 백엔드 파드를 결정할 때 서비스의
<code>SessionAffinity</code> 설정을 고려한다.</p>
<p>마지막으로, 유저-스페이스 프록시는 서비스의
<code>clusterIP</code> (가상)와 <code>port</code> 에 대한 트래픽을 캡처하는 iptables 규칙을 설치한다. 이 규칙은
트래픽을 백엔드 파드를 프록시하는 프록시 포트로 리다이렉션한다.</p>
<p>기본적으로, 유저스페이스 모드의 kube-proxy는 라운드-로빈 알고리즘으로 백엔드를 선택한다.</p>
<p><img src=/images/docs/services-userspace-overview.svg alt="유저스페이스 프록시에 대한 서비스 개요 다이어그램"></p>
<h3 id=proxy-mode-iptables><code>iptables</code> 프록시 모드</h3>
<p>이 모드에서는, kube-proxy는 쿠버네티스 컨트롤 플레인의 서비스, 엔드포인트 오브젝트의
추가와 제거를 감시한다. 각 서비스에 대해, 서비스의
<code>clusterIP</code> 및 <code>port</code>에 대한 트래픽을 캡처하고 해당 트래픽을 서비스의
백엔드 세트 중 하나로 리다이렉트(redirect)하는
iptables 규칙을 설치한다. 각 엔드포인트 오브젝트에 대해,
백엔드 파드를 선택하는 iptables 규칙을 설치한다.</p>
<p>기본적으로, iptables 모드의 kube-proxy는 임의의 백엔드를 선택한다.</p>
<p>트래픽을 처리하기 위해 iptables를 사용하면 시스템 오버헤드가 줄어드는데, 유저스페이스와
커널 스페이스 사이를 전환할 필요없이 리눅스 넷필터(netfilter)가 트래픽을 처리하기
때문이다. 이 접근 방식은 더 신뢰할 수 있기도 하다.</p>
<p>kube-proxy가 iptables 모드에서 실행 중이고 선택된 첫 번째 파드가
응답하지 않으면, 연결이 실패한다. 이는 userspace 모드와
다르다. 해당 시나리오에서는, kube-proxy는 첫 번째
파드에 대한 연결이 실패했음을 감지하고 다른 백엔드 파드로 자동으로 재시도한다.</p>
<p>파드 <a href=/ko/docs/concepts/workloads/pods/pod-lifecycle/#%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88-%ED%94%84%EB%A1%9C%EB%B8%8C-probe>준비성 프로브(readiness probe)</a>를 사용하여
백엔드 파드가 제대로 작동하는지 확인할 수 있으므로, iptables 모드의 kube-proxy는
정상으로 테스트된 백엔드만 볼 수 있다. 이렇게 하면 트래픽이 kube-proxy를 통해
실패한 것으로 알려진 파드로 전송되는 것을 막을 수 있다.</p>
<p><img src=/images/docs/services-iptables-overview.svg alt="iptables 프록시에 대한 서비스 개요 다이어그램"></p>
<h3 id=proxy-mode-ipvs>IPVS 프록시 모드</h3>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.11 [stable]</code>
</div>
<p><code>ipvs</code> 모드에서는, kube-proxy는 쿠버네티스 서비스와 엔드포인트를 감시하고,
<code>netlink</code> 인터페이스를 호출하여 그에 따라 IPVS 규칙을 생성하고
IPVS 규칙을 쿠버네티스 서비스와 엔드포인트와 주기적으로 동기화한다.
이 제어 루프는 IPVS 상태가 원하는 상태와 일치하도록
보장한다.
서비스에 접근하면, IPVS는 트래픽을 백엔드 파드 중 하나로 보낸다.</p>
<p>IPVS 프록시 모드는 iptables 모드와 유사한 넷필터 후크 기능을
기반으로 하지만, 해시 테이블을 기본 데이터 구조로 사용하고
커널 스페이스에서 동작한다.
이는 IPVS 모드의 kube-proxy는 iptables 모드의 kube-proxy보다
지연 시간이 짧은 트래픽을 리다이렉션하고, 프록시 규칙을 동기화할 때 성능이
훨씬 향상됨을 의미한다. 다른 프록시 모드와 비교했을 때, IPVS 모드는
높은 네트워크 트래픽 처리량도 지원한다.</p>
<p>IPVS는 트래픽을 백엔드 파드로 밸런싱하기 위한 추가 옵션을 제공한다.
다음과 같다.</p>
<ul>
<li><code>rr</code>: 라운드-로빈</li>
<li><code>lc</code>: 최소 연결 (가장 적은 수의 열려있는 연결)</li>
<li><code>dh</code>: 목적지 해싱</li>
<li><code>sh</code>: 소스 해싱</li>
<li><code>sed</code>: 최단 예상 지연 (shortest expected delay)</li>
<li><code>nq</code>: 큐 미사용 (never queue)</li>
</ul>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> <p>IPVS 모드에서 kube-proxy를 실행하려면, kube-proxy를 시작하기 전에 노드에서 IPVS를
사용 가능하도록 해야 한다.</p>
<p>kube-proxy가 IPVS 프록시 모드에서 시작될 때, IPVS 커널 모듈을
사용할 수 있는지 확인한다. IPVS 커널 모듈이 감지되지 않으면, kube-proxy는
iptables 프록시 모드에서 다시 실행된다.</p>
</div>
<p><img src=/images/docs/services-ipvs-overview.svg alt="IPVS 프록시에 대한 서비스 개요 다이어그램"></p>
<p>이 프록시 모델에서 클라이언트가 쿠버네티스 또는 서비스 또는 파드에
대해 알지 못하는 경우 서비스의 IP:포트로 향하는 트래픽은
적절한 백엔드로 프록시된다.</p>
<p>특정 클라이언트의 연결이 매번 동일한 파드로
전달되도록 하려면, <code>service.spec.sessionAffinity</code>를 "ClientIP"로 설정하여
클라이언트의 IP 주소를 기반으로 세션 어피니티(Affinity)를 선택할 수 있다.
(기본값은 "None")
<code>service.spec.sessionAffinityConfig.clientIP.timeoutSeconds</code>를 적절히 설정하여
최대 세션 고정 시간을 설정할 수도 있다.
(기본값은 10800으로, 3시간)</p>
<h2 id=멀티-포트-서비스>멀티-포트 서비스</h2>
<p>일부 서비스의 경우, 둘 이상의 포트를 노출해야 한다.
쿠버네티스는 서비스 오브젝트에서 멀티 포트 정의를 구성할 수 있도록 지원한다.
서비스에 멀티 포트를 사용하는 경우, 모든 포트 이름을
명확하게 지정해야 한다.
예를 들면</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>MyApp<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>http<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>9376</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>https<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>443</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>9377</span><span style=color:#bbb>
</span></code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> <p>쿠버네티스의 일반적인 <a class=glossary-tooltip title="/api/v1/pods/some-name과 같이, 리소스 URL에서 오브젝트를 가리키는 클라이언트 제공 문자열." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/overview/working-with-objects/names target=_blank aria-label=이름>이름</a>과 마찬가지로, 포트 이름은
소문자 영숫자와 <code>-</code> 만 포함해야 한다. 포트 이름은
영숫자로 시작하고 끝나야 한다.</p>
<p>예를 들어, <code>123-abc</code> 와 <code>web</code> 은 유효하지만, <code>123_abc</code> 와 <code>-web</code> 은 유효하지 않다.</p>
</div>
<h2 id=자신의-ip-주소-선택>자신의 IP 주소 선택</h2>
<p><code>서비스</code> 생성 요청시 고유한 클러스터 IP 주소를 지정할 수
있다. 이를 위해, <code>.spec.clusterIP</code> 필드를 설정한다. 예를 들어,
재사용하려는 기존 DNS 항목이 있거나, 특정 IP 주소로 구성되어
재구성이 어려운 레거시 시스템인 경우이다.</p>
<p>선택한 IP 주소는 API 서버에 대해 구성된 <code>service-cluster-ip-range</code>
CIDR 범위 내의 유효한 IPv4 또는 IPv6 주소여야 한다.
유효하지 않은 clusterIP 주소 값으로 서비스를 생성하려고 하면, API 서버는
422 HTTP 상태 코드를 리턴하여 문제점이 있음을 알린다.</p>
<h2 id=트래픽-정책>트래픽 정책</h2>
<h3 id=외부-트래픽-정책>외부 트래픽 정책</h3>
<p><code>spec.externalTrafficPolicy</code> 필드를 설정하여 외부 소스에서 오는 트래픽이 어떻게 라우트될지를 제어할 수 있다.
이 필드는 <code>Cluster</code> 또는 <code>Local</code>로 설정할 수 있다. 필드를 <code>Cluster</code>로 설정하면 외부 트래픽을 준비 상태의 모든 엔드포인트로 라우트하며,
<code>Local</code>로 설정하면 준비 상태의 노드-로컬 엔드포인트로만 라우트한다. 만약 트래픽 정책이 <code>Local</code>로 설정되어 있는데 노드-로컬
엔드포인트가 하나도 없는 경우, kube-proxy는 연관된 서비스로의 트래픽을 포워드하지 않는다.</p>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> <div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.22 [alpha]</code>
</div>
<p>kube-proxy에 대해 <code>ProxyTerminatingEndpoints</code>
<a href=/ko/docs/reference/command-line-tools-reference/feature-gates/>기능 게이트</a>를
활성화하면, kube-proxy는 노드에 로컬 엔드포인트가 있는지,
그리고 모든 로컬 엔드포인트가 "종료 중(terminating)"으로 표시되어 있는지 여부를 확인한다.
만약 로컬 엔드포인트가 존재하는데 <strong>모두</strong>가 종료 중이면, kube-proxy는 <code>Local</code>로 설정된 모든 외부 트래픽 정책을 무시한다.
대신, 모든 노드-로컬 엔드포인트가 "종료 중" 상태를 유지하는 동안,
kube-proxy는 마치 외부 트래픽 정책이 <code>Cluster</code>로 설정되어 있는 것처럼
그 서비스에 대한 트래픽을 정상 상태의 다른 엔드포인트로 포워드한다.
이러한 종료 중인 엔드포인트에 대한 포워딩 정책은 <code>NodePort</code> 서비스로 트래픽을 로드밸런싱하던 외부 로드밸런서가
헬스 체크 노드 포트가 작동하지 않을 때에도 연결들을 비돌발적으로(gracefully) 종료시킬 수 있도록 하기 위해 존재한다.
이러한 정책이 없다면, 노드가 여전히 로드밸런서 노드 풀에 있지만
파드 종료 과정에서 트래픽이 제거(drop)되는 상황에서 트래픽이 유실될 수 있다.
</div>
<h3 id=내부-트래픽-정책>내부 트래픽 정책</h3>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.22 [beta]</code>
</div>
<p><code>spec.internalTrafficPolicy</code> 필드를 설정하여 내부 소스에서 오는 트래픽이 어떻게 라우트될지를 제어할 수 있다.
이 필드는 <code>Cluster</code> 또는 <code>Local</code>로 설정할 수 있다. 필드를 <code>Cluster</code>로 설정하면 내부 트래픽을 준비 상태의 모든 엔드포인트로 라우트하며,
<code>Local</code>로 설정하면 준비 상태의 노드-로컬 엔드포인트로만 라우트한다. 만약 트래픽 정책이 <code>Local</code>로 설정되어 있는데 노드-로컬
엔드포인트가 하나도 없는 경우, kube-proxy는 트래픽을 포워드하지 않는다.</p>
<h2 id=서비스-디스커버리하기>서비스 디스커버리하기</h2>
<p>쿠버네티스는 서비스를 찾는 두 가지 기본 모드를 지원한다. - 환경
변수와 DNS</p>
<h3 id=환경-변수>환경 변수</h3>
<p>파드가 노드에서 실행될 때, kubelet은 각 활성화된 서비스에 대해 환경 변수 세트를 추가한다.
<code>{SVCNAME}_SERVICE_HOST</code> 및 <code>{SVCNAME}_SERVICE_PORT</code> 환경 변수가 추가되는데, 이 때 서비스 이름은 대문자로, 하이픈(<code>-</code>)은 언더스코어(<code>_</code>)로 변환하여 사용한다. 또한 도커 엔진의 "<em><a href=https://docs.docker.com/network/links/>레거시 컨테이너 연결</a></em>" 기능과 호환되는 변수(<a href=https://github.com/kubernetes/kubernetes/blob/dd2d12f6dc0e654c15d5db57a5f9f6ba61192726/pkg/kubelet/envvars/envvars.go#L72>makeLinkVariables</a> 참조)도 지원한다.</p>
<p>예를 들어, TCP 포트 6379를 개방하고
클러스터 IP 주소 10.0.0.11이 할당된 서비스 <code>redis-master</code>는,
다음 환경 변수를 생성한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#b8860b>REDIS_MASTER_SERVICE_HOST</span><span style=color:#666>=</span>10.0.0.11
<span style=color:#b8860b>REDIS_MASTER_SERVICE_PORT</span><span style=color:#666>=</span><span style=color:#666>6379</span>
<span style=color:#b8860b>REDIS_MASTER_PORT</span><span style=color:#666>=</span>tcp://10.0.0.11:6379
<span style=color:#b8860b>REDIS_MASTER_PORT_6379_TCP</span><span style=color:#666>=</span>tcp://10.0.0.11:6379
<span style=color:#b8860b>REDIS_MASTER_PORT_6379_TCP_PROTO</span><span style=color:#666>=</span>tcp
<span style=color:#b8860b>REDIS_MASTER_PORT_6379_TCP_PORT</span><span style=color:#666>=</span><span style=color:#666>6379</span>
<span style=color:#b8860b>REDIS_MASTER_PORT_6379_TCP_ADDR</span><span style=color:#666>=</span>10.0.0.11
</code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> <p>서비스에 접근이 필요한 파드가 있고, 환경 변수를
사용해 포트 및 클러스터 IP를 클라이언트 파드에 부여하는
경우, 클라이언트 파드가 생성되기 <em>전에</em> 서비스를 만들어야 한다.
그렇지 않으면, 해당 클라이언트 파드는 환경 변수를 생성할 수 없다.</p>
<p>DNS 만 사용하여 서비스의 클러스터 IP를 검색하는 경우, 이 순서
이슈에 대해 신경 쓸 필요가 없다.</p>
</div>
<h3 id=dns>DNS</h3>
<p><a href=/ko/docs/concepts/cluster-administration/addons/>애드-온</a>을 사용하여 쿠버네티스
클러스터의 DNS 서비스를 설정할 수(대개는 필수적임) 있다.</p>
<p>CoreDNS와 같은, 클러스터-인식 DNS 서버는 새로운 서비스를 위해 쿠버네티스 API를 감시하고
각각에 대한 DNS 레코드 세트를 생성한다. 클러스터 전체에서 DNS가 활성화된 경우
모든 파드는 DNS 이름으로 서비스를 자동으로
확인할 수 있어야 한다.</p>
<p>예를 들면, 쿠버네티스 네임스페이스 <code>my-ns</code>에 <code>my-service</code>라는
서비스가 있는 경우, 컨트롤 플레인과 DNS 서비스가 함께 작동하여
<code>my-service.my-ns</code>에 대한 DNS 레코드를 만든다. <code>my-ns</code> 네임 스페이스의 파드들은
<code>my-service</code>(<code>my-service.my-ns</code> 역시 동작함)에 대한 이름 조회를
수행하여 서비스를 찾을 수 있어야 한다.</p>
<p>다른 네임스페이스의 파드들은 이름을 <code>my-service.my-ns</code>으로 사용해야 한다. 이 이름은
서비스에 할당된 클러스터 IP로 변환된다.</p>
<p>쿠버네티스는 또한 알려진 포트에 대한 DNS SRV (서비스) 레코드를 지원한다.
<code>my-service.my-ns</code> 서비스에 프로토콜이 <code>TCP</code>로 설정된 <code>http</code>라는 포트가 있는 경우,
IP 주소와 <code>http</code>에 대한 포트 번호를 검색하기 위해 <code>_http._tcp.my-service.my-ns</code> 에 대한
DNS SRV 쿼리를 수행할 수 있다.</p>
<p>쿠버네티스 DNS 서버는 <code>ExternalName</code> 서비스에 접근할 수 있는 유일한 방법이다.
<a href=/ko/docs/concepts/services-networking/dns-pod-service/>DNS 파드와 서비스</a>에서
<code>ExternalName</code> 검색에 대한 자세한 정보를 찾을 수 있다.</p>
<h2 id=헤드리스-headless-서비스>헤드리스(Headless) 서비스</h2>
<p>때때로 로드-밸런싱과 단일 서비스 IP는 필요치 않다. 이 경우,
"헤드리스" 서비스라는 것을 만들 수 있는데, 명시적으로
클러스터 IP (<code>.spec.clusterIP</code>)에 "None"을 지정한다.</p>
<p>쿠버네티스의 구현에 묶이지 않고, 헤드리스 서비스를 사용하여
다른 서비스 디스커버리 메커니즘과 인터페이스할 수 있다.</p>
<p>헤드리스 <code>서비스</code>의 경우, 클러스터 IP가 할당되지 않고, kube-proxy가
이러한 서비스를 처리하지 않으며, 플랫폼에 의해 로드 밸런싱 또는 프록시를
하지 않는다. DNS가 자동으로 구성되는 방법은 서비스에 셀렉터가 정의되어 있는지
여부에 달려있다.</p>
<h3 id=셀렉터가-있는-경우>셀렉터가 있는 경우</h3>
<p>셀렉터를 정의하는 헤드리스 서비스의 경우, 엔드포인트 컨트롤러는
API에서 <code>엔드포인트</code> 레코드를 생성하고, DNS 구성을 수정하여
<code>서비스</code> 를 지원하는 <code>파드</code> 를 직접 가리키는 A 레코드(IP 주소)를 반환한다.</p>
<h3 id=셀렉터가-없는-경우>셀렉터가 없는 경우</h3>
<p>셀렉터를 정의하지 않는 헤드리스 서비스의 경우, 엔드포인트 컨트롤러는
<code>엔드포인트</code> 레코드를 생성하지 않는다. 그러나 DNS 시스템은 다음 중 하나를 찾고
구성한다.</p>
<ul>
<li><a href=#externalname><code>ExternalName</code></a>-유형 서비스에 대한 CNAME 레코드</li>
<li>다른 모든 유형에 대해, 서비스의 이름을 공유하는 모든 <code>엔드포인트</code>에
대한 레코드</li>
</ul>
<h2 id=publishing-services-service-types>서비스 퍼블리싱 (ServiceTypes)</h2>
<p>애플리케이션 중 일부(예: 프론트엔드)는 서비스를 클러스터 밖에
위치한 외부 IP 주소에 노출하고 싶은 경우가 있을 것이다.</p>
<p>쿠버네티스 <code>ServiceTypes</code>는 원하는 서비스 종류를 지정할 수 있도록 해준다.
기본 값은 <code>ClusterIP</code>이다.</p>
<p><code>Type</code> 값과 그 동작은 다음과 같다.</p>
<ul>
<li><code>ClusterIP</code>: 서비스를 클러스터-내부 IP에 노출시킨다. 이 값을 선택하면
클러스터 내에서만 서비스에 도달할 수 있다. 이것은
<code>ServiceTypes</code>의 기본 값이다.</li>
<li><a href=#type-nodeport><code>NodePort</code></a>: 고정 포트 (<code>NodePort</code>)로 각 노드의 IP에 서비스를
노출시킨다. <code>NodePort</code> 서비스가 라우팅되는 <code>ClusterIP</code> 서비스가
자동으로 생성된다. <code>&lt;NodeIP>:&lt;NodePort></code>를 요청하여,
클러스터 외부에서
<code>NodePort</code> 서비스에 접속할 수 있다.</li>
<li><a href=#loadbalancer><code>LoadBalancer</code></a>: 클라우드 공급자의 로드 밸런서를 사용하여
서비스를 외부에 노출시킨다. 외부 로드 밸런서가 라우팅되는
<code>NodePort</code>와 <code>ClusterIP</code> 서비스가 자동으로 생성된다.</li>
<li><a href=#externalname><code>ExternalName</code></a>: 값과 함께 CNAME 레코드를 리턴하여, 서비스를
<code>externalName</code> 필드의 콘텐츠 (예:<code>foo.bar.example.com</code>)에
매핑한다. 어떤 종류의 프록시도 설정되어 있지 않다.
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> <code>ExternalName</code> 유형을 사용하려면 kube-dns 버전 1.7 또는
CoreDNS 버전 1.7 이상이 필요하다.
</div></li>
</ul>
<p><a href=/ko/docs/concepts/services-networking/ingress/>인그레스</a>를 사용하여 서비스를 노출시킬 수도 있다. 인그레스는 서비스 유형이 아니지만, 클러스터의 진입점 역할을 한다. 동일한 IP 주소로 여러 서비스를
노출시킬 수 있기 때문에 라우팅 규칙을 단일 리소스로 통합할 수 있다.</p>
<h3 id=type-nodeport>NodePort 유형</h3>
<p><code>type</code> 필드를 <code>NodePort</code>로 설정하면, 쿠버네티스 컨트롤 플레인은
<code>--service-node-port-range</code> 플래그로 지정된 범위에서 포트를 할당한다 (기본값 : 30000-32767).
각 노드는 해당 포트 (모든 노드에서 동일한 포트 번호)를 서비스로 프록시한다.
서비스는 할당된 포트를 <code>.spec.ports[*].nodePort</code> 필드에 나타낸다.</p>
<p>포트를 프록시하기 위해 특정 IP를 지정하려면, kube-proxy에 대한
<code>--nodeport-addresses</code> 플래그 또는
<a href=/docs/reference/config-api/kube-proxy-config.v1alpha1/>kube-proxy 구성 파일</a>의
동등한 <code>nodePortAddresses</code> 필드를
특정 IP 블록으로 설정할 수 있다.</p>
<p>이 플래그는 쉼표로 구분된 IP 블록 목록(예: <code>10.0.0.0/8</code>, <code>192.0.2.0/25</code>)을 사용하여 kube-proxy가 로컬 노드로 고려해야 하는 IP 주소 범위를 지정한다.</p>
<p>예를 들어, <code>--nodeport-addresses=127.0.0.0/8</code> 플래그로 kube-proxy를 시작하면, kube-proxy는 NodePort 서비스에 대하여 루프백(loopback) 인터페이스만 선택한다. <code>--nodeport-addresses</code>의 기본 값은 비어있는 목록이다. 이것은 kube-proxy가 NodePort에 대해 사용 가능한 모든 네트워크 인터페이스를 고려해야 한다는 것을 의미한다. (이는 이전 쿠버네티스 릴리스와도 호환된다).</p>
<p>특정 포트 번호를 원한다면, <code>nodePort</code> 필드에 값을 지정할 수
있다. 컨트롤 플레인은 해당 포트를 할당하거나 API 트랜잭션이
실패했다고 보고한다.
이는 사용자 스스로 포트 충돌의 가능성을 고려해야 한다는 의미이다.
또한 NodePort 사용을 위해 구성된 범위 내에 있는, 유효한 포트 번호를
사용해야 한다.</p>
<p>NodePort를 사용하면 자유롭게 자체 로드 밸런싱 솔루션을 설정하거나,
쿠버네티스가 완벽하게 지원하지 않는 환경을 구성하거나,
하나 이상의 노드 IP를 직접 노출시킬 수 있다.</p>
<p>이 서비스는 <code>&lt;NodeIP>:spec.ports[*].nodePort</code>와
<code>.spec.clusterIP:spec.ports[*].port</code>로 표기된다.
kube-proxy에 대한 <code>--nodeport-addresses</code> 플래그 또는 kube-proxy 구성 파일의
동등한 필드가 설정된 경우, <code>&lt;NodeIP></code> 는 노드 IP를 필터링한다.</p>
<p>예를 들면</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>NodePort<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>MyApp<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 기본적으로 그리고 편의상 `targetPort` 는 `port` 필드와 동일한 값으로 설정된다.</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 선택적 필드</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 기본적으로 그리고 편의상 쿠버네티스 컨트롤 플레인은 포트 범위에서 할당한다(기본값: 30000-32767)</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>nodePort</span>:<span style=color:#bbb> </span><span style=color:#666>30007</span><span style=color:#bbb>
</span></code></pre></div><h3 id=loadbalancer>로드밸런서 유형</h3>
<p>외부 로드 밸런서를 지원하는 클라우드 공급자 상에서, <code>type</code>
필드를 <code>LoadBalancer</code>로 설정하면 서비스에 대한 로드 밸런서를 프로비저닝한다.
로드 밸런서의 실제 생성은 비동기적으로 수행되고,
프로비저닝된 밸런서에 대한 정보는 서비스의
<code>.status.loadBalancer</code> 필드에 발행된다.
예를 들면</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>MyApp<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>9376</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>clusterIP</span>:<span style=color:#bbb> </span><span style=color:#666>10.0.171.239</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>LoadBalancer<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>loadBalancer</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>ingress</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>ip</span>:<span style=color:#bbb> </span><span style=color:#666>192.0.2.127</span><span style=color:#bbb>
</span></code></pre></div><p>외부 로드 밸런서의 트래픽은 백엔드 파드로 전달된다. 클라우드 공급자는 로드 밸런싱 방식을 결정한다.</p>
<p>일부 클라우드 공급자는 <code>loadBalancerIP</code>를 지정할 수 있도록 허용한다. 이 경우, 로드 밸런서는
사용자 지정 <code>loadBalancerIP</code>로 생성된다. <code>loadBalancerIP</code> 필드가 지정되지 않으면,
임시 IP 주소로 loadBalancer가 설정된다. <code>loadBalancerIP</code>를 지정했지만
클라우드 공급자가 이 기능을 지원하지 않는 경우, 설정한 <code>loadbalancerIP</code> 필드는
무시된다.</p>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> <p><strong>Azure</strong> 에서 사용자 지정 공개(public) 유형 <code>loadBalancerIP</code>를 사용하려면, 먼저
정적 유형 공개 IP 주소 리소스를 생성해야 한다. 이 공개 IP 주소 리소스는
클러스터에서 자동으로 생성된 다른 리소스와 동일한 리소스 그룹에 있어야 한다.
예를 들면, <code>MC_myResourceGroup_myAKSCluster_eastus</code>이다.</p>
<p>할당된 IP 주소를 loadBalancerIP로 지정한다. 클라우드 공급자 구성 파일에서 securityGroupName을 업데이트했는지 확인한다. <code>CreatingLoadBalancerFailed</code> 권한 문제 해결에 대한 자세한 내용은 <a href=https://docs.microsoft.com/en-us/azure/aks/static-ip>Azure Kubernetes Service (AKS) 로드 밸런서에서 고정 IP 주소 사용</a> 또는 <a href=https://github.com/Azure/AKS/issues/357>고급 네트워킹 AKS 클러스터에서 CreateLoadBalancerFailed</a>를 참고한다.</p>
</div>
<h4 id=프로토콜-유형이-혼합된-로드밸런서>프로토콜 유형이 혼합된 로드밸런서</h4>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.20 [alpha]</code>
</div>
<p>기본적으로 로드밸런서 서비스 유형의 경우 둘 이상의 포트가 정의되어 있을 때 모든
포트는 동일한 프로토콜을 가져야 하며 프로토콜은 클라우드 공급자가
지원하는 프로토콜이어야 한다.</p>
<p>kube-apiserver에 대해 기능 게이트 <code>MixedProtocolLBService</code>가 활성화된 경우 둘 이상의 포트가 정의되어 있을 때 다른 프로토콜을 사용할 수 있다.</p>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> 로드밸런서 서비스 유형에 사용할 수 있는 프로토콜 세트는 여전히 클라우드 제공 업체에서 정의한다.
</div>
<h4 id=로드밸런서-nodeport-할당-비활성화>로드밸런서 NodePort 할당 비활성화</h4>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.22 [beta]</code>
</div>
<p><code>type=LoadBalancer</code> 서비스에 대한 노드 포트 할당을 선택적으로 비활성화할 수 있으며,
이는 <code>spec.allocateLoadBalancerNodePorts</code> 필드를 <code>false</code>로 설정하면 된다.
노드 포트를 사용하지 않고 트래픽을 파드로 직접 라우팅하는 로드 밸런서 구현에만 사용해야 한다.
기본적으로 <code>spec.allocateLoadBalancerNodePorts</code>는 <code>true</code>이며 로드밸런서 서비스 유형은 계속해서 노드 포트를 할당할 것이다.
노드 포트가 할당된 기존 서비스에서 <code>spec.allocateLoadBalancerNodePorts</code>가 <code>false</code>로 설정된 경우
해당 노드 포트는 자동으로 할당 해제되지 <strong>않는다</strong>.
이러한 노드 포트를 할당 해제하려면 모든 서비스 포트에서 <code>nodePorts</code> 항목을 명시적으로 제거해야 한다.
이 필드를 사용하려면 클러스터에 <code>ServiceLBNodePortControl</code>
<a href=/ko/docs/reference/command-line-tools-reference/feature-gates/>기능 게이트</a>가 활성화되어 있어야 한다.
쿠버네티스 v1.23에서, 이 기능 게이트는 기본적으로 활성화되어 있으므로,
<code>spec.allocateLoadBalancerNodePorts</code> 필드를 사용할 수 있다.
다른 버전의 쿠버네티스를 실행하는 클러스터에 대해서는, 해당 릴리스의 문서를 참조한다.</p>
<h4 id=load-balancer-class>로드 밸런서 구현 클래스 지정</h4>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.22 [beta]</code>
</div>
<p><code>spec.loadBalancerClass</code> 필드를 설정하여 클라우드 제공자가 설정한 기본값 이외의 로드 밸런서 구현을 사용할 수 있다.
이 필드를 사용하기 위해서는 클러스터에 <code>ServiceLoadBalancerClass</code> <a href=/ko/docs/reference/command-line-tools-reference/feature-gates/>기능 게이트</a>가 활성화되어 있어야 한다.
쿠버네티스 v1.23에서, 이 기능 게이트는 기본적으로 활성화되어 있다. 다른 버전의 쿠버네티스를 실행하는 클러스터에 대해서는, 해당 릴리스의 문서를 참조한다.
기본적으로, <code>spec.loadBalancerClass</code> 는 <code>nil</code> 이고,
클러스터가 클라우드 제공자의 로드밸런서를 이용하도록 <code>--cloud-provider</code> 컴포넌트 플래그를 이용하여 설정되어 있으면
<code>LoadBalancer</code> 유형의 서비스는 클라우드 공급자의 기본 로드 밸런서 구현을 사용한다.
<code>spec.loadBalancerClass</code> 가 지정되면, 지정된 클래스와 일치하는 로드 밸런서
구현이 서비스를 감시하고 있다고 가정한다.
모든 기본 로드 밸런서 구현(예: 클라우드 공급자가 제공하는
로드 밸런서 구현)은 이 필드가 설정된 서비스를 무시한다.
<code>spec.loadBalancerClass</code> 는 <code>LoadBalancer</code> 유형의 서비스에서만 설정할 수 있다.
한 번 설정하면 변경할 수 없다.
<code>spec.loadBalancerClass</code> 의 값은 "<code>internal-vip</code>" 또는
"<code>example.com/internal-vip</code>" 와 같은 선택적 접두사가 있는 레이블 스타일 식별자여야 한다.
접두사가 없는 이름은 최종 사용자를 위해 예약되어 있다.</p>
<h4 id=내부-로드-밸런서>내부 로드 밸런서</h4>
<p>혼재된 환경에서는 서비스의 트래픽을 동일한 (가상) 네트워크 주소 블록 내로
라우팅해야 하는 경우가 있다.</p>
<p>수평 분할 DNS 환경에서는 외부와 내부 트래픽을 엔드포인트로 라우팅 할 수 있는 두 개의 서비스가 필요하다.</p>
<p>내부 로드 밸런서를 설정하려면, 사용 중인 클라우드 서비스 공급자에 따라
다음의 어노테이션 중 하나를 서비스에 추가한다.</p>
<ul class="nav nav-tabs" id=service-tabs role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#service-tabs-0 role=tab aria-controls=service-tabs-0 aria-selected=true>Default</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#service-tabs-1 role=tab aria-controls=service-tabs-1>GCP</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#service-tabs-2 role=tab aria-controls=service-tabs-2>AWS</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#service-tabs-3 role=tab aria-controls=service-tabs-3>Azure</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#service-tabs-4 role=tab aria-controls=service-tabs-4>IBM Cloud</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#service-tabs-5 role=tab aria-controls=service-tabs-5>OpenStack</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#service-tabs-6 role=tab aria-controls=service-tabs-6>Baidu Cloud</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#service-tabs-7 role=tab aria-controls=service-tabs-7>Tencent Cloud</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#service-tabs-8 role=tab aria-controls=service-tabs-8>Alibaba Cloud</a></li></ul>
<div class=tab-content id=service-tabs><div id=service-tabs-0 class="tab-pane show active" role=tabpanel aria-labelledby=service-tabs-0>
<p><p>탭 중 하나를 선택</p>
</div>
<div id=service-tabs-1 class=tab-pane role=tabpanel aria-labelledby=service-tabs-1>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>[...]<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cloud.google.com/load-balancer-type</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;Internal&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span>[...]<span style=color:#bbb>
</span></code></pre></div></div>
<div id=service-tabs-2 class=tab-pane role=tabpanel aria-labelledby=service-tabs-2>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>[...]<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-internal</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span>[...]<span style=color:#bbb>
</span></code></pre></div></div>
<div id=service-tabs-3 class=tab-pane role=tabpanel aria-labelledby=service-tabs-3>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>[...]<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/azure-load-balancer-internal</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span>[...]<span style=color:#bbb>
</span></code></pre></div></div>
<div id=service-tabs-4 class=tab-pane role=tabpanel aria-labelledby=service-tabs-4>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>[...]<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.kubernetes.io/ibm-load-balancer-cloud-provider-ip-type</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;private&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span>[...]<span style=color:#bbb>
</span></code></pre></div></div>
<div id=service-tabs-5 class=tab-pane role=tabpanel aria-labelledby=service-tabs-5>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>[...]<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/openstack-internal-load-balancer</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span>[...]<span style=color:#bbb>
</span></code></pre></div></div>
<div id=service-tabs-6 class=tab-pane role=tabpanel aria-labelledby=service-tabs-6>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>[...]<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/cce-load-balancer-internal-vpc</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span>[...]<span style=color:#bbb>
</span></code></pre></div></div>
<div id=service-tabs-7 class=tab-pane role=tabpanel aria-labelledby=service-tabs-7>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>[...]<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>service.kubernetes.io/qcloud-loadbalancer-internal-subnetid</span>:<span style=color:#bbb> </span>subnet-xxxxx<span style=color:#bbb>
</span><span style=color:#bbb></span>[...]<span style=color:#bbb>
</span></code></pre></div></div>
<div id=service-tabs-8 class=tab-pane role=tabpanel aria-labelledby=service-tabs-8>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>[...]<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/alibaba-cloud-loadbalancer-address-type</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;intranet&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span>[...]<span style=color:#bbb>
</span></code></pre></div></div></div>
<h4 id=ssl-support-on-aws>AWS에서 TLS 지원</h4>
<p>AWS에서 실행되는 클러스터에서 부분적으로 TLS / SSL을 지원하기 위해, <code>LoadBalancer</code> 서비스에 세 가지
어노테이션을 추가할 수 있다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-ssl-cert</span>:<span style=color:#bbb> </span>arn:aws:acm:us-east-1:123456789012:certificate/12345678-1234-1234-1234-123456789012<span style=color:#bbb>
</span></code></pre></div><p>첫 번째는 사용할 인증서의 ARN을 지정한다. IAM에 업로드된
써드파티 발급자의 인증서이거나 AWS Certificate Manager에서
생성된 인증서일 수 있다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-backend-protocol</span>:<span style=color:#bbb> </span>(https|http|ssl|tcp)<span style=color:#bbb>
</span></code></pre></div><p>두 번째 어노테이션은 파드가 알려주는 프로토콜을 지정한다. HTTPS와
SSL의 경우, ELB는 인증서를 사용하여 암호화된 연결을 통해 파드가 스스로를
인증할 것으로 예상한다.</p>
<p>HTTP와 HTTPS는 7 계층 프록시를 선택한다. ELB는 요청을 전달할 때
사용자와의 연결을 종료하고, 헤더를 파싱하고 사용자의 IP 주소로 <code>X-Forwarded-For</code>
헤더를 삽입한다. (파드는 해당 연결의 다른 종단에서의
ELB의 IP 주소만 참조)</p>
<p>TCP 및 SSL은 4 계층 프록시를 선택한다. ELB는 헤더를 수정하지 않고
트래픽을 전달한다.</p>
<p>일부 포트는 보안성을 갖추고 다른 포트는 암호화되지 않은 혼재된 사용 환경에서는
다음 어노테이션을 사용할 수 있다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-backend-protocol</span>:<span style=color:#bbb> </span>http<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-ssl-ports</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;443,8443&#34;</span><span style=color:#bbb>
</span></code></pre></div><p>위의 예에서, 서비스에 <code>80</code>, <code>443</code>, <code>8443</code>의 3개 포트가 포함된 경우,
<code>443</code>, <code>8443</code>은 SSL 인증서를 사용하지만, <code>80</code>은 프록시하는 HTTP이다.</p>
<p>쿠버네티스 v1.9부터는 서비스에 대한 HTTPS 또는 SSL 리스너와 함께 <a href=https://docs.aws.amazon.com/elasticloadbalancing/latest/classic/elb-security-policy-table.html>사전에 정의된 AWS SSL 정책</a>을 사용할 수 있다.
사용 가능한 정책을 확인하려면, <code>aws</code> 커맨드라인 툴을 사용한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>aws elb describe-load-balancer-policies --query <span style=color:#b44>&#39;PolicyDescriptions[].PolicyName&#39;</span>
</code></pre></div><p>그리고
"<code>service.beta.kubernetes.io/aws-load-balancer-ssl-negotiation-policy</code>"
어노테이션을 사용하여 이러한 정책 중 하나를 지정할 수 있다. 예를 들면</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-ssl-negotiation-policy</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;ELBSecurityPolicy-TLS-1-2-2017-01&#34;</span><span style=color:#bbb>
</span></code></pre></div><h4 id=aws에서-지원하는-프록시-프로토콜>AWS에서 지원하는 프록시 프로토콜</h4>
<p>AWS에서 실행되는 클러스터에 대한 <a href=https://www.haproxy.org/download/1.8/doc/proxy-protocol.txt>프록시 프로토콜</a>
지원을 활성화하려면, 다음의 서비스 어노테이션을
사용할 수 있다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-proxy-protocol</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;*&#34;</span><span style=color:#bbb>
</span></code></pre></div><p>버전 1.3.0 부터, 이 어노테이션의 사용은 ELB에 의해 프록시되는 모든 포트에 적용되며
다르게 구성할 수 없다.</p>
<h4 id=aws의-elb-접근-로그>AWS의 ELB 접근 로그</h4>
<p>AWS ELB 서비스의 접근 로그를 관리하기 위한 몇 가지 어노테이션이 있다.</p>
<p><code>service.beta.kubernetes.io/aws-load-balancer-access-log-enabled</code> 어노테이션은
접근 로그의 활성화 여부를 제어한다.</p>
<p><code>service.beta.kubernetes.io/aws-load-balancer-access-log-emit-interval</code> 어노테이션은
접근 로그를 게시하는 간격을 분 단위로 제어한다. 5분 또는 60분의
간격으로 지정할 수 있다.</p>
<p><code>service.beta.kubernetes.io/aws-load-balancer-access-log-s3-bucket-name</code> 어노테이션은
로드 밸런서 접근 로그가 저장되는 Amazon S3 버킷의 이름을
제어한다.</p>
<p><code>service.beta.kubernetes.io/aws-load-balancer-access-log-s3-bucket-prefix</code> 어노테이션은
Amazon S3 버킷을 생성한 논리적 계층을 지정한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-access-log-enabled</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># 로드 밸런서의 접근 로그 활성화 여부를 명시.</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-access-log-emit-interval</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;60&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># 접근 로그를 게시하는 간격을 분 단위로 제어. 5분 또는 60분의 간격을 지정.</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-access-log-s3-bucket-name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;my-bucket&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># 로드 밸런서 접근 로그가 저장되는 Amazon S3 버킷의 이름 명시.</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-access-log-s3-bucket-prefix</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;my-bucket-prefix/prod&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># Amazon S3 버킷을 생성한 논리적 계층을 지정. 예: `my-bucket-prefix/prod`</span><span style=color:#bbb>
</span></code></pre></div><h4 id=aws의-연결-드레이닝-draining>AWS의 연결 드레이닝(Draining)</h4>
<p>Classic ELB의 연결 드레이닝은
<code>service.beta.kubernetes.io/aws-load-balancer-connection-draining-enabled</code> 어노테이션을
<code>"true"</code>값으로 설정하여 관리할 수 ​​있다. <code>service.beta.kubernetes.io/aws-load-balancer-connection-draining-timeout</code> 어노테이션을
사용하여 인스턴스를 해제하기 전에,
기존 연결을 열어 두는 목적으로 최대 시간을 초 단위로 설정할 수도 있다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-connection-draining-enabled</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-connection-draining-timeout</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;60&#34;</span><span style=color:#bbb>
</span></code></pre></div><h4 id=다른-elb-어노테이션>다른 ELB 어노테이션</h4>
<p>이하는 클래식 엘라스틱 로드 밸런서(Classic Elastic Load Balancers)를 관리하기 위한 다른 어노테이션이다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-connection-idle-timeout</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;60&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># 로드 밸런서가 연결을 닫기 전에, 유휴 상태(연결을 통해 전송 된 데이터가 없음)의 연결을 허용하는 초단위 시간</span><span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-cross-zone-load-balancing-enabled</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># 로드 밸런서에 교차-영역(cross-zone) 로드 밸런싱을 사용할 지 여부를 지정</span><span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-additional-resource-tags</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;environment=prod,owner=devops&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># 쉼표로 구분된 key-value 목록은 ELB에</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># 추가 태그로 기록됨</span><span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-healthcheck-healthy-threshold</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># 백엔드가 정상인 것으로 간주되는데 필요한 연속적인</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># 헬스 체크 성공 횟수이다. 기본값은 2이며, 2와 10 사이여야 한다.</span><span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-healthcheck-unhealthy-threshold</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;3&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># 백엔드가 비정상인 것으로 간주되는데 필요한</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># 헬스 체크 실패 횟수이다. 기본값은 6이며, 2와 10 사이여야 한다.</span><span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-healthcheck-interval</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;20&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># 개별 인스턴스의 상태 점검 사이의</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># 대략적인 간격 (초 단위). 기본값은 10이며, 5와 300 사이여야 한다.</span><span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-healthcheck-timeout</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;5&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># 헬스 체크 실패를 의미하는 무 응답의 총 시간 (초 단위)</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># 이 값은 service.beta.kubernetes.io/aws-load-balancer-healthcheck-interval</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># 값 보다 작아야한다. 기본값은 5이며, 2와 60 사이여야 한다.</span><span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-security-groups</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;sg-53fae93f&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># 생성된 ELB에 설정할 기존 보안 그룹(security group) 목록.</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># service.beta.kubernetes.io/aws-load-balancer-extra-security-groups 어노테이션과 달리, 이는 이전에 ELB에 할당된 다른 모든 보안 그룹을 대체하며,</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># &#39;해당 ELB를 위한 고유 보안 그룹 생성&#39;을 오버라이드한다.</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># 목록의 첫 번째 보안 그룹 ID는 인바운드 트래픽(서비스 트래픽과 헬스 체크)이 워커 노드로 향하도록 하는 규칙으로 사용된다.</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># 여러 ELB가 하나의 보안 그룹 ID와 연결되면, 1줄의 허가 규칙만이 워커 노드 보안 그룹에 추가된다.</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># 즉, 만약 여러 ELB 중 하나를 지우면, 1줄의 허가 규칙이 삭제되어, 같은 보안 그룹 ID와 연결된 모든 ELB에 대한 접속이 막힌다.</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># 적절하게 사용되지 않으면 이는 다수의 서비스가 중단되는 상황을 유발할 수 있다.</span><span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-extra-security-groups</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;sg-53fae93f,sg-42efd82e&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># 생성된 ELB에 추가할 추가 보안 그룹 목록</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># 이 방법을 사용하면 이전에 생성된 고유 보안 그룹이 그대로 유지되므로, 각 ELB가 고유 보안 그룹 ID와 그에 매칭되는 허가 규칙 라인을 소유하여</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># 트래픽(서비스 트래픽과 헬스 체크)이 워커 노드로 향할 수 있도록 한다. 여기에 기재되는 보안 그룹은 여러 서비스 간 공유될 수 있다.</span><span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-target-node-labels</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;ingress-gw,gw-name=public-api&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># 로드 밸런서의 대상 노드를 선택하는 데</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># 사용되는 키-값 쌍의 쉼표로 구분된 목록</span><span style=color:#bbb>
</span></code></pre></div><h4 id=aws-nlb-support>AWS의 네트워크 로드 밸런서 지원</h4>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.15 [beta]</code>
</div>
<p>AWS에서 네트워크 로드 밸런서를 사용하려면, <code>nlb</code> 값이 설정된 <code>service.beta.kubernetes.io/aws-load-balancer-type</code> 어노테이션을 사용한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-type</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;nlb&#34;</span><span style=color:#bbb>
</span></code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> NLB는 특정 인스턴스 클래스에서만 작동한다. 지원되는 인스턴스 유형 목록은 엘라스틱 로드 밸런싱에 대한 <a href=https://docs.aws.amazon.com/elasticloadbalancing/latest/network/target-group-register-targets.html#register-deregister-targets>AWS 문서</a>
를 참고한다.
</div>
<p>클래식 엘라스틱 로드 밸런서와 달리, 네트워크 로드 밸런서 (NLB)는
클라이언트의 IP 주소를 노드로 전달한다. 서비스의 <code>.spec.externalTrafficPolicy</code>가
<code>Cluster</code>로 설정되어 있으면, 클라이언트의 IP 주소가 종단 파드로
전파되지 않는다.</p>
<p><code>.spec.externalTrafficPolicy</code>를 <code>Local</code>로 설정하면, 클라이언트 IP 주소가
종단 파드로 전파되지만, 트래픽이 고르지 않게
분배될 수 있다. 특정 로드밸런서 서비스를 위한 파드가 없는 노드는 자동 할당된
<code>.spec.healthCheckNodePort</code>에 의해서 NLB 대상 그룹의
헬스 체크에 실패하고 트래픽을 수신하지 못하게 된다.</p>
<p>트래픽을 균일하게 하려면, DaemonSet을 사용하거나,
<a href=/ko/docs/concepts/scheduling-eviction/assign-pod-node/#%EC%96%B4%ED%94%BC%EB%8B%88%ED%8B%B0-affinity-%EC%99%80-%EC%95%88%ED%8B%B0-%EC%96%B4%ED%94%BC%EB%8B%88%ED%8B%B0-anti-affinity>파드 안티어피니티(pod anti-affinity)</a>
를 지정하여 동일한 노드에 위치하지 않도록 한다.</p>
<p><a href=/ko/docs/concepts/services-networking/service/#internal-load-balancer>내부 로드 밸런서</a> 어노테이션과 함께 NLB 서비스를
사용할 수도 있다.</p>
<p>클라이언트 트래픽이 NLB 뒤의 인스턴스에 도달하기 위해, 노드 보안
그룹은 다음 IP 규칙으로 수정된다.</p>
<table>
<thead>
<tr>
<th>규칙</th>
<th>프로토콜</th>
<th>포트</th>
<th>IP 범위</th>
<th>IP 범위 설명</th>
</tr>
</thead>
<tbody>
<tr>
<td>헬스 체크</td>
<td>TCP</td>
<td>NodePort(s) (<code>.spec.healthCheckNodePort</code> for <code>.spec.externalTrafficPolicy = Local</code>)</td>
<td>Subnet CIDR</td>
<td>kubernetes.io/rule/nlb/health=&lt;loadBalancerName></td>
</tr>
<tr>
<td>클라이언트 트래픽</td>
<td>TCP</td>
<td>NodePort(s)</td>
<td><code>.spec.loadBalancerSourceRanges</code> (defaults to <code>0.0.0.0/0</code>)</td>
<td>kubernetes.io/rule/nlb/client=&lt;loadBalancerName></td>
</tr>
<tr>
<td>MTU 탐색</td>
<td>ICMP</td>
<td>3,4</td>
<td><code>.spec.loadBalancerSourceRanges</code> (defaults to <code>0.0.0.0/0</code>)</td>
<td>kubernetes.io/rule/nlb/mtu=&lt;loadBalancerName></td>
</tr>
</tbody>
</table>
<p>네트워크 로드 밸런서에 접근할 수 있는 클라이언트 IP를 제한하려면,
<code>loadBalancerSourceRanges</code>를 지정한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>loadBalancerSourceRanges</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;143.231.0.0/16&#34;</span><span style=color:#bbb>
</span></code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> <code>.spec.loadBalancerSourceRanges</code>가 설정되어 있지 않으면, 쿠버네티스는
<code>0.0.0.0/0</code>에서 노드 보안 그룹으로의 트래픽을 허용한다. 노드에 퍼블릭 IP 주소가
있는 경우, 비(non)-NLB 트래픽도 해당 수정된 보안 그룹의
모든 인스턴스에 도달할 수 있다.
</div>
<p>엘라스틱 IP에 대한 설명 문서와 기타 일반적 사용 사례를
<a href=https://kubernetes-sigs.github.io/aws-load-balancer-controller/latest/guide/service/annotations/>AWS 로드 밸런서 컨트롤러 문서</a>에서 볼 수 있다.</p>
<h4 id=tencent-kubernetes-engine-tke-의-다른-clb-어노테이션>Tencent Kubernetes Engine (TKE)의 다른 CLB 어노테이션</h4>
<p>아래 표시된 것처럼 TKE에서 클라우드 로드 밸런서를 관리하기 위한 다른 어노테이션이 있다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># 지정된 노드로 로드 밸런서 바인드</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.kubernetes.io/qcloud-loadbalancer-backends-label</span>:<span style=color:#bbb> </span>key in (value1, value2)<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># 기존 로드 밸런서의 ID</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span>service.kubernetes.io/tke-existed-lbid：lb-6swtxxxx<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># 로드 밸런서 (LB)에 대한 사용자 지정 매개 변수는 아직 LB 유형 수정을 지원하지 않음</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.kubernetes.io/service.extensiveParameters</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># LB 리스너의 사용자 정의 매개 변수</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.kubernetes.io/service.listenerParameters</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># 로드 밸런서 유형 지정</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># 유효 값 : 클래식 (클래식 클라우드 로드 밸런서) 또는 애플리케이션 (애플리케이션 클라우드 로드 밸런서)</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.kubernetes.io/loadbalance-type</span>:<span style=color:#bbb> </span>xxxxx<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># 퍼블릭 네트워크 대역폭 청구 방법 지정</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># 유효 값: TRAFFIC_POSTPAID_BY_HOUR (트래픽 별) 및 BANDWIDTH_POSTPAID_BY_HOUR (대역폭 별)</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.kubernetes.io/qcloud-loadbalancer-internet-charge-type</span>:<span style=color:#bbb> </span>xxxxxx<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># 대역폭 값 지정 (값 범위 : [1,2000] Mbps).</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.kubernetes.io/qcloud-loadbalancer-internet-max-bandwidth-out</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;10&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># 이 어느테이션이 설정되면, 로드 밸런서는 파드가</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># 실행중인 노드만 등록하고, 그렇지 않으면 모든 노드가 등록됨</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.kubernetes.io/local-svc-only-bind-node-with-pod</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></code></pre></div><h3 id=externalname>ExternalName 유형</h3>
<p>ExternalName 유형의 서비스는 <code>my-service</code> 또는 <code>cassandra</code>와 같은 일반적인 셀렉터에 대한 서비스가 아닌,
DNS 이름에 대한 서비스에 매핑한다. <code>spec.externalName</code> 파라미터를 사용하여 이러한 서비스를 지정한다.</p>
<p>예를 들면, 이 서비스 정의는 <code>prod</code> 네임 스페이스의
<code>my-service</code> 서비스를 <code>my.database.example.com</code>에 매핑한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>prod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>ExternalName<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>externalName</span>:<span style=color:#bbb> </span>my.database.example.com<span style=color:#bbb>
</span></code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> ExternalName은 IPv4 주소 문자열을 허용하지만, IP 주소가 아닌 숫자로 구성된 DNS 이름을 허용한다. IPv4 주소와 유사한 ExternalName은 CoreDNS 또는 ingress-nginx에 의해 확인되지 않는데, ExternalName은
정식(canonical) DNS 이름을 지정하기 때문이다. IP 주소를 하드 코딩하려면,
<a href=#%ED%97%A4%EB%93%9C%EB%A6%AC%EC%8A%A4-headless-%EC%84%9C%EB%B9%84%EC%8A%A4>헤드리스(headless) 서비스</a> 사용을 고려한다.
</div>
<p><code>my-service.prod.svc.cluster.local</code> 호스트를 검색하면, 클러스터 DNS 서비스는
<code>my.database.example.com</code> 값의 <code>CNAME</code> 레코드를 반환한다. <code>my-service</code>에 접근하는 것은
다른 서비스와 같은 방식으로 작동하지만, 리다이렉션은 프록시 또는
포워딩을 통하지 않고 DNS 수준에서 발생한다는 중요한
차이점이 있다. 나중에 데이터베이스를 클러스터로 이동하기로 결정한 경우, 해당
파드를 시작하고 적절한 셀렉터 또는 엔드포인트를 추가하고,
서비스의 <code>유형(type)</code>을 변경할 수 있다.</p>
<div class="alert alert-danger warning callout" role=alert>
<strong>경고:</strong> <p>HTTP 및 HTTPS를 포함한, 몇몇 일반적인 프로토콜에 ExternalName을 사용하는 것은 문제가 있을 수 있다. ExternalName을 사용하는 경우, 클러스터 내부의 클라이언트가 사용하는 호스트 이름(hostname)이 ExternalName이 참조하는 이름과 다르다.</p>
<p>호스트 이름을 사용하는 프로토콜의 경우, 이러한 차이로 인해 오류가 발생하거나 예기치 않은 응답이 발생할 수 있다. HTTP 요청에는 오리진(origin) 서버가 인식하지 못하는 <code>Host :</code> 헤더가 있다. TLS 서버는 클라이언트가 연결된 호스트 이름과 일치하는 인증서를 제공할 수 없다.</p>
</div>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> 이 섹션은 <a href=https://akomljen.com/>Alen Komljen</a>의 <a href=https://akomljen.com/kubernetes-tips-part-1/>쿠버네티스 팁 - Part
1</a> 블로그 게시물에 대한 내용이다.
</div>
<h3 id=외부-ip>외부 IP</h3>
<p>하나 이상의 클러스터 노드로 라우팅되는 외부 IP가 있는 경우, 쿠버네티스 서비스는 이러한
<code>externalIPs</code>에 노출될 수 있다. 서비스 포트에서 외부 IP (목적지 IP)를 사용하여 클러스터로 들어오는 트래픽은
서비스 엔드포인트 중 하나로 라우팅된다. <code>externalIPs</code>는 쿠버네티스에 의해 관리되지 않으며
클러스터 관리자에게 책임이 있다.</p>
<p>서비스 명세에서, <code>externalIPs</code>는 모든 <code>ServiceTypes</code>와 함께 지정할 수 있다.
아래 예에서, 클라이언트는 "<code>80.11.12.10:80</code>"(<code>외부 IP:포트</code>)로 "<code>my-service</code>"에 접근할 수 있다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>MyApp<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>http<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>9376</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>externalIPs</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:#666>80.11.12.10</span><span style=color:#bbb>
</span></code></pre></div><h2 id=단점>단점</h2>
<p>VIP용 유저스페이스 프록시를 사용하면 중소 규모의 스케일에서는 동작하지만, 수천 개의
서비스가 포함된 대규모 클러스터로는 확장되지 않는다.
<a href=https://github.com/kubernetes/kubernetes/issues/1107>포털에 대한 독창적인 설계 제안</a>에 이에 대한 자세한 내용이
있다.</p>
<p>유저스페이스 프록시를 사용하면 서비스에 접근하는 패킷의 소스 IP 주소가
가려진다.
이것은 일종의 네트워크 필터링 (방화벽)을 불가능하게 만든다. iptables
프록시 모드는 클러스터 내
소스 IP를 가리지 않지만, 여전히 로드 밸런서 또는 노드-포트를 통해 오는
클라이언트에 영향을 미친다.</p>
<p><code>Type</code> 필드는 중첩된 기능으로 설계되었다. - 각 레벨은 이전 레벨에
추가된다. 이는 모든 클라우드 공급자에 반드시 필요한 것은 아니지만, (예: Google Compute Engine는
<code>LoadBalancer</code>를 작동시키기 위해 <code>NodePort</code>를 할당할 필요는 없지만, AWS는 필요하다)
현재 API에는 필요하다.</p>
<h2 id=the-gory-details-of-virtual-ips>가상 IP 구현</h2>
<p>서비스를 사용하려는 많은 사람들에게 이전 정보가
충분해야 한다. 그러나, 이해가 필요한 부분 뒤에는
많은 일이 있다.</p>
<h3 id=충돌-방지>충돌 방지</h3>
<p>쿠버네티스의 주요 철학 중 하나는 잘못한 것이
없는 경우 실패할 수 있는 상황에 노출되어서는
안된다는 것이다. 서비스 리소스 설계 시, 다른 사람의 포트 선택과
충돌할 경우에 대비해 자신의 포트 번호를 선택하지
않아도 된다. 그것은 격리 실패이다.</p>
<p>서비스에 대한 포트 번호를 선택할 수 있도록 하기 위해, 두 개의
서비스가 충돌하지 않도록 해야 한다. 쿠버네티스는 각 서비스에 고유한 IP 주소를
할당하여 이를 수행한다.</p>
<p>각 서비스가 고유한 IP를 받도록 하기 위해, 내부 할당기는
각 서비스를 만들기 전에 <a class=glossary-tooltip title="모든 클러스터 데이터를 담는 쿠버네티스 뒷단의 저장소로 사용되는 일관성·고가용성 키-값 저장소." data-toggle=tooltip data-placement=top href=/docs/tasks/administer-cluster/configure-upgrade-etcd/ target=_blank aria-label=etcd>etcd</a>에서
글로벌 할당 맵을 원자적으로(atomically) 업데이트한다. 서비스가 IP 주소 할당을 가져오려면
레지스트리에 맵 오브젝트가 있어야 하는데, 그렇지 않으면
IP 주소를 할당할 수 없다는 메시지와 함께 생성에 실패한다.</p>
<p>컨트롤 플레인에서, 백그라운드 컨트롤러는 해당 맵을
생성해야 한다. (인-메모리 잠금을 사용하는 이전 버전의 쿠버네티스에서 마이그레이션
지원 필요함) 쿠버네티스는 또한 컨트롤러를 사용하여 유효하지 않은
할당 (예: 관리자 개입으로)을 체크하고 더 이상 서비스에서 사용하지 않는 할당된
IP 주소를 정리한다.</p>
<h3 id=ips-and-vips>서비스 IP 주소</h3>
<p>실제로 고정된 목적지로 라우팅되는 파드 IP 주소와 달리,
서비스 IP는 실제로 단일 호스트에서 응답하지 않는다. 대신에, kube-proxy는
iptables (리눅스의 패킷 처리 로직)를 필요에 따라
명백하게 리다이렉션되는 <em>가상</em> IP 주소를 정의하기 위해 사용한다. 클라이언트가 VIP에
연결하면, 트래픽이 자동으로 적절한 엔드포인트로 전송된다.
환경 변수와 서비스 용 DNS는 실제로 서비스의
가상 IP 주소 (및 포트)로 채워진다.</p>
<p>kube-proxy는 조금씩 다르게 작동하는 세 가지 프록시 모드—유저스페이스, iptables and IPVS—를
지원한다.</p>
<h4 id=유저스페이스-userspace>유저스페이스 (Userspace)</h4>
<p>예를 들어, 위에서 설명한 이미지 처리 애플리케이션을 고려한다.
백엔드 서비스가 생성되면, 쿠버네티스 마스터는 가상
IP 주소(예 : 10.0.0.1)를 할당한다. 서비스 포트를 1234라고 가정하면, 서비스는
클러스터의 모든 kube-proxy 인스턴스에서 관찰된다.
프록시가 새 서비스를 발견하면, 새로운 임의의 포트를 열고, 가상 IP 주소에서
이 새로운 포트로 iptables 리다이렉션을 설정한 후,
연결을 수락하기 시작한다.</p>
<p>클라이언트가 서비스의 가상 IP 주소에 연결하면, iptables
규칙이 시작되고, 패킷을 프록시의 자체 포트로 리다이렉션한다.
"서비스 프록시"는 백엔드를 선택하고, 클라이언트에서 백엔드로의 트래픽을 프록시하기 시작한다.</p>
<p>이는 서비스 소유자가 충돌 위험 없이 원하는 어떤 포트든 선택할 수 있음을
의미한다. 클라이언트는 실제로 접근하는 파드를 몰라도, IP와 포트에
연결할 수 있다.</p>
<h4 id=iptables>iptables</h4>
<p>다시 한번, 위에서 설명한 이미지 처리 애플리케이션을 고려한다.
백엔드 서비스가 생성되면, 쿠버네티스 컨트롤 플레인은 가상
IP 주소(예 : 10.0.0.1)를 할당한다. 서비스 포트를 1234라고 가정하면, 서비스는
클러스터의 모든 kube-proxy 인스턴스에서 관찰된다.
프록시가 새로운 서비스를 발견하면, 가상 IP 주소에서 서비스-별 규칙으로
리다이렉션되는 일련의 iptables 규칙을 설치한다. 서비스-별
규칙은 트래픽을 (목적지 NAT를 사용하여) 백엔드로 리다이렉션하는 엔드포인트-별 규칙에
연결한다.</p>
<p>클라이언트가 서비스의 가상 IP 주소에 연결하면 iptables 규칙이 시작한다.
(세션 어피니티(Affinity)에 따라 또는 무작위로) 백엔드가 선택되고 패킷이
백엔드로 리다이렉션된다. 유저스페이스 프록시와 달리, 패킷은 유저스페이스로
복사되지 않으며, 가상 IP 주소가 작동하기 위해 kube-proxy가
실행 중일 필요는 없으며, 노드는 변경되지 않은 클라이언트 IP 주소에서 오는
트래픽을 본다.</p>
<p>트래픽이 노드-포트 또는 로드 밸런서를 통해 들어오는 경우에도,
이와 동일한 기본 흐름이 실행되지만, 클라이언트 IP는 변경된다.</p>
<h4 id=ipvs>IPVS</h4>
<p>iptables 작업은 대규모 클러스터 (예: 10,000 서비스)에서 크게 느려진다.
IPVS는 로드 밸런싱을 위해 설계되었고 커널-내부 해시 테이블을 기반으로 한다. 따라서 IPVS 기반 kube-proxy로부터 많은 개수의 서비스에서 일관성 있는 성능을 가질 수 있다. 한편, IPVS 기반 kube-proxy는 보다 정교한 로드 밸런싱 알고리즘 (least conns, locality, weighted, persistence)을 가진다.</p>
<h2 id=api-오브젝트>API 오브젝트</h2>
<p>서비스는 쿠버네티스 REST API의 최상위 리소스이다. API 오브젝트에 대한
자세한 내용은 다음을 참고한다. <a href=/docs/reference/generated/kubernetes-api/v1.23/#service-v1-core>서비스 API 오브젝트</a></p>
<h2 id=protocol-support>지원되는 프로토콜</h2>
<h3 id=tcp>TCP</h3>
<p>모든 종류의 서비스에 TCP를 사용할 수 있으며, 이는 기본 네트워크 프로토콜이다.</p>
<h3 id=udp>UDP</h3>
<p>대부분의 서비스에 UDP를 사용할 수 있다. type=LoadBalancer 서비스의 경우, UDP 지원은
이 기능을 제공하는 클라우드 공급자에 따라 다르다.</p>
<h3 id=sctp>SCTP</h3>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.20 [stable]</code>
</div>
<p>SCTP 트래픽을 지원하는 네트워크 플러그인을 사용하는 경우 대부분의 서비스에 SCTP를 사용할 수 있다.
type=LoadBalancer 서비스의 경우 SCTP 지원은 이 기능을 제공하는
클라우드 공급자에 따라 다르다. (대부분 그렇지 않음)</p>
<h4 id=caveat-sctp-overview>경고</h4>
<h5 id=caveat-sctp-multihomed>멀티홈드(multihomed) SCTP 연결을 위한 지원</h5>
<div class="alert alert-danger warning callout" role=alert>
<strong>경고:</strong> <p>멀티홈 SCTP 연결을 위해서는 먼저 CNI 플러그인이 파드에 대해 멀티 인터페이스 및 IP 주소 할당이 지원되어야 한다.</p>
<p>멀티홈 SCTP 연결을 위한 NAT는 해당 커널 모듈 내에 특수한 로직을 필요로 한다.</p>
</div>
<h5 id=caveat-sctp-windows-os>윈도우</h5>
<div class="alert alert-danger warning callout" role=alert>
<strong>경고:</strong> SCTP는 윈도우 기반 노드를 지원하지 않는다.
</div>
<h5 id=caveat-sctp-kube-proxy-userspace>유저스페이스 kube-proxy</h5>
<div class="alert alert-danger warning callout" role=alert>
<strong>경고:</strong> kube-proxy는 유저스페이스 모드에 있을 때 SCTP 연결 관리를 지원하지 않는다.
</div>
<h3 id=http>HTTP</h3>
<p>클라우드 공급자가 이를 지원하는 경우, LoadBalancer 모드의
서비스를 사용하여 서비스의 엔드포인트로 전달하는 외부 HTTP / HTTPS 리버스 프록시를
설정할 수 있다.</p>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> 서비스 대신 <a class=glossary-tooltip title="클러스터 내의 서비스에 대한 외부 접근을 관리하는 API 오브젝트이며, 일반적으로 HTTP를 관리함." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/services-networking/ingress/ target=_blank aria-label=인그레스>인그레스</a> 를 사용하여
HTTP/HTTPS 서비스를 노출할 수도 있다.
</div>
<h3 id=proxy-프로토콜>PROXY 프로토콜</h3>
<p>클라우드 공급자가 지원하는 경우에,
LoadBalancer 모드의 서비스를 사용하여 쿠버네티스 자체 외부에
로드 밸런서를 구성할 수 있으며, 이때 접두사가
<a href=https://www.haproxy.org/download/1.8/doc/proxy-protocol.txt>PROXY 프로토콜</a> 인 연결을 전달하게 된다.</p>
<p>로드 밸런서는 들어오는 연결을 설명하는 초기 일련의
옥텟(octets)을 전송하며, 이 예와 유사하게</p>
<pre><code>PROXY TCP4 192.0.2.202 10.0.42.7 12345 7\r\n
</code></pre><p>클라이언트 데이터가 뒤따라온다.</p>
<h2 id=다음-내용>다음 내용</h2>
<ul>
<li><a href=/ko/docs/concepts/services-networking/connect-applications-service/>서비스와 애플리케이션 연결</a> 알아보기</li>
<li><a href=/ko/docs/concepts/services-networking/ingress/>인그레스</a>에 대해 알아보기</li>
<li><a href=/ko/docs/concepts/services-networking/endpoint-slices/>엔드포인트슬라이스</a>에 대해 알아보기</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-3a38878244d862dfdb8d7adb32f77584>5.2 - 토폴로지 키를 사용하여 토폴로지-인지 트래픽 라우팅</h1>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.21 [deprecated]</code>
</div>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> 이 기능, 특히 알파 <code>topologyKeys</code> API는 쿠버네티스 v1.21부터
더 이상 사용되지 않는다.
쿠버네티스 v1.21에 도입된 <a href=/docs/concepts/services-networking/topology-aware-hints/>토폴로지 인지 힌트</a>는
유사한 기능을 제공한다.
</div>
<p><em>서비스 토폴로지</em> 를 활성화 하면 서비스는 클러스터의 노드 토폴로지를
기반으로 트래픽을 라우팅한다. 예를 들어, 서비스는 트래픽을
클라이언트와 동일한 노드이거나 동일한 가용성 영역에 있는 엔드포인트로
우선적으로 라우팅되도록 지정할 수 있다.</p>
<h2 id=소개>소개</h2>
<p>기본적으로 <code>ClusterIP</code> 또는 <code>NodePort</code> 서비스로 전송된 트래픽은 서비스의
모든 백엔드 주소로 라우팅될 수 있다. 쿠버네티스 1.7을 사용하면 트래픽을 수신한
동일한 노드에서 실행 중인 파드로 "외부(external)" 트래픽을 라우팅할 수
있다. <code>ClusterIP</code> 서비스의 경우, 라우팅에 대한 동일한 노드 기본 설정이
불가능했다. 또한 동일한 영역 내의 엔드 포인트에 대한 라우팅을 선호하도록
클러스터를 구성할 수도 없다.
서비스에 <code>topologyKeys</code> 를 설정하면, 출발 및 대상 노드에 대한
노드 레이블을 기반으로 트래픽을 라우팅하는 정책을 정의할 수 있다.</p>
<p>소스와 목적지 사이의 레이블 일치를 통해 클러스터 운영자는
서로 "근접(closer)"하거나 "먼(father)" 노드 그룹을 지정할 수 있다.
자신의 요구 사항에 맞는 메트릭을 나타내는 레이블을 정의할 수 있다.
예를 들어, 퍼블릭 클라우드에서는 지역 간의 트래픽에는 관련 비용이 발생(지역 내
트래픽은 일반적으로 그렇지 않다)하기 때문에, 네트워크 트래픽을 동일한 지역 내에 유지하는 것을
선호할 수 있다. 다른 일반적인 필요성으로는 데몬셋(DaemonSet)이 관리하는
로컬 파드로 트래픽을 라우팅하거나, 대기 시간을 최소화하기 위해
동일한 랙 상단(top-of-rack) 스위치에 연결된 노드로 트래픽을
유지하는 것이 있다.</p>
<h2 id=서비스-토폴로지-사용하기>서비스 토폴로지 사용하기</h2>
<p>만약 클러스터에서 <code>ServiceTopology</code> <a href=/ko/docs/reference/command-line-tools-reference/feature-gates/>기능 게이트</a>가 활성화된 경우, 서비스 사양에서
<code>topologyKeys</code> 필드를 지정해서 서비스 트래픽 라우팅을 제어할 수 있다. 이 필드는
이 서비스에 접근할 때 엔드포인트를 정렬하는데 사용되는 노드
레이블의 우선 순위 목록이다. 트래픽은 첫 번째 레이블 값이 해당 레이블의
발신 노드 값과 일치하는 노드로 보내진다. 만약 노드에 서비스와 일치하는
백엔드가 없는 경우, 두 번째 레이블을 그리고 더 이상의
레이블이 남지 않을 때까지 고려한다.</p>
<p>만약 일치하는 것을 못찾는 경우에는, 서비스에 대한 백엔드가 없었던 것처럼
트래픽이 거부될 것이다. 즉, 엔드포인트는 사용 가능한 백엔드가 있는 첫 번째
토폴로지 키를 기반으로 선택된다. 만약 이 필드가 지정되고 모든 항목에
클라이언트의 토폴로지와 일치하는 백엔드가 없는 경우, 서비스에는 해당 클라이언트에
대한 백엔드가 없기에 연결에 실패해야 한다. 특수한 값인 <code>"*"</code> 은 "모든 토폴로지"를
의미하는데 사용될 수 있다. 이 캐치 올(catch-all) 값을 사용하는 경우
목록의 마지막 값으로만 타당하다.</p>
<p>만약 <code>topologyKeys</code> 가 지정되지 않거나 비어있는 경우 토폴로지 제약 조건이 적용되지 않는다.</p>
<p>호스트 이름, 영역 이름 그리고 지역 이름으로 레이블이 지정된 노드가 있는
클러스터가 있다고 생각해 보자. 그러고 나면, 서비스의 <code>topologyKeys</code> 값을 설정해서 다음과 같이 트래픽을
전달할 수 있다.</p>
<ul>
<li>동일한 노드의 엔드포인트에만 해당하고, 엔드포인트가 노드에 없으면 실패한다:
<code>["kubernetes.io/hostname"]</code>.</li>
<li>동일한 노드의 엔드포인트를 선호하지만, 동일한 영역의 엔드포인트로 대체
한 후 동일한 지역으로 대체되고, 그렇지 않으면 실패한다: <code>["kubernetes.io/hostname", "topology.kubernetes.io/zone", "topology.kubernetes.io/region"]</code>.
예를 들어 데이터 위치가 중요한 경우에 유용할 수 있다.</li>
<li>동일한 영역이 선호되지만, 이 영역 내에 사용할 수 있는 항목이 없는 경우에는
사용가능한 엔드포인트로 대체된다:
<code>["topology.kubernetes.io/zone", "*"]</code>.</li>
</ul>
<h2 id=제약들>제약들</h2>
<ul>
<li>
<p>서비스 토폴로지는 <code>externalTrafficPolicy=Local</code> 와 호환되지 않으므로
서비스는 이 두 가지 기능을 함께 사용할 수 없다. 동일한 서비스가 아닌
같은 클러스터의 다른 서비스라면 이 기능을 함께 사용할
수 있다.</p>
</li>
<li>
<p>유효한 토폴로지 키는 현재 <code>kubernetes.io/hostname</code>,
<code>topology.kubernetes.io/zone</code> 그리고 <code>topology.kubernetes.io/region</code> 로
제한되어 있지만, 앞으로 다른 노드 레이블로 일반화 될 것이다.</p>
</li>
<li>
<p>토폴로지 키는 유효한 레이블 키이어야 하며 최대 16개의 키를 지정할 수 있다.</p>
</li>
<li>
<p>만약 캐치 올(catch-all) 값인 <code>"*"</code> 를 사용한다면 토폴로지 키들의 마지막 값이어야
한다.</p>
</li>
</ul>
<h2 id=예시들>예시들</h2>
<p>다음은 서비스 토폴로지 기능을 사용하는 일반적인 예시이다.</p>
<h3 id=노드-로컬-엔드포인트만>노드 로컬 엔드포인트만</h3>
<p>노드 로컬 엔드포인트로만 라우팅하는 서비스이다. 만약 노드에 엔드포인트가 없으면 트레픽이 드롭된다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>my-app<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>9376</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>topologyKeys</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;kubernetes.io/hostname&#34;</span><span style=color:#bbb>
</span></code></pre></div><h3 id=노드-로컬-엔드포인트-선호>노드 로컬 엔드포인트 선호</h3>
<p>노드 로컬 엔드포인트를 선호하지만, 노드 로컬 엔드포인트가 없는 경우 클러스터 전체 엔드포인트로 폴백 하는 서비스이다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>my-app<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>9376</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>topologyKeys</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;kubernetes.io/hostname&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;*&#34;</span><span style=color:#bbb>
</span></code></pre></div><h3 id=영역-또는-지리적-엔드포인트만>영역 또는 지리적 엔드포인트만</h3>
<p>영역보다는 지리적 엔드포인트를 선호하는 서비스이다. 만약 엔드포인트가 없다면, 트래픽은 드롭된다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>my-app<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>9376</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>topologyKeys</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;topology.kubernetes.io/zone&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;topology.kubernetes.io/region&#34;</span><span style=color:#bbb>
</span></code></pre></div><h3 id=노드-로컬-영역-및-지역-엔드포인트-선호>노드 로컬, 영역 및 지역 엔드포인트 선호</h3>
<p>노드 로컬, 영역 및 지역 엔드포인트를 선호하지만, 클러스터 전체 엔드포인트로 폴백하는 서비스이다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>my-app<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>9376</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>topologyKeys</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;kubernetes.io/hostname&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;topology.kubernetes.io/zone&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;topology.kubernetes.io/region&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;*&#34;</span><span style=color:#bbb>
</span></code></pre></div><h2 id=다음-내용>다음 내용</h2>
<ul>
<li><a href=/docs/tasks/administer-cluster/enabling-service-topology>서비스 토폴로지 활성화하기</a>를 읽어보기.</li>
<li><a href=/ko/docs/concepts/services-networking/connect-applications-service/>서비스와 애플리케이션 연결하기</a>를 읽어보기.</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-91cb8a4438b003df11bc1c426a81b756>5.3 - 서비스 및 파드용 DNS</h1>
<p>쿠버네티스는 파드와 서비스를 위한 DNS 레코드를 생성한다. 사용자는 IP 주소 대신에
일관된 DNS 네임을 통해서 서비스에 접속할 수 있다.</p>
<h2 id=소개>소개</h2>
<p>쿠버네티스 DNS는 클러스터의 서비스와 DNS 파드를 관리하며,
개별 컨테이너들이 DNS 네임을 해석할 때
DNS 서비스의 IP를 사용하도록 kubelets를 구성한다.</p>
<p>클러스터 내의 모든 서비스(DNS 서버 자신도 포함하여)에는 DNS 네임이 할당된다.
기본적으로 클라이언트 파드의 DNS 검색 리스트는 파드 자체의 네임스페이스와
클러스터의 기본 도메인을 포함한다.</p>
<h3 id=서비스의-네임스페이스>서비스의 네임스페이스</h3>
<p>DNS 쿼리는 그것을 생성하는 파드의 네임스페이스에 따라 다른 결과를 반환할 수
있다. 네임스페이스를 지정하지 않은 DNS 쿼리는 파드의 네임스페이스에
국한된다. DNS 쿼리에 네임스페이스를 명시하여 다른 네임스페이스에 있는 서비스에 접속한다.</p>
<p>예를 들어, <code>test</code> 네임스페이스에 있는 파드를 생각해보자. <code>data</code> 서비스는
<code>prod</code> 네임스페이스에 있다.</p>
<p>이 경우, <code>data</code> 에 대한 쿼리는 파드의 <code>test</code> 네임스페이스를 사용하기 때문에 결과를 반환하지 않을 것이다.</p>
<p><code>data.prod</code> 로 쿼리하면 의도한 결과를 반환할 것이다. 왜냐하면
네임스페이스가 명시되어 있기 때문이다.</p>
<p>DNS 쿼리는 파드의 <code>/etc/resolv.conf</code> 를 사용하여 확장될 수 있을 것이다. Kubelet은
각 파드에 대해서 파일을 설정한다. 예를 들어, <code>data</code> 만을 위한 쿼리는
<code>data.test.svc.cluster.local</code> 로 확장된다. <code>search</code> 옵션의 값은
쿼리를 확장하기 위해서 사용된다. DNS 쿼리에 대해 더 자세히 알고 싶은 경우,
<a href=https://www.man7.org/linux/man-pages/man5/resolv.conf.5.html><code>resolv.conf</code> 설명 페이지.</a>를 참고한다.</p>
<pre><code>nameserver 10.32.0.10
search &lt;namespace&gt;.svc.cluster.local svc.cluster.local cluster.local
options ndots:5
</code></pre><p>요약하면, <em>test</em> 네임스페이스에 있는 파드는 <code>data.prod</code> 또는
<code>data.prod.svc.cluster.local</code> 중 하나를 통해 성공적으로 해석될 수 있다.</p>
<h3 id=dns-레코드>DNS 레코드</h3>
<p>어떤 오브젝트가 DNS 레코드를 가지는가?</p>
<ol>
<li>서비스</li>
<li>파드</li>
</ol>
<p>다음 섹션은 지원되는 DNS 레코드의 종류 및 레이아웃에 대한 상세
내용이다. 혹시 동작시킬 필요가 있는 다른 레이아웃, 네임, 또는 쿼리는
구현 세부 사항으로 간주되며 경고 없이 변경될 수 있다.
최신 명세 확인을 위해서는,
<a href=https://github.com/kubernetes/dns/blob/master/docs/specification.md>쿠버네티스 DNS-기반 서비스 디스커버리</a>를 본다.</p>
<h2 id=서비스>서비스</h2>
<h3 id=a-aaaa-레코드>A/AAAA 레코드</h3>
<p>"노멀"(헤드리스가 아닌) 서비스는 서비스 IP 계열에 따라
<code>my-svc.my-namespace.svc.cluster-domain.example</code>
형식의 이름을 가진 DNS A 또는 AAAA 레코드가 할당된다. 이는 서비스의 클러스터
IP로 해석된다.</p>
<p>"헤드리스"(클러스터 IP가 없는) 서비스 또한 서비스 IP 계열에 따라
<code>my-svc.my-namespace.svc.cluster-domain.example</code>
형식의 이름을 가진 DNS A 또는 AAAA 레코드가 할당된다.
노멀 서비스와는 다르게 이는 서비스에 의해 선택된 파드들의 IP 집합으로 해석된다.
클라이언트는 해석된 IP 집합에서 IP를 직접 선택하거나 표준 라운드로빈을
통해 선택할 수 있다.</p>
<h3 id=srv-레코드>SRV 레코드</h3>
<p>SRV 레코드는 노멀 서비스 또는
<a href=/ko/docs/concepts/services-networking/service/#%ED%97%A4%EB%93%9C%EB%A6%AC%EC%8A%A4-headless-%EC%84%9C%EB%B9%84%EC%8A%A4>헤드리스 서비스</a>에
속하는 네임드 포트를 위해 만들어졌다. 각각의 네임드 포트에 대해서 SRV 레코드는 다음과 같은 형식을 가질 수 있다.
<code>_my-port-name._my-port-protocol.my-svc.my-namespace.svc.cluster-domain.example</code>.
정규 서비스의 경우, 이는 포트 번호와 도메인 네임으로 해석된다.
<code>my-svc.my-namespace.svc.cluster-domain.example</code>.
헤드리스 서비스의 경우, 서비스를 지원하는 각 파드에 대해 하나씩 복수 응답으로 해석되며 이 응답은 파드의
포트 번호와 도메인 이름을 포함한다.
<code>auto-generated-name.my-svc.my-namespace.svc.cluster-domain.example</code>.</p>
<h2 id=파드>파드</h2>
<h3 id=a-aaaa-레코드-1>A/AAAA 레코드</h3>
<p>일반적으로 파드에는 다음과 같은 DNS 주소를 갖는다.</p>
<p><code>pod-ip-address.my-namespace.pod.cluster-domain.example</code>.</p>
<p>예를 들어, <code>default</code> 네임스페이스의 파드에 IP 주소 172.17.0.3이 있고,
클러스터의 도메인 이름이 <code>cluster.local</code> 이면, 파드는 다음과 같은 DNS 주소를 갖는다.</p>
<p><code>172-17-0-3.default.pod.cluster.local</code>.</p>
<p>서비스에 의해 노출된 모든 파드는 다음과 같은 DNS 주소를 갖는다.</p>
<p><code>pod-ip-address.service-name.my-namespace.svc.cluster-domain.example</code>.</p>
<h3 id=파드의-hostname-및-subdomain-필드>파드의 hostname 및 subdomain 필드</h3>
<p>파드가 생성되면 hostname은 해당 파드의 <code>metadata.name</code> 값이 된다.</p>
<p>파드 스펙(Pod spec)에는 선택적 필드인 <code>hostname</code>이 있다.
이 필드는 파드의 호스트네임을 지정할 수 있다.
<code>hostname</code> 필드가 지정되면, 파드의 이름보다 파드의 호스트네임이 우선시된다.
예를 들어 <code>hostname</code> 필드가 "<code>my-host</code>"로 설정된 파드는 호스트네임이 "<code>my-host</code>"로 설정된다.</p>
<p>또한, 파드 스펙에는 선택적 필드인 <code>subdomain</code>이 있다. 이 필드는 서브도메인을 지정할 수 있다.
예를 들어 "<code>my-namespace</code>" 네임스페이스에서, <code>hostname</code> 필드가 "<code>foo</code>"로 설정되고,
<code>subdomain</code> 필드가 "<code>bar</code>"로 설정된 파드는 전체 주소 도메인 네임(FQDN)을 가지게 된다.
"<code>foo.bar.my-namespace.svc.cluster-domain.example</code>".</p>
<p>예시:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>default-subdomain<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>clusterIP</span>:<span style=color:#bbb> </span>None<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb> </span><span style=color:#080;font-style:italic># 사실 포트는 필요하지 않다.</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>1234</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>1234</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>busybox1<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>hostname</span>:<span style=color:#bbb> </span>busybox-1<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>subdomain</span>:<span style=color:#bbb> </span>default-subdomain<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox:1.28<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- sleep<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:#b44>&#34;3600&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>busybox2<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>hostname</span>:<span style=color:#bbb> </span>busybox-2<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>subdomain</span>:<span style=color:#bbb> </span>default-subdomain<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox:1.28<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- sleep<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:#b44>&#34;3600&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span></code></pre></div><p>파드와 동일한 네임스페이스 내에 같은 서브도메인 이름을 가진 헤드리스 서비스가 있다면,
클러스터의 DNS 서버는 파드의 전체 주소 호스트네임(fully qualified hostname)인 A 또는 AAAA 레코드를 반환한다.
예를 들어 호스트네임이 "<code>busybox-1</code>"이고,
서브도메인이 "<code>default-subdomain</code>"이고,
같은 네임스페이스 내 헤드리스 서비스의 이름이 "<code>default-subdomain</code>"이면,
파드는 다음과 같이 자기 자신의 FQDN을 얻게 된다.
"<code>busybox-1.default-subdomain.my-namespace.svc.cluster-domain.example</code>".
DNS는 위 FQDN에 대해 파드의 IP를 가리키는 A 또는 AAAA 레코드를 제공한다.
"<code>busybox1</code>"와 "<code>busybox2</code>" 파드 모두 각 파드를 구분 가능한 A 또는 AAAA 레코드를 가지고 있다.</p>
<p>엔드포인트 오브젝트는 <code>hostname</code> 필드를
임의의 엔드포인트 IP 주소로 지정할 수 있다.</p>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> A 또는 AAAA 레코드는 파드의 이름으로 생성되지 않기 때문에
파드의 A 또는 AAAA 레코드를 생성하기 위해서는 <code>hostname</code> 필드를 작성해야 한다.
<code>hostname</code> 필드는 없고 <code>subdomain</code> 필드만 있는 파드는 파드의 IP 주소를 가리키는 헤드리스 서비스의
A 또는 AAAA 레코드만 생성할 수 있다. (<code>default-subdomain.my-namespace.svc.cluster-domain.example</code>)
또한 서비스에서 <code>publishNotReadyAddresses=True</code> 를 설정하지 않았다면, 파드가 준비 상태가 되어야 레코드를 가질 수 있다.
</div>
<h3 id=pod-sethostnameasfqdn-field>파드의 setHostnameAsFQDN 필드</h3>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.22 [stable]</code>
</div>
<p>파드가 전체 주소 도메인 이름(FQDN)을 갖도록 구성된 경우, 해당 호스트네임은 짧은 호스트네임이다. 예를 들어, 전체 주소 도메인 이름이 <code>busybox-1.default-subdomain.my-namespace.svc.cluster-domain.example</code> 인 파드가 있는 경우, 기본적으로 해당 파드 내부의 <code>hostname</code> 명령어는 <code>busybox-1</code> 을 반환하고 <code>hostname --fqdn</code> 명령은 FQDN을 반환한다.</p>
<p>파드 명세에서 <code>setHostnameAsFQDN: true</code> 를 설정하면, kubelet은 파드의 FQDN을 해당 파드 네임스페이스의 호스트네임에 기록한다. 이 경우, <code>hostname</code> 과 <code>hostname --fqdn</code> 은 모두 파드의 FQDN을 반환한다.</p>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> <p>리눅스에서, 커널의 호스트네임 필드(<code>struct utsname</code> 의 <code>nodename</code> 필드)는 64자로 제한된다.</p>
<p>파드에서 이 기능을 사용하도록 설정하고 FQDN이 64자보다 길면, 시작되지 않는다. 파드는 파드 호스트네임과 클러스터 도메인에서 FQDN을 구성하지 못한다거나, FQDN <code>long-FDQN</code> 이 너무 길다(최대 64자, 70자 요청인 경우)와 같은 오류 이벤트를 생성하는 <code>Pending</code> 상태(<code>kubectl</code> 에서 표시하는 <code>ContainerCreating</code>)로 유지된다. 이 시나리오에서 사용자 경험을 개선하는 한 가지 방법은 사용자가 최상위 레벨을 오브젝트(예를 들어, 디플로이먼트)를 생성할 때 FQDN 크기를 제어하기 위해 <a href=/docs/reference/access-authn-authz/extensible-admission-controllers/#admission-webhooks>어드미션 웹훅 컨트롤러</a>를 생성하는 것이다.</p>
</div>
<h3 id=파드의-dns-정책>파드의 DNS 정책</h3>
<p>DNS 정책은 파드별로 설정할 수 있다.
현재 쿠버네티스는 다음과 같은 파드별 DNS 정책을 지원한다.
이 정책들은 파드 스펙의 <code>dnsPolicy</code> 필드에서 지정할 수 있다.</p>
<ul>
<li>"<code>Default</code>": 파드는 파드가 실행되고 있는 노드로부터 네임 해석 설정(the name resolution configuration)을 상속받는다.
자세한 내용은
<a href=/ko/docs/tasks/administer-cluster/dns-custom-nameservers>관련 논의</a>에서
확인할 수 있다.</li>
<li>"<code>ClusterFirst</code>": "<code>www.kubernetes.io</code>"와 같이 클러스터 도메인 suffix 구성과
일치하지 않는 DNS 쿼리는 노드에서 상속된 업스트림 네임서버로 전달된다.
클러스터 관리자는 추가 스텁-도메인(stub-domain)과 업스트림 DNS 서버를 구축할 수 있다.
그러한 경우 DNS 쿼리를 어떻게 처리하는지에 대한 자세한 내용은
<a href=/ko/docs/tasks/administer-cluster/dns-custom-nameservers>관련 논의</a>에서
확인할 수 있다.</li>
<li>"<code>ClusterFirstWithHostNet</code>": hostNetwork에서 running 상태인 파드의 경우 DNS 정책인
"<code>ClusterFirstWithHostNet</code>"을 명시적으로 설정해야 한다.</li>
<li>"<code>None</code>": 이 정책은 파드가 쿠버네티스 환경의 DNS 설정을 무시하도록 한다.
모든 DNS 설정은 파드 스펙 내에 <code>dnsConfig</code>필드를 사용하여 제공해야 한다.
아래 절인 <a href=#pod-dns-config>파드의 DNS 설정</a>에서
자세한 내용을 확인할 수 있다.</li>
</ul>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> "Default"는 기본 DNS 정책이 아니다. <code>dnsPolicy</code>가 명시적으로 지정되어 있지 않다면
"ClusterFirst"가 기본값으로 사용된다.
</div>
<p>아래 예시는 <code>hostNetwork</code>필드가 <code>true</code>로 설정되어 있어서
DNS 정책이 "<code>ClusterFirstWithHostNet</code>"으로 설정된 파드를 보여준다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox:1.28<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- sleep<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:#b44>&#34;3600&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>imagePullPolicy</span>:<span style=color:#bbb> </span>IfNotPresent<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Always<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>hostNetwork</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>dnsPolicy</span>:<span style=color:#bbb> </span>ClusterFirstWithHostNet<span style=color:#bbb>
</span></code></pre></div><h3 id=pod-dns-config>파드의 DNS 설정</h3>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.14 [stable]</code>
</div>
<p>사용자들은 파드의 DNS 설정을 통해서 직접 파드의 DNS를 세팅할 수 있다.</p>
<p><code>dnsConfig</code> 필드는 선택적이고, <code>dnsPolicy</code> 세팅과 함께 동작한다.
이때, 파드의 <code>dnsPolicy</code>의 값이 "<code>None</code>"으로 설정되어 있어야
<code>dnsConfig</code> 필드를 지정할 수 있다.</p>
<p>사용자는 <code>dnsConfig</code> 필드에서 다음과 같은 속성들을 지정할 수 있다.</p>
<ul>
<li><code>nameservers</code>: 파드의 DNS 서버가 사용할 IP 주소들의 목록이다.
파드의 <code>dnsPolicy</code>가 "<code>None</code>" 으로 설정된 경우에는
적어도 하나의 IP 주소가 포함되어야 하며,
그렇지 않으면 이 속성은 생략할 수 있다.
<code>nameservers</code>에 나열된 서버는 지정된 DNS 정책을 통해 생성된 기본 네임 서버와 합쳐지며
중복되는 주소는 제거된다.</li>
<li><code>searches</code>: 파드의 호스트네임을 찾기 위한 DNS 검색 도메인의 목록이다.
이 속성은 생략이 가능하며,
값을 지정한 경우 나열된 검색 도메인은 지정된 DNS 정책을 통해 생성된 기본 검색 도메인에 합쳐진다.
병합 시 중복되는 도메인은 제거되며,
쿠버네티스는 최대 6개의 검색 도메인을 허용하고 있다.</li>
<li><code>options</code>: <code>name</code> 속성(필수)과 <code>value</code> 속성(선택)을 가질 수 있는 오브젝트들의 선택적 목록이다.
이 속성의 내용은 지정된 DNS 정책에서 생성된 옵션으로 병합된다.
이 속성의 내용은 지정된 DNS 정책을 통해 생성된 옵션으로 합쳐지며,
병합 시 중복되는 항목은 제거된다.</li>
</ul>
<p>다음은 커스텀 DNS 세팅을 한 파드의 예시이다.</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/ko/examples/service/networking/custom-dns.yaml download=service/networking/custom-dns.yaml><code>service/networking/custom-dns.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('service-networking-custom-dns-yaml')" title="Copy service/networking/custom-dns.yaml to clipboard">
</img>
</div>
<div class=includecode id=service-networking-custom-dns-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>dns-example<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>dnsPolicy</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;None&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>dnsConfig</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>nameservers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:#666>1.2.3.4</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>searches</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- ns1.svc.cluster-domain.example<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- my.dns.search.suffix<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>options</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>ndots<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>edns0<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>위에서 파드가 생성되면,
컨테이너 <code>test</code>의 <code>/etc/resolv.conf</code> 파일에는 다음과 같은 내용이 추가된다.</p>
<pre><code>nameserver 1.2.3.4
search ns1.svc.cluster-domain.example my.dns.search.suffix
options ndots:2 edns0
</code></pre><p>IPv6 셋업을 위해서 검색 경로와 네임 서버 셋업은 다음과 같아야 한다:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#a2f>exec</span> -it dns-example -- cat /etc/resolv.conf
</code></pre></div><p>출력은 다음과 같은 형식일 것이다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>nameserver fd00:79:30::a
search default.svc.cluster-domain.example svc.cluster-domain.example cluster-domain.example
options ndots:5
</code></pre></div><h4 id=확장된-dns-환경-설정>확장된 DNS 환경 설정</h4>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes 1.22 [alpha]</code>
</div>
<p>쿠버네티스는 파드의 DNS 환경 설정을 위해 기본적으로 최대 6개의 탐색 도메인과
최대 256자의 탐색 도메인 목록을 허용한다.</p>
<p>kube-apiserver와 kubelet에 <code>ExpandedDNSConfig</code> 기능 게이트가 활성화되어 있으면,
쿠버네티스는 최대 32개의 탐색 도메인과
최대 2048자의 탐색 도메인 목록을 허용한다.</p>
<h3 id=기능-가용성>기능 가용성</h3>
<p>파드 DNS 환경 설정 기능과 DNS 정책 "<code>None</code>" 기능의 쿠버네티스 버전별 가용성은 다음과 같다.</p>
<table>
<thead>
<tr>
<th style=text-align:center>쿠버네티스 버전</th>
<th style=text-align:center>기능 지원</th>
</tr>
</thead>
<tbody>
<tr>
<td style=text-align:center>1.14</td>
<td style=text-align:center>안정</td>
</tr>
<tr>
<td style=text-align:center>1.10</td>
<td style=text-align:center>베타 (기본값으로 켜져 있음)</td>
</tr>
<tr>
<td style=text-align:center>1.9</td>
<td style=text-align:center>알파</td>
</tr>
</tbody>
</table>
<h2 id=다음-내용>다음 내용</h2>
<p>DNS 구성 관리에 대한 지침은
<a href=/ko/docs/tasks/administer-cluster/dns-custom-nameservers/>DNS 서비스 구성</a>에서 확인할 수 있다.</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-f804ac0532fcade3966ea2e3769ca031>5.4 - 서비스와 애플리케이션 연결하기</h1>
<h2 id=컨테이너-연결을-위한-쿠버네티스-모델>컨테이너 연결을 위한 쿠버네티스 모델</h2>
<p>지속적으로 실행중이고, 복제된 애플리케이션을 가지고 있다면 네트워크에 노출할 수 있다.</p>
<p>쿠버네티스는 파드가 배치된 호스트와는 무관하게 다른 파드와 통신할 수 있다고 가정한다. 쿠버네티스는 모든 파드에게 자체 클러스터-프라이빗 IP 주소를 제공하기 때문에 파드간에 명시적으로 링크를 만들거나 컨테이너 포트를 호스트 포트에 매핑할 필요가 없다. 이것은 파드 내의 컨테이너는 모두 로컬호스트(localhost)에서 서로의 포트에 도달할 수 있으며 클러스터의 모든 파드는 NAT 없이 서로를 볼 수 있다는 의미이다. 이 문서의 나머지 부분에서는 이러한 네트워킹 모델에서 신뢰할 수 있는 서비스를 실행하는 방법에 대해 자세히 설명할 것이다.</p>
<p>이 가이드는 간단한 nginx 서버를 사용해서 개념증명을 보여준다.</p>
<h2 id=파드를-클러스터에-노출하기>파드를 클러스터에 노출하기</h2>
<p>이 작업은 이전 예시에서 수행해 보았지만, 네트워킹 관점을 중점에 두고 다시 한번 수행해 보자.
nginx 파드를 생성하고, 해당 파드에 컨테이너 포트 사양이 있는 것을 참고한다.</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/ko/examples/service/networking/run-my-nginx.yaml download=service/networking/run-my-nginx.yaml><code>service/networking/run-my-nginx.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('service-networking-run-my-nginx-yaml')" title="Copy service/networking/run-my-nginx.yaml to clipboard">
</img>
</div>
<div class=includecode id=service-networking-run-my-nginx-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-nginx<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>run</span>:<span style=color:#bbb> </span>my-nginx<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>2</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>run</span>:<span style=color:#bbb> </span>my-nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-nginx<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>이렇게 하면 클러스터의 모든 노드에서 접근할 수 있다. 파드를 실행 중인 노드를 확인한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f ./run-my-nginx.yaml
kubectl get pods -l <span style=color:#b8860b>run</span><span style=color:#666>=</span>my-nginx -o wide
</code></pre></div><pre><code>NAME                        READY     STATUS    RESTARTS   AGE       IP            NODE
my-nginx-3800858182-jr4a2   1/1       Running   0          13s       10.244.3.4    kubernetes-minion-905m
my-nginx-3800858182-kna2y   1/1       Running   0          13s       10.244.2.5    kubernetes-minion-ljyd
</code></pre><p>파드의 IP를 확인한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods -l <span style=color:#b8860b>run</span><span style=color:#666>=</span>my-nginx -o yaml | grep podIP
    podIP: 10.244.3.4
    podIP: 10.244.2.5
</code></pre></div><p>이제 클러스터의 모든 노드로 ssh 접속하거나 <code>curl</code>과 같은 도구를 사용하여 두 IP 주소에 질의를 전송할 수 있을 것이다. 컨테이너는 노드의 포트 80을 사용하지 <em>않으며</em> , 트래픽을 파드로 라우팅하는 특별한 NAT 규칙도 없다는 것을 참고한다. 이것은 동일한 <code>containerPort</code>를 사용하여 동일한 노드에서 여러 nginx 파드를 실행하는 것이 가능하고, 또한 서비스에 할당된 IP 주소를 사용하여 클러스터의 다른 파드나 노드에서 접근할 수 있다는 의미이다. 호스트 노드의 특정 포트를 배후(backing) 파드로 포워드하고 싶다면, 가능은 하지만 네트워킹 모델을 사용하면 그렇게 할 필요가 없어야 한다.</p>
<p>만약 궁금하다면 <a href=/ko/docs/concepts/cluster-administration/networking/#%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EB%AA%A8%EB%8D%B8>쿠버네티스 네트워킹 모델</a>을 자세히 읽어본다.</p>
<h2 id=서비스-생성하기>서비스 생성하기</h2>
<p>평평하고 넓은 클러스터 전체의 주소 공간에서 nginx를 실행하는 파드가 있다고 가정하자. 이론적으로는 이러한 파드와 직접 대화할 수 있지만, 노드가 죽으면 어떻게 되는가? 파드가 함께 죽으면 디플로이먼트에서 다른 IP를 가진 새로운 파드를 생성한다. 이 문제를 서비스가 해결한다.</p>
<p>쿠버네티스 서비스는 클러스터 어딘가에서 실행되는 논리적인 파드 집합을 정의하고 추상화함으로써 모두 동일한 기능을 제공한다. 생성시 각 서비스에는 고유한 IP 주소(clusterIP라고도 한다)가 할당된다. 이 주소는 서비스의 수명과 연관되어 있으며, 서비스가 활성화 되어 있는 동안에는 변경되지 않는다. 파드는 서비스와 통신하도록 구성할 수 있으며, 서비스와의 통신은 서비스의 맴버 중 일부 파드에 자동적으로 로드-밸런싱 된다.</p>
<p><code>kubectl expose</code> 를 사용해서 2개의 nginx 레플리카에 대한 서비스를 생성할 수 있다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl expose deployment/my-nginx
</code></pre></div><pre><code>service/my-nginx exposed
</code></pre><p>이것은 다음 yaml 파일을 <code>kubectl apply -f</code> 로 실행한 것과 동일하다.</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/ko/examples/service/networking/nginx-svc.yaml download=service/networking/nginx-svc.yaml><code>service/networking/nginx-svc.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('service-networking-nginx-svc-yaml')" title="Copy service/networking/nginx-svc.yaml to clipboard">
</img>
</div>
<div class=includecode id=service-networking-nginx-svc-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-nginx<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>run</span>:<span style=color:#bbb> </span>my-nginx<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>run</span>:<span style=color:#bbb> </span>my-nginx<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>이 사양은 <code>run: my-nginx</code> 레이블이 부착된 모든 파드에 TCP 포트 80을
대상으로 하는 서비스를 만들고 추상화된 서비스 포트에 노출시킨다
(<code>targetPort</code> 는 컨테이너가 트래픽을 수신하는 포트, <code>port</code> 는
추상화된 서비스 포트로 다른 파드들이 서비스에 접속하기위해 사용하는
모든 포트일 수 있다).
<a href=/docs/reference/generated/kubernetes-api/v1.23/#service-v1-core>서비스</a>의
API 오브젝트를 보고 서비스 정의에서 지원되는 필드 목록을 확인한다.
서비스를 확인한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get svc my-nginx
</code></pre></div><pre><code>NAME       TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)   AGE
my-nginx   ClusterIP   10.0.162.149   &lt;none&gt;        80/TCP    21s
</code></pre><p>앞에서 언급한 바와 같이, 서비스는 파드 그룹에 의해 지원된다. 이 파드들은
<code>endpoints</code> 를 통해 노출된다. 서비스 셀렉터는 지속적으로 평가되고
결과는 <code>my-nginx</code> 이름의 엔드포인트 오브젝트에 POST된다.
파드가 죽으면 자동적으로 엔드포인트에서 제거되며 서비스 셀렉터와
일치하는 새 파드는 자동적으로 엔드포인트에 추가된다.
엔드포인트를 확인하고 IP가 첫 번째 단계에서 생성된 파드와 동일하다는
점을 참고한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe svc my-nginx
</code></pre></div><pre><code>Name:                my-nginx
Namespace:           default
Labels:              run=my-nginx
Annotations:         &lt;none&gt;
Selector:            run=my-nginx
Type:                ClusterIP
IP:                  10.0.162.149
Port:                &lt;unset&gt; 80/TCP
Endpoints:           10.244.2.5:80,10.244.3.4:80
Session Affinity:    None
Events:              &lt;none&gt;
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get ep my-nginx
</code></pre></div><pre><code>NAME       ENDPOINTS                     AGE
my-nginx   10.244.2.5:80,10.244.3.4:80   1m
</code></pre><p>이제 클러스터의 모든 노드에서 <code>&lt;CLUSTER-IP>:&lt;PORT></code> 로 nginx 서비스를
curl을 할 수 있을 것이다. 서비스 IP는 완전히 가상이므로 외부에서는 절대로 연결되지
않음에 참고한다. 만약 이것이 어떻게 작동하는지 궁금하다면
<a href=/ko/docs/concepts/services-networking/service/#%EA%B0%80%EC%83%81-ip%EC%99%80-%EC%84%9C%EB%B9%84%EC%8A%A4-%ED%94%84%EB%A1%9D%EC%8B%9C>서비스 프록시</a>에 대해 더 읽어본다.</p>
<h2 id=서비스에-접근하기>서비스에 접근하기</h2>
<p>쿠버네티스는 서비스를 찾는 두 가지 기본 모드인 환경 변수와 DNS를
지원한다. 전자는 기본적으로 작동하지만 후자는
<a href=https://releases.k8s.io/v1.23.17/cluster/addons/dns/coredns>CoreDNS 클러스터 애드온</a>이 필요하다.
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> 만약 서비스 환경 변수가 필요하지 않은 경우(소유한 프로그램과의 예상되는 충돌 가능성,
처리할 변수가 너무 많은 경우, DNS만 사용하는 경우 등) <a href=/docs/reference/generated/kubernetes-api/v1.23/#pod-v1-core>파드 사양</a>에서
<code>enableServiceLinks</code> 플래그를 <code>false</code> 로 설정하면 이 모드를 비활성화할 수 있다.
</div></p>
<h3 id=환경-변수들>환경 변수들</h3>
<p>파드가 노드에서 실행될 때 kubelet은 각기 활성화된 서비스에 대해 일련의 환경
변수 집합을 추가한다. 이것은 순서 문제를 야기한다. 이유를 확인하려면
실행 중인 nginx 파드 환경을 점검해야 한다(실제 사용자의 파드 이름은 다를 것이다).</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#a2f>exec</span> my-nginx-3800858182-jr4a2 -- printenv | grep SERVICE
</code></pre></div><pre><code>KUBERNETES_SERVICE_HOST=10.0.0.1
KUBERNETES_SERVICE_PORT=443
KUBERNETES_SERVICE_PORT_HTTPS=443
</code></pre><p>서비스에 대한 언급이 없다는 것에 참고해야 한다. 이것은 서비스 이전에 레플리카를
생성했기 때문이다. 이 작업을 수행할 때 또 다른 단점은 스케줄러가 두 파드를
모두 동일한 머신에 배치할 수도 있다는 것이며, 이로 인해 전체 서비스가 중단될 수
있다. 두개의 파드를 죽이고 디플로이먼트가 파드를 재생성하기를 기다리는 것으로
이를 정상화 할 수 있다. 이번에는 서비스가 레플리카들 <em>전</em> 에
존재한다. 이렇게 하면 올바른 환경 변수뿐만 아니라 파드의 스케줄러-수준의
서비스 분배(모든 노드에 동일한 용량이 제공되는 경우)가
된다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl scale deployment my-nginx --replicas<span style=color:#666>=</span>0; kubectl scale deployment my-nginx --replicas<span style=color:#666>=</span>2;

kubectl get pods -l <span style=color:#b8860b>run</span><span style=color:#666>=</span>my-nginx -o wide
</code></pre></div><pre><code>NAME                        READY     STATUS    RESTARTS   AGE     IP            NODE
my-nginx-3800858182-e9ihh   1/1       Running   0          5s      10.244.2.7    kubernetes-minion-ljyd
my-nginx-3800858182-j4rm4   1/1       Running   0          5s      10.244.3.8    kubernetes-minion-905m
</code></pre><p>파드가 죽고 재생성되었기 때문에 다른 이름을 가지는 것을 알 수 있다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#a2f>exec</span> my-nginx-3800858182-e9ihh -- printenv | grep SERVICE
</code></pre></div><pre><code>KUBERNETES_SERVICE_PORT=443
MY_NGINX_SERVICE_HOST=10.0.162.149
KUBERNETES_SERVICE_HOST=10.0.0.1
MY_NGINX_SERVICE_PORT=80
KUBERNETES_SERVICE_PORT_HTTPS=443
</code></pre><h3 id=dns>DNS</h3>
<p>쿠버네티스는 DNS 클러스터 애드온 서비스를 제공하며 dns 이름을 다른 서비스에 자동으로 할당한다. 다음 명령어로 이것이 클러스터에서 실행 중인지 확인할 수 있다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get services kube-dns --namespace<span style=color:#666>=</span>kube-system
</code></pre></div><pre><code>NAME       TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)         AGE
kube-dns   ClusterIP   10.0.0.10    &lt;none&gt;        53/UDP,53/TCP   8m
</code></pre><p>이 섹션의 나머지 부분에서는 수명이 긴 IP의 서비스(my-nginx)와 이 IP
에 이름을 할당한 DNS 서버가 있다고 가정한다. 여기서는 CoreDNS 클러스터 애드온(애플리케이션 이름 <code>kube-dns</code>)을 사용하므로, 표준 방법(예: <code>gethostbyname()</code>)을 사용해서 클러스터의 모든 파드에서 서비스와 통신할 수 있다. 만약 CoreDNS가 실행 중이 아니라면 <a href=https://github.com/coredns/deployment/tree/master/kubernetes>CoreDNS README</a> 또는 <a href=/ko/docs/tasks/administer-cluster/coredns/#coredns-%EC%84%A4%EC%B9%98>CoreDNS 설치</a>를 참조해서 활성화 할 수 있다. 이것을 테스트하기 위해 다른 curl 애플리케이션을 실행한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl run curl --image<span style=color:#666>=</span>radial/busyboxplus:curl -i --tty
</code></pre></div><pre><code>Waiting for pod default/curl-131556218-9fnch to be running, status is Pending, pod ready: false
Hit enter for command prompt
</code></pre><p>이제, <code>nslookup my-nginx</code> 를 입력하고 실행한다:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#666>[</span> root@curl-131556218-9fnch:/ <span style=color:#666>]</span>$ nslookup my-nginx
Server:    10.0.0.10
Address 1: 10.0.0.10

Name:      my-nginx
Address 1: 10.0.162.149
</code></pre></div><h2 id=서비스-보안>서비스 보안</h2>
<p>지금까지는 클러스터 내부에서만 ngnix 서버에 엑세스 해왔다. 서비스를 인터넷에 공개하기 전에 통신 채널이 안전한지 확인해야 한다. 이를 위해선 다음이 필요하다.</p>
<ul>
<li>https에 대한 자체 서명한 인증서 (신원 인증서를 가지고 있지 않은 경우)</li>
<li>인증서를 사용하도록 구성된 nginx 서버</li>
<li>파드에 접근할 수 있는 인증서를 만드는 <a href=/ko/docs/concepts/configuration/secret/>시크릿</a></li>
</ul>
<p><a href=https://github.com/kubernetes/examples/tree/master/staging/https-nginx/>nginx https 예제</a>에서 이 모든 것을 얻을 수 있다. 이를 위해서는 도구를 설치해야 한다. 만약 설치하지 않으려면 나중에 수동으로 단계를 수행한다. 한마디로:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>make keys <span style=color:#b8860b>KEY</span><span style=color:#666>=</span>/tmp/nginx.key <span style=color:#b8860b>CERT</span><span style=color:#666>=</span>/tmp/nginx.crt
kubectl create secret tls nginxsecret --key /tmp/nginx.key --cert /tmp/nginx.crt
</code></pre></div><pre><code>secret/nginxsecret created
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get secrets
</code></pre></div><pre><code>NAME                  TYPE                                  DATA      AGE
default-token-il9rc   kubernetes.io/service-account-token   1         1d
nginxsecret           kubernetes.io/tls                     2         1m
</code></pre><p>그리고 또한 컨피그맵:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create configmap nginxconfigmap --from-file<span style=color:#666>=</span>default.conf
</code></pre></div><pre><code>configmap/nginxconfigmap created
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get configmaps
</code></pre></div><pre><code>NAME             DATA   AGE
nginxconfigmap   1      114s
</code></pre><p>다음은 make를 실행하는데 문제가 있는 경우에 수행해야 하는 수동 단계이다(예시로 windows).</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># Create a public private key pair</span>
openssl req -x509 -nodes -days <span style=color:#666>365</span> -newkey rsa:2048 -keyout /d/tmp/nginx.key -out /d/tmp/nginx.crt -subj <span style=color:#b44>&#34;/CN=my-nginx/O=my-nginx&#34;</span>
<span style=color:#080;font-style:italic># Convert the keys to base64 encoding</span>
cat /d/tmp/nginx.crt | base64
cat /d/tmp/nginx.key | base64
</code></pre></div><p>이전 명령의 출력을 사용해서 다음과 같이 yaml 파일을 생성한다. base64로 인코딩된 값은 모두 한 줄에 있어야 한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;v1&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;Secret&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;nginxsecret&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;default&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>kubernetes.io/tls<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>tls.crt</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSURIekNDQWdlZ0F3SUJBZ0lKQUp5M3lQK0pzMlpJTUEwR0NTcUdTSWIzRFFFQkJRVUFNQ1l4RVRBUEJnTlYKQkFNVENHNW5hVzU0YzNaak1SRXdEd1lEVlFRS0V3aHVaMmx1ZUhOMll6QWVGdzB4TnpFd01qWXdOekEzTVRKYQpGdzB4T0RFd01qWXdOekEzTVRKYU1DWXhFVEFQQmdOVkJBTVRDRzVuYVc1NGMzWmpNUkV3RHdZRFZRUUtFd2h1CloybHVlSE4yWXpDQ0FTSXdEUVlKS29aSWh2Y05BUUVCQlFBRGdnRVBBRENDQVFvQ2dnRUJBSjFxSU1SOVdWM0IKMlZIQlRMRmtobDRONXljMEJxYUhIQktMSnJMcy8vdzZhU3hRS29GbHlJSU94NGUrMlN5ajBFcndCLzlYTnBwbQppeW1CL3JkRldkOXg5UWhBQUxCZkVaTmNiV3NsTVFVcnhBZW50VWt1dk1vLzgvMHRpbGhjc3paenJEYVJ4NEo5Ci82UVRtVVI3a0ZTWUpOWTVQZkR3cGc3dlVvaDZmZ1Voam92VG42eHNVR0M2QURVODBpNXFlZWhNeVI1N2lmU2YKNHZpaXdIY3hnL3lZR1JBRS9mRTRqakxCdmdONjc2SU90S01rZXV3R0ljNDFhd05tNnNTSzRqYUNGeGpYSnZaZQp2by9kTlEybHhHWCtKT2l3SEhXbXNhdGp4WTRaNVk3R1ZoK0QrWnYvcW1mMFgvbVY0Rmo1NzV3ajFMWVBocWtsCmdhSXZYRyt4U1FVQ0F3RUFBYU5RTUU0d0hRWURWUjBPQkJZRUZPNG9OWkI3YXc1OUlsYkROMzhIYkduYnhFVjcKTUI4R0ExVWRJd1FZTUJhQUZPNG9OWkI3YXc1OUlsYkROMzhIYkduYnhFVjdNQXdHQTFVZEV3UUZNQU1CQWY4dwpEUVlKS29aSWh2Y05BUUVGQlFBRGdnRUJBRVhTMW9FU0lFaXdyMDhWcVA0K2NwTHI3TW5FMTducDBvMm14alFvCjRGb0RvRjdRZnZqeE04Tzd2TjB0clcxb2pGSW0vWDE4ZnZaL3k4ZzVaWG40Vm8zc3hKVmRBcStNZC9jTStzUGEKNmJjTkNUekZqeFpUV0UrKzE5NS9zb2dmOUZ3VDVDK3U2Q3B5N0M3MTZvUXRUakViV05VdEt4cXI0Nk1OZWNCMApwRFhWZmdWQTRadkR4NFo3S2RiZDY5eXM3OVFHYmg5ZW1PZ05NZFlsSUswSGt0ejF5WU4vbVpmK3FqTkJqbWZjCkNnMnlwbGQ0Wi8rUUNQZjl3SkoybFIrY2FnT0R4elBWcGxNSEcybzgvTHFDdnh6elZPUDUxeXdLZEtxaUMwSVEKQ0I5T2wwWW5scE9UNEh1b2hSUzBPOStlMm9KdFZsNUIyczRpbDlhZ3RTVXFxUlU9Ci0tLS0tRU5EIENFUlRJRklDQVRFLS0tLS0K&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>tls.key</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;LS0tLS1CRUdJTiBQUklWQVRFIEtFWS0tLS0tCk1JSUV2UUlCQURBTkJna3Foa2lHOXcwQkFRRUZBQVNDQktjd2dnU2pBZ0VBQW9JQkFRQ2RhaURFZlZsZHdkbFIKd1V5eFpJWmVEZWNuTkFhbWh4d1NpeWF5N1AvOE9ta3NVQ3FCWmNpQ0RzZUh2dGtzbzlCSzhBZi9WemFhWm9zcApnZjYzUlZuZmNmVUlRQUN3WHhHVFhHMXJKVEVGSzhRSHA3VkpMcnpLUC9QOUxZcFlYTE0yYzZ3MmtjZUNmZitrCkU1bEVlNUJVbUNUV09UM3c4S1lPNzFLSWVuNEZJWTZMMDUrc2JGQmd1Z0ExUE5JdWFubm9UTWtlZTRuMG4rTDQKb3NCM01ZUDhtQmtRQlAzeE9JNHl3YjREZXUraURyU2pKSHJzQmlIT05Xc0RadXJFaXVJMmdoY1kxeWIyWHI2UAozVFVOcGNSbC9pVG9zQngxcHJHclk4V09HZVdPeGxZZmcvbWIvNnBuOUYvNWxlQlkrZStjSTlTMkQ0YXBKWUdpCkwxeHZzVWtGQWdNQkFBRUNnZ0VBZFhCK0xkbk8ySElOTGo5bWRsb25IUGlHWWVzZ294RGQwci9hQ1Zkank4dlEKTjIwL3FQWkUxek1yall6Ry9kVGhTMmMwc0QxaTBXSjdwR1lGb0xtdXlWTjltY0FXUTM5SjM0VHZaU2FFSWZWNgo5TE1jUHhNTmFsNjRLMFRVbUFQZytGam9QSFlhUUxLOERLOUtnNXNrSE5pOWNzMlY5ckd6VWlVZWtBL0RBUlBTClI3L2ZjUFBacDRuRWVBZmI3WTk1R1llb1p5V21SU3VKdlNyblBESGtUdW1vVlVWdkxMRHRzaG9reUxiTWVtN3oKMmJzVmpwSW1GTHJqbGtmQXlpNHg0WjJrV3YyMFRrdWtsZU1jaVlMbjk4QWxiRi9DSmRLM3QraTRoMTVlR2ZQegpoTnh3bk9QdlVTaDR2Q0o3c2Q5TmtEUGJvS2JneVVHOXBYamZhRGR2UVFLQmdRRFFLM01nUkhkQ1pKNVFqZWFKClFGdXF4cHdnNzhZTjQyL1NwenlUYmtGcVFoQWtyczJxWGx1MDZBRzhrZzIzQkswaHkzaE9zSGgxcXRVK3NHZVAKOWRERHBsUWV0ODZsY2FlR3hoc0V0L1R6cEdtNGFKSm5oNzVVaTVGZk9QTDhPTm1FZ3MxMVRhUldhNzZxelRyMgphRlpjQ2pWV1g0YnRSTHVwSkgrMjZnY0FhUUtCZ1FEQmxVSUUzTnNVOFBBZEYvL25sQVB5VWs1T3lDdWc3dmVyClUycXlrdXFzYnBkSi9hODViT1JhM05IVmpVM25uRGpHVHBWaE9JeXg5TEFrc2RwZEFjVmxvcG9HODhXYk9lMTAKMUdqbnkySmdDK3JVWUZiRGtpUGx1K09IYnRnOXFYcGJMSHBzUVpsMGhucDBYSFNYVm9CMUliQndnMGEyOFVadApCbFBtWmc2d1BRS0JnRHVIUVV2SDZHYTNDVUsxNFdmOFhIcFFnMU16M2VvWTBPQm5iSDRvZUZKZmcraEppSXlnCm9RN3hqWldVR3BIc3AyblRtcHErQWlSNzdyRVhsdlhtOElVU2FsbkNiRGlKY01Pc29RdFBZNS9NczJMRm5LQTQKaENmL0pWb2FtZm1nZEN0ZGtFMXNINE9MR2lJVHdEbTRpb0dWZGIwMllnbzFyb2htNUpLMUI3MkpBb0dBUW01UQpHNDhXOTVhL0w1eSt5dCsyZ3YvUHM2VnBvMjZlTzRNQ3lJazJVem9ZWE9IYnNkODJkaC8xT2sybGdHZlI2K3VuCnc1YytZUXRSTHlhQmd3MUtpbGhFZDBKTWU3cGpUSVpnQWJ0LzVPbnlDak9OVXN2aDJjS2lrQ1Z2dTZsZlBjNkQKckliT2ZIaHhxV0RZK2Q1TGN1YSt2NzJ0RkxhenJsSlBsRzlOZHhrQ2dZRUF5elIzT3UyMDNRVVV6bUlCRkwzZAp4Wm5XZ0JLSEo3TnNxcGFWb2RjL0d5aGVycjFDZzE2MmJaSjJDV2RsZkI0VEdtUjZZdmxTZEFOOFRwUWhFbUtKCnFBLzVzdHdxNWd0WGVLOVJmMWxXK29xNThRNTBxMmk1NVdUTThoSDZhTjlaMTltZ0FGdE5VdGNqQUx2dFYxdEYKWSs4WFJkSHJaRnBIWll2NWkwVW1VbGc9Ci0tLS0tRU5EIFBSSVZBVEUgS0VZLS0tLS0K&#34;</span><span style=color:#bbb>
</span></code></pre></div><p>이제 파일을 사용해서 시크릿을 생성한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f nginxsecrets.yaml
kubectl get secrets
</code></pre></div><pre><code>NAME                  TYPE                                  DATA      AGE
default-token-il9rc   kubernetes.io/service-account-token   1         1d
nginxsecret           kubernetes.io/tls                     2         1m
</code></pre><p>이제 nginx 레플리카를 수정하여 암호화된 인증서를 사용한 https 서버와 서비스를 실행하고, 두 포트(80과 443)를 노출한다.</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/ko/examples/service/networking/nginx-secure-app.yaml download=service/networking/nginx-secure-app.yaml><code>service/networking/nginx-secure-app.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('service-networking-nginx-secure-app-yaml')" title="Copy service/networking/nginx-secure-app.yaml to clipboard">
</img>
</div>
<div class=includecode id=service-networking-nginx-secure-app-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-nginx<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>run</span>:<span style=color:#bbb> </span>my-nginx<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>NodePort<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>8080</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>http<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>443</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>https<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>run</span>:<span style=color:#bbb> </span>my-nginx<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-nginx<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>run</span>:<span style=color:#bbb> </span>my-nginx<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>run</span>:<span style=color:#bbb> </span>my-nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-volume<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>secret</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>secretName</span>:<span style=color:#bbb> </span>nginxsecret<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>configmap-volume<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>configMap</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginxconfigmap<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginxhttps<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>bprashanth/nginxhttps:1.0<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>443</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/etc/nginx/ssl<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-volume<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/etc/nginx/conf.d<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>configmap-volume<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>nginx-secure-app의 매니페스트에 대한 주목할만한 점:</p>
<ul>
<li>이것은 동일한 파일에 디플로이먼트와 서비스의 사양을 모두 포함하고 있다.</li>
<li><a href=https://github.com/kubernetes/examples/tree/master/staging/https-nginx/default.conf>nginx 서버</a>
는 포트 80에서 HTTP 트래픽을 443에서 HTTPS 트래픽 서비스를 제공하고, nginx 서비스는
두 포트를 모두 노출한다.</li>
<li>각 컨테이너는 <code>/etc/nginx/ssl</code> 에 마운트된 볼륨을 통해 키에 접근할 수 있다.
이것은 nginx 서버가 시작되기 <em>전에</em> 설정된 것이다.</li>
</ul>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete deployments,svc my-nginx; kubectl create -f ./nginx-secure-app.yaml
</code></pre></div><p>이 시점에서 모든 노드에서 nginx 서버에 연결할 수 있다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods -o yaml | grep -i podip
    podIP: 10.244.3.5
node $ curl -k https://10.244.3.5
...
&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;
</code></pre></div><p>마지막 단계에서 curl에 <code>-k</code> 파라미터를 제공한 방법에 참고한다. 이는 인증서 생성시 nginx를 실행하는 파드에 대해 아무것도 모르기 때문에
curl에 CName 불일치를 무시하도록 지시해야하기 때문이다. 서비스를 생성해서 인증서에 사용된 CName을 서비스 조회시 파드에서 사용된 실제 DNS 이름과 연결했다.
파드에서 이것을 테스트 해보자(단순히 동일한 시크릿이 재사용되고 있으며, 파드는 서비스에 접근하기위해 nginx.crt만 필요하다).</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/ko/examples/service/networking/curlpod.yaml download=service/networking/curlpod.yaml><code>service/networking/curlpod.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('service-networking-curlpod-yaml')" title="Copy service/networking/curlpod.yaml to clipboard">
</img>
</div>
<div class=includecode id=service-networking-curlpod-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>curl-deployment<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>curlpod<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>curlpod<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-volume<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>secret</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>secretName</span>:<span style=color:#bbb> </span>nginxsecret<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>curlpod<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- sh<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- -c<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- while true; do sleep 1; done<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>radial/busyboxplus:curl<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/etc/nginx/ssl<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-volume<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f ./curlpod.yaml
kubectl get pods -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>curlpod
</code></pre></div><pre><code>NAME                               READY     STATUS    RESTARTS   AGE
curl-deployment-1515033274-1410r   1/1       Running   0          1m
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#a2f>exec</span> curl-deployment-1515033274-1410r -- curl https://my-nginx --cacert /etc/nginx/ssl/tls.crt
...
&lt;title&gt;Welcome to nginx!&lt;/title&gt;
...
</code></pre></div><h2 id=서비스-노출하기>서비스 노출하기</h2>
<p>애플리케이션의 일부인 경우 원한다면 외부 IP 주소에 서비스를
노출할 수 있다. 쿠버네티스는 이를 수행하는 2가지 방법인 NodePorts와
LoadBalancers를지원한다. 마지막 섹션에서 생성된 서비스는 이미 <code>NodePort</code> 를 사용했기에
노드에 공용 IP가 있는경우 nginx HTTPS 레플리카가 인터넷 트래픽을 처리할
준비가 되어 있다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get svc my-nginx -o yaml | grep nodePort -C <span style=color:#666>5</span>
  uid: 07191fb3-f61a-11e5-8ae5-42010af00002
spec:
  clusterIP: 10.0.162.149
  ports:
  - name: http
    nodePort: <span style=color:#666>31704</span>
    port: <span style=color:#666>8080</span>
    protocol: TCP
    targetPort: <span style=color:#666>80</span>
  - name: https
    nodePort: <span style=color:#666>32453</span>
    port: <span style=color:#666>443</span>
    protocol: TCP
    targetPort: <span style=color:#666>443</span>
  selector:
    run: my-nginx
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get nodes -o yaml | grep ExternalIP -C <span style=color:#666>1</span>
    - address: 104.197.41.11
      type: ExternalIP
    allocatable:
--
    - address: 23.251.152.56
      type: ExternalIP
    allocatable:
...

$ curl https://&lt;EXTERNAL-IP&gt;:&lt;NODE-PORT&gt; -k
...
&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;
</code></pre></div><p>이제 클라우드 로드 밸런서를 사용하도록 서비스를 재생성한다. <code>my-nginx</code> 서비스의 <code>Type</code> 을 <code>NodePort</code> 에서 <code>LoadBalancer</code> 로 변경한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl edit svc my-nginx
kubectl get svc my-nginx
</code></pre></div><pre><code>NAME       TYPE           CLUSTER-IP     EXTERNAL-IP        PORT(S)               AGE
my-nginx   LoadBalancer   10.0.162.149   xx.xxx.xxx.xxx     8080:30163/TCP        21s
</code></pre><pre><code>curl https://&lt;EXTERNAL-IP&gt; -k
...
&lt;title&gt;Welcome to nginx!&lt;/title&gt;
</code></pre><p><code>EXTERNAL-IP</code> 의 IP 주소는 공용 인터넷에서 이용할 수 있는 주소이다. <code>CLUSTER-IP</code> 는
클러스터/프라이빗 클라우드 네트워크 내에서만 사용할 수 있다.</p>
<p>AWS에서는 <code>LoadBalancer</code> 유형은 IP가 아닌 (긴)호스트네임을 사용하는 ELB를
생성한다는 점을 참고한다. 이것은 일반적인 <code>kubectl get svc</code> 의 출력에
맞추기에는 매우 길기 때문에 실제로 이를 보려면 <code>kubectl describe service my-nginx</code> 를
수행해야 한다. 다음과 같은 것을 보게 된다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe service my-nginx
...
LoadBalancer Ingress:   a320587ffd19711e5a37606cf4a74574-1142138393.us-east-1.elb.amazonaws.com
...
</code></pre></div><h2 id=다음-내용>다음 내용</h2>
<ul>
<li><a href=/ko/docs/tasks/access-application-cluster/service-access-application-cluster/>서비스를 사용해서 클러스터 내 애플리케이션에 접근하기</a>를 더 자세히 알아본다.</li>
<li><a href=/ko/docs/tasks/access-application-cluster/connecting-frontend-backend/>서비스를 사용해서 프론트 엔드부터 백 엔드까지 연결하기</a>를 더 자세히 알아본다.</li>
<li><a href=/docs/tasks/access-application-cluster/create-external-load-balancer/>외부 로드 밸런서를 생성하기</a>를 더 자세히 알아본다.</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-5a8edeb1f2dc8e38cd6d561bb08b0d78>5.5 - 인그레스 컨트롤러</h1>
<p>인그레스 리소스가 작동하려면, 클러스터는 실행 중인 인그레스 컨트롤러가 반드시 필요하다.</p>
<p><code>kube-controller-manager</code> 바이너리의 일부로 실행되는 컨트롤러의 다른 타입과 달리 인그레스 컨트롤러는
클러스터와 함께 자동으로 실행되지 않는다.
클러스터에 가장 적합한 인그레스 컨트롤러 구현을 선택하는데 이 페이지를 사용한다.</p>
<p>프로젝트로서 쿠버네티스는 <a href=https://github.com/kubernetes-sigs/aws-load-balancer-controller#readme>AWS</a>, <a href=https://git.k8s.io/ingress-gce/README.md#readme>GCE</a>와
<a href=https://git.k8s.io/ingress-nginx/README.md#readme>nginx</a> 인그레스 컨트롤러를 지원하고 유지한다.</p>
<h2 id=추가-컨트롤러>추가 컨트롤러</h2>
<div class="alert alert-secondary callout third-party-content" role=alert><strong>참고:</strong>
이 섹션은 쿠버네티스에 필요한 기능을 제공하는 써드파티 프로젝트와 관련이 있다. 쿠버네티스 프로젝트 작성자는 써드파티 프로젝트에 책임이 없다. 이 페이지는 <a href=https://github.com/cncf/foundation/blob/master/website-guidelines.md target=_blank>CNCF 웹사이트 가이드라인</a>에 따라 프로젝트를 알파벳 순으로 나열한다. 이 목록에 프로젝트를 추가하려면 변경사항을 제출하기 전에 <a href=/contribute/style/content-guide/#third-party-content>콘텐츠 가이드</a>를 읽어본다.</div>
<ul>
<li><a href=https://azure.github.io/application-gateway-kubernetes-ingress/>AKS 애플리케이션 게이트웨이 인그레스 컨트롤러</a>는 <a href=https://docs.microsoft.com>Azure 애플리케이션 게이트웨이</a>를 구성하는 인그레스 컨트롤러다.</li>
<li><a href=https://www.getambassador.io/>Ambassador</a> API 게이트웨이는 <a href=https://www.envoyproxy.io>Envoy</a> 기반 인그레스
컨트롤러다.</li>
<li><a href=https://github.com/apache/apisix-ingress-controller>Apache APISIX 인그레스 컨트롤러</a>는 <a href=https://github.com/apache/apisix>Apache APISIX</a> 기반의 인그레스 컨트롤러이다.</li>
<li><a href=https://github.com/vmware/load-balancer-and-ingress-services-for-kubernetes>Avi 쿠버네티스 오퍼레이터</a>는 <a href=https://avinetworks.com/>VMware NSX Advanced Load Balancer</a>을 사용하는 L4-L7 로드 밸런싱을 제공한다.</li>
<li><a href=https://github.com/bfenetworks/ingress-bfe>BFE Ingress Controller</a>는 <a href=https://www.bfe-networks.net>BFE</a> 기반 인그레스 컨트롤러다.</li>
<li><a href=https://github.com/citrix/citrix-k8s-ingress-controller#readme>Citrix 인그레스 컨트롤러</a>는
Citrix 애플리케이션 딜리버리 컨트롤러에서 작동한다.</li>
<li><a href=https://projectcontour.io/>Contour</a>는 <a href=https://www.envoyproxy.io/>Envoy</a> 기반 인그레스 컨트롤러다.</li>
<li><a href=https://getenroute.io/>EnRoute</a>는 인그레스 컨트롤러로 실행할 수 있는 <a href=https://www.envoyproxy.io>Envoy</a> 기반 API 게이트웨이다.</li>
<li><a href=https://github.com/megaease/easegress/blob/main/doc/reference/ingresscontroller.md>Easegress IngressController</a>는 인그레스 컨트롤러로서 실행할 수 있는 <a href=https://megaease.com/easegress/>Easegress</a> 기반 API 게이트웨이다.</li>
<li>F5 BIG-IP <a href=https://clouddocs.f5.com/containers/latest/userguide/kubernetes/>쿠버네티스 용 컨테이너 인그레스 서비스</a>를
이용하면 인그레스를 사용하여 F5 BIG-IP 가상 서버를 구성할 수 있다.</li>
<li><a href=https://gloo.solo.io>Gloo</a>는 API 게이트웨이 기능을 제공하는 <a href=https://www.envoyproxy.io>Envoy</a> 기반의
오픈소스 인그레스 컨트롤러다.</li>
<li><a href=https://haproxy-ingress.github.io/>HAProxy 인그레스</a>는 <a href=https://www.haproxy.org/#desc>HAProxy</a>의
인그레스 컨트롤러다.</li>
<li><a href=https://github.com/haproxytech/kubernetes-ingress#readme>쿠버네티스 용 HAProxy 인그레스 컨트롤러</a>는 <a href=https://www.haproxy.org/#desc>HAProxy</a> 용
인그레스 컨트롤러이기도 하다.</li>
<li><a href=https://istio.io/latest/docs/tasks/traffic-management/ingress/kubernetes-ingress/>Istio 인그레스</a>는 <a href=https://istio.io/>Istio</a>
기반 인그레스 컨트롤러다.</li>
<li><a href=https://github.com/Kong/kubernetes-ingress-controller#readme>쿠버네티스 용 Kong 인그레스 컨트롤러</a>는 <a href=https://konghq.com/kong/>Kong 게이트웨이</a>를
구동하는 인그레스 컨트롤러다.</li>
<li><a href=https://www.nginx.com/products/nginx-ingress-controller/>쿠버네티스 용 NGINX 인그레스 컨트롤러</a>는 <a href=https://www.nginx.com/resources/glossary/nginx/>NGINX</a>
웹서버(프록시로 사용)와 함께 작동한다.</li>
<li><a href=https://opensource.zalando.com/skipper/kubernetes/ingress-controller/>Skipper</a>는 사용자의 커스텀 프록시를 구축하기 위한 라이브러리로 설계된 쿠버네티스 인그레스와 같은 유스케이스를 포함한 서비스 구성을 위한 HTTP 라우터 및 역방향 프록시다.</li>
<li><a href=https://doc.traefik.io/traefik/providers/kubernetes-ingress/>Traefik 쿠버네티스 인그레스 제공자</a>는
<a href=https://traefik.io/traefik/>Traefik</a> 프록시 용 인그레스 컨트롤러다.</li>
<li><a href=https://github.com/TykTechnologies/tyk-operator>Tyk 오퍼레이터</a>는 사용자 지정 리소스로 인그레스를 확장하여 API 관리 기능을 인그레스로 가져온다. Tyk 오퍼레이터는 오픈 소스 Tyk 게이트웨이 및 Tyk 클라우드 컨트롤 플레인과 함께 작동한다.</li>
<li><a href=https://appscode.com/products/voyager>Voyager</a>는
<a href=https://www.haproxy.org/#desc>HAProxy</a>의 인그레스 컨트롤러다.</li>
</ul>
<h2 id=여러-인그레스-컨트롤러-사용>여러 인그레스 컨트롤러 사용</h2>
<p>하나의 클러스터 내에 <a href=https://git.k8s.io/ingress-nginx/docs/user-guide/multiple-ingress.md#multiple-ingress-controllers>여러 개의 인그레스 컨트롤러</a>를 배포할 수 있다.
인그레스를 생성할 때, 클러스터 내에 둘 이상의 인그레스 컨트롤러가 존재하는 경우
어떤 인그레스 컨트롤러를 사용해야 하는지 표시해주는 적절한 <a href=https://git.k8s.io/ingress-gce/docs/faq/README.md#how-do-i-run-multiple-ingress-controllers-in-the-same-cluster><code>ingress.class</code></a>
어노테이션을 각각의 인그레스에 달아야 한다.</p>
<p>만약 클래스를 정의하지 않으면, 클라우드 제공자는 기본 인그레스 컨트롤러를 사용할 수 있다.</p>
<p>이상적으로는 모든 인그레스 컨트롤러가 이 사양을 충족해야 하지만,
다양한 인그레스 컨트롤러는 약간 다르게 작동한다.</p>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> 인그레스 컨트롤러의 설명서를 검토하여 선택 시 주의 사항을 이해해야 한다.
</div>
<h2 id=다음-내용>다음 내용</h2>
<ul>
<li><a href=/ko/docs/concepts/services-networking/ingress/>인그레스</a>에 대해 자세히 알아보기.</li>
<li><a href=/ko/docs/tasks/access-application-cluster/ingress-minikube/>NGINX 컨트롤러로 Minikube에서 인그레스를 설정하기</a>.</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-199bcc92443dbc9bed44819467d7eb75>5.6 - 인그레스(Ingress)</h1>
<p>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.19 [stable]</code>
</div>
<p>클러스터 내의 서비스에 대한 외부 접근을 관리하는 API 오브젝트이며, 일반적으로 HTTP를 관리함.</p>
<p>인그레스는 부하 분산, SSL 종료, 명칭 기반의 가상 호스팅을 제공할 수 있다.</p></p>
<h2 id=용어>용어</h2>
<p>이 가이드는 용어의 명확성을 위해 다음과 같이 정의한다.</p>
<ul>
<li>노드(Node): 클러스터의 일부이며, 쿠버네티스에 속한 워커 머신.</li>
<li>클러스터(Cluster): 쿠버네티스에서 관리되는 컨테이너화 된 애플리케이션을 실행하는 노드 집합. 이 예시와 대부분의 일반적인 쿠버네티스 배포에서 클러스터에 속한 노드는 퍼블릭 인터넷의 일부가 아니다.</li>
<li>에지 라우터(Edge router): 클러스터에 방화벽 정책을 적용하는 라우터. 이것은 클라우드 공급자 또는 물리적 하드웨어의 일부에서 관리하는 게이트웨이일 수 있다.</li>
<li>클러스터 네트워크(Cluster network): 쿠버네티스 <a href=/ko/docs/concepts/cluster-administration/networking/>네트워킹 모델</a>에 따라 클러스터 내부에서 통신을 용이하게 하는 논리적 또는 물리적 링크 집합.</li>
<li>서비스: <a class=glossary-tooltip title="사용자에게 의미 있고 관련성 높은 특징으로 식별할 수 있도록 오브젝트에 태그를 붙인다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/overview/working-with-objects/labels target=_blank aria-label=레이블>레이블</a> 셀렉터를 사용해서 파드 집합을 식별하는 쿠버네티스 <a class=glossary-tooltip title="네트워크 서비스로 파드 집합에서 실행 중인 애플리케이션을 노출하는 방법" data-toggle=tooltip data-placement=top href=/ko/docs/concepts/services-networking/service/ target=_blank aria-label=서비스>서비스</a>. 달리 언급하지 않으면 서비스는 클러스터 네트워크 내에서만 라우팅 가능한 가상 IP를 가지고 있다고 가정한다.</li>
</ul>
<h2 id=인그레스란>인그레스란?</h2>
<p><a href=/docs/reference/generated/kubernetes-api/v1.23/#ingress-v1-networking-k8s-io>인그레스</a>는 클러스터 외부에서 클러스터 내부
<a href=/ko/docs/concepts/services-networking/service/ target=_blank>서비스</a>로 HTTP와 HTTPS 경로를 노출한다.
트래픽 라우팅은 인그레스 리소스에 정의된 규칙에 의해 컨트롤된다.</p>
<p>다음은 인그레스가 모든 트래픽을 하나의 서비스로 보내는 간단한 예시이다.
<figure>
<div class=mermaid>
graph LR;
client([클라이언트])-. 인그레스-매니지드 <br> 로드 밸런서 .->ingress[인그레스];
ingress-->|라우팅 규칙|service[서비스];
subgraph 클러스터
ingress;
service-->pod1[파드];
service-->pod2[파드];
end
classDef plain fill:#ddd,stroke:#fff,stroke-width:4px,color:#000;
classDef k8s fill:#326ce5,stroke:#fff,stroke-width:4px,color:#fff;
classDef cluster fill:#fff,stroke:#bbb,stroke-width:2px,color:#326ce5;
class ingress,service,pod1,pod2 k8s;
class client plain;
class cluster cluster;
</div>
</figure>
<noscript>
<div class="alert alert-secondary callout" role=alert>
<em class=javascript-required>JavaScript must be <a href=https://www.enable-javascript.com/>enabled</a> to view this content</em>
</div>
</noscript></p>
<p>인그레스는 외부에서 서비스로 접속이 가능한 URL, 로드 밸런스 트래픽, SSL / TLS 종료 그리고 이름-기반의 가상 호스팅을 제공하도록 구성할 수 있다. <a href=/ko/docs/concepts/services-networking/ingress-controllers>인그레스 컨트롤러</a>는 일반적으로 로드 밸런서를 사용해서 인그레스를 수행할 책임이 있으며, 트래픽을 처리하는데 도움이 되도록 에지 라우터 또는 추가 프런트 엔드를 구성할 수도 있다.</p>
<p>인그레스는 임의의 포트 또는 프로토콜을 노출시키지 않는다. HTTP와 HTTPS 이외의 서비스를 인터넷에 노출하려면 보통
<a href=/ko/docs/concepts/services-networking/service/#type-nodeport>Service.Type=NodePort</a> 또는
<a href=/ko/docs/concepts/services-networking/service/#loadbalancer>Service.Type=LoadBalancer</a> 유형의 서비스를 사용한다.</p>
<h2 id=전제-조건들>전제 조건들</h2>
<p><a href=/ko/docs/concepts/services-networking/ingress-controllers>인그레스 컨트롤러</a>가 있어야 인그레스를 충족할 수 있다. 인그레스 리소스만 생성한다면 효과가 없다.</p>
<p><a href=https://kubernetes.github.io/ingress-nginx/deploy/>ingress-nginx</a>와 같은 인그레스 컨트롤러를 배포해야 할 수도 있다. 여러
<a href=/ko/docs/concepts/services-networking/ingress-controllers>인그레스 컨트롤러</a> 중에서 선택할 수도 있다.</p>
<p>이상적으로, 모든 인그레스 컨트롤러는 참조 사양이 맞아야 한다. 실제로, 다양한 인그레스
컨트롤러는 조금 다르게 작동한다.</p>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> 인그레스 컨트롤러의 설명서를 검토하여 선택 시 주의 사항을 이해해야 한다.
</div>
<h2 id=인그레스-리소스>인그레스 리소스</h2>
<p>최소한의 인그레스 리소스 예제:</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/ko/examples/service/networking/minimal-ingress.yaml download=service/networking/minimal-ingress.yaml><code>service/networking/minimal-ingress.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('service-networking-minimal-ingress-yaml')" title="Copy service/networking/minimal-ingress.yaml to clipboard">
</img>
</div>
<div class=includecode id=service-networking-minimal-ingress-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>networking.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Ingress<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>minimal-ingress<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>nginx.ingress.kubernetes.io/rewrite-target</span>:<span style=color:#bbb> </span>/<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ingressClassName</span>:<span style=color:#bbb> </span>nginx-example<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>http</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>paths</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/testpath<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>pathType</span>:<span style=color:#bbb> </span>Prefix<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>backend</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>service</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>number</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>다른 모든 쿠버네티스 리소스와 마찬가지로 인그레스에는 <code>apiVersion</code>, <code>kind</code>, 그리고 <code>metadata</code> 필드가 필요하다.
인그레스 오브젝트의 이름은 유효한
<a href=/ko/docs/concepts/overview/working-with-objects/names/#dns-%EC%84%9C%EB%B8%8C%EB%8F%84%EB%A9%94%EC%9D%B8-%EC%9D%B4%EB%A6%84>DNS 서브도메인 이름</a>이어야 한다.
설정 파일의 작성에 대한 일반적인 내용은 <a href=/ko/docs/tasks/run-application/run-stateless-application-deployment/>애플리케이션 배포하기</a>, <a href=/docs/tasks/configure-pod-container/configure-pod-configmap/>컨테이너 구성하기</a>, <a href=/ko/docs/concepts/cluster-administration/manage-deployment/>리소스 관리하기</a>를 참조한다.
인그레스는 종종 어노테이션을 이용해서 인그레스 컨트롤러에 따라 몇 가지 옵션을 구성하는데,
그 예시는 <a href=https://github.com/kubernetes/ingress-nginx/blob/master/docs/examples/rewrite/README.md>재작성-타겟 어노테이션</a>이다.
서로 다른 <a href=/ko/docs/concepts/services-networking/ingress-controllers>인그레스 컨트롤러</a>는 서로 다른 어노테이션을 지원한다.
지원되는 어노테이션을 확인하려면 선택한 인그레스 컨트롤러의 설명서를 검토한다.</p>
<p>인그레스 <a href=https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status>사양</a>
에는 로드 밸런서 또는 프록시 서버를 구성하는데 필요한 모든 정보가 있다. 가장 중요한 것은,
들어오는 요청과 일치하는 규칙 목록을 포함하는 것이다. 인그레스 리소스는 HTTP(S) 트래픽을
지시하는 규칙만 지원한다.</p>
<p><code>ingressClassName</code>을 생략하려면, <a href=#default-ingress-class>기본 인그레스 클래스</a>가
정의되어 있어야 한다.</p>
<p>몇몇 인그레스 컨트롤러는 기본 <code>IngressClass</code>가 정의되어 있지 않아도 동작한다.
예를 들어, Ingress-NGINX 컨트롤러는 <code>--watch-ingress-without-class</code>
<a href=https://kubernetes.github.io/ingress-nginx/#what-is-the-flag-watch-ingress-without-class>플래그</a>를 이용하여 구성될 수 있다.
하지만 <a href=#default-ingress-class>아래</a>에 나와 있는 것과 같이 기본 <code>IngressClass</code>를 명시하는 것을
<a href=https://kubernetes.github.io/ingress-nginx/#i-have-only-one-instance-of-the-ingresss-nginx-controller-in-my-cluster-what-should-i-do>권장</a>한다.</p>
<h3 id=인그레스-규칙>인그레스 규칙</h3>
<p>각 HTTP 규칙에는 다음의 정보가 포함된다.</p>
<ul>
<li>선택적 호스트. 이 예시에서는, 호스트가 지정되지 않기에 지정된 IP 주소를 통해 모든 인바운드
HTTP 트래픽에 규칙이 적용 된다. 만약 호스트가 제공되면(예,
foo.bar.com), 규칙이 해당 호스트에 적용된다.</li>
<li>경로 목록 (예, <code>/testpath</code>)에는 각각 <code>service.name</code> 과
<code>service.port.name</code> 또는 <code>service.port.number</code> 가 정의되어 있는 관련
백엔드를 가지고 있다. 로드 밸런서가 트래픽을 참조된 서비스로
보내기 전에 호스트와 경로가 모두 수신 요청의 내용과
일치해야 한다.</li>
<li>백엔드는 <a href=/ko/docs/concepts/services-networking/service/>서비스 문서</a> 또는 <a href=#resource-backend>사용자 정의 리소스 백엔드</a>에 설명된 바와 같이
서비스와 포트 이름의 조합이다. 호스트와 규칙 경로가 일치하는 인그레스에 대한
HTTP(와 HTTPS) 요청은 백엔드 목록으로 전송된다.</li>
</ul>
<p><code>defaultBackend</code> 는 종종 사양의 경로와 일치하지 않는 서비스에 대한 모든 요청을 처리하도록 인그레스
컨트롤러에 구성되는 경우가 많다.</p>
<h3 id=default-backend>DefaultBackend</h3>
<p>규칙이 없는 인그레스는 모든 트래픽을 단일 기본 백엔드로 전송한다. <code>defaultBackend</code> 는 일반적으로
<a href=/ko/docs/concepts/services-networking/ingress-controllers>인그레스 컨트롤러</a>의 구성 옵션이며, 인그레스 리소스에 지정되어 있지 않다.</p>
<p>만약 인그레스 오브젝트의 HTTP 요청과 일치하는 호스트 또는 경로가 없으면, 트래픽은
기본 백엔드로 라우팅 된다.</p>
<h3 id=resource-backend>리소스 백엔드</h3>
<p><code>Resource</code> 백엔드는 인그레스 오브젝트와 동일한 네임스페이스 내에 있는
다른 쿠버네티스 리소스에 대한 ObjectRef이다. <code>Resource</code> 는 서비스와
상호 배타적인 설정이며, 둘 다 지정하면 유효성 검사에 실패한다. <code>Resource</code>
백엔드의 일반적인 용도는 정적 자산이 있는 오브젝트 스토리지 백엔드로 데이터를
수신하는 것이다.</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/ko/examples/service/networking/ingress-resource-backend.yaml download=service/networking/ingress-resource-backend.yaml><code>service/networking/ingress-resource-backend.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('service-networking-ingress-resource-backend-yaml')" title="Copy service/networking/ingress-resource-backend.yaml to clipboard">
</img>
</div>
<div class=includecode id=service-networking-ingress-resource-backend-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>networking.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Ingress<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>ingress-resource-backend<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>defaultBackend</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resource</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>k8s.example.com<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StorageBucket<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>static-assets<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>http</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>paths</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span>- <span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/icons<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>pathType</span>:<span style=color:#bbb> </span>ImplementationSpecific<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>backend</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>resource</span>:<span style=color:#bbb>
</span><span style=color:#bbb>                </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>k8s.example.com<span style=color:#bbb>
</span><span style=color:#bbb>                </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StorageBucket<span style=color:#bbb>
</span><span style=color:#bbb>                </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>icon-assets<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>위의 인그레스를 생성한 후, 다음의 명령으로 확인할 수 있다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl describe ingress ingress-resource-backend
</code></pre></div><pre><code>Name:             ingress-resource-backend
Namespace:        default
Address:
Default backend:  APIGroup: k8s.example.com, Kind: StorageBucket, Name: static-assets
Rules:
  Host        Path  Backends
  ----        ----  --------
  *
              /icons   APIGroup: k8s.example.com, Kind: StorageBucket, Name: icon-assets
Annotations:  &lt;none&gt;
Events:       &lt;none&gt;
</code></pre><h3 id=경로-유형>경로 유형</h3>
<p>인그레스의 각 경로에는 해당 경로 유형이 있어야 한다. 명시적
<code>pathType</code> 을 포함하지 않는 경로는 유효성 검사에 실패한다. 지원되는
경로 유형은 세 가지이다.</p>
<ul>
<li>
<p><code>ImplementationSpecific</code>: 이 경로 유형의 일치 여부는 IngressClass에 따라
달라진다. 이를 구현할 때 별도 <code>pathType</code> 으로 처리하거나, <code>Prefix</code> 또는 <code>Exact</code>
경로 유형과 같이 동일하게 처리할 수 있다.</p>
</li>
<li>
<p><code>Exact</code>: URL 경로의 대소문자를 엄격하게 일치시킨다.</p>
</li>
<li>
<p><code>Prefix</code>: URL 경로의 접두사를 <code>/</code> 를 기준으로 분리한 값과 일치시킨다.
일치는 대소문자를 구분하고,
요소별로 경로 요소에 대해 수행한다.
모든 <em>p</em> 가 요청 경로의 요소별 접두사가 <em>p</em> 인 경우
요청은 <em>p</em> 경로에 일치한다.</p>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> 경로의 마지막 요소가 요청 경로에 있는 마지막
요소의 하위 문자열인 경우에는 일치하지 않는다(예시: <code>/foo/bar</code> 는
<code>/foo/bar/baz</code> 와 일치하지만, <code>/foo/barbaz</code> 와는 일치하지 않는다).
</div>
</li>
</ul>
<h3 id=예제>예제</h3>
<table>
<thead>
<tr>
<th>종류</th>
<th>경로</th>
<th>요청 경로</th>
<th>일치 여부</th>
</tr>
</thead>
<tbody>
<tr>
<td>Prefix</td>
<td><code>/</code></td>
<td>(모든 경로)</td>
<td>예</td>
</tr>
<tr>
<td>Exact</td>
<td><code>/foo</code></td>
<td><code>/foo</code></td>
<td>예</td>
</tr>
<tr>
<td>Exact</td>
<td><code>/foo</code></td>
<td><code>/bar</code></td>
<td>아니오</td>
</tr>
<tr>
<td>Exact</td>
<td><code>/foo</code></td>
<td><code>/foo/</code></td>
<td>아니오</td>
</tr>
<tr>
<td>Exact</td>
<td><code>/foo/</code></td>
<td><code>/foo</code></td>
<td>아니오</td>
</tr>
<tr>
<td>Prefix</td>
<td><code>/foo</code></td>
<td><code>/foo</code>, <code>/foo/</code></td>
<td>예</td>
</tr>
<tr>
<td>Prefix</td>
<td><code>/foo/</code></td>
<td><code>/foo</code>, <code>/foo/</code></td>
<td>예</td>
</tr>
<tr>
<td>Prefix</td>
<td><code>/aaa/bb</code></td>
<td><code>/aaa/bbb</code></td>
<td>아니오</td>
</tr>
<tr>
<td>Prefix</td>
<td><code>/aaa/bbb</code></td>
<td><code>/aaa/bbb</code></td>
<td>예</td>
</tr>
<tr>
<td>Prefix</td>
<td><code>/aaa/bbb/</code></td>
<td><code>/aaa/bbb</code></td>
<td>예, 마지막 슬래시 무시함</td>
</tr>
<tr>
<td>Prefix</td>
<td><code>/aaa/bbb</code></td>
<td><code>/aaa/bbb/</code></td>
<td>예, 마지막 슬래시 일치함</td>
</tr>
<tr>
<td>Prefix</td>
<td><code>/aaa/bbb</code></td>
<td><code>/aaa/bbb/ccc</code></td>
<td>예, 하위 경로 일치함</td>
</tr>
<tr>
<td>Prefix</td>
<td><code>/aaa/bbb</code></td>
<td><code>/aaa/bbbxyz</code></td>
<td>아니오, 문자열 접두사 일치하지 않음</td>
</tr>
<tr>
<td>Prefix</td>
<td><code>/</code>, <code>/aaa</code></td>
<td><code>/aaa/ccc</code></td>
<td>예, <code>/aaa</code> 접두사 일치함</td>
</tr>
<tr>
<td>Prefix</td>
<td><code>/</code>, <code>/aaa</code>, <code>/aaa/bbb</code></td>
<td><code>/aaa/bbb</code></td>
<td>예, <code>/aaa/bbb</code> 접두사 일치함</td>
</tr>
<tr>
<td>Prefix</td>
<td><code>/</code>, <code>/aaa</code>, <code>/aaa/bbb</code></td>
<td><code>/ccc</code></td>
<td>예, <code>/</code> 접두사 일치함</td>
</tr>
<tr>
<td>Prefix</td>
<td><code>/aaa</code></td>
<td><code>/ccc</code></td>
<td>아니오, 기본 백엔드 사용함</td>
</tr>
<tr>
<td>Mixed</td>
<td><code>/foo</code> (Prefix), <code>/foo</code> (Exact)</td>
<td><code>/foo</code></td>
<td>예, Exact 선호함</td>
</tr>
</tbody>
</table>
<h4 id=다중-일치>다중 일치</h4>
<p>경우에 따라 인그레스의 여러 경로가 요청과 일치할 수 있다.
이 경우 가장 긴 일치하는 경로가 우선하게 된다. 두 개의 경로가
여전히 동일하게 일치하는 경우 접두사(prefix) 경로 유형보다
정확한(exact) 경로 유형을 가진 경로가 사용 된다.</p>
<h2 id=호스트네임-와일드카드>호스트네임 와일드카드</h2>
<p>호스트는 정확한 일치(예: "<code>foo.bar.com</code>") 또는 와일드카드(예:
"<code>* .foo.com</code>")일 수 있다. 정확한 일치를 위해서는 HTTP <code>host</code> 헤더가
<code>host</code> 필드와 일치해야 한다. 와일드카드 일치를 위해서는 HTTP <code>host</code> 헤더가
와일드카드 규칙의 접미사와 동일해야 한다.</p>
<table>
<thead>
<tr>
<th>호스트</th>
<th>호스트 헤더</th>
<th>일치 여부</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>*.foo.com</code></td>
<td><code>bar.foo.com</code></td>
<td>공유 접미사를 기반으로 일치함</td>
</tr>
<tr>
<td><code>*.foo.com</code></td>
<td><code>baz.bar.foo.com</code></td>
<td>일치하지 않음, 와일드카드는 단일 DNS 레이블만 포함함</td>
</tr>
<tr>
<td><code>*.foo.com</code></td>
<td><code>foo.com</code></td>
<td>일치하지 않음, 와일드카드는 단일 DNS 레이블만 포함함</td>
</tr>
</tbody>
</table>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/ko/examples/service/networking/ingress-wildcard-host.yaml download=service/networking/ingress-wildcard-host.yaml><code>service/networking/ingress-wildcard-host.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('service-networking-ingress-wildcard-host-yaml')" title="Copy service/networking/ingress-wildcard-host.yaml to clipboard">
</img>
</div>
<div class=includecode id=service-networking-ingress-wildcard-host-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>networking.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Ingress<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>ingress-wildcard-host<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>host</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;foo.bar.com&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>http</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>paths</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>pathType</span>:<span style=color:#bbb> </span>Prefix<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/bar&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>backend</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>service</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>service1<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>number</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>host</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;*.foo.com&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>http</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>paths</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>pathType</span>:<span style=color:#bbb> </span>Prefix<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/foo&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>backend</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>service</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>service2<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>number</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<h2 id=인그레스-클래스>인그레스 클래스</h2>
<p>인그레스는 서로 다른 컨트롤러에 의해 구현될 수 있으며, 종종 다른 구성으로
구현될 수 있다. 각 인그레스에서는 클래스를 구현해야하는 컨트롤러
이름을 포함하여 추가 구성이 포함된 IngressClass
리소스에 대한 참조 클래스를 지정해야 한다.</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/ko/examples/service/networking/external-lb.yaml download=service/networking/external-lb.yaml><code>service/networking/external-lb.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('service-networking-external-lb-yaml')" title="Copy service/networking/external-lb.yaml to clipboard">
</img>
</div>
<div class=includecode id=service-networking-external-lb-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>networking.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>IngressClass<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>external-lb<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>controller</span>:<span style=color:#bbb> </span>example.com/ingress-controller<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>parameters</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>k8s.example.com<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>IngressParameters<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>external-lb<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>인그레스클래스의 <code>.spec.parameters</code> 필드를 사용하여
해당 인그레스클래스와 연관있는 환경 설정을 제공하는 다른 리소스를 참조할 수 있다.</p>
<p>사용 가능한 파라미터의 상세한 타입은
인그레스클래스의 <code>.spec.parameters</code> 필드에 명시한 인그레스 컨트롤러의 종류에 따라 다르다.</p>
<h3 id=인그레스클래스-범위>인그레스클래스 범위</h3>
<p>인그레스 컨트롤러의 종류에 따라, 클러스터 범위로 설정한 파라미터의 사용이 가능할 수도 있고,
또는 한 네임스페이스에서만 사용 가능할 수도 있다.</p>
<ul class="nav nav-tabs" id=tabs-ingressclass-parameter-scope role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tabs-ingressclass-parameter-scope-0 role=tab aria-controls=tabs-ingressclass-parameter-scope-0 aria-selected=true>클러스터</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tabs-ingressclass-parameter-scope-1 role=tab aria-controls=tabs-ingressclass-parameter-scope-1>네임스페이스</a></li></ul>
<div class=tab-content id=tabs-ingressclass-parameter-scope><div id=tabs-ingressclass-parameter-scope-0 class="tab-pane show active" role=tabpanel aria-labelledby=tabs-ingressclass-parameter-scope-0>
<p><p>인그레스클래스 파라미터의 기본 범위는 클러스터 범위이다.</p>
<p><code>.spec.parameters</code> 필드만 설정하고 <code>.spec.parameters.scope</code> 필드는 지정하지 않거나,
<code>.spec.parameters.scope</code> 필드를 <code>Cluster</code>로 지정하면,
인그레스클래스는 클러스터 범위의 리소스를 참조한다.
파라미터의 <code>kind</code>(+<code>apiGroup</code>)는
클러스터 범위의 API (커스텀 리소스일 수도 있음) 를 참조하며,
파라미터의 <code>name</code>은
해당 API에 대한 특정 클러스터 범위 리소스를 가리킨다.</p>
<p>예시는 다음과 같다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>networking.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>IngressClass<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>external-lb-1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>controller</span>:<span style=color:#bbb> </span>example.com/ingress-controller<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>parameters</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 이 인그레스클래스에 대한 파라미터는 &#34;external-config-1&#34; 라는</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># ClusterIngressParameter(API 그룹 k8s.example.net)에 기재되어 있다.</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 이 정의는 쿠버네티스가 </span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 클러스터 범위의 파라미터 리소스를 검색하도록 한다.</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>scope</span>:<span style=color:#bbb> </span>Cluster<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>k8s.example.net<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterIngressParameter<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>external-config-1<span style=color:#bbb>
</span></code></pre></div></div>
<div id=tabs-ingressclass-parameter-scope-1 class=tab-pane role=tabpanel aria-labelledby=tabs-ingressclass-parameter-scope-1>
<p><div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.23 [stable]</code>
</div>
<p><code>.spec.parameters</code> 필드를 설정하고
<code>.spec.parameters.scope</code> 필드를 <code>Namespace</code>로 지정하면,
인그레스클래스는 네임스페이스 범위의 리소스를 참조한다.
사용하고자 하는 파라미터가 속한 네임스페이스를
<code>.spec.parameters</code> 의 <code>namespace</code> 필드에 설정해야 한다.</p>
<p>파라미터의 <code>kind</code>(+<code>apiGroup</code>)는
네임스페이스 범위의 API (예: 컨피그맵) 를 참조하며,
파라미터의 <code>name</code>은
<code>namespace</code>에 명시한 네임스페이스의 특정 리소스를 가리킨다.</p>
<p>네임스페이스 범위의 파라미터를 이용하여,
클러스터 운영자가 워크로드에 사용되는 환경 설정(예: 로드 밸런서 설정, API 게이트웨이 정의)에 대한 제어를 위임할 수 있다.
클러스터 범위의 파라미터를 사용했다면 다음 중 하나에 해당된다.</p>
<ul>
<li>다른 팀의 새로운 환경 설정 변경을 적용하려고 할 때마다
클러스터 운영 팀이 매번 승인을 해야 한다. 또는,</li>
<li>애플리케이션 팀이 클러스터 범위 파라미터 리소스를 변경할 수 있게 하는
<a href=/docs/reference/access-authn-authz/rbac/>RBAC</a> 롤, 바인딩 등의 특별 접근 제어를
클러스터 운영자가 정의해야 한다.</li>
</ul>
<p>인그레스클래스 API 자신은 항상 클러스터 범위이다.</p>
<p>네임스페이스 범위의 파라미터를 참조하는 인그레스클래스 예시가
다음과 같다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>networking.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>IngressClass<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>external-lb-2<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>controller</span>:<span style=color:#bbb> </span>example.com/ingress-controller<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>parameters</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 이 인그레스클래스에 대한 파라미터는 </span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># &#34;external-configuration&#34; 환경 설정 네임스페이스에 있는</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># &#34;external-config&#34; 라는 IngressParameter(API 그룹 k8s.example.com)에 기재되어 있다.</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>scope</span>:<span style=color:#bbb> </span>Namespace<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>k8s.example.com<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>IngressParameter<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>external-configuration<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>external-config<span style=color:#bbb>
</span></code></pre></div></div></div>
<h3 id=사용중단-deprecated-어노테이션>사용중단(Deprecated) 어노테이션</h3>
<p>쿠버네티스 1.18에 IngressClass 리소스 및 <code>ingressClassName</code> 필드가 추가되기
전에 인그레스 클래스는 인그레스에서
<code>kubernetes.io/ingress.class</code> 어노테이션으로 지정되었다. 이 어노테이션은
공식적으로 정의된 것은 아니지만, 인그레스 컨트롤러에서 널리 지원되었었다.</p>
<p>인그레스의 최신 <code>ingressClassName</code> 필드는 해당 어노테이션을
대체하지만, 직접적으로 해당하는 것은 아니다. 어노테이션은 일반적으로
인그레스를 구현해야 하는 인그레스 컨트롤러의 이름을 참조하는 데 사용되었지만,
이 필드는 인그레스 컨트롤러의 이름을 포함하는 추가 인그레스 구성이
포함된 인그레스 클래스 리소스에 대한 참조이다.</p>
<h3 id=default-ingress-class>기본 IngressClass</h3>
<p>특정 IngressClass를 클러스터의 기본 값으로 표시할 수 있다. IngressClass
리소스에서 <code>ingressclass.kubernetes.io/is-default-class</code> 를 <code>true</code> 로
설정하면 <code>ingressClassName</code> 필드가 지정되지 않은
새 인그레스에게 기본 IngressClass가 할당된다.</p>
<div class="alert alert-warning caution callout" role=alert>
<strong>주의:</strong> 클러스터의 기본값으로 표시된 IngressClass가 두 개 이상 있는 경우
어드미션 컨트롤러에서 <code>ingressClassName</code> 이 지정되지 않은
새 인그레스 오브젝트를 생성할 수 없다. 클러스터에서 최대 1개의 IngressClass가
기본값으로 표시하도록 해서 이 문제를 해결할 수 있다.
</div>
<p>몇몇 인그레스 컨트롤러는 기본 <code>IngressClass</code>가 정의되어 있지 않아도 동작한다.
예를 들어, Ingress-NGINX 컨트롤러는 <code>--watch-ingress-without-class</code>
<a href=https://kubernetes.github.io/ingress-nginx/#what-is-the-flag-watch-ingress-without-class>플래그</a>를 이용하여 구성될 수 있다.
하지만 다음과 같이 기본 <code>IngressClass</code>를 명시하는 것을
<a href=https://kubernetes.github.io/ingress-nginx/#i-have-only-one-instance-of-the-ingresss-nginx-controller-in-my-cluster-what-should-i-do>권장</a>한다.</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/ko/examples/service/networking/default-ingressclass.yaml download=service/networking/default-ingressclass.yaml><code>service/networking/default-ingressclass.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('service-networking-default-ingressclass-yaml')" title="Copy service/networking/default-ingressclass.yaml to clipboard">
</img>
</div>
<div class=includecode id=service-networking-default-ingressclass-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>networking.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>IngressClass<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/component</span>:<span style=color:#bbb> </span>controller<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-example<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>ingressclass.kubernetes.io/is-default-class</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>controller</span>:<span style=color:#bbb> </span>k8s.io/ingress-nginx<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<h2 id=인그레스-유형들>인그레스 유형들</h2>
<h3 id=single-service-ingress>단일 서비스로 지원되는 인그레스</h3>
<p>단일 서비스를 노출할 수 있는 기존 쿠버네티스 개념이 있다
(<a href=#%EB%8C%80%EC%95%88>대안</a>을 본다). 인그레스에 규칙 없이 <em>기본 백엔드</em> 를 지정해서
이를 수행할 수 있다.</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/ko/examples/service/networking/test-ingress.yaml download=service/networking/test-ingress.yaml><code>service/networking/test-ingress.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('service-networking-test-ingress-yaml')" title="Copy service/networking/test-ingress.yaml to clipboard">
</img>
</div>
<div class=includecode id=service-networking-test-ingress-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>networking.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Ingress<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-ingress<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>defaultBackend</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>service</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>number</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>만약 <code>kubectl apply -f</code> 를 사용해서 생성한다면 추가한 인그레스의
상태를 볼 수 있어야 한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl get ingress test-ingress
</code></pre></div><pre><code>NAME           CLASS         HOSTS   ADDRESS         PORTS   AGE
test-ingress   external-lb   *       203.0.113.123   80      59s
</code></pre><p>여기서 <code>203.0.113.123</code> 는 인그레스 컨트롤러가 인그레스를 충족시키기 위해
할당한 IP 이다.</p>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> 인그레스 컨트롤러와 로드 밸런서는 IP 주소를 할당하는데 1~2분이 걸릴 수 있다.
할당될 때 까지는 주소는 종종 <code>&lt;pending></code> 으로 표시된다.
</div>
<h3 id=간단한-팬아웃-fanout>간단한 팬아웃(fanout)</h3>
<p>팬아웃 구성은 HTTP URI에서 요청된 것을 기반으로 단일 IP 주소에서 1개 이상의 서비스로
트래픽을 라우팅 한다. 인그레스를 사용하면 로드 밸런서의 수를
최소로 유지할 수 있다. 예를 들어 다음과 같은 설정을 한다.</p>
<figure>
<div class=mermaid>
graph LR;
client([클라이언트])-. 인그레스-매니지드 <br> 로드 밸런서 .->ingress[인그레스, 178.91.123.132];
ingress-->|/foo|service1[서비스 service1:4200];
ingress-->|/bar|service2[서비스 service2:8080];
subgraph 클러스터
ingress;
service1-->pod1[파드];
service1-->pod2[파드];
service2-->pod3[파드];
service2-->pod4[파드];
end
classDef plain fill:#ddd,stroke:#fff,stroke-width:4px,color:#000;
classDef k8s fill:#326ce5,stroke:#fff,stroke-width:4px,color:#fff;
classDef cluster fill:#fff,stroke:#bbb,stroke-width:2px,color:#326ce5;
class ingress,service1,service2,pod1,pod2,pod3,pod4 k8s;
class client plain;
class cluster cluster;
</div>
</figure>
<noscript>
<div class="alert alert-secondary callout" role=alert>
<em class=javascript-required>JavaScript must be <a href=https://www.enable-javascript.com/>enabled</a> to view this content</em>
</div>
</noscript>
<p>다음과 같은 인그레스가 필요하다.</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/ko/examples/service/networking/simple-fanout-example.yaml download=service/networking/simple-fanout-example.yaml><code>service/networking/simple-fanout-example.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('service-networking-simple-fanout-example-yaml')" title="Copy service/networking/simple-fanout-example.yaml to clipboard">
</img>
</div>
<div class=includecode id=service-networking-simple-fanout-example-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>networking.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Ingress<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>simple-fanout-example<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>host</span>:<span style=color:#bbb> </span>foo.bar.com<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>http</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>paths</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/foo<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>pathType</span>:<span style=color:#bbb> </span>Prefix<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>backend</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>service</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>service1<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>number</span>:<span style=color:#bbb> </span><span style=color:#666>4200</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/bar<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>pathType</span>:<span style=color:#bbb> </span>Prefix<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>backend</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>service</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>service2<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>number</span>:<span style=color:#bbb> </span><span style=color:#666>8080</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p><code>kubectl apply -f</code> 를 사용해서 인그레스를 생성 할 때 다음과 같다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe ingress simple-fanout-example
</code></pre></div><pre><code>Name:             simple-fanout-example
Namespace:        default
Address:          178.91.123.132
Default backend:  default-http-backend:80 (10.8.2.3:8080)
Rules:
  Host         Path  Backends
  ----         ----  --------
  foo.bar.com
               /foo   service1:4200 (10.8.0.90:4200)
               /bar   service2:8080 (10.8.0.91:8080)
Events:
  Type     Reason  Age                From                     Message
  ----     ------  ----               ----                     -------
  Normal   ADD     22s                loadbalancer-controller  default/test
</code></pre><p>인그레스 컨트롤러는 서비스(<code>service1</code>, <code>service2</code>)가 존재하는 한,
인그레스를 만족시키는 특정한 로드 밸런서를 프로비저닝한다.
이렇게 하면, 주소 필드에서 로드 밸런서의 주소를
볼 수 있다.</p>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> 사용 중인 <a href=/ko/docs/concepts/services-networking/ingress-controllers/>인그레스 컨트롤러</a>에
따라 default-http-backend
<a href=/ko/docs/concepts/services-networking/service/>서비스</a>를 만들어야 할 수도 있다.
</div>
<h3 id=이름-기반의-가상-호스팅>이름 기반의 가상 호스팅</h3>
<p>이름 기반의 가상 호스트는 동일한 IP 주소에서 여러 호스트 이름으로 HTTP 트래픽을 라우팅하는 것을 지원한다.</p>
<figure>
<div class=mermaid>
graph LR;
client([클라이언트])-. 인그레스-매니지드 <br> 로드 밸런서 .->ingress[인그레스, 178.91.123.132];
ingress-->|호스트: foo.bar.com|service1[서비스 service1:80];
ingress-->|호스트: bar.foo.com|service2[서비스 service2:80];
subgraph 클러스터
ingress;
service1-->pod1[파드];
service1-->pod2[파드];
service2-->pod3[파드];
service2-->pod4[파드];
end
classDef plain fill:#ddd,stroke:#fff,stroke-width:4px,color:#000;
classDef k8s fill:#326ce5,stroke:#fff,stroke-width:4px,color:#fff;
classDef cluster fill:#fff,stroke:#bbb,stroke-width:2px,color:#326ce5;
class ingress,service1,service2,pod1,pod2,pod3,pod4 k8s;
class client plain;
class cluster cluster;
</div>
</figure>
<noscript>
<div class="alert alert-secondary callout" role=alert>
<em class=javascript-required>JavaScript must be <a href=https://www.enable-javascript.com/>enabled</a> to view this content</em>
</div>
</noscript>
<p>다음 인그레스는 <a href=https://tools.ietf.org/html/rfc7230#section-5.4>호스트 헤더</a>에 기반한 요청을
라우팅 하기 위해 뒷단의 로드 밸런서를 알려준다.</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/ko/examples/service/networking/name-virtual-host-ingress.yaml download=service/networking/name-virtual-host-ingress.yaml><code>service/networking/name-virtual-host-ingress.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('service-networking-name-virtual-host-ingress-yaml')" title="Copy service/networking/name-virtual-host-ingress.yaml to clipboard">
</img>
</div>
<div class=includecode id=service-networking-name-virtual-host-ingress-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>networking.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Ingress<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>name-virtual-host-ingress<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>host</span>:<span style=color:#bbb> </span>foo.bar.com<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>http</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>paths</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>pathType</span>:<span style=color:#bbb> </span>Prefix<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>backend</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>service</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>service1<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>number</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>host</span>:<span style=color:#bbb> </span>bar.foo.com<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>http</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>paths</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>pathType</span>:<span style=color:#bbb> </span>Prefix<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>backend</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>service</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>service2<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>number</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>만약 규칙에 정의된 호스트 없이 인그레스 리소스를 생성하는 경우,
이름 기반 가상 호스트가 없어도 인그레스 컨트롤러의 IP 주소에 대한 웹
트래픽을 일치 시킬 수 있다.</p>
<p>예를 들어, 다음 인그레스는 <code>first.bar.com</code>에 요청된 트래픽을
<code>service1</code>로, <code>second.bar.com</code>는 <code>service2</code>로, 그리고 요청 헤더가 <code>first.bar.com</code> 또는 <code>second.bar.com</code>에 해당되지 않는 모든 트래픽을 <code>service3</code>로 라우팅한다.</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/ko/examples/service/networking/name-virtual-host-ingress-no-third-host.yaml download=service/networking/name-virtual-host-ingress-no-third-host.yaml><code>service/networking/name-virtual-host-ingress-no-third-host.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('service-networking-name-virtual-host-ingress-no-third-host-yaml')" title="Copy service/networking/name-virtual-host-ingress-no-third-host.yaml to clipboard">
</img>
</div>
<div class=includecode id=service-networking-name-virtual-host-ingress-no-third-host-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>networking.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Ingress<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>name-virtual-host-ingress-no-third-host<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>host</span>:<span style=color:#bbb> </span>first.bar.com<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>http</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>paths</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>pathType</span>:<span style=color:#bbb> </span>Prefix<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>backend</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>service</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>service1<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>number</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>host</span>:<span style=color:#bbb> </span>second.bar.com<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>http</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>paths</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>pathType</span>:<span style=color:#bbb> </span>Prefix<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>backend</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>service</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>service2<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>number</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>http</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>paths</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>pathType</span>:<span style=color:#bbb> </span>Prefix<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>backend</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>service</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>service3<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>number</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<h3 id=tls>TLS</h3>
<p>TLS 개인 키 및 인증서가 포함된 <a class=glossary-tooltip title="비밀번호, OAuth 토큰 및 ssh 키와 같은 민감한 정보를 저장한다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/configuration/secret/ target=_blank aria-label=시크릿(Secret)>시크릿(Secret)</a>을
지정해서 인그레스를 보호할 수 있다. 인그레스 리소스는
단일 TLS 포트인 443만 지원하고 인그레스 지점에서 TLS 종료를
가정한다(서비스 및 해당 파드에 대한 트래픽은 일반 텍스트임).
인그레스의 TLS 구성 섹션에서 다른 호스트를 지정하면, SNI TLS 확장을 통해
지정된 호스트이름에 따라 동일한 포트에서 멀티플렉싱
된다(인그레스 컨트롤러가 SNI를 지원하는 경우). TLS secret에는
<code>tls.crt</code> 와 <code>tls.key</code> 라는 이름의 키가 있어야 하고, 여기에는 TLS에 사용할 인증서와
개인 키가 있다. 예를 들어 다음과 같다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>testsecret-tls<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>tls.crt</span>:<span style=color:#bbb> </span>base64 encoded cert<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>tls.key</span>:<span style=color:#bbb> </span>base64 encoded key<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>kubernetes.io/tls<span style=color:#bbb>
</span></code></pre></div><p>인그레스에서 시크릿을 참조하면 인그레스 컨트롤러가 TLS를 사용하여
클라이언트에서 로드 밸런서로 채널을 보호하도록 지시한다. 생성한
TLS 시크릿이 <code>https-example.foo.com</code> 의 정규화 된 도메인 이름(FQDN)이라고
하는 일반 이름(CN)을 포함하는 인증서에서 온 것인지 확인해야 한다.</p>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> 가능한 모든 하위 도메인에 대해 인증서가 발급되어야 하기 때문에
TLS는 기본 규칙에서 작동하지 않는다. 따라서
<code>tls</code> 섹션의 <code>hosts</code>는 <code>rules</code>섹션의 <code>host</code>와 명시적으로 일치해야
한다.
</div>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/ko/examples/service/networking/tls-example-ingress.yaml download=service/networking/tls-example-ingress.yaml><code>service/networking/tls-example-ingress.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('service-networking-tls-example-ingress-yaml')" title="Copy service/networking/tls-example-ingress.yaml to clipboard">
</img>
</div>
<div class=includecode id=service-networking-tls-example-ingress-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>networking.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Ingress<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>tls-example-ingress<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>tls</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>hosts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- https-example.foo.com<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>secretName</span>:<span style=color:#bbb> </span>testsecret-tls<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>host</span>:<span style=color:#bbb> </span>https-example.foo.com<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>http</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>paths</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>pathType</span>:<span style=color:#bbb> </span>Prefix<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>backend</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>service</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>service1<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>number</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> TLS 기능을 제공하는 다양한 인그레스 컨트롤러간의 기능
차이가 있다. 사용자 환경에서의 TLS의 작동 방식을 이해하려면
<a href=https://kubernetes.github.io/ingress-nginx/user-guide/tls/>nginx</a>,
<a href=https://git.k8s.io/ingress-gce/README.md#frontend-https>GCE</a> 또는 기타
플랫폼의 특정 인그레스 컨트롤러에 대한 설명서를 참조한다.
</div>
<h3 id=load-balancing>로드 밸런싱</h3>
<p>인그레스 컨트롤러는 로드 밸런싱 알고리즘, 백엔드 가중치 구성표 등
모든 인그레스에 적용되는 일부 로드 밸런싱
정책 설정으로 부트스트랩된다. 보다 진보된 로드 밸런싱 개념
(예: 지속적인 세션, 동적 가중치)은 아직 인그레스를 통해
노출되지 않는다. 대신 서비스에 사용되는 로드 밸런서를 통해 이러한 기능을
얻을 수 있다.</p>
<p>또한, 헬스 체크를 인그레스를 통해 직접 노출되지 않더라도, 쿠버네티스에는
<a href=/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/>준비 상태 프로브</a>와
같은 동일한 최종 결과를 얻을 수 있는 병렬 개념이
있다는 점도 주목할 가치가 있다. 컨트롤러 별
설명서를 검토하여 헬스 체크를 처리하는 방법을 확인한다(예:
<a href=https://git.k8s.io/ingress-nginx/README.md>nginx</a>, 또는
<a href=https://git.k8s.io/ingress-gce/README.md#health-checks>GCE</a>).</p>
<h2 id=인그레스-업데이트>인그레스 업데이트</h2>
<p>기존 인그레스를 업데이트해서 새 호스트를 추가하려면, 리소스를 편집해서 호스트를 업데이트 할 수 있다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe ingress <span style=color:#a2f>test</span>
</code></pre></div><pre><code>Name:             test
Namespace:        default
Address:          178.91.123.132
Default backend:  default-http-backend:80 (10.8.2.3:8080)
Rules:
  Host         Path  Backends
  ----         ----  --------
  foo.bar.com
               /foo   service1:80 (10.8.0.90:80)
Annotations:
  nginx.ingress.kubernetes.io/rewrite-target:  /
Events:
  Type     Reason  Age                From                     Message
  ----     ------  ----               ----                     -------
  Normal   ADD     35s                loadbalancer-controller  default/test
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl edit ingress <span style=color:#a2f>test</span>
</code></pre></div><p>YAML 형식의 기존 구성이 있는 편집기가 나타난다.
새 호스트를 포함하도록 수정한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>host</span>:<span style=color:#bbb> </span>foo.bar.com<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>http</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>paths</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>backend</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>service</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>service1<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>number</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/foo<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>pathType</span>:<span style=color:#bbb> </span>Prefix<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>host</span>:<span style=color:#bbb> </span>bar.baz.com<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>http</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>paths</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>backend</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>service</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>service2<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>number</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/foo<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>pathType</span>:<span style=color:#bbb> </span>Prefix<span style=color:#bbb>
</span><span style=color:#bbb></span>..<span style=color:#bbb>
</span></code></pre></div><p>변경사항을 저장한 후, kubectl은 API 서버의 리소스를 업데이트하며, 인그레스
컨트롤러에게도 로드 밸런서를 재구성하도록 지시한다.</p>
<p>이것을 확인한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe ingress <span style=color:#a2f>test</span>
</code></pre></div><pre><code>Name:             test
Namespace:        default
Address:          178.91.123.132
Default backend:  default-http-backend:80 (10.8.2.3:8080)
Rules:
  Host         Path  Backends
  ----         ----  --------
  foo.bar.com
               /foo   service1:80 (10.8.0.90:80)
  bar.baz.com
               /foo   service2:80 (10.8.0.91:80)
Annotations:
  nginx.ingress.kubernetes.io/rewrite-target:  /
Events:
  Type     Reason  Age                From                     Message
  ----     ------  ----               ----                     -------
  Normal   ADD     45s                loadbalancer-controller  default/test
</code></pre><p>수정된 인그레스 YAML 파일을 <code>kubectl replace -f</code> 를 호출해서 동일한 결과를 얻을 수 있다.</p>
<h2 id=가용성-영역에-전체에서의-실패>가용성 영역에 전체에서의 실패</h2>
<p>장애 도메인에 트래픽을 분산시키는 기술은 클라우드 공급자마다 다르다.
자세한 내용은 <a href=/ko/docs/concepts/services-networking/ingress-controllers>인그레스 컨트롤러</a> 설명서를 확인한다.</p>
<h2 id=대안>대안</h2>
<p>사용자는 인그레스 리소스를 직접적으로 포함하지 않는 여러가지 방법으로 서비스를 노출할 수 있다.</p>
<ul>
<li><a href=/ko/docs/concepts/services-networking/service/#loadbalancer>Service.Type=LoadBalancer</a> 사용.</li>
<li><a href=/ko/docs/concepts/services-networking/service/#type-nodeport>Service.Type=NodePort</a> 사용.</li>
</ul>
<h2 id=다음-내용>다음 내용</h2>
<ul>
<li><a href=/docs/reference/kubernetes-api/service-resources/ingress-v1/>인그레스</a> API에 대해 배우기</li>
<li><a href=/ko/docs/concepts/services-networking/ingress-controllers/>인그레스 컨트롤러</a>에 대해 배우기</li>
<li><a href=/ko/docs/tasks/access-application-cluster/ingress-minikube/>NGINX 컨트롤러로 Minikube에서 인그레스 구성하기</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-cd7657b1056ad32451974db57a951ba5>5.7 - 서비스 내부 트래픽 정책</h1>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.23 [beta]</code>
</div>
<p><em>서비스 내부 트래픽 정책</em> 을 사용하면 내부 트래픽 제한이 트래픽이 시작된
노드 내의 엔드포인트로만 내부 트래픽을 라우팅하도록 한다.
여기서 "내부" 트래픽은 현재 클러스터의 파드로부터 시작된 트래픽을 지칭한다.
이를 통해 비용을 절감하고 성능을 개선할 수 있다.</p>
<h2 id=서비스-내부-트래픽-정책-사용>서비스 내부 트래픽 정책 사용</h2>
<p><code>ServiceInternalTrafficPolicy</code> <a href=/ko/docs/reference/command-line-tools-reference/feature-gates/>기능 게이트</a>는
베타 기능이며 기본적으로 활성화되어 있다.
이 기능이 활성화되어 있으면,
<a class=glossary-tooltip title="네트워크 서비스로 파드 집합에서 실행 중인 애플리케이션을 노출하는 방법" data-toggle=tooltip data-placement=top href=/ko/docs/concepts/services-networking/service/ target=_blank aria-label=서비스>서비스</a>의
<code>.spec.internalTrafficPolicy</code>를 <code>Local</code>로 설정하여 내부 전용 트래픽 정책을 활성화 할 수 있다.
이것은 kube-proxy가 클러스터 내부 트래픽을 위해 노드 내부 엔드포인트로만 사용하도록 한다.</p>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> 지정된 서비스에 대한 엔드포인트가 없는 노드의 파드인 경우에
서비스는 다른 노드에 엔드포인트가 있더라도 엔드포인트가 없는 것처럼 작동한다.
(이 노드의 파드에 대해서)
</div>
<p>다음 예제는 서비스의 <code>.spec.internalTrafficPolicy</code>를 <code>Local</code>로
설정하는 것을 보여 준다:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>MyApp<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>9376</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>internalTrafficPolicy</span>:<span style=color:#bbb> </span>Local<span style=color:#bbb>
</span></code></pre></div><h2 id=작동-방식>작동 방식</h2>
<p>kube-proxy는 <code>spec.internalTrafficPolicy</code> 의 설정에 따라서 라우팅되는
엔드포인트를 필터링한다.
이것을 <code>Local</code>로 설정하면, 노드 내부 엔드포인트만 고려한다.
이 설정이 <code>Cluster</code>이거나 누락되었다면 모든 엔드포인트를 고려한다.
<a href=/ko/docs/reference/command-line-tools-reference/feature-gates/>기능 게이트</a>의
<code>ServiceInternalTrafficPolicy</code>를 활성화한다면, <code>spec.internalTrafficPolicy</code>는 기본값 "Cluster"로 설정된다.</p>
<h2 id=제약조건>제약조건</h2>
<ul>
<li>같은 서비스에서 <code>externalTrafficPolicy</code> 가 <code>Local</code>로 설정된 경우
서비스 내부 트래픽 정책이 사용되지 않는다.
클러스터에서 동일하지 않은 다른 서비스에서 이 두 가지 기능은 동시에 사용할 수 있다.</li>
</ul>
<h2 id=다음-내용>다음 내용</h2>
<ul>
<li><a href=/docs/concepts/services-networking/topology-aware-hints/>토폴로지 인식 힌트</a>에 대해서 읽기</li>
<li><a href=/docs/tasks/access-application-cluster/create-external-load-balancer/#preserving-the-client-source-ip>서비스 외부 트래픽 정책</a>에 대해서 읽기</li>
<li><a href=/ko/docs/concepts/services-networking/connect-applications-service/>서비스와 애플리케이션 연결하기</a> 읽기</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-f51db1097575de8072afe1f5b156a70c>5.8 - 엔드포인트슬라이스</h1>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.21 [stable]</code>
</div>
<p><em>엔드포인트슬라이스</em> 는 쿠버네티스 클러스터 내의 네트워크 엔드포인트를
추적하는 간단한 방법을 제공한다. 이것은 엔드포인트를 더 확장하고, 확장 가능한
대안을 제안한다.</p>
<h2 id=사용동기>사용동기</h2>
<p>엔드포인트 API는 쿠버네티스에서 네트워크 엔드포인트를 추적하는
간단하고 직접적인 방법을 제공한다. 불행하게도 쿠버네티스 클러스터와
<a class=glossary-tooltip title="네트워크 서비스로 파드 집합에서 실행 중인 애플리케이션을 노출하는 방법" data-toggle=tooltip data-placement=top href=/ko/docs/concepts/services-networking/service/ target=_blank aria-label=서비스>서비스</a>가 더 많은 수의 백엔드 파드로
더 많은 트래픽을 처리하고 전송하는 방향으로 성장함에 따라, 이 API의 한계가 더욱 눈에 띄게
되었다.
특히나, 많은 수의 네트워크 엔드포인트로 확장하는 것에
어려움이 있었다.</p>
<p>이후로 서비스에 대한 모든 네트워크 엔드포인트가 단일 엔드포인트
리소스에 저장되기 때문에 엔드포인트 리소스가 상당히 커질 수 있다. 이것은 쿠버네티스
구성요소 (특히 마스터 컨트롤 플레인)의 성능에 영향을 미쳤고
엔드포인트가 변경될 때 상당한 양의 네트워크 트래픽과 처리를 초래했다.
엔드포인트슬라이스는 이러한 문제를 완화하고 토폴로지 라우팅과
같은 추가 기능을 위한 확장 가능한 플랫폼을 제공한다.</p>
<h2 id=endpointslice-resource>엔드포인트슬라이스 리소스</h2>
<p>쿠버네티스에서 엔드포인트슬라이스는 일련의 네트워크 엔드포인트에 대한
참조를 포함한다. 쿠버네티스 서비스에 <a class=glossary-tooltip title="사용자가 레이블에 따라서 리소스 리스트를 필터할 수 있게 한다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/overview/working-with-objects/labels/ target=_blank aria-label=셀렉터>셀렉터</a>가 지정되면 컨트롤 플레인은 자동으로
엔드포인트슬라이스를 생성한다. 이 엔드포인트슬라이스는
서비스 셀렉터와 매치되는 모든 파드들을 포함하고 참조한다. 엔드포인트슬라이스는
프로토콜, 포트 번호 및 서비스 이름의 고유한 조합을 통해 네트워크 엔드포인트를
그룹화한다.
엔드포인트슬라이스 오브젝트의 이름은 유효한
<a href=/ko/docs/concepts/overview/working-with-objects/names/#dns-%EC%84%9C%EB%B8%8C%EB%8F%84%EB%A9%94%EC%9D%B8-%EC%9D%B4%EB%A6%84>DNS 서브도메인 이름</a>이어야 한다.</p>
<p>예를 들어, 여기에 <code>example</code> 쿠버네티스 서비스를 위한 엔드포인트슬라이스
리소스 샘플이 있다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>discovery.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>EndpointSlice<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>example-abc<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubernetes.io/service-name</span>:<span style=color:#bbb> </span>example<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>addressType</span>:<span style=color:#bbb> </span>IPv4<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>http<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>endpoints</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>addresses</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:#b44>&#34;10.1.2.3&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>conditions</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>ready</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>hostname</span>:<span style=color:#bbb> </span>pod-1<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>nodeName</span>:<span style=color:#bbb> </span>node-1<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>zone</span>:<span style=color:#bbb> </span>us-west2-a<span style=color:#bbb>
</span></code></pre></div><p>기본적으로, 컨트롤 플레인은 각각 100개 이하의 엔드포인트를
갖도록 엔드포인트슬라이스를
생성하고 관리한다. <code>--max-endpoints-per-slice</code>
<a class=glossary-tooltip title="컨트롤러 프로세스를 실행하는 컨트롤 플레인 컴포넌트." data-toggle=tooltip data-placement=top href=/docs/reference/command-line-tools-reference/kube-controller-manager/ target=_blank aria-label=kube-controller-manager>kube-controller-manager</a>
플래그를 사용하여, 최대 1000개까지 구성할 수 있다.</p>
<p>엔드포인트슬라이스는 내부 트래픽을 라우트하는 방법에 대해
<a class=glossary-tooltip title="kube-proxy는 클러스터의 각 노드에서 실행되는 네트워크 프록시이다." data-toggle=tooltip data-placement=top href=/ko/docs/reference/command-line-tools-reference/kube-proxy/ target=_blank aria-label=kube-proxy>kube-proxy</a>에
신뢰할 수 있는 소스로 역할을 할 수 있다. 이를 활성화 하면, 많은 수의 엔드포인트를 가지는
서비스에 대해 성능 향상을 제공해야 한다.</p>
<h3 id=주소-유형>주소 유형</h3>
<p>엔드포인트슬라이스는 다음 주소 유형을 지원한다.</p>
<ul>
<li>IPv4</li>
<li>IPv6</li>
<li>FQDN (전체 주소 도메인 이름)</li>
</ul>
<h3 id=조건>조건</h3>
<p>엔드포인트슬라이스 API는 컨슈머에게 유용한 엔드포인트에 대한 조건을 저장한다.
조건은 <code>준비</code>, <code>제공</code> 및 <code>종료</code> 세 가지가 있다.</p>
<h4 id=준비>준비</h4>
<p><code>ready</code>는 파드의 <code>Ready</code> 조건에 매핑되는 조건이다. <code>Ready</code> 조건이 <code>True</code>로 설정된 실행 중인 파드는
이 엔드포인트슬라이스 조건도 <code>true</code>로 설정되어야 한다. 호환성의
이유로, 파드가 종료될 때 <code>ready</code>는 절대 <code>true</code>가 되면 안 된다. 컨슈머는 <code>serving</code> 조건을 참조하여
파드 종료 준비 상태(readiness)를 검사해야 한다.
이 규칙의 유일한 예외는 <code>spec.publishNotReadyAddresses</code>가 <code>true</code>로 설정된 서비스이다.
이러한 서비스의 엔드 포인트는 항상 <code>ready</code>조건이 <code>true</code>로 설정된다.</p>
<h4 id=제공-serving>제공(Serving)</h4>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.20 [alpha]</code>
</div>
<p><code>serving</code>은 종료 상태를 고려하지 않는다는 점을 제외하면 <code>ready</code> 조건과 동일하다.
엔드포인트슬라이스 API 컨슈머는 파드가 종료되는 동안 파드 준비 상태에 관심이 있다면
이 조건을 확인해야 한다.</p>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> <code>serving</code>은 <code>ready</code>와 거의 동일하지만 <code>ready</code>의 기존 의미가 깨지는 것을 방지하기 위해 추가되었다.
엔드포인트를 종료하기 위해 <code>ready</code>가 <code>true</code> 일 수 있다면 기존 클라이언트에게는 예상치 못한 일이 될 수 있다.
역사적으로 종료된 엔드포인트는 처음부터 엔드포인트 또는 엔드포인트슬라이스 API에 포함되지 않았기 때문이다.
이러한 이유로 <code>ready</code>는 엔드포인트 종료를 위해 <em>always</em> <code>false</code>이며,
클라이언트가 <code>ready</code>에 대한 기존 의미와 관계없이 파드 종료 준비 상태를
추적 할 수 있도록 v1.20에 새로운 조건 <code>serving</code>이 추가되었다.
</div>
<h4 id=종료-terminating>종료(Terminating)</h4>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.20 [alpha]</code>
</div>
<p><code>종료(Terminating)</code>는 엔드포인트가 종료되는지 여부를 나타내는 조건이다.
파드의 경우 삭제 타임 스탬프가 설정된 모든 파드이다.</p>
<h3 id=토폴로지>토폴로지 정보</h3>
<p>엔드포인트슬라이스 내의 각 엔드 포인트는 관련 토폴로지 정보를 포함할 수 있다.
토폴로지 정보에는 엔드 포인트의 위치와 해당 노드 및
영역에 대한 정보가 포함된다. 엔드포인트슬라이스의 다음의 엔드 포인트별
필드에서 사용할 수 있다.</p>
<p>*<code>nodeName</code> - 이 엔드 포인트가 있는 노드의 이름이다.
*<code>zone</code> - 이 엔드 포인트가 있는 영역이다.</p>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> <p>v1 API에서는, 전용 필드 <code>nodeName</code> 및 <code>zone</code> 을 위해 엔드 포인트별
<code>topology</code> 가 효과적으로 제거되었다.</p>
<p><code>EndpointSlice</code> 리소스의 <code>endpoint</code> 필드에 임의의 토폴로지 필드를
설정하는 것은 더 이상 사용되지 않으며, v1 API에서 지원되지 않는다. 대신,
v1 API는 개별 <code>nodeName</code> 및 <code>zone</code> 필드 설정을 지원한다. 이러한
필드는 API 버전 간에 자동으로 번역된다. 예를 들어,
v1beta1 API의 <code>topology</code> 필드에 있는 <code>"topology.kubernetes.io/zone"</code>
키 값은 v1 API의 <code>zone</code> 필드로 접근할 수 있다.</p>
</div>
<h3 id=관리>관리</h3>
<p>대부분의 경우, 컨트롤 플레인(특히, 엔드포인트슬라이스
<a class=glossary-tooltip title="API 서버를 통해 클러스터의 공유된 상태를 감시하고, 현재 상태를 원하는 상태로 이행시키는 컨트롤 루프." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/architecture/controller/ target=_blank aria-label=컨트롤러>컨트롤러</a>)는
엔드포인트슬라이스 오브젝트를 생성하고 관리한다. 다른 엔티티나 컨트롤러가 추가
엔드포인트슬라이스 집합을 관리하게 할 수 있는 서비스 메시 구현과 같이
엔드포인트슬라이스에 대한 다양한 다른 유스케이스가 있다.</p>
<p>여러 엔티티가 서로 간섭하지 않고 엔드포인트슬라이스를
관리할 수 있도록 쿠버네티스는 엔드포인트슬라이스를 관리하는
엔티티를 나타내는 <code>endpointslice.kubernetes.io/managed-by</code>
<a class=glossary-tooltip title="사용자에게 의미 있고 관련성 높은 특징으로 식별할 수 있도록 오브젝트에 태그를 붙인다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/overview/working-with-objects/labels target=_blank aria-label=레이블>레이블</a>을
정의한다.
엔드포인트슬라이스 컨트롤러는 관리하는 모든 엔드포인트슬라이스에 레이블의 값으로
<code>endpointslice-controller.k8s.io</code> 를 설정한다. 엔드포인트슬라이스를
관리하는 다른 엔티티도 이 레이블에 고유한 값을 설정해야 한다.</p>
<h3 id=소유권>소유권</h3>
<p>대부분의 유스케이스에서, 엔드포인트슬라이스 오브젝트가 엔드포인트를
추적하는 서비스가 엔드포인트슬라이스를 소유한다. 이 소유권은 각 엔드포인트슬라이스의 소유자
참조와 서비스에 속한 모든 엔드포인트슬라이스의 간단한 조회를 가능하게 하는
<code>kubernetes.io/service-name</code> 레이블로 표시된다.</p>
<h3 id=엔드포인트슬라이스-미러링>엔드포인트슬라이스 미러링</h3>
<p>경우에 따라, 애플리케이션이 사용자 지정 엔드포인트 리소스를 생성한다. 이러한
애플리케이션이 엔드포인트와 엔드포인트슬라이스 리소스에 동시에 쓸 필요가 없도록
클러스터의 컨트롤 플레인은 대부분의 엔드포인트 리소스를
해당 엔드포인트슬라이스에 미러링한다.</p>
<p>컨트롤 플레인은 다음을 제외하고 엔드포인트 리소스를 미러링한다.</p>
<ul>
<li>엔드포인트 리소스에는 <code>endpointslice.kubernetes.io/skip-mirror</code> 레이블이
<code>true</code> 로 설정되어 있다.</li>
<li>엔드포인트 리소스에는 <code>control-plane.alpha.kubernetes.io/leader</code>
어노테이션이 있다.</li>
<li>해당 서비스 리소스가 존재하지 않는다.</li>
<li>해당 서비스 리소스에 nil이 아닌 셀렉터가 있다.</li>
</ul>
<p>개별 엔드포인트 리소스는 여러 엔드포인트슬라이스로 변환될 수 있다.
엔드포인트 리소스에 여러 하위 집합이 있거나 여러 IP 제품군(IPv4 및 IPv6)이 있는
엔드포인트가 포함된 경우 변환이 일어난다. 하위 집합 당 최대 1000개의 주소가
엔드포인트슬라이스에 미러링된다.</p>
<h3 id=엔드포인트슬라이스의-배포>엔드포인트슬라이스의 배포</h3>
<p>각 엔드포인트슬라이스에는 리소스 내에 모든 엔드포인트가 적용되는
포트 집합이 있다. 서비스에 알려진 포트를 사용하는 경우 파드는
동일하게 알려진 포트에 대해 다른 대상 포트 번호로 끝날 수 있으며 다른
엔드포인트슬라이스가 필요하다. 이는 하위 집합이 엔드포인트와 그룹화하는
방식의 논리와 유사하다.</p>
<p>컨트롤 플레인은 엔드포인트슬라이스를 최대한 채우려고 노력하지만,
적극적으로 재조정하지는 않는다. 로직은 매우 직관적이다.</p>
<ol>
<li>기존 엔드포인트슬라이스에 대해 반복적으로, 더 이상 필요하지 않는 엔드포인트를
제거하고 변경에 의해 일치하는 엔드포인트를 업데이트 한다.</li>
<li>첫 번째 단계에서 수정된 엔드포인트슬라이스를 반복해서
필요한 새 엔드포인트로 채운다.</li>
<li>추가할 새 엔드포인트가 여전히 남아있으면, 이전에 변경되지 않은
슬라이스에 엔드포인트를 맞추거나 새로운 것을 생성한다.</li>
</ol>
<p>중요한 것은, 세 번째 단계는 엔드포인트슬라이스를 완벽하게 전부 배포하는 것보다
엔드포인트슬라이스 업데이트 제한을 우선시한다. 예를 들어, 추가할 새 엔드포인트가
10개이고 각각 5개의 공간을 사용할 수 있는 엔드포인트 공간이 있는 2개의
엔드포인트슬라이스가 있는 경우, 이 방법은 기존 엔드포인트슬라이스
2개를 채우는 대신에 새 엔드포인트슬라이스를 생성한다. 다른 말로, 단일
엔드포인트슬라이스를 생성하는 것이 여러 엔드포인트슬라이스를 업데이트하는 것 보다 더 선호된다.</p>
<p>각 노드에서 kube-proxy를 실행하고 엔드포인트슬라이스를 관찰하면,
엔드포인트슬라이스에 대한 모든 변경 사항이 클러스터의 모든 노드로 전송되기
때문에 상대적으로 비용이 많이 소요된다. 이 방법은 여러 엔드포인트슬라이스가
가득 차지 않은 결과가 발생할지라도, 모든 노드에 전송해야 하는
변경 횟수를 의도적으로 제한하기 위한 것이다.</p>
<p>실제로는, 이러한 이상적이지 않은 분배는 드물 것이다. 엔드포인트슬라이스
컨트롤러에서 처리하는 대부분의 변경 내용은 기존 엔드포인트슬라이스에
적합할 정도로 적고, 그렇지 않은 경우 새 엔드포인트슬라이스가
필요할 수 있다. 디플로이먼트의 롤링 업데이트도 모든 파드와 해당
교체되는 엔드포인트에 대해서 엔드포인트슬라이스를
자연스럽게 재포장한다.</p>
<h3 id=중복-엔드포인트>중복 엔드포인트</h3>
<p>엔드포인트슬라이스 변경의 특성으로 인해, 엔드포인트는 동시에 둘 이상의
엔드포인트슬라이스에 표시될 수 있다. 이는 다른 엔드포인트슬라이스 오브젝트에
대한 변경 사항이 다른 시간에서의 쿠버네티스 클라이언트 워치(watch)/캐시에
도착할 수 있기 때문에 자연스럽게 발생한다. 엔드포인트슬라이스를 사용하는 구현은
엔드포인트가 둘 이상의 슬라이스에 표시되도록 할 수 있어야 한다. 엔드포인트
중복 제거를 수행하는 방법에 대한 레퍼런스 구현은 <code>kube-proxy</code> 의
<code>EndpointSliceCache</code> 구현에서 찾을 수 있다.</p>
<h2 id=다음-내용>다음 내용</h2>
<ul>
<li><a href=/ko/docs/concepts/services-networking/connect-applications-service/>서비스와 애플리케이션 연결하기</a>를 읽어보기</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-374e5c954990aec58a0797adc70a5039>5.9 - 토폴로지 인지 힌트</h1>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.23 [beta]</code>
</div>
<p><em>토폴로지 인지 힌트(Topology Aware Hints)</em> 는 클라이언트가 엔드포인트를 어떻게 사용해야 하는지에 대한 제안을 포함시킴으로써
토폴로지 인지 라우팅을 가능하게 한다.
이러한 접근은 엔드포인트슬라이스(EndpointSlice) 및 엔드포인트(Endpoint) 오브젝트의 소비자(consumer)가 이용할 수 있는 메타데이터를 추가하며,
이를 통해 해당 네트워크 엔드포인트로의 트래픽이 근원지에 더 가깝게 라우트될 수 있다.</p>
<p>예를 들어, 비용을 줄이거나 네트워크 성능을 높이기 위해,
인접성을 고려하여 트래픽을 라우트할 수 있다.</p>
<h2 id=동기-motivation>동기(motivation)</h2>
<p>쿠버네티스 클러스터가 멀티-존(multi-zone) 환경에 배포되는 일이 점점 많아지고 있다.
<em>토폴로지 인지 힌트</em> 는 트래픽이 발생한 존 내에서 트래픽을 유지하도록 처리하는 메커니즘을 제공한다.
이러한 개념은 보통 "토폴로지 인지 라우팅"이라고 부른다.
<a class=glossary-tooltip title="네트워크 서비스로 파드 집합에서 실행 중인 애플리케이션을 노출하는 방법" data-toggle=tooltip data-placement=top href=/ko/docs/concepts/services-networking/service/ target=_blank aria-label=서비스>서비스</a>의 엔드포인트를 계산할 때,
엔드포인트슬라이스 컨트롤러는 각 엔드포인트의 토폴로지(지역(region) 및 존)를 고려하여,
엔드포인트가 특정 존에 할당되도록 힌트 필드를 채운다.
그러면 <a class=glossary-tooltip title="kube-proxy는 클러스터의 각 노드에서 실행되는 네트워크 프록시이다." data-toggle=tooltip data-placement=top href=/ko/docs/reference/command-line-tools-reference/kube-proxy/ target=_blank aria-label=kube-proxy>kube-proxy</a>와 같은
클러스터 구성 요소는 해당 힌트를 인식하고,
(토폴로지 상 가까운 엔드포인트를 사용하도록) 트래픽 라우팅 구성에 활용한다.</p>
<h2 id=토폴로지-인지-힌트-사용하기>토폴로지 인지 힌트 사용하기</h2>
<p><code>service.kubernetes.io/topology-aware-hints</code> 어노테이션을 <code>auto</code>로 설정하여
서비스에 대한 토폴로지 인지 힌트를 활성화할 수 있다.
이는 엔드포인트슬라이스 컨트롤러가 안전하다고 판단되는 경우 토폴로지 힌트를 설정하도록 지시하는 것이다.
명심할 점은, 이를 수행한다고 해서 힌트가 항상 설정되는 것은 아니라는 것이다.</p>
<h2 id=implementation>동작 방법</h2>
<p>이 기능을 동작시키는 요소는
엔드포인트슬라이스 컨트롤러와 kube-proxy 두 구성요소로 나눠져 있다.
이 섹션에서는 각 구성요소가 어떻게 이 기능을 동작시키는지에 대한 고차원 개요를 제공한다.</p>
<h3 id=implementation-control-plane>엔드포인트슬라이스 컨트롤러</h3>
<p>엔드포인트슬라이스 컨트롤러는 이 기능이 활성화되어 있을 때
엔드포인트슬라이스에 힌트를 설정하는 일을 담당한다.
컨트롤러는 각 존에 일정 비율의 엔드포인트를 할당한다.
이 비율은 해당 존에 있는 노드의
<a href=/docs/tasks/administer-cluster/reserve-compute-resources/#node-allocatable>할당 가능한(allocatable)</a> CPU 코어에 의해 결정된다.
예를 들어, 한 존에 2 CPU 코어가 있고 다른 존에 1 CPU 코어만 있는 경우,
컨트롤러는 2 CPU 코어가 있는 존에 엔드포인트를 2배 할당할 것이다.</p>
<p>다음 예시는 엔드포인트슬라이스에 힌트가 채워졌을 때에 대한
예시이다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>discovery.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>EndpointSlice<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>example-hints<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubernetes.io/service-name</span>:<span style=color:#bbb> </span>example-svc<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>addressType</span>:<span style=color:#bbb> </span>IPv4<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>http<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>endpoints</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>addresses</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:#b44>&#34;10.1.2.3&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>conditions</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>ready</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>hostname</span>:<span style=color:#bbb> </span>pod-1<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>zone</span>:<span style=color:#bbb> </span>zone-a<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>hints</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>forZones</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;zone-a&#34;</span><span style=color:#bbb>
</span></code></pre></div><h3 id=implementation-kube-proxy>kube-proxy</h3>
<p>kube-proxy 구성요소는 엔드포인트슬라이스 컨트롤러가 설정한 힌트를 기반으로
자신이 라우팅하는 엔드포인트를 필터링한다.
대부분의 경우, 이는 kube-proxy가 동일 존 내에서 트래픽을 엔드포인트로 라우팅할 수 있음을 뜻한다.
때때로 컨트롤러는 존 사이에 보다 균등한 엔드포인트 분배를 위해 다른 존으로부터 엔드포인트를 할당하기도 한다.
이러한 경우 일부 트래픽은 다른 존으로 라우팅될 것이다.</p>
<h2 id=보호-규칙>보호 규칙</h2>
<p>쿠버네티스 컨트롤 플레인과 각 노드의 kube-proxy는
토폴로지 인지 힌트를 사용하기 전에 몇 가지 보호 규칙을 적용한다.
이들이 만족되지 않으면, kube-proxy는 존에 상관없이
클러스터의 모든 곳으로부터 엔드포인트를 선택한다.</p>
<ol>
<li>
<p><strong>엔드포인트 수가 충분하지 않음:</strong> 존의 숫자보다 엔드포인트의 숫자가 적으면,
컨트롤러는 어떤 힌트도 할당하지 않을 것이다.</p>
</li>
<li>
<p><strong>균형잡힌 할당이 불가능함:</strong> 일부 경우에, 존 간 균형잡힌 엔드포인트 할당이 불가능할 수 있다.
예를 들어, zone-a가 zone-b보다 2배 큰 상황에서,
엔드포인트가 2개 뿐이라면,
zone-a에 할당된 엔드포인트는 zone-b에 할당된 엔드포인트보다 2배의 트래픽을 수신할 것이다.
컨트롤러는 이 "예상 과부하" 값을 각 존에 대해
허용 가능한 임계값보다 작게 낮출 수 없는 경우에는 힌트를 할당하지 않는다.
명심할 점은, 이것이 실시간 피드백 기반이 아니라는 것이다.
개별 엔드포인트가 과부하 상태로 바뀔 가능성도 여전히 있다.</p>
</li>
<li>
<p><strong>하나 이상의 노드에 대한 정보가 불충분함:</strong> <code>topology.kubernetes.io/zone</code> 레이블이 없는 노드가 있거나
할당 가능한 CPU 값을 보고하지 않는 노드가 있으면,
컨트롤 플레인은 토폴로지 인지 엔드포인트를 설정하지 않으며
이로 인해 kube-proxy는 존 별로 엔드포인트를 필터링하지 않는다.</p>
</li>
<li>
<p><strong>하나 이상의 엔드포인트에 존 힌트가 없음:</strong> 이러한 상황이 발생하면,
kube-proxy는 토폴로지 인지 힌트로부터의 또는 토폴로지 인지 힌트로의 전환이 진행 중이라고 가정한다.
이 상태에서 서비스의 엔드포인트를 필터링하는 것은 위험할 수 있으므로
kube-proxy는 모든 엔드포인트를 사용하는 모드로 전환된다.</p>
</li>
<li>
<p><strong>힌트에 존이 기재되지 않음:</strong> kube-proxy가 실행되고 있는 존을 향하는 힌트를 갖는 엔드포인트를
하나도 찾지 못했다면,
모든 존에서 오는 엔드포인트를 사용하는 모드로 전환된다.
이러한 경우는 기존에 있던 클러스터에 새로운 존을 추가하는 경우에 발생할 가능성이 가장 높다.</p>
</li>
</ol>
<h2 id=제약사항>제약사항</h2>
<ul>
<li>
<p>토폴로지 인지 힌트는 서비스의 <code>externalTrafficPolicy</code> 또는
<code>internalTrafficPolicy</code>가 <code>Local</code>로 설정된 경우에는 사용되지 않는다.
동일 클러스터의 서로 다른 서비스들에 대해 두 기능 중 하나를 사용하는 것은 가능하며,
하나의 서비스에 두 기능 모두를 사용하는 것은 불가능하다.</p>
</li>
<li>
<p>이러한 접근 방법은 존의 일부분에서
많은 트래픽이 발생하는 서비스에는 잘 작동하지 않을 것이다.
대신, 들어오는 트래픽이
각 존 내 노드 용량에 대략 비례한다고 가정한다.</p>
</li>
<li>
<p>엔드포인트슬라이스 컨트롤러는 각 존 내의 비율을 계산할 때
준비되지 않은(unready) 노드는 무시한다.
이 때문에 많은 노드가 준비되지 않은 상태에서는 의도하지 않은 결과가 나타날 수도 있다.</p>
</li>
<li>
<p>엔드포인트슬라이스 컨트롤러는 각 존 내의 비율을 계산할 때
<a class=glossary-tooltip title="세 가지 필수 속성: 키(key), 값(value), 효과(effect)로 구성된 코어 오브젝트. 톨러레이션은 매칭되는 테인트(taint)를 가진 노드나 노드 그룹에 파드가 스케줄링되는 것을 활성화한다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/scheduling-eviction/taint-and-toleration/ target=_blank aria-label=톨러레이션>톨러레이션</a>은 고려하지 않는다.
서비스를 구성하는 파드가 클러스터의 일부 노드에만 배치되어 있는 경우,
이러한 상황은 고려되지 않을 것이다.</p>
</li>
<li>
<p>오토스케일링 기능과는 잘 동작하지 않을 수 있다.
예를 들어, 하나의 존에서 많은 트래픽이 발생하는 경우,
해당 존에 할당된 엔드포인트만 트래픽을 처리하고 있을 것이다.
이로 인해 <a class=glossary-tooltip title="An API resource that automatically scales the number of pod replicas based on targeted CPU utilization or custom metric targets." data-toggle=tooltip data-placement=top href=/docs/tasks/run-application/horizontal-pod-autoscale/ target=_blank aria-label="Horizontal Pod Autoscaler">Horizontal Pod Autoscaler</a>가
이 이벤트를 감지하지 못하거나,
또는 새롭게 추가되는 파드가 다른 존에 추가될 수 있다.</p>
</li>
</ul>
<h2 id=다음-내용>다음 내용</h2>
<ul>
<li><a href=/ko/docs/concepts/services-networking/connect-applications-service/>서비스와 애플리케이션 연결하기</a>를 읽어본다.</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-ded1daafdcd293023ee333728007ca61>5.10 - 네트워크 정책</h1>
<p>IP 주소 또는 포트 수준(OSI 계층 3 또는 4)에서 트래픽 흐름을 제어하려는 경우, 클러스터의 특정 애플리케이션에 대해 쿠버네티스 네트워크폴리시(NetworkPolicy) 사용을 고려할 수 있다. 네트워크폴리시는 <a class=glossary-tooltip title="파드는 클러스터에서 실행 중인 컨테이너의 집합을 나타낸다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/pods/ target=_blank aria-label=파드>파드</a>가 네트워크 상의 다양한 네트워크 "엔티티"(여기서는 "엔티티"를 사용하여 쿠버네티스에서 특별한 의미로 사용되는 "엔드포인트" 및 "서비스"와 같은 일반적인 용어가 중의적으로 표현되는 것을 방지함)와 통신할 수 있도록 허용하는 방법을 지정할 수 있는 애플리케이션 중심 구조이다. 네트워크폴리시는 한쪽 또는 양쪽 종단이 파드인 연결에만 적용되며, 다른 연결에는 관여하지 않는다.</p>
<p>파드가 통신할 수 있는 엔티티는 다음 3개의 식별자 조합을 통해 식별된다.</p>
<ol>
<li>허용되는 다른 파드(예외: 파드는 자신에 대한 접근을 차단할 수 없음)</li>
<li>허용되는 네임스페이스</li>
<li>IP 블록(예외: 파드 또는 노드의 IP 주소와 관계없이 파드가 실행 중인 노드와의 트래픽은 항상 허용됨)</li>
</ol>
<p>pod- 또는 namespace- 기반의 네트워크폴리시를 정의할 때, <a class=glossary-tooltip title="사용자가 레이블에 따라서 리소스 리스트를 필터할 수 있게 한다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/overview/working-with-objects/labels/ target=_blank aria-label=셀렉터>셀렉터</a>를 사용하여 셀렉터와 일치하는 파드와 주고받는 트래픽을 지정한다.</p>
<p>한편, IP 기반의 네트워크폴리시가 생성되면, IP 블록(CIDR 범위)을 기반으로 정책을 정의한다.</p>
<h2 id=전제-조건>전제 조건</h2>
<p>네트워크 정책은 <a href=/ko/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/>네트워크 플러그인</a>으로 구현된다. 네트워크 정책을 사용하려면 네트워크폴리시를 지원하는 네트워킹 솔루션을 사용해야만 한다. 이를 구현하는 컨트롤러 없이 네트워크폴리시 리소스를 생성해도 아무런 효과가 없기 때문이다.</p>
<h2 id=파드-격리의-두-가지-종류>파드 격리의 두 가지 종류</h2>
<p>파드 격리에는 이그레스에 대한 격리와 인그레스에 대한 격리의 두 가지 종류가 있다. 이들은 어떤 연결이 성립될지에 대해 관여한다. 여기서 "격리"는 절대적인 것이 아니라, "일부 제한이 적용됨"을 의미한다. 반대말인 "이그레스/인그레스에 대한 비격리"는 각 방향에 대해 제한이 적용되지 않음을 의미한다. 두 종류의 격리(또는 비격리)는 독립적으로 선언되며, 두 종류 모두 파드 간 연결과 연관된다.</p>
<p>기본적으로, 파드는 이그레스에 대해 비격리되어 있다. 즉, 모든 아웃바운드 연결이 허용된다. 해당 파드에 적용되면서 <code>policyTypes</code>에 "Egress"가 있는 NetworkPolicy가 존재하는 경우, 파드가 이그레스에 대해 격리된다. 이러한 정책은 파드의 이그레스에 적용된다고 말한다. 파드가 이그레스에 대해 격리되면, 파드에서 나가는 연결 중에서 파드의 이그레스에 적용된 NetworkPolicy의 <code>egress</code> 리스트에 허용된 연결만이 허용된다. <code>egress</code> 리스트 각 항목의 효과는 합산되어 적용된다.</p>
<p>기본적으로, 파드는 인그레스에 대해 비격리되어 있다. 즉, 모든 인바운드 연결이 허용된다. 해당 파드에 적용되면서 <code>policyTypes</code>에 "Ingress"가 있는 NetworkPolicy가 존재하는 경우, 파드가 인그레스에 대해 격리된다. 이러한 정책은 파드의 인그레스에 적용된다고 말한다. 파드가 인그레스에 대해 격리되면, 파드로 들어오는 연결 중에서 파드의 인그레스에 적용된 NetworkPolicy의 <code>ingress</code> 리스트에 허용된 연결만이 허용된다. <code>ingress</code> 리스트 각 항목의 효과는 합산되어 적용된다.</p>
<p>네트워크 폴리시가 충돌하는 경우는 없다. 네트워크 폴리시는 합산되어 적용된다. 특정 파드의 특정 방향에 대해 하나 또는 여러 개의 폴리시가 적용되면, 해당 파드의 해당 방향에 대해 허용된 연결은 모든 폴리시가 허용하는 연결의 합집합이다. 따라서, 판별 순서는 폴리시 결과에 영향을 미치지 않는다.</p>
<p>송신 파드에서 수신 파드로의 연결이 허용되기 위해서는, 송신 파드의 이그레스 폴리시와 수신 파드의 인그레스 폴리시가 해당 연결을 허용해야 한다. 만약 어느 한 쪽이라도 해당 연결을 허용하지 않으면, 연결이 되지 않을 것이다.</p>
<h2 id=networkpolicy-resource>네트워크폴리시 리소스</h2>
<p>리소스에 대한 전체 정의에 대한 참조는 <a href=/docs/reference/generated/kubernetes-api/v1.23/#networkpolicy-v1-networking-k8s-io>네트워크폴리시</a> 를 본다.</p>
<p>네트워크폴리시 의 예시는 다음과 같다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>networking.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>NetworkPolicy<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-network-policy<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>podSelector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>role</span>:<span style=color:#bbb> </span>db<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>policyTypes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- Ingress<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- Egress<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ingress</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>from</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>ipBlock</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cidr</span>:<span style=color:#bbb> </span><span style=color:#666>172.17.0.0</span>/16<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>except</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:#666>172.17.1.0</span>/24<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>namespaceSelector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>project</span>:<span style=color:#bbb> </span>myproject<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>podSelector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>role</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>6379</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>egress</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>to</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>ipBlock</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cidr</span>:<span style=color:#bbb> </span><span style=color:#666>10.0.0.0</span>/24<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>5978</span><span style=color:#bbb>
</span></code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> 선택한 네트워킹 솔루션이 네트워킹 정책을 지원하지 않으면 클러스터의 API 서버에 이를 POST 하더라도 효과가 없다.
</div>
<p><strong>필수 필드들</strong>: 다른 모든 쿠버네티스 설정과 마찬가지로 네트워크폴리시 에는
<code>apiVersion</code>, <code>kind</code>, 그리고 <code>metadata</code> 필드가 필요하다. 구성 파일
작업에 대한 일반적인 정보는
<a href=/docs/tasks/configure-pod-container/configure-pod-configmap/>컨피그 맵을 사용해서 컨테이너 구성하기</a>,
그리고 <a href=/ko/docs/concepts/overview/working-with-objects/object-management>오브젝트 관리</a> 를 본다.</p>
<p><strong>spec</strong>: 네트워크폴리시 <a href=https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#spec-and-status>사양</a>에는 지정된 네임스페이스에서 특정 네트워크 정책을 정의하는데 필요한 모든 정보가 있다.</p>
<p><strong>podSelector</strong>: 각 네트워크폴리시에는 정책이 적용되는 파드 그룹을 선택하는 <code>podSelector</code> 가 포함된다. 예시 정책은 "role=db" 레이블이 있는 파드를 선택한다. 비어있는 <code>podSelector</code> 는 네임스페이스의 모든 파드를 선택한다.</p>
<p><strong>policyTypes</strong>: 각 네트워크폴리시에는 <code>Ingress</code>, <code>Egress</code> 또는 두 가지 모두를 포함할 수 있는 <code>policyTypes</code> 목록이 포함된다. <code>policyTypes</code> 필드는 선택한 파드에 대한 인그레스 트래픽 정책, 선택한 파드에 대한 이그레스 트래픽 정책 또는 두 가지 모두에 지정된 정책의 적용 여부를 나타낸다. 만약 네트워크폴리시에 <code>policyTypes</code> 가 지정되어 있지 않으면 기본적으로 <code>Ingress</code> 가 항상 설정되고, 네트워크폴리시에 <code>Egress</code> 가 있으면 이그레스 규칙이 설정된다.</p>
<p><strong>ingress</strong>: 각 네트워크폴리시에는 화이트리스트 <code>ingress</code> 규칙 목록이 포함될 수 있다. 각 규칙은 <code>from</code> 과 <code>ports</code> 부분과 모두 일치하는 트래픽을 허용한다. 예시 정책에는 단일 규칙이 포함되어 있는데 첫 번째 포트는 <code>ipBlock</code> 을 통해 지정되고, 두 번째는 <code>namespaceSelector</code> 를 통해 그리고 세 번째는 <code>podSelector</code> 를 통해 세 가지 소스 중 하나의 단일 포트에서 발생하는 트래픽과 일치 시킨다.</p>
<p><strong>egress</strong>: 각 네트워크폴리시에는 화이트리스트 <code>egress</code> 규칙이 포함될 수 있다. 각 규칙은 <code>to</code> 와 <code>ports</code> 부분과 모두 일치하는 트래픽을 허용한다. 예시 정책에는 단일 포트의 트래픽을 <code>10.0.0.0/24</code> 의 모든 대상과 일치시키는 단일 규칙을 포함하고 있다.</p>
<p>따라서 예시의 네트워크폴리시는 다음과 같이 동작한다.</p>
<ol>
<li>
<p>인그레스 및 이그레스 트래픽에 대해 "default" 네임스페이스에서 "role=db"인 파드를 격리한다(아직 격리되지 않은 경우).</p>
</li>
<li>
<p>(인그레스 규칙)은 "role=db" 레이블을 사용하는 "default" 네임스페이스의 모든 파드에 대해서 TCP 포트 6397로의 연결을 허용한다. 인그레스을 허용 할 대상은 다음과 같다.</p>
<ul>
<li>"role=frontend" 레이블이 있는 "default" 네임스페이스의 모든 파드</li>
<li>네임스페이스와 "project=myproject" 를 레이블로 가지는 모든 파드</li>
<li>172.17.0.0–172.17.0.255 와 172.17.2.0–172.17.255.255 의 범위를 가지는 IP 주소(예: 172.17.0.0/16 전체에서 172.17.1.0/24 를 제외)</li>
</ul>
</li>
<li>
<p>(이그레스 규칙)은 "role=db" 레이블이 있는 "default" 네임스페이스의 모든 파드에서 TCP 포트 5978의 CIDR 10.0.0.0/24 로의 연결을 허용한다.</p>
</li>
</ol>
<p>자세한 설명과 추가 예시는 <a href=/ko/docs/tasks/administer-cluster/declare-network-policy/>네트워크 정책 선언</a>을 본다.</p>
<h2 id=to-및-from-셀럭터의-동작><code>to</code> 및 <code>from</code> 셀럭터의 동작</h2>
<p><code>ingress</code> <code>from</code> 부분 또는 <code>egress</code> <code>to</code> 부분에 지정할 수 있는 네 종류의 셀렉터가 있다.</p>
<p><strong>podSelector</strong>: 네트워크폴리시를 통해서, 인그레스 소스 또는 이그레스 목적지로 허용되야 하는 동일한 네임스페이스에 있는 특정 파드들을 선택한다.</p>
<p><strong>namespaceSelector</strong>: 모든 파드가 인그레스 소스 또는 이그레스를 대상으로 허용되어야 하는 특정 네임스페이스를 선택한다.</p>
<p><strong>namespaceSelector</strong> <em>와</em> <strong>podSelector</strong>: <code>namespaceSelector</code> 와 <code>podSelector</code> 를 모두 지정하는 단일 <code>to</code>/<code>from</code> 항목은 특정 네임스페이스 내에서 특정 파드를 선택한다. 올바른 YAML 구문을 사용하도록 주의해야 한다. 이 정책:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ingress</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>from</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>namespaceSelector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>user</span>:<span style=color:#bbb> </span>alice<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>podSelector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>role</span>:<span style=color:#bbb> </span>client<span style=color:#bbb>
</span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></code></pre></div><p>네임스페이스에서 레이블이 <code>role=client</code> 인 것과 레이블이 <code>user=alice</code> 인 파드의 연결을 허용하는 단일 <code>from</code> 요소가 포함되어 있다. 그러나 <em>이</em> 정책:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ingress</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>from</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>namespaceSelector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>user</span>:<span style=color:#bbb> </span>alice<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>podSelector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>role</span>:<span style=color:#bbb> </span>client<span style=color:#bbb>
</span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></code></pre></div><p><code>from</code> 배열에 두 개의 요소가 포함되어 있으며, 로컬 네임스페이스에 레이블을 <code>role=client</code> 로 가지는 파드 <em>또는</em> 네임스페이스에 레이블을 <code>user=alice</code> 로 가지는 파드의 연결을 허용한다.</p>
<p>의심스러운 경우, <code>kubectl describe</code> 를 사용해서 쿠버네티스가 정책을 어떻게 해석하는지 확인해본다.</p>
<p><a name=behavior-of-ipblock-selectors></a>
<strong>ipBlock</strong>: 인그레스 소스 또는 이그레스 대상으로 허용할 IP CIDR 범위를 선택한다. 파드 IP는 임시적이고 예측할 수 없기에 클러스터 외부 IP이어야 한다.</p>
<p>클러스터 인그레스 및 이그레스 매커니즘은 종종 패킷의 소스 또는 대상 IP의 재작성을
필요로 한다. 이러한 상황이 발생하는 경우, 네트워크폴리시의 처리 전 또는 후에
발생한 것인지 정의되지 않으며, 네트워크 플러그인, 클라우드 공급자,
<code>서비스</code> 구현 등의 조합에 따라 동작이 다를 수 있다.</p>
<p>인그레스 사례에서의 의미는 실제 원본 소스 IP를 기준으로 들어오는 패킷을
필터링할 수 있는 반면에 다른 경우에는 네트워크폴리시가 작동하는
"소스 IP"는 <code>LoadBalancer</code> 또는 파드가 속한 노드 등의 IP일 수 있다.</p>
<p>이그레스의 경우 파드에서 클러스터 외부 IP로 다시 작성된 <code>서비스</code> IP로의 연결은
<code>ipBlock</code> 기반의 정책의 적용을 받거나 받지 않을 수 있다는 것을 의미한다.</p>
<h2 id=기본-정책>기본 정책</h2>
<p>기본적으로 네임스페이스 정책이 없으면 해당 네임스페이스의 파드에 대한 모든 인그레스와 이그레스 트래픽이 허용된다. 다음 예시에서는 해당 네임스페이스의 기본 동작을
변경할 수 있다.</p>
<h3 id=기본적으로-모든-인그레스-트래픽-거부>기본적으로 모든 인그레스 트래픽 거부</h3>
<p>모든 파드를 선택하지만 해당 파드에 대한 인그레스 트래픽은 허용하지 않는 네트워크폴리시를 생성해서 네임스페이스에 대한 "기본" 인그레스 격리 정책을 생성할 수 있다.</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/ko/examples/service/networking/network-policy-default-deny-ingress.yaml download=service/networking/network-policy-default-deny-ingress.yaml><code>service/networking/network-policy-default-deny-ingress.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('service-networking-network-policy-default-deny-ingress-yaml')" title="Copy service/networking/network-policy-default-deny-ingress.yaml to clipboard">
</img>
</div>
<div class=includecode id=service-networking-network-policy-default-deny-ingress-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>networking.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>NetworkPolicy<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>default-deny-ingress<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>podSelector</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>policyTypes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- Ingress<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>이렇게 하면 다른 네트워크폴리시에서 선택하지 않은 파드도 인그레스에 대해 여전히 격리된다. 이 정책은 다른 파드로부터의 이그레스 격리에는 영향을 미치지 않는다.</p>
<h3 id=모든-인그레스-트래픽-허용>모든 인그레스 트래픽 허용</h3>
<p>한 네임스페이스의 모든 파드로의 인입(incoming) 연결을 허용하려면, 이를 명시적으로 허용하는 정책을 만들 수 있다.</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/ko/examples/service/networking/network-policy-allow-all-ingress.yaml download=service/networking/network-policy-allow-all-ingress.yaml><code>service/networking/network-policy-allow-all-ingress.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('service-networking-network-policy-allow-all-ingress-yaml')" title="Copy service/networking/network-policy-allow-all-ingress.yaml to clipboard">
</img>
</div>
<div class=includecode id=service-networking-network-policy-allow-all-ingress-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>networking.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>NetworkPolicy<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>allow-all-ingress<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>podSelector</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ingress</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- {}<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>policyTypes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- Ingress<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>이 정책이 존재하면, 해당 파드로의 인입 연결을 막는 다른 정책은 효력이 없다. 이 정책은 모든 파드로부터의 이그레스 격리에는 영향을 미치지 않는다.</p>
<h3 id=기본적으로-모든-이그레스-트래픽-거부>기본적으로 모든 이그레스 트래픽 거부</h3>
<p>모든 파드를 선택하지만, 해당 파드의 이그레스 트래픽을 허용하지 않는 네트워크폴리시를 생성해서 네임스페이스에 대한 "기본" 이그레스 격리 정책을 생성할 수 있다.</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/ko/examples/service/networking/network-policy-default-deny-egress.yaml download=service/networking/network-policy-default-deny-egress.yaml><code>service/networking/network-policy-default-deny-egress.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('service-networking-network-policy-default-deny-egress-yaml')" title="Copy service/networking/network-policy-default-deny-egress.yaml to clipboard">
</img>
</div>
<div class=includecode id=service-networking-network-policy-default-deny-egress-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>networking.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>NetworkPolicy<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>default-deny-egress<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>podSelector</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>policyTypes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- Egress<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>이렇게 하면 다른 네트워크폴리시에서 선택하지 않은 파드조차도 이그레스 트래픽을 허용하지 않는다. 이 정책은
모든 파드의 인그레스 격리 정책을 변경하지 않는다.</p>
<h3 id=모든-이그레스-트래픽-허용>모든 이그레스 트래픽 허용</h3>
<p>한 네임스페이스의 모든 파드로부터의 모든 연결을 허용하려면, 해당 네임스페이스의 파드로부터 나가는(outgoing) 모든 연결을 명시적으로 허용하는 정책을 생성할 수 있다.</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/ko/examples/service/networking/network-policy-allow-all-egress.yaml download=service/networking/network-policy-allow-all-egress.yaml><code>service/networking/network-policy-allow-all-egress.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('service-networking-network-policy-allow-all-egress-yaml')" title="Copy service/networking/network-policy-allow-all-egress.yaml to clipboard">
</img>
</div>
<div class=includecode id=service-networking-network-policy-allow-all-egress-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>networking.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>NetworkPolicy<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>allow-all-egress<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>podSelector</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>egress</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- {}<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>policyTypes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- Egress<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>이 정책이 존재하면, 해당 파드에서 나가는 연결을 막는 다른 정책은 효력이 없다. 이 정책은 모든 파드로의 인그레스 격리에는 영향을 미치지 않는다.</p>
<h3 id=기본적으로-모든-인그레스와-모든-이그레스-트래픽-거부>기본적으로 모든 인그레스와 모든 이그레스 트래픽 거부</h3>
<p>해당 네임스페이스에 아래의 네트워크폴리시를 만들어 모든 인그레스와 이그레스 트래픽을 방지하는 네임스페이스에 대한 "기본" 정책을 만들 수 있다.</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/ko/examples/service/networking/network-policy-default-deny-all.yaml download=service/networking/network-policy-default-deny-all.yaml><code>service/networking/network-policy-default-deny-all.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('service-networking-network-policy-default-deny-all-yaml')" title="Copy service/networking/network-policy-default-deny-all.yaml to clipboard">
</img>
</div>
<div class=includecode id=service-networking-network-policy-default-deny-all-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>networking.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>NetworkPolicy<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>default-deny-all<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>podSelector</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>policyTypes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- Ingress<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- Egress<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>이렇게 하면 다른 네트워크폴리시에서 선택하지 않은 파드도 인그레스 또는 이그레스 트래픽을 허용하지 않는다.</p>
<h2 id=sctp-지원>SCTP 지원</h2>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.20 [stable]</code>
</div>
<p>안정된 기능으로, 기본 활성화되어 있다. 클러스터 수준에서 SCTP를 비활성화하려면, 사용자(또는 클러스터 관리자)가 API 서버에 <code>--feature-gates=SCTPSupport=false,…</code> 를 사용해서 <code>SCTPSupport</code> <a href=/ko/docs/reference/command-line-tools-reference/feature-gates/>기능 게이트</a>를 비활성화해야 한다.
해당 기능 게이트가 활성화되어 있는 경우, 네트워크폴리시의 <code>protocol</code> 필드를 <code>SCTP</code>로 지정할 수 있다.</p>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> SCTP 프로토콜 네트워크폴리시를 지원하는 <a class=glossary-tooltip title="컨테이너 네트워크 인터페이스(CNI) 플러그인은 appc/CNI 스팩을 따르는 네트워크 플러그인의 일종이다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/#cni target=_blank aria-label=CNI>CNI</a> 플러그인을 사용하고 있어야 한다.
</div>
<h2 id=포트-범위-지정>포트 범위 지정</h2>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.22 [beta]</code>
</div>
<p>네트워크폴리시를 작성할 때, 단일 포트 대신 포트 범위를 대상으로 지정할 수 있다.</p>
<p>다음 예와 같이 <code>endPort</code> 필드를 사용하면, 이 작업을 수행할 수 있다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>networking.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>NetworkPolicy<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>multi-port-egress<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>podSelector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>role</span>:<span style=color:#bbb> </span>db<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>policyTypes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- Egress<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>egress</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>to</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>ipBlock</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cidr</span>:<span style=color:#bbb> </span><span style=color:#666>10.0.0.0</span>/24<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>32000</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>endPort</span>:<span style=color:#bbb> </span><span style=color:#666>32768</span><span style=color:#bbb>
</span></code></pre></div><p>위 규칙은 대상 포트가 32000에서 32768 사이에 있는 경우,
네임스페이스 <code>default</code> 에 레이블이 <code>role=db</code> 인 모든 파드가
TCP를 통해 <code>10.0.0.0/24</code> 범위 내의 모든 IP와 통신하도록 허용한다.</p>
<p>이 필드를 사용할 때 다음의 제한 사항이 적용된다.</p>
<ul>
<li>베타 기능으로, 기본적으로 활성화되어 있다.
클러스터 수준에서 <code>endPort</code> 필드를 비활성화하려면, 사용자(또는 클러스터 관리자)가
API 서버에 대해 <code>--feature-gates=NetworkPolicyEndPort=false,…</code> 명령을 이용하여
<code>NetworkPolicyEndPort</code> <a href=/ko/docs/reference/command-line-tools-reference/feature-gates/>기능 게이트</a>를 비활성화해야 한다.</li>
<li><code>endPort</code> 필드는 <code>port</code> 필드보다 크거나 같아야 한다.</li>
<li><code>endPort</code> 는 <code>port</code> 도 정의된 경우에만 정의할 수 있다.</li>
<li>두 포트 모두 숫자여야 한다.</li>
</ul>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> 클러스터가 네트워크폴리시 명세의 <code>endPort</code> 필드를 지원하는
<a class=glossary-tooltip title="컨테이너 네트워크 인터페이스(CNI) 플러그인은 appc/CNI 스팩을 따르는 네트워크 플러그인의 일종이다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/#cni target=_blank aria-label=CNI>CNI</a> 플러그인을 사용해야 한다.
만약 <a href=/ko/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/>네트워크 플러그인</a>이
<code>endPort</code> 필드를 지원하지 않는데 네트워크폴리시의 해당 필드에 명시를 하면,
그 정책은 <code>port</code> 필드에만 적용될 것이다.
</div>
<h2 id=이름으로-네임스페이스-지정>이름으로 네임스페이스 지정</h2>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes 1.21 [beta]</code>
</div>
<p>쿠버네티스 컨트롤 플레인은 <code>NamespaceDefaultLabelName</code>
<a href=/ko/docs/reference/command-line-tools-reference/feature-gates/>기능 게이트</a>가 활성화된 경우
모든 네임스페이스에 변경할 수 없는(immutable) 레이블 <code>kubernetes.io/metadata.name</code> 을 설정한다.
레이블의 값은 네임스페이스 이름이다.</p>
<p>네트워크폴리시는 일부 오브젝트 필드가 있는 이름으로 네임스페이스를 대상으로 지정할 수 없지만, 표준화된 레이블을 사용하여
특정 네임스페이스를 대상으로 지정할 수 있다.</p>
<h2 id=네트워크-정책으로-할-수-없는-것-적어도-아직은-할-수-없는>네트워크 정책으로 할 수 없는 것(적어도 아직은 할 수 없는)</h2>
<p>쿠버네티스 1.27부터 다음의 기능은 네트워크폴리시 API에 존재하지 않지만, 운영 체제 컴포넌트(예: SELinux, OpenVSwitch, IPTables 등) 또는 Layer 7 기술(인그레스 컨트롤러, 서비스 메시 구현) 또는 어드미션 컨트롤러를 사용하여 제2의 해결책을 구현할 수 있다. 쿠버네티스의 네트워크 보안을 처음 사용하는 경우, 네트워크폴리시 API를 사용하여 다음의 사용자 스토리를 (아직) 구현할 수 없다는 점에 유의할 필요가 있다.</p>
<ul>
<li>내부 클러스터 트래픽이 공통 게이트웨이를 통과하도록 강제한다(서비스 메시나 기타 프록시와 함께 제공하는 것이 가장 좋을 수 있음).</li>
<li>TLS와 관련된 모든 것(이를 위해 서비스 메시나 인그레스 컨트롤러 사용).</li>
<li>노드별 정책(이에 대해 CIDR 표기법을 사용할 수 있지만, 특히 쿠버네티스 ID로 노드를 대상으로 지정할 수 없음).</li>
<li>이름으로 서비스를 타겟팅한다(그러나, <a class=glossary-tooltip title="사용자에게 의미 있고 관련성 높은 특징으로 식별할 수 있도록 오브젝트에 태그를 붙인다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/overview/working-with-objects/labels target=_blank aria-label=레이블>레이블</a>로 파드나 네임스페이스를 타겟팅할 수 있으며, 이는 종종 실행할 수 있는 해결 방법임).</li>
<li>타사 공급사가 이행한 "정책 요청"의 생성 또는 관리.</li>
<li>모든 네임스페이스나 파드에 적용되는 기본 정책(이를 수행할 수 있는 타사 공급사의 쿠버네티스 배포본 및 프로젝트가 있음).</li>
<li>고급 정책 쿼리 및 도달 가능성 도구.</li>
<li>네트워크 보안 이벤트를 기록하는 기능(예: 차단되거나 수락된 연결).</li>
<li>명시적으로 정책을 거부하는 기능(현재 네트워크폴리시 모델은 기본적으로 거부하며, 허용 규칙을 추가하는 기능만 있음).</li>
<li>루프백 또는 들어오는 호스트 트래픽을 방지하는 기능(파드는 현재 로컬 호스트 접근을 차단할 수 없으며, 상주 노드의 접근을 차단할 수 있는 기능도 없음).</li>
</ul>
<h2 id=다음-내용>다음 내용</h2>
<ul>
<li>자세한 설명과 추가 예시는
<a href=/ko/docs/tasks/administer-cluster/declare-network-policy/>네트워크 정책 선언</a>을 본다.</li>
<li>네트워크폴리시 리소스에서 사용되는 일반적인 시나리오는 <a href=https://github.com/ahmetb/kubernetes-network-policy-recipes>레시피</a>를 본다.</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-21f8d19c60c33914baab66224c3d46a7>5.11 - IPv4/IPv6 이중 스택</h1>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.23 [stable]</code>
</div>
<p>IPv4/IPv6 이중 스택 네트워킹을 사용하면 <a class=glossary-tooltip title="파드는 클러스터에서 실행 중인 컨테이너의 집합을 나타낸다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/pods/ target=_blank aria-label=파드>파드</a>와 <a class=glossary-tooltip title="네트워크 서비스로 파드 집합에서 실행 중인 애플리케이션을 노출하는 방법" data-toggle=tooltip data-placement=top href=/ko/docs/concepts/services-networking/service/ target=_blank aria-label=서비스>서비스</a>에 IPv4와 IPv6 주소를 모두 할당할 수 있다.</p>
<p>IPv4/IPv6 이중 스택 네트워킹은 1.21부터 쿠버네티스 클러스터에 기본적으로 활성화되어 있고, IPv4 및 IPv6 주소를 동시에 할당할 수 있다.</p>
<h2 id=지원되는-기능>지원되는 기능</h2>
<p>쿠버네티스 클러스터의 IPv4/IPv6 이중 스택은 다음의 기능을 제공한다.</p>
<ul>
<li>이중 스택 파드 네트워킹(파드 당 단일 IPv4와 IPv6 주소 할당)</li>
<li>IPv4와 IPv6 지원 서비스</li>
<li>IPv4와 IPv6 인터페이스를 통한 파드 오프(off) 클러스터 이그레스 라우팅(예: 인터넷)</li>
</ul>
<h2 id=필수-구성-요소>필수 구성 요소</h2>
<p>IPv4/IPv6 이중 스택 쿠버네티스 클러스터를 활용하려면 다음의 필수 구성 요소가 필요하다.</p>
<ul>
<li>쿠버네티스 1.20 이상
이전 버전과 함께 이중 스택 서비스를 사용하는 방법에 대한 정보
쿠버네티스 버전, 쿠버네티스 해당 버전에 대한
문서 참조</li>
<li>이중 스택 네트워킹을 위한 공급자의 지원(클라우드 공급자 또는 다른 방식으로 쿠버네티스 노드에 라우팅 가능한 IPv4/IPv6 네트워크 인터페이스를 제공할 수 있어야 한다.)</li>
<li>이중 스택(예: Kubenet 또는 Calico)을 지원하는 네트워크 플러그인</li>
</ul>
<h2 id=ipv4-ipv6-이중-스택-구성>IPv4/IPv6 이중 스택 구성</h2>
<p>IPv4/IPv6 이중 스택을 구성하려면, 이중 스택 클러스터 네트워크 할당을 설정한다.</p>
<ul>
<li>kube-apiserver:
<ul>
<li><code>--service-cluster-ip-range=&lt;IPv4 CIDR>,&lt;IPv6 CIDR></code></li>
</ul>
</li>
<li>kube-controller-manager:
<ul>
<li><code>--cluster-cidr=&lt;IPv4 CIDR>,&lt;IPv6 CIDR></code></li>
<li><code>--service-cluster-ip-range=&lt;IPv4 CIDR>,&lt;IPv6 CIDR></code></li>
<li><code>--node-cidr-mask-size-ipv4|--node-cidr-mask-size-ipv6</code> IPv4의 기본값은 /24 이고 IPv6의 기본값은 /64 이다.</li>
</ul>
</li>
<li>kube-proxy:
<ul>
<li><code>--cluster-cidr=&lt;IPv4 CIDR>,&lt;IPv6 CIDR></code></li>
</ul>
</li>
<li>kubelet:
<ul>
<li><code>--cloud-provider</code>가 명시되지 않았다면
관리자는 해당 노드에 듀얼 스택 <code>.status.addresses</code>를 수동으로 설정하기 위해
쉼표로 구분된 IP 주소 쌍을 <code>--node-ip</code> 플래그로 전달할 수 있다.
해당 노드의 파드가 HostNetwork 모드로 실행된다면,
파드는 이 IP 주소들을 자신의 <code>.status.podIPs</code> 필드에 보고한다.
노드의 모든 <code>podIPs</code>는 해당 노드의 <code>.status.addresses</code> 필드에 의해 정의된
IP 패밀리 선호사항을 만족한다.</li>
</ul>
</li>
</ul>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> <p>IPv4 CIDR의 예: <code>10.244.0.0/16</code> (자신의 주소 범위를 제공하더라도)</p>
<p>IPv6 CIDR의 예: <code>fdXY:IJKL:MNOP:15::/64</code> (이 형식으로 표시되지만, 유효한 주소는 아니다 - <a href=https://tools.ietf.org/html/rfc4193>RFC 4193</a>을 본다.)</p>
</div>
<h2 id=서비스>서비스</h2>
<p>IPv4, IPv6 또는 둘 다를 사용할 수 있는 <a class=glossary-tooltip title="네트워크 서비스로 파드 집합에서 실행 중인 애플리케이션을 노출하는 방법" data-toggle=tooltip data-placement=top href=/ko/docs/concepts/services-networking/service/ target=_blank aria-label=서비스>서비스</a>를 생성할 수 있다.</p>
<p>서비스의 주소 계열은 기본적으로 첫 번째 서비스 클러스터 IP 범위의 주소 계열로 설정된다. (<code>--service-cluster-ip-range</code> 플래그를 통해 kube-apiserver에 구성)</p>
<p>서비스를 정의할 때 선택적으로 이중 스택으로 구성할 수 있다. 원하는 동작을 지정하려면 <code>.spec.ipFamilyPolicy</code> 필드를
다음 값 중 하나로 설정한다.</p>
<ul>
<li><code>SingleStack</code>: 단일 스택 서비스. 컨트롤 플레인은 첫 번째로 구성된 서비스 클러스터 IP 범위를 사용하여 서비스에 대한 클러스터 IP를 할당한다.</li>
<li><code>PreferDualStack</code>:
<ul>
<li>서비스에 IPv4 및 IPv6 클러스터 IP를 할당한다.</li>
</ul>
</li>
<li><code>RequireDualStack</code>: IPv4 및 IPv6 주소 범위 모두에서 서비스 <code>.spec.ClusterIPs</code>를 할당한다.
<ul>
<li><code>.spec.ipFamilies</code> 배열의 첫 번째 요소의 주소 계열을 기반으로 <code>.spec.ClusterIPs</code> 목록에서 <code>.spec.ClusterIP</code>를 선택한다.</li>
</ul>
</li>
</ul>
<p>단일 스택에 사용할 IP 계열을 정의하거나 이중 스택에 대한 IP 군의 순서를 정의하려는 경우, 서비스에서 옵션 필드 <code>.spec.ipFamilies</code>를 설정하여 주소 군을 선택할 수 있다.</p>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> <code>.spec.ipFamilies</code> 필드는 이미 존재하는 서비스에 <code>.spec.ClusterIP</code>를 재할당할 수 없기 때문에 변경할 수 없다. <code>.spec.ipFamilies</code>를 변경하려면 서비스를 삭제하고 다시 생성한다.
</div>
<p><code>.spec.ipFamilies</code>를 다음 배열 값 중 하나로 설정할 수 있다.</p>
<ul>
<li><code>["IPv4"]</code></li>
<li><code>["IPv6"]</code></li>
<li><code>["IPv4","IPv6"]</code> (이중 스택)</li>
<li><code>["IPv6","IPv4"]</code> (이중 스택)</li>
</ul>
<p>나열한 첫 번째 군은 레거시<code>.spec.ClusterIP</code> 필드에 사용된다.</p>
<h3 id=이중-스택-서비스-구성-시나리오>이중 스택 서비스 구성 시나리오</h3>
<p>이 예제는 다양한 이중 스택 서비스 구성 시나리오의 동작을 보여준다.</p>
<h4 id=새로운-서비스에-대한-이중-스택-옵션>새로운 서비스에 대한 이중 스택 옵션</h4>
<ol>
<li>이 서비스 사양은 <code>.spec.ipFamilyPolicy</code>를 명시적으로 정의하지 않는다. 이 서비스를 만들 때 쿠버네티스는 처음 구성된 <code>service-cluster-ip-range</code>에서 서비스에 대한 클러스터 IP를 할당하고 <code>.spec.ipFamilyPolicy</code>를 <code>SingleStack</code>으로 설정한다. (<a href=/ko/docs/concepts/services-networking/service/#%EC%85%80%EB%A0%89%ED%84%B0%EA%B0%80-%EC%97%86%EB%8A%94-%EC%84%9C%EB%B9%84%EC%8A%A4>셀렉터가 없는 서비스</a> 및 <a href=/ko/docs/concepts/services-networking/service/#%ED%97%A4%EB%93%9C%EB%A6%AC%EC%8A%A4-headless-%EC%84%9C%EB%B9%84%EC%8A%A4>헤드리스 서비스</a>와 같은 방식으로 동작한다.)</li>
</ol>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/ko/examples/service/networking/dual-stack-default-svc.yaml download=service/networking/dual-stack-default-svc.yaml><code>service/networking/dual-stack-default-svc.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('service-networking-dual-stack-default-svc-yaml')" title="Copy service/networking/dual-stack-default-svc.yaml to clipboard">
</img>
</div>
<div class=includecode id=service-networking-dual-stack-default-svc-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>MyApp<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>MyApp<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<ol>
<li>
<p>이 서비스 사양은 <code>.spec.ipFamilyPolicy</code>에 <code>PreferDualStack</code>을 명시적으로 정의한다. 이중 스택 클러스터에서 이 서비스를 생성하면 쿠버네티스는 서비스에 대해 IPv4 및 IPv6 주소를 모두 할당한다. 컨트롤 플레인은 서비스의 <code>.spec</code>을 업데이트하여 IP 주소 할당을 기록한다. 필드 <code>.spec.ClusterIPs</code>는 기본 필드이며 할당된 IP 주소를 모두 포함한다. <code>.spec.ClusterIP</code>는 값이 <code>.spec.ClusterIPs</code>에서 계산된 보조 필드이다.</p>
<ul>
<li><code>.spec.ClusterIP</code> 필드의 경우 컨트롤 플레인은 첫 번째 서비스 클러스터 IP 범위와 동일한 주소 계열의 IP 주소를 기록한다.</li>
<li>단일 스택 클러스터에서 <code>.spec.ClusterIPs</code> 및 <code>.spec.ClusterIP</code> 필드는 모두 하나의 주소만 나열한다.</li>
<li>이중 스택이 활성화된 클러스터에서 <code>.spec.ipFamilyPolicy</code>에 <code>RequireDualStack</code>을 지정하면 <code>PreferDualStack</code>과 동일하게 작동한다.</li>
</ul>
</li>
</ol>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/ko/examples/service/networking/dual-stack-preferred-svc.yaml download=service/networking/dual-stack-preferred-svc.yaml><code>service/networking/dual-stack-preferred-svc.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('service-networking-dual-stack-preferred-svc-yaml')" title="Copy service/networking/dual-stack-preferred-svc.yaml to clipboard">
</img>
</div>
<div class=includecode id=service-networking-dual-stack-preferred-svc-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>MyApp<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ipFamilyPolicy</span>:<span style=color:#bbb> </span>PreferDualStack<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>MyApp<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<ol>
<li>이 서비스 사양은 <code>.spec.ipFamilies</code>에<code> IPv6</code>과 <code>IPv4</code>를 명시적으로 정의하고 <code>.spec.ipFamilyPolicy</code>에 <code>PreferDualStack</code>을 정의한다. 쿠버네티스가 <code>.spec.ClusterIPs</code>에 IPv6 및 IPv4 주소를 할당할 때 <code>.spec.ClusterIP</code>는 <code>.spec.ClusterIPs</code> 배열의 첫 번째 요소이므로 IPv6 주소로 설정되어 기본값을 재정의한다.</li>
</ol>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/ko/examples/service/networking/dual-stack-preferred-ipfamilies-svc.yaml download=service/networking/dual-stack-preferred-ipfamilies-svc.yaml><code>service/networking/dual-stack-preferred-ipfamilies-svc.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('service-networking-dual-stack-preferred-ipfamilies-svc-yaml')" title="Copy service/networking/dual-stack-preferred-ipfamilies-svc.yaml to clipboard">
</img>
</div>
<div class=includecode id=service-networking-dual-stack-preferred-ipfamilies-svc-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>MyApp<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ipFamilyPolicy</span>:<span style=color:#bbb> </span>PreferDualStack<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ipFamilies</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- IPv6<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- IPv4<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>MyApp<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<h4 id=기존-서비스의-이중-스택-기본값>기존 서비스의 이중 스택 기본값</h4>
<p>이 예제는 서비스가 이미 있는 클러스터에서 이중 스택이 새로 활성화된 경우의 기본 동작을 보여준다. (기존 클러스터를 1.21 이상으로 업그레이드하면 이중 스택이 활성화된다.)</p>
<ol>
<li>클러스터에서 이중 스택이 활성화된 경우 기존 서비스 (<code>IPv4</code> 또는 <code>IPv6</code>)는 컨트롤 플레인이 <code>.spec.ipFamilyPolicy</code>를 <code>SingleStack</code>으로 지정하고 <code>.spec.ipFamilies</code>를 기존 서비스의 주소 계열로 설정한다. 기존 서비스 클러스터 IP는 <code>.spec.ClusterIPs</code>에 저장한다.</li>
</ol>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/ko/examples/service/networking/dual-stack-default-svc.yaml download=service/networking/dual-stack-default-svc.yaml><code>service/networking/dual-stack-default-svc.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('service-networking-dual-stack-default-svc-yaml')" title="Copy service/networking/dual-stack-default-svc.yaml to clipboard">
</img>
</div>
<div class=includecode id=service-networking-dual-stack-default-svc-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>MyApp<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>MyApp<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>kubectl을 사용하여 기존 서비스를 검사하여 이 동작을 검증할 수 있다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get svc my-service -o yaml
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>MyApp<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>clusterIP</span>:<span style=color:#bbb> </span><span style=color:#666>10.0.197.123</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>clusterIPs</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:#666>10.0.197.123</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ipFamilies</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- IPv4<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ipFamilyPolicy</span>:<span style=color:#bbb> </span>SingleStack<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>MyApp<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>ClusterIP<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>loadBalancer</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span></code></pre></div><ol>
<li>클러스터에서 이중 스택이 활성화된 경우, 셀렉터가 있는 기존 <a href=/ko/docs/concepts/services-networking/service/#%ED%97%A4%EB%93%9C%EB%A6%AC%EC%8A%A4-headless-%EC%84%9C%EB%B9%84%EC%8A%A4>헤드리스 서비스</a>는 <code>.spec.ClusterIP</code>가 <code>None</code>이라도 컨트롤 플레인이 <code>.spec.ipFamilyPolicy</code>을 <code>SingleStack</code>으로 지정하고 <code>.spec.ipFamilies</code>는 첫 번째 서비스 클러스터 IP 범위(kube-apiserver에 대한 <code>--service-cluster-ip-range</code> 플래그를 통해 구성)의 주소 계열으로 지정한다.</li>
</ol>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/ko/examples/service/networking/dual-stack-default-svc.yaml download=service/networking/dual-stack-default-svc.yaml><code>service/networking/dual-stack-default-svc.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('service-networking-dual-stack-default-svc-yaml')" title="Copy service/networking/dual-stack-default-svc.yaml to clipboard">
</img>
</div>
<div class=includecode id=service-networking-dual-stack-default-svc-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>MyApp<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>MyApp<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>kubectl을 사용하여 셀렉터로 기존 헤드리스 서비스를 검사하여 이 동작의 유효성을 검사 할 수 있다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get svc my-service -o yaml
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>MyApp<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>clusterIP</span>:<span style=color:#bbb> </span>None<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>clusterIPs</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- None<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ipFamilies</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- IPv4<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ipFamilyPolicy</span>:<span style=color:#bbb> </span>SingleStack<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>MyApp<span style=color:#bbb>
</span></code></pre></div><h4 id=단일-스택과-이중-스택-간-서비스-전환>단일 스택과 이중 스택 간 서비스 전환</h4>
<p>서비스는 단일 스택에서 이중 스택으로, 이중 스택에서 단일 스택으로 변경할 수 있다.</p>
<ol>
<li>
<p>서비스를 단일 스택에서 이중 스택으로 변경하려면 원하는 대로 <code>.spec.ipFamilyPolicy</code>를 <code>SingleStack</code>에서 <code>PreferDualStack</code> 또는 <code>RequireDualStack</code>으로 변경한다. 이 서비스를 단일 스택에서 이중 스택으로 변경하면 쿠버네티스는 누락된 주소 계열의 것을 배정하므로 해당 서비스는 이제 IPv4와 IPv6 주소를 갖게된다.</p>
<p><code>.spec.ipFamilyPolicy</code>를 <code>SingleStack</code>에서 <code>PreferDualStack</code>으로 업데이트하는 서비스 사양을 편집한다.</p>
</li>
</ol>
<p>이전:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ipFamilyPolicy</span>:<span style=color:#bbb> </span>SingleStack<span style=color:#bbb>
</span></code></pre></div><p>이후:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ipFamilyPolicy</span>:<span style=color:#bbb> </span>PreferDualStack<span style=color:#bbb>
</span></code></pre></div><ol>
<li>서비스를 이중 스택에서 단일 스택으로 변경하려면 <code>.spec.ipFamilyPolicy</code>를 <code>PreferDualStack</code>에서 또는 <code>RequireDualStack</code>을 <code>SingleStack</code>으로 변경한다. 이 서비스를 이중 스택에서 단일 스택으로 변경하면 쿠버네티스는 <code>.spec.ClusterIPs</code> 배열의 첫 번째 요소 만 유지하고 <code>.spec.ClusterIP</code>를 해당 IP 주소로 설정하고 <code>.spec.ipFamilies</code>를 <code>.spec.ClusterIPs</code>의 주소 계열로 설정한다.</li>
</ol>
<h3 id=셀렉터가-없는-헤드리스-서비스>셀렉터가 없는 헤드리스 서비스</h3>
<p><a href=/ko/docs/concepts/services-networking/service/#%EC%85%80%EB%A0%89%ED%84%B0%EA%B0%80-%EC%97%86%EB%8A%94-%EC%84%9C%EB%B9%84%EC%8A%A4>셀렉터가 없는 서비스</a> 및 <code>.spec.ipFamilyPolicy</code>가 명시적으로 설정되지 않은 경우 <code>.spec.ipFamilyPolicy</code> 필드의 기본값은 <code>RequireDualStack</code> 이다.</p>
<h3 id=로드밸런서-서비스-유형>로드밸런서 서비스 유형</h3>
<p>서비스에 이중 스택 로드밸런서를 프로비저닝하려면</p>
<ul>
<li><code>.spec.type</code> 필드를 <code>LoadBalancer</code>로 설정</li>
<li><code>.spec.ipFamilyPolicy</code> 필드를 <code>PreferDualStack</code> 또는 <code>RequireDualStack</code>으로 설정</li>
</ul>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> 이중 스택 <code>LoadBalancer</code> 유형 서비스를 사용하려면 클라우드 공급자가 IPv4 및 IPv6로드 밸런서를 지원해야 한다.
</div>
<h2 id=이그레스-egress-트래픽>이그레스(Egress) 트래픽</h2>
<p>비공개로 라우팅할 수 있는 IPv6 주소를 사용하는 파드에서 클러스터 외부 대상 (예: 공용 인터넷)에 도달하기 위해 이그레스 트래픽을 활성화하려면 투명 프록시 또는 IP 위장과 같은 메커니즘을 통해 공개적으로 라우팅한 IPv6 주소를 사용하도록 파드를 활성화해야 한다. <a href=https://github.com/kubernetes-sigs/ip-masq-agent>ip-masq-agent</a> 프로젝트는 이중 스택 클러스터에서 IP 위장을 지원한다.</p>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> <a class=glossary-tooltip title="컨테이너 네트워크 인터페이스(CNI) 플러그인은 appc/CNI 스팩을 따르는 네트워크 플러그인의 일종이다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/#cni target=_blank aria-label=CNI>CNI</a> 공급자가 IPv6를 지원하는지 확인한다.
</div>
<h2 id=다음-내용>다음 내용</h2>
<ul>
<li><a href=/ko/docs/tasks/network/validate-dual-stack>IPv4/IPv6 이중 스택 검증</a> 네트워킹</li>
<li><a href=/docs/setup/production-environment/tools/kubeadm/dual-stack-support/>kubeadm을 사용하여 이중 스택 네트워킹 활성화
</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-f018f568c6723865753f150c3c59bdda>6 - 스토리지</h1>
<div class=lead>클러스터의 파드에 장기(long-term) 및 임시 스토리지를 모두 제공하는 방법</div>
</div>
<div class=td-content>
<h1 id=pg-27795584640a03bd2024f1fe3b3ab754>6.1 - 볼륨</h1>
<p>컨테이너 내의 디스크에 있는 파일은 임시적이며, 컨테이너에서 실행될 때
애플리케이션에 적지 않은 몇 가지 문제가 발생한다. 한 가지 문제는
컨테이너가 크래시될 때 파일이 손실된다는 것이다. kubelet은 컨테이너를 다시 시작하지만
초기화된 상태이다. 두 번째 문제는 <code>Pod</code>에서 같이 실행되는 컨테이너간에
파일을 공유할 때 발생한다.
쿠버네티스 <a class=glossary-tooltip title="데이터를 포함하고 있는 디렉터리이며, 파드의 컨테이너에서 접근 가능하다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/storage/volumes/ target=_blank aria-label=볼륨>볼륨</a> 추상화는
이러한 문제를 모두 해결한다.
<a href=/ko/docs/concepts/workloads/pods/>파드</a>에 대해 익숙해지는 것을 추천한다.</p>
<h2 id=배경>배경</h2>
<p>도커는 다소 느슨하고, 덜 관리되지만
<a href=https://docs.docker.com/storage/>볼륨</a>이라는
개념을 가지고 있다. 도커 볼륨은 디스크에 있는 디렉터리이거나
다른 컨테이너에 있다. 도커는 볼륨
드라이버를 제공하지만, 기능이 다소 제한된다.</p>
<p>쿠버네티스는 다양한 유형의 볼륨을 지원한다. <a class=glossary-tooltip title="파드는 클러스터에서 실행 중인 컨테이너의 집합을 나타낸다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/pods/ target=_blank aria-label=파드>파드</a>는
여러 볼륨 유형을 동시에 사용할 수 있다.
임시 볼륨 유형은 파드의 수명을 갖지만, 퍼시스턴트 볼륨은
파드의 수명을 넘어 존재한다. 파드가 더 이상 존재하지 않으면, 쿠버네티스는 임시(ephemeral) 볼륨을 삭제하지만,
퍼시스턴트(persistent) 볼륨은 삭제하지 않는다.
볼륨의 종류와 상관없이, 파드 내의 컨테이너가 재시작되어도 데이터는 보존된다.</p>
<p>기본적으로 볼륨은 디렉터리이며, 일부 데이터가 있을 수 있으며, 파드
내 컨테이너에서 접근할 수 있다. 디렉터리의 생성 방식, 이를 지원하는
매체와 내용은 사용된 특정 볼륨의 유형에 따라
결정된다.</p>
<p>볼륨을 사용하려면, <code>.spec.volumes</code> 에서 파드에 제공할 볼륨을 지정하고
<code>.spec.containers[*].volumeMounts</code> 의 컨테이너에 해당 볼륨을 마운트할 위치를 선언한다.
컨테이너의 프로세스는
<a class=glossary-tooltip title="컨테이너의 저장된 인스턴스이며, 애플리케이션 구동에 필요한 소프트웨어 집합을 가지고 있다." data-toggle=tooltip data-placement=top href="/ko/docs/reference/glossary/?all=true#term-image" target=_blank aria-label="컨테이너 이미지">컨테이너 이미지</a>의 최초 내용물과
컨테이너 안에 마운트된 볼륨(정의된 경우에 한함)으로 구성된 파일시스템을 보게 된다.
프로세스는 컨테이너 이미지의 최초 내용물에 해당되는 루트 파일시스템을
보게 된다.
쓰기가 허용된 경우, 해당 파일시스템에 쓰기 작업을 하면
추후 파일시스템에 접근할 때 변경된 내용을 보게 될 것이다.
볼륨은 이미지의 <a href=#using-subpath>특정 경로</a>에
마운트된다.
파드에 정의된 각 컨테이너에 대해,
컨테이너가 사용할 각 볼륨을 어디에 마운트할지 명시해야 한다.</p>
<p>볼륨은 다른 볼륨 안에 마운트될 수 없다
(하지만, <a href=#using-subpath>서브패스 사용</a>에서 관련 메커니즘을 확인한다).
또한, 볼륨은 다른 볼륨에 있는 내용물을 가리키는 하드 링크를 포함할 수 없다.</p>
<h2 id=volume-types>볼륨 유형들</h2>
<p>쿠버네티스는 여러 유형의 볼륨을 지원한다.</p>
<h3 id=awselasticblockstore>awsElasticBlockStore</h3>
<p><code>awsElasticBlockStore</code> 볼륨은 아마존 웹 서비스 (AWS)
<a href=https://aws.amazon.com/ebs/>EBS 볼륨</a>을 파드에 마운트 한다. 파드를
제거할 때 지워지는 <code>emptyDir</code> 와는 다르게 EBS 볼륨의
내용은 유지되고, 볼륨은 마운트 해제만 된다. 이 의미는 EBS 볼륨에
데이터를 미리 채울 수 있으며, 파드 간에 데이터를 "전달(handed off)"할 수 있다.</p>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> 이를 사용하려면 먼저 <code>aws ec2 create-volume</code> 또는 AWS API를 사용해서 EBS 볼륨을 생성해야 한다.
</div>
<p><code>awsElasticBlockStore</code> 볼륨을 사용할 때 몇 가지 제한이 있다.</p>
<ul>
<li>파드가 실행 중인 노드는 AWS EC2 인스턴스여야 함</li>
<li>이러한 인스턴스는 EBS 볼륨과 동일한 지역과 가용성 영역에 있어야 함</li>
<li>EBS는 볼륨을 마운트하는 단일 EC2 인스턴스만 지원함</li>
</ul>
<h4 id=aws-ebs-볼륨-생성하기>AWS EBS 볼륨 생성하기</h4>
<p>파드와 함께 EBS 볼륨을 사용하려면, 먼저 EBS 볼륨을 생성해야 한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>aws ec2 create-volume --availability-zone<span style=color:#666>=</span>eu-west-1a --size<span style=color:#666>=</span><span style=color:#666>10</span> --volume-type<span style=color:#666>=</span>gp2
</code></pre></div><p>클러스터를 띄운 영역과 생성하는 영역이 일치하는지 확인한다. 크기와 EBS 볼륨 유형이
사용에 적합한지 확인한다.</p>
<h4 id=aws-ebs-구성-예시>AWS EBS 구성 예시</h4>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-ebs<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/test-webserver<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-container<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/test-ebs<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-volume<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-volume<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 이 AWS EBS 볼륨은 이미 존재해야 한다.</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>awsElasticBlockStore</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumeID</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&lt;volume-id&gt;&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>fsType</span>:<span style=color:#bbb> </span>ext4<span style=color:#bbb>
</span></code></pre></div><p>EBS 볼륨이 파티션된 경우, 선택적 필드인 <code>partition: "&lt;partition number>"</code> 를 제공하여 마운트할 파티션을 지정할 수 있다.</p>
<h4 id=aws-ebs-csi-마이그레이션>AWS EBS CSI 마이그레이션</h4>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.17 [beta]</code>
</div>
<p><code>awsElasticBlockStore</code> 의 <code>CSIMigration</code> 기능이 활성화된 경우, 기존 인-트리 플러그인의
모든 플러그인 작업을 <code>ebs.csi.aws.com</code> 컨테이너 스토리지 인터페이스(CSI)
드라이버로 리디렉션한다. 이 기능을 사용하려면, 클러스터에 <a href=https://github.com/kubernetes-sigs/aws-ebs-csi-driver>AWS EBS CSI
드라이버</a>를
설치하고 <code>CSIMigration</code> 과 <code>CSIMigrationAWS</code>
베타 기능을 활성화해야 한다.</p>
<h4 id=aws-ebs-csi-마이그레이션-완료>AWS EBS CSI 마이그레이션 완료</h4>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.17 [alpha]</code>
</div>
<p>컨트롤러 관리자와 kubelet에 의해 로드되지 않도록 <code>awsElasticBlockStore</code> 스토리지
플러그인을 끄려면, <code>InTreePluginAWSUnregister</code> 플래그를 <code>true</code> 로 설정한다.</p>
<h3 id=azuredisk>azureDisk</h3>
<p><code>azureDisk</code> 볼륨 유형은 Microsoft Azure <a href=https://docs.microsoft.com/en-us/azure/aks/csi-storage-drivers>데이터 디스크</a>를 파드에 마운트한다.</p>
<p>더 자세한 내용은 <a href=https://github.com/kubernetes/examples/tree/master/staging/volumes/azure_disk/README.md><code>azureDisk</code> 볼륨 플러그인</a>을 참고한다.</p>
<h4 id=azuredisk-csi-마이그레이션>azureDisk CSI 마이그레이션</h4>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.19 [beta]</code>
</div>
<p><code>azureDisk</code> 의 <code>CSIMigration</code> 기능이 활성화된 경우, 기존 트리 내 플러그인에서
<code>disk.csi.azure.com</code> 컨테이너 스토리지 인터페이스(CSI)
드라이버로 모든 플러그인 작업을 수행한다. 이 기능을 사용하려면, 클러스터에 <a href=https://github.com/kubernetes-sigs/azuredisk-csi-driver>Azure 디스크 CSI
드라이버</a>
를 설치하고 <code>CSIMigration</code> 과 <code>CSIMigrationAzureDisk</code>
기능을 활성화해야 한다.</p>
<h3 id=azurefile>azureFile</h3>
<p><code>azureFile</code> 볼륨 유형은 Microsoft Azure 파일 볼륨(SMB 2.1과 3.0)을 파드에
마운트한다.</p>
<p>더 자세한 내용은 <a href=https://github.com/kubernetes/examples/tree/master/staging/volumes/azure_file/README.md><code>azureFile</code> 볼륨 플러그인</a>을 참고한다.</p>
<h4 id=azurefile-csi-마이그레이션>azureFile CSI 마이그레이션</h4>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.21 [beta]</code>
</div>
<p><code>azureFile</code> 의 <code>CSIMigration</code> 기능이 활성화된 경우, 기존 트리 내 플러그인에서
<code>file.csi.azure.com</code> 컨테이너 스토리지 인터페이스(CSI)
드라이버로 모든 플러그인 작업을 수행한다. 이 기능을 사용하려면, 클러스터에 <a href=https://github.com/kubernetes-sigs/azurefile-csi-driver>Azure 파일 CSI
드라이버</a>
를 설치하고 <code>CSIMigration</code> 과 <code>CSIMigrationAzureFile</code>
<a href=/ko/docs/reference/command-line-tools-reference/feature-gates/>기능 게이트</a>를 활성화해야 한다.</p>
<p>Azure File CSI 드라이버는 동일한 볼륨을 다른 fsgroup에서 사용하는 것을 지원하지 않는다. Azurefile CSI 마이그레이션이 활성화된 경우, 다른 fsgroup에서 동일한 볼륨을 사용하는 것은 전혀 지원되지 않는다.</p>
<h3 id=cephfs>cephfs</h3>
<p><code>cephfs</code> 볼륨은 기존 CephFS 볼륨을
파드에 마운트 할 수 있다. 파드를 제거할 때 지워지는 <code>emptyDir</code>
와는 다르게 cephfs 볼륨의 내용은 유지되고, 볼륨은 그저 마운트
해제만 된다. 이 의미는 <code>cephfs</code> 볼륨에 데이터를 미리 채울 수 있으며,
해당 데이터는 파드 간에 공유될 수 있다. <code>cephfs</code> 볼륨은 여러 작성자가
동시에 마운트할 수 있다.</p>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> CephFS를 사용하기 위해선 먼저 Ceph 서버를 실행하고 공유를 내보내야 한다.
</div>
<p>더 자세한 내용은 <a href=https://github.com/kubernetes/examples/tree/master/volumes/cephfs/>CephFS 예시</a>를 참조한다.</p>
<h3 id=cinder>cinder</h3>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> 쿠버네티스는 오픈스택 클라우드 공급자로 구성되어야 한다.
</div>
<p><code>cinder</code> 볼륨 유형은 오픈스택 Cinder 볼륨을 파드에 마운트하는데 사용된다.</p>
<h4 id=cinder-볼륨-구성-예시>Cinder 볼륨 구성 예시</h4>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-cinder<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/test-webserver<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-cinder-container<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/test-cinder<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-volume<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-volume<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 이 오픈스택 볼륨은 이미 존재해야 한다.</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>cinder</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumeID</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&lt;volume id&gt;&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>fsType</span>:<span style=color:#bbb> </span>ext4<span style=color:#bbb>
</span></code></pre></div><h4 id=오픈스택-csi-마이그레이션>오픈스택 CSI 마이그레이션</h4>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.21 [beta]</code>
</div>
<p>Cinder의<code>CSIMigration</code> 기능은 Kubernetes 1.21에서 기본적으로 활성화됩니다.
기존 트리 내 플러그인에서 <code>cinder.csi.openstack.org</code> 컨테이너 스토리지 인터페이스(CSI)
드라이버로 모든 플러그인 작업을 수행한다.
<a href=https://github.com/kubernetes/cloud-provider-openstack/blob/master/docs/cinder-csi-plugin/using-cinder-csi-plugin.md>오픈스택 Cinder CSI 드라이버</a>가
클러스터에 설치되어 있어야 한다.
<code>CSIMigrationOpenStack</code> <a href=/ko/docs/reference/command-line-tools-reference/feature-gates/>기능 게이트</a>를
<code>false</code> 로 설정하여 클러스터에 대한 Cinder CSI 마이그레이션을 비활성화할 수 있다.
<code>CSIMigrationOpenStack</code> 기능을 비활성화하면, 트리 내 Cinder 볼륨 플러그인이
Cinder 볼륨 스토리지 관리의 모든 측면을 담당한다.</p>
<h3 id=configmap>컨피그맵(configMap)</h3>
<p><a href=/docs/tasks/configure-pod-container/configure-pod-configmap/>컨피그맵</a>은
구성 데이터를 파드에 주입하는 방법을 제공한다.
컨피그맵에 저장된 데이터는 <code>configMap</code> 유형의 볼륨에서 참조되고
그런 다음에 파드에서 실행되는 컨테이너화된 애플리케이션이 소비한다.</p>
<p>컨피그맵을 참조할 때, 볼륨에 컨피그맵의 이름을
제공한다. 컨피그맵의 특정 항목에 사용할 경로를
사용자 정의할 수 있다. 다음 구성은 <code>log-config</code> 컨피그맵을
<code>configmap-pod</code> 라 부르는 파드에 마운트하는 방법을 보여준다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>configmap-pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>config-vol<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/etc/config<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>config-vol<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>configMap</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>log-config<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>items</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>log_level<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>log_level<span style=color:#bbb>
</span></code></pre></div><p><code>log-config</code> 컨피그맵은 볼륨으로 마운트되며, <code>log_level</code> 항목에
저장된 모든 컨텐츠는 파드의 <code>/etc/config/log_level</code> 경로에 마운트된다.
이 경로는 볼륨의 <code>mountPath</code> 와 <code>log_level</code> 로 키가 지정된
<code>path</code> 에서 파생된다.</p>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> <ul>
<li>
<p><a href=/docs/tasks/configure-pod-container/configure-pod-configmap/>컨피그맵</a>을 사용하기 위해서는
먼저 컨피그맵을 생성해야 한다.</p>
</li>
<li>
<p>컨피그맵을 <a href=#using-subpath><code>subPath</code></a> 볼륨 마운트로 사용하는 컨테이너는 컨피그맵
업데이트를 수신하지 않는다.</p>
</li>
<li>
<p>텍스트 데이터는 UTF-8 문자 인코딩을 사용하는 파일로 노출된다. 다른 문자 인코딩의 경우, <code>binaryData</code> 를 사용한다.</p>
</li>
</ul>
</div>
<h3 id=downwardapi>downwardAPI</h3>
<p><code>downwardAPI</code> 볼륨은 애플리케이션에서 다운워드(downward) API 데이터를 사용할 수 있도록 한다.
이것은 디렉터리를 마운트하고 요청된 데이터를 일반 텍스트 파일로 작성한다.</p>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> 다운워드 API를 <a href=#using-subpath><code>subPath</code></a> 볼륨 마운트로 사용하는 컨테이너는 다운워드 API
업데이트를 수신하지 않는다.
</div>
<p>더 자세한 내용은 <a href=/ko/docs/tasks/inject-data-application/downward-api-volume-expose-pod-information/>다운워드 API 예시</a>를 참고한다.</p>
<h3 id=emptydir>emptyDir</h3>
<p><code>emptyDir</code> 볼륨은 파드가 노드에 할당될 때 처음 생성되며,
해당 노드에서 파드가 실행되는 동안에만 존재한다. 이름에서 알 수 있듯이
<code>emptyDir</code> 볼륨은 처음에는 비어있다. 파드 내 모든 컨테이너는 <code>emptyDir</code> 볼륨에서 동일한
파일을 읽고 쓸 수 있지만, 해당 볼륨은 각각의 컨테이너에서 동일하거나
다른 경로에 마운트될 수 있다. 어떤 이유로든 노드에서 파드가 제거되면
<code>emptyDir</code> 의 데이터가 영구적으로 삭제된다.</p>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> 컨테이너가 크래시되는 것은 노드에서 파드를 제거하지 <em>않는다</em>. <code>emptyDir</code> 볼륨의 데이터는
컨테이너 크래시로부터 안전하다.
</div>
<p><code>emptyDir</code> 의 일부 용도는 다음과 같다.</p>
<ul>
<li>디스크 기반의 병합 종류와 같은 스크레치 공간</li>
<li>충돌로부터 복구하기위해 긴 계산을 검사점으로 지정</li>
<li>웹 서버 컨테이너가 데이터를 처리하는 동안 컨텐츠 매니저
컨테이너가 가져오는 파일을 보관</li>
</ul>
<p>환경에 따라, <code>emptyDir</code> 볼륨은 디스크, SSD 또는 네트워크 스토리지와
같이 노드를 지원하는 모든 매체에 저장된다. 그러나, <code>emptyDir.medium</code> 필드를
<code>"Memory"</code>로 설정하면, 쿠버네티스에 tmpfs(RAM 기반 파일시스템)를 마운트하도록 할 수 있다.
tmpfs는 매우 빠르지만, 디스크와 다르게 노드 재부팅시 tmpfs가 지워지고,
작성하는 모든 파일이 컨테이너 메모리
제한에 포함된다.</p>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> <code>SizeMemoryBackedVolumes</code> <a href=/ko/docs/reference/command-line-tools-reference/feature-gates/>기능 게이트</a>가 활성화된 경우,
메모리 기반 볼륨의 크기를 지정할 수 있다. 크기를 지정하지 않으면, 메모리
기반 볼륨의 크기는 리눅스 호스트 메모리의 50%로 조정된다.
</div>
<h4 id=emptydir-구성-예시>emptyDir 구성 예시</h4>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-pd<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/test-webserver<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-container<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/cache<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cache-volume<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cache-volume<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>emptyDir</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span></code></pre></div><h3 id=fc>fc (파이버 채널)</h3>
<p><code>fc</code> 볼륨 유형은 기존 파이버 채널 블록 스토리지 볼륨을
파드에 마운트할 수 있게 한다. 볼륨 구성에서 <code>targetWWNs</code> 파라미터를 사용하여
단일 또는 다중 대상 월드 와이드 이름(WWN)을 지정할 수 있다. 만약 여러 WWN이 지정된 경우,
targetWWN은 해당 WWN이 다중 경로 연결에서 온 것으로 예상한다.</p>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> 이러한 LUN (볼륨)을 할당하고 대상 WWN에 마스킹하도록 FC SAN Zoning을 구성해야만
쿠버네티스 호스트가 해당 LUN에 접근할 수 있다.
</div>
<p>더 자세한 내용은 <a href=https://github.com/kubernetes/examples/tree/master/staging/volumes/fibre_channel>파이버 채널 예시</a>를 참고한다.</p>
<h3 id=flocker>flocker (사용 중단됨(deprecated))</h3>
<p><a href=https://github.com/ClusterHQ/flocker>Flocker</a>는 오픈소스이고, 클러스터
컨테이너 데이터 볼륨 매니저이다. Flocker는 다양한
스토리지 백엔드가 지원하는 데이터 볼륨 관리와 오케스트레이션을 제공한다.</p>
<p><code>flocker</code> 볼륨은 Flocker 데이터셋을 파드에 마운트할 수 있게 한다. 만약
Flocker내에 데이터셋이 없는 경우, 먼저 Flocker
CLI 또는 Flocker API를 사용해서 생성해야 한다. 만약 데이터셋이 이미 있다면
Flocker는 파드가 스케줄 되어 있는 노드에 다시 연결한다. 이는 필요에
따라 파드 간에 데이터를 공유할 수 있다는 의미이다.</p>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> <code>flocker</code> 볼륨을 사용하기 위해서는 먼저 Flocker를 설치하고 실행한다.
</div>
<p>더 자세한 내용은 <a href=https://github.com/kubernetes/examples/tree/master/staging/volumes/flocker>Flocker 예시</a>를 참조한다.</p>
<h3 id=gcepersistentdisk>gcePersistentDisk</h3>
<p><code>gcePersistentDisk</code> 볼륨은 구글 컴퓨트 엔진(GCE)
<a href=https://cloud.google.com/compute/docs/disks>영구 디스크</a>(PD)를 파드에 마운트한다.
파드를 제거할 때 지워지는 <code>emptyDir</code> 와는 다르게, PD의 내용은 유지되고,
볼륨은 마운트 해제만 된다. 이는 PD에 데이터를
미리 채울 수 있으며, 파드 간에 데이터를 공유할 수 있다는 것을 의미한다.</p>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> <code>gcePersistentDisk</code> 를 사용하려면 먼저 PD를 <code>gcloud</code>, GCE API 또는 UI를 사용해서 생성해야 한다.
</div>
<p><code>gcePersistentDisk</code> 를 사용할 때 몇 가지 제한이 있다.</p>
<ul>
<li>파드가 실행 중인 노드는 GCE VM이어야 함</li>
<li>이러한 VM은 영구 디스크와 동일한 GCE 프로젝트와 영역에 있어야 함</li>
</ul>
<p>GCE 영구 디스크의 한 가지 기능은 영구 디스크에 대한 동시 읽기 전용 접근이다.
<code>gcePersistentDisk</code> 볼륨을 사용하면 여러 사용자가 영구 디스크를 읽기 전용으로
동시에 마운트할 수 있다. 즉, PD를 데이터 세트로 미리 채운 다음
필요한 만큼 많은 파드에서 병렬로 제공할 수 있다. 불행히도,
PD는 읽기-쓰기 모드에서 단일 사용자만 마운트할 수 있다. 동시
쓰기는 허용되지 않는다.</p>
<p>PD가 읽기 전용이거나 레플리카의 수가 0 또는 1이 아니라면 레플리카셋(ReplicaSet)으로 제어되는
파드가 있는 GCE 영구 디스크를 사용할 수 없다.</p>
<h4 id=gce-create-persistent-disk>GCE 영구 디스크 생성하기</h4>
<p>GCE 영구 디스크를 파드와 함께 사용하려면, 디스크를 먼저 생성해야 한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>gcloud compute disks create --size<span style=color:#666>=</span>500GB --zone<span style=color:#666>=</span>us-central1-a my-data-disk
</code></pre></div><h4 id=gce-영구-디스크-구성-예시>GCE 영구 디스크 구성 예시</h4>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-pd<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/test-webserver<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-container<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/test-pd<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-volume<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-volume<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 이 GCE PD는 이미 존재해야 한다.</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>gcePersistentDisk</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>pdName</span>:<span style=color:#bbb> </span>my-data-disk<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>fsType</span>:<span style=color:#bbb> </span>ext4<span style=color:#bbb>
</span></code></pre></div><h4 id=리전-영구-디스크>리전 영구 디스크</h4>
<p><a href=https://cloud.google.com/compute/docs/disks/#repds>리전 영구 디스크</a>
기능을 사용하면 동일한 영역 내의 두 영역에서 사용할 수 있는 영구 디스크를
생성할 수 있다. 이 기능을 사용하려면 볼륨을 퍼시스턴트볼륨(PersistentVolume)으로
프로비저닝해야 한다. 파드에서 직접 볼륨을 참조하는 것은 지원되지 않는다.</p>
<h4 id=리전-pd-퍼시스턴트볼륨을-수동으로-프로비저닝하기>리전 PD 퍼시스턴트볼륨을 수동으로 프로비저닝하기</h4>
<p><a href=/ko/docs/concepts/storage/storage-classes/#gce-pd>GCE PD용 스토리지클래스</a>를
사용해서 동적 프로비저닝이 가능하다.
퍼시스턴트볼륨을 생성하기 전에 영구 디스크를 생성해야만 한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>gcloud compute disks create --size<span style=color:#666>=</span>500GB my-data-disk
  --region us-central1
  --replica-zones us-central1-a,us-central1-b
</code></pre></div><h4 id=리전-영구-디스크-구성-예시>리전 영구 디스크 구성 예시</h4>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolume<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-volume<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>capacity</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>400Gi<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- ReadWriteOnce<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>gcePersistentDisk</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>pdName</span>:<span style=color:#bbb> </span>my-data-disk<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>fsType</span>:<span style=color:#bbb> </span>ext4<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>nodeAffinity</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>required</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>nodeSelectorTerms</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># 1.21 이전 버전에서는 failure-domain.beta.kubernetes.io/zone 키를 사용해야 한다.</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>topology.kubernetes.io/zone<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span>In<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>values</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span>- us-central1-a<span style=color:#bbb>
</span><span style=color:#bbb>          </span>- us-central1-b<span style=color:#bbb>
</span></code></pre></div><h4 id=gce-csi-마이그레이션>GCE CSI 마이그레이션</h4>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.17 [beta]</code>
</div>
<p>GCE PD의 <code>CSIMigration</code> 기능이 활성화된 경우 기존 인-트리 플러그인에서
<code>pd.csi.storage.gke.io</code> 컨테이너 스토리지 인터페이스(CSI)
드라이버로 모든 플러그인 작업을 리디렉션한다. 이 기능을 사용하려면, 클러스터에 <a href=https://github.com/kubernetes-sigs/gcp-compute-persistent-disk-csi-driver>GCE PD CSI
드라이버</a>
를 설치하고 <code>CSIMigration</code> 과 <code>CSIMigrationGCE</code>
베타 기능을 활성화해야 한다.</p>
<h4 id=gce-csi-마이그레이션-완료>GCE CSI 마이그레이션 완료</h4>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.21 [alpha]</code>
</div>
<p>컨트롤러 매니저와 kubelet이 <code>gcePersistentDisk</code> 스토리지 플러그인을 로드하는 것을 방지하려면,
<code>InTreePluginGCEUnregister</code> 플래그를 <code>true</code>로 설정한다.</p>
<h3 id=gitrepo>gitRepo (사용 중단됨)</h3>
<div class="alert alert-danger warning callout" role=alert>
<strong>경고:</strong> <code>gitRepo</code> 볼륨 유형은 사용 중단되었다. git repo가 있는 컨테이너를 프로비전 하려면 초기화 컨테이너(InitContainer)에 <a href=#emptydir>EmptyDir</a>을 마운트하고, 여기에 git을 사용해서 repo를 복제하고, <a href=#emptydir>EmptyDir</a>을 파드 컨테이너에 마운트 한다.
</div>
<p><code>gitRepo</code> 볼륨은 볼륨 플러그인의 예시이다. 이 플러그인은
빈 디렉터리를 마운트하고 파드가 사용할 수 있도록 이 디렉터리에 git 리포지터리를
복제한다.</p>
<p>여기 <code>gitRepo</code> 볼륨의 예시가 있다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>server<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/mypath<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>git-volume<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>git-volume<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>gitRepo</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>repository</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;git@somewhere:me/my-git-repository.git&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>revision</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;22f1d8406d464b0c0874075539c1f2e96c253775&#34;</span><span style=color:#bbb>
</span></code></pre></div><h3 id=glusterfs>glusterfs</h3>
<p><code>glusterfs</code> 볼륨을 사용하면 <a href=https://www.gluster.org>Glusterfs</a> (오픈
소스 네트워크 파일시스템) 볼륨을 파드에 마운트할 수 있다. 파드를
제거할 때 지워지는 <code>emptyDir</code> 와는 다르게 <code>glusterfs</code>
볼륨의 내용은 유지되고, 볼륨은 마운트 해제만 된다. 이 의미는
glusterfs 볼륨에 데이터를 미리 채울 수 있으며, 파드 간에 데이터를
공유할 수 있다. GlusterFS는 여러 작성자가 동시에
마운트할 수 있다.</p>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> 사용하려면 먼저 GlusterFS를 설치하고 실행해야 한다.
</div>
<p>더 자세한 내용은 <a href=https://github.com/kubernetes/examples/tree/master/volumes/glusterfs>GlusterFS 예시</a>를 본다.</p>
<h3 id=hostpath>hostPath</h3>
<div class="alert alert-danger warning callout" role=alert>
<strong>경고:</strong> <p>HostPath 볼륨에는 많은 보안 위험이 있으며, 가능하면 HostPath를 사용하지 않는
것이 좋다. HostPath 볼륨을 사용해야 하는 경우, 필요한 파일 또는 디렉터리로만
범위를 지정하고 ReadOnly로 마운트해야 한다.</p>
<p>AdmissionPolicy를 사용하여 특정 디렉터리로의 HostPath 액세스를 제한하는 경우,
<code>readOnly</code> 마운트를 사용하는 정책이 유효하려면 <code>volumeMounts</code> 가 반드시 지정되어야 한다.</p>
</div>
<p><code>hostPath</code> 볼륨은 호스트 노드의 파일시스템에 있는 파일이나 디렉터리를
파드에 마운트 한다. 이것은 대부분의 파드들이 필요한 것은 아니지만, 일부
애플리케이션에 강력한 탈출구를 제공한다.</p>
<p>예를 들어, <code>hostPath</code> 의 일부 용도는 다음과 같다.</p>
<ul>
<li>도커 내부에 접근할 필요가 있는 실행중인 컨테이너. <code>/var/lib/docker</code> 를
<code>hostPath</code> 로 이용함</li>
<li>컨테이너에서 cAdvisor의 실행. <code>/sys</code> 를 <code>hostPath</code> 로 이용함</li>
<li>파드는 주어진 <code>hostPath</code> 를 파드가 실행되기 이전에 있어야 하거나,
생성해야 하는지 그리고 존재해야 하는 대상을 지정할 수 있도록 허용함</li>
</ul>
<p>필요한 <code>path</code> 속성 외에도, <code>hostPath</code> 볼륨에 대한 <code>type</code> 을 마음대로 지정할 수 있다.</p>
<p>필드가 <code>type</code> 에 지원되는 값은 다음과 같다.</p>
<table>
<thead>
<tr>
<th style=text-align:left>값</th>
<th style=text-align:left>행동</th>
</tr>
</thead>
<tbody>
<tr>
<td style=text-align:left></td>
<td style=text-align:left>빈 문자열 (기본값)은 이전 버전과의 호환성을 위한 것으로, hostPath 볼륨은 마운트 하기 전에 아무런 검사도 수행되지 않는다.</td>
</tr>
<tr>
<td style=text-align:left><code>DirectoryOrCreate</code></td>
<td style=text-align:left>만약 주어진 경로에 아무것도 없다면, 필요에 따라 Kubelet이 가지고 있는 동일한 그룹과 소유권, 권한을 0755로 설정한 빈 디렉터리를 생성한다.</td>
</tr>
<tr>
<td style=text-align:left><code>Directory</code></td>
<td style=text-align:left>주어진 경로에 디렉터리가 있어야 함</td>
</tr>
<tr>
<td style=text-align:left><code>FileOrCreate</code></td>
<td style=text-align:left>만약 주어진 경로에 아무것도 없다면, 필요에 따라 Kubelet이 가지고 있는 동일한 그룹과 소유권, 권한을 0644로 설정한 빈 파일을 생성한다.</td>
</tr>
<tr>
<td style=text-align:left><code>File</code></td>
<td style=text-align:left>주어진 경로에 파일이 있어야 함</td>
</tr>
<tr>
<td style=text-align:left><code>Socket</code></td>
<td style=text-align:left>주어진 경로에 UNIX 소캣이 있어야 함</td>
</tr>
<tr>
<td style=text-align:left><code>CharDevice</code></td>
<td style=text-align:left>주어진 경로에 문자 디바이스가 있어야 함</td>
</tr>
<tr>
<td style=text-align:left><code>BlockDevice</code></td>
<td style=text-align:left>주어진 경로에 블록 디바이스가 있어야 함</td>
</tr>
</tbody>
</table>
<p>다음과 같은 이유로 이 유형의 볼륨 사용시 주의해야 한다.</p>
<ul>
<li>HostPath는 권한있는 시스템 자격 증명 (예 : Kubelet 용) 또는 권한있는 API
(예 : 컨테이너 런타임 소켓)를 노출 할 수 있으며, 이는 컨테이너 이스케이프 또는
클러스터의 다른 부분을 공격하는 데 사용될 수 있다.</li>
<li>동일한 구성(파드템플릿으로 생성한 것과 같은)을
가진 파드는 노드에 있는 파일이 다르기 때문에 노드마다 다르게 동작할 수 있다.</li>
<li>기본 호스트에 생성된 파일 또는 디렉터리는 root만 쓸 수 있다.
프로세스를 <a href=/docs/tasks/configure-pod-container/security-context/>특권을 가진(privileged) 컨테이너</a>에서
루트로 실행하거나
<code>hostPath</code> 볼륨에 쓸 수 있도록 호스트의 파일 권한을 수정해야 한다.</li>
</ul>
<h4 id=hostpath-구성-예시>hostPath 구성 예시</h4>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-pd<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/test-webserver<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-container<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/test-pd<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-volume<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-volume<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>hostPath</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 호스트의 디렉터리 위치</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/data<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 이 필드는 선택 사항이다</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Directory<span style=color:#bbb>
</span></code></pre></div><div class="alert alert-warning caution callout" role=alert>
<strong>주의:</strong> <code>FileOrCreate</code> 모드는 파일의 상위 디렉터리를 생성하지 않는다. 마운트된 파일의 상위 디렉터리가
없으면 파드가 시작되지 않는다. 이 모드가 작동하는지 확인하려면,
<a href=#hostpath-fileorcreate-example><code>FileOrCreate</code> 구성</a>에 표시된대로
디렉터리와 파일을 별도로 마운트할 수 있다.
</div>
<h4 id=hostpath-fileorcreate-example>hostPath FileOrCreate 구성 예시</h4>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-webserver<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-webserver<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/test-webserver:latest<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/var/local/aaa<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mydir<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/var/local/aaa/1.txt<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>myfile<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mydir<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>hostPath</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 파일 디렉터리가 생성되었는지 확인한다.</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/var/local/aaa<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>DirectoryOrCreate<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>myfile<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>hostPath</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/var/local/aaa/1.txt<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>FileOrCreate<span style=color:#bbb>
</span></code></pre></div><h3 id=iscsi>iscsi</h3>
<p><code>iscsi</code> 볼륨을 사용하면 기존 iSCSI (SCSI over IP) 볼륨을 파드에 마운트
할수 있다. 파드를 제거할 때 지워지는 <code>emptyDir</code> 와는
다르게 <code>iscsi</code> 볼륨의 내용은 유지되고, 볼륨은 그저 마운트
해제만 된다. 이 의미는 iscsi 볼륨에 데이터를 미리 채울 수 있으며,
파드간에 데이터를 공유할 수 있다는 것이다.</p>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> 사용하려면 먼저 iSCSI 서버를 실행하고 볼륨을 생성해야 한다.
</div>
<p>iSCSI 특징은 여러 고객이 읽기 전용으로 마운트할 수
있다는 것이다. 즉, 데이터셋으로 사전에 볼륨을 채운다음,
필요한 만큼 많은 파드에서 병렬로 제공할 수 있다. 불행하게도,
iSCSI 볼륨은 읽기-쓰기 모드에서는 단일 고객만 마운트할 수 있다.
동시 쓰기는 허용되지 않는다.</p>
<p>더 자세한 내용은 <a href=https://github.com/kubernetes/examples/tree/master/volumes/iscsi>iSCSI 예시</a>를 본다.</p>
<h3 id=local>local</h3>
<p><code>local</code> 볼륨은 디스크, 파티션 또는 디렉터리 같은 마운트된 로컬 스토리지
장치를 나타낸다.</p>
<p>로컬 볼륨은 정적으로 생성된 퍼시스턴트볼륨으로만 사용할 수 있다. 동적으로
프로비저닝된 것은 지원되지 않는다.</p>
<p><code>hostPath</code> 볼륨에 비해 <code>local</code> 볼륨은 수동으로 파드를 노드에 예약하지 않고도
내구성과 휴대성을 갖춘 방식으로 사용된다. 시스템은
퍼시스턴트볼륨의 노드 어피니티를 확인하여 볼륨의 노드 제약 조건을 인식한다.</p>
<p>그러나 <code>local</code> 볼륨은 여전히 기본 노드의 가용성을 따르며
모든 애플리케이션에 적합하지는 않는다. 만약 노드가 비정상 상태가
되면 <code>local</code> 볼륨도 접근할 수 없게 되고, 파드를 실행할 수
없게 된다. <code>local</code> 볼륨을 사용하는 애플리케이션은 기본 디스크의
내구 특성에 따라 이러한 감소되는 가용성과 데이터
손실 가능성도 허용할 수 있어야 한다.</p>
<p>다음의 예시는 <code>local</code> 볼륨과 <code>nodeAffinity</code> 를 사용하는 퍼시스턴트볼륨을
보여준다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolume<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>example-pv<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>capacity</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>100Gi<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumeMode</span>:<span style=color:#bbb> </span>Filesystem<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- ReadWriteOnce<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>persistentVolumeReclaimPolicy</span>:<span style=color:#bbb> </span>Delete<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>storageClassName</span>:<span style=color:#bbb> </span>local-storage<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>local</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/mnt/disks/ssd1<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>nodeAffinity</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>required</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>nodeSelectorTerms</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>kubernetes.io/hostname<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span>In<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>values</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span>- example-node<span style=color:#bbb>
</span></code></pre></div><p><code>local</code> 볼륨을 사용하는 경우 퍼시스턴트볼륨 <code>nodeAffinity</code> 를 설정해야 합니다.
쿠버네티스 스케줄러는 퍼시스턴트볼륨 <code>nodeAffinity</code> 를 사용하여
파드를 올바른 노드로 스케줄한다.</p>
<p>퍼시스턴트볼륨의 <code>volumeMode</code> 을 "Block" (기본값인 "Filesystem"을
대신해서)으로 설정하면 로컬 볼륨을 원시 블록 장치로 노출할 수 있다.</p>
<p>로컬 볼륨을 사용할 때는 <code>volumeBindingMode</code> 가 <code>WaitForFirstConsumer</code> 로 설정된
스토리지클래스(StorageClass)를 생성하는 것을 권장한다. 자세한 내용은
local <a href=/ko/docs/concepts/storage/storage-classes/#local>스토리지클래스(StorageClas)</a> 예제를 참고한다.
볼륨 바인딩을 지연시키는 것은 퍼시스턴트볼륨클래임 바인딩 결정도
노드 리소스 요구사항, 노드 셀렉터, 파드 어피니티 그리고 파드 안티 어피니티와
같이 파드가 가질 수 있는 다른 노드 제약 조건으로 평가되도록 만든다.</p>
<p>로컬 볼륨 라이프사이클의 향상된 관리를 위해 외부 정적
프로비저너를 별도로 실행할 수 있다. 이 프로비저너는 아직 동적
프로비저닝을 지원하지 않는 것을 참고한다. 외부 로컬 프로비저너를 실행하는 방법에 대한
예시는 <a href=https://github.com/kubernetes-sigs/sig-storage-local-static-provisioner>로컬 볼륨 프로비저너 사용자
가이드</a>를 본다.</p>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> 로컬 정적 프로비저너를 사용해서 볼륨 라이프사이클을 관리하지 않는
경우 로컬 퍼시스턴트볼륨을 수동으로 정리하고 삭제하는 것이
필요하다.
</div>
<h3 id=nfs>nfs</h3>
<p><code>nfs</code> 볼륨을 사용하면 기존 NFS (네트워크 파일 시스템) 볼륨을 파드에 마운트
할수 있다. 파드를 제거할 때 지워지는 <code>emptyDir</code> 와는
다르게 <code>nfs</code> 볼륨의 내용은 유지되고, 볼륨은 그저 마운트
해제만 된다. 이 의미는 NFS 볼륨에 데이터를 미리 채울 수 있으며,
파드 간에 데이터를 공유할 수 있다는 뜻이다. NFS는 여러 작성자가
동시에 마운트할 수 있다.</p>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> 사용하려면 먼저 NFS 서버를 실행하고 공유를 내보내야 한다.
</div>
<p>더 자세한 내용은 <a href=https://github.com/kubernetes/examples/tree/master/staging/volumes/nfs>NFS 예시</a>를 본다.</p>
<h3 id=persistentvolumeclaim>persistentVolumeClaim</h3>
<p><code>persistentVolumeClaim</code> 볼륨은
<a href=/ko/docs/concepts/storage/persistent-volumes>퍼시스턴트볼륨</a>을 파드에 마운트하는데 사용한다. 퍼시스턴트볼륨클레임은
사용자가 특정 클라우드 환경의 세부 내용을 몰라도 내구성이있는 스토리지 (GCE 퍼시스턴트디스크 또는
iSCSI 볼륨와 같은)를 "클레임" 할 수 있는 방법이다.</p>
<p>더 자세한 내용은 <a href=/ko/docs/concepts/storage/persistent-volumes>퍼시스턴트볼륨 예시</a>를
본다.</p>
<h3 id=portworxvolume>portworxVolume</h3>
<p><code>portworxVolume</code> 은 쿠버네티스와 하이퍼컨버지드(hyperconverged)를 실행하는 탄력적인 블록 스토리지
계층이다. <a href=https://portworx.com/use-case/kubernetes-storage/>Portworx</a>는 서버의
스토리지를 핑거프린팅하고(fingerprints), 기능에 기반하여 계층화하고, 그리고 여러 서버에 걸쳐 용량을 집계한다.
Portworx는 가상 머신 내 게스트 또는 베어 메탈 리눅스 노드 위에서 실행된다.</p>
<p><code>portworxVolume</code> 은 쿠버네티스를 통해 동적으로 생성되거나
사전에 프로비전할 수 있으며 쿠버네티스 파드 내에서 참조할 수 있다.
다음은 사전에 프로비저닝된 Portworx 볼륨을 참조하는 파드의 예시이다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-portworx-volume-pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/test-webserver<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-container<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/mnt<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pxvol<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pxvol<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 이 Portworx 볼륨은 이미 존재해야 한다.</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>portworxVolume</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumeID</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;pxvol&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>fsType</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&lt;fs-type&gt;&#34;</span><span style=color:#bbb>
</span></code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> 파드에서 사용하기 이전에 먼저 이름이 <code>pxvol</code> 인 PortworxVolume이
있는지 확인한다.
</div>
<p>자세한 내용은 <a href=https://github.com/kubernetes/examples/tree/master/staging/volumes/portworx/README.md>Portworx 볼륨</a> 예제를 참고한다.</p>
<h3 id=projected>projected</h3>
<p><code>Projected</code> 볼륨은 여러 기존 볼륨 소스를 동일한 디렉터리에 매핑한다.
더 자세한 사항은 <a href=/docs/concepts/storage/projected-volumes/>projected volumes</a>를 참고한다.</p>
<h3 id=quobyte>quobyte (사용 중단됨)</h3>
<p><code>quobyte</code> 볼륨을 사용하면 기존 <a href=https://www.quobyte.com>Quobyte</a> 볼륨을
파드에 마운트할 수 있다.</p>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> 사용하기 위해선 먼저 Quobyte를 설정하고 생성한 볼륨과
함께 실행해야 한다.
</div>
<p>Quobyte는 <a class=glossary-tooltip title="컨테이너 스토리지 인터페이스(CSI)는 컨테이너에 스토리지 시스템을 노출하는 표준 인터페이스를 정의한다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/storage/volumes/#csi target=_blank aria-label="컨테이너 스토리지 인터페이스">컨테이너 스토리지 인터페이스</a>를 지원한다.
CSI 는 쿠버네티스 내에서 Quobyte 볼륨을 사용하기 위해 권장하는 플러그인이다. Quobyte의
깃헙 프로젝트에는 예시와 함께 CSI를 사용해서 Quobyte를 배포하기 위한 <a href=https://github.com/quobyte/quobyte-csi#quobyte-csi>사용 설명서</a>가 있다.</p>
<h3 id=rbd>rbd</h3>
<p><code>rbd</code> 볼륨을 사용하면
<a href=https://docs.ceph.com/en/latest/rbd/>Rados Block Device</a>(RBD) 볼륨을 파드에 마운트할 수
있다. 파드를 제거할 때 지워지는 <code>emptyDir</code> 와는 다르게 <code>rbd</code> 볼륨의
내용은 유지되고, 볼륨은 마운트 해제만 된다. 이
의미는 RBD 볼륨에 데이터를 미리 채울 수 있으며, 데이터를
공유할 수 있다는 것이다.</p>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> RBD를 사용하기 위해선 먼저 Ceph를 설치하고 실행해야 한다.
</div>
<p>RBD의 특징은 여러 고객이 동시에 읽기 전용으로 마운트할 수
있다는 것이다. 즉, 데이터셋으로 볼륨을 미리 채운 다음, 필요한
만큼 많은 파드에서 병렬로 제공할수 있다. 불행하게도,
RBD는 읽기-쓰기 모드에서 단일 고객만 마운트할 수 있다.
동시 쓰기는 허용되지 않는다.</p>
<p>더 자세한 내용은 <a href=https://github.com/kubernetes/examples/tree/master/volumes/rbd>RBD 예시</a>를
참고한다.</p>
<h4 id=rbd-csi-migration>RBD CSI 마이그레이션</h4>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.23 [alpha]</code>
</div>
<p><code>RBD</code>를 위한 <code>CSIMigration</code> 기능이 활성화되어 있으면,
사용 중이 트리 내(in-tree) 플러그인의 모든 플러그인 동작을
<code>rbd.csi.ceph.com</code> <a class=glossary-tooltip title="컨테이너 스토리지 인터페이스(CSI)는 컨테이너에 스토리지 시스템을 노출하는 표준 인터페이스를 정의한다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/storage/volumes/#csi target=_blank aria-label=CSI>CSI</a>
드라이버로 리다이렉트한다.
이 기능을 사용하려면, 클러스터에
<a href=https://github.com/ceph/ceph-csi>Ceph CSI 드라이버</a>가 설치되어 있고
<code>CSIMigration</code>, <code>csiMigrationRBD</code>
<a href=/ko/docs/reference/command-line-tools-reference/feature-gates/>기능 게이트</a>가 활성화되어 있어야 한다.</p>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> <p>스토리지를 관리하는 쿠버네티스 클러스터 관리자는,
RBD CSI 드라이버로의 마이그레이션을 시도하기 전에
다음의 선행 사항을 완료해야 한다.</p>
<ul>
<li>쿠버네티스 클러스터에 Ceph CSI 드라이버 (<code>rbd.csi.ceph.com</code>) v3.5.0
이상을 설치해야 한다.</li>
<li>CSI 드라이버가 동작하기 위해 <code>clusterID</code> 필드가 필수이지만
트리 내(in-tree) 스토리지클래스는 <code>monitors</code> 필드가 필수임을 감안하여,
쿠버네티스 저장소 관리자는 monitors 값의
해시(예: <code>#echo -n '&lt;monitors_string>' | md5sum</code>)
기반으로 clusterID를 CSI 컨피그맵 내에 만들고
이 clusterID 환경 설정 아래에 monitors 필드를 유지해야 한다.</li>
<li>또한, 트리 내(in-tree) 스토리지클래스의
<code>adminId</code> 값이 <code>admin</code>이 아니면, 트리 내(in-tree) 스토리지클래스의
<code>adminSecretName</code> 값이 <code>adminId</code> 파라미터 값의
base64 값으로 패치되어야 하며, 아니면 이 단계를 건너뛸 수 있다.</li>
</ul>
<h3 id=secret>secret</h3>
<p><code>secret</code> 볼륨은 암호와 같은 민감한 정보를 파드에 전달하는데
사용된다. 쿠버네티스 API에 시크릿을 저장하고 쿠버네티스에 직접적으로 연결하지 않고도
파드에서 사용할 수 있도록 파일로 마운트 할 수 있다. <code>secret</code> 볼륨은
tmpfs(RAM 기반 파일시스템)로 지원되기 때문에 비 휘발성 스토리지에 절대
기록되지 않는다.</p>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> 사용하기 위해선 먼저 쿠버네티스 API에서 시크릿을 생성해야 한다.
</div>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> 시크릿을 <a href=#using-subpath><code>subPath</code></a> 볼륨 마운트로 사용하는 컨테이너는 시크릿
업데이트를 수신하지 못한다.
</div>
<p>더 자세한 내용은 <a href=/ko/docs/concepts/configuration/secret/>시크릿 구성하기</a>를 참고한다.</p>
<h3 id=storageos>storageOS (사용 중단됨)</h3>
<p><code>storageos</code> 볼륨을 사용하면 기존 <a href=https://www.storageos.com>StorageOS</a>
볼륨을 파드에 마운트할 수 있다.</p>
<p>StorageOS 는 쿠버네티스 환경에서 컨테이너로 실행되므로
쿠버네티스 클러스터의 모든 노드의 로컬 또는 연결된 스토리지에 접근할 수 있다.
노드 장애로부터 보호하기 위해 데이터를 복제할 수 있다. 씬(Thin) 프로비저닝과
압축은 활용률을 높이고 비용을 절감할 수 있게 한다.</p>
<p>StorageOS의 핵심은 컨테이너에 파일시스템을 통해 접근할 수 있는 블록 스토리지를 제공하는 것이다.</p>
<p>StorageOS 컨테이너는 64 비트 리눅스가 필요하고 추가적인 종속성이 없다.
무료 개발자 라이선스를 사용할 수 있다.</p>
<div class="alert alert-warning caution callout" role=alert>
<strong>주의:</strong> StorageOS 볼륨에 접근하거나 스토리지 용량을
풀에 제공할 StorageOS 컨테이너를 실행해야 한다.
설치 설명서는
<a href=https://docs.storageos.com>StorageOS 문서</a>를 찾아본다.
</div>
<p>다음의 예시는 StorageOS를 사용한 파드 구성이다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>role</span>:<span style=color:#bbb> </span>master<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-storageos-redis<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>master<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>kubernetes/redis:v1<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>MASTER<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>6379</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/redis-master-data<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>redis-data<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>redis-data<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>storageos</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># `redis-vol01` 볼륨은 StorageOS에 `default` 네임스페이스로 있어야 한다.</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>volumeName</span>:<span style=color:#bbb> </span>redis-vol01<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>fsType</span>:<span style=color:#bbb> </span>ext4<span style=color:#bbb>
</span></code></pre></div><p>StorageOS, 동적 프로비저닝과 퍼시스턴트 볼륨 클래임에 대한 더 자세한 정보는
<a href=https://github.com/kubernetes/examples/blob/master/volumes/storageos>StorageOS 예제</a>를 참고한다.</p>
<h3 id=vspherevolume>vsphereVolume</h3>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> 쿠버네티스 vSphere 클라우드 공급자를 구성해야 한다. 클라우드공급자
구성에 대해선 <a href=https://vmware.github.io/vsphere-storage-for-kubernetes/documentation/>vSphere 시작 가이드</a>를 참조한다.
</div>
<p><code>vsphereVolume</code> 은 vSphere VMDK 볼륨을 파드에 마운트하는데 사용된다. 볼륨을
마운트 해제해도 볼륨의 내용이 유지된다. VMFS와 VSAM 데이터스토어를 모두 지원한다.</p>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> 파드와 함께 사용하기 위해선 먼저 다음 방법 중 하나를 사용하여 vSphere VMDK 볼륨을 생성해야 한다.
</div>
<h4 id=creating-vmdk-volume>VMDK 볼륨 생성하기</h4>
<p>다음 중 하나를 선택해서 VMDK를 생성한다.</p>
<ul class="nav nav-tabs" id=tabs-volumes role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tabs-volumes-0 role=tab aria-controls=tabs-volumes-0 aria-selected=true>vmkfstools를 사용해서 생성</a></li>
<pre><code>    &lt;li class=&quot;nav-item&quot;&gt;&lt;a data-toggle=&quot;tab&quot; class=&quot;nav-link&quot; href=&quot;#tabs-volumes-1&quot; role=&quot;tab&quot; aria-controls=&quot;tabs-volumes-1&quot;&gt;vmware-vdiskmanager를 사용해서 생성&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;
</code></pre>
<div class=tab-content id=tabs-volumes><div id=tabs-volumes-0 class="tab-pane show active" role=tabpanel aria-labelledby=tabs-volumes-0>
<p><p>먼저 ESX에 ssh로 들어간 다음, 다음 명령을 사용해서 VMDK를 생성한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>vmkfstools -c 2G /vmfs/volumes/DatastoreName/volumes/myDisk.vmdk
</code></pre></div></div>
<div id=tabs-volumes-1 class=tab-pane role=tabpanel aria-labelledby=tabs-volumes-1>
<p><p>다음 명령을 사용해서 VMDK를 생성한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>vmware-vdiskmanager -c -t <span style=color:#666>0</span> -s 40GB -a lsilogic myDisk.vmdk
</code></pre></div></div></div>
<h4 id=vsphere-vmdk-configuration>vSphere VMDK 구성 예시</h4>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-vmdk<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/test-webserver<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-container<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/test-vmdk<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-volume<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-volume<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 이 VMDK 볼륨은 이미 있어야 한다.</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>vsphereVolume</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumePath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;[DatastoreName] volumes/myDisk&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>fsType</span>:<span style=color:#bbb> </span>ext4<span style=color:#bbb>
</span></code></pre></div><p>더 자세한 내용은 <a href=https://github.com/kubernetes/examples/tree/master/staging/volumes/vsphere>vSphere 볼륨</a> 예제를 참고한다.</p>
<h4 id=vsphere-csi-migration>vSphere CSI 마이그레이션</h4>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.19 [beta]</code>
</div>
<p><code>vsphereVolume</code> 용 <code>CSIMigration</code> 기능이 활성화되면, 기존 인-트리 플러그인에서
<code>csi.vsphere.vmware.com</code> <a class=glossary-tooltip title="컨테이너 스토리지 인터페이스(CSI)는 컨테이너에 스토리지 시스템을 노출하는 표준 인터페이스를 정의한다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/storage/volumes/#csi target=_blank aria-label=CSI>CSI</a> 드라이버로 모든 플러그인 작업을 리디렉션한다. 이 기능을 사용하려면,
<a href=https://github.com/kubernetes-sigs/vsphere-csi-driver>vSphere CSI 드라이버</a>가
클러스터에 설치되어야 하며 <code>CSIMigration</code> 및 <code>CSIMigrationvSphere</code>
<a href=/ko/docs/reference/command-line-tools-reference/feature-gates/>기능 게이트</a>가 활성화되어 있어야 한다.</p>
<p>또한 최소 vSphere vCenter/ESXi 버전은 7.0u1이고 최소 HW 버전은 VM 버전 15여야 한다.</p>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> <p>빌트인 <code>vsphereVolume</code> 플러그인의 다음 스토리지클래스 파라미터는 vSphere CSI 드라이버에서 지원되지 않는다.</p>
<ul>
<li><code>diskformat</code></li>
<li><code>hostfailurestotolerate</code></li>
<li><code>forceprovisioning</code></li>
<li><code>cachereservation</code></li>
<li><code>diskstripes</code></li>
<li><code>objectspacereservation</code></li>
<li><code>iopslimit</code></li>
</ul>
<p>이러한 파라미터를 사용하여 생성된 기존 볼륨은 vSphere CSI 드라이버로 마이그레이션되지만,
vSphere CSI 드라이버에서 생성된 새 볼륨은 이러한 파라미터를 따르지 않는다.</p>
</div>
<h4 id=vsphere-csi-migration-complete>vSphere CSI 마이그레이션 완료</h4>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.19 [beta]</code>
</div>
<p><code>vsphereVolume</code> 플러그인이 컨트롤러 관리자와 kubelet에 의해 로드되지 않도록 기능을 비활성화하려면, <code>InTreePluginvSphereUnregister</code> 기능 플래그를 <code>true</code> 로 설정해야 한다. 이를 위해서는 모든 워커 노드에 <code>csi.vsphere.vmware.com</code> <a class=glossary-tooltip title="컨테이너 스토리지 인터페이스(CSI)는 컨테이너에 스토리지 시스템을 노출하는 표준 인터페이스를 정의한다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/storage/volumes/#csi target=_blank aria-label=CSI>CSI</a> 드라이버를 설치해야 한다.</p>
<h4 id=portworx-csi-마이그레이션>Portworx CSI 마이그레이션</h4>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.23 [alpha]</code>
</div>
<p>Portworx를 위한 <code>CSIMigration</code> 기능이 쿠버네티스 1.23에 추가되었지만
알파 상태이기 때문에 기본적으로는 비활성화되어 있다.
이 기능은 사용 중이 트리 내(in-tree) 플러그인의 모든 플러그인 동작을
<code>pxd.portworx.com</code> CSI 드라이버로 리다이렉트한다.
이 기능을 사용하려면, 클러스터에 <a href=https://docs.portworx.com/portworx-install-with-kubernetes/storage-operations/csi/>Portworx CSI 드라이버</a>가
설치되어 있고, kube-controller-manager와 kubelet에 <code>CSIMigrationPortworx=true</code>로 설정해야 한다.</p>
<h2 id=using-subpath>subPath 사용하기</h2>
<p>때로는 단일 파드에서 여러 용도의 한 볼륨을 공유하는 것이 유용하다.
<code>volumeMounts.subPath</code> 속성을 사용해서 root 대신 참조하는 볼륨 내의 하위 경로를
지정할 수 있다.</p>
<p>다음의 예시는 단일 공유 볼륨을 사용하여 LAMP 스택(리눅스 Apache MySQL PHP)이
있는 파드를 구성하는 방법을 보여준다. 이 샘플 <code>subPath</code> 구성은 프로덕션 용도로
권장되지 않는다.</p>
<p>PHP 애플리케이션의 코드와 자산은 볼륨의 <code>html</code> 폴더에 매핑되고
MySQL 데이터베이스는 볼륨의 <code>mysql</code> 폴더에 저장된다. 예를 들면 다음과 같다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-lamp-site<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>MYSQL_ROOT_PASSWORD<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;rootpasswd&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/var/lib/mysql<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>site-data<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>subPath</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>php<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>php:7.0-apache<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/var/www/html<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>site-data<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>subPath</span>:<span style=color:#bbb> </span>html<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>site-data<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>persistentVolumeClaim</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>claimName</span>:<span style=color:#bbb> </span>my-lamp-site-data<span style=color:#bbb>
</span></code></pre></div><h3 id=using-subpath-expanded-environment>subPath를 확장된 환경 변수와 함께 사용하기</h3>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.17 [stable]</code>
</div>
<p><code>subPathExpr</code> 필드를 사용해서 다운워드 API 환경 변수로부터
<code>subPath</code> 디렉터리 이름을 구성한다.
<code>subPath</code> 와 <code>subPathExpr</code> 속성은 상호 배타적이다.</p>
<p>이 예제는 <code>Pod</code> 가 <code>subPathExpr</code> 을 사용해서 <code>hostPath</code> 볼륨
<code>/var/log/pods</code> 내에 <code>pod1</code> 디렉터리를 만든다.
<code>hostPath</code> 볼륨은 <code>downwardAPI</code> 에서 <code>Pod</code> 이름을 사용한다.
호스트 디렉토리 <code>/var/log/pods/pod1</code> 은 컨테이너의 <code>/logs</code> 에 마운트된다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pod1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>container1<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>POD_NAME<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>fieldRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>fieldPath</span>:<span style=color:#bbb> </span>metadata.name<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#bbb> </span><span style=color:#b44>&#34;sh&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;-c&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;while [ true ]; do echo &#39;Hello&#39;; sleep 10; done | tee -a /logs/hello.txt&#34;</span><span style=color:#bbb> </span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>workdir1<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/logs<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 변수 확장에는 괄호를 사용한다(중괄호 아님).</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>subPathExpr</span>:<span style=color:#bbb> </span>$(POD_NAME)<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>workdir1<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>hostPath</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/var/log/pods<span style=color:#bbb>
</span></code></pre></div><h2 id=리소스>리소스</h2>
<p><code>emptyDir</code> 볼륨의 스토리지 매체(디스크나 SSD와 같은)는 kubelet root
디렉터리(보통 <code>/var/lib/kubelet</code>)를 보유한 파일시스템의
매체에 의해 결정 된다. <code>emptyDir</code> 또는 <code>hostPath</code> 볼륨이
사용할 수 있는 공간의 크기는 제한이 없으며, 컨테이너 간 또는 파드 간 격리는
없다.</p>
<p>리소스 사양을 사용한 공간 요청에 대한 자세한 내용은
<a href=/ko/docs/concepts/configuration/manage-resources-containers/>리소스 관리 방법</a>을 참고한다.</p>
<h2 id=아웃-오브-트리-out-of-tree-볼륨-플러그인>아웃-오브-트리(out-of-tree) 볼륨 플러그인</h2>
<p>아웃-오브-트리 볼륨 플러그인에는
<a class=glossary-tooltip title="컨테이너 스토리지 인터페이스(CSI)는 컨테이너에 스토리지 시스템을 노출하는 표준 인터페이스를 정의한다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/storage/volumes/#csi target=_blank aria-label="컨테이너 스토리지 인터페이스">컨테이너 스토리지 인터페이스</a>(CSI) 그리고 FlexVolume(사용 중단됨)이 포함된다. 이러한 플러그인을 사용하면 스토리지 벤더들은 플러그인 소스 코드를 쿠버네티스 리포지터리에
추가하지 않고도 사용자 정의 스토리지 플러그인을 만들 수 있다.</p>
<p>이전에는 모든 볼륨 플러그인이 "인-트리(in-tree)"에 있었다. "인-트리" 플러그인은 쿠버네티스 핵심 바이너리와
함께 빌드, 링크, 컴파일 및 배포되었다. 즉, 쿠버네티스(볼륨 플러그인)에
새로운 스토리지 시스템을 추가하려면 쿠버네티스 핵심 코드 리포지토리의 코드 확인이 필요했음을 의미한다.</p>
<p>CSI와 FlexVolume을 통해 쿠버네티스 코드 베이스와는
독립적으로 볼륨 플러그인을 개발하고, 쿠버네티스 클러스터의 확장으로 배포(설치)
할 수 있다.</p>
<p>아웃 오브 트리(out-of-tree) 볼륨 플러그인을 생성하려는 스토리지 벤더는
<a href=https://github.com/kubernetes/community/blob/master/sig-storage/volume-plugin-faq.md>볼륨 플러그인 FAQ</a>를 참조한다.</p>
<h3 id=csi>csi</h3>
<p><a href=https://github.com/container-storage-interface/spec/blob/master/spec.md>컨테이너 스토리지 인터페이스</a>(CSI)는
컨테이너 오케스트레이션 시스템(쿠버네티스와 같은)을 위한 표준 인터페이스를
정의하여 임의의 스토리지 시스템을 컨테이너 워크로드에 노출시킨다.</p>
<p>더 자세한 정보는 <a href=https://github.com/kubernetes/community/blob/master/contributors/design-proposals/storage/container-storage-interface.md>CSI 디자인 제안</a>을 읽어본다.</p>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> CSI 규격 버전 0.2와 0.3에 대한 지원은 쿠버네티스 v1.13에서 사용중단(deprecated)
되었고, 향후 릴리스에서 제거될 예정이다.
</div>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> CSI 드라이버는 일부 쿠버네티스 릴리스에서 호환되지 않을 수 있다.
각각의 쿠버네티스 릴리스와 호환성 매트릭스에 대해 지원되는
배포 단계는 특정 CSI 드라이버 문서를 참조한다.
</div>
<p>CSI 호환 볼륨 드라이버가 쿠버네티스 클러스터에 배포되면
사용자는 <code>csi</code> 볼륨 유형을 사용해서 CSI 드라이버에 의해 노출된 볼륨에 연결하거나
마운트할 수 있다.</p>
<p><code>csi</code> 볼륨은 세 가지 방법으로 파드에서 사용할 수 있다.</p>
<ul>
<li><a href=#persistentvolumeclaim>퍼시스턴트볼륨클레임</a>에 대한 참조를 통해서</li>
<li><a href=/docs/concepts/storage/ephemeral-volumes/#generic-ephemeral-volume>일반 임시 볼륨</a>과 함께
(알파 기능)</li>
<li>드라이버가 지원하는 경우
<a href=/docs/concepts/storage/ephemeral-volumes/#csi-ephemeral-volume>CSI 임시 볼륨</a>과 함께 (베타 기능)</li>
</ul>
<p>스토리지 관리자가 다음 필드를 사용해서 CSI 퍼시스턴트 볼륨을
구성할 수 있다.</p>
<ul>
<li><code>driver</code>: 사용할 볼륨 드라이버의 이름을 지정하는 문자열 값.
이 값은 <a href=https://github.com/container-storage-interface/spec/blob/master/spec.md#getplugininfo>CSI 사양</a>에
정의된 CSI 드라이버가 <code>GetPluginInfoResponse</code> 에 반환하는 값과 일치해야 한다.
쿠버네티스에서 호출할 CSI 드라이버를 식별하고, CSI 드라이버 컴포넌트에서
CSI 드라이버에 속하는 PV 오브젝트를 식별하는데 사용한다.</li>
<li><code>volumeHandle</code>: 볼륨을 식별하게 하는 고유한 문자열 값.
이 값은 <a href=https://github.com/container-storage-interface/spec/blob/master/spec.md#createvolume>CSI 사양</a>에
정의된 CSI 드라이버가 <code>CreateVolumeResponse</code> 의 <code>volume.id</code> 필드에 반환하는 값과 일치해야 한다.
이 값은 볼륨을 참조할 때 CSI 볼륨 드라이버에 대한 모든 호출에
<code>volume_id</code> 값을 전달한다.</li>
<li><code>readOnly</code>: 볼륨을 읽기 전용으로 "ControllerPublished" (연결)할지
여부를 나타내는 선택적인 불리언(boolean) 값. 기본적으로 false 이다. 이 값은
<code>ControllerPublishVolumeRequest</code> 의 <code>readonly</code> 필드를
통해 CSI 드라이버로 전달된다.</li>
<li><code>fsType</code>: 만약 PV의 <code>VolumeMode</code> 가 <code>Filesystem</code> 인 경우에 이 필드는
볼륨을 마운트하는 데 사용해야 하는 파일시스템을 지정하는 데 사용될 수 있다. 만약
볼륨이 포맷되지 않았고 포맷이 지원되는 경우, 이 값은
볼륨을 포맷하는데 사용된다.
이 값은 <code>ControllerPublishVolumeRequest</code>, <code>NodeStageVolumeRequest</code>
그리고 <code>NodePublishVolumeRequest</code> 의 <code>VolumeCapability</code>
필드를 통해 CSI 드라이버로 전달된다.</li>
<li><code>volumeAttributes</code>: 볼륨의 정적 속성을 지정하는 문자열과 문자열을
매핑한다. 이 매핑은 <a href=https://github.com/container-storage-interface/spec/blob/master/spec.md#createvolume>CSI 사양</a>에
정의된 대로 CSI 드라이버의 <code>CreateVolumeResponse</code> 와 <code>volume.attributes</code>
필드에서 반환되는 매핑과 일치해야 한다.
이 매핑은 <code>ControllerPublishVolumeRequest</code>, <code>NodeStageVolumeRequest</code>,
그리고 <code>NodePublishVolumeRequest</code> 의 <code>volume_context</code> 필드를
통해 CSI 드라이버로 전달된다.</li>
<li><code>controllerPublishSecretRef</code>: CSI의 <code>ControllerPublishVolume</code>
그리고 <code>ControllerUnpublishVolume</code> 호출을 완료하기 위해 CSI 드라이버에 전달하려는
민감한 정보가 포함된 시크릿 오브젝트에 대한 참조이다. 이 필드는
선택 사항이며, 시크릿이 필요하지 않은 경우 비어있을 수 있다. 만약 시크릿에
둘 이상의 시크릿이 포함된 경우에도 모든 시크릿이 전달된다.</li>
<li><code>nodeStageSecretRef</code>: CSI의 <code>NodeStageVolume</code> 호출을 완료하기위해
CSI 드라이버에 전달하려는 민감한 정보가 포함 된 시크릿
오브젝트에 대한 참조이다. 이 필드는 선택 사항이며, 시크릿이 필요하지 않은
경우 비어있을 수 있다. 만약 시크릿에 둘 이상의 시크릿이 포함된 경우에도
모든 시크릿이 전달된다.</li>
<li><code>nodePublishSecretRef</code>: CSI의 <code>NodePublishVolume</code> 호출을 완료하기위해
CSI 드라이버에 전달하려는 민감한 정보가 포함 된 시크릿
오브젝트에 대한 참조이다. 이 필드는 선택 사항이며, 시크릿이 필요하지 않은
경우 비어있을 수 있다. 만약 시크릿 오브젝트에 둘 이상의 시크릿이 포함된 경우에도
모든 시크릿이 전달된다.</li>
</ul>
<h4 id=csi-원시-raw-블록-볼륨-지원>CSI 원시(raw) 블록 볼륨 지원</h4>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.18 [stable]</code>
</div>
<p>외부 CSI 드라이버가 있는 벤더들은 쿠버네티스 워크로드에서 원시(raw) 블록 볼륨
지원을 구현할 수 있다.</p>
<p>CSI 설정 변경 없이 평소와 같이
<a href=/ko/docs/concepts/storage/persistent-volumes/#%EC%9B%90%EC%8B%9C-%EB%B8%94%EB%A1%9D-%EB%B3%BC%EB%A5%A8-%EC%A7%80%EC%9B%90>원시 블록 볼륨 지원으로 퍼시스턴트볼륨/퍼시스턴트볼륨클레임</a> 설정을 할 수 있다.</p>
<h4 id=csi-임시-ephemeral-볼륨>CSI 임시(ephemeral) 볼륨</h4>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.16 [beta]</code>
</div>
<p>파드 명세 내에서 CSI 볼륨을 직접 구성할 수
있다. 이 방식으로 지정된 볼륨은 임시 볼륨이며
파드가 다시 시작할 때 지속되지 않는다. 자세한 내용은 <a href=/docs/concepts/storage/ephemeral-volumes/#csi-ephemeral-volumes>임시
볼륨</a>을
참고한다.</p>
<p>CSI 드라이버의 개발 방법에 대한 더 자세한 정보는
<a href=https://kubernetes-csi.github.io/docs/>쿠버네티스-csi 문서</a>를 참조한다.</p>
<h4 id=인-트리-플러그인으로부터-csi-드라이버로-마이그레이션하기>인-트리 플러그인으로부터 CSI 드라이버로 마이그레이션하기</h4>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.17 [beta]</code>
</div>
<p><code>CSIMigration</code> 기능이 활성화 되면 기존의 인-트리 플러그인에
대한 작업을 해당 CSI 플러그인(설치와 구성이 될 것으로 예상한)으로 유도한다.
결과적으로, 운영자는 인-트리 플러그인을 대체하는
CSI 드라이버로 전환할 때 기존 스토리지 클래스, 퍼시스턴트볼륨 또는 퍼시스턴트볼륨클레임(인-트리 플러그인 참조)에
대한 구성 변경을 수행할 필요가 없다.</p>
<p>지원되는 작업 및 기능은 프로비저닝/삭제,
연결/분리, 마운트/마운트 해제 그리고 볼륨 크기 재조정이 포함된다.</p>
<p><code>CSIMigration</code> 을 지원하고 해당 CSI 드라이버가 구현된 인-트리 플러그인은
<a href=#volume-types>볼륨 유형들</a>에 나열되어 있다.</p>
<h3 id=flexvolume>flexVolume</h3>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.23 [deprecated]</code>
</div>
<p>FlexVolume은 스토리지 드라이버와 인터페이싱하기 위해 exec 기반 모델을 사용하는 아웃-오브-트리 플러그인 인터페이스이다.
FlexVolume 드라이버 바이너리 파일은 각 노드의 미리 정의된 볼륨 플러그인 경로에 설치되어야 하며,
일부 경우에는 컨트롤 플레인 노드에도 설치되어야 한다.</p>
<p>파드는 <code>flexvolume</code> 인-트리 볼륨 플러그인을 통해 FlexVolume 드라이버와 상호 작용한다.
더 자세한 내용은 FlexVolume <a href=https://github.com/kubernetes/community/blob/master/contributors/devel/sig-storage/flexvolume.md#readme>README</a> 문서를 참고한다.</p>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> <p>FlexVolume은 사용 중단되었다. 쿠버네티스에 외부 스토리지를 연결하려면 아웃-오브-트리 CSI 드라이버를 사용하는 것을 권장한다.</p>
<p>FlexVolume 드라이버 메인테이너는 CSI 드라이버를 구현하고 사용자들이 FlexVolume 드라이버에서 CSI로 마이그레이트할 수 있도록 지원해야 한다.
FlexVolume 사용자는 워크로드가 동등한 CSI 드라이버를 사용하도록 이전해야 한다.</p>
</div>
<h2 id=마운트-전파-propagation>마운트 전파(propagation)</h2>
<p>마운트 전파를 통해 컨테이너가 마운트한 볼륨을 동일한 파드의
다른 컨테이너 또는 동일한 노드의 다른 파드로 공유할 수 있다.</p>
<p>볼륨 마운트 전파는 <code>Container.volumeMounts</code> 의 <code>mountPropagation</code> 필드에
의해 제어된다. 그 값은 다음과 같다.</p>
<ul>
<li>
<p><code>None</code> - 이 볼륨 마운트는 호스트의 볼륨 또는 해당 서브디렉터리에
마운트된 것을 마운트 이후에 수신하지 않는다.
비슷한 방식으로, 컨테이너가 생성한 마운트는 호스트에서 볼 수 없다.
이것이 기본 모드이다.</p>
<p>이 모드는 <a href=https://www.kernel.org/doc/Documentation/filesystems/sharedsubtree.txt>리눅스 커널 문서</a>에
설명된 <code>rshared</code> 마운트 전파와 같다.</p>
</li>
<li>
<p><code>HostToContainer</code> - 이 볼륨 마운트는 볼륨 또는 해당
서브디렉터리를 마운트한 정보를 수신한다.</p>
<p>다시 말하면, 만약 호스트가 볼륨 마운트 내부에 다른 것을 마운트
하더라도 컨테이너가 마운트된 것을 볼 수 있다.</p>
<p>마찬가지로 <code>Bidirectional</code> 마운트 전파가 있는 파드가 동일한 마운트가 된 경우에
파드에 <code>HostToContainer</code> 마운트 전파가 있는
컨테이너가 이를 볼 수 있다.</p>
<p>이 모드는 <a href=https://www.kernel.org/doc/Documentation/filesystems/sharedsubtree.txt>리눅스 커널 문서</a>에
설명된 <code>rshared</code> 마운트 전파와 같다.</p>
</li>
<li>
<p><code>Bidirectional</code> - 이 볼륨 마운트는 <code>HostToContainer</code> 마운트와 동일하게 작동한다.
추가로 컨테이너에서 생성된 모든 볼륨 마운트는 동일한 볼륨을
사용하는 모든 파드의 모든 컨테이너와 호스트로 다시 전파된다.</p>
<p>이 모드의 일반적인 유스 케이스로는 FlexVolume 또는 CSI 드라이버를 사용하는 파드 또는
<code>hostPath</code> 볼륨을 사용하는 호스트에 무언가를 마운트해야 하는 파드이다.</p>
<p>이 모드는 <a href=https://www.kernel.org/doc/Documentation/filesystems/sharedsubtree.txt>리눅스 커널 문서</a>에
설명된 <code>rshared</code> 마운트 전파와 같다.</p>
</li>
</ul>
<div class="alert alert-danger warning callout" role=alert>
<strong>경고:</strong> <code>Bidirectional</code> 마운트 전파는 위험할 수 있다. 이것은
호스트 운영체제를 손상시킬 수 있기에 권한이 있는 컨테이너에서만
허용된다. 리눅스 커널 동작을 숙지하는 것을 권장한다.
또한 파드 내 컨테이너에 의해 생성된 볼륨 마운트는 종료 시
컨테이너에 의해 파괴(마운트 해제)되어야 한다.
</div>
<h3 id=구성>구성</h3>
<p>일부 배포판(CoreOS, RedHat/Centos, Ubuntu)에서 마운트 전파가
제대로 작동하려면 아래와 같이 도커에서의 마운트 공유를
올바르게 구성해야 한다.</p>
<p>도커의 <code>systemd</code> 서비스 파일을 편집한다. <code>MountFlags</code> 를 다음과 같이 설정한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#b8860b>MountFlags</span><span style=color:#666>=</span>shared
</code></pre></div><p>또는 <code>MountFlags=slave</code> 가 있으면 제거한다. 이후 도커 데몬을 재시작 한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>sudo systemctl daemon-reload
sudo systemctl restart docker
</code></pre></div><h2 id=다음-내용>다음 내용</h2>
<p><a href=/ko/docs/tutorials/stateful-application/mysql-wordpress-persistent-volume/>퍼시스턴트 볼륨과 함께 워드프레스와 MySQL 배포하기</a>의 예시를 따른다.</p>
</div>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-ffd12528a12882b282e1bd19e29f9e75>6.2 - 퍼시스턴트 볼륨</h1>
<p>이 페이지에서는 쿠버네티스의 <em>퍼시스턴트 볼륨</em> 에 대해 설명한다. <a href=/ko/docs/concepts/storage/volumes/>볼륨</a>에 대해 익숙해지는 것을 추천한다.</p>
<h2 id=소개>소개</h2>
<p>스토리지 관리는 컴퓨트 인스턴스 관리와는 별개의 문제다. 퍼시스턴트볼륨 서브시스템은 사용자 및 관리자에게 스토리지 사용 방법에서부터 스토리지가 제공되는 방법에 대한 세부 사항을 추상화하는 API를 제공한다. 이를 위해 퍼시스턴트볼륨 및 퍼시스턴트볼륨클레임이라는 두 가지 새로운 API 리소스를 소개한다.</p>
<p><em>퍼시스턴트볼륨</em> (PV)은 관리자가 프로비저닝하거나 <a href=/ko/docs/concepts/storage/storage-classes/>스토리지 클래스</a>를 사용하여 동적으로 프로비저닝한 클러스터의 스토리지이다. 노드가 클러스터 리소스인 것처럼 PV는 클러스터 리소스이다. PV는 Volumes와 같은 볼륨 플러그인이지만, PV를 사용하는 개별 파드와는 별개의 라이프사이클을 가진다. 이 API 오브젝트는 NFS, iSCSI 또는 클라우드 공급자별 스토리지 시스템 등 스토리지 구현에 대한 세부 정보를 담아낸다.</p>
<p><em>퍼시스턴트볼륨클레임</em> (PVC)은 사용자의 스토리지에 대한 요청이다. 파드와 비슷하다. 파드는 노드 리소스를 사용하고 PVC는 PV 리소스를 사용한다. 파드는 특정 수준의 리소스(CPU 및 메모리)를 요청할 수 있다. 클레임은 특정 크기 및 접근 모드를 요청할 수 있다(예: ReadWriteOnce, ReadOnlyMany 또는 ReadWriteMany로 마운트 할 수 있음. <a href=#%EC%A0%91%EA%B7%BC-%EB%AA%A8%EB%93%9C>AccessModes</a> 참고).</p>
<p>퍼시스턴트볼륨클레임을 사용하면 사용자가 추상화된 스토리지 리소스를 사용할 수 있지만, 다른 문제들 때문에 성능과 같은 다양한 속성을 가진 퍼시스턴트볼륨이 필요한 경우가 일반적이다. 클러스터 관리자는 사용자에게 해당 볼륨의 구현 방법에 대한 세부 정보를 제공하지 않고 크기와 접근 모드와는 다른 방식으로 다양한 퍼시스턴트볼륨을 제공할 수 있어야 한다. 이러한 요구에는 <em>스토리지클래스</em> 리소스가 있다.</p>
<p><a href=/ko/docs/tasks/configure-pod-container/configure-persistent-volume-storage/>실습 예제와 함께 상세한 내용</a>을 참고하길 바란다.</p>
<h2 id=볼륨과-클레임-라이프사이클>볼륨과 클레임 라이프사이클</h2>
<p>PV는 클러스터 리소스이다. PVC는 해당 리소스에 대한 요청이며 리소스에 대한 클레임 검사 역할을 한다. PV와 PVC 간의 상호 작용은 다음 라이프사이클을 따른다.</p>
<h3 id=프로비저닝>프로비저닝</h3>
<p>PV를 프로비저닝 할 수 있는 두 가지 방법이 있다: 정적(static) 프로비저닝과 동적(dynamic) 프로비저닝</p>
<h4 id=정적-프로비저닝>정적 프로비저닝</h4>
<p>클러스터 관리자는 여러 PV를 만든다. 클러스터 사용자가 사용할 수 있는 실제 스토리지의 세부 사항을 제공한다. 이 PV들은 쿠버네티스 API에 존재하며 사용할 수 있다.</p>
<h4 id=동적-프로비저닝>동적 프로비저닝</h4>
<p>관리자가 생성한 정적 PV가 사용자의 퍼시스턴트볼륨클레임과 일치하지 않으면
클러스터는 PVC를 위해 특별히 볼륨을 동적으로 프로비저닝 하려고 시도할 수 있다.
이 프로비저닝은 스토리지클래스를 기반으로 한다. PVC는
<a href=/ko/docs/concepts/storage/storage-classes/>스토리지 클래스</a>를
요청해야 하며 관리자는 동적 프로비저닝이 발생하도록 해당 클래스를 생성하고 구성해야 한다.
<code>""</code> 클래스를 요청하는 클레임은 동적 프로비저닝을 효과적으로
비활성화한다.</p>
<p>스토리지 클래스를 기반으로 동적 스토리지 프로비저닝을 사용하려면 클러스터 관리자가 API 서버에서
<code>DefaultStorageClass</code> <a href=/docs/reference/access-authn-authz/admission-controllers/#defaultstorageclass>어드미션 컨트롤러</a>를 사용하도록 설정해야 한다.
예를 들어 API 서버 컴포넌트의 <code>--enable-admission-plugins</code> 플래그에 대한 쉼표로 구분되어
정렬된 값들의 목록 중에 <code>DefaultStorageClass</code>가 포함되어 있는지 확인하여 설정할 수 있다.
API 서버 커맨드라인 플래그에 대한 자세한 정보는
<a href=/docs/admin/kube-apiserver/>kube-apiserver</a> 문서를 확인하면 된다.</p>
<h3 id=바인딩>바인딩</h3>
<p>사용자는 원하는 특정 용량의 스토리지와 특정 접근 모드로 퍼시스턴트볼륨클레임을 생성하거나 동적 프로비저닝의 경우 이미 생성한 상태다. 마스터의 컨트롤 루프는 새로운 PVC를 감시하고 일치하는 PV(가능한 경우)를 찾아 서로 바인딩한다. PV가 새 PVC에 대해 동적으로 프로비저닝된 경우 루프는 항상 해당 PV를 PVC에 바인딩한다. 그렇지 않으면 사용자는 항상 최소한 그들이 요청한 것을 얻지만 볼륨은 요청된 것을 초과할 수 있다. 일단 바인딩되면 퍼시스턴트볼륨클레임은 어떻게 바인딩되었는지 상관없이 배타적으로 바인딩된다. PVC 대 PV 바인딩은 일대일 매핑으로, 퍼시스턴트볼륨과 퍼시스턴트볼륨클레임 사이의 양방향 바인딩인 ClaimRef를 사용한다.</p>
<p>일치하는 볼륨이 없는 경우 클레임은 무한정 바인딩되지 않은 상태로 남아 있다. 일치하는 볼륨이 제공되면 클레임이 바인딩된다. 예를 들어 많은 수의 50Gi PV로 프로비저닝된 클러스터는 100Gi를 요청하는 PVC와 일치하지 않는다. 100Gi PV가 클러스터에 추가되면 PVC를 바인딩할 수 있다.</p>
<h3 id=사용-중>사용 중</h3>
<p>파드는 클레임을 볼륨으로 사용한다. 클러스터는 클레임을 검사하여 바인딩된 볼륨을 찾고 해당 볼륨을 파드에 마운트한다. 여러 접근 모드를 지원하는 볼륨의 경우 사용자는 자신의 클레임을 파드에서 볼륨으로 사용할 때 원하는 접근 모드를 지정한다.</p>
<p>일단 사용자에게 클레임이 있고 그 클레임이 바인딩되면, 바인딩된 PV는 사용자가 필요로 하는 한 사용자에게 속한다. 사용자는 파드의 <code>volumes</code> 블록에 <code>persistentVolumeClaim</code>을 포함하여 파드를 스케줄링하고 클레임한 PV에 접근한다. 이에 대한 자세한 내용은 <a href=#%EB%B3%BC%EB%A5%A8%EC%9C%BC%EB%A1%9C-%ED%81%B4%EB%A0%88%EC%9E%84%ED%95%98%EA%B8%B0>볼륨으로 클레임하기</a>를 참고하길 바란다.</p>
<h3 id=사용-중인-스토리지-오브젝트-보호>사용 중인 스토리지 오브젝트 보호</h3>
<p>사용 중인 스토리지 오브젝트 보호 기능의 목적은 PVC에 바인딩된 파드와 퍼시스턴트볼륨(PV)이 사용 중인 퍼시스턴트볼륨클레임(PVC)을 시스템에서 삭제되지 않도록 하는 것이다. 삭제되면 이로 인해 데이터의 손실이 발생할 수 있기 때문이다.</p>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> PVC를 사용하는 파드 오브젝트가 존재하면 파드가 PVC를 사용하고 있는 상태이다.
</div>
<p>사용자가 파드에서 활발하게 사용 중인 PVC를 삭제하면 PVC는 즉시 삭제되지 않는다. PVC가 더 이상 파드에서 적극적으로 사용되지 않을 때까지 PVC 삭제가 연기된다. 또한 관리자가 PVC에 바인딩된 PV를 삭제하면 PV는 즉시 삭제되지 않는다. PV가 더 이상 PVC에 바인딩되지 않을 때까지 PV 삭제가 연기된다.</p>
<p>PVC의 상태가 <code>Terminating</code>이고 <code>Finalizers</code> 목록에 <code>kubernetes.io/pvc-protection</code>이 포함되어 있으면 PVC가 보호된 것으로 볼 수 있다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe pvc hostpath
Name:          hostpath
Namespace:     default
StorageClass:  example-hostpath
Status:        Terminating
Volume:
Labels:        &lt;none&gt;
Annotations:   volume.beta.kubernetes.io/storage-class<span style=color:#666>=</span>example-hostpath
               volume.beta.kubernetes.io/storage-provisioner<span style=color:#666>=</span>example.com/hostpath
Finalizers:    <span style=color:#666>[</span>kubernetes.io/pvc-protection<span style=color:#666>]</span>
...
</code></pre></div><p>마찬가지로 PV 상태가 <code>Terminating</code>이고 <code>Finalizers</code> 목록에 <code>kubernetes.io/pv-protection</code>이 포함되어 있으면 PV가 보호된 것으로 볼 수 있다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe pv task-pv-volume
Name:            task-pv-volume
Labels:          <span style=color:#b8860b>type</span><span style=color:#666>=</span><span style=color:#a2f>local</span>
Annotations:     &lt;none&gt;
Finalizers:      <span style=color:#666>[</span>kubernetes.io/pv-protection<span style=color:#666>]</span>
StorageClass:    standard
Status:          Terminating
Claim:
Reclaim Policy:  Delete
Access Modes:    RWO
Capacity:        1Gi
Message:
Source:
    Type:          HostPath <span style=color:#666>(</span>bare host directory volume<span style=color:#666>)</span>
    Path:          /tmp/data
    HostPathType:
Events:            &lt;none&gt;
</code></pre></div><h3 id=반환-reclaiming>반환(Reclaiming)</h3>
<p>사용자가 볼륨을 다 사용하고나면 리소스를 반환할 수 있는 API를 사용하여 PVC 오브젝트를 삭제할 수 있다. 퍼시스턴트볼륨의 반환 정책은 볼륨에서 클레임을 해제한 후 볼륨에 수행할 작업을 클러스터에 알려준다. 현재 볼륨에 대한 반환 정책은 Retain, Recycle, 그리고 Delete가 있다.</p>
<h4 id=retain-보존>Retain(보존)</h4>
<p><code>Retain</code> 반환 정책은 리소스를 수동으로 반환할 수 있게 한다. 퍼시스턴트볼륨클레임이 삭제되면 퍼시스턴트볼륨은 여전히 존재하며 볼륨은 "릴리스 된" 것으로 간주된다. 그러나 이전 요청자의 데이터가 여전히 볼륨에 남아 있기 때문에 다른 요청에 대해서는 아직 사용할 수 없다. 관리자는 다음 단계에 따라 볼륨을 수동으로 반환할 수 있다.</p>
<ol>
<li>퍼시스턴트볼륨을 삭제한다. PV가 삭제된 후에도 외부 인프라(예: AWS EBS, GCE PD, Azure Disk 또는 Cinder 볼륨)의 관련 스토리지 자산이 존재한다.</li>
<li>관련 스토리지 자산의 데이터를 수동으로 삭제한다.</li>
<li>연결된 스토리지 자산을 수동으로 삭제한다.</li>
</ol>
<p>동일한 스토리지 자산을 재사용하려는 경우, 동일한 스토리지 자산 정의로 새 퍼시스턴트볼륨을 생성한다.</p>
<h4 id=delete-삭제>Delete(삭제)</h4>
<p><code>Delete</code> 반환 정책을 지원하는 볼륨 플러그인의 경우, 삭제는 쿠버네티스에서 퍼시스턴트볼륨 오브젝트와 외부 인프라(예: AWS EBS, GCE PD, Azure Disk 또는 Cinder 볼륨)의 관련 스토리지 자산을 모두 삭제한다. 동적으로 프로비저닝된 볼륨은 <a href=#%EB%B0%98%ED%99%98-%EC%A0%95%EC%B1%85>스토리지클래스의 반환 정책</a>을 상속하며 기본값은 <code>Delete</code>이다. 관리자는 사용자의 기대에 따라 스토리지클래스를 구성해야 한다. 그렇지 않으면 PV를 생성한 후 PV를 수정하거나 패치해야 한다. <a href=/ko/docs/tasks/administer-cluster/change-pv-reclaim-policy/>퍼시스턴트볼륨의 반환 정책 변경</a>을 참고하길 바란다.</p>
<h4 id=recycle-재활용>Recycle(재활용)</h4>
<div class="alert alert-danger warning callout" role=alert>
<strong>경고:</strong> <code>Recycle</code> 반환 정책은 더 이상 사용하지 않는다. 대신 권장되는 방식은 동적 프로비저닝을 사용하는 것이다.
</div>
<p>기본 볼륨 플러그인에서 지원하는 경우 <code>Recycle</code> 반환 정책은 볼륨에서 기본 스크럽(<code>rm -rf /thevolume/*</code>)을 수행하고 새 클레임에 다시 사용할 수 있도록 한다.</p>
<p>그러나 관리자는 <a href=/docs/reference/command-line-tools-reference/kube-controller-manager/>레퍼런스</a>에
설명된 대로 쿠버네티스 컨트롤러 관리자 커맨드라인 인자(command line arguments)를
사용하여 사용자 정의 재활용 파드 템플릿을 구성할 수 있다.
사용자 정의 재활용 파드 템플릿에는 아래 예와 같이 <code>volumes</code> 명세가
포함되어야 한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pv-recycler<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>vol<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>hostPath</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/any/path/it/will/be/replaced<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pv-recycler<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;k8s.gcr.io/busybox&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;/bin/sh&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;-c&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;test -e /scrub &amp;&amp; rm -rf /scrub/..?* /scrub/.[!.]* /scrub/*  &amp;&amp; test -z \&#34;$(ls -A /scrub)\&#34; || exit 1&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>vol<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/scrub<span style=color:#bbb>
</span></code></pre></div><p>그러나 <code>volumes</code> 부분의 사용자 정의 재활용 파드 템플릿에 지정된 특정 경로는 재활용되는 볼륨의 특정 경로로 바뀐다.</p>
<h3 id=퍼시스턴트볼륨-예약>퍼시스턴트볼륨 예약</h3>
<p>컨트롤 플레인은 클러스터에서 <a href=#%EB%B0%94%EC%9D%B8%EB%94%A9>퍼시스턴트볼륨클레임을 일치하는 퍼시스턴트볼륨에 바인딩</a>할
수 있다. 그러나, PVC를 특정 PV에 바인딩하려면, 미리 바인딩해야 한다.</p>
<p>퍼시스턴트볼륨클레임에서 퍼시스턴트볼륨을 지정하여, 특정 PV와 PVC 간의 바인딩을 선언한다.
퍼시스턴트볼륨이 존재하고 <code>claimRef</code> 필드를 통해 퍼시스턴트볼륨클레임을 예약하지 않은 경우, 퍼시스턴트볼륨 및 퍼시스턴트볼륨클레임이 바인딩된다.</p>
<p>바인딩은 노드 선호도(affinity)를 포함하여 일부 볼륨 일치(matching) 기준과 관계없이 발생한다.
컨트롤 플레인은 여전히 <a href=/ko/docs/concepts/storage/storage-classes/>스토리지 클래스</a>, 접근 모드 및 요청된 스토리지 크기가 유효한지 확인한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolumeClaim<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo-pvc<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>storageClassName</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&#34;</span><span style=color:#bbb> </span><span style=color:#080;font-style:italic># 빈 문자열은 명시적으로 설정해야 하며 그렇지 않으면 기본 스토리지클래스가 설정됨</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumeName</span>:<span style=color:#bbb> </span>foo-pv<span style=color:#bbb>
</span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></code></pre></div><p>이 메서드는 퍼시스턴트볼륨에 대한 바인딩 권한을 보장하지 않는다. 다른 퍼시스턴트볼륨클레임에서 지정한 PV를 사용할 수 있는 경우, 먼저 해당 스토리지 볼륨을 예약해야 한다. PV의 <code>claimRef</code> 필드에 관련 퍼시스턴트볼륨클레임을 지정하여 다른 PVC가 바인딩할 수 없도록 한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolume<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo-pv<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>storageClassName</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>claimRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo-pvc<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb>
</span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></code></pre></div><p>이는 기존 PV를 재사용하는 경우를 포함하여 <code>claimPolicy</code> 가
<code>Retain</code> 으로 설정된 퍼시스턴트볼륨을 사용하려는 경우에 유용하다.</p>
<h3 id=퍼시스턴트-볼륨-클레임-확장>퍼시스턴트 볼륨 클레임 확장</h3>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.11 [beta]</code>
</div>
<p>퍼시스턴트볼륨클레임(PVC) 확장 지원은 기본적으로 활성화되어 있다. 다음 유형의
볼륨을 확장할 수 있다.</p>
<ul>
<li>azureDisk</li>
<li>azureFile</li>
<li>awsElasticBlockStore</li>
<li>cinder (deprecated)</li>
<li><a class=glossary-tooltip title="컨테이너 스토리지 인터페이스(CSI)는 컨테이너에 스토리지 시스템을 노출하는 표준 인터페이스를 정의한다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/storage/volumes/#csi target=_blank aria-label=csi>csi</a></li>
<li>flexVolume (deprecated)</li>
<li>gcePersistentDisk</li>
<li>glusterfs</li>
<li>rbd</li>
<li>portworxVolume</li>
</ul>
<p>스토리지 클래스의 <code>allowVolumeExpansion</code> 필드가 true로 설정된 경우에만 PVC를 확장할 수 있다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>storage.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StorageClass<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>gluster-vol-default<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>provisioner</span>:<span style=color:#bbb> </span>kubernetes.io/glusterfs<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>parameters</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resturl</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;http://192.168.10.100:8080&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restuser</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>secretNamespace</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>secretName</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>allowVolumeExpansion</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></code></pre></div><p>PVC에 대해 더 큰 볼륨을 요청하려면 PVC 오브젝트를 수정하여 더 큰 용량을
지정한다. 이는 기본 퍼시스턴트볼륨을 지원하는 볼륨의 확장을 트리거한다. 클레임을 만족시키기 위해
새로운 퍼시스턴트볼륨이 생성되지 않고 기존 볼륨의 크기가 조정된다.</p>
<div class="alert alert-danger warning callout" role=alert>
<strong>경고:</strong> 퍼시스턴트볼륨의 크기를 직접 변경하면 자동 볼륨 리사이즈 기능을 이용할 수 없게 된다.
퍼시스턴트볼륨의 크기를 변경하고,
퍼시스턴트볼륨에 해당되는 퍼시스턴트볼륨클레임의 <code>.spec</code>에 적혀 있는 크기를 동일하게 변경하면,
스토리지 리사이즈가 발생하지 않는다.
쿠버네티스 컨트롤 플레인은
두 리소스의 목표 상태(desired state)가 일치하는 것을 확인하고,
배후(backing) 볼륨 크기가 수동으로 증가되어 리사이즈가 필요하지 않다고 판단할 것이다.
</div>
<h4 id=csi-볼륨-확장>CSI 볼륨 확장</h4>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.16 [beta]</code>
</div>
<p>CSI 볼륨 확장 지원은 기본적으로 활성화되어 있지만 볼륨 확장을 지원하려면 특정 CSI 드라이버도 필요하다. 자세한 내용은 특정 CSI 드라이버 문서를 참고한다.</p>
<h4 id=파일시스템을-포함하는-볼륨-크기-조정>파일시스템을 포함하는 볼륨 크기 조정</h4>
<p>파일시스템이 XFS, Ext3 또는 Ext4 인 경우에만 파일시스템을 포함하는 볼륨의 크기를 조정할 수 있다.</p>
<p>볼륨에 파일시스템이 포함된 경우 새 파드가 <code>ReadWrite</code> 모드에서 퍼시스턴트볼륨클레임을 사용하는
경우에만 파일시스템의 크기가 조정된다. 파일시스템 확장은 파드가 시작되거나
파드가 실행 중이고 기본 파일시스템이 온라인 확장을 지원할 때 수행된다.</p>
<p>FlexVolumes(쿠버네티스 v1.23부터 사용 중단됨)는 드라이버의 <code>RequiresFSResize</code> 기능이 <code>true</code>로 설정된 경우 크기 조정을 허용한다.
FlexVolume은 파드 재시작 시 크기를 조정할 수 있다.</p>
<h4 id=사용-중인-퍼시스턴트볼륨클레임-크기-조정>사용 중인 퍼시스턴트볼륨클레임 크기 조정</h4>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.15 [beta]</code>
</div>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> 사용 중인 PVC 확장은 쿠버네티스 1.15 이후 버전에서는 베타로, 1.11 이후 버전에서는 알파로 제공된다. <code>ExpandInUsePersistentVolumes</code> 기능을 사용하도록 설정해야 한다. 베타 기능의 경우 여러 클러스터에서 자동으로 적용된다. 자세한 내용은 <a href=/ko/docs/reference/command-line-tools-reference/feature-gates/>기능 게이트</a> 문서를 참고한다.
</div>
<p>이 경우 기존 PVC를 사용하는 파드 또는 디플로이먼트를 삭제하고 다시 만들 필요가 없다.
파일시스템이 확장되자마자 사용 중인 PVC가 파드에서 자동으로 사용 가능하다.
이 기능은 파드나 디플로이먼트에서 사용하지 않는 PVC에는 영향을 미치지 않는다. 확장을 완료하기 전에
PVC를 사용하는 파드를 만들어야 한다.</p>
<p>다른 볼륨 유형과 비슷하게 FlexVolume 볼륨도 파드에서 사용 중인 경우 확장할 수 있다.</p>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> FlexVolume의 크기 조정은 기본 드라이버가 크기 조정을 지원하는 경우에만 가능하다.
</div>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> EBS 볼륨 확장은 시간이 많이 걸리는 작업이다. 또한 6시간마다 한 번의 수정을 할 수 있는 볼륨별 쿼터가 있다.
</div>
<h4 id=볼륨-확장-시-오류-복구>볼륨 확장 시 오류 복구</h4>
<p>사용자가 기반 스토리지 시스템이 제공할 수 있는 것보다 더 큰 사이즈를 지정하면, 사용자 또는 클러스터 관리자가 조치를 취하기 전까지 PVC 확장을 계속 시도한다. 이는 바람직하지 않으며 따라서 쿠버네티스는 이러한 오류 상황에서 벗어나기 위해 다음과 같은 방법을 제공한다.</p>
<ul class="nav nav-tabs" id=recovery-methods role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#recovery-methods-0 role=tab aria-controls=recovery-methods-0 aria-selected=true>클러스터 관리자 접근 권한을 이용하여 수동으로</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#recovery-methods-1 role=tab aria-controls=recovery-methods-1>더 작은 크기로의 확장을 요청하여</a></li></ul>
<div class=tab-content id=recovery-methods><div id=recovery-methods-0 class="tab-pane show active" role=tabpanel aria-labelledby=recovery-methods-0>
<p><p>기본 스토리지 확장에 실패하면, 클러스터 관리자가 수동으로 퍼시스턴트 볼륨 클레임(PVC) 상태를 복구하고 크기 조정 요청을 취소할 수 있다. 그렇지 않으면, 컨트롤러가 관리자 개입 없이 크기 조정 요청을 계속해서 재시도한다.</p>
<ol>
<li>퍼시스턴트볼륨클레임(PVC)에 바인딩된 퍼시스턴트볼륨(PV)을 <code>Retain</code> 반환 정책으로 표시한다.</li>
<li>PVC를 삭제한다. PV에는 <code>Retain</code> 반환 정책이 있으므로 PVC를 재생성할 때 데이터가 손실되지 않는다.</li>
<li>새 PVC를 바인딩할 수 있도록 PV 명세에서 <code>claimRef</code> 항목을 삭제한다. 그러면 PV가 <code>Available</code> 상태가 된다.</li>
<li>PV 보다 작은 크기로 PVC를 다시 만들고 PVC의 <code>volumeName</code> 필드를 PV 이름으로 설정한다. 이것은 새 PVC를 기존 PV에 바인딩해야 한다.</li>
<li>PV의 반환 정책을 복원하는 것을 잊지 않는다.</li>
</ol>
</div>
<div id=recovery-methods-1 class=tab-pane role=tabpanel aria-labelledby=recovery-methods-1>
<p><div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.23 [alpha]</code>
</div>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> PVC 확장 실패의 사용자에 의한 복구는 쿠버네티스 1.23부터 제공되는 알파 기능이다. 이 기능이 작동하려면 <code>RecoverVolumeExpansionFailure</code> 기능이 활성화되어 있어야 한다. 더 많은 정보는 <a href=/ko/docs/reference/command-line-tools-reference/feature-gates/>기능 게이트</a> 문서를 참조한다.
</div>
<p>클러스터에 <code>ExpandPersistentVolumes</code>와 <code>RecoverVolumeExpansionFailure</code>
기능 게이트가 활성화되어 있는 상태에서 PVC 확장이 실패하면
이전에 요청했던 값보다 작은 크기로의 확장을 재시도할 수 있다.
더 작은 크기를 지정하여 확장 시도를 요청하려면,
이전에 요청했던 값보다 작은 크기로 PVC의 <code>.spec.resources</code> 값을 수정한다.
이는 총 용량 제한(capacity constraint)으로 인해 큰 값으로의 확장이 실패한 경우에 유용하다.
만약 확장이 실패했다면, 또는 실패한 것 같다면, 기반 스토리지 공급자의 용량 제한보다 작은 값으로 확장을 재시도할 수 있다.
<code>.status.resizeStatus</code>와 PVC의 이벤트를 감시하여 리사이즈 작업의 상태를 모니터할 수 있다.</p>
<p>참고:
이전에 요청했던 값보다 작은 크기를 요청했더라도,
새로운 값이 여전히 <code>.status.capacity</code>보다 클 수 있다.
쿠버네티스는 PVC를 현재 크기보다 더 작게 축소하는 것은 지원하지 않는다.</p>
</div></div>
<h2 id=퍼시스턴트-볼륨의-유형>퍼시스턴트 볼륨의 유형</h2>
<p>퍼시스턴트볼륨 유형은 플러그인으로 구현된다. 쿠버네티스는 현재 다음의 플러그인을 지원한다.</p>
<ul>
<li><a href=/ko/docs/concepts/storage/volumes/#awselasticblockstore><code>awsElasticBlockStore</code></a> - AWS Elastic Block Store (EBS)</li>
<li><a href=/ko/docs/concepts/storage/volumes/#azuredisk><code>azureDisk</code></a> - Azure Disk</li>
<li><a href=/ko/docs/concepts/storage/volumes/#azurefile><code>azureFile</code></a> - Azure File</li>
<li><a href=/ko/docs/concepts/storage/volumes/#cephfs><code>cephfs</code></a> - CephFS 볼륨</li>
<li><a href=/ko/docs/concepts/storage/volumes/#csi><code>csi</code></a> - 컨테이너 스토리지 인터페이스 (CSI)</li>
<li><a href=/ko/docs/concepts/storage/volumes/#fc><code>fc</code></a> - Fibre Channel (FC) 스토리지</li>
<li><a href=/ko/docs/concepts/storage/volumes/#gcepersistentdisk><code>gcePersistentDisk</code></a> - GCE Persistent Disk</li>
<li><a href=/ko/docs/concepts/storage/volumes/#glusterfs><code>glusterfs</code></a> - Glusterfs 볼륨</li>
<li><a href=/ko/docs/concepts/storage/volumes/#hostpath><code>hostPath</code></a> - HostPath 볼륨
(단일 노드 테스트 전용. 다중-노드 클러스터에서 작동하지 않음.
대신 <code>로컬</code> 볼륨 사용 고려)</li>
<li><a href=/ko/docs/concepts/storage/volumes/#iscsi><code>iscsi</code></a> - iSCSI (SCSI over IP) 스토리지</li>
<li><a href=/ko/docs/concepts/storage/volumes/#local><code>local</code></a> - 노드에 마운트된
로컬 스토리지 디바이스</li>
<li><a href=/ko/docs/concepts/storage/volumes/#nfs><code>nfs</code></a> - 네트워크 파일 시스템 (NFS) 스토리지</li>
<li><a href=/ko/docs/concepts/storage/volumes/#portworxvolume><code>portworxVolume</code></a> - Portworx 볼륨</li>
<li><a href=/ko/docs/concepts/storage/volumes/#rbd><code>rbd</code></a> - Rados Block Device (RBD) 볼륨</li>
<li><a href=/ko/docs/concepts/storage/volumes/#vspherevolume><code>vsphereVolume</code></a> - vSphere VMDK 볼륨</li>
</ul>
<p>아래의 PersistentVolume 타입은 사용 중단되었다. 이 말인 즉슨, 지원은 여전히 제공되지만 추후 쿠버네티스 릴리스에서는 삭제될 예정이라는 것이다.</p>
<ul>
<li><a href=/ko/docs/concepts/storage/volumes/#cinder><code>cinder</code></a> - Cinder (오픈스택 블록 스토리지)
(v1.18에서 <strong>사용 중단</strong>)</li>
<li><a href=/ko/docs/concepts/storage/volumes/#flexvolume><code>flexVolume</code></a> - FlexVolume
(v1.23에서 <strong>사용 중단</strong>)</li>
<li><a href=/ko/docs/concepts/storage/volumes/#flocker><code>flocker</code></a> - Flocker 스토리지
(v1.22에서 <strong>사용 중단</strong>)</li>
<li><a href=/ko/docs/concepts/storage/volumes/#quobyte><code>quobyte</code></a> - Quobyte 볼륨
(v1.22에서 <strong>사용 중단</strong>)</li>
<li><a href=/ko/docs/concepts/storage/volumes/#storageos><code>storageos</code></a> - StorageOS 볼륨
(v1.22에서 <strong>사용 중단</strong>)</li>
</ul>
<p>이전 쿠버네티스 버전은 아래의 인-트리 PersistentVolume 타입도 지원했었다.</p>
<ul>
<li><code>photonPersistentDisk</code> - Photon 컨트롤러 퍼시스턴트 디스크.
(v1.15 이후 <strong>사용 불가</strong>)</li>
<li><a href=/ko/docs/concepts/storage/volumes/#scaleio><code>scaleIO</code></a> - ScaleIO 볼륨
(v1.21 이후 <strong>사용 불가</strong>)</li>
</ul>
<h2 id=퍼시스턴트-볼륨>퍼시스턴트 볼륨</h2>
<p>각 PV에는 스펙과 상태(볼륨의 명세와 상태)가 포함된다.
퍼시스턴트볼륨 오브젝트의 이름은 유효한
<a href=/ko/docs/concepts/overview/working-with-objects/names/#dns-%EC%84%9C%EB%B8%8C%EB%8F%84%EB%A9%94%EC%9D%B8-%EC%9D%B4%EB%A6%84>DNS 서브도메인 이름</a>이어야 한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolume<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pv0003<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>capacity</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>5Gi<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumeMode</span>:<span style=color:#bbb> </span>Filesystem<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- ReadWriteOnce<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>persistentVolumeReclaimPolicy</span>:<span style=color:#bbb> </span>Recycle<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>storageClassName</span>:<span style=color:#bbb> </span>slow<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>mountOptions</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- hard<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- nfsvers=4.1<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>nfs</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/tmp<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>server</span>:<span style=color:#bbb> </span><span style=color:#666>172.17.0.2</span><span style=color:#bbb>
</span></code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> 클러스터 내에서 퍼시스턴트볼륨을 사용하려면 볼륨 유형과 관련된 헬퍼(Helper) 프로그램이 필요할 수 있다. 이 예에서 퍼시스턴트볼륨은 NFS 유형이며 NFS 파일시스템 마운트를 지원하려면 헬퍼 프로그램인 /sbin/mount.nfs가 필요하다.
</div>
<h3 id=용량>용량</h3>
<p>일반적으로 PV는 특정 저장 용량을 가진다. 이것은 PV의 <code>capacity</code> 속성을 사용하여 설정된다. <code>capacity</code>가 사용하는 단위를 이해하려면 용어집에 있는 <a href="/ko/docs/reference/glossary/?all=true#term-quantity">수량</a> 항목을 참고한다.</p>
<p>현재 스토리지 용량 크기는 설정하거나 요청할 수 있는 유일한 리소스이다. 향후 속성에 IOPS, 처리량 등이 포함될 수 있다.</p>
<h3 id=볼륨-모드>볼륨 모드</h3>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.18 [stable]</code>
</div>
<p>쿠버네티스는 퍼시스턴트볼륨의 두 가지 <code>volumeModes</code>인 <code>Filesystem</code>과 <code>Block</code>을 지원한다.</p>
<p><code>volumeMode</code>는 선택적 API 파라미터이다.
<code>Filesystem</code>은 <code>volumeMode</code> 파라미터가 생략될 때 사용되는 기본 모드이다.</p>
<p><code>volumeMode: Filesystem</code>이 있는 볼륨은 파드의 디렉터리에 <em>마운트</em> 된다. 볼륨이 장치에
의해 지원되고 그 장치가 비어 있으면 쿠버네티스는 장치를
처음 마운트하기 전에 장치에 파일시스템을 만든다.</p>
<p>볼륨을 원시 블록 장치로 사용하려면 <code>volumeMode</code>의 값을 <code>Block</code>으로 설정할 수 있다.
이러한 볼륨은 파일시스템이 없는 블록 장치로 파드에 제공된다.
이 모드는 파드와 볼륨 사이에 파일시스템 계층 없이도 볼륨에 액세스하는
가장 빠른 방법을 파드에 제공하는 데 유용하다. 반면에 파드에서 실행되는 애플리케이션은
원시 블록 장치를 처리하는 방법을 알아야 한다.
파드에서 <code>volumeMode: Block</code>으로 볼륨을 사용하는 방법에 대한 예는
<a href=#%EC%9B%90%EC%8B%9C-%EB%B8%94%EB%A1%9D-%EB%B3%BC%EB%A5%A8-%EC%A7%80%EC%9B%90>원시 블록 볼륨 지원</a>를 참조하십시오.</p>
<h3 id=접근-모드>접근 모드</h3>
<p>리소스 제공자가 지원하는 방식으로 호스트에 퍼시스턴트볼륨을 마운트할 수 있다. 아래 표에서 볼 수 있듯이 제공자들은 서로 다른 기능을 가지며 각 PV의 접근 모드는 해당 볼륨에서 지원하는 특정 모드로 설정된다. 예를 들어 NFS는 다중 읽기/쓰기 클라이언트를 지원할 수 있지만 특정 NFS PV는 서버에서 읽기 전용으로 export할 수 있다. 각 PV는 특정 PV의 기능을 설명하는 자체 접근 모드 셋을 갖는다.</p>
<p>접근 모드는 다음과 같다.</p>
<dl>
<dt><code>ReadWriteOnce</code></dt>
<dd>하나의 노드에서 해당 볼륨이 읽기-쓰기로 마운트 될 수 있다. ReadWriteOnce 접근 모드에서도 파드가 동일 노드에서 구동되는 경우에는 복수의 파드에서 볼륨에 접근할 수 있다.</dd>
<dt><code>ReadOnlyMany</code></dt>
<dd>볼륨이 다수의 노드에서 읽기 전용으로 마운트 될 수 있다.</dd>
<dt><code>ReadWriteMany</code></dt>
<dd>볼륨이 다수의 노드에서 읽기-쓰기로 마운트 될 수 있다.</dd>
<dt><code>ReadWriteOncePod</code></dt>
<dd>볼륨이 단일 파드에서 읽기-쓰기로 마운트될 수 있다. 전체 클러스터에서 단 하나의 파드만 해당 PVC를 읽거나 쓸 수 있어야하는 경우 ReadWriteOncePod 접근 모드를 사용한다. 이 기능은 CSI 볼륨과 쿠버네티스 버전 1.22+ 에서만 지원된다.</dd>
</dl>
<p><a href=/blog/2021/09/13/read-write-once-pod-access-mode-alpha/>퍼시스턴트 볼륨에 대한 단일 파드 접근 모드 소개</a> 블로그 기사에서 이에 대해 보다 자세한 내용을 다룬다.</p>
<p>CLI에서 접근 모드는 다음과 같이 약어로 표시된다.</p>
<ul>
<li>RWO - ReadWriteOnce</li>
<li>ROX - ReadOnlyMany</li>
<li>RWX - ReadWriteMany</li>
<li>RWOP - ReadWriteOncePod</li>
</ul>
<blockquote>
<p><strong>중요!</strong> 볼륨이 여러 접근 모드를 지원하더라도 한 번에 하나의 접근 모드를 사용하여 마운트할 수 있다. 예를 들어 GCEPersistentDisk는 하나의 노드가 ReadWriteOnce로 마운트하거나 여러 노드가 ReadOnlyMany로 마운트할 수 있지만 동시에는 불가능하다.</p>
</blockquote>
<table>
<thead>
<tr>
<th style=text-align:left>Volume Plugin</th>
<th style=text-align:center>ReadWriteOnce</th>
<th style=text-align:center>ReadOnlyMany</th>
<th style=text-align:center>ReadWriteMany</th>
<th>ReadWriteOncePod</th>
</tr>
</thead>
<tbody>
<tr>
<td style=text-align:left>AWSElasticBlockStore</td>
<td style=text-align:center>✓</td>
<td style=text-align:center>-</td>
<td style=text-align:center>-</td>
<td>-</td>
</tr>
<tr>
<td style=text-align:left>AzureFile</td>
<td style=text-align:center>✓</td>
<td style=text-align:center>✓</td>
<td style=text-align:center>✓</td>
<td>-</td>
</tr>
<tr>
<td style=text-align:left>AzureDisk</td>
<td style=text-align:center>✓</td>
<td style=text-align:center>-</td>
<td style=text-align:center>-</td>
<td>-</td>
</tr>
<tr>
<td style=text-align:left>CephFS</td>
<td style=text-align:center>✓</td>
<td style=text-align:center>✓</td>
<td style=text-align:center>✓</td>
<td>-</td>
</tr>
<tr>
<td style=text-align:left>Cinder</td>
<td style=text-align:center>✓</td>
<td style=text-align:center>-</td>
<td style=text-align:center>-</td>
<td>-</td>
</tr>
<tr>
<td style=text-align:left>CSI</td>
<td style=text-align:center>depends on the driver</td>
<td style=text-align:center>depends on the driver</td>
<td style=text-align:center>depends on the driver</td>
<td>depends on the driver</td>
</tr>
<tr>
<td style=text-align:left>FC</td>
<td style=text-align:center>✓</td>
<td style=text-align:center>✓</td>
<td style=text-align:center>-</td>
<td>-</td>
</tr>
<tr>
<td style=text-align:left>FlexVolume</td>
<td style=text-align:center>✓</td>
<td style=text-align:center>✓</td>
<td style=text-align:center>depends on the driver</td>
<td>-</td>
</tr>
<tr>
<td style=text-align:left>Flocker</td>
<td style=text-align:center>✓</td>
<td style=text-align:center>-</td>
<td style=text-align:center>-</td>
<td>-</td>
</tr>
<tr>
<td style=text-align:left>GCEPersistentDisk</td>
<td style=text-align:center>✓</td>
<td style=text-align:center>✓</td>
<td style=text-align:center>-</td>
<td>-</td>
</tr>
<tr>
<td style=text-align:left>Glusterfs</td>
<td style=text-align:center>✓</td>
<td style=text-align:center>✓</td>
<td style=text-align:center>✓</td>
<td>-</td>
</tr>
<tr>
<td style=text-align:left>HostPath</td>
<td style=text-align:center>✓</td>
<td style=text-align:center>-</td>
<td style=text-align:center>-</td>
<td>-</td>
</tr>
<tr>
<td style=text-align:left>iSCSI</td>
<td style=text-align:center>✓</td>
<td style=text-align:center>✓</td>
<td style=text-align:center>-</td>
<td>-</td>
</tr>
<tr>
<td style=text-align:left>Quobyte</td>
<td style=text-align:center>✓</td>
<td style=text-align:center>✓</td>
<td style=text-align:center>✓</td>
<td>-</td>
</tr>
<tr>
<td style=text-align:left>NFS</td>
<td style=text-align:center>✓</td>
<td style=text-align:center>✓</td>
<td style=text-align:center>✓</td>
<td>-</td>
</tr>
<tr>
<td style=text-align:left>RBD</td>
<td style=text-align:center>✓</td>
<td style=text-align:center>✓</td>
<td style=text-align:center>-</td>
<td>-</td>
</tr>
<tr>
<td style=text-align:left>VsphereVolume</td>
<td style=text-align:center>✓</td>
<td style=text-align:center>-</td>
<td style=text-align:center>- (works when Pods are collocated)</td>
<td>-</td>
</tr>
<tr>
<td style=text-align:left>PortworxVolume</td>
<td style=text-align:center>✓</td>
<td style=text-align:center>-</td>
<td style=text-align:center>✓</td>
<td>-</td>
</tr>
<tr>
<td style=text-align:left>StorageOS</td>
<td style=text-align:center>✓</td>
<td style=text-align:center>-</td>
<td style=text-align:center>-</td>
<td>-</td>
</tr>
</tbody>
</table>
<h3 id=클래스>클래스</h3>
<p>PV는 <code>storageClassName</code> 속성을
<a href=/ko/docs/concepts/storage/storage-classes/>스토리지클래스</a>의
이름으로 설정하여 지정하는 클래스를 가질 수 있다.
특정 클래스의 PV는 해당 클래스를 요청하는 PVC에만 바인딩될 수 있다.
<code>storageClassName</code>이 없는 PV에는 클래스가 없으며 특정 클래스를 요청하지 않는 PVC에만
바인딩할 수 있다.</p>
<p>이전에는 <code>volume.beta.kubernetes.io/storage-class</code> 어노테이션이
<code>storageClassName</code> 속성 대신 사용되었다. 이 어노테이션은 아직까지는 사용할 수 있지만,
향후 쿠버네티스 릴리스에서 완전히 사용 중단(deprecated)이 될 예정이다.</p>
<h3 id=반환-정책>반환 정책</h3>
<p>현재 반환 정책은 다음과 같다.</p>
<ul>
<li>Retain(보존) -- 수동 반환</li>
<li>Recycle(재활용) -- 기본 스크럽 (<code>rm -rf /thevolume/*</code>)</li>
<li>Delete(삭제) -- AWS EBS, GCE PD, Azure Disk 또는 OpenStack Cinder 볼륨과 같은 관련 스토리지 자산이 삭제됨</li>
</ul>
<p>현재 NFS 및 HostPath만 재활용을 지원한다. AWS EBS, GCE PD, Azure Disk 및 Cinder 볼륨은 삭제를 지원한다.</p>
<h3 id=마운트-옵션>마운트 옵션</h3>
<p>쿠버네티스 관리자는 퍼시스턴트 볼륨이 노드에 마운트될 때 추가 마운트 옵션을 지정할 수 있다.</p>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> 모든 퍼시스턴트 볼륨 유형이 마운트 옵션을 지원하는 것은 아니다.
</div>
<p>다음 볼륨 유형은 마운트 옵션을 지원한다.</p>
<ul>
<li><code>awsElasticBlockStore</code></li>
<li><code>azureDisk</code></li>
<li><code>azureFile</code></li>
<li><code>cephfs</code></li>
<li><code>cinder</code> (v1.18에서 <strong>사용 중단됨</strong>)</li>
<li><code>gcePersistentDisk</code></li>
<li><code>glusterfs</code></li>
<li><code>iscsi</code></li>
<li><code>nfs</code></li>
<li><code>quobyte</code> (v1.22에서 <strong>사용 중단됨</strong>)</li>
<li><code>rbd</code></li>
<li><code>storageos</code> (v1.22에서 <strong>사용 중단됨</strong>)</li>
<li><code>vsphereVolume</code></li>
</ul>
<p>마운트 옵션의 유효성이 검사되지 않는다. 마운트 옵션이 유효하지 않으면, 마운트가 실패한다.</p>
<p>이전에는 <code>mountOptions</code> 속성 대신 <code>volume.beta.kubernetes.io/mount-options</code> 어노테이션이
사용되었다. 이 어노테이션은 아직까지는 사용할 수 있지만,
향후 쿠버네티스 릴리스에서 완전히 사용 중단(deprecated)이 될 예정이다.</p>
<h3 id=노드-어피니티-affinity>노드 어피니티(affinity)</h3>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> 대부분의 볼륨 유형의 경우 이 필드를 설정할 필요가 없다. <a href=/ko/docs/concepts/storage/volumes/#awselasticblockstore>AWS EBS</a>, <a href=/ko/docs/concepts/storage/volumes/#gcepersistentdisk>GCE PD</a> 및 <a href=/ko/docs/concepts/storage/volumes/#azuredisk>Azure Disk</a> 볼륨 블록 유형에 자동으로 채워진다. <a href=/ko/docs/concepts/storage/volumes/#local>로컬</a> 볼륨에 대해서는 이를 명시적으로 설정해야 한다.
</div>
<p>PV는 <a href=/docs/reference/generated/kubernetes-api/v1.23/#volumenodeaffinity-v1-core>노드 어피니티</a>를 지정하여 이 볼륨에 접근할 수 있는 노드를 제한하는 제약 조건을 정의할 수 있다. PV를 사용하는 파드는 노드 어피니티에 의해 선택된 노드로만 스케줄링된다. 노드 어피니티를 명기하기 위해서는, PV의 <code>.spec</code>에 <code>nodeAffinity</code>를 설정한다. <a href=/docs/reference/kubernetes-api/config-and-storage-resources/persistent-volume-v1/#PersistentVolumeSpec>퍼시스턴트볼륨</a> API 레퍼런스에 해당 필드에 대해 보다 자세한 내용이 있다.</p>
<h3 id=단계-phase>단계(Phase)</h3>
<p>볼륨은 다음 단계 중 하나이다.</p>
<ul>
<li>Available(사용 가능) -– 아직 클레임에 바인딩되지 않은 사용할 수 있는 리소스</li>
<li>Bound(바인딩) –- 볼륨이 클레임에 바인딩됨</li>
<li>Released(릴리스) –- 클레임이 삭제되었지만 클러스터에서 아직 리소스를 반환하지 않음</li>
<li>Failed(실패) –- 볼륨이 자동 반환에 실패함</li>
</ul>
<p>CLI는 PV에 바인딩된 PVC의 이름을 표시한다.</p>
<h2 id=퍼시스턴트볼륨클레임>퍼시스턴트볼륨클레임</h2>
<p>각 PVC에는 스펙과 상태(클레임의 명세와 상태)가 포함된다.
퍼시스턴트볼륨클레임 오브젝트의 이름은 유효한
<a href=/ko/docs/concepts/overview/working-with-objects/names/#dns-%EC%84%9C%EB%B8%8C%EB%8F%84%EB%A9%94%EC%9D%B8-%EC%9D%B4%EB%A6%84>DNS 서브도메인 이름</a>이어야 한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolumeClaim<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>myclaim<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- ReadWriteOnce<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumeMode</span>:<span style=color:#bbb> </span>Filesystem<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>8Gi<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>storageClassName</span>:<span style=color:#bbb> </span>slow<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>release</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;stable&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- {<span style=color:green;font-weight:700>key: environment, operator: In, values</span>:<span style=color:#bbb> </span>[dev]}<span style=color:#bbb>
</span></code></pre></div><h3 id=접근-모드-1>접근 모드</h3>
<p>클레임은 특정 접근 모드로 저장소를 요청할 때 <a href=#%EC%A0%91%EA%B7%BC-%EB%AA%A8%EB%93%9C>볼륨과 동일한 규칙</a>을 사용한다.</p>
<h3 id=볼륨-모드-1>볼륨 모드</h3>
<p>클레임은 <a href=#%EB%B3%BC%EB%A5%A8-%EB%AA%A8%EB%93%9C>볼륨과 동일한 규칙</a>을 사용하여 파일시스템 또는 블록 장치로 볼륨을 사용함을 나타낸다.</p>
<h3 id=리소스>리소스</h3>
<p>파드처럼 클레임은 특정 수량의 리소스를 요청할 수 있다. 이 경우는 스토리지에 대한 요청이다. 동일한 <a href=https://git.k8s.io/community/contributors/design-proposals/scheduling/resources.md>리소스 모델</a>이 볼륨과 클레임 모두에 적용된다.</p>
<h3 id=셀렉터>셀렉터</h3>
<p>클레임은 볼륨 셋을 추가로 필터링하기 위해 <a href=/ko/docs/concepts/overview/working-with-objects/labels/#%EB%A0%88%EC%9D%B4%EB%B8%94-%EC%85%80%EB%A0%89%ED%84%B0>레이블 셀렉터</a>를 지정할 수 있다. 레이블이 셀렉터와 일치하는 볼륨만 클레임에 바인딩할 수 있다. 셀렉터는 두 개의 필드로 구성될 수 있다.</p>
<ul>
<li><code>matchLabels</code> - 볼륨에 이 값의 레이블이 있어야함</li>
<li><code>matchExpressions</code> - 키, 값의 목록, 그리고 키와 값에 관련된 연산자를 지정하여 만든 요구 사항 목록. 유효한 연산자에는 In, NotIn, Exists 및 DoesNotExist가 있다.</li>
</ul>
<p><code>matchLabels</code> 및 <code>matchExpressions</code>의 모든 요구 사항이 AND 조건이다. 일치하려면 모두 충족해야 한다.</p>
<h3 id=클래스-1>클래스</h3>
<p>클레임은 <code>storageClassName</code> 속성을 사용하여
<a href=/ko/docs/concepts/storage/storage-classes/>스토리지클래스</a>의 이름을 지정하여
특정 클래스를 요청할 수 있다.
요청된 클래스의 PV(PVC와 동일한 <code>storageClassName</code>을 갖는 PV)만 PVC에
바인딩될 수 있다.</p>
<p>PVC는 반드시 클래스를 요청할 필요는 없다. <code>storageClassName</code>이 <code>""</code>로 설정된
PVC는 항상 클래스가 없는 PV를 요청하는 것으로 해석되므로
클래스가 없는 PV(어노테이션이 없거나 <code>""</code>와 같은 하나의 셋)에만 바인딩될 수
있다. <code>storageClassName</code>이 없는 PVC는
<a href=/docs/reference/access-authn-authz/admission-controllers/#defaultstorageclass><code>DefaultStorageClass</code> 어드미션 플러그인</a>이
켜져 있는지 여부에 따라 동일하지 않으며
클러스터에 따라 다르게 처리된다.</p>
<ul>
<li>어드미션 플러그인이 켜져 있으면 관리자가 기본 스토리지클래스를 지정할 수 있다.
<code>storageClassName</code>이 없는 모든 PVC는 해당 기본값의 PV에만 바인딩할 수 있다. 기본
스토리지클래스 지정은 스토리지클래스 오브젝트에서 어노테이션
<code>storageclass.kubernetes.io/is-default-class</code>를 <code>true</code>로
설정하여 수행된다. 관리자가 기본값을 지정하지 않으면 어드미션 플러그인이 꺼져 있는 것처럼
클러스터가 PVC 생성에 응답한다. 둘 이상의 기본값이 지정된 경우 어드미션
플러그인은 모든 PVC 생성을
금지한다.</li>
<li>어드미션 플러그인이 꺼져 있으면 기본 스토리지클래스에 대한 기본값 자체가 없다.
<code>storageClassName</code>이 없는 모든 PVC는 클래스가 없는 PV에만 바인딩할 수 있다. 이 경우
<code>storageClassName</code>이 없는 PVC는 <code>storageClassName</code>이 <code>""</code>로 설정된 PVC와
같은 방식으로 처리된다.</li>
</ul>
<p>설치 방법에 따라 설치 중에 애드온 관리자가 기본 스토리지클래스를 쿠버네티스 클러스터에
배포할 수 있다.</p>
<p>PVC가 스토리지클래스를 요청하는 것 외에도 <code>selector</code>를 지정하면 요구 사항들이
AND 조건으로 동작한다. 요청된 클래스와 요청된 레이블이 있는 PV만 PVC에
바인딩될 수 있다.</p>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> 현재 비어 있지 않은 <code>selector</code>가 있는 PVC에는 PV를 동적으로 프로비저닝할 수 없다.
</div>
<p>이전에는 <code>volume.beta.kubernetes.io/storage-class</code> 어노테이션이 <code>storageClassName</code>
속성 대신 사용되었다. 이 어노테이션은 아직까지는 사용할 수 있지만,
향후 쿠버네티스 릴리스에서는 지원되지 않는다.</p>
<h2 id=볼륨으로-클레임하기>볼륨으로 클레임하기</h2>
<p>클레임을 볼륨으로 사용해서 파드가 스토리지에 접근한다. 클레임은 클레임을 사용하는 파드와 동일한 네임스페이스에 있어야 한다. 클러스터는 파드의 네임스페이스에서 클레임을 찾고 이를 사용하여 클레임과 관련된 퍼시스턴트볼륨을 얻는다. 그런 다음 볼륨이 호스트와 파드에 마운트된다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>myfrontend<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/var/www/html&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypd<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypd<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>persistentVolumeClaim</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>claimName</span>:<span style=color:#bbb> </span>myclaim<span style=color:#bbb>
</span></code></pre></div><h3 id=네임스페이스에-대한-참고-사항>네임스페이스에 대한 참고 사항</h3>
<p>퍼시스턴트볼륨 바인딩은 배타적이며, 퍼시스턴트볼륨클레임은 네임스페이스 오브젝트이므로 "다중" 모드(<code>ROX</code>, <code>RWX</code>)를 사용한 클레임은 하나의 네임스페이스 내에서만 가능하다.</p>
<h3 id=hostpath-유형의-퍼시스턴트볼륨><code>hostPath</code> 유형의 퍼시스턴트볼륨</h3>
<p><code>hostPath</code> 퍼시스턴트볼륨은 노드의 파일이나 디렉터리를 사용하여 네트워크 연결 스토리지를 에뮬레이션한다.
<a href=/ko/docs/tasks/configure-pod-container/configure-persistent-volume-storage/#%ED%8D%BC%EC%8B%9C%EC%8A%A4%ED%84%B4%ED%8A%B8%EB%B3%BC%EB%A5%A8-%EC%83%9D%EC%84%B1%ED%95%98%EA%B8%B0><code>hostPath</code> 유형 볼륨의 예</a>를 참고한다.</p>
<h2 id=원시-블록-볼륨-지원>원시 블록 볼륨 지원</h2>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.18 [stable]</code>
</div>
<p>다음 볼륨 플러그인에 해당되는 경우 동적 프로비저닝을 포함하여 원시 블록 볼륨을
지원한다.</p>
<ul>
<li>AWSElasticBlockStore</li>
<li>AzureDisk</li>
<li>CSI</li>
<li>FC (파이버 채널)</li>
<li>GCEPersistentDisk</li>
<li>iSCSI</li>
<li>Local volume</li>
<li>OpenStack Cinder</li>
<li>RBD (Ceph Block Device)</li>
<li>VsphereVolume</li>
</ul>
<h3 id=persistent-volume-using-a-raw-block-volume>원시 블록 볼륨을 사용하는 퍼시스턴트볼륨</h3>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolume<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>block-pv<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>capacity</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>10Gi<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- ReadWriteOnce<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumeMode</span>:<span style=color:#bbb> </span>Block<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>persistentVolumeReclaimPolicy</span>:<span style=color:#bbb> </span>Retain<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>fc</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>targetWWNs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;50060e801049cfd1&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>lun</span>:<span style=color:#bbb> </span><span style=color:#666>0</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>false</span><span style=color:#bbb>
</span></code></pre></div><h3 id=persistent-volume-claim-requesting-a-raw-block-volume>원시 블록 볼륨을 요청하는 퍼시스턴트볼륨클레임</h3>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolumeClaim<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>block-pvc<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- ReadWriteOnce<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumeMode</span>:<span style=color:#bbb> </span>Block<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>10Gi<span style=color:#bbb>
</span></code></pre></div><h3 id=컨테이너에-원시-블록-장치-경로를-추가하는-파드-명세>컨테이너에 원시 블록 장치 경로를 추가하는 파드 명세</h3>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pod-with-block-volume<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>fc-container<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>fedora:26<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;/bin/sh&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;-c&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb> </span>[<span style=color:#bbb> </span><span style=color:#b44>&#34;tail -f /dev/null&#34;</span><span style=color:#bbb> </span>]<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumeDevices</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>data<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>devicePath</span>:<span style=color:#bbb> </span>/dev/xvda<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>data<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>persistentVolumeClaim</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>claimName</span>:<span style=color:#bbb> </span>block-pvc<span style=color:#bbb>
</span></code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> 파드에 대한 원시 블록 장치를 추가할 때 마운트 경로 대신 컨테이너에 장치 경로를 지정한다.
</div>
<h3 id=블록-볼륨-바인딩>블록 볼륨 바인딩</h3>
<p>사용자가 퍼시스턴트볼륨클레임 스펙에서 <code>volumeMode</code> 필드를 사용하여 이를 나타내는 원시 블록 볼륨을 요청하는 경우 바인딩 규칙은 스펙의 일부분으로 이 모드를 고려하지 않은 이전 릴리스에 비해 약간 다르다.
사용자와 관리자가 원시 블록 장치를 요청하기 위해 지정할 수 있는 가능한 조합의 표가 아래 나열되어 있다. 이 테이블은 볼륨이 바인딩되는지 여부를 나타낸다.
정적 프로비저닝된 볼륨에 대한 볼륨 바인딩 매트릭스이다.</p>
<table>
<thead>
<tr>
<th>PV volumeMode</th>
<th style=text-align:center>PVC volumeMode</th>
<th style=text-align:right>Result</th>
</tr>
</thead>
<tbody>
<tr>
<td>지정되지 않음</td>
<td style=text-align:center>지정되지 않음</td>
<td style=text-align:right>BIND</td>
</tr>
<tr>
<td>지정되지 않음</td>
<td style=text-align:center>Block</td>
<td style=text-align:right>NO BIND</td>
</tr>
<tr>
<td>지정되지 않음</td>
<td style=text-align:center>Filesystem</td>
<td style=text-align:right>BIND</td>
</tr>
<tr>
<td>Block</td>
<td style=text-align:center>지정되지 않음</td>
<td style=text-align:right>NO BIND</td>
</tr>
<tr>
<td>Block</td>
<td style=text-align:center>Block</td>
<td style=text-align:right>BIND</td>
</tr>
<tr>
<td>Block</td>
<td style=text-align:center>Filesystem</td>
<td style=text-align:right>NO BIND</td>
</tr>
<tr>
<td>Filesystem</td>
<td style=text-align:center>Filesystem</td>
<td style=text-align:right>BIND</td>
</tr>
<tr>
<td>Filesystem</td>
<td style=text-align:center>Block</td>
<td style=text-align:right>NO BIND</td>
</tr>
<tr>
<td>Filesystem</td>
<td style=text-align:center>지정되지 않음</td>
<td style=text-align:right>BIND</td>
</tr>
</tbody>
</table>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> 알파 릴리스에서는 정적으로 프로비저닝된 볼륨만 지원된다. 관리자는 원시 블록 장치로 작업할 때 이러한 값을 고려해야 한다.
</div>
<h2 id=볼륨-스냅샷-및-스냅샷-지원에서-볼륨-복원>볼륨 스냅샷 및 스냅샷 지원에서 볼륨 복원</h2>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.20 [stable]</code>
</div>
<p>볼륨 스냅 샷은 아웃-오브-트리 CSI 볼륨 플러그인만 지원한다. 자세한 내용은 <a href=/ko/docs/concepts/storage/volume-snapshots/>볼륨 스냅샷</a>을 참조한다.
인-트리 볼륨 플러그인은 사용 중단 되었다. <a href=https://github.com/kubernetes/community/blob/master/sig-storage/volume-plugin-faq.md>볼륨 플러그인 FAQ</a>에서 사용 중단된 볼륨 플러그인에 대해 확인할 수 있다.</p>
<h3 id=create-persistent-volume-claim-from-volume-snapshot>볼륨 스냅샷에서 퍼시스턴트볼륨클레임 생성</h3>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolumeClaim<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>restore-pvc<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>storageClassName</span>:<span style=color:#bbb> </span>csi-hostpath-sc<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>dataSource</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>new-snapshot-test<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>VolumeSnapshot<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>snapshot.storage.k8s.io<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- ReadWriteOnce<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>10Gi<span style=color:#bbb>
</span></code></pre></div><h2 id=볼륨-복제>볼륨 복제</h2>
<p><a href=/ko/docs/concepts/storage/volume-pvc-datasource/>볼륨 복제</a>는 CSI 볼륨 플러그인만 사용할 수 있다.</p>
<h3 id=create-persistent-volume-claim-from-an-existing-pvc>기존 pvc에서 퍼시스턴트볼륨클레임 생성</h3>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolumeClaim<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cloned-pvc<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>storageClassName</span>:<span style=color:#bbb> </span>my-csi-plugin<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>dataSource</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>existing-src-pvc-name<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolumeClaim<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- ReadWriteOnce<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>10Gi<span style=color:#bbb>
</span></code></pre></div><h2 id=볼륨-파퓰레이터-volume-populator-와-데이터-소스>볼륨 파퓰레이터(Volume populator)와 데이터 소스</h2>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.22 [alpha]</code>
</div>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> <p>쿠버네티스는 커스텀 볼륨 파퓰레이터를 지원한다.
이 알파 기능은 쿠버네티스 1.18에서 도입되었으며
1.22에서는 새로운 메카니즘과 리디자인된 API로 새롭게 구현되었다.
현재 사용 중인 클러스터의 버전에 맞는 쿠버네티스 문서를 읽고 있는지 다시 한번
확인한다.
버전 확인을 위해서, 다음 커맨드를 실행 <code>kubectl version</code>.</p>
<p>커스텀 볼륨 파퓰레이터를 사용하려면, kube-apiserver와 kube-controller-manager에 대해
<code>AnyVolumeDataSource</code> <a href=/ko/docs/reference/command-line-tools-reference/feature-gates/>기능 게이트</a>를 활성화해야 한다.</p>
</div>
<p>볼륨 파퓰레이터는 <code>dataSourceRef</code>라는 PVC 스펙 필드를 활용한다.
다른 PersistentVolumeClaim 또는 VolumeSnapshot을 가리키는 참조만 명시할 수 있는
<code>dataSource</code> 필드와는 다르게, <code>dataSourceRef</code> 필드는 동일 네임스페이스에 있는
어떠한 오브젝트에 대한 참조도 명시할 수 있다(단, PVC 외의 다른 코어 오브젝트는 제외).
기능 게이트가 활성화된 클러스터에서는 <code>dataSource</code>보다 <code>dataSourceRef</code>를 사용하는 것을 권장한다.</p>
<h2 id=데이터-소스-참조>데이터 소스 참조</h2>
<p><code>dataSourceRef</code> 필드는 <code>dataSource</code> 필드와 거의 동일하게 동작한다.
둘 중 하나만 명시되어 있으면, API 서버는 두 필드에 같은 값을 할당할 것이다.
두 필드 모두 생성 이후에는 변경될 수 없으며,
두 필드에 다른 값을 넣으려고 시도하면 검증 에러가 발생할 것이다.
따라서 두 필드는 항상 같은 값을 갖게 된다.</p>
<p><code>dataSourceRef</code> 필드와 <code>dataSource</code> 필드 사이에는
사용자가 알고 있어야 할 두 가지 차이점이 있다.</p>
<ul>
<li><code>dataSource</code> 필드는 유효하지 않은 값(예를 들면, 빈 값)을 무시하지만,
<code>dataSourceRef</code> 필드는 어떠한 값도 무시하지 않으며 유효하지 않은 값이 들어오면 에러를 발생할 것이다.
유효하지 않은 값은 PVC를 제외한 모든 코어 오브젝트(apiGroup이 없는 오브젝트)이다.</li>
<li><code>dataSourceRef</code> 필드는 여러 타입의 오브젝트를 포함할 수 있지만, <code>dataSource</code> 필드는
PVC와 VolumeSnapshot만 포함할 수 있다.</li>
</ul>
<p>기능 게이트가 활성화된 클러스터에서는 <code>dataSourceRef</code>를 사용해야 하고, 그렇지 않은
클러스터에서는 <code>dataSource</code>를 사용해야 한다. 어떤 경우에서든 두 필드 모두를 확인해야
할 필요는 없다. 이렇게 약간의 차이만 있는 중복된 값은 이전 버전 호환성을 위해서만
존재하는 것이다. 상세히 설명하면, 이전 버전과 새로운 버전의 컨트롤러가 함께 동작할
수 있는데, 이는 두 필드가 동일하기 때문이다.</p>
<h3 id=볼륨-파퓰레이터-사용하기>볼륨 파퓰레이터 사용하기</h3>
<p>볼륨 파퓰레이터는 비어 있지 않은 볼륨(non-empty volume)을 생성할 수 있는 <a class=glossary-tooltip title="API 서버를 통해 클러스터의 공유된 상태를 감시하고, 현재 상태를 원하는 상태로 이행시키는 컨트롤 루프." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/architecture/controller/ target=_blank aria-label=컨트롤러>컨트롤러</a>이며,
이 볼륨의 내용물은 커스텀 리소스(Custom Resource)에 의해 결정된다.
파퓰레이티드 볼륨(populated volume)을 생성하려면 <code>dataSourceRef</code> 필드에 커스텀 리소스를 기재한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolumeClaim<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>populated-pvc<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>dataSourceRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>example-name<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ExampleDataSource<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>example.storage.k8s.io<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- ReadWriteOnce<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>10Gi<span style=color:#bbb>
</span></code></pre></div><p>볼륨 파퓰레이터는 외부 컴포넌트이기 때문에,
만약 적합한 컴포넌트가 설치되어 있지 않다면 볼륨 파퓰레이터를 사용하는 PVC에 대한 생성 요청이 실패할 수 있다.
외부 컨트롤러는 '컴포넌트가 없어서 PVC를 생성할 수 없음' 경고와 같은
PVC 생성 상태에 대한 피드백을 제공하기 위해, PVC에 대한 이벤트를 생성해야 한다.</p>
<p>알파 버전의 <a href=https://github.com/kubernetes-csi/volume-data-source-validator>볼륨 데이터 소스 검증기</a>를
클러스터에 설치할 수 있다.
해당 데이터 소스를 다루는 파퓰레이터가 등록되어 있지 않다면 이 컨트롤러가 PVC에 경고 이벤트를 생성한다.
PVC를 위한 적절한 파퓰레이터가 설치되어 있다면,
볼륨 생성과 그 과정에서 발생하는 이슈에 대한 이벤트를 생성하는 것은 파퓰레이터 컨트롤러의 몫이다.</p>
<h2 id=포터블-구성-작성>포터블 구성 작성</h2>
<p>광범위한 클러스터에서 실행되고 퍼시스턴트 스토리지가 필요한
구성 템플릿 또는 예제를 작성하는 경우 다음 패턴을 사용하는 것이 좋다.</p>
<ul>
<li>구성 번들(디플로이먼트, 컨피그맵 등)에 퍼시스턴트볼륨클레임
오브젝트를 포함시킨다.</li>
<li>구성을 인스턴스화 하는 사용자에게 퍼시스턴트볼륨을 생성할 권한이 없을 수 있으므로
퍼시스턴트볼륨 오브젝트를 구성에 포함하지 않는다.</li>
<li>템플릿을 인스턴스화 할 때 스토리지 클래스 이름을 제공하는 옵션을
사용자에게 제공한다.
<ul>
<li>사용자가 스토리지 클래스 이름을 제공하는 경우 해당 값을
<code>permanentVolumeClaim.storageClassName</code> 필드에 입력한다.
클러스터에서 관리자가 스토리지클래스를 활성화한 경우
PVC가 올바른 스토리지 클래스와 일치하게 된다.</li>
<li>사용자가 스토리지 클래스 이름을 제공하지 않으면
<code>permanentVolumeClaim.storageClassName</code> 필드를 nil로 남겨둔다.
그러면 클러스터에 기본 스토리지클래스가 있는 사용자에 대해 PV가 자동으로 프로비저닝된다.
많은 클러스터 환경에 기본 스토리지클래스가 설치되어 있거나 관리자가
고유한 기본 스토리지클래스를 생성할 수 있다.</li>
</ul>
</li>
<li>도구(tooling)에서 일정 시간이 지나도 바인딩되지 않는 PVC를 관찰하여 사용자에게
노출시킨다. 이는 클러스터가 동적 스토리지를 지원하지
않거나(이 경우 사용자가 일치하는 PV를 생성해야 함),
클러스터에 스토리지 시스템이 없음을 나타낸다(이 경우
사용자는 PVC가 필요한 구성을 배포할 수 없음).</li>
</ul>
<h2 id=다음-내용>다음 내용</h2>
<ul>
<li><a href=/ko/docs/tasks/configure-pod-container/configure-persistent-volume-storage/#%ED%8D%BC%EC%8B%9C%EC%8A%A4%ED%84%B4%ED%8A%B8%EB%B3%BC%EB%A5%A8-%EC%83%9D%EC%84%B1%ED%95%98%EA%B8%B0>퍼시스턴트볼륨 생성</a>에 대해 자세히 알아보기</li>
<li><a href=/ko/docs/tasks/configure-pod-container/configure-persistent-volume-storage/#%ED%8D%BC%EC%8B%9C%EC%8A%A4%ED%84%B4%ED%8A%B8%EB%B3%BC%EB%A5%A8%ED%81%B4%EB%A0%88%EC%9E%84-%EC%83%9D%EC%84%B1%ED%95%98%EA%B8%B0>퍼시스턴트볼륨클레임 생성</a>에 대해 자세히 알아보기</li>
<li><a href=https://git.k8s.io/community/contributors/design-proposals/storage/persistent-storage.md>퍼시스턴트 스토리지 설계 문서</a> 읽어보기</li>
</ul>
<h3 id=reference>API 레퍼런스</h3>
<p>본 페이지에 기술된 API에 대해서 다음을 읽어본다.</p>
<ul>
<li><a href=/docs/reference/kubernetes-api/config-and-storage-resources/persistent-volume-v1/><code>PersistentVolume</code></a></li>
<li><a href=/docs/reference/kubernetes-api/config-and-storage-resources/persistent-volume-claim-v1/><code>PersistentVolumeClaim</code></a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-f0276d05eef111249272a1c932a91e2c>6.3 - 스토리지 클래스</h1>
<p>이 문서는 쿠버네티스의 스토리지클래스의 개념을 설명한다.
<a href=/ko/docs/concepts/storage/volumes/>볼륨</a>과
<a href=/ko/docs/concepts/storage/persistent-volumes>퍼시스턴트 볼륨</a>에 익숙해지는 것을 권장한다.</p>
<h2 id=소개>소개</h2>
<p>스토리지클래스는 관리자가 제공하는 스토리지의 "classes"를 설명할 수 있는
방법을 제공한다. 다른 클래스는 서비스의 품질 수준 또는
백업 정책, 클러스터 관리자가 정한 임의의 정책에
매핑될 수 있다. 쿠버네티스 자체는 클래스가 무엇을 나타내는지에
대해 상관하지 않는다. 다른 스토리지 시스템에서는 이 개념을
"프로파일"이라고도 한다.</p>
<h2 id=스토리지클래스-리소스>스토리지클래스 리소스</h2>
<p>각 스토리지클래스에는 해당 스토리지클래스에 속하는 퍼시스턴트볼륨을 동적으로 프로비저닝
할 때 사용되는 <code>provisioner</code>, <code>parameters</code> 와
<code>reclaimPolicy</code> 필드가 포함된다.</p>
<p>스토리지클래스 오브젝트의 이름은 중요하며, 사용자가 특정
클래스를 요청할 수 있는 방법이다. 관리자는 스토리지클래스 오브젝트를
처음 생성할 때 클래스의 이름과 기타 파라미터를 설정하며,
일단 생성된 오브젝트는 업데이트할 수 없다.</p>
<p>관리자는 특정 클래스에 바인딩을 요청하지 않는 PVC에 대해서만 기본
스토리지클래스를 지정할 수 있다. 자세한 내용은
<a href=/ko/docs/concepts/storage/persistent-volumes/#%ED%8D%BC%EC%8B%9C%EC%8A%A4%ED%84%B4%ED%8A%B8%EB%B3%BC%EB%A5%A8%ED%81%B4%EB%A0%88%EC%9E%84>퍼시스턴트볼륨클레임 섹션</a>을
본다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>storage.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StorageClass<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>standard<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>provisioner</span>:<span style=color:#bbb> </span>kubernetes.io/aws-ebs<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>parameters</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>gp2<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>reclaimPolicy</span>:<span style=color:#bbb> </span>Retain<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>allowVolumeExpansion</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>mountOptions</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- debug<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>volumeBindingMode</span>:<span style=color:#bbb> </span>Immediate<span style=color:#bbb>
</span></code></pre></div><h3 id=프로비저너>프로비저너</h3>
<p>각 스토리지클래스에는 PV 프로비저닝에 사용되는 볼륨 플러그인을 결정하는
프로비저너가 있다. 이 필드는 반드시 지정해야 한다.</p>
<table>
<thead>
<tr>
<th style=text-align:left>볼륨 플러그인</th>
<th style=text-align:center>내부 프로비저너</th>
<th style=text-align:center>설정 예시</th>
</tr>
</thead>
<tbody>
<tr>
<td style=text-align:left>AWSElasticBlockStore</td>
<td style=text-align:center>✓</td>
<td style=text-align:center><a href=#aws-ebs>AWS EBS</a></td>
</tr>
<tr>
<td style=text-align:left>AzureFile</td>
<td style=text-align:center>✓</td>
<td style=text-align:center><a href=#azure-%ED%8C%8C%EC%9D%BC>Azure 파일</a></td>
</tr>
<tr>
<td style=text-align:left>AzureDisk</td>
<td style=text-align:center>✓</td>
<td style=text-align:center><a href=#azure-%EB%94%94%EC%8A%A4%ED%81%AC>Azure 디스크</a></td>
</tr>
<tr>
<td style=text-align:left>CephFS</td>
<td style=text-align:center>-</td>
<td style=text-align:center>-</td>
</tr>
<tr>
<td style=text-align:left>Cinder</td>
<td style=text-align:center>✓</td>
<td style=text-align:center><a href=#openstack-cinder>OpenStack Cinder</a></td>
</tr>
<tr>
<td style=text-align:left>FC</td>
<td style=text-align:center>-</td>
<td style=text-align:center>-</td>
</tr>
<tr>
<td style=text-align:left>FlexVolume</td>
<td style=text-align:center>-</td>
<td style=text-align:center>-</td>
</tr>
<tr>
<td style=text-align:left>Flocker</td>
<td style=text-align:center>✓</td>
<td style=text-align:center>-</td>
</tr>
<tr>
<td style=text-align:left>GCEPersistentDisk</td>
<td style=text-align:center>✓</td>
<td style=text-align:center><a href=#gce-pd>GCE PD</a></td>
</tr>
<tr>
<td style=text-align:left>Glusterfs</td>
<td style=text-align:center>✓</td>
<td style=text-align:center><a href=#glusterfs>Glusterfs</a></td>
</tr>
<tr>
<td style=text-align:left>iSCSI</td>
<td style=text-align:center>-</td>
<td style=text-align:center>-</td>
</tr>
<tr>
<td style=text-align:left>Quobyte</td>
<td style=text-align:center>✓</td>
<td style=text-align:center><a href=#quobyte>Quobyte</a></td>
</tr>
<tr>
<td style=text-align:left>NFS</td>
<td style=text-align:center>-</td>
<td style=text-align:center><a href=#nfs>NFS</a></td>
</tr>
<tr>
<td style=text-align:left>RBD</td>
<td style=text-align:center>✓</td>
<td style=text-align:center><a href=#ceph-rbd>Ceph RBD</a></td>
</tr>
<tr>
<td style=text-align:left>VsphereVolume</td>
<td style=text-align:center>✓</td>
<td style=text-align:center><a href=#vsphere>vSphere</a></td>
</tr>
<tr>
<td style=text-align:left>PortworxVolume</td>
<td style=text-align:center>✓</td>
<td style=text-align:center><a href=#portworx-%EB%B3%BC%EB%A5%A8>Portworx 볼륨</a></td>
</tr>
<tr>
<td style=text-align:left>ScaleIO</td>
<td style=text-align:center>✓</td>
<td style=text-align:center><a href=#scaleio>ScaleIO</a></td>
</tr>
<tr>
<td style=text-align:left>StorageOS</td>
<td style=text-align:center>✓</td>
<td style=text-align:center><a href=#storageos>StorageOS</a></td>
</tr>
<tr>
<td style=text-align:left>Local</td>
<td style=text-align:center>-</td>
<td style=text-align:center><a href=#local>Local</a></td>
</tr>
</tbody>
</table>
<p>여기 목록에서 "내부" 프로비저너를 지정할 수 있다(이
이름은 "kubernetes.io" 가 접두사로 시작하고, 쿠버네티스와
함께 제공된다). 또한, 쿠버네티스에서 정의한
<a href=https://git.k8s.io/community/contributors/design-proposals/storage/volume-provisioning.md>사양</a>을
따르는 독립적인 프로그램인 외부 프로비저너를 실행하고 지정할 수 있다.
외부 프로비저너의 작성자는 코드의 수명, 프로비저너의
배송 방법, 실행 방법, (Flex를 포함한)볼륨 플러그인
등에 대한 완전한 재량권을 가진다. <a href=https://github.com/kubernetes-sigs/sig-storage-lib-external-provisioner>kubernetes-sigs/sig-storage-lib-external-provisioner</a>
리포지터리에는 대량의 사양을 구현하는 외부 프로비저너를 작성하기
위한 라이브러리가 있다. 일부 외부 프로비저너의 목록은
<a href=https://github.com/kubernetes-sigs/sig-storage-lib-external-provisioner>kubernetes-sigs/sig-storage-lib-external-provisioner</a> 리포지터리에 있다.</p>
<p>예를 들어, NFS는 내부 프로비저너를 제공하지 않지만, 외부
프로비저너를 사용할 수 있다. 타사 스토리지 업체가 자체 외부
프로비저너를 제공하는 경우도 있다.</p>
<h3 id=리클레임-정책>리클레임 정책</h3>
<p>스토리지클래스에 의해 동적으로 생성된 퍼시스턴트볼륨은 클래스의
<code>reclaimPolicy</code> 필드에 지정된 리클레임 정책을 가지는데,
이는 <code>Delete</code> 또는 <code>Retain</code> 이 될 수 있다. 스토리지클래스 오브젝트가
생성될 때 <code>reclaimPolicy</code> 가 지정되지 않으면 기본값은 <code>Delete</code> 이다.</p>
<p>수동으로 생성되고 스토리지클래스를 통해 관리되는 퍼시스턴트볼륨에는
생성 시 할당된 리클레임 정책이 있다.</p>
<h3 id=볼륨-확장-허용>볼륨 확장 허용</h3>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.11 [beta]</code>
</div>
<p>퍼시스턴트볼륨은 확장이 가능하도록 구성할 수 있다. 이 기능을 <code>true</code> 로 설정하면
해당 PVC 오브젝트를 편집하여 볼륨 크기를 조정할 수 있다.</p>
<p>다음 볼륨 유형은 기본 스토리지클래스에서 <code>allowVolumeExpansion</code> 필드가
true로 설정된 경우 볼륨 확장을 지원한다.</p>
<table><caption style=display:none>Table of Volume types and the version of Kubernetes they require</caption>
<thead>
<tr>
<th style=text-align:left>볼륨 유형</th>
<th style=text-align:left>요구되는 쿠버네티스 버전</th>
</tr>
</thead>
<tbody>
<tr>
<td style=text-align:left>gcePersistentDisk</td>
<td style=text-align:left>1.11</td>
</tr>
<tr>
<td style=text-align:left>awsElasticBlockStore</td>
<td style=text-align:left>1.11</td>
</tr>
<tr>
<td style=text-align:left>Cinder</td>
<td style=text-align:left>1.11</td>
</tr>
<tr>
<td style=text-align:left>glusterfs</td>
<td style=text-align:left>1.11</td>
</tr>
<tr>
<td style=text-align:left>rbd</td>
<td style=text-align:left>1.11</td>
</tr>
<tr>
<td style=text-align:left>Azure File</td>
<td style=text-align:left>1.11</td>
</tr>
<tr>
<td style=text-align:left>Azure Disk</td>
<td style=text-align:left>1.11</td>
</tr>
<tr>
<td style=text-align:left>Portworx</td>
<td style=text-align:left>1.11</td>
</tr>
<tr>
<td style=text-align:left>FlexVolume</td>
<td style=text-align:left>1.13</td>
</tr>
<tr>
<td style=text-align:left>CSI</td>
<td style=text-align:left>1.14 (alpha), 1.16 (beta)</td>
</tr>
</tbody>
</table>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> 볼륨 확장 기능을 사용해서 볼륨을 확장할 수 있지만, 볼륨을 축소할 수는 없다.
</div>
<h3 id=마운트-옵션>마운트 옵션</h3>
<p>스토리지클래스에 의해 동적으로 생성된 퍼시스턴트볼륨은
클래스의 <code>mountOptions</code> 필드에 지정된 마운트 옵션을 가진다.</p>
<p>만약 볼륨 플러그인이 마운트 옵션을 지원하지 않는데, 마운트
옵션을 지정하면 프로비저닝은 실패한다. 마운트 옵션은 클래스 또는 PV에서
검증되지 않는다. PV 마운트가 유효하지 않으면, 마운트가 실패하게 된다.</p>
<h3 id=볼륨-바인딩-모드>볼륨 바인딩 모드</h3>
<p><code>volumeBindingMode</code> 필드는 <a href=/ko/docs/concepts/storage/persistent-volumes/#%ED%94%84%EB%A1%9C%EB%B9%84%EC%A0%80%EB%8B%9D>볼륨 바인딩과 동적
프로비저닝</a>의 시작 시기를 제어한다. 설정되어 있지 않으면, <code>Immediate</code> 모드가 기본으로 사용된다.</p>
<p><code>Immediate</code> 모드는 퍼시스턴트볼륨클레임이 생성되면 볼륨
바인딩과 동적 프로비저닝이 즉시 발생하는 것을 나타낸다. 토폴로지 제약이
있고 클러스터의 모든 노드에서 전역적으로 접근할 수 없는 스토리지
백엔드의 경우, 파드의 스케줄링 요구 사항에 대한 지식 없이 퍼시스턴트볼륨이
바인딩되거나 프로비저닝된다. 이로 인해 스케줄되지 않은 파드가 발생할 수 있다.</p>
<p>클러스터 관리자는 <code>WaitForFirstConsumer</code> 모드를 지정해서 이 문제를 해결할 수 있는데
이 모드는 퍼시스턴트볼륨클레임을 사용하는 파드가 생성될 때까지 퍼시스턴트볼륨의 바인딩과 프로비저닝을 지연시킨다.
퍼시스턴트볼륨은 파드의 스케줄링 제약 조건에 의해 지정된 토폴로지에
따라 선택되거나 프로비전된다. 여기에는
<a href=/ko/docs/concepts/configuration/manage-resources-containers/>리소스 요구 사항</a>,
<a href=/ko/docs/concepts/scheduling-eviction/assign-pod-node/#%EB%85%B8%EB%93%9C-%EC%85%80%EB%A0%89%ED%84%B0-nodeselector>노드 셀렉터</a>,
<a href=/ko/docs/concepts/scheduling-eviction/assign-pod-node/#%EC%96%B4%ED%94%BC%EB%8B%88%ED%8B%B0-affinity-%EC%99%80-%EC%95%88%ED%8B%B0-%EC%96%B4%ED%94%BC%EB%8B%88%ED%8B%B0-anti-affinity>파드 어피니티(affinity)와
안티-어피니티(anti-affinity)</a>
그리고 <a href=/ko/docs/concepts/scheduling-eviction/taint-and-toleration/>테인트(taint)와 톨러레이션(toleration)</a>이 포함된다.</p>
<p>다음 플러그인은 동적 프로비저닝과 <code>WaitForFirstConsumer</code> 를 지원한다.</p>
<ul>
<li><a href=#aws-ebs>AWSElasticBlockStore</a></li>
<li><a href=#gce-pd>GCEPersistentDisk</a></li>
<li><a href=#azure-%EB%94%94%EC%8A%A4%ED%81%AC>Azure디스크</a></li>
</ul>
<p>다음 플러그인은 사전에 생성된 퍼시스턴트볼륨 바인딩으로 <code>WaitForFirstConsumer</code> 를 지원한다.</p>
<ul>
<li>위에서 언급한 모든 플러그인</li>
<li><a href=#local>Local</a></li>
</ul>
<p>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.17 [stable]</code>
</div>
<a href=/ko/docs/concepts/storage/volumes/#csi>CSI 볼륨</a>은 동적 프로비저닝과
사전에 생성된 PV에서도 지원되지만, 지원되는 토폴로지 키와 예시를 보려면 해당
CSI 드라이버에 대한 문서를 본다.</p>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> <p><code>WaitForFirstConsumer</code>를 사용한다면, 노드 어피니티를 지정하기 위해서 파드 스펙에 <code>nodeName</code>을 사용하지는 않아야 한다.
만약 <code>nodeName</code>을 사용한다면, 스케줄러가 바이패스되고 PVC가 <code>pending</code> 상태로 있을 것이다.</p>
<p>대신, 아래와 같이 호스트네임을 이용하는 노드셀렉터를 사용할 수 있다.</p>
</div>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>task-pv-pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>nodeSelector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubernetes.io/hostname</span>:<span style=color:#bbb> </span>kube-01<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>task-pv-storage<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>persistentVolumeClaim</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>claimName</span>:<span style=color:#bbb> </span>task-pv-claim<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>task-pv-container<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;http-server&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/usr/share/nginx/html&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>task-pv-storage<span style=color:#bbb>
</span></code></pre></div><h3 id=허용된-토폴로지>허용된 토폴로지</h3>
<p>클러스터 운영자가 <code>WaitForFirstConsumer</code> 볼륨 바인딩 모드를 지정하면, 대부분의 상황에서
더 이상 특정 토폴로지로 프로비저닝을 제한할 필요가 없다. 그러나
여전히 필요한 경우에는 <code>allowedTopologies</code> 를 지정할 수 있다.</p>
<p>이 예시는 프로비전된 볼륨의 토폴로지를 특정 영역으로 제한하는 방법을
보여 주며 지원되는 플러그인의 <code>zone</code> 과 <code>zones</code> 파라미터를 대체하는
데 사용해야 한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>storage.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StorageClass<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>standard<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>provisioner</span>:<span style=color:#bbb> </span>kubernetes.io/gce-pd<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>parameters</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>pd-standard<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>volumeBindingMode</span>:<span style=color:#bbb> </span>WaitForFirstConsumer<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>allowedTopologies</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>matchLabelExpressions</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>failure-domain.beta.kubernetes.io/zone<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>values</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- us-central1-a<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- us-central1-b<span style=color:#bbb>
</span></code></pre></div><h2 id=파라미터>파라미터</h2>
<p>스토리지 클래스에는 스토리지 클래스에 속하는 볼륨을 설명하는 파라미터가
있다. <code>provisioner</code> 에 따라 다른 파라미터를 사용할 수 있다. 예를 들어,
파라미터 <code>type</code> 에 대한 값 <code>io1</code> 과 파라미터 <code>iopsPerGB</code> 는
EBS에만 사용할 수 있다. 파라미터 생략 시 일부 기본값이
사용된다.</p>
<p>스토리지클래스에 대해 최대 512개의 파라미터를 정의할 수 있다.
키와 값을 포함하여 파라미터 오브젝터의 총 길이는 256 KiB를
초과할 수 없다.</p>
<h3 id=aws-ebs>AWS EBS</h3>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>storage.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StorageClass<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>slow<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>provisioner</span>:<span style=color:#bbb> </span>kubernetes.io/aws-ebs<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>parameters</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>io1<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>iopsPerGB</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;10&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>fsType</span>:<span style=color:#bbb> </span>ext4<span style=color:#bbb>
</span></code></pre></div><ul>
<li><code>type</code>: <code>io1</code>, <code>gp2</code>, <code>sc1</code>, <code>st1</code>. 자세한 내용은
<a href=https://docs.aws.amazon.com/ko_kr/AWSEC2/latest/UserGuide/ebs-volume-types.html>AWS 문서</a>를
본다. 기본값: <code>gp2</code>.</li>
<li><code>zone</code> (사용 중단(deprecated)): AWS 영역. <code>zone</code> 과 <code>zones</code> 를 지정하지 않으면, 일반적으로
쿠버네티스 클러스터의 노드가 있는 모든 활성화된 영역에 걸쳐 볼륨이
라운드 로빈으로 조정된다. <code>zone</code> 과 <code>zones</code> 파라미터를 동시에 사용해서는 안된다.</li>
<li><code>zones</code> (사용 중단): 쉼표로 구분된 AWS 영역의 목록. <code>zone</code> 과 <code>zones</code> 를
지정하지 않으면, 일반적으로 쿠버네티스 클러스터의 노드가 있는 모든 활성화된 영역에 걸쳐
볼륨이 라운드 로빈으로 조정된다. <code>zone</code> 과 <code>zones</code> 파라미터를
동시에 사용해서는 안된다.</li>
<li><code>iopsPerGB</code>: <code>io1</code> 볼륨 전용이다. 1초당 GiB에 대한 I/O 작업 수이다. AWS
볼륨 플러그인은 요청된 볼륨 크기에 곱셈하여 볼륨의 IOPS를
계산하고 이를 20,000 IOPS로 제한한다(AWS에서 지원하는 최대값으로,
<a href=https://docs.aws.amazon.com/ko_kr/AWSEC2/latest/UserGuide/ebs-volume-types.html>AWS 문서</a>를 본다).
여기에는 문자열, 즉 <code>10</code> 이 아닌, <code>"10"</code> 이 필요하다.</li>
<li><code>fsType</code>: fsType은 쿠버네티스에서 지원된다. 기본값: <code>"ext4"</code>.</li>
<li><code>encrypted</code>: EBS 볼륨의 암호화 여부를 나타낸다.
유효한 값은 <code>"ture"</code> 또는 <code>"false"</code> 이다. 여기에는 문자열,
즉 <code>true</code> 가 아닌, <code>"true"</code> 가 필요하다.</li>
<li><code>kmsKeyId</code>: 선택 사항. 볼륨을 암호화할 때 사용할 키의 전체 Amazon
리소스 이름이다. 아무것도 제공되지 않지만, <code>encrypted</code> 가 true라면
AWS에 의해 키가 생성된다. 유효한 ARN 값은 AWS 문서를 본다.</li>
</ul>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> <code>zone</code> 과 <code>zones</code> 파라미터는 사용 중단 되었으며,
<a href=#allowed-topologies>allowedTopologies</a>로 대체되었다.
</div>
<h3 id=gce-pd>GCE PD</h3>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>storage.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StorageClass<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>slow<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>provisioner</span>:<span style=color:#bbb> </span>kubernetes.io/gce-pd<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>parameters</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>pd-standard<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>fstype</span>:<span style=color:#bbb> </span>ext4<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replication-type</span>:<span style=color:#bbb> </span>none<span style=color:#bbb>
</span></code></pre></div><ul>
<li>
<p><code>type</code>: <code>pd-standard</code> 또는 <code>pd-ssd</code>. 기본값: <code>pd-standard</code></p>
</li>
<li>
<p><code>zone</code> (사용 중단): GCE 영역. <code>zone</code> 과 <code>zones</code> 를 모두 지정하지 않으면, 쿠버네티스 클러스터의
노드가 있는 모든 활성화된 영역에 걸쳐 볼륨이 라운드 로빈으로
조정된다. <code>zone</code> 과 <code>zones</code> 파라미터를 동시에 사용해서는 안된다.</p>
</li>
<li>
<p><code>zones</code> (사용 중단): 쉼표로 구분되는 GCE 영역의 목록. <code>zone</code> 과 <code>zones</code> 를 모두
지정하지 않으면, 쿠버네티스 클러스터의 노드가 있는 모든 활성화된 영역에
걸쳐 볼륨이 라운드 로빈으로 조정된다. <code>zone</code> 과 <code>zones</code> 파라미터를
동시에 사용해서는 안된다.</p>
</li>
<li>
<p><code>fstype</code>: <code>ext4</code> 또는 <code>xfs</code>. 기본값: <code>ext4</code>. 정의된 파일시스템 유형은 호스트 운영체제에서 지원되어야 한다.</p>
</li>
<li>
<p><code>replication-type</code>: <code>none</code> 또는 <code>regional-pd</code>. 기본값: <code>none</code>.</p>
</li>
</ul>
<p><code>replication-type</code> 을 <code>none</code> 으로 설정하면 (영역) PD가 프로비전된다.</p>
<p><code>replication-type</code> 이 <code>regional-pd</code> 로 설정되면,
<a href=https://cloud.google.com/compute/docs/disks/#repds>지역 퍼시스턴트 디스크</a>
가 프로비전된다. 이는 퍼시스턴트볼륨클레임과 스토리지클래스를 소모하는 파드를
생성할 때 지역 퍼시스턴트 디스크는 두개의 영역으로
프로비전되기에 <code>volumeBindingMode: WaitForFirstConsumer</code> 를
설정하는 것을 강력히 권장한다. 하나의 영역은 파드가 스케줄된
영역과 동일하다. 다른 영역은 클러스터에서 사용할 수
있는 영역에서 임의로 선택된다. 디스크 영역은 <code>allowedTopologies</code> 를
사용하면 더 제한할 수 있다.</p>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> <code>zone</code> 과 <code>zones</code> 파라미터는 사용 중단 되었으며,
<a href=#allowed-topologies>allowedTopologies</a>로 대체되었다.
</div>
<h3 id=glusterfs>Glusterfs</h3>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>storage.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StorageClass<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>slow<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>provisioner</span>:<span style=color:#bbb> </span>kubernetes.io/glusterfs<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>parameters</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resturl</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;http://127.0.0.1:8081&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>clusterid</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;630372ccdc720a92c681fb928f27b53f&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restauthenabled</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restuser</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;admin&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>secretNamespace</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;default&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>secretName</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;heketi-secret&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>gidMin</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;40000&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>gidMax</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;50000&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumetype</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;replicate:3&#34;</span><span style=color:#bbb>
</span></code></pre></div><ul>
<li>
<p><code>resturl</code>: 필요에 따라 gluster 볼륨을 프로비전하는 Gluster REST 서비스/Heketi
서비스 url 이다. 일반적인 형식은 <code>IPaddress:Port</code> 이어야 하며 이는 GlusterFS
동적 프로비저너의 필수 파라미터이다. Heketi 서비스가 openshift/kubernetes
설정에서 라우팅이 가능한 서비스로 노출이 되는 경우 이것은 fqdn이 해석할 수 있는
Heketi 서비스 url인 <code>http://heketi-storage-project.cloudapps.mystorage.com</code> 과
유사한 형식을 가질 수 있다.</p>
</li>
<li>
<p><code>restauthenabled</code> : REST 서버에 대한 인증을 가능하게 하는 Gluster REST 서비스
인증 부울이다. 이 값이 <code>"true"</code> 이면, <code>restuser</code> 와 <code>restuserkey</code>
또는 <code>secretNamespace</code> + <code>secretName</code> 을 채워야 한다. 이 옵션은
사용 중단이며, <code>restuser</code>, <code>restuserkey</code>, <code>secretName</code> 또는
<code>secretNamespace</code> 중 하나를 지정하면 인증이 활성화된다.</p>
</li>
<li>
<p><code>restuser</code> : Gluster REST 서비스/Heketi 사용자로 Gluster Trusted Pool에서
볼륨을 생성할 수 있다.</p>
</li>
<li>
<p><code>restuserkey</code> : REST 서버에 대한 인증에 사용될 Gluster REST 서비스/Heketi
사용자의 암호이다. 이 파라미터는 <code>secretNamespace</code> + <code>secretName</code> 을 위해
사용 중단 되었다.</p>
</li>
<li>
<p><code>secretNamespace</code>, <code>secretName</code> : Gluster REST 서비스와 통신할 때 사용할
사용자 암호가 포함된 시크릿 인스턴스를 식별한다. 이 파라미터는
선택 사항으로 <code>secretNamespace</code> 와 <code>secretName</code> 을 모두 생략하면
빈 암호가 사용된다. 제공된 시크릿은 <code>"kubernetes.io/glusterfs"</code> 유형이어야
하며, 예를 들어 다음과 같이 생성한다.</p>
<pre><code>kubectl create secret generic heketi-secret \
  --type=&quot;kubernetes.io/glusterfs&quot; --from-literal=key='opensesame' \
  --namespace=default
</code></pre><p>시크릿의 예시는
<a href=https://github.com/kubernetes/examples/tree/master/staging/persistent-volume-provisioning/glusterfs/glusterfs-secret.yaml>glusterfs-provisioning-secret.yaml</a>에서 찾을 수 있다.</p>
</li>
<li>
<p><code>clusterid</code>: <code>630372ccdc720a92c681fb928f27b53f</code> 는 볼륨을 프로비저닝할
때 Heketi가 사용할 클러스터의 ID이다. 또한, 예시와 같이 클러스터
ID 목록이 될 수 있다. 예:
<code>"8452344e2becec931ece4e33c4674e4e,42982310de6c63381718ccfa6d8cf397"</code>. 이것은
선택적 파라미터이다.</p>
</li>
<li>
<p><code>gidMin</code>, <code>gidMax</code> : 스토리지클래스에 대한 GID 범위의 최소값과
최대값이다. 이 범위( gidMin-gidMax )의 고유한 값(GID)은 동적으로
프로비전된 볼륨에 사용된다. 이것은 선택적인 값이다. 지정하지 않으면,
볼륨은 각각 gidMin과 gidMax의 기본값인 2000-2147483647
사이의 값으로 프로비전된다.</p>
</li>
<li>
<p><code>volumetype</code> : 볼륨 유형과 파라미터는 이 선택적 값으로 구성할
수 있다. 볼륨 유형을 언급하지 않는 경우, 볼륨 유형을 결정하는 것은
프로비저너의 책임이다.</p>
<p>예를 들어:</p>
<ul>
<li>레플리카 볼륨: <code>volumetype: replicate:3</code> 여기서 '3'은 레플리카의 수이다.</li>
<li>Disperse/EC 볼륨: <code>volumetype: disperse:4:2</code> 여기서 '4'는 데이터이고 '2'는 중복 횟수이다.</li>
<li>Distribute 볼륨: <code>volumetype: none</code></li>
</ul>
<p>사용 가능한 볼륨 유형과 관리 옵션에 대해서는
<a href=https://access.redhat.com/documentation/en-US/Red_Hat_Storage/3.1/html/Administration_Guide/part-Overview.html>관리 가이드</a>를 참조한다.</p>
<p>자세한 정보는
<a href=https://github.com/heketi/heketi/wiki/Setting-up-the-topology>Heketi 구성 방법</a>을 참조한다.</p>
<p>퍼시스턴트 볼륨이 동적으로 프로비전되면 Gluster 플러그인은
<code>gluster-dynamic-&lt;claimname></code> 이라는 이름으로 엔드포인트와
헤드리스 서비스를 자동으로 생성한다. 퍼시스턴트 볼륨 클레임을
삭제하면 동적 엔드포인트와 서비스가 자동으로 삭제된다.</p>
</li>
</ul>
<h3 id=nfs>NFS</h3>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>storage.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StorageClass<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>example-nfs<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>provisioner</span>:<span style=color:#bbb> </span>example.com/external-nfs<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>parameters</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>server</span>:<span style=color:#bbb> </span>nfs-server.example.com<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/share<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;false&#34;</span><span style=color:#bbb>
</span></code></pre></div><ul>
<li><code>server</code>: NFS 서버의 호스트네임 또는 IP 주소.</li>
<li><code>path</code>: NFS 서버가 익스포트(export)한 경로.</li>
<li><code>readOnly</code>: 스토리지를 읽기 전용으로 마운트할지 나타내는 플래그(기본값: false).</li>
</ul>
<p>쿠버네티스에는 내장 NFS 프로비저너가 없다. NFS를 위한 스토리지클래스를 생성하려면 외부 프로비저너를 사용해야 한다.
예시는 다음과 같다.</p>
<ul>
<li><a href=https://github.com/kubernetes-sigs/nfs-ganesha-server-and-external-provisioner>NFS Ganesha server and external provisioner</a></li>
<li><a href=https://github.com/kubernetes-sigs/nfs-subdir-external-provisioner>NFS subdir external provisioner</a></li>
</ul>
<h3 id=openstack-cinder>OpenStack Cinder</h3>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>storage.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StorageClass<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>gold<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>provisioner</span>:<span style=color:#bbb> </span>kubernetes.io/cinder<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>parameters</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>availability</span>:<span style=color:#bbb> </span>nova<span style=color:#bbb>
</span></code></pre></div><ul>
<li><code>availability</code>: 가용성 영역. 지정하지 않으면, 일반적으로 쿠버네티스 클러스터의
노드가 있는 모든 활성화된 영역에 걸쳐 볼륨이 라운드 로빈으로 조정된다.</li>
</ul>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> <div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.11 [deprecated]</code>
</div>
<p>이 OpenStack 내부 프로비저너는 사용 중단 되었다. <a href=https://github.com/kubernetes/cloud-provider-openstack>OpenStack용 외부 클라우드 공급자</a>를 사용한다.
</div>
<h3 id=vsphere>vSphere</h3>
<p>vSphere 스토리지 클래스에는 두 가지 유형의 프로비저닝 도구가 있다.</p>
<ul>
<li><a href=#vsphere-provisioner-csi>CSI 프로비저닝 도구</a>: <code>csi.vsphere.vmware.com</code></li>
<li><a href=#vcp-%ED%94%84%EB%A1%9C%EB%B9%84%EC%A0%80%EB%8B%9D-%EB%8F%84%EA%B5%AC>vCP 프로비저닝 도구</a>: <code>kubernetes.io/vsphere-volume</code></li>
</ul>
<p>인-트리 프로비저닝 도구는 <a href=/blog/2019/12/09/kubernetes-1-17-feature-csi-migration-beta/#why-are-we-migrating-in-tree-plugins-to-csi>사용 중단</a>되었다. CSI 프로비저닝 도구에 대한 자세한 내용은 <a href=https://vsphere-csi-driver.sigs.k8s.io/>쿠버네티스 vSphere CSI 드라이버</a> 및 <a href=/ko/docs/concepts/storage/volumes/#csi-%EB%A7%88%EC%9D%B4%EA%B7%B8%EB%A0%88%EC%9D%B4%EC%85%98>vSphereVolume CSI 마이그레이션</a>을 참고한다.</p>
<h4 id=vsphere-provisioner-csi>CSI 프로비저닝 도구</h4>
<p>vSphere CSI 스토리지클래스 프로비저닝 도구는 Tanzu 쿠버네티스 클러스터에서 작동한다. 예시는 <a href=https://github.com/kubernetes-sigs/vsphere-csi-driver/blob/master/example/vanilla-k8s-RWM-filesystem-volumes/example-sc.yaml>vSphere CSI 리포지터리</a>를 참조한다.</p>
<h4 id=vcp-프로비저닝-도구>vCP 프로비저닝 도구</h4>
<p>다음 예시에서는 VMware 클라우드 공급자(vCP) 스토리지클래스 프로비저닝 도구를 사용한다.</p>
<ol>
<li>
<p>사용자 지정 디스크 형식으로 스토리지클래스를 생성한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>storage.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StorageClass<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>fast<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>provisioner</span>:<span style=color:#bbb> </span>kubernetes.io/vsphere-volume<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>parameters</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>diskformat</span>:<span style=color:#bbb> </span>zeroedthick<span style=color:#bbb>
</span></code></pre></div><p><code>diskformat</code>: <code>thin</code>, <code>zeroedthick</code> 와 <code>eagerzeroedthick</code>. 기본값: <code>"thin"</code>.</p>
</li>
<li>
<p>사용자 지정 데이터스토어에 디스크 형식으로 스토리지클래스를 생성한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>storage.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StorageClass<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>fast<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>provisioner</span>:<span style=color:#bbb> </span>kubernetes.io/vsphere-volume<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>parameters</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>diskformat</span>:<span style=color:#bbb> </span>zeroedthick<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>datastore</span>:<span style=color:#bbb> </span>VSANDatastore<span style=color:#bbb>
</span></code></pre></div><p><code>datastore</code>: 또한, 사용자는 스토리지클래스에서 데이터스토어를 지정할 수 있다.
볼륨은 스토리지클래스에 지정된 데이터스토어에 생성되며,
이 경우 <code>VSANDatastore</code> 이다. 이 필드는 선택 사항이다. 데이터스토어를
지정하지 않으면, vSphere 클라우드 공급자를 초기화하는데 사용되는 vSphere
설정 파일에 지정된 데이터스토어에 볼륨이
생성된다.</p>
</li>
<li>
<p>쿠버네티스 내부 스토리지 정책을 관리한다.</p>
<ul>
<li>
<p>기존 vCenter SPBM 정책을 사용한다.</p>
<p>vSphere 스토리지 관리의 가장 중요한 기능 중 하나는
정책 기반 관리이다. 스토리지 정책 기반 관리(Storage Policy Based Management (SPBM))는
광범위한 데이터 서비스와 스토리지 솔루션에서 단일 통합 컨트롤 플레인을
제공하는 스토리지 정책 프레임워크이다. SPBM을 통해 vSphere 관리자는 용량 계획,
차별화된 서비스 수준과 용량의 헤드룸(headroom) 관리와 같은
선행 스토리지 프로비저닝 문제를
극복할 수 있다.</p>
<p>SPBM 정책은 <code>storagePolicyName</code> 파라미터를 사용하면
스토리지클래스에서 지정할 수 있다.</p>
</li>
<li>
<p>쿠버네티스 내부의 가상 SAN 정책 지원</p>
<p>Vsphere 인프라스트럭쳐(Vsphere Infrastructure (VI)) 관리자는
동적 볼륨 프로비저닝 중에 사용자 정의 가상 SAN 스토리지
기능을 지정할 수 있다. 이제 동적 볼륨 프로비저닝 중에 스토리지
기능의 형태로 성능 및 가용성과 같은 스토리지 요구 사항을 정의할
수 있다. 스토리지 기능 요구 사항은 가상 SAN 정책으로 변환된
퍼시스턴트 볼륨(가상 디스크)을 생성할 때
가상 SAN 계층으로 푸시된다. 가상 디스크는 가상 SAN 데이터
스토어에 분산되어 요구 사항을 충족시키게 된다.</p>
<p>퍼시스턴트 볼륨 관리에 스토리지 정책을 사용하는 방법에 대한 자세한 내용은
<a href=https://vmware.github.io/vsphere-storage-for-kubernetes/documentation/policy-based-mgmt.html>볼륨의 동적 프로비저닝을 위한 스토리지 정책 기반 관리(SPBM)</a>를
참조한다.</p>
</li>
</ul>
</li>
</ol>
<p>vSphere용 쿠버네티스 내에서 퍼시스턴트 볼륨 관리를 시도하는
<a href=https://github.com/kubernetes/examples/tree/master/staging/volumes/vsphere>vSphere 예시</a>는
거의 없다.</p>
<h3 id=ceph-rbd>Ceph RBD</h3>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>storage.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StorageClass<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>fast<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>provisioner</span>:<span style=color:#bbb> </span>kubernetes.io/rbd<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>parameters</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>monitors</span>:<span style=color:#bbb> </span><span style=color:#666>10.16.153.105</span>:<span style=color:#666>6789</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>adminId</span>:<span style=color:#bbb> </span>kube<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>adminSecretName</span>:<span style=color:#bbb> </span>ceph-secret<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>adminSecretNamespace</span>:<span style=color:#bbb> </span>kube-system<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>pool</span>:<span style=color:#bbb> </span>kube<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>userId</span>:<span style=color:#bbb> </span>kube<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>userSecretName</span>:<span style=color:#bbb> </span>ceph-secret-user<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>userSecretNamespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>fsType</span>:<span style=color:#bbb> </span>ext4<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>imageFormat</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>imageFeatures</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;layering&#34;</span><span style=color:#bbb>
</span></code></pre></div><ul>
<li>
<p><code>monitors</code>: 쉼표로 구분된 Ceph 모니터. 이 파라미터는 필수이다.</p>
</li>
<li>
<p><code>adminId</code>: 풀에 이미지를 생성할 수 있는 Ceph 클라이언트 ID.
기본값은 "admin".</p>
</li>
<li>
<p><code>adminSecretName</code>: <code>adminId</code> 의 시크릿 이름. 이 파라미터는 필수이다.
제공된 시크릿은 "kubernetes.io/rbd" 유형이어야 한다.</p>
</li>
<li>
<p><code>adminSecretNamespace</code>: <code>adminSecretName</code> 의 네임스페이스. 기본값은 "default".</p>
</li>
<li>
<p><code>pool</code>: Ceph RBD 풀. 기본값은 "rbd".</p>
</li>
<li>
<p><code>userId</code>: RBD 이미지를 매핑하는 데 사용하는 Ceph 클라이언트 ID. 기본값은
<code>adminId</code> 와 동일하다.</p>
</li>
<li>
<p><code>userSecretName</code>: RDB 이미지를 매핑하기 위한 <code>userId</code> 에 대한 Ceph 시크릿 이름. PVC와
동일한 네임스페이스에 존재해야 한다. 이 파라미터는 필수이다.
제공된 시크릿은 "kubernetes.io/rbd" 유형이어야 하며, 다음의 예시와 같이
생성되어야 한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create secret generic ceph-secret --type<span style=color:#666>=</span><span style=color:#b44>&#34;kubernetes.io/rbd&#34;</span> <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --from-literal<span style=color:#666>=</span><span style=color:#b8860b>key</span><span style=color:#666>=</span><span style=color:#b44>&#39;QVFEQ1pMdFhPUnQrSmhBQUFYaERWNHJsZ3BsMmNjcDR6RFZST0E9PQ==&#39;</span> <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --namespace<span style=color:#666>=</span>kube-system
</code></pre></div></li>
<li>
<p><code>userSecretNamespace</code>: <code>userSecretName</code> 의 네임스페이스.</p>
</li>
<li>
<p><code>fsType</code>: 쿠버네티스가 지원하는 fsType. 기본값: <code>"ext4"</code>.</p>
</li>
<li>
<p><code>imageFormat</code>: Ceph RBD 이미지 형식, "1" 또는 "2". 기본값은 "2".</p>
</li>
<li>
<p><code>imageFeatures</code>: 이 파라미터는 선택 사항이며, <code>imageFormat</code> 을 "2"로 설정한
경우에만 사용해야 한다. 현재 <code>layering</code> 에서만 기능이 지원된다.
기본값은 ""이며, 기능이 설정되어 있지 않다.</p>
</li>
</ul>
<h3 id=quobyte>Quobyte</h3>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.22 [deprecated]</code>
</div>
<p>Quobyte 인-트리 스토리지 플러그인은 사용 중단되었으며,
아웃-오브-트리 Quobyte 플러그인에 대한 <a href=https://github.com/quobyte/quobyte-csi/blob/master/example/StorageClass.yaml>예제</a>
<code>StorageClass</code>는 Quobyte CSI 저장소에서 찾을 수 있다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>storage.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StorageClass<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>   </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>slow<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>provisioner</span>:<span style=color:#bbb> </span>kubernetes.io/quobyte<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>parameters</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>quobyteAPIServer</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;http://138.68.74.142:7860&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>registry</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;138.68.74.142:7861&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>adminSecretName</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;quobyte-admin-secret&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>adminSecretNamespace</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;kube-system&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>user</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;root&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>group</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;root&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>quobyteConfig</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;BASE&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>quobyteTenant</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;DEFAULT&#34;</span><span style=color:#bbb>
</span></code></pre></div><ul>
<li>
<p><code>quobyteAPIServer</code>: <code>"http(s)://api-server:7860"</code> 형식의
Quobyte의 API 서버이다.</p>
</li>
<li>
<p><code>registry</code>: 볼륨을 마운트하는 데 사용할 Quobyte 레지스트리이다. 레지스트리를
<code>&lt;host>:&lt;port></code> 의 쌍으로 지정하거나 여러 레지스트리를
지정하려면 쉼표만 있으면 된다.
예: <code>&lt;host1>:&lt;port>,&lt;host2>:&lt;port>,&lt;host3>:&lt;port></code>
호스트는 IP 주소이거나 DNS가 작동 중인 경우
DNS 이름을 제공할 수도 있다.</p>
</li>
<li>
<p><code>adminSecretNamespace</code>: <code>adminSecretName</code> 의 네임스페이스.
기본값은 "default".</p>
</li>
<li>
<p><code>adminSecretName</code>: 시크릿은 API 서버에 대해 인증하기 위한 Quobyte 사용자와 암호에
대한 정보를 담고 있다. 제공된 시크릿은 "kubernetes.io/quobyte"
유형과 <code>user</code> 및 <code>password</code> 키를 가져야 하며, 예를 들면
다음과 같다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create secret generic quobyte-admin-secret <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --type<span style=color:#666>=</span><span style=color:#b44>&#34;kubernetes.io/quobyte&#34;</span> --from-literal<span style=color:#666>=</span><span style=color:#b8860b>user</span><span style=color:#666>=</span><span style=color:#b44>&#39;admin&#39;</span> --from-literal<span style=color:#666>=</span><span style=color:#b8860b>password</span><span style=color:#666>=</span><span style=color:#b44>&#39;opensesame&#39;</span> <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --namespace<span style=color:#666>=</span>kube-system
</code></pre></div></li>
<li>
<p><code>user</code>: 이 사용자에 대한 모든 접근을 매핑한다. 기본값은 "root".</p>
</li>
<li>
<p><code>group</code>: 이 그룹에 대한 모든 접근을 매핑한다. 기본값은 "nfsnobody".</p>
</li>
<li>
<p><code>quobyteConfig</code>: 지정된 구성을 사용해서 볼륨을 생성한다. 웹 콘솔
또는 quobyte CLI를 사용해서 새 구성을 작성하거나 기존 구성을
수정할 수 있다. 기본값은 "BASE".</p>
</li>
<li>
<p><code>quobyteTenant</code>: 지정된 테넌트 ID를 사용해서 볼륨을 생성/삭제한다.
이 Quobyte 테넌트는 이미 Quobyte에 있어야 한다.
기본값은 "DEFAULT".</p>
</li>
</ul>
<h3 id=azure-디스크>Azure 디스크</h3>
<h4 id=azure-unmanaged-disk-storage-class>Azure 비관리 디스크 스토리지 클래스</h4>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>storage.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StorageClass<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>slow<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>provisioner</span>:<span style=color:#bbb> </span>kubernetes.io/azure-disk<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>parameters</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>skuName</span>:<span style=color:#bbb> </span>Standard_LRS<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>location</span>:<span style=color:#bbb> </span>eastus<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>storageAccount</span>:<span style=color:#bbb> </span>azure_storage_account_name<span style=color:#bbb>
</span></code></pre></div><ul>
<li><code>skuName</code>: Azure 스토리지 계정 Sku 계층. 기본값은 없음.</li>
<li><code>location</code>: Azure 스토리지 계정 지역. 기본값은 없음.</li>
<li><code>storageAccount</code>: Azure 스토리지 계정 이름. 스토리지 계정이 제공되면, 클러스터와 동일한
리소스 그룹에 있어야 하며, <code>location</code> 은 무시된다. 스토리지 계정이
제공되지 않으면, 클러스터와 동일한 리소스
그룹에 새 스토리지 계정이 생성된다.</li>
</ul>
<h4 id=azure-disk-storage-class>Azure 디스크 스토리지 클래스(v1.7.2부터 제공)</h4>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>storage.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StorageClass<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>slow<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>provisioner</span>:<span style=color:#bbb> </span>kubernetes.io/azure-disk<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>parameters</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>storageaccounttype</span>:<span style=color:#bbb> </span>Standard_LRS<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>managed<span style=color:#bbb>
</span></code></pre></div><ul>
<li><code>storageaccounttype</code>: Azure 스토리지 계정 Sku 계층. 기본값은 없음.</li>
<li><code>kind</code>: 가능한 값은 <code>shared</code>, <code>dedicated</code>, 그리고 <code>managed</code> (기본값) 이다.
<code>kind</code> 가 <code>shared</code> 인 경우, 모든 비관리 디스크는 클러스터와
동일한 리소스 그룹에 있는 몇 개의 공유 스토리지 계정에 생성된다. <code>kind</code> 가
<code>dedicated</code> 인 경우, 클러스터와 동일한 리소스 그룹에서 새로운
비관리 디스크에 대해 새로운 전용 스토리지 계정이 생성된다. <code>kind</code> 가
<code>managed</code> 인 경우, 모든 관리 디스크는 클러스터와 동일한 리소스
그룹에 생성된다.</li>
<li><code>resourceGroup</code>: Azure 디스크를 만들 리소스 그룹을 지정한다.
기존에 있는 리소스 그룹 이름이어야 한다. 지정되지 않는 경우, 디스크는
현재 쿠버네티스 클러스터와 동일한 리소스 그룹에 배치된다.</li>
</ul>
<ul>
<li>프리미엄 VM은 표준 LRS(Standard_LRS)와 프리미엄 LRS(Premium_LRS) 디스크를 모두 연결할 수 있는 반면에,
표준 VM은 표준 LRS(Standard_LRS) 디스크만 연결할 수 있다.</li>
<li>관리되는 VM은 관리되는 디스크만 연결할 수 있고,
비관리 VM은 비관리 디스크만 연결할 수 있다.</li>
</ul>
<h3 id=azure-파일>Azure 파일</h3>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>storage.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StorageClass<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>azurefile<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>provisioner</span>:<span style=color:#bbb> </span>kubernetes.io/azure-file<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>parameters</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>skuName</span>:<span style=color:#bbb> </span>Standard_LRS<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>location</span>:<span style=color:#bbb> </span>eastus<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>storageAccount</span>:<span style=color:#bbb> </span>azure_storage_account_name<span style=color:#bbb>
</span></code></pre></div><ul>
<li><code>skuName</code>: Azure 스토리지 계정 Sku 계층. 기본값은 없음.</li>
<li><code>location</code>: Azure 스토리지 계정 지역. 기본값은 없음.</li>
<li><code>storageAccount</code>: Azure 스토리지 계정 이름. 기본값은 없음. 스토리지 계정이
제공되지 않으면, 리소스 그룹과 관련된 모든 스토리지 계정이
검색되어 <code>skuName</code> 과 <code>location</code> 이 일치하는 것을 찾는다. 스토리지 계정이
제공되면, 클러스터와 동일한 리소스 그룹에 있어야
하며 <code>skuName</code> 과 <code>location</code> 은 무시된다.</li>
<li><code>secretNamespace</code>: Azure 스토리지 계정 이름과 키가 포함된 시크릿
네임스페이스. 기본값은 파드와 동일하다.</li>
<li><code>secretName</code>: Azure 스토리지 계정 이름과 키가 포함된 시크릿 이름.
기본값은 <code>azure-storage-account-&lt;accountName>-secret</code></li>
<li><code>readOnly</code>: 스토리지가 읽기 전용으로 마운트되어야 하는지 여부를 나타내는 플래그.
읽기/쓰기 마운트를 의미하는 기본값은 false. 이 설정은
볼륨마운트(VolumeMounts)의 <code>ReadOnly</code> 설정에도 영향을 준다.</li>
</ul>
<p>스토리지 프로비저닝 중에 마운트 자격증명에 대해 <code>secretName</code>
이라는 시크릿이 생성된다. 클러스터에
<a href=/docs/reference/access-authn-authz/rbac/>RBAC</a>과
<a href=/docs/reference/access-authn-authz/rbac/#controller-roles>컨트롤러의 롤(role)들</a>을
모두 활성화한 경우, clusterrole <code>system:controller:persistent-volume-binder</code>
에 대한 <code>secret</code> 리소스에 <code>create</code> 권한을 추가한다.</p>
<p>다중 테넌시 컨텍스트에서 <code>secretNamespace</code> 의 값을 명시적으로 설정하는
것을 권장하며, 그렇지 않으면 다른 사용자가 스토리지 계정 자격증명을
읽을 수 있기 때문이다.</p>
<h3 id=portworx-볼륨>Portworx 볼륨</h3>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>storage.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StorageClass<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>portworx-io-priority-high<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>provisioner</span>:<span style=color:#bbb> </span>kubernetes.io/portworx-volume<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>parameters</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>repl</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;1&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>snap_interval</span>:<span style=color:#bbb>   </span><span style=color:#b44>&#34;70&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>priority_io</span>:<span style=color:#bbb>  </span><span style=color:#b44>&#34;high&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>
</span></code></pre></div><ul>
<li><code>fs</code>: 배치할 파일 시스템: <code>none/xfs/ext4</code> (기본값: <code>ext4</code>)</li>
<li><code>block_size</code>: Kbytes 단위의 블록 크기(기본값: <code>32</code>).</li>
<li><code>repl</code>: 레플리케이션 팩터 <code>1..3</code> (기본값: <code>1</code>)의 형태로 제공될
동기 레플리카의 수. 여기에는 문자열,
즉 <code>0</code> 이 아닌, <code>"0"</code> 이 필요하다.</li>
<li><code>priority_io</code>: 볼륨이 고성능 또는 우선 순위가 낮은 스토리지에서
생성될 것인지를 결정한다 <code>high/medium/low</code> (기본값: <code>low</code>).</li>
<li><code>snap_interval</code>: 스냅샷을 트리거할 때의 시각/시간 간격(분).
스냅샷은 이전 스냅샷과의 차이에 따라 증분되며, 0은 스냅을
비활성화 한다(기본값: <code>0</code>). 여기에는 문자열,
즉 <code>70</code> 이 아닌, <code>"70"</code> 이 필요하다.</li>
<li><code>aggregation_level</code>: 볼륨이 분배될 청크 수를 지정하며, 0은 집계되지 않은
볼륨을 나타낸다(기본값: <code>0</code>). 여기에는 문자열,
즉 <code>0</code> 이 아닌, <code>"0"</code> 이 필요하다.</li>
<li><code>ephemeral</code>: 마운트 해제 후 볼륨을 정리해야 하는지 혹은 지속적이어야
하는지를 지정한다. <code>emptyDir</code> 에 대한 유스케이스는 이 값을 true로
설정할 수 있으며, <code>persistent volumes</code> 에 대한 유스케이스인
카산드라와 같은 데이터베이스는 false로 설정해야 한다. <code>true/false</code> (기본값 <code>false</code>)
여기에는 문자열, 즉 <code>true</code> 가 아닌, <code>"true"</code> 가 필요하다.</li>
</ul>
<h3 id=scaleio>ScaleIO</h3>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>storage.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StorageClass<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>slow<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>provisioner</span>:<span style=color:#bbb> </span>kubernetes.io/scaleio<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>parameters</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>gateway</span>:<span style=color:#bbb> </span>https://192.168.99.200:443/api<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>system</span>:<span style=color:#bbb> </span>scaleio<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>protectionDomain</span>:<span style=color:#bbb> </span>pd0<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>storagePool</span>:<span style=color:#bbb> </span>sp1<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>storageMode</span>:<span style=color:#bbb> </span>ThinProvisioned<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>secretRef</span>:<span style=color:#bbb> </span>sio-secret<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;false&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>fsType</span>:<span style=color:#bbb> </span>xfs<span style=color:#bbb>
</span></code></pre></div><ul>
<li><code>provisioner</code>: 속성이 <code>kubernetes.io/scaleio</code> 로 설정되어 있다.</li>
<li><code>gateway</code>: ScaleIO API 게이트웨이 주소(필수)</li>
<li><code>system</code>: ScaleIO 시스템의 이름(필수)</li>
<li><code>protectionDomain</code>: ScaleIO 보호 도메인의 이름(필수)</li>
<li><code>storagePool</code>: 볼륨 스토리지 풀의 이름(필수)</li>
<li><code>storageMode</code>: 스토리지 프로비전 모드: <code>ThinProvisioned</code> (기본값) 또는
<code>ThickProvisioned</code></li>
<li><code>secretRef</code>: 구성된 시크릿 오브젝트에 대한 참조(필수)</li>
<li><code>readOnly</code>: 마운트된 볼륨에 대한 접근 모드의 지정(기본값: false)</li>
<li><code>fsType</code>: 볼륨에 사용할 파일 시스템 유형(기본값: ext4)</li>
</ul>
<p>ScaleIO 쿠버네티스 볼륨 플러그인에는 구성된 시크릿 오브젝트가 필요하다.
시크릿은 다음 명령에 표시된 것처럼 <code>kubernetes.io/scaleio</code> 유형으로
작성해야 하며, PVC와 동일한 네임스페이스
값을 사용해야 한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create secret generic sio-secret --type<span style=color:#666>=</span><span style=color:#b44>&#34;kubernetes.io/scaleio&#34;</span> <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>--from-literal<span style=color:#666>=</span><span style=color:#b8860b>username</span><span style=color:#666>=</span>sioadmin --from-literal<span style=color:#666>=</span><span style=color:#b8860b>password</span><span style=color:#666>=</span><span style=color:#b8860b>d2NABDNjMA</span><span style=color:#666>==</span> <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>--namespace<span style=color:#666>=</span>default
</code></pre></div><h3 id=storageos>StorageOS</h3>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>storage.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StorageClass<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>fast<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>provisioner</span>:<span style=color:#bbb> </span>kubernetes.io/storageos<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>parameters</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>pool</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>description</span>:<span style=color:#bbb> </span>Kubernetes volume<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>fsType</span>:<span style=color:#bbb> </span>ext4<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>adminSecretNamespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>adminSecretName</span>:<span style=color:#bbb> </span>storageos-secret<span style=color:#bbb>
</span></code></pre></div><ul>
<li><code>pool</code>: 볼륨을 프로비전할 StorageOS 분산 용량
풀의 이름. 지정되지 않은 경우 일반적으로 존재하는 <code>default</code> 풀을 사용한다.</li>
<li><code>description</code>: 동적으로 생성된 볼륨에 할당할 설명.
모든 볼륨 설명은 스토리지 클래스에 대해 동일하지만, 서로 다른
유스케이스에 대한 설명을 허용하기 위해 다른 스토리지 클래스를 사용할 수 있다.
기본값은 <code>Kubernetes volume</code>.</li>
<li><code>fsType</code>: 요청할 기본 파일 시스템 유형. StorageOS 내의 사용자
정의 규칙이 이 값을 무시할 수 있다. 기본 값은 <code>ext4</code>.</li>
<li><code>adminSecretNamespace</code>: API 구성 시크릿이 있는 네임스페이스.
adminSecretName 이 설정된 경우 필수이다.</li>
<li><code>adminSecretName</code>: StorageOS API 자격증명을 얻는 데 사용할 시크릿의 이름.
지정하지 않으면 기본값이 시도된다.</li>
</ul>
<p>StorageOS 쿠버네티스 볼륨 플러그인은 시크릿 오브젝트를 사용해서 StorageOS API에
접근하기 위한 엔드포인트와 자격증명을 지정할 수 있다. 이것은 기본값이
변경된 경우에만 필요하다.
시크릿은 다음의 명령과 같이 <code>kubernetes.io/storageos</code> 유형으로
만들어야 한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create secret generic storageos-secret <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>--type<span style=color:#666>=</span><span style=color:#b44>&#34;kubernetes.io/storageos&#34;</span> <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>--from-literal<span style=color:#666>=</span><span style=color:#b8860b>apiAddress</span><span style=color:#666>=</span>tcp://localhost:5705 <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>--from-literal<span style=color:#666>=</span><span style=color:#b8860b>apiUsername</span><span style=color:#666>=</span>storageos <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>--from-literal<span style=color:#666>=</span><span style=color:#b8860b>apiPassword</span><span style=color:#666>=</span>storageos <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>--namespace<span style=color:#666>=</span>default
</code></pre></div><p>동적으로 프로비전된 볼륨에 사용되는 시크릿은 모든 네임스페이스에서
생성할 수 있으며 <code>adminSecretNamespace</code> 파라미터로 참조될 수 있다.
사전에 프로비전된 볼륨에서 사용하는 시크릿은 이를 참조하는 PVC와
동일한 네임스페이스에서 작성해야 한다.</p>
<h3 id=local>Local</h3>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.14 [stable]</code>
</div>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>storage.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StorageClass<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>local-storage<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>provisioner</span>:<span style=color:#bbb> </span>kubernetes.io/no-provisioner<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>volumeBindingMode</span>:<span style=color:#bbb> </span>WaitForFirstConsumer<span style=color:#bbb>
</span></code></pre></div><p>로컬 볼륨은 현재 동적 프로비저닝을 지원하지 않지만, 파드 스케줄링까지
볼륨 바인딩을 지연시키기 위해서는 스토리지클래스가 여전히 생성되어야 한다. 이것은
<code>WaitForFirstConsumer</code> 볼륨 바인딩 모드에 의해 지정된다.</p>
<p>볼륨 바인딩을 지연시키면 스케줄러가 퍼시스턴트볼륨클레임에
적절한 퍼시스턴트볼륨을 선택할 때 파드의 모든 스케줄링
제약 조건을 고려할 수 있다.</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-df33eab51202c17bb0fe551d1d5cc5d2>6.4 - 임시 볼륨</h1>
<p>이 문서는 쿠버네티스의 <em>임시(ephemeral) 볼륨</em> 에 대해 설명한다.
쿠버네티스 <a href=/ko/docs/concepts/storage/volumes/>볼륨</a>,
특히 퍼시스턴트볼륨클레임(PersistentVolumeClaim) 및 퍼시스턴트볼륨(PersistentVolume)에 대해 잘 알고 있는 것이 좋다.</p>
<p>일부 애플리케이션은 추가적인 저장소를 필요로 하면서도
재시작 시 데이터의 영구적 보존 여부는 신경쓰지 않을 수도 있다.
예를 들어, 캐싱 서비스는 종종 메모리 사이즈에 제약을 받으며
이에 따라 전반적인 성능에 적은 영향을 미치면서도
사용 데이터를 메모리보다는 느린 저장소에 간헐적으로 옮길 수도 있다.</p>
<p>또 다른 애플리케이션은 읽기 전용 입력 데이터를 파일에서 읽도록 되어 있으며,
이러한 데이터의 예시로는 구성 데이터 또는 비밀 키 등이 있다.</p>
<p><em>임시 볼륨</em> 은 이러한 사용 사례를 위해 설계되었다.
임시 볼륨은 파드의 수명을 따르며 파드와 함께 생성 및 삭제되기 때문에,
일부 퍼시스턴트 볼륨이 어디에서 사용 가능한지에 제약되는 일 없이
파드가 중지 및 재시작될 수 있다.</p>
<p>임시 볼륨은 파드 명세에 <em>인라인</em> 으로 명시되며,
이로 인해 애플리케이션 배포 및 관리가 간편해진다.</p>
<h3 id=임시-볼륨의-종류>임시 볼륨의 종류</h3>
<p>쿠버네티스는 각 목적에 맞는
몇 가지의 임시 볼륨을 지원한다.</p>
<ul>
<li><a href=/ko/docs/concepts/storage/volumes/#emptydir>emptyDir</a>:
파드가 시작될 때 빈 상태로 시작되며,
저장소는 로컬의 kubelet 베이스 디렉터리(보통 루트 디스크) 또는 램에서 제공된다</li>
<li><a href=/ko/docs/concepts/storage/volumes/#configmap>configMap</a>,
<a href=/ko/docs/concepts/storage/volumes/#downwardapi>downwardAPI</a>,
<a href=/ko/docs/concepts/storage/volumes/#secret>secret</a>:
각 종류의 쿠버네티스 데이터를 파드에 주입한다</li>
<li><a href=#csi-ephemeral-volumes>CSI 임시 볼륨</a>:
앞의 볼륨 종류와 비슷하지만,
특히 <a href=https://kubernetes-csi.github.io/docs/drivers.html>이 기능을 지원</a>하는 특수한
<a href=https://github.com/container-storage-interface/spec/blob/master/spec.md>CSI 드라이버</a>에 의해 제공된다</li>
<li><a href=#generic-ephemeral-volumes>일반(generic) 임시 볼륨</a>:
퍼시스턴트 볼륨도 지원하는 모든 스토리지 드라이버에 의해 제공될 수 있다</li>
</ul>
<p><code>emptyDir</code>, <code>configMap</code>, <code>downwardAPI</code>, <code>secret</code>은
<a href=/ko/docs/concepts/configuration/manage-resources-containers/#%EB%A1%9C%EC%BB%AC-%EC%9E%84%EC%8B%9C-ephemeral-%EC%8A%A4%ED%86%A0%EB%A6%AC%EC%A7%80>로컬 임시 스토리지</a>로서
제공된다.
이들은 각 노드의 kubelet에 의해 관리된다.</p>
<p>CSI 임시 볼륨은
써드파티 CSI 스토리지 드라이버에 의해 제공 <em>되어야 한다</em>.</p>
<p>일반 임시 볼륨은 써드파티 CSI 스토리지 드라이버에 의해 제공 <em>될 수 있지만</em>,
동적 프로비저닝을 지원하는 다른 스토리지 드라이버에 의해서도 제공될 수 있다.
일부 CSI 드라이버는 특히 CSI 임시 볼륨을 위해 만들어져서
동적 프로비저닝을 지원하지 않는데,
이러한 경우에는 일반 임시 볼륨 용으로는 사용할 수 없다.</p>
<p>써드파티 드라이버 사용의 장점은
쿠버네티스 자체적으로는 지원하지 않는 기능(예:
kubelet에서 관리하는 디스크와 성능 특성이 다른 스토리지, 또는 다른 데이터 주입)을
제공할 수 있다는 것이다.</p>
<h3 id=csi-ephemeral-volumes>CSI 임시 볼륨</h3>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.16 [beta]</code>
</div>
<p>이 기능을 사용하려면 <code>CSIInlineVolume</code> <a href=/ko/docs/reference/command-line-tools-reference/feature-gates/>기능 게이트</a>를 활성화해야 한다.
쿠버네티스 1.16부터는 기본적으로 활성화되어 있다.</p>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> CSI 드라이버 중 일부만 CSI 임시 볼륨을 지원한다.
쿠버네티스 CSI <a href=https://kubernetes-csi.github.io/docs/drivers.html>드라이버 목록</a>에서
어떤 드라이버가 임시 볼륨을 지원하는지 보여 준다.
</div>
<p>개념적으로, CSI 임시 볼륨은 <code>configMap</code>, <code>downwardAPI</code>, <code>secret</code> 볼륨 유형과 비슷하다.
즉, 스토리지는 각 노드에서 로컬하게 관리되며,
파드가 노드에 스케줄링된 이후에 다른 로컬 리소스와 함께 생성된다.
쿠버네티스에는 지금 단계에서는 파드를 재스케줄링하는 개념이 없다.
볼륨 생성은 실패하는 일이 거의 없어야 하며,
만약 실패할 경우 파드 시작 과정이 중단될 것이다.
특히, <a href=/ko/docs/concepts/storage/storage-capacity/>스토리지 용량 인지 파드 스케줄링</a>은
이러한 볼륨에 대해서는 지원되지 <em>않는다</em>.
또한 이러한 볼륨은 파드의 스토리지 자원 사용 상한에 제한받지 않는데,
이는 kubelet 자신이 관리하는 스토리지에만 강제할 수 있는 것이기 때문이다.</p>
<p>다음은 CSI 임시 스토리지를 사용하는 파드에 대한 예시 매니페스트이다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-csi-app<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-frontend<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/data&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-csi-inline-vol<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#bbb> </span><span style=color:#b44>&#34;sleep&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;1000000&#34;</span><span style=color:#bbb> </span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-csi-inline-vol<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>csi</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>driver</span>:<span style=color:#bbb> </span>inline.storage.kubernetes.io<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>volumeAttributes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>foo</span>:<span style=color:#bbb> </span>bar<span style=color:#bbb>
</span></code></pre></div><p><code>volumeAttributes</code>은 드라이버에 의해 어떤 볼륨이 준비되는지를 결정한다.
이러한 속성은 각 드라이버별로 다르며 표준화되지 않았다.
더 자세한 사항은 각 CSI 드라이버 문서를
참고한다.</p>
<p>클러스터 관리자는, <a href=/ko/docs/concepts/policy/pod-security-policy/>파드시큐리티폴리시(PodSecurityPolicy)</a>를 사용하여 파드 내에서 어떤 CSI 드라이버가 사용될 수 있는지를 제어할 수 있으며,
<a href=/docs/reference/generated/kubernetes-api/v1.23/#podsecuritypolicyspec-v1beta1-policy><code>allowedCSIDrivers</code> 필드</a>에 기재하면 된다.</p>
<h3 id=generic-ephemeral-volumes>일반 임시 볼륨</h3>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.23 [stable]</code>
</div>
<p>일반 임시 볼륨은
프로비저닝 후 일반적으로 비어 있는 스크래치 데이터에 대해 파드 별 디렉터리를 제공한다는 점에서
<code>emptyDir</code> 볼륨과 유사하다.
하지만 다음과 같은 추가 기능도 제공한다.</p>
<ul>
<li>스토리지는 로컬이거나 네트워크 연결형(network-attached)일 수 있다.</li>
<li>볼륨의 크기를 고정할 수 있으며 파드는 이 크기를 초과할 수 없다.</li>
<li>드라이버와 파라미터에 따라
볼륨이 초기 데이터를 가질 수도 있다.</li>
<li>볼륨에 대한 일반적인 작업은 드라이버가 지원하는 범위 내에서 지원된다.
이와 같은 작업은 다음을 포함한다.
<a href=/ko/docs/concepts/storage/volume-snapshots/>스냅샷</a>,
<a href=/ko/docs/concepts/storage/volume-pvc-datasource/>복제</a>,
<a href=/ko/docs/concepts/storage/persistent-volumes/#%ED%8D%BC%EC%8B%9C%EC%8A%A4%ED%84%B4%ED%8A%B8-%EB%B3%BC%EB%A5%A8-%ED%81%B4%EB%A0%88%EC%9E%84-%ED%99%95%EC%9E%A5>크기 조정</a>,
및 <a href=/ko/docs/concepts/storage/storage-capacity/>스토리지 용량 추적</a>.</li>
</ul>
<p>다음은 예시이다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-app<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-frontend<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/scratch&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>scratch-volume<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#bbb> </span><span style=color:#b44>&#34;sleep&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;1000000&#34;</span><span style=color:#bbb> </span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>scratch-volume<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>ephemeral</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>volumeClaimTemplate</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>my-frontend-volume<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb> </span>[<span style=color:#bbb> </span><span style=color:#b44>&#34;ReadWriteOnce&#34;</span><span style=color:#bbb> </span>]<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>storageClassName</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;scratch-storage-class&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>                </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>1Gi<span style=color:#bbb>
</span></code></pre></div><h3 id=라이프사이클-및-퍼시스턴트볼륨클레임>라이프사이클 및 퍼시스턴트볼륨클레임</h3>
<p>핵심 설계 아이디어는
<a href=/docs/reference/generated/kubernetes-api/v1.23/#ephemeralvolumesource-v1alpha1-core>볼륨 클레임을 위한 파라미터</a>는
파드의 볼륨 소스 내부에서 허용된다는 점이다.
레이블, 어노테이션 및 퍼시스턴트볼륨클레임을 위한 모든 필드가 지원된다.
이러한 파드가 생성되면, 임시 볼륨 컨트롤러는 파드가 속한 동일한 네임스페이스에
퍼시스턴트볼륨클레임 오브젝트를 생성하고
파드가 삭제될 때에는 퍼시스턴트볼륨클레임도 삭제되도록 만든다.</p>
<p>이는 볼륨 바인딩 및/또는 프로비저닝을 유발하는데,
<a class=glossary-tooltip title="스토리지클래스는 관리자가 사용 가능한 다양한 스토리지 유형을 설명할 수 있는 방법을 제공한다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/storage/storage-classes target=_blank aria-label=스토리지클래스>스토리지클래스</a>가
즉각적인(immediate) 볼륨 바인딩을 사용하는 경우에는 즉시,
또는 파드가 노드에 잠정적으로 스케줄링되었을 때 발생한다(<code>WaitForFirstConsumer</code> 볼륨 바인딩 모드).
일반 임시 볼륨에는 후자가 추천되는데, 이 경우 스케줄러가 파드를 할당하기에 적합한 노드를 선택하기가 쉬워지기 때문이다.
즉각적인 바인딩을 사용하는 경우,
스케줄러는 볼륨이 사용 가능해지는 즉시 해당 볼륨에 접근 가능한 노드를 선택하도록 강요받는다.</p>
<p><a href=/ko/docs/concepts/workloads/controllers/garbage-collection/#%EC%86%8C%EC%9C%A0%EC%9E%90-owner-%EC%99%80-%EC%A2%85%EC%86%8D-dependent>리소스 소유권</a> 관점에서,
일반 임시 스토리지를 갖는 파드는
해당 임시 스토리지를 제공하는 퍼시스턴트볼륨클레임의 소유자이다.
파드가 삭제되면, 쿠버네티스 가비지 콜렉터는 해당 PVC를 삭제하는데,
스토리지 클래스의 기본 회수 정책이 볼륨을 삭제하는 것이기 때문에 PVC의 삭제는 보통 볼륨의 삭제를 유발한다.
회수 정책을 <code>retain</code>으로 설정한 스토리지클래스를 사용하여 준 임시(quasi-ephemeral) 로컬 스토리지를 생성할 수도 있는데,
이렇게 하면 스토리지의 수명이 파드의 수명보다 길어지며,
이러한 경우 볼륨 정리를 별도로 수행해야 함을 명심해야 한다.</p>
<p>이러한 PVC가 존재하는 동안은, 다른 PVC와 동일하게 사용될 수 있다.
특히, 볼륨 복제 또는 스냅샷 시에 데이터 소스로 참조될 수 있다.
또한 해당 PVC 오브젝트는 해당 볼륨의 현재 상태도
가지고 있다.</p>
<h3 id=퍼시스턴트볼륨클레임-이름-정하기>퍼시스턴트볼륨클레임 이름 정하기</h3>
<p>자동으로 생성된 PVC의 이름은 규칙에 따라 정해진다.
PVC의 이름은 파드 이름과 볼륨 이름의 사이를 하이픈(<code>-</code>)으로 결합한 형태이다.
위의 예시에서, PVC 이름은 <code>my-app-scratch-volume</code>가 된다.
이렇게 규칙에 의해 정해진 이름은 PVC와의 상호작용을 더 쉽게 만드는데,
이는 파드 이름과 볼륨 이름을 알면
PVC 이름을 별도로 검색할 필요가 없기 때문이다.</p>
<p>PVC 이름 규칙에 따라 서로 다른 파드 간 이름 충돌이 발생할 수
있으며("pod-a" 파드 + "scratch" 볼륨 vs. "pod" 파드 + "a-scratch" 볼륨 -
두 경우 모두 PVC 이름은 "pod-a-scratch")
또한 파드와 수동으로 생성한 PVC 간에도 이름 충돌이 발생할 수 있다.</p>
<p>이러한 충돌은 감지될 수 있는데, 이는 PVC가 파드를 위해 생성된 경우에만 임시 볼륨으로 사용되기 때문이다.
이러한 체크는 소유권 관계를 기반으로 한다.
기존에 존재하던 PVC는 덮어써지거나 수정되지 않는다.
대신에 충돌을 해결해주지는 않는데,
이는 적합한 PVC가 없이는 파드가 시작될 수 없기 때문이다.</p>
<div class="alert alert-warning caution callout" role=alert>
<strong>주의:</strong> 이러한 충돌이 발생하지 않도록
동일한 네임스페이스 내에서는 파드와 볼륨의 이름을 정할 때 주의해야 한다.
</div>
<h3 id=보안>보안</h3>
<p>GenericEphemeralVolume 기능을 활성화하면
사용자가 파드를 생성할 수 있는 경우 PVC를 간접적으로 생성할 수 있도록 허용하며,
심지어 사용자가 PVC를 직접적으로 만들 수 있는 권한이 없는 경우에도 이를 허용한다.
클러스터 관리자는 이를 명심해야 한다.
이것이 보안 모델에 부합하지 않는다면, 다음의 두 가지 선택지가 있다.</p>
<ul>
<li><code>volumes</code>의 목록 중에 <code>ephemeral</code> 볼륨 타입이 없는 경우,
<a href=/ko/docs/concepts/policy/pod-security-policy/>파드시큐리티폴리시</a>를
사용한다(쿠버네티스
1.21에서 사용 중단됨).</li>
<li>일반 임시 볼륨을 갖는 파드와 같은 오브젝트를 거부하는
<a href=/docs/reference/access-authn-authz/extensible-admission-controllers/>어드미션 웹훅</a>을
사용한다.</li>
</ul>
<p>일반적인 <a href=/ko/docs/concepts/policy/resource-quotas/#%EC%8A%A4%ED%86%A0%EB%A6%AC%EC%A7%80-%EB%A6%AC%EC%86%8C%EC%8A%A4-%EC%BF%BC%ED%84%B0>PVC의 네임스페이스 쿼터</a>는 여전히 적용되므로,
사용자가 이 새로운 메카니즘을 사용할 수 있도록 허용되었어도,
다른 정책을 우회하는 데에는 사용할 수 없다.</p>
<h2 id=다음-내용>다음 내용</h2>
<h3 id=kubelet이-관리하는-임시-볼륨>kubelet이 관리하는 임시 볼륨</h3>
<p><a href=/ko/docs/concepts/configuration/manage-resources-containers/#%EB%A1%9C%EC%BB%AC-%EC%9E%84%EC%8B%9C-ephemeral-%EC%8A%A4%ED%86%A0%EB%A6%AC%EC%A7%80>로컬 임시 스토리지</a>를 참고한다.</p>
<h3 id=csi-임시-볼륨>CSI 임시 볼륨</h3>
<ul>
<li>설계에 대한 더 자세한 정보는
<a href=https://github.com/kubernetes/enhancements/blob/ad6021b3d61a49040a3f835e12c8bb5424db2bbb/keps/sig-storage/20190122-csi-inline-volumes.md>임시 인라인 CSI 볼륨 KEP</a>를 참고한다.</li>
<li>이 기능의 추가 개발에 대한 자세한 정보는 <a href=https://github.com/kubernetes/enhancements/issues/596>enhancement 저장소의 이슈 #596</a>을 참고한다.</li>
</ul>
<h3 id=일반-임시-볼륨>일반 임시 볼륨</h3>
<ul>
<li>설계에 대한 더 자세한 정보는
<a href=https://github.com/kubernetes/enhancements/blob/master/keps/sig-storage/1698-generic-ephemeral-volumes/README.md>일반 임시 인라인 볼륨 KEP</a>를 참고한다.</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-018f0a7fc6e2f6d16da37702fc39b4f3>6.5 - 동적 볼륨 프로비저닝</h1>
<p>동적 볼륨 프로비저닝을 통해 온-디맨드 방식으로 스토리지 볼륨을 생성할 수 있다.
동적 프로비저닝이 없으면 클러스터 관리자는 클라우드 또는 스토리지
공급자에게 수동으로 요청해서 새 스토리지 볼륨을 생성한 다음, 쿠버네티스에
표시하기 위해 <a href=/ko/docs/concepts/storage/persistent-volumes/><code>PersistentVolume</code> 오브젝트</a>를
생성해야 한다. 동적 프로비저닝 기능을 사용하면 클러스터 관리자가
스토리지를 사전 프로비저닝 할 필요가 없다. 대신 사용자가
스토리지를 요청하면 자동으로 프로비저닝 한다.</p>
<h2 id=배경>배경</h2>
<p>동적 볼륨 프로비저닝의 구현은 <code>storage.k8s.io</code> API 그룹의 <code>StorageClass</code>
API 오브젝트를 기반으로 한다. 클러스터 관리자는 볼륨을 프로비전하는
<em>볼륨 플러그인</em> (프로비저너라고도 알려짐)과 프로비저닝시에 프로비저너에게
전달할 파라미터 집합을 지정하는 <code>StorageClass</code>
오브젝트를 필요한 만큼 정의할 수 있다.
클러스터 관리자는 클러스터 내에서 사용자 정의 파라미터 집합을
사용해서 여러 가지 유형의 스토리지 (같거나 다른 스토리지 시스템들)를
정의하고 노출시킬 수 있다. 또한 이 디자인을 통해 최종 사용자는
스토리지 프로비전 방식의 복잡성과 뉘앙스에 대해 걱정할 필요가 없다. 하지만,
여전히 여러 스토리지 옵션들을 선택할 수 있다.</p>
<p>스토리지 클래스에 대한 자세한 정보는
<a href=/ko/docs/concepts/storage/storage-classes/>여기</a>에서 찾을 수 있다.</p>
<h2 id=동적-프로비저닝-활성화하기>동적 프로비저닝 활성화하기</h2>
<p>동적 프로비저닝을 활성화하려면 클러스터 관리자가 사용자를 위해 하나 이상의 스토리지클래스(StorageClass)
오브젝트를 사전 생성해야 한다.
스토리지클래스 오브젝트는 동적 프로비저닝이 호출될 때 사용할 프로비저너와
해당 프로비저너에게 전달할 파라미터를 정의한다.
스토리지클래스 오브젝트의 이름은 유효한
<a href=/ko/docs/concepts/overview/working-with-objects/names/#dns-%EC%84%9C%EB%B8%8C%EB%8F%84%EB%A9%94%EC%9D%B8-%EC%9D%B4%EB%A6%84>DNS 서브도메인 이름</a>이어야 한다.</p>
<p>다음 매니페스트는 표준 디스크와 같은 퍼시스턴트 디스크를 프로비전하는
스토리지 클래스 "slow"를 만든다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>storage.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StorageClass<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>slow<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>provisioner</span>:<span style=color:#bbb> </span>kubernetes.io/gce-pd<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>parameters</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>pd-standard<span style=color:#bbb>
</span></code></pre></div><p>다음 매니페스트는 SSD와 같은 퍼시스턴트 디스크를 프로비전하는
스토리지 클래스 "fast"를 만든다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>storage.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StorageClass<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>fast<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>provisioner</span>:<span style=color:#bbb> </span>kubernetes.io/gce-pd<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>parameters</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>pd-ssd<span style=color:#bbb>
</span></code></pre></div><h2 id=동적-프로비저닝-사용하기>동적 프로비저닝 사용하기</h2>
<p>사용자는 <code>PersistentVolumeClaim</code> 에 스토리지 클래스를 포함시켜 동적으로 프로비전된
스토리지를 요청한다. 쿠버네티스 v1.6 이전에는 <code>volume.beta.kubernetes.io/storage-class</code>
어노테이션을 통해 수행되었다. 그러나 이 어노테이션은
v1.9부터는 더 이상 사용하지 않는다. 사용자는 이제 <code>PersistentVolumeClaim</code> 오브젝트의
<code>storageClassName</code> 필드를 사용해야 한다. 이 필드의 값은
관리자가 구성한 <code>StorageClass</code> 의 이름과
일치해야 한다. (<a href=#%EB%8F%99%EC%A0%81-%ED%94%84%EB%A1%9C%EB%B9%84%EC%A0%80%EB%8B%9D-%ED%99%9C%EC%84%B1%ED%99%94%ED%95%98%EA%B8%B0>아래</a>를 참고)</p>
<p>예를 들어 "fast" 스토리지 클래스를 선택하려면 다음과
같은 <code>PersistentVolumeClaim</code> 을 생성한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolumeClaim<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>claim1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- ReadWriteOnce<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>storageClassName</span>:<span style=color:#bbb> </span>fast<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>30Gi<span style=color:#bbb>
</span></code></pre></div><p>이 클레임의 결과로 SSD와 같은 퍼시스턴트 디스크가 자동으로
프로비전 된다. 클레임이 삭제되면 볼륨이 삭제된다.</p>
<h2 id=기본-동작>기본 동작</h2>
<p>스토리지 클래스가 지정되지 않은 경우 모든 클레임이 동적으로
프로비전이 되도록 클러스터에서 동적 프로비저닝을 활성화 할 수 있다. 클러스터 관리자는
이 방법으로 활성화 할 수 있다.</p>
<ul>
<li>하나의 <code>StorageClass</code> 오브젝트를 <em>default</em> 로 표시한다.</li>
<li>API 서버에서 <a href=/docs/reference/access-authn-authz/admission-controllers/#defaultstorageclass><code>DefaultStorageClass</code> 어드미션 컨트롤러</a>를
사용하도록 설정한다.</li>
</ul>
<p>관리자는 <code>storageclass.kubernetes.io/is-default-class</code> 어노테이션을
추가해서 특정 <code>StorageClass</code> 를 기본으로 표시할 수 있다.
기본 <code>StorageClass</code> 가 클러스터에 존재하고 사용자가
<code>storageClassName</code> 를 지정하지 않은 <code>PersistentVolumeClaim</code> 을
작성하면, <code>DefaultStorageClass</code> 어드미션 컨트롤러가 디폴트
스토리지 클래스를 가리키는 <code>storageClassName</code> 필드를 자동으로 추가한다.</p>
<p>클러스터에는 최대 하나의 <em>default</em> 스토리지 클래스가 있을 수 있다. 그렇지 않은 경우
<code>storageClassName</code> 을 명시적으로 지정하지 않은 <code>PersistentVolumeClaim</code> 을
생성할 수 없다.</p>
<h2 id=토폴로지-인식>토폴로지 인식</h2>
<p><a href=/ko/docs/setup/best-practices/multiple-zones/>다중 영역</a> 클러스터에서 파드는 한 지역 내
여러 영역에 걸쳐 분산될 수 있다. 파드가 예약된 영역에서 단일 영역 스토리지 백엔드를
프로비전해야 한다. <a href=/ko/docs/concepts/storage/storage-classes/#%EB%B3%BC%EB%A5%A8-%EB%B0%94%EC%9D%B8%EB%94%A9-%EB%AA%A8%EB%93%9C>볼륨 바인딩 모드</a>를
설정해서 수행할 수 있다.</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-c262af210c6828dec445d2f55a1d877a>6.6 - 볼륨 스냅샷</h1>
<p>쿠버네티스에서 스토리지 시스템 볼륨 스냅샷은 <em>VolumeSnapshot</em> 을 나타낸다. 이 문서는 이미 쿠버네티스 <a href=/ko/docs/concepts/storage/persistent-volumes/>퍼시스턴트 볼륨</a>에 대해 잘 알고 있다고 가정한다.</p>
<h2 id=소개>소개</h2>
<p>API 리소스 <code>PersistentVolume</code> 및 <code>PersistentVolumeClaim</code> 가 사용자 및 관리자가 볼륨을 프로비전할 때의 방법과 유사하게, <code>VolumeSnapshotContent</code> 및 <code>VolumeSnapshot</code> API 리소스는 볼륨 스냅샷을 생성하기 위해 제공된다.</p>
<p><code>VolumeSnapshotContent</code> 는 관리자가 프로버져닝한 클러스터 볼륨에서의 스냅샷이다. 퍼시스턴트볼륨이 클러스터 리소스인 것처럼 이것 또한 클러스터 리소스이다.</p>
<p><code>VolumeSnapshot</code> 은 사용자가 볼륨의 스냅샷을 요청할 수 있는 방법이다. 이는 퍼시스턴트볼륨클레임과 유사하다.</p>
<p><code>VolumeSnapshotClass</code> 을 사용하면 <code>VolumeSnapshot</code> 에 속한 다른 속성을 지정할 수 있다. 이러한 속성은 스토리지 시스템에의 동일한 볼륨에서 가져온 스냅샷마다 다를 수 있으므로 <code>PersistentVolumeClaim</code> 의 <code>StorageClass</code> 를 사용하여 표현할 수는 없다.</p>
<p>볼륨 스냅샷은 쿠버네티스 사용자에게 완전히 새로운 볼륨을 생성하지 않고도 특정 시점에 볼륨의 콘텐츠를 복사하는 표준화된 방법을 제공한다. 예를 들어, 데이터베이스 관리자는 이 기능을 사용하여 수정 사항을 편집 또는 삭제하기 전에 데이터베이스를 백업할 수 있다.</p>
<p>사용자는 이 기능을 사용할 때 다음 사항을 알고 있어야 한다.</p>
<ul>
<li>API 오브젝트인 <code>VolumeSnapshot</code>, <code>VolumeSnapshotContent</code>, <code>VolumeSnapshotClass</code> 는 핵심 API가 아닌, <a class=glossary-tooltip title="사용자 정의 서버를 완전히 새로 구축할 필요가 없도록 쿠버네티스 API 서버에 추가할 리소스를 정의하는 사용자 정의 코드." data-toggle=tooltip data-placement=top href=/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/ target=_blank aria-label=CRDs>CRDs</a>이다.</li>
<li><code>VolumeSnapshot</code> 은 CSI 드라이버에서만 사용할 수 있다.</li>
<li>쿠버네티스 팀은 <code>VolumeSnapshot</code> 의 배포 프로세스 일부로써, 컨트롤 플레인에 배포할 스냅샷 컨트롤러와 CSI 드라이버와 함께 배포할 csi-snapshotter라는 사이드카 헬퍼(helper) 컨테이너를 제공한다. 스냅샷 컨트롤러는 <code>VolumeSnapshot</code> 및 <code>VolumeSnapshotContent</code> 오브젝트를 관찰하고 동적 프로비저닝에서 <code>VolumeSnapshotContent</code> 오브젝트의 생성 및 삭제를 할 수 있다.사이드카 csi-snapshotter는 <code>VolumeSnapshotContent</code> 오브젝트를 관찰하고 CSI 엔드포인트에 대해 <code>CreateSnapshot</code> 및 <code>DeleteSnapshot</code> 을 트리거(trigger)한다.</li>
<li>스냅샷 오브젝트에 대한 강화된 검증을 제공하는 검증 웹훅 서버도 있다. 이는 CSI 드라이버가 아닌 스냅샷 컨트롤러 및 CRD와 함께 쿠버네티스 배포판에 의해 설치되어야 한다. 스냅샷 기능이 활성화된 모든 쿠버네티스 클러스터에 설치해야 한다.</li>
<li>CSI 드라이버에서의 볼륨 스냅샷 기능 유무는 확실하지 않다. 볼륨 스냅샷 서포트를 제공하는 CSI 드라이버는 csi-snapshotter를 사용할 가능성이 높다. 자세한 사항은 <a href=https://kubernetes-csi.github.io/docs/>CSI 드라이버 문서</a>를 확인하면 된다.</li>
<li>CRDs 및 스냅샷 컨트롤러는 쿠버네티스 배포 시 설치된다.</li>
</ul>
<h2 id=볼륨-스냅샷-및-볼륨-스냅샷-컨텐츠의-라이프사이클>볼륨 스냅샷 및 볼륨 스냅샷 컨텐츠의 라이프사이클</h2>
<p><code>VolumeSnapshotContents</code> 은 클러스터 리소스이다. <code>VolumeSnapshots</code> 은 이러한 리소스의 요청이다. <code>VolumeSnapshotContents</code> 과 <code>VolumeSnapshots</code>의 상호 작용은 다음과 같은 라이프사이클을 따른다.</p>
<h3 id=프로비저닝-볼륨-스냅샷>프로비저닝 볼륨 스냅샷</h3>
<p>스냅샷을 프로비저닝할 수 있는 방법에는 사전 프로비저닝 혹은 동적 프로비저닝의 두 가지가 있다: .</p>
<h4 id=static>사전 프로비전</h4>
<p>클러스터 관리자는 많은 <code>VolumeSnapshotContents</code> 을 생성한다. 그들은 클러스터 사용자들이 사용 가능한 스토리지 시스템의 실제 볼륨 스냅샷 세부 정보를 제공한다. 이것은 쿠버네티스 API에 있고 사용 가능하다.</p>
<h4 id=동적>동적</h4>
<p>사전 프로비저닝을 사용하는 대신 퍼시스턴트볼륨클레임에서 스냅샷을 동적으로 가져오도록 요청할 수 있다. <a href=/ko/docs/concepts/storage/volume-snapshot-classes/>볼륨스냅샷클래스</a>는 스냅샷 사용 시 스토리지 제공자의 특정 파라미터를 명세한다.</p>
<h3 id=바인딩>바인딩</h3>
<p>스냅샷 컨트롤러는 사전 프로비저닝과 동적 프로비저닝된 시나리오에서 <code>VolumeSnapshot</code> 오브젝트와 적절한 <code>VolumeSnapshotContent</code> 오브젝트와의 바인딩을 처리한다. 바인딩은 1:1 매핑이다.</p>
<p>사전 프로비저닝된 경우, 볼륨스냅샷은 볼륨스냅샷컨텐츠 오브젝트 생성이 요청될 때까지 바인드되지 않은 상태로 유지된다.</p>
<h3 id=스냅샷-소스-보호로서의-퍼시스턴트-볼륨-클레임>스냅샷 소스 보호로서의 퍼시스턴트 볼륨 클레임</h3>
<p>이 보호의 목적은 스냅샷이 생성되는 동안 사용 중인
<a class=glossary-tooltip title="컨테이너의 볼륨으로 마운트될 수 있도록 퍼시스턴트볼륨(PersistentVolume)에 정의된 스토리지 리소스를 요청한다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/storage/persistent-volumes/ target=_blank aria-label=퍼시스턴트볼륨클레임>퍼시스턴트볼륨클레임</a>
API 오브젝트가 시스템에서 지워지지 않게 하는 것이다(데이터 손실이 발생할 수 있기 때문에).</p>
<p>퍼시스턴트볼륨클레임이 스냅샷을 생성할 동안에는 해당 퍼시스턴트볼륨클레임은 사용 중인 상태이다. 스냅샷 소스로 사용 중인 퍼시스턴트볼륨클레임 API 오브젝트를 삭제한다면, 퍼시스턴트볼륨클레임 오브젝트는 즉시 삭제되지 않는다. 대신, 퍼시스턴트볼륨클레임 오브젝트 삭제는 스냅샷이 준비(readyToUse) 혹은 중단(aborted) 상태가 될 때까지 연기된다.</p>
<h3 id=삭제>삭제</h3>
<p>삭제는 <code>VolumeSnapshot</code> 를 삭제 시 트리거로 <code>DeletionPolicy</code> 가 실행된다. <code>DeletionPolicy</code> 가 <code>Delete</code> 라면, 기본 스토리지 스냅샷이 <code>VolumeSnapshotContent</code> 오브젝트와 함께 삭제될 것이다. <code>DeletionPolicy</code> 이 <code>Retain</code> 이라면, 기본 스트리지 스냅샷과 <code>VolumeSnapshotContent</code> 둘 다 유지된다.</p>
<h2 id=볼륨-스냅샷>볼륨 스냅샷</h2>
<p>각각의 볼륨 스냅샷은 스펙과 상태를 포함한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>snapshot.storage.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>VolumeSnapshot<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>new-snapshot-test<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumeSnapshotClassName</span>:<span style=color:#bbb> </span>csi-hostpath-snapclass<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>source</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>persistentVolumeClaimName</span>:<span style=color:#bbb> </span>pvc-test<span style=color:#bbb>
</span></code></pre></div><p><code>persistentVolumeClaimName</code> 은 스냅샷을 위한 퍼시스턴트볼륨클레임 데이터 소스의 이름이다. 이 필드는 동적 프로비저닝 스냅샷이 필요하다.</p>
<p>볼륨 스냅샷은 <code>volumeSnapshotClassName</code> 속성을 사용하여
<a href=/ko/docs/concepts/storage/volume-snapshot-classes/>볼륨스냅샷클래스</a>의 이름을 지정하여
특정 클래스를 요청할 수 있다. 아무것도 설정하지 않으면, 사용 가능한 경우 기본 클래스가 사용될 것이다.</p>
<p>사전 프로비저닝된 스냅샷의 경우, 다음 예와 같이 <code>volumeSnapshotContentName</code>을 스냅샷 소스로 지정해야 한다. 사전 프로비저닝된 스냅샷에는 <code>volumeSnapshotContentName</code> 소스 필드가 필요하다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>snapshot.storage.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>VolumeSnapshot<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-snapshot<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>source</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeSnapshotContentName</span>:<span style=color:#bbb> </span>test-content<span style=color:#bbb>
</span></code></pre></div><h2 id=볼륨-스냅샷-컨텐츠>볼륨 스냅샷 컨텐츠</h2>
<p>각각의 볼륨스냅샷컨텐츠는 스펙과 상태를 포함한다. 동적 프로비저닝에서는, 스냅샷 공통 컨트롤러는 <code>VolumeSnapshotContent</code> 오브젝트를 생성한다. 예시는 다음과 같다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>snapshot.storage.k8s.io/v1beta1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>VolumeSnapshotContent<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>snapcontent-72d9a349-aacd-42d2-a240-d775650d2455<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>deletionPolicy</span>:<span style=color:#bbb> </span>Delete<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>driver</span>:<span style=color:#bbb> </span>hostpath.csi.k8s.io<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>source</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeHandle</span>:<span style=color:#bbb> </span>ee0cfb94-f8d4-11e9-b2d8-0242ac110002<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumeSnapshotClassName</span>:<span style=color:#bbb> </span>csi-hostpath-snapclass<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumeSnapshotRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>new-snapshot-test<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>uid</span>:<span style=color:#bbb> </span>72d9a349-aacd-42d2-a240-d775650d2455<span style=color:#bbb>
</span></code></pre></div><p><code>volumeHandle</code> 은 스토리지 백엔드에서 생성되고 볼륨 생성 중에 CSI 드라이버가 반환하는 볼륨의 고유 식별자이다. 이 필드는 스냅샷을 동적 프로비저닝하는 데 필요하다. 이것은 스냅샷의 볼륨 소스를 지정한다.</p>
<p>사전 프로비저닝된 스냅샷의 경우, (클러스터 관리자로서) 다음과 같이 <code>VolumeSnapshotContent</code> 오브젝트를 작성해야 한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>snapshot.storage.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>VolumeSnapshotContent<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>new-snapshot-content-test<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>deletionPolicy</span>:<span style=color:#bbb> </span>Delete<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>driver</span>:<span style=color:#bbb> </span>hostpath.csi.k8s.io<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>source</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>snapshotHandle</span>:<span style=color:#bbb> </span>7bdd0de3-aaeb-11e8-9aae-0242ac110002<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumeSnapshotRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>new-snapshot-test<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span></code></pre></div><p><code>snapshotHandle</code> 은 스토리지 백엔드에서 생성된 볼륨 스냅샷의 고유 식별자이다. 이 필드는 사전 프로비저닝된 스냅샷에 필요하다. <code>VolumeSnapshotContent</code> 가 나타내는 스토리지 시스템의 CSI 스냅샷 id를 지정한다.</p>
<h2 id=스냅샷을-위한-프로비저닝-볼륨>스냅샷을 위한 프로비저닝 볼륨</h2>
<p><code>PersistentVolumeClaim</code> 오브젝트의 <em>dataSource</em> 필드를 사용하여
스냅샷 데이터로 미리 채워진 새 볼륨을 프로비저닝할 수 있다.</p>
<p>보다 자세한 사항은
<a href=/ko/docs/concepts/storage/persistent-volumes/#%EB%B3%BC%EB%A5%A8-%EC%8A%A4%EB%83%85%EC%83%B7-%EB%B0%8F-%EC%8A%A4%EB%83%85%EC%83%B7-%EC%A7%80%EC%9B%90%EC%97%90%EC%84%9C-%EB%B3%BC%EB%A5%A8-%EB%B3%B5%EC%9B%90>볼륨 스냅샷 및 스냅샷에서 볼륨 복원</a>에서 확인할 수 있다.</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-4d00116c86dade62bdd5be7dc2afa1ca>6.7 - 볼륨 스냅샷 클래스</h1>
<p>이 문서는 쿠버네티스의 볼륨스냅샷클래스(VolumeSnapshotClass) 개요를 설명한다.
<a href=/ko/docs/concepts/storage/volume-snapshots/>볼륨 스냅샷</a>과
<a href=/ko/docs/concepts/storage/storage-classes>스토리지 클래스</a>의 숙지를 추천한다.</p>
<h2 id=소개>소개</h2>
<p>스토리지클래스(StorageClass)는 관리자가 볼륨을 프로비저닝할 때 제공하는 스토리지의 "클래스"를
설명하는 방법을 제공하는 것처럼, 볼륨스냅샷클래스는 볼륨 스냅샷을
프로비저닝할 때 스토리지의 "클래스"를 설명하는 방법을 제공한다.</p>
<h2 id=volumesnapshotclass-리소스>VolumeSnapshotClass 리소스</h2>
<p>각 볼륨스냅샷클래스에는 클래스에 속하는 볼륨스냅샷을
동적으로 프로비전 할 때 사용되는 <code>driver</code>, <code>deletionPolicy</code> 그리고 <code>parameters</code>
필드를 포함한다.</p>
<p>볼륨스냅샷클래스 오브젝트의 이름은 중요하며, 사용자가 특정
클래스를 요청할 수 있는 방법이다. 관리자는 볼륨스냅샷클래스 오브젝트를
처음 생성할 때 클래스의 이름과 기타 파라미터를 설정하고, 오브젝트가
생성된 이후에는 업데이트할 수 없다.</p>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> CRD의 설치는 쿠버네티스 배포판의 책임이다. 필요한 CRD가 존재하지 않는다면, 볼륨스냅샷클래스 생성이 실패할 것이다.
</div>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>snapshot.storage.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>VolumeSnapshotClass<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>csi-hostpath-snapclass<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>driver</span>:<span style=color:#bbb> </span>hostpath.csi.k8s.io<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>deletionPolicy</span>:<span style=color:#bbb> </span>Delete<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>parameters</span>:<span style=color:#bbb>
</span></code></pre></div><p>관리자는<code>snapshot.storage.kubernetes.io/is-default-class: "true"</code> 어노테이션을 추가하여
바인딩할 특정 클래스를 요청하지 않는 볼륨스냅샷에 대한
기본 볼륨스냅샷클래스를 지정할 수 있다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>snapshot.storage.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>VolumeSnapshotClass<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>csi-hostpath-snapclass<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>snapshot.storage.kubernetes.io/is-default-class</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>driver</span>:<span style=color:#bbb> </span>hostpath.csi.k8s.io<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>deletionPolicy</span>:<span style=color:#bbb> </span>Delete<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>parameters</span>:<span style=color:#bbb>
</span></code></pre></div><h3 id=드라이버>드라이버</h3>
<p>볼륨 스냅샷 클래스에는 볼륨스냅샷의 프로비저닝에 사용되는 CSI 볼륨 플러그인을
결정하는 드라이버를 가지고 있다. 이 필드는 반드시 지정해야 한다.</p>
<h3 id=삭제정책-deletionpolicy>삭제정책(DeletionPolicy)</h3>
<p>볼륨 스냅샷 클래스는 삭제정책을 가지고 있다. 바인딩된 볼륨스냅샷 오브젝트를 삭제할 때 VolumeSnapshotContent의 상황을 구성할 수 있다. 볼륨 스냅샷 클래스의 삭제정책은 <code>Retain</code> 또는 <code>Delete</code> 일 수 있다. 이 필드는 반드시 지정해야 한다.</p>
<p>삭제정책이 <code>Delete</code> 인 경우 기본 스토리지 스냅샷이 VolumeSnapshotContent 오브젝트와 함께 삭제된다. 삭제정책이 <code>Retain</code> 인 경우 기본 스냅샷과 VolumeSnapshotContent 모두 유지된다.</p>
<h2 id=파라미터>파라미터</h2>
<p>볼륨 스냅샷 클래스에는 볼륨 스냅샷 클래스에 속하는 볼륨 스냅샷을
설명하는 파라미터를 가지고 있다. <code>driver</code> 에 따라 다른 파라미터를 사용할
수 있다.</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-707ca81a34eb1ca202f34692e9917d1e>6.8 - CSI 볼륨 복제하기</h1>
<p>이 문서에서는 쿠버네티스의 기존 CSI 볼륨 복제의 개념을 설명한다. <a href=/ko/docs/concepts/storage/volumes>볼륨</a>을 숙지하는 것을 추천한다.</p>
<h2 id=소개>소개</h2>
<p><a class=glossary-tooltip title="컨테이너 스토리지 인터페이스(CSI)는 컨테이너에 스토리지 시스템을 노출하는 표준 인터페이스를 정의한다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/storage/volumes/#csi target=_blank aria-label=CSI>CSI</a> 볼륨 복제 기능은 <code>dataSource</code> 필드에 기존 <a class=glossary-tooltip title="컨테이너의 볼륨으로 마운트될 수 있도록 퍼시스턴트볼륨(PersistentVolume)에 정의된 스토리지 리소스를 요청한다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/storage/persistent-volumes/ target=_blank aria-label=PVC>PVC</a>를 지정하는 지원을 추가해서 사용자가 <a class=glossary-tooltip title="데이터를 포함하고 있는 디렉터리이며, 파드의 컨테이너에서 접근 가능하다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/storage/volumes/ target=_blank aria-label=볼륨(Volume)>볼륨(Volume)</a>을 복제하려는 것을 나타낸다.</p>
<p>복제는 표준 볼륨처럼 소비할 수 있는 쿠버네티스 볼륨의 복제본으로 정의된다. 유일한 차이점은 프로비저닝할 때 "새" 빈 볼륨을 생성하는 대신에 백엔드 장치가 지정된 볼륨의 정확한 복제본을 생성한다는 것이다.</p>
<p>쿠버네티스 API의 관점에서 복제를 구현하면 새로운 PVC 생성 중에 기존 PVC를 데이터 소스로 지정할 수 있는 기능이 추가된다. 소스 PVC는 바인딩되어 있고, 사용 가능해야 한다(사용 중이 아니어야 함).</p>
<p>사용자는 이 기능을 사용할 때 다음 사항을 알고 있어야 한다.</p>
<ul>
<li>복제 지원(<code>VolumePVCDataSource</code>)은 CSI 드라이버에서만 사용할 수 있다.</li>
<li>복제 지원은 동적 프로비저너만 사용할 수 있다.</li>
<li>CSI 드라이버는 볼륨 복제 기능을 구현했거나 구현하지 않았을 수 있다.</li>
<li>PVC는 대상 PVC와 동일한 네임스페이스에 있는 경우에만 복제할 수 있다(소스와 대상은 동일한 네임스페이스에 있어야 함).</li>
<li>복제는 동일한 스토리지 클래스 내에서만 지원된다.
<ul>
<li>대상 볼륨은 소스와 동일한 스토리지 클래스여야 한다.</li>
<li>기본 스토리지 클래스를 사용할 수 있으며, 사양에 storageClassName을 생략할 수 있다.</li>
</ul>
</li>
<li>동일한 VolumeMode 설정을 사용하는 두 볼륨에만 복제를 수행할 수 있다(블록 모드 볼륨을 요청하는 경우에는 반드시 소스도 블록 모드여야 한다).</li>
</ul>
<h2 id=프로비저닝>프로비저닝</h2>
<p>동일한 네임스페이스에서 기존 PVC를 참조하는 dataSource를 추가하는 것을 제외하고는 다른 PVC와 마찬가지로 복제가 프로비전된다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolumeClaim<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>clone-of-pvc-1<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>myns<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- ReadWriteOnce<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>storageClassName</span>:<span style=color:#bbb> </span>cloning<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>5Gi<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>dataSource</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolumeClaim<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pvc-1<span style=color:#bbb>
</span></code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> <code>spec.resources.requests.storage</code> 에 용량 값을 지정해야 하며, 지정한 값은 소스 볼륨의 용량과 같거나 또는 더 커야 한다.
</div>
<p>그 결과로 지정된 소스 <code>pvc-1</code> 과 동일한 내용을 가진 <code>clone-of-pvc-1</code> 이라는 이름을 가지는 새로운 PVC가 생겨난다.</p>
<h2 id=사용>사용</h2>
<p>새 PVC를 사용할 수 있게 되면, 복제된 PVC는 다른 PVC와 동일하게 소비된다. 또한, 이 시점에서 새롭게 생성된 PVC는 독립된 오브젝트이다. 원본 dataSource PVC와는 무관하게 독립적으로 소비하고, 복제하고, 스냅샷의 생성 또는 삭제를 할 수 있다. 이는 소스가 새롭게 생성된 복제본에 어떤 방식으로든 연결되어 있지 않으며, 새롭게 생성된 복제본에 영향 없이 수정하거나, 삭제할 수도 있는 것을 의미한다.</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-00cd24f4570b7acaac75c2551c948bc7>6.9 - 스토리지 용량</h1>
<p>스토리지 용량은 제한이 있으며, 파드가 실행되는 노드의 상황에 따라 달라질 수 있다.
예를 들어, 일부 노드에서 NAS(Network Attached Storage)에 접근할 수 없는 경우가 있을 수 있으며,
또는 각 노드에 종속적인 로컬 스토리지를 사용하는 경우일 수도 있다.</p>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.21 [beta]</code>
</div>
<p>이 페이지에서는 쿠버네티스가 어떻게 스토리지 용량을 추적하고
스케줄러가 남아 있는 볼륨을 제공하기 위해 스토리지 용량이 충분한 노드에
파드를 스케줄링하기 위해 이 정보를 어떻게 사용하는지 설명한다.
스토리지 용량을 추적하지 않으면, 스케줄러는
볼륨을 제공할 충분한 용량이 없는 노드를 선정할 수 있으며,
스케줄링을 여러 번 다시 시도해야 한다.</p>
<p>스토리지 용량 추적은 <a class=glossary-tooltip title="컨테이너 스토리지 인터페이스(CSI)는 컨테이너에 스토리지 시스템을 노출하는 표준 인터페이스를 정의한다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/storage/volumes/#csi target=_blank aria-label="컨테이너 스토리지 인터페이스(CSI)">컨테이너 스토리지 인터페이스(CSI)</a> 드라이버에서 지원하며,
CSI 드라이버를 설치할 때 <a href=#%EC%8A%A4%ED%86%A0%EB%A6%AC%EC%A7%80-%EC%9A%A9%EB%9F%89-%EC%B6%94%EC%A0%81-%ED%99%9C%EC%84%B1%ED%99%94>사용하도록 설정</a>해야 한다.</p>
<h2 id=api>API</h2>
<p>이 기능에는 다음 두 가지 API 확장이 있다.</p>
<ul>
<li>CSIStorageCapacity 오브젝트:
CSI 드라이버가 설치된 네임스페이스에
CSI 드라이버가 이 오브젝트를 생성한다. 각 오브젝트는
하나의 스토리지 클래스에 대한 용량 정보를 담고 있으며,
어떤 노드가 해당 스토리지에 접근할 수 있는지를 정의한다.</li>
<li><a href=/docs/reference/generated/kubernetes-api/v1.23/#csidriverspec-v1-storage-k8s-io> <code>CSIDriverSpec.StorageCapacity</code> 필드</a>:
<code>true</code>로 설정하면, 쿠버네티스 스케줄러가
CSI 드라이버를 사용하는 볼륨의 스토리지 용량을 고려하게 된다.</li>
</ul>
<h2 id=스케줄링>스케줄링</h2>
<p>다음과 같은 경우 쿠버네티스 스케줄러에서 스토리지 용량 정보를 사용한다.</p>
<ul>
<li><code>CSIStorageCapacity</code> 기능 게이트(feature gate)가 true이고,</li>
<li>파드가 아직 생성되지 않은 볼륨을 사용하고,</li>
<li>해당 볼륨은 CSI 드라이버를 참조하고
<code>WaitForFirstConsumer</code>
<a href=/ko/docs/concepts/storage/storage-classes/#%EB%B3%BC%EB%A5%A8-%EB%B0%94%EC%9D%B8%EB%94%A9-%EB%AA%A8%EB%93%9C>볼륨 바인딩 모드</a>를 사용하는
<a class=glossary-tooltip title="스토리지클래스는 관리자가 사용 가능한 다양한 스토리지 유형을 설명할 수 있는 방법을 제공한다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/storage/storage-classes target=_blank aria-label=스토리지클래스(StorageClass)>스토리지클래스(StorageClass)</a>를 사용하고,</li>
<li>드라이버의 <code>CSIDriver</code> 오브젝트에 <code>StorageCapacity</code> 속성이
true로 설정되어 있다.</li>
</ul>
<p>이 경우 스케줄러는 파드에 제공할
충분한 스토리지가 있는 노드만 고려한다.
이 검사는 아주 간단한데,
볼륨의 크기를 노드를 포함하는 토폴로지를 가진 <code>CSIStorageCapacity</code> 오브젝트에
나열된 용량과 비교한다.</p>
<p>볼륨 바인딩 모드가 <code>Immediate</code> 인 볼륨의 경우에는 스토리지 드라이버는
볼륨을 사용하는 파드와 관계없이 볼륨을 생성할 위치를 정한다.
볼륨을 생성한 후에, 스케줄러는
볼륨을 사용할 수 있는 노드에 파드를 스케줄링한다.</p>
<p><a href=/ko/docs/concepts/storage/volumes/#csi>CSI 임시 볼륨</a>의 경우에는
볼륨 유형이 로컬 볼륨이고
큰 자원이 필요하지 않은 특정 CSI 드라이버에서만 사용된다는 가정하에,
항상 스토리지 용량을 고려하지 않고
스케줄링한다.</p>
<h2 id=리스케줄링>리스케줄링</h2>
<p><code>WaitForFirstConsumer</code> 볼륨을 가진 파드에 대해
노드가 선정되었더라도 아직은 잠정적인 결정이다. 다음 단계에서
선정한 노드에서 볼륨을 사용할 수 있어야 한다는 힌트를 주고
CSI 스토리지 드라이버에 볼륨 생성을 요청한다</p>
<p>쿠버네티스는 시간이 지난 스토리지 용량 정보를 기반으로
노드를 선정할 수도 있으므로, 볼륨을 실제로 생성하지 않을 수도 있다.
그런 다음 노드 선정이 재설정되고 쿠버네티스 스케줄러가
파드를 위한 노드를 찾는 것을 재시도한다.</p>
<h2 id=제한사항>제한사항</h2>
<p>스토리지 용량 추적은 첫 시도에 스케줄링이 성공할 가능성을 높이지만,
스케줄러가 시간이 지난 정보를 기반으로
결정해야 할 수도 있기 때문에 이를 보장하지는 않는다.
일반적으로 스토리지 용량 정보가 없는 스케줄링과
동일한 재시도 메커니즘으로 스케줄링 실패를 처리한다.</p>
<p>스케줄링이 영구적으로 실패할 수 있는 한 가지 상황은
파드가 여러 볼륨을 사용하는 경우이다.
토폴로지 세그먼트에 하나의 볼륨이 이미 생성되어
다른 볼륨에 충분한 용량이 남아 있지 않을 수 있다.
이러한 상황을 복구하려면
용량을 늘리거나 이미 생성된 볼륨을 삭제하는 등의 수작업이 필요하며,
자동으로 처리하려면
<a href=https://github.com/kubernetes/enhancements/pull/1703>추가 작업</a>이 필요하다.</p>
<h2 id=스토리지-용량-추적-활성화>스토리지 용량 추적 활성화</h2>
<p>스토리지 용량 추적은 베타 기능이며,
쿠버네티스 1.21 이후 버전부터 쿠버네티스 클러스터에 기본적으로 활성화되어 있다.
클러스터에서 스토리지 용량 추적 기능을 활성화하는 것뿐만 아니라, CSI 드라이버에서도 이 기능을 지원해야 한다.
자세한 내용은 드라이버 문서를 참조한다.</p>
<h2 id=다음-내용>다음 내용</h2>
<ul>
<li>설계에 대한 자세한 내용은
<a href=https://github.com/kubernetes/enhancements/blob/master/keps/sig-storage/1472-storage-capacity-tracking/README.md>파드 스케줄링 스토리지 용량 제약 조건</a>을 참조한다.</li>
<li>이 기능의 추가 개발에 대한 자세한 내용은 <a href=https://github.com/kubernetes/enhancements/issues/1472>개선 추적 이슈 #1472</a>를 참조한다.</li>
<li><a href=/ko/docs/concepts/scheduling-eviction/kube-scheduler/>쿠버네티스 스케줄러</a>에 대해 살펴본다.</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-b2e4b16ac37988c678a3312a4a6639f8>6.10 - 노드 별 볼륨 한도</h1>
<p>이 페이지는 다양한 클라우드 공급자들이 제공하는 노드에 연결할 수 있는
최대 볼륨 수를 설명한다.</p>
<p>Google, Amazon 그리고 Microsoft와 같은 클라우드 공급자는 일반적으로 노드에
연결할 수 있는 볼륨 수에 제한이 있다. 쿠버네티스가 이러한 제한을
준수하는 것은 중요하다. 그렇지 않으면, 노드에서 예약된 파드가 볼륨이
연결될 때까지 멈추고 기다릴 수 있다.</p>
<h2 id=쿠버네티스-기본-한도>쿠버네티스 기본 한도</h2>
<p>쿠버네티스 스케줄러에는 노드에 연결될 수 있는 볼륨 수에 대한
기본 한도가 있다.</p>
<table>
<tr><th>클라우드 서비스</th><th>노드 당 최대 볼륨</th></tr>
<tr><td><a href=https://aws.amazon.com/ebs/>Amazon Elastic Block Store (EBS)</a></td><td>39</td></tr>
<tr><td><a href=https://cloud.google.com/persistent-disk/>Google Persistent Disk</a></td><td>16</td></tr>
<tr><td><a href=https://azure.microsoft.com/ko-kr/services/storage/main-disks/>Microsoft Azure Disk Storage</a></td><td>16</td></tr>
</table>
<h2 id=사용자-정의-한도>사용자 정의 한도</h2>
<p><code>KUBE_MAX_PD_VOLS</code> 환경 변수의 값을 설정한 후,
스케줄러를 시작하여 이러한 한도를 변경할 수 있다.
CSI 드라이버는 절차가 다를 수 있으므로, 한도를 사용자 정의하는
방법에 대한 문서를 참고한다.</p>
<p>기본 한도보다 높은 한도를 설정한 경우 주의한다. 클라우드
공급자의 문서를 참조하여 노드가 실제로 사용자가 설정한 한도를
지원할 수 있는지 확인한다.</p>
<p>한도는 전체 클러스터에 적용되므로, 모든 노드에 영향을 준다.</p>
<h2 id=동적-볼륨-한도>동적 볼륨 한도</h2>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.17 [stable]</code>
</div>
<p>다음 볼륨 유형에 대해 동적 볼륨 한도가 지원된다.</p>
<ul>
<li>Amazon EBS</li>
<li>Google Persistent Disk</li>
<li>Azure Disk</li>
<li>CSI</li>
</ul>
<p>인-트리(in-tree) 볼륨 플러그인으로 관리되는 볼륨의 경우, 쿠버네티스는 자동으로 노드 유형을
결정하고 노드에 적절한 최대 볼륨 수를 적용한다. 예를 들면, 다음과 같다.</p>
<ul>
<li>
<p><a href=https://cloud.google.com/compute/>Google Compute Engine</a>에서는,
<a href=https://cloud.google.com/compute/docs/disks/#pdnumberlimits>노드 유형에 따라</a>
최대 127개의 볼륨까지
노드에 연결할 수 있다.</p>
</li>
<li>
<p>M5, C5, R5, T3와 Z1D 인스턴스 유형의 Amazon EBS 디스크의 경우, 쿠버네티스는 25개의 볼륨만 노드에
연결할 수 있도록 허용한다.
<a href=https://aws.amazon.com/ec2/>Amazon Elastic Compute Cloud (EC2)</a>의
다른 인스턴스 유형의 경우, 쿠버네티스는 노드에 39개의 볼륨을 연결할 수 있도록 허용한다.</p>
</li>
<li>
<p>Azure에서는, 노드 유형에 따라 최대 64개의 디스크를 노드에 연결할 수 있다. 더 자세한 내용은 <a href=https://docs.microsoft.com/ko-kr/azure/virtual-machines/windows/sizes>Azure의 가상 머신 크기</a>를 참고한다.</p>
</li>
<li>
<p>CSI 스토리지 드라이버가 <code>NodeGetInfo</code> 를 사용해서 노드에 대한 최대 볼륨 수를 알린다면, <a class=glossary-tooltip title="노드가 배정되지 않은 새로 생성된 파드를 감지하고, 실행할 노드를 선택하는 컨트롤 플레인 컴포넌트." data-toggle=tooltip data-placement=top href=/docs/reference/command-line-tools-reference/kube-scheduler/ target=_blank aria-label=kube-scheduler>kube-scheduler</a>는 그 한도를 따른다.</p>
</li>
</ul>
<p>자세한 내용은 <a href=https://github.com/container-storage-interface/spec/blob/master/spec.md#nodegetinfo>CSI 명세</a>를 참고한다.</p>
<ul>
<li>CSI 드라이버로 마이그레이션된 인-트리 플러그인으로 관리되는 볼륨의 경우, 최대 볼륨 수는 CSI 드라이버가 보고한 개수이다.</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-4f40cb95a671e51b4f0156a409d95c6d>6.11 - 볼륨 헬스 모니터링</h1>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.21 [alpha]</code>
</div>
<p><a class=glossary-tooltip title="컨테이너 스토리지 인터페이스(CSI)는 컨테이너에 스토리지 시스템을 노출하는 표준 인터페이스를 정의한다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/storage/volumes/#csi target=_blank aria-label=CSI>CSI</a> 볼륨 헬스 모니터링을 통해 CSI 드라이버는 기본 스토리지 시스템에서 비정상적인 볼륨 상태를 감지하고 이를 <a class=glossary-tooltip title="컨테이너의 볼륨으로 마운트될 수 있도록 퍼시스턴트볼륨(PersistentVolume)에 정의된 스토리지 리소스를 요청한다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/storage/persistent-volumes/ target=_blank aria-label=PVC>PVC</a> 또는 <a class=glossary-tooltip title="파드는 클러스터에서 실행 중인 컨테이너의 집합을 나타낸다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/pods/ target=_blank aria-label=파드>파드</a>의 이벤트로 보고한다.</p>
<h2 id=볼륨-헬스-모니터링>볼륨 헬스 모니터링</h2>
<p>쿠버네티스 <em>볼륨 헬스 모니터링</em> 은 쿠버네티스가 CSI(Container Storage Interface)를 구현하는 방법의 일부다. 볼륨 헬스 모니터링 기능은 외부 헬스 모니터 컨트롤러와 <a class=glossary-tooltip title="클러스터의 각 노드에서 실행되는 에이전트. Kubelet은 파드에서 컨테이너가 확실하게 동작하도록 관리한다." data-toggle=tooltip data-placement=top href=/docs/reference/generated/kubelet target=_blank aria-label=kubelet>kubelet</a>, 2가지 컴포넌트로 구현된다.</p>
<p>CSI 드라이버가 컨트롤러 측의 볼륨 헬스 모니터링 기능을 지원하는 경우, CSI 볼륨에서 비정상적인 볼륨 상태가 감지될 때 관련 <a class=glossary-tooltip title="컨테이너의 볼륨으로 마운트될 수 있도록 퍼시스턴트볼륨(PersistentVolume)에 정의된 스토리지 리소스를 요청한다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/storage/persistent-volumes/ target=_blank aria-label=퍼시스턴트볼륨클레임>퍼시스턴트볼륨클레임</a>(PersistentVolumeClaim, PVC) 이벤트가 보고된다.</p>
<p>외부 헬스 모니터 <a class=glossary-tooltip title="API 서버를 통해 클러스터의 공유된 상태를 감시하고, 현재 상태를 원하는 상태로 이행시키는 컨트롤 루프." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/architecture/controller/ target=_blank aria-label=컨트롤러>컨트롤러</a>는 노드 장애 이벤트도 감시한다. <code>enable-node-watcher</code> 플래그를 true로 설정하여 노드 장애 모니터링을 활성화할 수 있다. 외부 헬스 모니터가 노드 장애 이벤트를 감지하면, 컨트롤러는 이 PVC를 사용하는 파드가 장애 상태인 노드에 있음을 나타내는 이벤트가 PVC에 보고된다고 알린다.</p>
<p>CSI 드라이버가 노드 측에서 볼륨 헬스 모니터링 기능을 지원하는 경우, CSI 볼륨에서 비정상적인 볼륨 상태가 감지되면 PVC를 사용하는 모든 파드에서 이벤트가 보고된다.</p>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> 노드 측에서 이 기능을 사용하려면 <code>CSIVolumeHealth</code> <a href=/ko/docs/reference/command-line-tools-reference/feature-gates/>기능 게이트</a>를 활성화해야 한다.
</div>
<h2 id=다음-내용>다음 내용</h2>
<p>이 기능을 구현한 CSI 드라이버를 확인하려면 <a href=https://kubernetes-csi.github.io/docs/drivers.html>CSI 드라이버 문서</a>를 참고한다.</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-275bea454e1cf4c5adeca4058b5af988>7 - 구성</h1>
<div class=lead>쿠버네티스가 파드 구성을 위해 제공하는 리소스</div>
</div>
<div class=td-content>
<h1 id=pg-ddef6fd0e47bb51c6f05e8e7fb11d2dd>7.1 - 구성 모범 사례</h1>
<p>이 문서는 사용자 가이드, 시작하기 문서 및 예제들에 걸쳐 소개된 구성 모범 사례를 강조하고 통합한다.</p>
<p>이 문서는 지속적으로 변경 가능하다. 이 목록에 없지만 다른 사람들에게 유용할 것 같은 무엇인가를 생각하고 있다면, 새로운 이슈를 생성하거나 풀 리퀘스트를 제출하는 것을 망설이지 말기를 바란다.</p>
<h2 id=일반적인-구성-팁>일반적인 구성 팁</h2>
<ul>
<li>
<p>구성을 정의할 때, 안정된 최신 API 버전을 명시한다.</p>
</li>
<li>
<p>구성 파일들은 클러스터에 적용되기 전에 버전 컨트롤에 저장되어 있어야 한다. 이는 만약 필요하다면 구성의 변경 사항을 빠르게 되돌릴 수 있도록 해준다. 이는 또한 클러스터의 재-생성과 복원을 도와준다.</p>
</li>
<li>
<p>JSON보다는 YAML을 사용해 구성 파일을 작성한다. 비록 이러한 포맷들은 대부분의 모든 상황에서 통용되어 사용될 수 있지만, YAML이 좀 더 사용자 친화적인 성향을 가진다.</p>
</li>
<li>
<p>의미상 맞다면 가능한 연관된 오브젝트들을 하나의 파일에 모아 놓는다. 때로는 여러 개의 파일보다 하나의 파일이 더 관리하기 쉽다. 이 문법의 예시로서 <a href=https://github.com/kubernetes/examples/tree/master/guestbook/all-in-one/guestbook-all-in-one.yaml>guestbook-all-in-one.yaml</a> 파일을 참고한다.</p>
</li>
<li>
<p>많은 <code>kubectl</code> 커맨드들은 디렉터리에 대해 호출될 수 있다. 예를 들어, 구성 파일들의 디렉터리에 대해 <code>kubectl apply</code>를 호출할 수 있다.</p>
</li>
<li>
<p>불필요하게 기본 값을 명시하지 않는다. 간단하고 최소한의 설정은 에러를 덜 발생시킨다.</p>
</li>
<li>
<p>더 나은 인트로스펙션(introspection)을 위해서, 어노테이션에 오브젝트의 설명을 넣는다.</p>
</li>
</ul>
<h2 id=naked-pods-vs-replicasets-deployments-and-jobs>"단독(Naked)" 파드 vs 레플리카셋(ReplicaSet), 디플로이먼트(Deployment), 그리고 잡(Job)</h2>
<ul>
<li>
<p>가능하다면 단독 파드(즉, <a href=/ko/docs/concepts/workloads/controllers/replicaset/>레플리카셋</a>이나 <a href=/ko/docs/concepts/workloads/controllers/deployment/>디플로이먼트</a>에 연결되지 않은 파드)를 사용하지 않는다. 단독 파드는 노드 장애 이벤트가 발생해도 다시 스케줄링되지 않는다.</p>
<p>명백하게 <a href=/ko/docs/concepts/workloads/pods/pod-lifecycle/#%EC%9E%AC%EC%8B%9C%EC%9E%91-%EC%A0%95%EC%B1%85><code>restartPolicy: Never</code></a>를 사용하는 상황을 제외한다면, 의도한 파드의 수가 항상 사용 가능한 상태를 유지하는 레플리카셋을 생성하고, 파드를 교체하는 전략(<a href=/ko/docs/concepts/workloads/controllers/deployment/#%EB%94%94%ED%94%8C%EB%A1%9C%EC%9D%B4%EB%A8%BC%ED%8A%B8-%EB%A1%A4%EB%A7%81-%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8>롤링 업데이트</a>와 같은)을 명시하는 디플로이먼트는 파드를 직접 생성하기 위해 항상 선호되는 방법이다. <a href=/ko/docs/concepts/workloads/controllers/job/>잡</a> 또한 적절할 수 있다.</p>
</li>
</ul>
<h2 id=서비스>서비스</h2>
<ul>
<li>
<p>서비스에 대응하는 백엔드 워크로드(디플로이먼트 또는 레플리카셋) 또는 서비스 접근이 필요한 어떠한 워크로드를 생성하기 전에 <a href=/ko/docs/concepts/services-networking/service/>서비스</a>를 미리 생성한다. 쿠버네티스가 컨테이너를 시작할 때, 쿠버네티스는 컨테이너 시작 당시에 생성되어 있는 모든 서비스를 가리키는 환경 변수를 컨테이너에 제공한다. 예를 들어, <code>foo</code> 라는 이름의 서비스가 존재한다면, 모든 컨테이너들은 초기 환경에서 다음의 변수들을 얻을 것이다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#b8860b>FOO_SERVICE_HOST</span><span style=color:#666>=</span>&lt;서비스가 동작 중인 호스트&gt;
<span style=color:#b8860b>FOO_SERVICE_PORT</span><span style=color:#666>=</span>&lt;서비스가 동작 중인 포트&gt;
</code></pre></div><p><em>이는 순서를 정하는 일이 요구됨을 암시한다</em> - <code>파드</code>가 접근하기를 원하는 어떠한 <code>서비스</code>는 <code>파드</code> 스스로가 생성되기 전에 미리 생성되어 있어야 하며, 그렇지 않으면 환경 변수가 설정되지 않을 것이다. DNS는 이러한 제한을 가지고 있지 않다.</p>
</li>
<li>
<p>선택적인(그렇지만 매우 권장되는) <a href=/ko/docs/concepts/cluster-administration/addons/>클러스터 애드온</a>은 DNS 서버이다.
DNS 서버는 새로운 <code>서비스</code>를 위한 쿠버네티스 API를 Watch하며, 각 서비스를 위한 DNS 레코드 셋을 생성한다. 만약 DNS가 클러스터에 걸쳐 활성화되어 있다면, 모든 <code>파드</code>는 <code>서비스</code>의 이름을 자동으로 해석할 수 있어야 한다.</p>
</li>
<li>
<p>반드시 필요한 것이 아니라면 파드에 <code>hostPort</code> 를 명시하지 않는다. &lt;<code>hostIP</code>, <code>hostPort</code>, <code>protocol</code>> 조합은 유일해야 하기 때문에, <code>hostPort</code>로 바인드하는 것은 파드가 스케줄링될 수 있는 위치의 개수를 제한한다. 만약 <code>hostIP</code>와 <code>protocol</code>을 뚜렷히 명시하지 않으면, 쿠버네티스는 <code>hostIP</code>의 기본 값으로 <code>0.0.0.0</code>를, <code>protocol</code>의 기본 값으로 <code>TCP</code>를 사용한다.</p>
<p>만약 오직 디버깅의 목적으로 포트에 접근해야 한다면, <a href=/ko/docs/tasks/access-application-cluster/access-cluster/#%EC%88%98%EC%9E%91%EC%97%85%EC%9C%BC%EB%A1%9C-apiserver-proxy-url%EC%9D%84-%EA%B5%AC%EC%B6%95>apiserver proxy</a> 또는 <a href=/ko/docs/tasks/access-application-cluster/port-forward-access-application-cluster/><code>kubectl port-forward</code></a>를 사용할 수 있다.</p>
<p>만약 파드의 포트를 노드에서 명시적으로 노출해야 한다면, <code>hostPort</code>에 의존하기 전에 <a href=/ko/docs/concepts/services-networking/service/#type-nodeport>NodePort</a> 서비스를 사용하는 것을 고려할 수 있다.</p>
</li>
<li>
<p><code>hostPort</code>와 같은 이유로, <code>hostNetwork</code>를 사용하는 것을 피한다.</p>
</li>
<li>
<p><code>kube-proxy</code> 로드 밸런싱이 필요하지 않을 때, 서비스 발견을 위해 <a href=/ko/docs/concepts/services-networking/service/#%ED%97%A4%EB%93%9C%EB%A6%AC%EC%8A%A4-headless-%EC%84%9C%EB%B9%84%EC%8A%A4>헤드리스 서비스</a>(<code>ClusterIP</code>의 값을 <code>None</code>으로 가지는)를 사용한다.</p>
</li>
</ul>
<h2 id=레이블-사용하기>레이블 사용하기</h2>
<ul>
<li><code>{ app: myapp, tier: frontend, phase: test, deployment: v3 }</code>처럼 애플리케이션이나 디플로이먼트의 <strong>속성에 대한 의미</strong> 를 식별하는 <a href=/ko/docs/concepts/overview/working-with-objects/labels/>레이블</a>을 정의해 사용한다. 다른 리소스를 위해 적절한 파드를 선택하는 용도로 이러한 레이블을 이용할 수 있다. 예를 들어, 모든 <code>tier: frontend</code> 파드를 선택하거나, <code>app: myapp</code>의 모든 <code>phase: test</code> 컴포넌트를 선택하는 서비스를 생각해 볼 수 있다. 이 접근 방법의 예시는 <a href=https://github.com/kubernetes/examples/tree/master/guestbook/>방명록</a> 앱을 참고한다.</li>
</ul>
<p>릴리스에 특정되는 레이블을 서비스의 셀렉터에서 생략함으로써 여러 개의 디플로이먼트에 걸치는 서비스를 생성할 수 있다. 동작 중인 서비스를 다운타임 없이 갱신하려면, <a href=/ko/docs/concepts/workloads/controllers/deployment/>디플로이먼트</a>를 사용한다.</p>
<p>오브젝트의 의도한 상태는 디플로이먼트에 의해 기술되며, 만약 그 스펙에 대한 변화가 <em>적용될</em> 경우, 디플로이먼트 컨트롤러는 일정한 비율로 실제 상태를 의도한 상태로 변화시킨다.</p>
<ul>
<li>
<p>일반적인 활용 사례인 경우 <a href=/ko/docs/concepts/overview/working-with-objects/common-labels/>쿠버네티스 공통 레이블</a>을 사용한다. 이 표준화된 레이블은 <code>kubectl</code> 및 <a href=/ko/docs/tasks/access-application-cluster/web-ui-dashboard>대시보드</a>와 같은 도구들이 상호 운용이 가능한 방식으로 동작할 수 있도록 메타데이터를 향상시킨다.</p>
</li>
<li>
<p>디버깅을 위해 레이블을 조작할 수 있다. (레플리카셋과 같은) 쿠버네티스 컨트롤러와 서비스는 셀렉터 레이블을 사용해 파드를 선택하기 때문에, 관련된 레이블을 파드에서 삭제하는 것은 컨트롤러로부터 관리되거나 서비스로부터 트래픽을 전달받는 것을 중단시킨다. 만약 이미 존재하는 파드의 레이블을 삭제한다면, 파드의 컨트롤러는 그 자리를 대신할 새로운 파드를 생성한다. 이것은 이전에 "살아 있는" 파드를 "격리된" 환경에서 디버그할 수 있는 유용한 방법이다. 레이블을 상호적으로 추가하고 삭제하기 위해서, <a href=/docs/reference/generated/kubectl/kubectl-commands#label><code>kubectl label</code></a>를 사용할 수 있다.</p>
</li>
</ul>
<h2 id=kubectl-사용하기>kubectl 사용하기</h2>
<ul>
<li>
<p><code>kubectl apply -f &lt;디렉터리></code>를 사용한다. 이 명령어는 <code>&lt;디렉터리></code> 내부의 모든 <code>.yaml</code>, <code>.yml</code>, 그리고 <code>.json</code> 쿠버네티스 구성 파일을 찾아 <code>apply</code>에 전달한다.</p>
</li>
<li>
<p><code>get</code>과 <code>delete</code> 동작을 위해 특정 오브젝트의 이름 대신 레이블 셀렉터를 사용한다. <a href=/ko/docs/concepts/overview/working-with-objects/labels/#%EB%A0%88%EC%9D%B4%EB%B8%94-%EC%85%80%EB%A0%89%ED%84%B0>레이블 셀렉터</a>와 <a href=/ko/docs/concepts/cluster-administration/manage-deployment/#%ED%9A%A8%EA%B3%BC%EC%A0%81%EC%9D%B8-%EB%A0%88%EC%9D%B4%EB%B8%94-%EC%82%AC%EC%9A%A9>효율적으로 레이블 사용하기</a>를 참고할 수 있다.</p>
</li>
<li>
<p>단일 컨테이너로 구성된 디플로이먼트와 서비스를 빠르게 생성하기 위해 <code>kubectl create deployment</code> 와 <code>kubectl expose</code> 를 사용한다. <a href=/ko/docs/tasks/access-application-cluster/service-access-application-cluster/>클러스터 내부의 애플리케이션에 접근하기 위한 서비스 사용</a>에서 예시를 확인할 수 있다.</p>
</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-6b5ccadd699df0904e8e9917c5450c4b>7.2 - 컨피그맵(ConfigMap)</h1>
<p><p>컨피그맵은 키-값 쌍으로 기밀이 아닌 데이터를 저장하는 데 사용하는 API 오브젝트이다.
<a class=glossary-tooltip title="파드는 클러스터에서 실행 중인 컨테이너의 집합을 나타낸다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/pods/ target=_blank aria-label=파드>파드</a>는
<a class=glossary-tooltip title="데이터를 포함하고 있는 디렉터리이며, 파드의 컨테이너에서 접근 가능하다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/storage/volumes/ target=_blank aria-label=볼륨>볼륨</a>에서
환경 변수, 커맨드-라인 인수 또는 구성 파일로 컨피그맵을 사용할 수 있다.</p></p>
<p>컨피그맵을 사용하면 <a class=glossary-tooltip title="컨테이너의 저장된 인스턴스이며, 애플리케이션 구동에 필요한 소프트웨어 집합을 가지고 있다." data-toggle=tooltip data-placement=top href="/ko/docs/reference/glossary/?all=true#term-image" target=_blank aria-label="컨테이너 이미지">컨테이너 이미지</a>에서 환경별 구성을 분리하여, 애플리케이션을 쉽게 이식할 수 있다.</p>
<div class="alert alert-warning caution callout" role=alert>
<strong>주의:</strong> 컨피그맵은 보안 또는 암호화를 제공하지 않는다.
저장하려는 데이터가 기밀인 경우, 컨피그맵
대신 <a class=glossary-tooltip title="비밀번호, OAuth 토큰 및 ssh 키와 같은 민감한 정보를 저장한다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/configuration/secret/ target=_blank aria-label=시크릿(Secret)>시크릿(Secret)</a> 또는 추가(써드파티) 도구를
사용하여 데이터를 비공개로 유지하자.
</div>
<h2 id=사용-동기>사용 동기</h2>
<p>애플리케이션 코드와 별도로 구성 데이터를 설정하려면 컨피그맵을 사용하자.</p>
<p>예를 들어, 자신의 컴퓨터(개발용)와 클라우드(실제 트래픽 처리)에서
실행할 수 있는 애플리케이션을 개발한다고 가정해보자.
<code>DATABASE_HOST</code> 라는 환경 변수를 찾기 위해 코드를 작성한다.
로컬에서는 해당 변수를 <code>localhost</code> 로 설정한다. 클라우드에서는, 데이터베이스
컴포넌트를 클러스터에 노출하는 쿠버네티스 <a class=glossary-tooltip title="네트워크 서비스로 파드 집합에서 실행 중인 애플리케이션을 노출하는 방법" data-toggle=tooltip data-placement=top href=/ko/docs/concepts/services-networking/service/ target=_blank aria-label=서비스>서비스</a>를
참조하도록 설정한다.
이를 통해 클라우드에서 실행 중인 컨테이너 이미지를 가져와
필요한 경우 정확히 동일한 코드를 로컬에서 디버깅할 수 있다.</p>
<p>컨피그맵은 많은 양의 데이터를 보유하도록 설계되지 않았다. 컨피그맵에 저장된
데이터는 1MiB를 초과할 수 없다. 이 제한보다 큰 설정을
저장해야 하는 경우, 볼륨을 마운트하는 것을 고려하거나 별도의
데이터베이스 또는 파일 서비스를 사용할 수 있다.</p>
<h2 id=컨피그맵-오브젝트>컨피그맵 오브젝트</h2>
<p>컨피그맵은 다른 오브젝트가 사용할 구성을 저장할 수 있는
API <a href=/ko/docs/concepts/overview/working-with-objects/kubernetes-objects/>오브젝트</a>이다.
<code>spec</code> 이 있는 대부분의 쿠버네티스 오브젝트와 달리, 컨피그맵에는 <code>data</code> 및 <code>binaryData</code>
필드가 있다. 이러한 필드는 키-값 쌍을 값으로 허용한다. <code>data</code> 필드와
<code>binaryData</code> 는 모두 선택 사항이다. <code>data</code> 필드는
UTF-8 바이트 시퀀스를 포함하도록 설계되었으며 <code>binaryData</code> 필드는 바이너리
데이터를 base64로 인코딩된 문자열로 포함하도록 설계되었다.</p>
<p>컨피그맵의 이름은 유효한
<a href=/ko/docs/concepts/overview/working-with-objects/names/#dns-%EC%84%9C%EB%B8%8C%EB%8F%84%EB%A9%94%EC%9D%B8-%EC%9D%B4%EB%A6%84>DNS 서브도메인 이름</a>이어야 한다.</p>
<p><code>data</code> 또는 <code>binaryData</code> 필드 아래의 각 키는
영숫자 문자, <code>-</code>, <code>_</code> 또는 <code>.</code> 으로 구성되어야 한다. <code>data</code> 에 저장된 키는
<code>binaryData</code> 필드의 키와 겹치지 않아야 한다.</p>
<p>v1.19부터 컨피그맵 정의에 <code>immutable</code> 필드를 추가하여
<a href=#configmap-immutable>변경할 수 없는 컨피그맵</a>을 만들 수 있다.</p>
<h2 id=컨피그맵과-파드>컨피그맵과 파드</h2>
<p>컨피그맵을 참조하는 파드 <code>spec</code> 을 작성하고 컨피그맵의 데이터를
기반으로 해당 파드의 컨테이너를 구성할 수 있다. 파드와 컨피그맵은
동일한 <a class=glossary-tooltip title="쿠버네티스에서 동일한 물리 클러스터에서 다중의 가상 클러스터를 지원하기 위해 사용하는 추상화." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/overview/working-with-objects/namespaces target=_blank aria-label=네임스페이스>네임스페이스</a>에 있어야 한다.</p>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> <a class=glossary-tooltip title="특정 노드의 Kubelet 데몬이 직접 관리하는 파드" data-toggle=tooltip data-placement=top href=/ko/docs/tasks/configure-pod-container/static-pod/ target=_blank aria-label="스태틱(static) 파드">스태틱(static) 파드</a>의 <code>spec</code>은 컨피그맵
또는 다른 API 오브젝트를 참조할 수 없다.
</div>
<p>다음은 단일 값을 가진 키와,
값이 구성 형식의 일부처럼 보이는 키를 가진 컨피그맵의
예시이다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>game-demo<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 속성과 비슷한 키; 각 키는 간단한 값으로 매핑됨</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>player_initial_lives</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;3&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ui_properties_file_name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;user-interface.properties&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 파일과 비슷한 키</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>game.properties</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span><span style=color:#b44;font-style:italic>    enemy.types=aliens,monsters
</span><span style=color:#b44;font-style:italic>    player.maximum-lives=5</span><span style=color:#bbb>    
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>user-interface.properties</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span><span style=color:#b44;font-style:italic>    color.good=purple
</span><span style=color:#b44;font-style:italic>    color.bad=yellow
</span><span style=color:#b44;font-style:italic>    allow.textmode=true</span><span style=color:#bbb>    
</span></code></pre></div><p>컨피그맵을 사용하여 파드 내부에 컨테이너를 구성할 수 있는
네 가지 방법이 있다.</p>
<ol>
<li>컨테이너 커맨드와 인수 내에서</li>
<li>컨테이너에 대한 환경 변수</li>
<li>애플리케이션이 읽을 수 있도록 읽기 전용 볼륨에 파일 추가</li>
<li>쿠버네티스 API를 사용하여 컨피그맵을 읽는 파드 내에서 실행할 코드 작성</li>
</ol>
<p>이러한 방법들은 소비되는 데이터를 모델링하는
방식에 따라 다르게 쓰인다.
처음 세 가지 방법의 경우,
<a class=glossary-tooltip title="클러스터의 각 노드에서 실행되는 에이전트. Kubelet은 파드에서 컨테이너가 확실하게 동작하도록 관리한다." data-toggle=tooltip data-placement=top href=/docs/reference/generated/kubelet target=_blank aria-label=kubelet>kubelet</a>은 파드의 컨테이너를 시작할 때
컨피그맵의 데이터를 사용한다.</p>
<p>네 번째 방법은 컨피그맵과 데이터를 읽기 위해 코드를 작성해야 한다는 것을 의미한다.
그러나, 쿠버네티스 API를 직접 사용하기 때문에, 애플리케이션은
컨피그맵이 변경될 때마다 업데이트를 받기 위해 구독할 수 있고, 업데이트가
있으면 반응한다. 쿠버네티스 API에 직접 접근하면, 이
기술을 사용하여 다른 네임스페이스의 컨피그맵에 접근할 수도 있다.</p>
<p>다음은 <code>game-demo</code> 의 값을 사용하여 파드를 구성하는 파드 예시이다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>configmap-demo-pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>demo<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>alpine<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;sleep&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;3600&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># 환경 변수 정의</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>PLAYER_INITIAL_LIVES<span style=color:#bbb> </span><span style=color:#080;font-style:italic># 참고로 여기서는 컨피그맵의 키 이름과</span><span style=color:#bbb>
</span><span style=color:#bbb>                                     </span><span style=color:#080;font-style:italic># 대소문자가 다르다.</span><span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>configMapKeyRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>game-demo          <span style=color:#bbb> </span><span style=color:#080;font-style:italic># 이 값의 컨피그맵.</span><span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>player_initial_lives<span style=color:#bbb> </span><span style=color:#080;font-style:italic># 가져올 키.</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>UI_PROPERTIES_FILE_NAME<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>configMapKeyRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>game-demo<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>ui_properties_file_name<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>config<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/config&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 파드 레벨에서 볼륨을 설정한 다음, 해당 파드 내의 컨테이너에 마운트한다.</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>config<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>configMap</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># 마운트하려는 컨피그맵의 이름을 제공한다.</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>game-demo<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># 컨피그맵에서 파일로 생성할 키 배열</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>items</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;game.properties&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;game.properties&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;user-interface.properties&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;user-interface.properties&#34;</span><span style=color:#bbb>
</span></code></pre></div><p>컨피그맵은 단일 라인 속성(single line property) 값과 멀티 라인의 파일과 비슷한(multi-line file-like) 값을
구분하지 않는다.
더 중요한 것은 파드와 다른 오브젝트가 이러한 값을 소비하는 방식이다.</p>
<p>이 예제에서, 볼륨을 정의하고 <code>demo</code> 컨테이너에
<code>/config</code> 로 마운트하면 컨피그맵에 4개의 키가 있더라도
<code>/config/game.properties</code> 와 <code>/config/user-interface.properties</code>
2개의 파일이 생성된다. 이것은 파드 정의가
<code>volume</code> 섹션에서 <code>items</code> 배열을 지정하기 때문이다.
<code>items</code> 배열을 완전히 생략하면, 컨피그맵의 모든 키가
키와 이름이 같은 파일이 되고, 4개의 파일을 얻게 된다.</p>
<h2 id=컨피그맵-사용하기>컨피그맵 사용하기</h2>
<p>컨피그맵은 데이터 볼륨으로 마운트할 수 있다. 컨피그맵은 파드에 직접적으로
노출되지 않고, 시스템의 다른 부분에서도 사용할 수 있다. 예를 들어,
컨피그맵은 시스템의 다른 부분이 구성을 위해 사용해야 하는 데이터를 보유할 수 있다.</p>
<p>컨피그맵을 사용하는 가장 일반적인 방법은 동일한 네임스페이스의
파드에서 실행되는 컨테이너에 대한 설정을 구성하는 것이다. 컨피그맵을
별도로 사용할 수도 있다.</p>
<p>예를 들어,
컨피그맵에 기반한 동작을 조정하는 <a class=glossary-tooltip title="Resources that extend the functionality of Kubernetes." data-toggle=tooltip data-placement=top href=/docs/concepts/cluster-administration/addons/ target=_blank aria-label=애드온>애드온</a>이나
<a class=glossary-tooltip title="A specialized controller used to manage a custom resource" data-toggle=tooltip data-placement=top href=/docs/concepts/extend-kubernetes/operator/ target=_blank aria-label=오퍼레이터>오퍼레이터</a>를
사용할 수도 있다.</p>
<h3 id=파드에서-컨피그맵을-파일로-사용하기>파드에서 컨피그맵을 파일로 사용하기</h3>
<p>파드의 볼륨에서 컨피그맵을 사용하려면 다음을 수행한다.</p>
<ol>
<li>컨피그맵을 생성하거나 기존 컨피그맵을 사용한다. 여러 파드가 동일한 컨피그맵을
참조할 수 있다.</li>
<li>파드 정의를 수정해서 <code>.spec.volumes[]</code> 아래에 볼륨을 추가한다. 볼륨 이름은
원하는 대로 정하고, 컨피그맵 오브젝트를 참조하도록 <code>.spec.volumes[].configMap.name</code>
필드를 설정한다.</li>
<li>컨피그맵이 필요한 각 컨테이너에 <code>.spec.containers[].volumeMounts[]</code> 를
추가한다. <code>.spec.containers[].volumeMounts[].readOnly = true</code> 를 설정하고
컨피그맵이 연결되기를 원하는 곳에 사용하지 않은 디렉터리 이름으로
<code>.spec.containers[].volumeMounts[].mountPath</code> 를 지정한다.</li>
<li>프로그램이 해당 디렉터리에서 파일을 찾도록 이미지 또는 커맨드 라인을
수정한다. 컨피그맵의 <code>data</code> 맵 각 키는 <code>mountPath</code> 아래의
파일 이름이 된다.</li>
</ol>
<p>다음은 볼륨에 컨피그맵을 마운트하는 파드의 예시이다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/etc/foo&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>configmap</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>myconfigmap<span style=color:#bbb>
</span></code></pre></div><p>사용하려는 각 컨피그맵은 <code>.spec.volumes</code> 에서 참조해야 한다.</p>
<p>파드에 여러 컨테이너가 있는 경우 각 컨테이너에는 자체 <code>volumeMounts</code> 블록이 필요하지만,
컨피그맵은 각 컨피그맵 당 하나의 <code>.spec.volumes</code> 만 필요하다.</p>
<h4 id=마운트된-컨피그맵이-자동으로-업데이트>마운트된 컨피그맵이 자동으로 업데이트</h4>
<p>현재 볼륨에서 사용된 컨피그맵이 업데이트되면, 프로젝션된 키도 마찬가지로 업데이트된다.
kubelet은 모든 주기적인 동기화에서 마운트된 컨피그맵이 최신 상태인지 확인한다.
그러나, kubelet은 로컬 캐시를 사용해서 컨피그맵의 현재 값을 가져온다.
캐시 유형은 <a href=/docs/reference/config-api/kubelet-config.v1beta1/>KubeletConfiguration 구조체</a>의
<code>ConfigMapAndSecretChangeDetectionStrategy</code> 필드를 사용해서 구성할 수 있다.
컨피그맵은 watch(기본값), ttl 기반 또는 API 서버로 직접
모든 요청을 리디렉션할 수 있다.
따라서 컨피그맵이 업데이트되는 순간부터 새 키가 파드에 업데이트되는 순간까지의
총 지연시간은 kubelet 동기화 기간 + 캐시 전파 지연만큼 길 수 있다. 여기서 캐시
전파 지연은 선택한 캐시 유형에 따라 달라질 수 있다(전파
지연을 지켜보거나, 캐시의 ttl 또는 0에 상응함).</p>
<p>환경 변수로 사용되는 컨피그맵은 자동으로 업데이트되지 않으며 파드를 다시 시작해야 한다.</p>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> 컨피그맵을 <a href=/ko/docs/concepts/storage/volumes/#using-subpath>subPath</a> 볼륨 마운트로 사용하는 컨테이너는 컨피그맵 업데이트를 받지 못할 것이다.
</div>
<h2 id=configmap-immutable>변경할 수 없는(immutable) 컨피그맵</h2>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.21 [stable]</code>
</div>
<p>쿠버네티스 기능인 <em>변경할 수 없는 시크릿과 컨피그맵</em> 은 개별 시크릿과
컨피그맵을 변경할 수 없는 것으로 설정하는 옵션을 제공한다. 컨피그맵을 광범위하게
사용하는 클러스터(최소 수만 개의 고유한 컨피그맵이 파드에 마운트)의 경우
데이터 변경을 방지하면 다음과 같은 이점이 있다.</p>
<ul>
<li>애플리케이션 중단을 일으킬 수 있는 우발적(또는 원하지 않는) 업데이트로부터 보호</li>
<li>immutable로 표시된 컨피그맵에 대한 감시를 중단하여, kube-apiserver의 부하를 크게 줄임으로써
클러스터의 성능을 향상시킴</li>
</ul>
<p>이 기능은 <code>ImmutableEphemeralVolumes</code>
<a href=/ko/docs/reference/command-line-tools-reference/feature-gates/>기능 게이트</a>에 의해 제어된다.
<code>immutable</code> 필드를 <code>true</code> 로 설정하여 변경할 수 없는 컨피그맵을 생성할 수 있다.
다음은 예시이다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>immutable</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></code></pre></div><p>컨피그맵을 immutable로 표시하면, 이 변경 사항을 되돌리거나
<code>data</code> 또는 <code>binaryData</code> 필드 내용을 변경할 수 <em>없다</em>. 컨피그맵만
삭제하고 다시 작성할 수 있다. 기존 파드는 삭제된 컨피그맵에 대한 마운트 지점을
유지하므로, 이러한 파드를 다시 작성하는 것을 권장한다.</p>
<h2 id=다음-내용>다음 내용</h2>
<ul>
<li><a href=/ko/docs/concepts/configuration/secret/>시크릿</a>에 대해 읽어본다.</li>
<li><a href=/docs/tasks/configure-pod-container/configure-pod-configmap/>컨피그맵을 사용하도록 파드 구성하기</a>를 읽어본다.</li>
<li>코드를 구성에서 분리하려는 동기를 이해하려면
<a href=https://12factor.net/ko/>Twelve-Factor 앱</a>을 읽어본다.</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-e511ed821ada65d0053341dbd8ad2bb5>7.3 - 시크릿(Secret)</h1>
<p>시크릿은 암호, 토큰 또는 키와 같은 소량의 중요한 데이터를
포함하는 오브젝트이다. 이를 사용하지 않으면 중요한 정보가 <a class=glossary-tooltip title="파드는 클러스터에서 실행 중인 컨테이너의 집합을 나타낸다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/pods/ target=_blank aria-label=파드>파드</a>
명세나 <a class=glossary-tooltip title="컨테이너의 저장된 인스턴스이며, 애플리케이션 구동에 필요한 소프트웨어 집합을 가지고 있다." data-toggle=tooltip data-placement=top href="/ko/docs/reference/glossary/?all=true#term-image" target=_blank aria-label="컨테이너 이미지">컨테이너 이미지</a>에
포함될 수 있다. 시크릿을 사용한다는 것은 사용자의 기밀 데이터를
애플리케이션 코드에 넣을 필요가
없음을 뜻한다.</p>
<p>시크릿은 시크릿을 사용하는 파드와 독립적으로 생성될 수 있기 때문에,
파드를 생성하고, 확인하고, 수정하는 워크플로우 동안 시크릿(그리고 데이터)이
노출되는 것에 대한 위험을 경감시킬 수 있다. 쿠버네티스
및 클러스터에서 실행되는 애플리케이션은 기밀 데이터를 비휘발성
저장소에 쓰는 것을 피하는 것과 같이, 시크릿에 대해 추가 예방 조치를 취할 수도 있다.</p>
<p>시크릿은 <a class=glossary-tooltip title="키-값 쌍으로 기밀이 아닌 데이터를 저장하는 데 사용하는 API 오브젝트이다. 볼륨에서 환경 변수, 커맨드-라인 인수 또는 구성 파일로 사용될 수 있다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/configuration/configmap/ target=_blank aria-label=컨피그맵>컨피그맵</a>과 유사하지만
특별히 기밀 데이터를 보관하기 위한 것이다.</p>
<div class="alert alert-warning caution callout" role=alert>
<strong>주의:</strong> <p>쿠버네티스 시크릿은 기본적으로 API 서버의 기본 데이터 저장소(etcd)에 암호화되지 않은 상태로 저장된다. API 접근(access) 권한이 있는 모든 사용자 또는 etcd에 접근할 수 있는 모든 사용자는 시크릿을 조회하거나 수정할 수 있다.
또한 네임스페이스에서 파드를 생성할 권한이 있는 사람은 누구나 해당 접근을 사용하여 해당 네임스페이스의 모든 시크릿을 읽을 수 있다. 여기에는 디플로이먼트 생성 기능과 같은 간접 접근이 포함된다.</p>
<p>시크릿을 안전하게 사용하려면 최소한 다음의 단계를 따르는 것이 좋다.</p>
<ol>
<li>시크릿에 대한 <a href=/docs/tasks/administer-cluster/encrypt-data/>암호화 활성화</a>.</li>
<li>시크릿의 데이터 읽기 및 쓰기(간접적인 방식 포함)를 제한하는 <a href=/ko/docs/reference/access-authn-authz/authorization/>RBAC 규칙</a>
활성화 또는 구성.</li>
<li>적절한 경우, RBAC과 같은 메커니즘을 사용하여 새로운 시크릿을 생성하거나 기존 시크릿을 대체할 수 있는 주체(principal)들을 제한한다.</li>
</ol>
</div>
<h2 id=시크릿-개요>시크릿 개요</h2>
<p>시크릿을 사용하려면, 파드가 시크릿을 참조해야 한다.
시크릿은 세 가지 방법으로 파드와 함께 사용할 수 있다.</p>
<ul>
<li>하나 이상의 컨테이너에 마운트된
<a class=glossary-tooltip title="데이터를 포함하고 있는 디렉터리이며, 파드의 컨테이너에서 접근 가능하다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/storage/volumes/ target=_blank aria-label=볼륨>볼륨</a> 내의
<a href=#%EC%8B%9C%ED%81%AC%EB%A6%BF%EC%9D%84-%ED%8C%8C%EB%93%9C%EC%9D%98-%ED%8C%8C%EC%9D%BC%EB%A1%9C-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0>파일</a>로써 사용.</li>
<li><a href=#%EC%8B%9C%ED%81%AC%EB%A6%BF%EC%9D%84-%ED%99%98%EA%B2%BD-%EB%B3%80%EC%88%98%EB%A1%9C-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0>컨테이너 환경 변수</a>로써 사용.</li>
<li>파드의 <a href=#imagepullsecrets-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0>이미지를 가져올 때 kubelet</a>에 의해 사용.</li>
</ul>
<p>쿠버네티스 컨트롤 플레인 또한 시크릿을 사용한다. 예를 들어,
<a href=#%EB%B6%80%ED%8A%B8%EC%8A%A4%ED%8A%B8%EB%9E%A9-%ED%86%A0%ED%81%B0-%EC%8B%9C%ED%81%AC%EB%A6%BF>부트스트랩 토큰 시크릿</a>은
노드 등록을 자동화하는 데 도움을 주는 메커니즘이다.</p>
<p>시크릿 오브젝트의 이름은 유효한
<a href=/ko/docs/concepts/overview/working-with-objects/names/#dns-%EC%84%9C%EB%B8%8C%EB%8F%84%EB%A9%94%EC%9D%B8-%EC%9D%B4%EB%A6%84>DNS 서브도메인 이름</a>이어야 한다.
사용자는 시크릿을 위한 파일을 구성할 때 <code>data</code> 및 (또는) <code>stringData</code> 필드를
명시할 수 있다. 해당 <code>data</code> 와 <code>stringData</code> 필드는 선택적으로 명시할 수 있다.
<code>data</code> 필드의 모든 키(key)에 해당하는 값(value)은 base64로 인코딩된 문자열이어야 한다.
만약 사용자에게 base64로의 문자열 변환이 적합하지 않다면,
임의의 문자열을 값으로 받는 <code>stringData</code> 필드를 대신 사용할 수 있다.</p>
<p><code>data</code> 및 <code>stringData</code>의 키는 영숫자 문자,
<code>-</code>, <code>_</code>, 또는 <code>.</code> 으로 구성되어야 한다. <code>stringData</code> 필드의 모든 키-값 쌍은 의도적으로
<code>data</code> 필드로 합쳐진다. 만약 키가 <code>data</code> 와 <code>stringData</code> 필드 모두에 정의되어
있으면, <code>stringData</code> 필드에 지정된 값이
우선적으로 사용된다.</p>
<h2 id=secret-types>시크릿 타입</h2>
<p>시크릿을 생성할 때, <a href=/docs/reference/generated/kubernetes-api/v1.23/#secret-v1-core><code>Secret</code></a>
리소스의 <code>type</code> 필드를 사용하거나, (활용 가능하다면) <code>kubectl</code> 의
유사한 특정 커맨드라인 플래그를 사용하여 시크릿의 타입을 명시할 수 있다.
시크릿 타입은 여러 종류의 기밀 데이터를 프로그래밍 방식으로 용이하게 처리하기 위해 사용된다.</p>
<p>쿠버네티스는 일반적인 사용 시나리오를 위해 몇 가지 빌트인 타입을 제공한다.
이 타입은 쿠버네티스가 부과하여 수행되는 검증 및 제약에
따라 달라진다.</p>
<table>
<thead>
<tr>
<th>빌트인 타입</th>
<th>사용처</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Opaque</code></td>
<td>임의의 사용자 정의 데이터</td>
</tr>
<tr>
<td><code>kubernetes.io/service-account-token</code></td>
<td>서비스 어카운트 토큰</td>
</tr>
<tr>
<td><code>kubernetes.io/dockercfg</code></td>
<td>직렬화 된(serialized) <code>~/.dockercfg</code> 파일</td>
</tr>
<tr>
<td><code>kubernetes.io/dockerconfigjson</code></td>
<td>직렬화 된 <code>~/.docker/config.json</code> 파일</td>
</tr>
<tr>
<td><code>kubernetes.io/basic-auth</code></td>
<td>기본 인증을 위한 자격 증명(credential)</td>
</tr>
<tr>
<td><code>kubernetes.io/ssh-auth</code></td>
<td>SSH를 위한 자격 증명</td>
</tr>
<tr>
<td><code>kubernetes.io/tls</code></td>
<td>TLS 클라이언트나 서버를 위한 데이터</td>
</tr>
<tr>
<td><code>bootstrap.kubernetes.io/token</code></td>
<td>부트스트랩 토큰 데이터</td>
</tr>
</tbody>
</table>
<p>사용자는 시크릿 오브젝트의 <code>type</code> 값에 비어 있지 않은 문자열을 할당하여 자신만의 시크릿
타입을 정의하고 사용할 수 있다. 비어 있는 문자열은 <code>Opaque</code> 타입으로 인식된다.
쿠버네티스는 타입 명칭에 제약을 부과하지는 않는다. 그러나 만약
빌트인 타입 중 하나를 사용한다면, 해당 타입에 정의된 모든 요구 사항을
만족시켜야 한다.</p>
<h3 id=불투명-opaque-시크릿>불투명(Opaque) 시크릿</h3>
<p><code>Opaque</code> 은 시크릿 구성 파일에서 누락된 경우의 기본 시크릿 타입이다.
<code>kubectl</code> 을 사용하여 시크릿을 생성할 때 <code>Opaque</code> 시크릿 타입을 나타내기
위해서는 <code>generic</code> 하위 커맨드를 사용할 것이다. 예를 들어, 다음 커맨드는
타입 <code>Opaque</code> 의 비어 있는 시크릿을 생성한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create secret generic empty-secret
kubectl get secret empty-secret
</code></pre></div><p>출력은 다음과 같다.</p>
<pre><code>NAME           TYPE     DATA   AGE
empty-secret   Opaque   0      2m6s
</code></pre><p>해당 <code>DATA</code> 열은 시크릿에 저장된 데이터 아이템의 수를 보여준다.
이 경우, <code>0</code> 은 비어 있는 시크릿을 하나 생성하였다는 것을 의미한다.</p>
<h3 id=서비스-어카운트-토큰-시크릿>서비스 어카운트 토큰 시크릿</h3>
<p><code>kubernetes.io/service-account-token</code> 시크릿 타입은 서비스 어카운트를 확인하는 토큰을 저장하기 위해서 사용한다. 이 시크릿 타입을 사용할 때는,
<code>kubernetes.io/service-account.name</code> 어노테이션이 존재하는 서비스
어카운트 이름으로 설정되도록 해야 한다. 쿠버네티스 컨트롤러는
<code>kubernetes.io/service-account.uid</code> 및 실제 토큰
콘텐츠로 설정된 <code>data</code> 필드의 <code>token</code> 키와 같은,
몇 가지 다른 필드들을 채운다.</p>
<p>다음은 서비스 어카운트 토큰 시크릿의 구성 예시이다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-sa-sample<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubernetes.io/service-account.name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;sa-name&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>kubernetes.io/service-account-token<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 사용자는 불투명 시크릿을 사용하므로 추가적인 키 값 쌍을 포함할 수 있다.</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>extra</span>:<span style=color:#bbb> </span>YmFyCg==<span style=color:#bbb>
</span></code></pre></div><p><code>Pod</code> 를 생성할 때, 쿠버네티스는 자동으로 서비스 어카운트 시크릿을
생성하고 자동으로 파드가 해당 시크릿을 사용하도록 수정한다. 해당 서비스
어카운트 토큰 시크릿은 API 접속을 위한 자격 증명을 포함한다.</p>
<p>이러한 API 자격 증명의 자동 생성과 사용은 원하는 경우 해제하거나
기각할 수 있다. 그러나 만약 사용자가 API 서버에 안전하게 접근하는 것만
필요하다면, 이것이 권장되는 워크플로우이다.</p>
<p><a href=/docs/tasks/configure-pod-container/configure-service-account/>서비스 어카운트</a> 문서를 보면
서비스 어카운트가 동작하는 방법에 대한 더 자세한 정보를 얻을 수 있다.
또한 파드에서 서비스 어카운트를 참조하는 방법을
<a href=/docs/reference/generated/kubernetes-api/v1.23/#pod-v1-core><code>Pod</code></a>의
<code>automountServiceAccountToken</code> 필드와 <code>serviceAccountName</code>
필드를 통해 확인할 수 있다.</p>
<h3 id=도커-컨피그-시크릿>도커 컨피그 시크릿</h3>
<p>이미지에 대한 도커 레지스트리 접속 자격 증명을 저장하기 위한
시크릿을 생성하기 위해서 다음의 <code>type</code> 값 중 하나를 사용할 수 있다.</p>
<ul>
<li><code>kubernetes.io/dockercfg</code></li>
<li><code>kubernetes.io/dockerconfigjson</code></li>
</ul>
<p><code>kubernetes.io/dockercfg</code> 는 직렬화 된 도커 커맨드라인 구성을
위한 기존(legacy) 포맷 <code>~/.dockercfg</code> 를 저장하기 위해 할당된 타입이다.
시크릿 타입을 사용할 때는, <code>data</code> 필드가 base64 포맷으로
인코딩된 <code>~/.dockercfg</code> 파일의 콘텐츠를 값으로 가지는 <code>.dockercfg</code> 키를 포함하고 있는지
확실히 확인해야 한다.</p>
<p><code>kubernetes.io/dockerconfigjson</code> 타입은 <code>~/.dockercfg</code> 의
새로운 포맷인 <code>~/.docker/config.json</code> 파일과 동일한 포맷 법칙을
따르는 직렬화 된 JSON의 저장을 위해 디자인되었다.
이 시크릿 타입을 사용할 때는, 시크릿 오브젝트의 <code>data</code> 필드가 <code>.dockerconfigjson</code> 키를
꼭 포함해야 한다. <code>~/.docker/config.json</code> 파일을 위한 콘텐츠는
base64로 인코딩된 문자열으로 제공되어야 한다.</p>
<p>아래는 시크릿의 <code>kubernetes.io/dockercfg</code> 타입 예시이다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-dockercfg<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>kubernetes.io/dockercfg<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>.dockercfg</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span><span style=color:#b44;font-style:italic>    </span><span style=color:#bbb>    </span><span style=color:#b44>&#34;&lt;base64 encoded ~/.dockercfg file&gt;&#34;</span><span style=color:#bbb>
</span></code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> 만약 base64 인코딩 수행을 원하지 않는다면, 그 대신 <code>stringData</code> 필드의
사용을 선택할 수 있다.
</div>
<p>이러한 타입들을 매니페스트를 사용하여 생성하는 경우, API
서버는 해당 <code>data</code> 필드에 기대하는 키가 존재하는지 확인하고,
제공된 값이 유효한 JSON으로 파싱될 수 있는지 검증한다. API
서버가 해당 JSON이 실제 도커 컨피그 파일인지를 검증하지는 않는다.</p>
<p>도커 컨피그 파일을 가지고 있지 않거나 도커 레지스트리 시크릿을 생성하기
위해 <code>kubectl</code> 을 사용하고 싶은 경우, 다음과 같이 처리할 수 있다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create secret docker-registry secret-tiger-docker <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --docker-username<span style=color:#666>=</span>tiger <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --docker-password<span style=color:#666>=</span>pass113 <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --docker-email<span style=color:#666>=</span>tiger@acme.com <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --docker-server<span style=color:#666>=</span>my-registry.example:5000
</code></pre></div><p>이 커맨드는 <code>kubernetes.io/dockerconfigjson</code> 타입의 시크릿을 생성한다.
만약 <code>data</code> 필드로부터 <code>.dockerconfigjson</code> 콘텐츠를 복사(dump)해오면,
다음과 같이 유효한 도커 JSON 콘텐츠를
즉석에서 얻게 될 것이다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
    <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;v1&#34;</span>,
    <span style=color:green;font-weight:700>&#34;data&#34;</span>: {
        <span style=color:green;font-weight:700>&#34;.dockerconfigjson&#34;</span>: <span style=color:#b44>&#34;eyJhdXRocyI6eyJteS1yZWdpc3RyeTo1MDAwIjp7InVzZXJuYW1lIjoidGlnZXIiLCJwYXNzd29yZCI6InBhc3MxMTMiLCJlbWFpbCI6InRpZ2VyQGFjbWUuY29tIiwiYXV0aCI6ImRHbG5aWEk2Y0dGemN6RXhNdz09In19fQ==&#34;</span>
    },
    <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;Secret&#34;</span>,
    <span style=color:green;font-weight:700>&#34;metadata&#34;</span>: {
        <span style=color:green;font-weight:700>&#34;creationTimestamp&#34;</span>: <span style=color:#b44>&#34;2021-07-01T07:30:59Z&#34;</span>,
        <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;secret-tiger-docker&#34;</span>,
        <span style=color:green;font-weight:700>&#34;namespace&#34;</span>: <span style=color:#b44>&#34;default&#34;</span>,
        <span style=color:green;font-weight:700>&#34;resourceVersion&#34;</span>: <span style=color:#b44>&#34;566718&#34;</span>,
        <span style=color:green;font-weight:700>&#34;uid&#34;</span>: <span style=color:#b44>&#34;e15c1d7b-9071-4100-8681-f3a7a2ce89ca&#34;</span>
    },
    <span style=color:green;font-weight:700>&#34;type&#34;</span>: <span style=color:#b44>&#34;kubernetes.io/dockerconfigjson&#34;</span>
}

</code></pre></div><h3 id=기본-인증-시크릿>기본 인증 시크릿</h3>
<p><code>kubernetes.io/basic-auth</code> 타입은 기본 인증을 위한 자격 증명을 저장하기
위해 제공된다. 이 시크릿 타입을 사용할 때는 시크릿의 <code>data</code> 필드가
다음의 두 키 중 하나를 포함해야 한다.</p>
<ul>
<li><code>username</code>: 인증을 위한 사용자 이름</li>
<li><code>password</code>: 인증을 위한 암호나 토큰</li>
</ul>
<p>위의 두 키에 대한 두 값은 모두 base64로 인코딩된 문자열이다. 물론,
시크릿 생성 시 <code>stringData</code> 를 사용하여 평문 텍스트 콘텐츠(clear text content)를 제공할
수도 있다.</p>
<p>다음의 YAML은 기본 인증 시크릿을 위한 구성 예시이다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-basic-auth<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>kubernetes.io/basic-auth<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>stringData</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>username</span>:<span style=color:#bbb> </span>admin<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>password</span>:<span style=color:#bbb> </span>t0p-Secret<span style=color:#bbb>
</span></code></pre></div><p>이 기본 인증 시크릿 타입은 사용자 편의만을 위해서 제공된다.
사용자는 기본 인증에서 사용되는 자격 증명을 위한 <code>Opaque</code> 를 생성할 수도 있다.
그러나, 빌트인 시크릿 타입을 사용하는 것은 사용자의 자격 증명들의 포맷을 통합하는 데 도움이 되고,
API 서버는 요구되는 키가 시크릿 구성에서 제공되고 있는지
검증도 한다.</p>
<h3 id=ssh-인증-시크릿>SSH 인증 시크릿</h3>
<p>이 빌트인 타입 <code>kubernetes.io/ssh-auth</code> 는 SSH 인증에 사용되는 데이터를
저장하기 위해서 제공된다. 이 시크릿 타입을 사용할 때는 <code>ssh-privatekey</code>
키-값 쌍을 사용할 SSH 자격 증명으로 <code>data</code> (또는 <code>stringData</code>)
필드에 명시해야 할 것이다.</p>
<p>다음 YAML은 SSH 인증 시크릿의 구성 예시이다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-ssh-auth<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>kubernetes.io/ssh-auth<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 본 예시를 위해 축약된 데이터임</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ssh-privatekey</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span><span style=color:#b44;font-style:italic>     </span><span style=color:#bbb>     </span>MIIEpQIBAAKCAQEAulqb/Y ...<span style=color:#bbb>
</span></code></pre></div><p>SSH 인증 시크릿 타입은 사용자 편의만을 위해서 제공된다.
사용자는 SSH 인증에서 사용되는 자격 증명을 위한 <code>Opaque</code> 를 생성할 수도 있다.
그러나, 빌트인 시크릿 타입을 사용하는 것은 사용자의 자격 증명들의 포맷을 통합하는 데 도움이 되고,
API 서버는 요구되는 키가 시크릿 구성에서 제공되고 있는지
검증도 한다.</p>
<div class="alert alert-warning caution callout" role=alert>
<strong>주의:</strong> SSH 개인 키는 자체적으로 SSH 클라이언트와 호스트 서버 간에 신뢰할 수 있는 통신을
설정하지 않는다. 컨피그맵(ConfigMap)에 추가된 <code>known_hosts</code> 파일과 같은
"중간자(man in the middle)" 공격을 완화하려면 신뢰를 설정하는
2차 수단이 필요하다.
</div>
<h3 id=tls-시크릿>TLS 시크릿</h3>
<p>쿠버네티스는 보통 TLS를 위해 사용되는 인증서와 관련된 키를 저장하기 위해서
빌트인 시크릿 타입 <code>kubernetes.io/tls</code> 를 제공한다.
이 데이터는 인그레스 리소스의 TLS 종료에 주로 사용되지만, 다른
리소스나 워크로드에 의해 직접적으로 사용될 수도 있다.
이 타입의 시크릿을 사용할 때는 <code>tls.key</code> 와 <code>tls.crt</code> 키가 시크릿 구성의
<code>data</code> (또는 <code>stringData</code>) 필드에서 제공되어야 한다. 그러나, API
서버가 각 키에 대한 값이 유효한지 실제로 검증하지는 않는다.</p>
<p>다음 YAML은 TLS 시크릿을 위한 구성 예시를 포함한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-tls<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>kubernetes.io/tls<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 본 예시를 위해 축약된 데이터임</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>tls.crt</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span><span style=color:#b44;font-style:italic>    </span><span style=color:#bbb>    </span>MIIC2DCCAcCgAwIBAgIBATANBgkqh ...<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>tls.key</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span><span style=color:#b44;font-style:italic>    </span><span style=color:#bbb>    </span>MIIEpgIBAAKCAQEA7yn3bRHQ5FHMQ ...<span style=color:#bbb>
</span></code></pre></div><p>TLS 시크릿 타입은 사용자 편의만을 위해서 제공된다. 사용자는 TLS 서버 및/또는
클라이언트를 위해 사용되는 자격 증명을 위한 <code>Opaque</code> 를 생성할 수도 있다. 그러나, 빌트인
시크릿 타입을 사용하는 것은 사용자의 자격 증명들의 포맷을 통합하는 데 도움이 되고,
API 서버는 요구되는 키가 시크릿 구성에서 제공되고 있는지 검증도 한다.</p>
<p><code>kubectl</code> 를 사용하여 TLS 시크릿을 생성할 때, <code>tls</code> 하위 커맨드를
다음 예시와 같이 사용할 수 있다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create secret tls my-tls-secret <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --cert<span style=color:#666>=</span>path/to/cert/file <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --key<span style=color:#666>=</span>path/to/key/file
</code></pre></div><p>공개/개인 키 쌍은 사전에 존재해야 한다. <code>--cert</code> 를 위한 공개 키 인증서는
.PEM 으로 인코딩(Base64로 인코딩된 DER 포맷)되어야 하며, <code>--key</code> 를 위해 주어진
개인 키에 맞아야 한다.
개인 키는 일반적으로 PEM 개인 키 포맷이라고 하는,
암호화되지 않은 형태(unencrypted)이어야 한다. 두 가지 방식 모두에 대해서, PEM의
시작과 끝 라인(예를 들면, 인증서의 <code>--------BEGIN CERTIFICATE-----</code> 및 <code>-------END CERTIFICATE----</code>)
은 포함되면 <em>안</em> 된다.</p>
<h3 id=부트스트랩-토큰-시크릿>부트스트랩 토큰 시크릿</h3>
<p>부트스트랩 토큰 시크릿은 시크릿 <code>type</code> 을 <code>bootstrap.kubernetes.io/token</code> 으로
명확하게 지정하면 생성할 수 있다. 이 타입의 시크릿은 노드 부트스트랩 과정 중에 사용되는
토큰을 위해 디자인되었다. 이것은 잘 알려진 컨피그맵에 서명하는 데 사용되는
토큰을 저장한다.</p>
<p>부트스트랩 토큰 시크릿은 보통 <code>kube-system</code> 네임스페이스에 생성되며
<code>&lt;token-id></code> 가 해당 토큰 ID의 6개 문자의 문자열으로 구성된 <code>bootstrap-token-&lt;token-id></code> 형태로
이름이 지정된다.</p>
<p>쿠버네티스 매니페스트로서, 부트스트렙 토큰 시크릿은 다음과 유사할
것이다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>bootstrap-token-5emitj<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>kube-system<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>bootstrap.kubernetes.io/token<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>auth-extra-groups</span>:<span style=color:#bbb> </span>c3lzdGVtOmJvb3RzdHJhcHBlcnM6a3ViZWFkbTpkZWZhdWx0LW5vZGUtdG9rZW4=<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>expiration</span>:<span style=color:#bbb> </span>MjAyMC0wOS0xM1QwNDozOToxMFo=<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>token-id</span>:<span style=color:#bbb> </span>NWVtaXRq<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>token-secret</span>:<span style=color:#bbb> </span>a3E0Z2lodnN6emduMXAwcg==<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>usage-bootstrap-authentication</span>:<span style=color:#bbb> </span>dHJ1ZQ==<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>usage-bootstrap-signing</span>:<span style=color:#bbb> </span>dHJ1ZQ==<span style=color:#bbb>
</span></code></pre></div><p>부트스트랩 타입 시크릿은 <code>data</code> 아래 명시된 다음의 키들을 가진다.</p>
<ul>
<li><code>token-id</code>: 토큰 식별자로 임의의 6개 문자의 문자열. 필수 사항.</li>
<li><code>token-secret</code>: 실제 토큰 시크릿으로 임의의 16개 문자의 문자열. 필수 사항.</li>
<li><code>description</code>: 토큰의 사용처를 설명하는 사람이 읽을 수 있는
문자열. 선택 사항.</li>
<li><code>expiration</code>: 토큰이 만료되어야 하는 시기를 명시한 RFC3339를
사용하는 절대 UTC 시간. 선택 사항.</li>
<li><code>usage-bootstrap-&lt;usage></code>: 부트스트랩 토큰의 추가적인 사용처를 나타내는
불리언(boolean) 플래그.</li>
<li><code>auth-extra-groups</code>: <code>system:bootstrappers</code> 그룹에 추가로 인증될
쉼표로 구분된 그룹 이름 목록.</li>
</ul>
<p>위의 YAML은 모두 base64로 인코딩된 문자열 값이므로 혼란스러워 보일
수 있다. 사실은 다음 YAML을 사용하여 동일한 시크릿을 생성할 수 있다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 시크릿 이름이 어떻게 지정되었는지 확인</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>bootstrap-token-5emitj<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 부트스트랩 토큰 시크릿은 일반적으로 kube-system 네임스페이스에 포함</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>kube-system<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>bootstrap.kubernetes.io/token<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>stringData</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>auth-extra-groups</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;system:bootstrappers:kubeadm:default-node-token&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>expiration</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2020-09-13T04:39:10Z&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 이 토큰 ID는 이름에 사용됨</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>token-id</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;5emitj&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>token-secret</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;kq4gihvszzgn1p0r&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 이 토큰은 인증을 위해서 사용될 수 있음</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>usage-bootstrap-authentication</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 또한 서명(signing)에도 사용될 수 있음</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>usage-bootstrap-signing</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span></code></pre></div><h2 id=시크릿-생성하기>시크릿 생성하기</h2>
<p>시크릿을 생성하기 위한 몇 가지 옵션이 있다.</p>
<ul>
<li><a href=/ko/docs/tasks/configmap-secret/managing-secret-using-kubectl/><code>kubectl</code> 명령을 사용하여 시크릿 생성하기</a></li>
<li><a href=/ko/docs/tasks/configmap-secret/managing-secret-using-config-file/>구성 파일로 시크릿 생성하기</a></li>
<li><a href=/ko/docs/tasks/configmap-secret/managing-secret-using-kustomize/>kustomize를 사용하여 시크릿 생성하기</a></li>
</ul>
<h2 id=시크릿-편집하기>시크릿 편집하기</h2>
<p>기존 시크릿은 다음 명령을 사용하여 편집할 수 있다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl edit secrets mysecret
</code></pre></div><p>이렇게 하면 기본으로 설정된 에디터가 열리고 <code>data</code> 필드에 base64로 인코딩된 시크릿 값을 업데이트할 수 있다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#080;font-style:italic># 아래 오브젝트를 수정한다. &#39;#&#39;로 시작하는 줄은 무시되고,</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># 빈 파일은 편집이 취소될 것이다. 이 파일을 저장하는 도중에 오류가 발생하면</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># 관련 오류와 함께 다시 열린다.</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic>#</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>username</span>:<span style=color:#bbb> </span>YWRtaW4=<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>password</span>:<span style=color:#bbb> </span>MWYyZDFlMmU2N2Rm<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubectl.kubernetes.io/last-applied-configuration</span>:<span style=color:#bbb> </span>{<span style=color:#bbb> </span>... }<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>creationTimestamp</span>:<span style=color:#bbb> </span>2016-01-22T18:41:56Z<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resourceVersion</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;164619&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>uid</span>:<span style=color:#bbb> </span>cfee02d6-c137-11e5-8d73-42010af00002<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Opaque<span style=color:#bbb>
</span></code></pre></div><h2 id=시크릿-사용하기>시크릿 사용하기</h2>
<p>시크릿은 데이터 볼륨으로 마운트되거나 파드의 컨테이너에서 사용할
<a class=glossary-tooltip title="컨테이너 환경 변수는 파드에서 동작 중인 컨테이너에 유용한 정보를 제공하기 위한 이름=값 쌍이다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/containers/container-environment/ target=_blank aria-label="환경 변수">환경 변수</a>로
노출될 수 있다. 또한, 시크릿은 파드에 직접 노출되지 않고,
시스템의 다른 부분에서도 사용할 수 있다. 예를 들어, 시크릿은
시스템의 다른 부분이 사용자를 대신해서 외부 시스템과 상호 작용하는 데 사용해야 하는
자격 증명을 보유할 수 있다.</p>
<h3 id=시크릿을-파드의-파일로-사용하기>시크릿을 파드의 파일로 사용하기</h3>
<p>파드의 볼륨에서 시크릿을 사용하려면 다음과 같이 한다.</p>
<ol>
<li>시크릿을 생성하거나 기존 시크릿을 사용한다. 여러 파드가 동일한 시크릿을 참조할 수 있다.</li>
<li><code>.spec.volumes[].</code> 아래에 볼륨을 추가하려면 파드 정의를 수정한다. 볼륨의 이름을 뭐든지 지정하고, 시크릿 오브젝트의 이름과 동일한 <code>.spec.volumes[].secret.secretName</code> 필드를 생성한다.</li>
<li>시크릿이 필요한 각 컨테이너에 <code>.spec.containers[].volumeMounts[]</code> 를 추가한다. 시크릿을 표시하려는 사용되지 않은 디렉터리 이름에 <code>.spec.containers[].volumeMounts[].readOnly = true</code> 와 <code>.spec.containers[].volumeMounts[].mountPath</code> 를 지정한다.</li>
<li>프로그램이 해당 디렉터리에서 파일을 찾도록 이미지 또는 커맨드 라인을 수정한다. 시크릿 <code>data</code> 맵의 각 키는 <code>mountPath</code> 아래의 파일명이 된다.</li>
</ol>
<p>다음은 볼륨에 시크릿을 마운트하는 파드의 예시이다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/etc/foo&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>secret</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>secretName</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span></code></pre></div><p>사용하려는 각 시크릿은 <code>.spec.volumes</code> 에서 참조해야 한다.</p>
<p>파드에 여러 컨테이너가 있는 경우, 모든 컨테이너는
자체 <code>volumeMounts</code> 블록이 필요하지만, 시크릿에 대해서는 시크릿당 하나의 <code>.spec.volumes</code> 만 필요하다.</p>
<p>많은 파일을 하나의 시크릿으로 패키징하거나, 여러 시크릿을 사용할 수 있으며, 어느 쪽이든 편리한 방법을 사용하면 된다.</p>
<h4 id=특정-경로에-대한-시크릿-키-투영하기>특정 경로에 대한 시크릿 키 투영하기</h4>
<p>시크릿 키가 투영되는 볼륨 내 경로를 제어할 수도 있다.
<code>.spec.volumes[].secret.items</code> 필드를 사용하여 각 키의 대상 경로를 변경할 수 있다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/etc/foo&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>secret</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>secretName</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>items</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>username<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>my-group/my-username<span style=color:#bbb>
</span></code></pre></div><p>다음과 같은 일들이 일어날 것이다.</p>
<ul>
<li><code>username</code> 시크릿은 <code>/etc/foo/username</code> 대신 <code>/etc/foo/my-group/my-username</code> 아래의 파일에 저장된다.</li>
<li><code>password</code> 시크릿은 투영되지 않는다.</li>
</ul>
<p><code>.spec.volumes[].secret.items</code> 를 사용하면, <code>items</code> 에 지정된 키만 투영된다.
시크릿의 모든 키를 사용하려면, 모든 키가 <code>items</code> 필드에 나열되어야 한다.
나열된 모든 키는 해당 시크릿에 존재해야 한다. 그렇지 않으면, 볼륨이 생성되지 않는다.</p>
<h4 id=시크릿-파일-퍼미션>시크릿 파일 퍼미션</h4>
<p>단일 시크릿 키에 대한 파일 접근 퍼미션 비트를 설정할 수 있다.
만약 사용자가 퍼미션을 지정하지 않는다면, 기본적으로 <code>0644</code> 가 사용된다.
전체 시크릿 볼륨에 대한 기본 모드를 설정하고 필요한 경우 키별로 오버라이드할 수도 있다.</p>
<p>예를 들어, 다음과 같은 기본 모드를 지정할 수 있다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/etc/foo&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>secret</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>secretName</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>defaultMode</span>:<span style=color:#bbb> </span><span style=color:#666>0400</span><span style=color:#bbb>
</span></code></pre></div><p>그러고 나면, 시크릿이 <code>/etc/foo</code> 에 마운트되고 시크릿 볼륨 마운트로 생성된
모든 파일의 퍼미션은 <code>0400</code> 이 될 것이다.</p>
<p>참고로 JSON 스펙은 8진수 표기법을 지원하지 않으므로, 0400 퍼미션에 대해서
값 256을 사용한다. 파드에 대해 JSON 대신 YAML을 사용하는 경우, 8진수 표기법을
사용하여 보다 자연스러운 방식으로 퍼미션을 지정할 수 있다.</p>
<p>참고로 파드에 <code>kubectl exec</code> 을 사용하는 경우, 예상되는 파일 모드를 찾기 위해
심볼릭 링크를 따라가야 한다. 예를 들면, 다음과 같다.</p>
<p>파드에서 시크릿 파일 모드를 확인한다.</p>
<pre><code>kubectl exec mypod -it sh

cd /etc/foo
ls -l
</code></pre><p>출력 결과는 다음과 비슷하다.</p>
<pre><code>total 0
lrwxrwxrwx 1 root root 15 May 18 00:18 password -&gt; ..data/password
lrwxrwxrwx 1 root root 15 May 18 00:18 username -&gt; ..data/username
</code></pre><p>올바른 파일 모드를 찾으려면 심볼릭 링크를 따라간다.</p>
<pre><code>cd /etc/foo/..data
ls -l
</code></pre><p>출력 결과는 다음과 비슷하다.</p>
<pre><code>total 8
-r-------- 1 root root 12 May 18 00:18 password
-r-------- 1 root root  5 May 18 00:18 username
</code></pre><p>이전 예제에서와 같이 매핑을 사용하여, 다음과 같이
다른 파일에 대해 다른 퍼미션을 지정할 수도 있다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/etc/foo&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>secret</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>secretName</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>items</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>username<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>my-group/my-username<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>mode</span>:<span style=color:#bbb> </span><span style=color:#666>0777</span><span style=color:#bbb>
</span></code></pre></div><p>이 경우, <code>/etc/foo/my-group/my-username</code> 에 있는 파일은
결과적으로 <code>0777</code> 퍼미션 값을 갖게 된다. JSON을 사용하는 경우, JSON 제한으로 인해
10진수 표기법(<code>511</code>)으로 모드를 지정해야 한다.</p>
<p>참고로 이 퍼미션 값은 나중에 읽을 때 10진수 표기법으로
표시될 수 있다.</p>
<h4 id=볼륨에서-시크릿-값-사용하기>볼륨에서 시크릿 값 사용하기</h4>
<p>시크릿 볼륨을 마운트하는 컨테이너 내부에서, 시크릿 키는 파일로
나타나고 시크릿 값은 base64로 디코딩되어 이런 파일 내에 저장된다.
다음은 위의 예에서 컨테이너 내부에서 실행된 명령의 결과이다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>ls /etc/foo/
</code></pre></div><p>출력 결과는 다음과 비슷하다.</p>
<pre><code>username
password
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>cat /etc/foo/username
</code></pre></div><p>출력 결과는 다음과 비슷하다.</p>
<pre><code>admin
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>cat /etc/foo/password
</code></pre></div><p>출력 결과는 다음과 비슷하다.</p>
<pre><code>1f2d1e2e67df
</code></pre><p>컨테이너의 프로그램은 파일에서 시크릿을 읽는 역할을
한다.</p>
<h4 id=마운트된-시크릿은-자동으로-업데이트됨>마운트된 시크릿은 자동으로 업데이트됨</h4>
<p>볼륨에서 현재 사용되는 시크릿이 업데이트되면, 투영된 키도 결국 업데이트된다.
kubelet은 마운트된 시크릿이 모든 주기적인 동기화에서 최신 상태인지 여부를 확인한다.
그러나, kubelet은 시크릿의 현재 값을 가져 오기 위해 로컬 캐시를 사용한다.
캐시의 유형은 <a href=/docs/reference/config-api/kubelet-config.v1beta1/>KubeletConfiguration 구조체</a>의
<code>ConfigMapAndSecretChangeDetectionStrategy</code> 필드를 사용하여 구성할 수 있다.
시크릿은 watch(기본값), ttl 기반 또는 API 서버로 모든 요청을 직접
리디렉션하여 전파할 수 있다.
결과적으로, 시크릿이 업데이트된 순간부터 새로운 키가 파드에 투영되는
순간까지의 총 지연 시간은 kubelet 동기화 시간 + 캐시
전파 지연만큼 길 수 있다. 여기서 캐시 전파 지연은 선택한 캐시 유형에 따라
달라질 수 있다(캐시 전파 지연은 각 캐시 유형에 따라 watch 전파 지연, 캐시의 ttl, 또는 0 에 상응함).</p>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> 시크릿을 <a href=/ko/docs/concepts/storage/volumes/#subpath-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0>subPath</a>
볼륨 마운트로 사용하는 컨테이너는 시크릿 업데이트를
받지 않는다.
</div>
<h3 id=시크릿을-환경-변수로-사용하기>시크릿을 환경 변수로 사용하기</h3>
<p>파드에서 <a class=glossary-tooltip title="컨테이너 환경 변수는 파드에서 동작 중인 컨테이너에 유용한 정보를 제공하기 위한 이름=값 쌍이다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/containers/container-environment/ target=_blank aria-label="환경 변수">환경 변수</a>에
시크릿을 사용하려면 다음과 같이 한다.</p>
<ol>
<li>시크릿을 생성하거나 기존 시크릿을 사용한다. 여러 파드가 동일한 시크릿을 참조할 수 있다.</li>
<li>사용하려는 각 시크릿 키에 대한 환경 변수를 추가하려면 시크릿 키 값을 사용하려는 각 컨테이너에서 파드 정의를 수정한다. 시크릿 키를 사용하는 환경 변수는 시크릿의 이름과 키를 <code>env[].valueFrom.secretKeyRef</code> 에 채워야 한다.</li>
<li>프로그램이 지정된 환경 변수에서 값을 찾도록 이미지 및/또는 커맨드 라인을 수정한다.</li>
</ol>
<p>다음은 환경 변수의 시크릿을 사용하는 파드의 예시이다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-env-pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mycontainer<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>SECRET_USERNAME<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>secretKeyRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>username<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>SECRET_PASSWORD<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>secretKeyRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>password<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
</span></code></pre></div><h4 id=환경-변수에서-시크릿-값-사용하기>환경 변수에서 시크릿 값 사용하기</h4>
<p>환경 변수에서 시크릿을 사용하는 컨테이너 내부에서, 시크릿 키는
시크릿 데이터의 base64 디코딩된 값을 포함하는 일반 환경 변수로 나타난다.
다음은 위의 예에서 컨테이너 내부에서 실행된 명령의 결과이다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#a2f>echo</span> <span style=color:#b8860b>$SECRET_USERNAME</span>
</code></pre></div><p>출력 결과는 다음과 비슷하다.</p>
<pre><code>admin
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#a2f>echo</span> <span style=color:#b8860b>$SECRET_PASSWORD</span>
</code></pre></div><p>출력 결과는 다음과 비슷하다.</p>
<pre><code>1f2d1e2e67df
</code></pre><h4 id=시크릿-업데이트-후-환경-변수가-업데이트되지-않음>시크릿 업데이트 후 환경 변수가 업데이트되지 않음</h4>
<p>컨테이너가 환경 변수에서 이미 시크릿을 사용하는 경우, 다시 시작하지 않는 한 컨테이너에서 시크릿 업데이트를 볼 수 없다.
시크릿이 변경될 때 재시작을 트리거하는 써드파티 솔루션이 있다.</p>
<h2 id=secret-immutable>변경할 수 없는(immutable) 시크릿</h2>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.21 [stable]</code>
</div>
<p>쿠버네티스 기능인 <em>변경할 수 없는 시크릿과 컨피그맵</em> 은
개별 시크릿과 컨피그맵을 변경할 수 없는 것으로 설정하는 옵션을 제공한다. 시크릿을 광범위하게 사용하는
클러스터(최소 수만 개의 고유한 시크릿이 파드에 마운트)의 경우, 데이터 변경을 방지하면
다음과 같은 이점이 있다.</p>
<ul>
<li>애플리케이션 중단을 유발할 수 있는 우발적(또는 원하지 않는) 업데이트로부터 보호</li>
<li>immutable로 표시된 시크릿에 대한 감시를 중단하여, kube-apiserver의 부하를
크게 줄임으로써 클러스터의 성능을 향상시킴</li>
</ul>
<p>이 기능은 v1.19부터 기본적으로 활성화된 <code>ImmutableEphemeralVolumes</code>
<a href=/ko/docs/reference/command-line-tools-reference/feature-gates/>기능 게이트</a>에
의해 제어된다. <code>immutable</code> 필드를 <code>true</code> 로 설정하여
변경할 수 없는 시크릿을 생성할 수 있다. 다음은 예시이다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>immutable</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> 시크릿 또는 컨피그맵을 immutable로 표시하면, 이 변경 사항을 되돌리거나
<code>data</code> 필드 내용을 변경할 수 <em>없다</em>. 시크릿을 삭제하고 다시 생성할 수만 있다.
기존 파드는 삭제된 시크릿에 대한 마운트 포인트를 유지하며, 이러한 파드를 다시 생성하는 것을
권장한다.
</div>
<h3 id=imagepullsecrets-사용하기>imagePullSecrets 사용하기</h3>
<p><code>imagePullSecrets</code> 필드는 동일한 네임스페이스의 시크릿에 대한 참조 목록이다.
<code>imagePullSecretsDocker</code> 를 사용하여 도커(또는 다른 컨테이너) 이미지 레지스트리
비밀번호가 포함된 시크릿을 kubelet에 전달할 수 있다. kubelet은 이 정보를 사용해서 파드를 대신하여 프라이빗 이미지를 가져온다.
<code>imagePullSecrets</code> 필드에 대한 자세한 정보는 <a href=/docs/reference/generated/kubernetes-api/v1.23/#podspec-v1-core>PodSpec API</a>를 참고한다.</p>
<h4 id=imagepullsecret-수동으로-지정하기>imagePullSecret 수동으로 지정하기</h4>
<p><a href=/ko/docs/concepts/containers/images/#%ED%8C%8C%EB%93%9C%EC%97%90-imagepullsecrets-%EB%AA%85%EC%8B%9C>컨테이너 이미지 문서</a>에서 <code>ImagePullSecrets</code> 지정하는 방법을 배울 수 있다.</p>
<h3 id=imagepullsecrets가-자동으로-연결되도록-정렬하기>imagePullSecrets가 자동으로 연결되도록 정렬하기</h3>
<p>수동으로 <code>imagePullSecrets</code> 를 생성하고, 서비스어카운트(ServiceAccount)에서
참조할 수 있다. 해당 서비스어카운트로 생성되거나
기본적인 서비스어카운트로 생성된 모든 파드는 파드의 <code>imagePullSecrets</code>
필드를 가져오고 서비스 어카운트의 필드로 설정한다.
해당 프로세스에 대한 자세한 설명은
<a href=/docs/tasks/configure-pod-container/configure-service-account/#add-imagepullsecrets-to-a-service-account>서비스 어카운트에 ImagePullSecrets 추가하기</a>를 참고한다.</p>
<h2 id=상세-내용>상세 내용</h2>
<h3 id=제약-사항>제약 사항</h3>
<p>시크릿 볼륨 소스는 지정된 오브젝트 참조가
실제로 시크릿 유형의 오브젝트를 가리키는지 확인하기 위해 유효성을 검사한다. 따라서, 시크릿에
의존하는 모든 파드보다 먼저 시크릿을 만들어야 한다.</p>
<p>시크릿 리소스는 <a class=glossary-tooltip title="쿠버네티스에서 동일한 물리 클러스터에서 다중의 가상 클러스터를 지원하기 위해 사용하는 추상화." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/overview/working-with-objects/namespaces target=_blank aria-label=네임스페이스>네임스페이스</a>에 존재한다.
시크릿은 동일한 네임스페이스에 있는 파드에서만 참조할 수 있다.</p>
<p>개별 시크릿의 크기는 1MiB로 제한된다. 이는 API 서버와
kubelet 메모리를 소진시키는 매우 큰 시크릿 생성을 막기 위한 것이다.
그러나, 많은 작은 시크릿을 만들어도 메모리가 고갈될 수 있다. 시크릿으로
인한 메모리 사용에 대한 보다 포괄적인 제한은 향후 버전에 계획된 기능이다.</p>
<p>kubelet은 API 서버에서 시크릿을 가져오는 파드에 대한
시크릿 사용만 지원한다.
여기에는 <code>kubectl</code> 을 사용하거나, 레플리케이션 컨트롤러를 통해 간접적으로 생성된 모든
파드가 포함된다. kubelet의 <code>--manifest-url</code> 플래그, <code>--config</code> 플래그 또는
kubectl의 REST API(이 방법들은 파드를 생성하는 일반적인 방법이 아님)로
생성된 파드는 포함하지 않는다.
<a class=glossary-tooltip title="특정 노드의 Kubelet 데몬이 직접 관리하는 파드" data-toggle=tooltip data-placement=top href=/ko/docs/tasks/configure-pod-container/static-pod/ target=_blank aria-label="스태틱(static) 파드">스태틱(static) 파드</a>의 <code>spec</code>은 컨피그맵
또는 다른 API 오브젝트를 참조할 수 없다.</p>
<p>시크릿은 optional(선택 사항)로 표시되지 않는 한 파드에서 환경
변수로 사용되기 전에 생성되어야 한다. 존재하지 않는 시크릿을
참조하면 파드가 시작되지 않는다.</p>
<p>명명된 시크릿에 존재하지 않는 키에 대한 참조(<code>secretKeyRef</code> 필드)는
파드가 시작되지 않도록 한다.</p>
<p>잘못된 환경 변수 이름으로 간주되는 키가 있는 <code>envFrom</code> 필드로
환경 변수를 채우는 데 사용되는 시크릿은 해당 키를
건너뛴다. 이러면 해당 파드가 시작될 수 있다. 원인이 <code>InvalidVariableNames</code> 인
이벤트가 발생하며 건너뛴 유효하지 않은 키 목록이
포함된 메시지가 생성된다. 다음의 예는 2개의 유효하지 않은
키(<code>1badkey</code> 와 <code>2alsobad</code>)가 포함된 default/mysecret을 참조하는 파드를 보여준다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get events
</code></pre></div><p>출력 결과는 다음과 비슷하다.</p>
<pre><code>LASTSEEN   FIRSTSEEN   COUNT     NAME            KIND      SUBOBJECT                         TYPE      REASON
0s         0s          1         dapi-test-pod   Pod                                         Warning   InvalidEnvironmentVariableNames   kubelet, 127.0.0.1      Keys [1badkey, 2alsobad] from the EnvFrom secret default/mysecret were skipped since they are considered invalid environment variable names.
</code></pre><h3 id=시크릿-및-파드-수명-상호-작용>시크릿 및 파드 수명 상호 작용</h3>
<p>쿠버네티스 API를 호출하여 파드가 생성될 때, 참조된 시크릿이 있는지 확인하지
않는다. 일단 파드가 스케줄되면, kubelet은 시크릿 값 가져오기를
시도한다. 시크릿이 존재하지 않거나 API 서버에 대한
일시적인 연결 부족으로 인해 시크릿을 가져올 수 없는 경우, kubelet은
주기적으로 재시도한다. kubelet은 아직 시작되지 않은 이유를 설명하는
파드에 대한 이벤트를 보고한다. 시크릿을 가져오면, kubelet은
이를 포함하는 볼륨을 생성하고 마운트한다. 모든 파드의 볼륨이
마운트될 때까지 파드의 컨테이너는 시작되지 않는다.</p>
<h2 id=사용-사레>사용 사레</h2>
<h3 id=사용-사례-컨테이너-환경-변수로-사용하기>사용 사례: 컨테이너 환경 변수로 사용하기</h3>
<p>시크릿 정의를 작성한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Opaque<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>USER_NAME</span>:<span style=color:#bbb> </span>YWRtaW4=<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>PASSWORD</span>:<span style=color:#bbb> </span>MWYyZDFlMmU2N2Rm<span style=color:#bbb>
</span></code></pre></div><p>시크릿을 생성한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f mysecret.yaml
</code></pre></div><p>모든 시크릿 데이터를 컨테이너 환경 변수로 정의하는 데 <code>envFrom</code> 을 사용한다. 시크릿의 키는 파드의 환경 변수 이름이 된다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-test-pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-container<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/busybox<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#bbb> </span><span style=color:#b44>&#34;/bin/sh&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;-c&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;env&#34;</span><span style=color:#bbb> </span>]<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>envFrom</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>secretRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
</span></code></pre></div><h3 id=사용-사례-ssh-키가-있는-파드>사용 사례: ssh 키가 있는 파드</h3>
<p>몇 가지 ssh 키를 포함하는 시크릿을 생성한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create secret generic ssh-key-secret --from-file<span style=color:#666>=</span>ssh-privatekey<span style=color:#666>=</span>/path/to/.ssh/id_rsa --from-file<span style=color:#666>=</span>ssh-publickey<span style=color:#666>=</span>/path/to/.ssh/id_rsa.pub
</code></pre></div><p>출력 결과는 다음과 비슷하다.</p>
<pre><code>secret &quot;ssh-key-secret&quot; created
</code></pre><p>ssh 키를 포함하는 <code>secretGenerator</code> 필드가 있는 <code>kustomization.yaml</code> 를 만들 수도 있다.</p>
<div class="alert alert-warning caution callout" role=alert>
<strong>주의:</strong> 사용자 자신의 ssh 키를 보내기 전에 신중하게 생각한다. 클러스터의 다른 사용자가 시크릿에 접근할 수 있다. 쿠버네티스 클러스터를 공유하는 모든 사용자가 접근할 수 있도록 하려는 서비스 어카운트를 사용하고, 사용자가 손상된 경우 이 계정을 취소할 수 있다.
</div>
<p>이제 ssh 키를 가진 시크릿을 참조하고
볼륨에서 시크릿을 사용하는 파드를 만들 수 있다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-test-pod<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-test<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-volume<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>secret</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>secretName</span>:<span style=color:#bbb> </span>ssh-key-secret<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>ssh-test-container<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>mySshImage<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-volume<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/etc/secret-volume&#34;</span><span style=color:#bbb>
</span></code></pre></div><p>컨테이너의 명령이 실행될 때, 다음 위치에서 키 부분을 사용할 수 있다.</p>
<pre><code>/etc/secret-volume/ssh-publickey
/etc/secret-volume/ssh-privatekey
</code></pre><p>그러면 컨테이너는 ssh 연결을 맺기 위해 시크릿 데이터를 자유롭게 사용할 수 있다.</p>
<h3 id=사용-사례-운영-테스트-자격-증명이-있는-파드>사용 사례: 운영 / 테스트 자격 증명이 있는 파드</h3>
<p>이 예제에서는 운영 환경의 자격 증명이 포함된 시크릿을
사용하는 파드와 테스트 환경의 자격 증명이 있는 시크릿을 사용하는 다른 파드를
보여준다.</p>
<p>사용자는 <code>secretGenerator</code> 필드가 있는 <code>kustomization.yaml</code> 을 만들거나
<code>kubectl create secret</code> 을 실행할 수 있다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create secret generic prod-db-secret --from-literal<span style=color:#666>=</span><span style=color:#b8860b>username</span><span style=color:#666>=</span>produser --from-literal<span style=color:#666>=</span><span style=color:#b8860b>password</span><span style=color:#666>=</span>Y4nys7f11
</code></pre></div><p>출력 결과는 다음과 비슷하다.</p>
<pre><code>secret &quot;prod-db-secret&quot; created
</code></pre><p>테스트 환경의 자격 증명에 대한 시크릿을 만들 수도 있다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create secret generic test-db-secret --from-literal<span style=color:#666>=</span><span style=color:#b8860b>username</span><span style=color:#666>=</span>testuser --from-literal<span style=color:#666>=</span><span style=color:#b8860b>password</span><span style=color:#666>=</span>iluvtests
</code></pre></div><p>출력 결과는 다음과 비슷하다.</p>
<pre><code>secret &quot;test-db-secret&quot; created
</code></pre><div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> <p><code>$</code>, <code>\</code>, <code>*</code>, <code>=</code> 그리고 <code>!</code> 와 같은 특수 문자는 사용자의 <a href=https://ko.wikipedia.org/wiki/%EC%85%B8>셸</a>에 의해 해석되고 이스케이핑이 필요하다.
대부분의 셸에서 비밀번호를 이스케이프하는 가장 쉬운 방법은 작은 따옴표(<code>'</code>)로 묶는 것이다.
예를 들어, 실제 비밀번호가 <code>S!B\*d$zDsb=</code> 이면, 다음과 같은 명령을 실행해야 한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create secret generic dev-db-secret --from-literal<span style=color:#666>=</span><span style=color:#b8860b>username</span><span style=color:#666>=</span>devuser --from-literal<span style=color:#666>=</span><span style=color:#b8860b>password</span><span style=color:#666>=</span><span style=color:#b44>&#39;S!B\*d$zDsb=&#39;</span>
</code></pre></div><p>파일(<code>--from-file</code>)에서는 비밀번호의 특수 문자를 이스케이프할 필요가 없다.</p>
</div>
<p>이제 파드를 생성한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>cat <span style=color:#b44>&lt;&lt;EOF &gt; pod.yaml
</span><span style=color:#b44>apiVersion: v1
</span><span style=color:#b44>kind: List
</span><span style=color:#b44>items:
</span><span style=color:#b44>- kind: Pod
</span><span style=color:#b44>  apiVersion: v1
</span><span style=color:#b44>  metadata:
</span><span style=color:#b44>    name: prod-db-client-pod
</span><span style=color:#b44>    labels:
</span><span style=color:#b44>      name: prod-db-client
</span><span style=color:#b44>  spec:
</span><span style=color:#b44>    volumes:
</span><span style=color:#b44>    - name: secret-volume
</span><span style=color:#b44>      secret:
</span><span style=color:#b44>        secretName: prod-db-secret
</span><span style=color:#b44>    containers:
</span><span style=color:#b44>    - name: db-client-container
</span><span style=color:#b44>      image: myClientImage
</span><span style=color:#b44>      volumeMounts:
</span><span style=color:#b44>      - name: secret-volume
</span><span style=color:#b44>        readOnly: true
</span><span style=color:#b44>        mountPath: &#34;/etc/secret-volume&#34;
</span><span style=color:#b44>- kind: Pod
</span><span style=color:#b44>  apiVersion: v1
</span><span style=color:#b44>  metadata:
</span><span style=color:#b44>    name: test-db-client-pod
</span><span style=color:#b44>    labels:
</span><span style=color:#b44>      name: test-db-client
</span><span style=color:#b44>  spec:
</span><span style=color:#b44>    volumes:
</span><span style=color:#b44>    - name: secret-volume
</span><span style=color:#b44>      secret:
</span><span style=color:#b44>        secretName: test-db-secret
</span><span style=color:#b44>    containers:
</span><span style=color:#b44>    - name: db-client-container
</span><span style=color:#b44>      image: myClientImage
</span><span style=color:#b44>      volumeMounts:
</span><span style=color:#b44>      - name: secret-volume
</span><span style=color:#b44>        readOnly: true
</span><span style=color:#b44>        mountPath: &#34;/etc/secret-volume&#34;
</span><span style=color:#b44>EOF</span>
</code></pre></div><p>동일한 kustomization.yaml에 파드를 추가한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>cat <span style=color:#b44>&lt;&lt;EOF &gt;&gt; kustomization.yaml
</span><span style=color:#b44>resources:
</span><span style=color:#b44>- pod.yaml
</span><span style=color:#b44>EOF</span>
</code></pre></div><p>다음을 실행하여 API 서버에 이러한 모든 오브젝트를 적용한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -k .
</code></pre></div><p>두 컨테이너 모두 각 컨테이너의 환경에 대한 값을 가진 파일시스템에 다음의 파일이 존재한다.</p>
<pre><code>/etc/secret-volume/username
/etc/secret-volume/password
</code></pre><p>두 파드의 사양이 한 필드에서만 어떻게 다른지 확인한다. 이를 통해
공통 파드 템플릿에서 다양한 기능을 가진 파드를 생성할 수 있다.</p>
<p>두 개의 서비스 어카운트를 사용하여 기본 파드 명세를 더욱 단순화할 수 있다.</p>
<ol>
<li><code>prod-db-secret</code> 을 가진 <code>prod-user</code></li>
<li><code>test-db-secret</code> 을 가진 <code>test-user</code></li>
</ol>
<p>파드 명세는 다음과 같이 단축된다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>prod-db-client-pod<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>prod-db-client<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>serviceAccount</span>:<span style=color:#bbb> </span>prod-db-client<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>db-client-container<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>myClientImage<span style=color:#bbb>
</span></code></pre></div><h3 id=사용-사례-시크릿-볼륨의-도트-파일-dotfile>사용 사례: 시크릿 볼륨의 도트 파일(dotfile)</h3>
<p>점으로 시작하는 키를 정의하여 데이터를 "숨김"으로 만들 수 있다.
이 키는 도트 파일 또는 "숨겨진" 파일을 나타낸다. 예를 들어, 다음 시크릿이 <code>secret-volume</code> 볼륨에
마운트되면 아래와 같다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>dotfile-secret<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>.secret-file</span>:<span style=color:#bbb> </span>dmFsdWUtMg0KDQo=<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-dotfiles-pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-volume<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>secret</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>secretName</span>:<span style=color:#bbb> </span>dotfile-secret<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>dotfile-test-container<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/busybox<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- ls<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;-l&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;/etc/secret-volume&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-volume<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/etc/secret-volume&#34;</span><span style=color:#bbb>
</span></code></pre></div><p>볼륨은 <code>.secret-file</code> 이라는 하나의 파일을 포함하고,
<code>dotfile-test-container</code> 는 <code>/etc/secret-volume/.secret-file</code> 경로에
이 파일을 가지게 된다.</p>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> <code>ls -l</code> 명령의 결과에서 숨겨진 점으로 시작하는 파일들은
디렉터리 내용을 나열할 때 <code>ls -la</code> 를 사용해야 이 파일들을 볼 수 있다.
</div>
<h3 id=사용-사례-파드의-한-컨테이너에-표시되는-시크릿>사용 사례: 파드의 한 컨테이너에 표시되는 시크릿</h3>
<p>HTTP 요청을 처리하고, 복잡한 비즈니스 로직을 수행한 다음, HMAC이 있는 일부 메시지에
서명해야 하는 프로그램을 고려한다. 애플리케이션 로직이
복잡하기 때문에, 서버에서 눈에 띄지 않는 원격 파일 읽기 공격이
있을 수 있으며, 이로 인해 개인 키가 공격자에게 노출될 수 있다.</p>
<p>이는 두 개의 컨테이너의 두 개 프로세스로 나눌 수 있다. 사용자 상호 작용과
비즈니스 로직을 처리하지만, 개인 키를 볼 수 없는 프론트엔드 컨테이너와
개인 키를 볼 수 있고, 프론트엔드의 간단한 서명 요청(예를 들어, localhost 네트워킹을 통해)에
응답하는 서명자 컨테이너로 나눌 수 있다.</p>
<p>이 분할된 접근 방식을 사용하면, 공격자는 이제 애플리케이션 서버를 속여서
파일을 읽는 것보다 다소 어려운 임의적인 어떤 작업을 수행해야
한다.</p>
<h2 id=모범-사례>모범 사례</h2>
<h3 id=시크릿-api를-사용하는-클라이언트>시크릿 API를 사용하는 클라이언트</h3>
<p>시크릿 API와 상호 작용하는 애플리케이션을 배포할 때,
<a href=/docs/reference/access-authn-authz/rbac/>RBAC</a>과 같은
<a href=/ko/docs/reference/access-authn-authz/authorization/>인가 정책</a>을
사용하여 접근을 제한해야 한다.</p>
<p>시크릿은 종종 다양한 중요도에 걸친 값을 보유하며, 이 중 많은 부분이
쿠버네티스(예: 서비스 어카운트 토큰)와 외부 시스템으로 단계적으로
확대될 수 있다. 개별 앱이 상호 작용할 것으로 예상되는 시크릿의 힘에 대해 추론할 수 있더라도
동일한 네임스페이스 내의 다른 앱이 이러한 가정을
무효화할 수 있다.</p>
<p>이러한 이유로 네임스페이스 내 시크릿에 대한 <code>watch</code> 와 <code>list</code> 요청은
매우 강력한 기능이며, 시크릿을 나열하면 클라이언트가 해당 네임스페이스에
있는 모든 시크릿의 값을 검사할 수 있기 때문에 피해야 한다. 클러스터의
모든 시크릿을 감시(<code>watch</code>)하고 나열(<code>list</code>)하는 기능은 가장 특권이 있는 시스템 레벨의
컴포넌트에 대해서만 예약되어야 한다.</p>
<p>시크릿 API에 접근해야 하는 애플리케이션은 필요한 시크릿에 대한 <code>get</code> 요청을
수행해야 한다. 이를 통해 관리자는 앱에 필요한
<a href=/docs/reference/access-authn-authz/rbac/#referring-to-resources>개별 인스턴스에 대한 접근을 허용 목록에 추가</a>하면서 모든 시크릿에 대한 접근을
제한할 수 있다.</p>
<p><code>get</code> 반복을 통한 성능 향상을 위해, 클라이언트는 시크릿을
참조한 다음 리소스를 감시(<code>watch</code>)하고, 참조가 변경되면 시크릿을 다시 요청하는 리소스를
설계할 수 있다. 덧붙여, 클라이언트에게 개별 리소스를 감시(<code>watch</code>)하도록 하는 <a href=https://github.com/kubernetes/community/blob/master/contributors/design-proposals/api-machinery/bulk_watch.md>"대량 감시" API</a>도
제안되었으며, 쿠버네티스의 후속 릴리스에서 사용할 수
있을 것이다.</p>
<h2 id=보안-속성>보안 속성</h2>
<h3 id=보호>보호</h3>
<p>시크릿은 시크릿을 사용하는 파드와 독립적으로 생성될 수
있으므로, 파드 생성, 보기, 편집 워크플로 중에
시크릿이 노출될 위험이 적다. 또한 시스템은 가능한 경우
디스크에 기록하지 않는 등 시크릿에 대한 추가 예방 조치를
취할 수 있다.</p>
<p>해당 노드의 파드에 필요한 경우에만 시크릿이 노드로 전송된다.
kubelet은 시크릿이 디스크 저장소에 기록되지 않도록 시크릿을
<code>tmpfs</code> 에 저장한다. 일단 시크릿에 의존하는 파드가 삭제되면, kubelet은
시크릿 데이터의 로컬 복제본도 삭제한다.</p>
<p>동일한 노드의 여러 파드에 대한 시크릿이 있을 수 있다. 그러나
파드가 요청하는 시크릿만 해당 컨테이너 내에서 잠재적으로 볼 수 있다.
따라서, 하나의 파드는 다른 파드의 시크릿에 접근할 수 없다.</p>
<p>파드에는 여러 개의 컨테이너가 있을 수 있다. 그러나, 파드의 각 컨테이너는
컨테이너 내에서 볼 수 있도록 파드의 <code>volumeMounts</code> 에 있는 시크릿 볼륨을
요청해야 한다. 이것은 유용한 <a href=#%EC%82%AC%EC%9A%A9-%EC%82%AC%EB%A1%80-%ED%8C%8C%EB%93%9C%EC%9D%98-%ED%95%9C-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88%EC%97%90-%ED%91%9C%EC%8B%9C%EB%90%98%EB%8A%94-%EC%8B%9C%ED%81%AC%EB%A6%BF>파드 레벨에서의 보안
파티션</a>을 구성하는 데 사용할 수 있다.</p>
<p>대부분의 쿠버네티스 배포판에서, 사용자와 API 서버 간,
API 서버에서 kubelet으로의 통신은 SSL/TLS로 보호된다.
이러한 채널을 통해 전송될 때 시크릿이 보호된다.</p>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.13 [beta]</code>
</div>
<p>시크릿 데이터에 대해 <a href=/docs/tasks/administer-cluster/encrypt-data/>저장 시 암호화(encryption at rest)</a>를
활성화할 수 있으며, 이를 통해 보안성에 대한 보장 없이는 시크릿이 <a class=glossary-tooltip title="모든 클러스터 데이터를 담는 쿠버네티스 뒷단의 저장소로 사용되는 일관성·고가용성 키-값 저장소." data-toggle=tooltip data-placement=top href=/docs/tasks/administer-cluster/configure-upgrade-etcd/ target=_blank aria-label=etcd>etcd</a>에 저장되지 않도록 한다 .</p>
<h3 id=위험>위험</h3>
<ul>
<li>API 서버에서 시크릿 데이터는 <a class=glossary-tooltip title="모든 클러스터 데이터를 담는 쿠버네티스 뒷단의 저장소로 사용되는 일관성·고가용성 키-값 저장소." data-toggle=tooltip data-placement=top href=/docs/tasks/administer-cluster/configure-upgrade-etcd/ target=_blank aria-label=etcd>etcd</a>에 저장된다.
따라서,
<ul>
<li>관리자는 클러스터 데이터에 대해 저장 시 암호화를 활성화해야 한다. (v1.13 이상 필요)</li>
<li>관리자는 etcd에 대한 접근을 admin 사용자로 제한해야 한다.</li>
<li>관리자는 더 이상 사용하지 않을 때 etcd에서 사용하는 디스크를 지우거나 폐기할 수 있다.</li>
<li>클러스터에서 etcd를 실행하는 경우, 관리자는 etcd peer-to-peer 통신에 대해
SSL/TLS를 사용해야 한다.</li>
</ul>
</li>
<li>base64로 인코딩된 시크릿 데이터가 있는 매니페스트(JSON 또는 YAML)
파일을 통해 시크릿을 구성하는 경우, 이 파일을 공유하거나 소스 리포지터리에
체크인하면 시크릿이 손상된다. Base64 인코딩은 암호화 방법이 <em>아니며</em>
일반 텍스트와 동일한 것으로 간주된다.</li>
<li>실수로 기록하거나 신뢰할 수 없는 상대방에게 전송하지 않는 것과 같이,
애플리케이션은 볼륨에서 읽은 후에 시크릿 값을 보호해야 한다.</li>
<li>시크릿을 사용하는 파드를 생성할 수 있는 사용자는 해당 시크릿의 값도 볼 수 있다.
API 서버 정책이 해당 사용자가 시크릿을 읽을 수 있도록 허용하지 않더라도, 사용자는
시크릿을 노출하는 파드를 실행할 수 있다.</li>
</ul>
<h2 id=다음-내용>다음 내용</h2>
<ul>
<li><a href=/ko/docs/tasks/configmap-secret/managing-secret-using-kubectl/><code>kubectl</code> 을 사용한 시크릿 관리</a>하는 방법 배우기</li>
<li><a href=/ko/docs/tasks/configmap-secret/managing-secret-using-config-file/>구성 파일을 사용한 시크릿 관리</a>하는 방법 배우기</li>
<li><a href=/ko/docs/tasks/configmap-secret/managing-secret-using-kustomize/>kustomize를 사용한 시크릿 관리</a>하는 방법 배우기</li>
<li><a href=/docs/reference/kubernetes-api/config-and-storage-resources/secret-v1/>API 레퍼런스</a>에서 <code>Secret</code>에 대해 읽기</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-436057b96151ecb8a4a9a9f456b5d0fc>7.4 - 파드 및 컨테이너 리소스 관리</h1>
<p><a class=glossary-tooltip title="파드는 클러스터에서 실행 중인 컨테이너의 집합을 나타낸다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/pods/ target=_blank aria-label=파드>파드</a>를 지정할 때,
<a class=glossary-tooltip title="소프트웨어와 그것에 종속된 모든 것을 포함한 가볍고 휴대성이 높은 실행 가능 이미지." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/containers/ target=_blank aria-label=컨테이너>컨테이너</a>에 필요한 각 리소스의 양을 선택적으로 지정할 수 있다.
지정할 가장 일반적인 리소스는 CPU와 메모리(RAM) 그리고 다른 것들이 있다.</p>
<p>파드에서 컨테이너에 대한 리소스 <em>요청(request)</em> 을 지정하면,
<a class=glossary-tooltip title="노드가 배정되지 않은 새로 생성된 파드를 감지하고, 실행할 노드를 선택하는 컨트롤 플레인 컴포넌트." data-toggle=tooltip data-placement=top href=/docs/reference/command-line-tools-reference/kube-scheduler/ target=_blank aria-label=kube-scheduler>kube-scheduler</a>는 이 정보를
사용하여 파드가 배치될 노드를 결정한다. 컨테이너에 대한 리소스 <em>제한(limit)</em> 을
지정하면, kubelet은 실행 중인 컨테이너가 설정한 제한보다 많은 리소스를
사용할 수 없도록 해당 제한을 적용한다. 또한 kubelet은
컨테이너가 사용할 수 있도록 해당 시스템 리소스의 최소 <em>요청</em> 량을
예약한다.</p>
<h2 id=요청-및-제한>요청 및 제한</h2>
<p>파드가 실행 중인 노드에 사용 가능한 리소스가 충분하면, 컨테이너가 해당
리소스에 지정한 <code>request</code> 보다 더 많은 리소스를 사용할 수 있도록 허용된다.
그러나, 컨테이너는 리소스 <code>limit</code> 보다 더 많은 리소스를 사용할 수는 없다.</p>
<p>예를 들어, 컨테이너에 대해 256MiB의 <code>memory</code> 요청을 설정하고, 해당 컨테이너가
8GiB의 메모리를 가진 노드로 스케줄된 파드에 있고 다른 파드는 없는 경우, 컨테이너는 더 많은 RAM을
사용할 수 있다.</p>
<p>해당 컨테이너에 대해 4GiB의 <code>memory</code> 제한을 설정하면, kubelet(그리고
<a class=glossary-tooltip title="컨테이너 런타임은 컨테이너 실행을 담당하는 소프트웨어이다." data-toggle=tooltip data-placement=top href=/ko/docs/setup/production-environment/container-runtimes/ target=_blank aria-label="컨테이너 런타임">컨테이너 런타임</a>)이 제한을 적용한다.
런타임은 컨테이너가 구성된 리소스 제한을 초과하여 사용하지 못하게 한다. 예를 들어,
컨테이너의 프로세스가 허용된 양보다 많은 메모리를 사용하려고 하면,
시스템 커널은 메모리 부족(out of memory, OOM) 오류와 함께 할당을 시도한 프로세스를
종료한다.</p>
<p>제한은 반응적(시스템이 위반을 감지한 후에 개입)으로
또는 강제적(시스템이 컨테이너가 제한을 초과하지 않도록 방지)으로 구현할 수 있다. 런타임마다
다른 방식으로 동일한 제약을 구현할 수 있다.</p>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> 컨테이너가 자체 메모리 제한을 지정하지만, 메모리 요청을 지정하지 않는 경우, 쿠버네티스는
제한과 일치하는 메모리 요청을 자동으로 할당한다. 마찬가지로, 컨테이너가 자체 CPU 제한을
지정하지만, CPU 요청을 지정하지 않는 경우, 쿠버네티스는 제한과 일치하는 CPU 요청을 자동으로
할당한다.
</div>
<h2 id=리소스-타입>리소스 타입</h2>
<p><em>CPU</em> 와 <em>메모리</em> 는 각각 <em>리소스 타입</em> 이다. 리소스 타입에는 기본 단위가 있다.
CPU는 컴퓨팅 처리를 나타내며 <a href=#cpu%EC%9D%98-%EC%9D%98%EB%AF%B8>쿠버네티스 CPU</a> 단위로 지정된다.
메모리는 바이트 단위로 지정된다.
리눅스 워크로드에 대해서는, <em>huge page</em> 리소스를 지정할 수 있다.
Huge page는 노드 커널이 기본 페이지 크기보다 훨씬 큰 메모리
블록을 할당하는 리눅스 관련 기능이다.</p>
<p>예를 들어, 기본 페이지 크기가 4KiB인 시스템에서, <code>hugepages-2Mi: 80Mi</code> 제한을
지정할 수 있다. 컨테이너가 40개 이상의 2MiB huge page(총 80MiB)를
할당하려고 하면 해당 할당이 실패한다.</p>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> <code>hugepages-*</code> 리소스를 오버커밋할 수 없다.
이것은 <code>memory</code> 및 <code>cpu</code> 리소스와는 다르다.
</div>
<p>CPU와 메모리를 통칭하여 <em>컴퓨트 리소스</em> 또는 <em>리소스</em> 라고 한다. 컴퓨트
리소스는 요청, 할당 및 소비될 수 있는 측정 가능한
수량이다. 이것은
<a href=/ko/docs/concepts/overview/kubernetes-api/>API 리소스</a>와는 다르다. 파드 및
<a href=/ko/docs/concepts/services-networking/service/>서비스</a>와 같은 API 리소스는
쿠버네티스 API 서버를 통해 읽고 수정할 수 있는 오브젝트이다.</p>
<h2 id=파드와-컨테이너의-리소스-요청-및-제한>파드와 컨테이너의 리소스 요청 및 제한</h2>
<p>각 컨테이너에 대해, 다음과 같은
리소스 제한(limit) 및 요청(request)을 지정할 수 있다.</p>
<ul>
<li><code>spec.containers[].resources.limits.cpu</code></li>
<li><code>spec.containers[].resources.limits.memory</code></li>
<li><code>spec.containers[].resources.limits.hugepages-&lt;size></code></li>
<li><code>spec.containers[].resources.requests.cpu</code></li>
<li><code>spec.containers[].resources.requests.memory</code></li>
<li><code>spec.containers[].resources.requests.hugepages-&lt;size></code></li>
</ul>
<p>요청 및 제한은 개별 컨테이너에 대해서만 지정할 수 있지만,
한 파드의 총 리소스 요청 및 제한에 대해 생각해 보는 것도
유용할 수 있다.
특정 리소스 종류에 대해, <em>파드 리소스 요청/제한</em> 은 파드의 각 컨테이너에 대한
해당 타입의 리소스 요청/제한의 합이다.</p>
<h2 id=쿠버네티스의-리소스-단위>쿠버네티스의 리소스 단위</h2>
<h3 id=meaning-of-cpu>CPU 리소스 단위</h3>
<p>CPU 리소스에 대한 제한 및 요청은 <em>cpu</em> 단위로 측정된다.
쿠버네티스에서, 1 CPU 단위는 노드가 물리 호스트인지
아니면 물리 호스트 내에서 실행되는 가상 머신인지에 따라
<strong>1 물리 CPU 코어</strong> 또는 <strong>1 가상 코어</strong> 에 해당한다.</p>
<p>요청량을 소수점 형태로 명시할 수도 있다. 컨테이너의
<code>spec.containers[].resources.requests.cpu</code>를 <code>0.5</code>로 설정한다는 것은,
<code>1.0</code> CPU를 요청했을 때와 비교하여 절반의 CPU 타임을 요청한다는 의미이다.
CPU 자원의 단위와 관련하여, <code>0.1</code> 이라는 <a href=/docs/reference/kubernetes-api/common-definitions/quantity/>수량</a> 표현은
"백 밀리cpu"로 읽을 수 있는 <code>100m</code> 표현과 동일하다. 어떤 사람들은
"백 밀리코어"라고 말하는데, 같은 것을 의미하는 것으로 이해된다.</p>
<p>CPU 리소스는 항상 리소스의 절대량으로 표시되며, 상대량으로 표시되지 않는다.
예를 들어, 컨테이너가 싱글 코어, 듀얼 코어, 또는 48 코어 머신 중 어디에서 실행되는지와 상관없이
<code>500m</code> CPU는 거의 같은 양의 컴퓨팅 파워를 가리킨다.</p>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> 쿠버네티스에서 CPU 리소스를 <code>1m</code>보다 더 정밀한 단위로 표기할 수 없다.
이 때문에, CPU 단위를 <code>1.0</code> 또는 <code>1000m</code>보다 작은 밀리CPU 형태로 표기하는 것이 유용하다.
예를 들어, <code>0.005</code> 보다는 <code>5m</code>으로 표기하는 것이 좋다.
</div>
<h3 id=meaning-of-memory>메모리 리소스 단위</h3>
<p><code>memory</code> 에 대한 제한 및 요청은 바이트 단위로 측정된다.
E, P, T, G, M, k 와 같은
<a href=/docs/reference/kubernetes-api/common-definitions/quantity/>수량</a> 접미사 중 하나를 사용하여 메모리를
일반 정수 또는 고정 소수점 숫자로 표현할 수 있다. Ei, Pi, Ti, Gi, Mi, Ki와
같은 2의 거듭제곱을 사용할 수도 있다. 예를 들어, 다음은 대략 동일한 값을 나타낸다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>128974848, 129e6, 129M, 128974848000m, 123Mi
</code></pre></div><p>접미사의 대소문자에 유의한다.
<code>400m</code>의 메모리를 요청하면, 이는 0.4 바이트를 요청한 것이다.
이 사람은 아마도 400 메비바이트(mebibytes) (<code>400Mi</code>) 또는 400 메가바이트 (<code>400M</code>) 를 요청하고 싶었을 것이다.</p>
<h2 id=example-1>컨테이너 리소스 예제</h2>
<p>다음 파드는 두 컨테이너로 구성된다.
각 컨테이너는 0.25 CPU와 64 MiB(2<sup>26</sup> 바이트) 메모리 요청을 갖도록 정의되어 있다.
또한 각 컨테이너는 0.5 CPU와 128 MiB 메모리 제한을 갖는다.
이 경우 파드는 0.5 CPU와 128 MiB 메모리 요청을 가지며,
1 CPU와 256 MiB 메모리 제한을 갖는다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>app<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>images.my-company.example/app:v4<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;64Mi&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;250m&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;128Mi&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;500m&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>log-aggregator<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>images.my-company.example/log-aggregator:v6<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;64Mi&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;250m&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;128Mi&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;500m&#34;</span><span style=color:#bbb>
</span></code></pre></div><h2 id=리소스-요청이-포함된-파드를-스케줄링하는-방법>리소스 요청이 포함된 파드를 스케줄링하는 방법</h2>
<p>파드를 생성할 때, 쿠버네티스 스케줄러는 파드를 실행할 노드를
선택한다. 각 노드는 파드에 제공할 수 있는 CPU와 메모리 양과 같은 각 리소스 타입에 대해
최대 용량을 갖는다. 스케줄러는 각 리소스 타입마다
스케줄된 컨테이너의 리소스 요청 합계가
노드 용량보다 작도록 한다.
참고로 노드의 실제 메모리나
CPU 리소스 사용량은 매우 적지만, 용량 확인에 실패한 경우
스케줄러는 여전히 노드에 파드를 배치하지 않는다. 이는 리소스 사용량이
나중에 증가할 때, 예를 들어, 일일 요청 비율이
최대일 때 노드의 리소스 부족을 방지한다.</p>
<h2 id=how-pods-with-resource-limits-are-run>쿠버네티스가 리소스 요청 및 제한을 적용하는 방법</h2>
<p>kubelet이 파드의 컨테이너를 시작할 때,
kubelet은 해당 컨테이너의 메모리/CPU 요청 및 제한을 컨테이너 런타임에 전달한다.</p>
<p>리눅스에서, 일반적으로 컨테이너 런타임은
적용될 커널 <a class=glossary-tooltip title="선택적으로 리소스를 격리, 관리, 제한하는 리눅스 프로세스의 그룹." data-toggle=tooltip data-placement=top href="/ko/docs/reference/glossary/?all=true#term-cgroup" target=_blank aria-label=cgroup>cgroup</a>을 설정하고,
명시한 제한을 적용한다.</p>
<ul>
<li>CPU 제한은 해당 컨테이너가 사용할 수 있는 CPU 시간에 대한 강한 상한(hard ceiling)을 정의한다.
각 스케줄링 간격(시간 조각)마다, 리눅스 커널은 이 제한이 초과되었는지를 확인하고,
만약 초과되었다면 cgroup의 실행 재개를 허가하지 않고 기다린다.</li>
<li>CPU 요청은 일반적으로 가중치 설정(weighting)을 정의한다.
현재 부하율이 높은 시스템에서 여러 개의 컨테이너(cgroup)가 실행되어야 하는 경우,
큰 CPU 요청값을 갖는 워크로드가 작은 CPU 요청값을 갖는 워크로드보다 더 많은 CPU 시간을 할당받는다.</li>
<li>메모리 요청은 주로 (쿠버네티스) 파드 스케줄링 과정에서 사용된다.
cgroup v2를 사용하는 노드에서, 컨테이너 런타임은 메모리 요청을 힌트로 사용하여
<code>memory.min</code> 및 <code>memory.low</code>을 설정할 수 있다.</li>
<li>메모리 제한은 해당 cgroup에 대한 메모리 사용량 상한을 정의한다.
컨테이너가 제한보다 더 많은 메모리를 할당받으려고 시도하면,
리눅스 커널의 메모리 부족(out-of-memory) 서브시스템이 활성화되고
(일반적으로) 개입하여 메모리를 할당받으려고 했던 컨테이너의 프로세스 중 하나를 종료한다.
해당 프로세스의 PID가 1이고, 컨테이너가 재시작 가능(restartable)으로 표시되어 있으면, 쿠버네티스가 해당 컨테이너를 재시작한다.</li>
<li>파드 또는 컨테이너의 메모리 제한은 메모리 기반 볼륨(예: <code>emptyDir</code>)의 페이지에도 적용될 수 있다.
kubelet은 <code>tmpfs</code> emptyDir 볼륨을 로컬 임시(ephemeral) 스토리지가 아닌
컨테이너 메모리 사용으로 간주하여 추적한다.</li>
</ul>
<p>한 컨테이너가 메모리 요청을 초과하고
해당 노드의 메모리가 부족하지면,
해당 컨테이너가 속한 파드가 <a class=glossary-tooltip title="Process of terminating one or more Pods on Nodes" data-toggle=tooltip data-placement=top href=/docs/concepts/scheduling-eviction/ target=_blank aria-label=축출>축출</a>될 수 있다.</p>
<p>컨테이너가 비교적 긴 시간 동안 CPU 제한을 초과하는 것이 허용될 수도, 허용되지 않을 수도 있다.
그러나, 컨테이너 런타임은 과도한 CPU 사용률을 이유로 파드 또는 컨테이너를 종료시키지는 않는다.</p>
<p>리소스 제한으로 인해 컨테이너를 스케줄할 수 없는지 또는 종료 중인지 확인하려면,
<a href=#%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0>문제 해결</a> 섹션을 참조한다.</p>
<h3 id=컴퓨트-및-메모리-리소스-사용량-모니터링>컴퓨트 및 메모리 리소스 사용량 모니터링</h3>
<p>kubelet은 파드의 리소스 사용량을 파드
<a href=/ko/docs/concepts/overview/working-with-objects/kubernetes-objects/#%EC%98%A4%EB%B8%8C%EC%A0%9D%ED%8A%B8-%EB%AA%85%EC%84%B8-spec-%EC%99%80-%EC%83%81%ED%83%9C-status><code>status</code></a>에 포함하여 보고한다.</p>
<p>클러스터에서 선택적인 모니터링 도구를
사용할 수 있다면, <a href=/ko/docs/tasks/debug-application-cluster/resource-metrics-pipeline/#%EB%A9%94%ED%8A%B8%EB%A6%AD-api>메트릭 API</a>에서
직접 또는 모니터링 도구에서 파드 리소스
사용량을 검색할 수 있다.</p>
<h2 id=로컬-임시-ephemeral-스토리지>로컬 임시(ephemeral) 스토리지</h2>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.10 [beta]</code>
</div>
<p>노드에는 로컬에 연결된 쓰기 가능 장치 또는, 때로는 RAM에 의해
지원되는 로컬 임시 스토리지가 있다.
"임시"는 내구성에 대한 장기간의 보증이 없음을 의미한다.</p>
<p>파드는 스크래치 공간, 캐싱 및 로그에 대해 임시 로컬 스토리지를 사용한다.
kubelet은 로컬 임시 스토리지를 사용하여 컨테이너에
<a href=/ko/docs/concepts/storage/volumes/#emptydir><code>emptyDir</code></a>
<a class=glossary-tooltip title="데이터를 포함하고 있는 디렉터리이며, 파드의 컨테이너에서 접근 가능하다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/storage/volumes/ target=_blank aria-label=볼륨>볼륨</a>을 마운트하기 위해 파드에 스크래치 공간을 제공할 수 있다.</p>
<p>kubelet은 이러한 종류의 스토리지를 사용하여
<a href=/ko/docs/concepts/cluster-administration/logging/#%EB%85%B8%EB%93%9C-%EB%A0%88%EB%B2%A8%EC%97%90%EC%84%9C%EC%9D%98-%EB%A1%9C%EA%B9%85>노드-레벨 컨테이너 로그</a>,
컨테이너 이미지 및 실행 중인 컨테이너의 쓰기 가능 계층을 보유한다.</p>
<div class="alert alert-warning caution callout" role=alert>
<strong>주의:</strong> 노드가 실패하면, 임시 스토리지의 데이터가 손실될 수 있다.
애플리케이션은 로컬 임시 스토리지에서 성능에 대한 SLA(예: 디스크 IOPS)를
기대할 수 없다.
</div>
<p>베타 기능에서, 쿠버네티스는 파드가 사용할 수 있는 임시 로컬 스토리지의 양을
추적, 예약 및 제한할 수 있도록 해준다.</p>
<h3 id=로컬-임시-스토리지-구성>로컬 임시 스토리지 구성</h3>
<p>쿠버네티스는 노드에서 로컬 임시 스토리지를 구성하는 두 가지 방법을 지원한다.
<ul class="nav nav-tabs" id=local-storage-configurations role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#local-storage-configurations-0 role=tab aria-controls=local-storage-configurations-0 aria-selected=true>단일 파일시스템</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#local-storage-configurations-1 role=tab aria-controls=local-storage-configurations-1>두 개의 파일시스템</a></li></ul>
<div class=tab-content id=local-storage-configurations><div id=local-storage-configurations-0 class="tab-pane show active" role=tabpanel aria-labelledby=local-storage-configurations-0>
<p><p>이 구성에서, 모든 종류의 임시 로컬 데이터(<code>emptyDir</code> 볼륨,
쓰기 가능 계층, 컨테이너 이미지, 로그)를 하나의 파일시스템에 배치한다.
kubelet을 구성하는 가장 효과적인 방법은 이 파일시스템을 쿠버네티스(kubelet) 데이터 전용으로
하는 것이다.</p>
<p>kubelet은 또한
<a href=/ko/docs/concepts/cluster-administration/logging/#%EB%85%B8%EB%93%9C-%EB%A0%88%EB%B2%A8%EC%97%90%EC%84%9C%EC%9D%98-%EB%A1%9C%EA%B9%85>노드-레벨 컨테이너 로그</a>를
작성하고 임시 로컬 스토리지와 유사하게 처리한다.</p>
<p>kubelet은 구성된 로그 디렉터리 내의 파일에 로그를 기록한다(기본적으로
<code>/var/log</code>). 그리고 로컬에 저장된 다른 데이터에 대한 기본 디렉터리가 있다(기본적으로
<code>/var/lib/kubelet</code>).</p>
<p>일반적으로, <code>/var/lib/kubelet</code> 와 <code>/var/log</code> 모두 시스템 루트 파일시스템에 위치하고,
그리고 kubelet은 이런 레이아웃을 염두에 두고 설계되었다.</p>
<p>노드는 쿠버네티스에서 사용하지 않는 다른 많은 파일시스템을
가질 수 있다.</p>
</div>
<div id=local-storage-configurations-1 class=tab-pane role=tabpanel aria-labelledby=local-storage-configurations-1>
<p><p>사용하고 있는 노드에 실행 중인 파드에서 발생하는 임시 데이터를
위한 파일시스템을 가진다(로그와 <code>emptyDir</code> 볼륨). 이 파일시스템을
다른 데이터(예를 들어, 쿠버네티스와 관련없는 시스템 로그)를 위해 사용할 수 있다. 이 파일시스템은
루트 파일시스템일 수도 있다.</p>
<p>kubelet은 또한
<a href=/ko/docs/concepts/cluster-administration/logging/#%EB%85%B8%EB%93%9C-%EB%A0%88%EB%B2%A8%EC%97%90%EC%84%9C%EC%9D%98-%EB%A1%9C%EA%B9%85>노드-레벨 컨테이너 로그</a>를
첫 번째 파일시스템에 기록하고, 임시 로컬 스토리지와 유사하게 처리한다.</p>
<p>또한 다른 논리 스토리지 장치가 지원하는 별도의 파일시스템을 사용한다.
이 구성에서, 컨테이너 이미지 계층과 쓰기 가능한 계층을 배치하도록
kubelet에 지시하는 디렉터리는 이 두 번째 파일시스템에 있다.</p>
<p>첫 번째 파일시스템에는 이미지 계층이나 쓰기 가능한 계층이 없다.</p>
<p>노드는 쿠버네티스에서 사용하지 않는 다른 많은 파일시스템을
가질 수 있다.</p>
</div></div>
</p>
<p>kubelet은 사용 중인 로컬 스토리지 양을 측정할 수 있다. 이것은 다음을
제공한다.</p>
<ul>
<li><code>LocalStorageCapacityIsolation</code>
<a href=/ko/docs/reference/command-line-tools-reference/feature-gates/>기능 게이트</a>(이
기능이 기본적으로 설정되어 있음)를 활성화하고,</li>
<li>로컬 임시 스토리지에 대한 지원되는 구성 중 하나를
사용하여 노드를 설정한다.</li>
</ul>
<p>다른 구성을 사용하는 경우, kubelet은 임시 로컬 스토리지에 대한 리소스
제한을 적용하지 않는다.</p>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> kubelet은 로컬 임시 스토리지가 아닌 컨테이너 메모리 사용으로
<code>tmpfs</code> emptyDir 볼륨을 추적한다.
</div>
<h3 id=로컬-임시-스토리지에-대한-요청-및-제한-설정>로컬 임시 스토리지에 대한 요청 및 제한 설정</h3>
<p><code>ephemeral-storage</code>를 명시하여 로컬 임시 저장소를 관리할 수 있다.
파드의 각 컨테이너는 다음 중 하나 또는 모두를 명시할 수 있다.</p>
<ul>
<li><code>spec.containers[].resources.limits.ephemeral-storage</code></li>
<li><code>spec.containers[].resources.requests.ephemeral-storage</code></li>
</ul>
<p><code>ephemeral-storage</code> 에 대한 제한 및 요청은 바이트 단위로 측정된다.
E, P, T, G, M, K와 같은 접미사 중 하나를 사용하여 스토리지를 일반 정수 또는 고정 소수점 숫자로 표현할 수 있다.
Ei, Pi, Ti, Gi, Mi, Ki와 같은 2의 거듭제곱을 사용할 수도 있다.
예를 들어, 다음은 거의 동일한 값을 나타낸다.</p>
<ul>
<li><code>128974848</code></li>
<li><code>129e6</code></li>
<li><code>129M</code></li>
<li><code>123Mi</code></li>
</ul>
<p>다음 예에서, 파드에 두 개의 컨테이너가 있다.
각 컨테이너에는 2GiB의 로컬 임시 스토리지 요청이 있다.
각 컨테이너에는 4GiB의 로컬 임시 스토리지 제한이 있다.
따라서, 파드는 4GiB의 로컬 임시 스토리지 요청과 8GiB 로컬 임시 스토리지 제한을 가진다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>app<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>images.my-company.example/app:v4<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ephemeral-storage</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2Gi&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ephemeral-storage</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;4Gi&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>ephemeral<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/tmp&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>log-aggregator<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>images.my-company.example/log-aggregator:v6<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ephemeral-storage</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2Gi&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ephemeral-storage</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;4Gi&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>ephemeral<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/tmp&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>ephemeral<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>emptyDir</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span></code></pre></div><h3 id=ephemeral-storage-요청이-있는-파드의-스케줄링-방법><code>ephemeral-storage</code> 요청이 있는 파드의 스케줄링 방법</h3>
<p>파드를 생성할 때, 쿠버네티스 스케줄러는 파드를 실행할 노드를 선택한다.
각 노드에는 파드에 제공할 수 있는 최대 임시 스토리지 공간이 있다.
자세한 정보는,
<a href=/docs/tasks/administer-cluster/reserve-compute-resources/#node-allocatable>노드 할당 가능</a>을 참조한다.</p>
<p>스케줄러는 스케줄된 컨테이너의 리소스 요청 합계가 노드 용량보다 작도록 한다.</p>
<h3 id=resource-emphemeralstorage-consumption>임시 스토리지 소비 관리</h3>
<p>kubelet이 로컬 임시 스토리지를 리소스로 관리하는 경우,
kubelet은 다음에서 스토리지 사용을 측정한다.</p>
<ul>
<li><em>tmpfs</em> <code>emptyDir</code> 볼륨을 제외한 <code>emptyDir</code> 볼륨</li>
<li>노드-레벨 로그가 있는 디렉터리</li>
<li>쓰기 가능한 컨테이너 계층</li>
</ul>
<p>허용하는 것보다 더 많은 임시 스토리지를 파드가 사용하는 경우, kubelet은
파드 축출을 트리거하는 축출 신호를 설정한다.</p>
<p>컨테이너-레벨 격리의 경우, 컨테이너의 쓰기 가능한 계층과 로그
사용량이 스토리지 제한을 초과하면, kubelet은 파드를 축출하도록 표시한다.</p>
<p>파드-레벨 격리에 대해 kubelet은 해당 파드의 컨테이너에 대한 제한을 합하여
전체 파드 스토리지 제한을 해결한다. 이 경우, 모든
컨테이너와 파드의 <code>emptyDir</code> 볼륨의 로컬 임시 스토리지 사용량 합계가
전체 파드 스토리지 제한을 초과하면, kubelet은 파드를 축출 대상으로
표시한다.</p>
<div class="alert alert-warning caution callout" role=alert>
<strong>주의:</strong> <p>kubelet이 로컬 임시 스토리지를 측정하지 않는 경우,
로컬 스토리지 제한을 초과하는 파드는 로컬 스토리지 리소스 제한을
위반해도 축출되지 않는다.</p>
<p>그러나, 쓰기 가능한 컨테이너 계층, 노드-레벨 로그
또는 <code>emptyDir</code> 볼륨의 파일 시스템 공간이 부족하면, 로컬
스토리지가 부족하다고 노드 자체에 <a class=glossary-tooltip title="세 가지 필수 속성: 키(key), 값(value), 효과(effect)로 구성된 코어 오브젝트. 테인트는 파드가 노드나 노드 그룹에 스케줄링되는 것을 방지한다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/scheduling-eviction/taint-and-toleration/ target=_blank aria-label=테인트>테인트</a>되고
이로인해 특별히 이 테인트를 허용하지 않는 모든 파드를 축출하도록 트리거한다.</p>
<p>임시 로컬 스토리지에 대해 지원되는 <a href=#%EB%A1%9C%EC%BB%AC-%EC%9E%84%EC%8B%9C-%EC%8A%A4%ED%86%A0%EB%A6%AC%EC%A7%80-%EA%B5%AC%EC%84%B1>구성</a>을
참조한다.</p>
</div>
<p>kubelet은 파드 스토리지 사용을 측정하는 다양한 방법을 지원한다.</p>
<ul class="nav nav-tabs" id=resource-emphemeralstorage-measurement role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#resource-emphemeralstorage-measurement-0 role=tab aria-controls=resource-emphemeralstorage-measurement-0 aria-selected=true>주기적 스캐닝</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#resource-emphemeralstorage-measurement-1 role=tab aria-controls=resource-emphemeralstorage-measurement-1>파일시스템 프로젝트 쿼터</a></li></ul>
<div class=tab-content id=resource-emphemeralstorage-measurement><div id=resource-emphemeralstorage-measurement-0 class="tab-pane show active" role=tabpanel aria-labelledby=resource-emphemeralstorage-measurement-0>
<p><p>kubelet은 각 <code>emptyDir</code> 볼륨, 컨테이너 로그 디렉터리 및 쓰기 가능한 컨테이너 계층을
스캔하는 정기적인 스케줄 검사를 수행한다.</p>
<p>스캔은 사용된 공간의 양을 측정한다.</p>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> <p>이 모드에서, kubelet은 삭제된 파일의 열린 파일 디스크립터를
추적하지 않는다.</p>
<p>여러분(또는 컨테이너)이 <code>emptyDir</code> 볼륨 안에 파일을 생성하면,
그 파일이 열리고, 파일이 열려있는 동안 파일을
삭제하면, 삭제된 파일의 inode는 해당 파일을 닫을 때까지
유지되지만 kubelet은 사용 중인 공간으로 분류하지 않는다.</p>
</div>
</div>
<div id=resource-emphemeralstorage-measurement-1 class=tab-pane role=tabpanel aria-labelledby=resource-emphemeralstorage-measurement-1>
<p><div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.15 [alpha]</code>
</div>
<p>프로젝트 쿼터는 파일시스템에서 스토리지 사용을 관리하기 위한
운영체제 레벨의 기능이다. 쿠버네티스를 사용하면, 스토리지 사용을
모니터링하기 위해 프로젝트 쿼터를 사용할 수 있다. 노드에서 'emptyDir' 볼륨을
지원하는 파일시스템이 프로젝트 쿼터 지원을 제공하는지 확인한다.
예를 들어, XFS와 ext4fs는 프로젝트 쿼터를 지원한다.</p>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> 프로젝트 쿼터를 통해 스토리지 사용을 모니터링할 수 있다. 이는 제한을 강제하지 않는다.
</div>
<p>쿠버네티스는 <code>1048576</code> 부터 프로젝트 ID를 사용한다. 사용 중인 ID는
<code>/etc/projects</code> 와 <code>/etc/projid</code> 에 등록되어 있다. 이 범위의 프로젝트 ID가
시스템에서 다른 목적으로 사용되는 경우, 쿠버네티스가
이를 사용하지 않도록 해당 프로젝트 ID를 <code>/etc/projects</code> 와 <code>/etc/projid</code> 에
등록해야 한다.</p>
<p>쿼터는 디렉터리 검색보다 빠르고 정확하다. 디렉터리가
프로젝트에 할당되면, 디렉터리 아래에 생성된
모든 파일이 해당 프로젝트에 생성되며, 커널은 해당 프로젝트의
파일에서 사용 중인 블록 수를 추적하기만 하면 된다.
파일이 생성되고 삭제되었지만, 열린 파일 디스크립터가 있으면,
계속 공간을 소비한다. 쿼터 추적은 공간을 정확하게 기록하는 반면
디렉터리 스캔은 삭제된 파일이 사용한 스토리지를 간과한다.</p>
<p>프로젝트 쿼터를 사용하려면, 다음을 수행해야 한다.</p>
<ul>
<li>
<p><a href=/docs/reference/config-api/kubelet-config.v1beta1/>kubelet 구성</a>의
<code>featureGates</code> 필드 또는 <code>--feature-gates</code> 커맨드 라인 플래그를 사용하여
<code>LocalStorageCapacityIsolationFSQuotaMonitoring=true</code>
<a href=/ko/docs/reference/command-line-tools-reference/feature-gates/>기능 게이트</a>를
활성화한다.</p>
</li>
<li>
<p>루트 파일시스템(또는 선택적인 런타임 파일시스템)에
프로젝트 쿼터가 활성화되어 있는지 확인한다. 모든 XFS 파일시스템은 프로젝트 쿼터를 지원한다.
ext4 파일시스템의 경우, 파일시스템이 마운트되지 않은 상태에서 프로젝트 쿼터
추적 기능을 활성화해야 한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#080;font-style:italic># ext4인 /dev/block-device가 마운트되지 않은 경우</span>
sudo tune2fs -O project -Q prjquota /dev/block-device
</code></pre></div></li>
<li>
<p>루트 파일시스템(또는 선택적인 런타임 파일시스템)은 프로젝트 쿼터를
활성화한 상태에서 마운트해야 힌다. XFS와 ext4fs 모두에서,
마운트 옵션의 이름은 <code>prjquota</code> 이다.</p>
</li>
</ul>
</div></div>
<h2 id=확장된-리소스>확장된 리소스</h2>
<p>확장된 리소스는 <code>kubernetes.io</code> 도메인 외부의 전체 주소(fully-qualified)
리소스 이름이다. 쿠버네티스에 내장되지 않은 리소스를 클러스터 운영자가 알리고
사용자는 사용할 수 있다.</p>
<p>확장된 리소스를 사용하려면 두 단계가 필요한다. 먼저, 클러스터
운영자는 확장된 리소스를 알려야 한다. 둘째, 사용자는 파드의
확장된 리소스를 요청해야 한다.</p>
<h3 id=확장된-리소스-관리>확장된 리소스 관리</h3>
<h4 id=노드-레벨의-확장된-리소스>노드-레벨의 확장된 리소스</h4>
<p>노드-레벨의 확장된 리소스는 노드에 연결된다.</p>
<h5 id=장치-플러그인-관리-리소스>장치 플러그인 관리 리소스</h5>
<p>각 노드에서
장치 플러그인 관리 리소스를 알리는 방법은
<a href=/ko/docs/concepts/extend-kubernetes/compute-storage-net/device-plugins/>장치 플러그인</a>을 참조한다.</p>
<h5 id=기타-리소스>기타 리소스</h5>
<p>새로운 노드-레벨의 확장된 리소스를 알리기 위해, 클러스터 운영자는
API 서버에 <code>PATCH</code> HTTP 요청을 제출하여 클러스터의
노드에 대해 <code>status.capacity</code> 에서 사용할 수 있는 수량을 지정할 수 있다. 이 작업
후에는, 노드의 <code>status.capacity</code> 에 새로운 리소스가 포함된다. 이
<code>status.allocatable</code> 필드는 kubelet에 의해 비동기적으로 새로운
리소스로 자동 업데이트된다.</p>
<p>스케줄러가 파드 적합성을 평가할 때 노드의 <code>status.allocatable</code> 값을 사용하므로,
스케줄러는 해당 비동기 업데이트 이후의 새로운 값만을 고려한다.
따라서 노드 용량을 새 리소스로 패치하는 시점과
해당 자원을 요청하는 첫 파드가 해당 노드에 스케줄될 수 있는 시점 사이에
약간의 지연이 있을 수 있다.</p>
<p><strong>예제:</strong></p>
<p>다음은 <code>curl</code> 을 사용하여 마스터가 <code>k8s-master</code> 인 노드 <code>k8s-node-1</code> 에
5개의 "example.com/foo" 리소스를 알리는 HTTP 요청을 구성하는 방법을
보여주는 예이다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>curl --header <span style=color:#b44>&#34;Content-Type: application/json-patch+json&#34;</span> <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>--request PATCH <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>--data <span style=color:#b44>&#39;[{&#34;op&#34;: &#34;add&#34;, &#34;path&#34;: &#34;/status/capacity/example.com~1foo&#34;, &#34;value&#34;: &#34;5&#34;}]&#39;</span> <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>http://k8s-master:8080/api/v1/nodes/k8s-node-1/status
</code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> 앞의 요청에서, <code>~1</code> 은 패치 경로에서 문자 <code>/</code> 의
인코딩이다. JSON-Patch의 작업 경로 값은
JSON-Pointer로 해석된다. 더 자세한 내용은,
<a href=https://tools.ietf.org/html/rfc6901#section-3>IETF RFC 6901, 섹션 3</a>을 참조한다.
</div>
<h4 id=클러스터-레벨의-확장된-리소스>클러스터-레벨의 확장된 리소스</h4>
<p>클러스터-레벨의 확장된 리소스는 노드에 연결되지 않는다. 이들은 일반적으로
리소스 소비와 리소스 쿼터를 처리하는 스케줄러 익스텐더(extender)에 의해 관리된다.</p>
<p><a href=/docs/reference/config-api/kube-scheduler-config.v1beta3/>스케줄러 구성</a>에서
스케줄러 익스텐더가 처리하는 확장된 리소스를 지정할 수 있다.</p>
<p><strong>예제:</strong></p>
<p>스케줄러 정책에 대한 다음의 구성은 클러스터-레벨의 확장된 리소스
"example.com/foo"가 스케줄러 익스텐더에 의해 처리됨을
나타낸다.</p>
<ul>
<li>파드가 "example.com/foo"를 요청하는 경우에만 스케줄러가 파드를 스케줄러
익스텐더로 보낸다.</li>
<li>이 <code>ignoredByScheduler</code> 필드는 스케줄러가 <code>PodFitsResources</code> 속성에서
"example.com/foo" 리소스를 확인하지 않도록 지정한다.</li>
</ul>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;Policy&#34;</span>,
  <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;v1&#34;</span>,
  <span style=color:green;font-weight:700>&#34;extenders&#34;</span>: [
    {
      <span style=color:green;font-weight:700>&#34;urlPrefix&#34;</span>:<span style=color:#b44>&#34;&lt;extender-endpoint&gt;&#34;</span>,
      <span style=color:green;font-weight:700>&#34;bindVerb&#34;</span>: <span style=color:#b44>&#34;bind&#34;</span>,
      <span style=color:green;font-weight:700>&#34;managedResources&#34;</span>: [
        {
          <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;example.com/foo&#34;</span>,
          <span style=color:green;font-weight:700>&#34;ignoredByScheduler&#34;</span>: <span style=color:#a2f;font-weight:700>true</span>
        }
      ]
    }
  ]
}
</code></pre></div><h3 id=확장된-리소스-소비>확장된 리소스 소비</h3>
<p>사용자는 CPU와 메모리 같은 파드 스펙의 확장된 리소스를 사용할 수 있다.
스케줄러는 리소스 어카운팅(resource accounting)을 관리하여 사용 가능한 양보다
많은 양의 리소스가 여러 파드에 동시에 할당되지 않도록 한다.</p>
<p>API 서버는 확장된 리소스의 수량을 정수로 제한한다.
<em>유효한</em> 수량의 예로는 <code>3</code>, <code>3000m</code> 그리고 <code>3Ki</code> 를 들 수 있다. <em>유효하지 않은</em>
수량의 예는 <code>0.5</code> 와 <code>1500m</code> 이다.</p>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> 확장된 리소스는 불명확한 정수 리소스를 대체한다.
사용자는 예약된 <code>kubernetes.io</code> 이외의 모든 도메인 이름 접두사를 사용할 수 있다.
</div>
<p>파드에서 확장된 리소스를 사용하려면, 컨테이너 사양에서 <code>spec.containers[].resources.limits</code>
맵에 리소스 이름을 키로 포함한다.</p>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> 확장된 리소스는 오버커밋할 수 없으므로, 컨테이너 사양에
둘 다 있으면 요청과 제한이 동일해야 한다.
</div>
<p>파드는 CPU, 메모리 및 확장된 리소스를 포함하여 모든 리소스 요청이
충족되는 경우에만 예약된다. 리소스 요청을 충족할 수 없다면
파드는 <code>PENDING</code> 상태를 유지한다.</p>
<p><strong>예제:</strong></p>
<p>아래의 파드는 2개의 CPU와 1개의 "example.com/foo"(확장된 리소스)를 요청한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-container<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>myimage<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#666>2</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>example.com/foo</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>example.com/foo</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></code></pre></div><h2 id=pid-제한>PID 제한</h2>
<p>프로세스 ID(PID) 제한은 kubelet의 구성에 대해
주어진 파드가 사용할 수 있는 PID 수를 제한할 수 있도록 허용한다.
자세한 내용은 <a href=/docs/concepts/policy/pid-limiting/>PID 제한</a>을 참고한다.</p>
<h2 id=문제-해결>문제 해결</h2>
<h3 id=내-파드가-failedscheduling-이벤트-메시지로-보류-중이다>내 파드가 <code>FailedScheduling</code> 이벤트 메시지로 보류 중이다</h3>
<p>파드가 배치될 수 있는 노드를 스케줄러가 찾을 수 없으면,
노드를 찾을 수 있을 때까지 파드는 스케줄되지 않은 상태로 유지한다.
파드가 할당될 곳을 스케줄러가 찾지 못하면
<a href=/docs/reference/kubernetes-api/cluster-resources/event-v1/>Event</a>가 생성된다.
다음과 같이 <code>kubectl</code>을 사용하여 파드의 이벤트를 볼 수 있다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe pod frontend | grep -A <span style=color:#666>9999999999</span> Events
</code></pre></div><pre><code>Events:
  Type     Reason            Age   From               Message
  ----     ------            ----  ----               -------
  Warning  FailedScheduling  23s   default-scheduler  0/42 nodes available: insufficient cpu
</code></pre><p>위의 예에서, 모든 노드의 CPU 리소스가 충분하지 않아 이름이
"frontend"인 파드를 스케줄하지 못했다. 비슷한 메시지로
메모리 부족(PodExceedsFreeMemory)으로 인한 장애도 알릴 수 있다. 일반적으로, 파드가
이 타입의 메시지로 보류 중인 경우, 몇 가지 시도해 볼 것들이 있다.</p>
<ul>
<li>클러스터에 더 많은 노드를 추가한다.</li>
<li>불필요한 파드를 종료하여 보류 중인 파드를 위한 공간을 확보한다.</li>
<li>파드가 모든 노드보다 크지 않은지 확인한다. 예를 들어, 모든
노드의 용량이 <code>cpu: 1</code> 인 경우, <code>cpu: 1.1</code> 요청이 있는 파드는
절대 스케줄되지 않는다.</li>
<li>노드 테인트를 확인한다.
대부분의 노드에 테인트가 걸려 있고, 신규 파드가 해당 테인트에 배척된다면,
스케줄러는 해당 테인트가 걸려 있지 않은 나머지 노드에만 배치를 고려할 것이다.</li>
</ul>
<p><code>kubectl describe nodes</code> 명령으로 노드 용량과 할당된 양을
확인할 수 있다. 예를 들면, 다음과 같다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe nodes e2e-test-node-pool-4lw4
</code></pre></div><pre><code>Name:            e2e-test-node-pool-4lw4
[ ... 명확하게 하기 위해 라인들을 제거함 ...]
Capacity:
 cpu:                               2
 memory:                            7679792Ki
 pods:                              110
Allocatable:
 cpu:                               1800m
 memory:                            7474992Ki
 pods:                              110
[ ... 명확하게 하기 위해 라인들을 제거함 ...]
Non-terminated Pods:        (5 in total)
  Namespace    Name                                  CPU Requests  CPU Limits  Memory Requests  Memory Limits
  ---------    ----                                  ------------  ----------  ---------------  -------------
  kube-system  fluentd-gcp-v1.38-28bv1               100m (5%)     0 (0%)      200Mi (2%)       200Mi (2%)
  kube-system  kube-dns-3297075139-61lj3             260m (13%)    0 (0%)      100Mi (1%)       170Mi (2%)
  kube-system  kube-proxy-e2e-test-...               100m (5%)     0 (0%)      0 (0%)           0 (0%)
  kube-system  monitoring-influxdb-grafana-v4-z1m12  200m (10%)    200m (10%)  600Mi (8%)       600Mi (8%)
  kube-system  node-problem-detector-v0.1-fj7m3      20m (1%)      200m (10%)  20Mi (0%)        100Mi (1%)
Allocated resources:
  (Total limits may be over 100 percent, i.e., overcommitted.)
  CPU Requests    CPU Limits    Memory Requests    Memory Limits
  ------------    ----------    ---------------    -------------
  680m (34%)      400m (20%)    920Mi (11%)        1070Mi (13%)
</code></pre><p>위의 출력에서, 1.120 이상의 CPU 또는 6.23 Gi 이상의 메모리를 요청하는 파드는
노드에 할당될 수 없음을 확인할 수 있다.</p>
<p>"Pods" 섹션을 살펴보면, 어떤 파드가 노드에서 공간을 차지하고 있는지를
볼 수 있다.</p>
<p>사용 가능한 리소스의 일부를 시스템 데몬이 사용하기 때문에,
파드에 사용 가능한 리소스의 양은 노드 총 용량보다 적다.
쿠버네티스 API에서, 각 노드는 <code>.status.allocatable</code> 필드(상세 사항은
<a href=/docs/reference/kubernetes-api/cluster-resources/node-v1/#NodeStatus>NodeStatus</a> 참조)를
갖는다.</p>
<p><code>.status.allocatable</code> 필드는 해당 노드에서 파드가 사용할 수 있는
리소스의 양을 표시한다(예: 15 vCPUs 및 7538 MiB 메모리).
쿠버네티스의 노드 할당 가능 리소스에 대한 상세 사항은
<a href=/docs/tasks/administer-cluster/reserve-compute-resources/>시스템 데몬을 위한 컴퓨트 자원 예약하기</a>를 참고한다.</p>
<p><a href=/ko/docs/concepts/policy/resource-quotas/>리소스 쿼터</a>를 설정하여,
한 네임스페이스가 사용할 수 있는 리소스 총량을 제한할 수 있다.
특정 네임스페이스 내에 ResourceQuota가 설정되어 있으면
쿠버네티스는 오브젝트에 대해 해당 쿼터를 적용한다.
예를 들어, 각 팀에 네임스페이스를 할당한다면, 각 네임스페이스에 ResourceQuota를 설정할 수 있다.
리소스 쿼터를 설정함으로써 한 팀이 지나치게 많은 리소스를 사용하여
다른 팀에 영향을 주는 것을 막을 수 있다.</p>
<p>해당 네임스페이스에 어떤 접근을 허용할지도 고려해야 한다.
네임스페이스에 대한 <strong>완전한</strong> 쓰기 권한을 가진 사람은
어떠한 리소스(네임스페이스에 설정된 ResourceQuota 포함)라도 삭제할 수 있다.</p>
<h3 id=내-컨테이너가-종료되었다>내 컨테이너가 종료되었다</h3>
<p>리소스가 부족하여 컨테이너가 종료될 수 있다. 리소스
제한에 도달하여 컨테이너가 종료되고 있는지 확인하려면,
관심있는 파드에 대해 <code>kubectl describe pod</code> 를 호출한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe pod simmemleak-hra99
</code></pre></div><p>출력은 다음과 같다.</p>
<pre><code>Name:                           simmemleak-hra99
Namespace:                      default
Image(s):                       saadali/simmemleak
Node:                           kubernetes-node-tf0f/10.240.216.66
Labels:                         name=simmemleak
Status:                         Running
Reason:
Message:
IP:                             10.244.2.75
Containers:
  simmemleak:
    Image:  saadali/simmemleak:latest
    Limits:
      cpu:          100m
      memory:       50Mi
    State:          Running
      Started:      Tue, 07 Jul 2019 12:54:41 -0700
    Last State:     Terminated
      Reason:       OOMKilled
      Exit Code:    137
      Started:      Fri, 07 Jul 2019 12:54:30 -0700
      Finished:     Fri, 07 Jul 2019 12:54:33 -0700
    Ready:          False
    Restart Count:  5
Conditions:
  Type      Status
  Ready     False
Events:
  Type    Reason     Age   From               Message
  ----    ------     ----  ----               -------
  Normal  Scheduled  42s   default-scheduler  Successfully assigned simmemleak-hra99 to kubernetes-node-tf0f
  Normal  Pulled     41s   kubelet            Container image &quot;saadali/simmemleak:latest&quot; already present on machine
  Normal  Created    41s   kubelet            Created container simmemleak
  Normal  Started    40s   kubelet            Started container simmemleak
  Normal  Killing    32s   kubelet            Killing container with id ead3fb35-5cf5-44ed-9ae1-488115be66c6: Need to kill Pod
</code></pre><p>앞의 예제에서, <code>Restart Count: 5</code> 표시는 파드의 <code>simmemleak</code>
컨테이너가 종료되고 (지금까지) 5번 다시 시작되었음을 나타낸다.
<code>Reason: OOMKilled</code>를 통해 컨테이너가 제한보다 많은 양의 메모리를 사용하려고 했다는 것을 확인할 수 있다.</p>
<p>다음 단계로 메모리 누수가 있는지 애플리케이션 코드를 확인해 볼 수 있다.
애플리케이션이 예상한 대로 동작하는 것을 확인했다면,
해당 컨테이너의 메모리 제한(및 요청)을 더 높게 설정해 본다.</p>
<h2 id=다음-내용>다음 내용</h2>
<ul>
<li><a href=/ko/docs/tasks/configure-pod-container/assign-memory-resource/>컨테이너와 파드에 메모리 리소스를 할당</a>하는 핸즈온 경험을 해보자.</li>
<li><a href=/docs/tasks/configure-pod-container/assign-cpu-resource/>컨테이너와 파드에 CPU 리소스를 할당</a>하는 핸즈온 경험을 해보자.</li>
<li>API 레퍼런스에 <a href=/docs/reference/kubernetes-api/workload-resources/pod-v1/#Container>컨테이너</a>와
<a href=/docs/reference/kubernetes-api/workload-resources/pod-v1/#resources>컨테이너 리소스 요구사항</a>이 어떻게 정의되어 있는지 확인한다.</li>
<li>XFS의 <a href=https://xfs.org/docs/xfsdocs-xml-dev/XFS_User_Guide/tmp/en-US/html/xfs-quotas.html>프로젝트 쿼터</a>에 대해 읽어보기</li>
<li><a href=/docs/reference/config-api/kube-scheduler-config.v1beta3/>kube-scheduler 정책 레퍼런스 (v1beta3)</a>에 대해 더 읽어보기</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-ab6d20f33ad930a67ee7ef57bff6c75e>7.5 - kubeconfig 파일을 사용하여 클러스터 접근 구성하기</h1>
<p>kubeconfig 파일들을 사용하여 클러스터, 사용자, 네임스페이스 및 인증 메커니즘에 대한 정보를 관리하자.
<code>kubectl</code> 커맨드라인 툴은 kubeconfig 파일을 사용하여
클러스터의 선택과
클러스터의 API 서버와의 통신에 필요한 정보를 찾는다.</p>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> 클러스터에 대한 접근을 구성하는 데 사용되는 파일을 <em>kubeconfig 파일</em> 이라 한다.
이는 구성 파일을 참조하는 일반적인 방법을 의미한다.
<code>kubeconfig</code>라는 이름의 파일이 있다는 의미는 아니다.
</div>
<div class="alert alert-danger warning callout" role=alert>
<strong>경고:</strong> 신뢰할 수 있는 소스의 kubeconfig 파일만 사용한다. 특수 제작된 kubeconfig 파일을 사용하면 악성 코드가 실행되거나 파일이 노출될 수 있다.
신뢰할 수 없는 kubeconfig 파일을 사용해야 하는 경우 셸 스크립트를 사용하는 경우처럼 먼저 신중하게 검사한다.
</div>
<p>기본적으로 <code>kubectl</code>은 <code>$HOME/.kube</code> 디렉터리에서 <code>config</code>라는 이름의 파일을 찾는다.
<code>KUBECONFIG</code> 환경 변수를 설정하거나
<a href=/docs/reference/generated/kubectl/kubectl/><code>--kubeconfig</code></a> 플래그를 지정해서
다른 kubeconfig 파일을 사용할 수 있다.</p>
<p>kubeconfig 파일을 생성하고 지정하는 단계별 지시사항은
<a href=/ko/docs/tasks/access-application-cluster/configure-access-multiple-clusters/>다중 클러스터로 접근 구성하기</a>를 참조한다.</p>
<h2 id=다중-클러스터-사용자와-인증-메커니즘-지원>다중 클러스터, 사용자와 인증 메커니즘 지원</h2>
<p>여러 클러스터가 있고, 사용자와 구성 요소가 다양한 방식으로 인증한다고 가정하자.
예를 들면 다음과 같다.</p>
<ul>
<li>실행 중인 kubelet은 인증서를 이용하여 인증할 수 있다.</li>
<li>사용자는 토큰으로 인증할 수 있다.</li>
<li>관리자는 개별 사용자에게 제공하는 인증서 집합을 가지고 있다.</li>
</ul>
<p>kubeconfig 파일을 사용하면 클러스터와 사용자와 네임스페이스를 구성할 수 있다.
또한 컨텍스트를 정의하여
빠르고 쉽게 클러스터와 네임스페이스 간에 전환할 수 있다.</p>
<h2 id=컨텍스트>컨텍스트</h2>
<p>kubeconfig에서 <em>컨텍스트</em> 요소는 편리한 이름으로 접속 매개 변수를 묶는데 사용한다.
각 컨텍스트는 클러스터, 네임스페이스와 사용자라는 세 가지 매개 변수를 가진다.
기본적으로 <code>kubectl</code> 커맨드라인 툴은 <em>현재 컨텍스트</em> 의 매개 변수를
사용하여 클러스터와 통신한다.</p>
<p>현재 컨택스트를 선택하려면 다음을 실행한다.</p>
<pre><code>kubectl config use-context
</code></pre><h2 id=kubeconfig-환경-변수>KUBECONFIG 환경 변수</h2>
<p><code>KUBECONFIG</code> 환경 변수는 kubeconfig 파일 목록을 보유한다.
리눅스 및 Mac의 경우 이는 콜론(:)으로 구분된 목록이다.
윈도우는 세미콜론(;)으로 구분한다. <code>KUBECONFIG</code> 환경 변수가 필수는 아니다.
<code>KUBECONFIG</code> 환경 변수가 없으면,
<code>kubectl</code>은 기본 kubeconfig 파일인 <code>$HOME/.kube/config</code>를 사용한다.</p>
<p><code>KUBECONFIG</code> 환경 변수가 존재하면, <code>kubectl</code>은
<code>KUBECONFIG</code> 환경 변수에 나열된 파일을 병합한 결과 형태의
효과적 구성을 이용한다.</p>
<h2 id=kubeconfig-파일-병합>kubeconfig 파일 병합</h2>
<p>구성을 보려면, 다음 커맨드를 입력한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl config view
</code></pre></div><p>앞서 설명한 것처럼, 이 출력 내용은 단일 kubeconfig 파일이나
여러 kubeconfig 파일을 병합한 결과 일 수 있다.</p>
<p>다음은 kubeconfig 파일을 병합할 때에 <code>kubectl</code>에서 사용하는 규칙이다.</p>
<ol>
<li>
<p><code>--kubeconfig</code> 플래그를 설정했으면, 지정한 파일만 사용한다. 병합하지 않는다.
이 플래그는 오직 한 개 인스턴스만 허용한다.</p>
<p>그렇지 않고, <code>KUBECONFIG</code> 환경 변수를 설정하였다면
병합해야 하는 파일의 목록으로 사용한다.
<code>KUBECONFIG</code> 환경 변수의 나열된 파일은
다음 규칙에 따라 병합한다.</p>
<ul>
<li>빈 파일명은 무시한다.</li>
<li>역 직렬화 불가한 파일 내용에 대해서 오류를 일으킨다.</li>
<li>특정 값이나 맵 키를 설정한 첫 번째 파일을 우선한다.</li>
<li>값이나 맵 키를 변경하지 않는다.
예: <code>현재 컨텍스트</code>를 설정할 첫 번째 파일의 컨택스트를 유지한다.
예: 두 파일이 <code>red-user</code>를 지정했다면, 첫 번째 파일의 <code>red-user</code> 값만을 사용한다.
두 번째 파일의 <code>red-user</code> 하위에 충돌하지 않는 항목이 있어도 버린다.</li>
</ul>
<p><code>KUBECONFIG</code> 환경 변수 설정의 예로,
<a href=/ko/docs/tasks/access-application-cluster/configure-access-multiple-clusters/#kubeconfig-%ED%99%98%EA%B2%BD-%EB%B3%80%EC%88%98-%EC%84%A4%EC%A0%95>KUBECONFIG 환경 변수 설정</a>를 참조한다.</p>
<p>그렇지 않다면, 병합하지 않고 기본 kubeconfig 파일인 <code>$HOME/.kube/config</code>를 사용한다.</p>
</li>
<li>
<p>이 체인에서 첫 번째를 기반으로 사용할 컨텍스트를 결정한다.</p>
<ol>
<li>커맨드라인 플래그의 <code>--context</code>를 사용한다.</li>
<li>병합된 kubeconfig 파일에서 <code>current-context</code>를 사용한다.</li>
</ol>
<p>이 시점에서는 빈 컨텍스트도 허용한다.</p>
</li>
<li>
<p>클러스터와 사용자를 결정한다. 이 시점에서는 컨텍스트가 있을 수도 있고 없을 수도 있다.
사용자에 대해 한 번, 클러스터에 대해 한 번 총 두 번에 걸친
이 체인에서 첫 번째 것을 기반으로 클러스터와 사용자를 결정한다.</p>
<ol>
<li>커맨드라인 플래그가 존재하면, <code>--user</code> 또는 <code>--cluster</code>를 사용한다.</li>
<li>컨텍스트가 비어있지 않다면, 컨텍스트에서 사용자 또는 클러스터를 가져온다.</li>
</ol>
<p>이 시점에서는 사용자와 클러스터는 비워둘 수 있다.</p>
</li>
<li>
<p>사용할 실제 클러스터 정보를 결정한다.
이 시점에서 클러스터 정보가 있을 수 있고 없을 수도 있다.
이 체인을 기반으로 클러스터 정보를 구축한다. 첫 번째 것을 사용한다.</p>
<ol>
<li>커맨드라인 플래그가 존재하면, <code>--server</code>, <code>--certificate-authority</code>, <code>--insecure-skip-tls-verify</code>를 사용한다.</li>
<li>병합된 kubeconfig 파일에서 클러스터 정보 속성이 있다면 사용한다.</li>
<li>서버 위치가 없다면 실패한다.</li>
</ol>
</li>
<li>
<p>사용할 실제 사용자 정보를 결정한다.
사용자 당 하나의 인증 기법만 허용하는 것을 제외하고는
클러스터 정보와 동일한 규칙을 사용하여 사용자 정보를 작성한다.</p>
<ol>
<li>커맨드라인 플래그가 존재하면, <code>--client-certificate</code>, <code>--client-key</code>, <code>--username</code>, <code>--password</code>, <code>--token</code>을 사용한다.</li>
<li>병합된 kubeconfig 파일에서 <code>user</code> 필드를 사용한다.</li>
<li>충돌하는 두 가지 기법이 있다면 실패한다.</li>
</ol>
</li>
<li>
<p>여전히 누락된 정보는 기본 값을 사용하고
인증 정보를 묻는 메시지가 표시될 수 있다.</p>
</li>
</ol>
<h2 id=파일-참조>파일 참조</h2>
<p>kubeconfig 파일에서 파일과 경로 참조는 kubeconfig 파일의 위치와 관련 있다.
커맨드라인 상에 파일 참조는 현재 디렉터리를 기준으로 한다.
<code>$HOME/.kube/config</code>에서 상대 경로는 상대적으로, 절대 경로는
절대적으로 저장한다.</p>
<h2 id=다음-내용>다음 내용</h2>
<ul>
<li><a href=/ko/docs/tasks/access-application-cluster/configure-access-multiple-clusters/>다중 클러스터 접근 구성하기</a></li>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands#config><code>kubectl config</code></a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-712cb3c03ff14a39e5a83a6d9b71d203>8 - 보안</h1>
<div class=lead>클라우드 네이티브 워크로드를 안전하게 유지하기 위한 개념</div>
</div>
<div class=td-content>
<h1 id=pg-04eeb110d75afc8acb2cf7a3db743985>8.1 - 클라우드 네이티브 보안 개요</h1>
<div class=lead>클라우드 네이티브 보안 관점에서 쿠버네티스 보안을 생각해보기 위한 모델</div>
<p>이 개요는 클라우드 네이티브 보안의 맥락에서 쿠버네티스 보안에 대한 생각의 모델을 정의한다.</p>
<div class="alert alert-danger warning callout" role=alert>
<strong>경고:</strong> 이 컨테이너 보안 모델은 입증된 정보 보안 정책이 아닌 제안 사항을 제공한다.
</div>
<h2 id=클라우드-네이티브-보안의-4c>클라우드 네이티브 보안의 4C</h2>
<p>보안은 계층으로 생각할 수 있다. 클라우드 네이티브 보안의 4C는 클라우드(Cloud),
클러스터(Cluster), 컨테이너(Container)와 코드(Code)이다.</p>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> 이 계층화된 접근 방식은 보안에 대한 <a href=https://en.wikipedia.org/wiki/Defense_in_depth_(computing)>심층 방어</a>
컴퓨팅 접근 방식을 강화하며, 소프트웨어 시스템의 보안을 위한 모범 사례로
널리 알려져 있다.
</div>
<figure class=diagram-large>
<img src=/images/docs/4c.png> <figcaption>
<h4>클라우드 네이티브 보안의 4C</h4>
</figcaption>
</figure>
<p>클라우드 네이티브 보안 모델의 각 계층은 다음의 가장 바깥쪽 계층을 기반으로 한다.
코드 계층은 강력한 기본(클라우드, 클러스터, 컨테이너) 보안 계층의 이점을 제공한다.
코드 수준에서 보안을 처리하여 기본 계층의 열악한 보안 표준을
보호할 수 없다.</p>
<h2 id=클라우드>클라우드</h2>
<p>여러 면에서 클라우드(또는 공동 위치 서버, 또는 기업의 데이터 센터)는 쿠버네티스 클러스터 구성을 위한
<a href=https://en.wikipedia.org/wiki/Trusted_computing_base>신뢰 컴퓨팅 기반(trusted computing base)</a>
이다. 클라우드 계층이 취약하거나 취약한 방식으로
구성된 경우 이 기반 위에서 구축된 구성 요소가 안전하다는
보장은 없다. 각 클라우드 공급자는 해당 환경에서 워크로드를 안전하게 실행하기
위한 보안 권장 사항을 제시한다.</p>
<h3 id=클라우드-공급자-보안>클라우드 공급자 보안</h3>
<p>자신의 하드웨어 또는 다른 클라우드 공급자에서 쿠버네티스 클러스터를 실행 중인 경우,
보안 모범 사례는 설명서를 참고한다.
다음은 인기있는 클라우드 공급자의 보안 문서 중 일부에 대한 링크이다.</p>
<table><caption style=display:none>클라우드 공급자 보안</caption>
<thead>
<tr>
<th>IaaS 공급자</th>
<th>링크</th>
</tr>
</thead>
<tbody>
<tr>
<td>Alibaba Cloud</td>
<td><a href=https://www.alibabacloud.com/trust-center>https://www.alibabacloud.com/trust-center</a></td>
</tr>
<tr>
<td>Amazon Web Services</td>
<td><a href=https://aws.amazon.com/security/>https://aws.amazon.com/security/</a></td>
</tr>
<tr>
<td>Google Cloud Platform</td>
<td><a href=https://cloud.google.com/security/>https://cloud.google.com/security/</a></td>
</tr>
<tr>
<td>IBM Cloud</td>
<td><a href=https://www.ibm.com/cloud/security>https://www.ibm.com/cloud/security</a></td>
</tr>
<tr>
<td>Microsoft Azure</td>
<td><a href=https://docs.microsoft.com/en-us/azure/security/azure-security>https://docs.microsoft.com/en-us/azure/security/azure-security</a></td>
</tr>
<tr>
<td>Oracle Cloud Infrastructure</td>
<td><a href=https://www.oracle.com/security/>https://www.oracle.com/security/</a></td>
</tr>
<tr>
<td>VMWare VSphere</td>
<td><a href=https://www.vmware.com/security/hardening-guides.html>https://www.vmware.com/security/hardening-guides.html</a></td>
</tr>
</tbody>
</table>
<h3 id=infrastructure-security>인프라스트럭처 보안</h3>
<p>쿠버네티스 클러스터에서 인프라 보안을 위한 제안은 다음과 같다.</p>
<table><caption style=display:none>인프라스트럭처 보안</caption>
<thead>
<tr>
<th>쿠버네티스 인프라에서 고려할 영역</th>
<th>추천</th>
</tr>
</thead>
<tbody>
<tr>
<td>API 서버에 대한 네트워크 접근(컨트롤 플레인)</td>
<td>쿠버네티스 컨트롤 플레인에 대한 모든 접근은 인터넷에서 공개적으로 허용되지 않으며 클러스터 관리에 필요한 IP 주소 집합으로 제한된 네트워크 접근 제어 목록에 의해 제어된다.</td>
</tr>
<tr>
<td>노드에 대한 네트워크 접근(노드)</td>
<td>지정된 포트의 컨트롤 플레인에서 <em>만</em> (네트워크 접근 제어 목록을 통한) 연결을 허용하고 NodePort와 LoadBalancer 유형의 쿠버네티스 서비스에 대한 연결을 허용하도록 노드를 구성해야 한다. 가능하면 이러한 노드가 공용 인터넷에 완전히 노출되어서는 안된다.</td>
</tr>
<tr>
<td>클라우드 공급자 API에 대한 쿠버네티스 접근</td>
<td>각 클라우드 공급자는 쿠버네티스 컨트롤 플레인 및 노드에 서로 다른 권한 집합을 부여해야 한다. 관리해야하는 리소스에 대해 <a href=https://en.wikipedia.org/wiki/Principle_of_least_privilege>최소 권한의 원칙</a>을 따르는 클라우드 공급자의 접근 권한을 클러스터에 구성하는 것이 가장 좋다. <a href=https://github.com/kubernetes/kops/blob/master/docs/iam_roles.md#iam-roles>Kops 설명서</a>는 IAM 정책 및 역할에 대한 정보를 제공한다.</td>
</tr>
<tr>
<td>etcd에 대한 접근</td>
<td>etcd(쿠버네티스의 데이터 저장소)에 대한 접근은 컨트롤 플레인으로만 제한되어야 한다. 구성에 따라 TLS를 통해 etcd를 사용해야 한다. 자세한 내용은 <a href=https://github.com/etcd-io/etcd/tree/master/Documentation>etcd 문서</a>에서 확인할 수 있다.</td>
</tr>
<tr>
<td>etcd 암호화</td>
<td>가능한 한 모든 스토리지를 암호화하는 것이 좋은 방법이며, etcd는 전체 클러스터(시크릿 포함)의 상태를 유지하고 있기에 특히 디스크는 암호화되어 있어야 한다.</td>
</tr>
</tbody>
</table>
<h2 id=클러스터>클러스터</h2>
<p>쿠버네티스 보안에는 다음의 두 가지 영역이 있다.</p>
<ul>
<li>설정 가능한 클러스터 컴포넌트의 보안</li>
<li>클러스터에서 실행되는 애플리케이션의 보안</li>
</ul>
<h3 id=cluster-components>클러스터의 컴포넌트</h3>
<p>우발적이거나 악의적인 접근으로부터 클러스터를 보호하고,
모범 사례에 대한 정보를 채택하기 위해서는
<a href=/docs/tasks/administer-cluster/securing-a-cluster/>클러스터 보안</a>에 대한 조언을 읽고 따른다.</p>
<h3 id=cluster-applications>클러스터 내 컴포넌트(애플리케이션)</h3>
<p>애플리케이션의 공격 영역에 따라, 보안의 특정 측면에
중점을 둘 수 있다. 예를 들어, 다른 리소스 체인에 중요한 서비스(서비스 A)와
리소스 소진 공격에 취약한 별도의 작업 부하(서비스 B)를 실행하는 경우,
서비스 B의 리소스를 제한하지 않으면
서비스 A가 손상될 위험이 높다. 다음은 쿠버네티스에서
실행되는 워크로드를 보호하기 위한 보안 문제 및 권장 사항이 나와 있는 표이다.</p>
<table>
<thead>
<tr>
<th>워크로드 보안에서 고려할 영역</th>
<th>추천</th>
</tr>
</thead>
<tbody>
<tr>
<td>RBAC 인증(쿠버네티스 API에 대한 접근)</td>
<td><a href=https://kubernetes.io/docs/reference/access-authn-authz/rbac/>https://kubernetes.io/docs/reference/access-authn-authz/rbac/</a></td>
</tr>
<tr>
<td>인증</td>
<td><a href=https://kubernetes.io/ko/docs/concepts/security/controlling-access/>https://kubernetes.io/ko/docs/concepts/security/controlling-access/</a></td>
</tr>
<tr>
<td>애플리케이션 시크릿 관리(및 유휴 상태에서의 etcd 암호화 등)</td>
<td><a href=https://kubernetes.io/ko/docs/concepts/configuration/secret/>https://kubernetes.io/ko/docs/concepts/configuration/secret/</a> <br> <a href=https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/>https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/</a></td>
</tr>
<tr>
<td>파드가 파드 시큐리티 폴리시를 만족하는지 확인하기</td>
<td><a href=https://kubernetes.io/docs/concepts/security/pod-security-standards/#policy-instantiation>https://kubernetes.io/docs/concepts/security/pod-security-standards/#policy-instantiation</a></td>
</tr>
<tr>
<td>서비스 품질(및 클러스터 리소스 관리)</td>
<td><a href=https://kubernetes.io/ko/docs/tasks/configure-pod-container/quality-service-pod/>https://kubernetes.io/ko/docs/tasks/configure-pod-container/quality-service-pod/</a></td>
</tr>
<tr>
<td>네트워크 정책</td>
<td><a href=https://kubernetes.io/ko/docs/concepts/services-networking/network-policies/>https://kubernetes.io/ko/docs/concepts/services-networking/network-policies/</a></td>
</tr>
<tr>
<td>쿠버네티스 인그레스를 위한 TLS</td>
<td><a href=https://kubernetes.io/ko/docs/concepts/services-networking/ingress/#tls>https://kubernetes.io/ko/docs/concepts/services-networking/ingress/#tls</a></td>
</tr>
</tbody>
</table>
<h2 id=컨테이너>컨테이너</h2>
<p>컨테이너 보안은 이 가이드의 범위를 벗어난다. 다음은 일반적인 권장사항과
이 주제에 대한 링크이다.</p>
<table>
<thead>
<tr>
<th>컨테이너에서 고려할 영역</th>
<th>추천</th>
</tr>
</thead>
<tbody>
<tr>
<td>컨테이너 취약점 스캔 및 OS에 종속적인 보안</td>
<td>이미지 빌드 단계의 일부로 컨테이너에 알려진 취약점이 있는지 검사해야 한다.</td>
</tr>
<tr>
<td>이미지 서명 및 시행</td>
<td>컨테이너 이미지에 서명하여 컨테이너의 내용에 대한 신뢰 시스템을 유지한다.</td>
</tr>
<tr>
<td>권한있는 사용자의 비허용</td>
<td>컨테이너를 구성할 때 컨테이너의 목적을 수행하는데 필요한 최소 권한을 가진 사용자를 컨테이너 내에 만드는 방법에 대해서는 설명서를 참조한다.</td>
</tr>
<tr>
<td>더 강력한 격리로 컨테이너 런타임 사용</td>
<td>더 강력한 격리를 제공하는 <a href=/ko/docs/concepts/containers/runtime-class/>컨테이너 런타임 클래스</a>를 선택한다.</td>
</tr>
</tbody>
</table>
<h2 id=코드>코드</h2>
<p>애플리케이션 코드는 가장 많은 제어를 할 수 있는 주요 공격 영역 중 하나이다.
애플리케이션 코드 보안은 쿠버네티스 보안 주제를 벗어나지만,
애플리케이션 코드를 보호하기 위한 권장 사항은 다음과 같다.</p>
<h3 id=코드-보안>코드 보안</h3>
<table><caption style=display:none>코드 보안</caption>
<thead>
<tr>
<th>코드에서 고려할 영역</th>
<th>추천</th>
</tr>
</thead>
<tbody>
<tr>
<td>TLS를 통한 접근</td>
<td>코드가 TCP를 통해 통신해야 한다면, 미리 클라이언트와 TLS 핸드 셰이크를 수행한다. 몇 가지 경우를 제외하고, 전송 중인 모든 것을 암호화한다. 한 걸음 더 나아가, 서비스 간 네트워크 트래픽을 암호화하는 것이 좋다. 이것은 인증서를 가지고 있는 두 서비스의 양방향 검증을 실행하는 <a href=https://en.wikipedia.org/wiki/Mutual_authentication>mTLS(상호 TLS 인증)</a>를 통해 수행할 수 있다.</td>
</tr>
<tr>
<td>통신 포트 범위 제한</td>
<td>이 권장사항은 당연할 수도 있지만, 가능하면 통신이나 메트릭 수집에 꼭 필요한 서비스의 포트만 노출시켜야 한다.</td>
</tr>
<tr>
<td>타사 종속성 보안</td>
<td>애플리케이션의 타사 라이브러리를 정기적으로 스캔하여 현재 알려진 취약점이 없는지 확인하는 것이 좋다. 각 언어에는 이런 검사를 자동으로 수행하는 도구를 가지고 있다.</td>
</tr>
<tr>
<td>정적 코드 분석</td>
<td>대부분 언어에는 잠재적으로 안전하지 않은 코딩 방법에 대해 코드 스니펫을 분석할 수 있는 방법을 제공한다. 가능한 언제든지 일반적인 보안 오류에 대해 코드베이스를 스캔할 수 있는 자동화된 도구를 사용하여 검사를 한다. 도구는 다음에서 찾을 수 있다. <a href=https://owasp.org/www-community/Source_Code_Analysis_Tools>https://owasp.org/www-community/Source_Code_Analysis_Tools</a></td>
</tr>
<tr>
<td>동적 탐지 공격</td>
<td>잘 알려진 공격 중 일부를 서비스에 테스트할 수 있는 자동화된 몇 가지 도구가 있다. 여기에는 SQL 인젝션, CSRF 및 XSS가 포함된다. 가장 널리 사용되는 동적 분석 도구는 <a href=https://owasp.org/www-project-zap/>OWASP Zed Attack 프록시</a>이다.</td>
</tr>
</tbody>
</table>
<h2 id=다음-내용>다음 내용</h2>
<p>쿠버네티스 보안 주제에 관련한 내용들을 배워보자.</p>
<ul>
<li><a href=/docs/concepts/security/pod-security-standards/>파드 보안 표준</a></li>
<li><a href=/ko/docs/concepts/services-networking/network-policies/>파드에 대한 네트워크 정책</a></li>
<li><a href=/ko/docs/concepts/security/controlling-access>쿠버네티스 API 접근 제어하기</a></li>
<li><a href=/docs/tasks/administer-cluster/securing-a-cluster/>클러스터 보안</a></li>
<li>컨트롤 플레인을 위한 <a href=/ko/docs/tasks/tls/managing-tls-in-a-cluster/>전송 데이터 암호화</a></li>
<li><a href=/docs/tasks/administer-cluster/encrypt-data/>Rest에서 데이터 암호화</a></li>
<li><a href=/ko/docs/concepts/configuration/secret/>쿠버네티스 시크릿</a></li>
<li><a href=/ko/docs/concepts/containers/runtime-class>런타임 클래스</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-4d77d1ae4c06aa14f54b385191627881>8.2 - 쿠버네티스 API 접근 제어하기</h1>
<p>이 페이지는 쿠버네티스 API에 대한 접근 제어의 개요를 제공한다.</p>
<p>사용자는 <code>kubectl</code>, 클라이언트 라이브러리
또는 REST 요청을 통해
<a href=/ko/docs/tasks/access-application-cluster/access-cluster/>API에 접근한다</a>.
사용자와 쿠버네티스 서비스 어카운트 모두 API에 접근할 수 있다.
요청이 API에 도달하면,
다음 다이어그램에 설명된 몇 가지 단계를 거친다.</p>
<p><img src=/images/docs/admin/access-control-overview.svg alt="Diagram of request handling steps for Kubernetes API request"></p>
<h2 id=전송-보안>전송 보안</h2>
<p>일반적인 쿠버네티스 클러스터에서 API는 443번 포트에서 서비스한다.
API 서버는 인증서를 제시한다.
이 인증서는 종종 자체 서명되기 때문에 일반적으로 사용자 머신의 <code>$USER/.kube/config</code>는
API 서버의 인증서에 대한 루트 인증서를 포함하며,
시스템 기본 루트 인증서 대신 사용된다.
<code>kube-up.sh</code>을 사용하여 클러스터를 직접 생성할 때
이 인증서는 일반적으로 <code>$USER/.kube/config</code>에 자동으로 기록된다.
클러스터에 여러 명의 사용자가 있는 경우, 작성자는 인증서를 다른 사용자와 공유해야 한다.</p>
<h2 id=인증>인증</h2>
<p>TLS가 설정되면 HTTP 요청이 인증 단계로 넘어간다.
이는 다이어그램에 <strong>1</strong>단계로 표시되어 있다.
클러스터 생성 스크립트 또는 클러스터 관리자는
API 서버가 하나 이상의 인증기 모듈을 실행하도록 구성한다.
인증기는 <a href=/docs/reference/access-authn-authz/authentication/>여기</a>에서 더 자세히 서술한다.</p>
<p>인증 단계로 들어가는 것은 온전한 HTTP 요청이지만
일반적으로 헤더 그리고/또는 클라이언트 인증서를 검사한다.</p>
<p>인증 모듈은 클라이언트 인증서, 암호 및 일반 토큰, 부트스트랩 토큰,
JWT 토큰(서비스 어카운트에 사용됨)을 포함한다.</p>
<p>여러 개의 인증 모듈을 지정할 수 있으며,
이 경우 하나의 인증 모듈이 성공할 때까지 각 모듈을 순차적으로 시도한다.</p>
<p>GCE에서는 클라이언트 인증서, 암호, 일반 토큰 및 JWT 토큰이 모두 사용 가능하다.</p>
<p>요청을 인증할 수 없는 경우 HTTP 상태 코드 401과 함께 거부된다.
이 외에는 사용자가 특정 <code>username</code>으로 인증되며,
이 username은 다음 단계에서 사용자의 결정에 사용할 수 있다.
일부 인증기는 사용자 그룹 관리 기능을 제공하는 반면,
이외의 인증기는 그렇지 않다.</p>
<p>쿠버네티스는 접근 제어 결정과 요청 기록 시 <code>usernames</code>를 사용하지만,
<code>user</code> 오브젝트를 가지고 있지 않고 usernames 나 기타 사용자 정보를
오브젝트 저장소에 저장하지도 않는다.</p>
<h2 id=인가>인가</h2>
<p>특정 사용자로부터 온 요청이 인증된 후에는 인가되어야 한다. 이는 다이어그램에 <strong>2</strong>단계로 표시되어 있다.</p>
<p>요청은 요청자의 username, 요청된 작업 및 해당 작업이 영향을 주는 오브젝트를 포함해야 한다. 기존 정책이 요청된 작업을 완료할 수 있는 권한이 해당 사용자에게 있다고 선언하는 경우 요청이 인가된다.</p>
<p>예를 들어 Bob이 아래와 같은 정책을 가지고 있다면 <code>projectCaribou</code> 네임스페이스에서만 파드를 읽을 수 있다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
    <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;abac.authorization.kubernetes.io/v1beta1&#34;</span>,
    <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;Policy&#34;</span>,
    <span style=color:green;font-weight:700>&#34;spec&#34;</span>: {
        <span style=color:green;font-weight:700>&#34;user&#34;</span>: <span style=color:#b44>&#34;bob&#34;</span>,
        <span style=color:green;font-weight:700>&#34;namespace&#34;</span>: <span style=color:#b44>&#34;projectCaribou&#34;</span>,
        <span style=color:green;font-weight:700>&#34;resource&#34;</span>: <span style=color:#b44>&#34;pods&#34;</span>,
        <span style=color:green;font-weight:700>&#34;readonly&#34;</span>: <span style=color:#a2f;font-weight:700>true</span>
    }
}
</code></pre></div><p>Bob이 다음과 같은 요청을 하면 'projectCaribou' 네임스페이스의 오브젝트를 읽을 수 있기 때문에 요청이 인가된다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
  <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;authorization.k8s.io/v1beta1&#34;</span>,
  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;SubjectAccessReview&#34;</span>,
  <span style=color:green;font-weight:700>&#34;spec&#34;</span>: {
    <span style=color:green;font-weight:700>&#34;resourceAttributes&#34;</span>: {
      <span style=color:green;font-weight:700>&#34;namespace&#34;</span>: <span style=color:#b44>&#34;projectCaribou&#34;</span>,
      <span style=color:green;font-weight:700>&#34;verb&#34;</span>: <span style=color:#b44>&#34;get&#34;</span>,
      <span style=color:green;font-weight:700>&#34;group&#34;</span>: <span style=color:#b44>&#34;unicorn.example.org&#34;</span>,
      <span style=color:green;font-weight:700>&#34;resource&#34;</span>: <span style=color:#b44>&#34;pods&#34;</span>
    }
  }
}
</code></pre></div><p>Bob이 <code>projectCaribou</code> 네임스페이스에 있는 오브젝트에 쓰기(<code>create</code> 또는 <code>update</code>) 요청을 하면 그의 인가는 거부된다. 만약 Bob이 <code>projectFish</code>처럼 다른 네임스페이스의 오브젝트 읽기(<code>get</code>) 요청을 하면 그의 인가는 거부된다.</p>
<p>쿠버네티스 인가는 공통 REST 속성을 사용하여 기존 조직 전체 또는 클라우드 제공자 전체의 접근 제어 시스템과 상호 작용할 것을 요구한다. 이러한 제어 시스템은 쿠버네티스 API 이외의 다른 API와 상호작용할 수 있으므로 REST 형식을 사용하는 것이 중요하다.</p>
<p>쿠버네티스는 ABAC 모드, RBAC 모드, 웹훅 모드와 같은 여러 개의 인가 모듈을 지원한다. 관리자가 클러스터를 생성할 때 API 서버에서 사용해야 하는 인가 모듈을 구성했다. 인가 모듈이 2개 이상 구성되면 쿠버네티스가 각 모듈을 확인하고, 어느 모듈이 요청을 승인하면 요청을 진행할 수 있다. 모든 모듈이 요청을 거부하면 요청이 거부된다(HTTP 상태 코드 403).</p>
<p>인가 모듈을 사용한 정책 생성을 포함해 쿠버네티스 인가에 대해 더 배우려면 <a href=/ko/docs/reference/access-authn-authz/authorization/>인가 개요</a>를 참조한다.</p>
<h2 id=어드미션-제어>어드미션 제어</h2>
<p>어드미션 제어 모듈은 요청을 수정하거나 거부할 수 있는 소프트웨어 모듈이다.
인가 모듈에서 사용할 수 있는 속성 외에도
어드미션 제어 모듈은 생성되거나 수정된 오브젝트 내용에 접근할 수 있다.</p>
<p>어드미션 컨트롤러는 오브젝트를 생성, 수정, 삭제 또는 (프록시에) 연결하는 요청에 따라 작동한다.
어드미션 컨트롤러는 단순히 오브젝트를 읽는 요청에는 작동하지 않는다.
여러 개의 어드미션 컨트롤러가 구성되면 순서대로 호출된다.</p>
<p>이는 다이어그램에 <strong>3</strong>단계로 표시되어 있다.</p>
<p>인증 및 인가 모듈과 달리,
어드미션 제어 모듈이 거부되면 요청은 즉시 거부된다.</p>
<p>어드미션 제어 모듈은 오브젝트를 거부하는 것 외에도
필드의 복잡한 기본값을 설정할 수 있다.</p>
<p>사용 가능한 어드미션 제어 모듈은 <a href=/docs/reference/access-authn-authz/admission-controllers/>여기</a>에 서술되어 있다.</p>
<p>요청이 모든 어드미션 제어 모듈을 통과하면 유효성 검사 루틴을 사용하여 해당 API 오브젝트를 검증한 후
오브젝트 저장소에 기록(<strong>4</strong>단계)된다.</p>
<h2 id=api-서버-포트와-ip>API 서버 포트와 IP</h2>
<p>이전의 논의는 (일반적인 경우) API 서버의 보안 포트로 전송되는 요청에 적용된다.
API 서버는 실제로 다음과 같이 2개의 포트에서 서비스할 수 있다.</p>
<p>기본적으로, 쿠버네티스 API 서버는 2개의 포트에서 HTTP 서비스를 한다.</p>
<ol>
<li>
<p><code>로컬호스트 포트</code>:</p>
<ul>
<li>테스트 및 부트스트랩을 하기 위한 것이며 마스터 노드의 다른 구성요소
(스케줄러, 컨트롤러 매니저)가 API와 통신하기 위한 것이다.</li>
<li>TLS가 없다.</li>
<li>기본 포트는 8080이다.</li>
<li>기본 IP는 로컬호스트(localhost)이며, <code>--insecure-bind-address</code> 플래그를 사용하여 변경한다.</li>
<li>요청이 인증 및 인가 모듈을 <strong>우회한다</strong>.</li>
<li>요청이 어드미션 제어 모듈(들)에 의해 처리된다.</li>
<li>호스트 접근 요구로부터 보호를 받는다.</li>
</ul>
</li>
<li>
<p><code>보안 포트</code>:</p>
<ul>
<li>가능한 항상 사용하는 것이 좋다.</li>
<li>TLS를 사용한다. <code>--tls-cert-file</code> 플래그로 인증서를 지정하고 <code>--tls-private-key-file</code> 플래그로 키를 지정한다.</li>
<li>기본 포트는 6443이며, <code>--secure-port</code> 플래그를 사용하여 변경한다.</li>
<li>기본 IP는 로컬호스트가 아닌 첫 번째 네트워크 인터페이스이며, <code>--bind-address</code> 플래그를 사용하여 변경한다.</li>
<li>요청이 인증 및 인가 모듈에 의해 처리된다.</li>
<li>요청이 어드미션 제어 모듈(들)에 의해 처리된다.</li>
<li>인증 및 인가 모듈을 실행한다.</li>
</ul>
</li>
</ol>
<p>GCE(구글 컴퓨트 엔진) 및 다른 클라우드 제공자에서 <code>kube-up.sh</code>로 클러스터를 생성하면
API 서버는 포트 443에서 서비스한다.
GCE에서는 외부 HTTPS가 API에 접근할 수 있도록 프로젝트에서 방화벽 규칙이 구성된다.
이외에 클러스터 설정 방법은 다양하다.</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-c21d05f31057c5bcd2ebdd01f4e62a0e>9 - 스케줄링, 선점(Preemption), 축출(Eviction)</h1>
<div class=lead>쿠버네티스에서, 스케줄링은 kubelet이 파드를 실행할 수 있도록 파드를 노드에 할당하는 것을 말한다. 선점은 우선순위가 높은 파드가 노드에 스케줄될 수 있도록 우선순위가 낮은 파드를 종료시키는 과정을 말한다. 축출은 리소스가 부족한 노드에서 하나 이상의 파드를 사전에 종료시키는 프로세스이다.</div>
<p>쿠버네티스에서, 스케줄링은 <a class=glossary-tooltip title="클러스터의 각 노드에서 실행되는 에이전트. Kubelet은 파드에서 컨테이너가 확실하게 동작하도록 관리한다." data-toggle=tooltip data-placement=top href=/docs/reference/generated/kubelet target=_blank aria-label=kubelet>kubelet</a>이 파드를 실행할 수 있도록
<a class=glossary-tooltip title="파드는 클러스터에서 실행 중인 컨테이너의 집합을 나타낸다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/pods/ target=_blank aria-label=파드>파드</a>를
<a class=glossary-tooltip title="노드는 쿠버네티스의 작업 장비(worker machine)이다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/architecture/nodes/ target=_blank aria-label=노드>노드</a>에 할당하는 것을 말한다.
선점은 <a class=glossary-tooltip title="Pod Priority indicates the importance of a Pod relative to other Pods." data-toggle=tooltip data-placement=top href=/docs/concepts/scheduling-eviction/pod-priority-preemption/#pod-priority target=_blank aria-label=우선순위>우선순위</a>가 높은 파드가 노드에 스케줄될 수 있도록
우선순위가 낮은 파드를 종료시키는 과정을 말한다.
축출은 리소스가 부족한 노드에서 하나 이상의 파드를 사전에 종료시키는 프로세스이다.</p>
<h2 id=스케줄링>스케줄링</h2>
<ul>
<li><a href=/ko/docs/concepts/scheduling-eviction/kube-scheduler/>쿠버네티스 스케줄러</a></li>
<li><a href=/ko/docs/concepts/scheduling-eviction/assign-pod-node/>노드에 파드 할당하기</a></li>
<li><a href=/ko/docs/concepts/scheduling-eviction/pod-overhead/>파드 오버헤드</a></li>
<li><a href=/ko/docs/concepts/scheduling-eviction/taint-and-toleration/>테인트(Taints)와 톨러레이션(Tolerations)</a></li>
<li><a href=/docs/concepts/scheduling-eviction/scheduling-framework/>스케줄링 프레임워크</a></li>
<li><a href=/ko/docs/concepts/scheduling-eviction/scheduler-perf-tuning/>스케줄러 성능 튜닝</a></li>
<li><a href=/ko/docs/concepts/scheduling-eviction/resource-bin-packing/>확장된 리소스를 위한 리소스 빈 패킹(bin packing)</a></li>
</ul>
<h2 id=파드-중단-disruption>파드 중단(disruption)</h2>
<p><a href=/ko/docs/concepts/workloads/pods/disruptions/>파드 중단</a>은
노드에 있는 파드가 자발적 또는 비자발적으로 종료되는 절차이다.</p>
<p>자발적 중단은 애플리케이션 소유자 또는 클러스터 관리자가 의도적으로 시작한다.
비자발적 중단은 의도하지 않은 것이며,
노드의 리소스 부족과 같은 피할 수 없는 문제 또는 우발적인 삭제로 인해 트리거가 될 수 있다.</p>
<ul>
<li><a href=/ko/docs/concepts/scheduling-eviction/pod-priority-preemption/>파드 우선순위와 선점</a></li>
<li><a href=/ko/docs/concepts/scheduling-eviction/node-pressure-eviction/>노드-압박 축출</a></li>
<li><a href=/ko/docs/concepts/scheduling-eviction/api-eviction/>API를 이용한 축출</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-598f36d691ab197f9d995784574b0a12>9.1 - 쿠버네티스 스케줄러</h1>
<p>쿠버네티스에서 <em>스케줄링</em> 은 <a class=glossary-tooltip title="클러스터의 각 노드에서 실행되는 에이전트. Kubelet은 파드에서 컨테이너가 확실하게 동작하도록 관리한다." data-toggle=tooltip data-placement=top href=/docs/reference/generated/kubelet target=_blank aria-label=Kubelet>Kubelet</a>이
파드를 실행할 수 있도록 <a class=glossary-tooltip title="파드는 클러스터에서 실행 중인 컨테이너의 집합을 나타낸다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/pods/ target=_blank aria-label=파드>파드</a>가
<a class=glossary-tooltip title="노드는 쿠버네티스의 작업 장비(worker machine)이다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/architecture/nodes/ target=_blank aria-label=노드>노드</a>에 적합한지 확인하는 것을 말한다.</p>
<h2 id=scheduling>스케줄링 개요</h2>
<p>스케줄러는 노드가 할당되지 않은 새로 생성된 파드를 감시한다.
스케줄러가 발견한 모든 파드에 대해 스케줄러는 해당 파드가 실행될
최상의 노드를 찾는 책임을 진다. 스케줄러는
아래 설명된 스케줄링 원칙을 고려하여 이 배치 결정을
하게 된다.</p>
<p>파드가 특정 노드에 배치되는 이유를 이해하려고 하거나
사용자 정의된 스케줄러를 직접 구현하려는 경우 이
페이지를 통해서 스케줄링에 대해 배울 수 있을 것이다.</p>
<h2 id=kube-scheduler>kube-scheduler</h2>
<p><a href=/docs/reference/command-line-tools-reference/kube-scheduler/>kube-scheduler</a>는
쿠버네티스의 기본 스케줄러이며 <a class=glossary-tooltip title="컨테이너의 라이프사이클을 정의, 배포, 관리하기 위한 API와 인터페이스들을 노출하는 컨테이너 오케스트레이션 레이어." data-toggle=tooltip data-placement=top href="/ko/docs/reference/glossary/?all=true#term-control-plane" target=_blank aria-label="컨트롤 플레인">컨트롤 플레인</a>의
일부로 실행된다.
kube-scheduler는 원하거나 필요에 따라 자체 스케줄링 컴포넌트를
만들고 대신 사용할 수 있도록 설계되었다.</p>
<p>새로 생성된 모든 파드 또는 예약되지 않은 다른 파드에 대해 kube-scheduler는
실행할 최적의 노드를 선택한다. 그러나 파드의 모든 컨테이너에는
리소스에 대한 요구사항이 다르며 모든 파드에도
요구사항이 다르다. 따라서 기존 노드들은
특정 스케줄링 요구사항에 따라 필터링 되어야 한다.</p>
<p>클러스터에서 파드에 대한 스케줄링 요구사항을 충족하는 노드를
<em>실행 가능한(feasible)</em> 노드라고 한다. 적합한 노드가 없으면 스케줄러가
배치할 수 있을 때까지 파드가 스케줄 되지 않은 상태로 유지된다.</p>
<p>스케줄러는 파드가 실행 가능한 노드를 찾은 다음 실행 가능한 노드의
점수를 측정하는 기능 셋을 수행하고 실행 가능한 노드 중에서 가장 높은 점수를
가진 노드를 선택하여 파드를 실행한다. 그런 다음 스케줄러는
<em>바인딩</em> 이라는 프로세스에서 이 결정에 대해 API 서버에 알린다.</p>
<p>스케줄링 결정을 위해 고려해야 할 요소에는
개별 및 집단 리소스 요구사항, 하드웨어 / 소프트웨어 /
정책 제한조건, 어피니티 및 안티-어피니티 명세, 데이터
지역성(data locality), 워크로드 간 간섭 등이 포함된다.</p>
<h3 id=kube-scheduler-implementation>kube-scheduler에서 노드 선택</h3>
<p>kube-scheduler는 2단계 작업에서 파드에 대한 노드를 선택한다.</p>
<ol>
<li>필터링</li>
<li>스코어링(scoring)</li>
</ol>
<p><em>필터링</em> 단계는 파드를 스케줄링 할 수 있는 노드 셋을
찾는다. 예를 들어 PodFitsResources 필터는
후보 노드가 파드의 특정 리소스 요청을 충족시키기에 충분한 가용 리소스가
있는지 확인한다. 이 단계 다음에 노드 목록에는 적합한 노드들이
포함된다. 하나 이상의 노드가 포함된 경우가 종종 있을 것이다. 목록이 비어 있으면
해당 파드는 (아직) 스케줄링 될 수 없다.</p>
<p><em>스코어링</em> 단계에서 스케줄러는 목록에 남아있는 노드의 순위를 지정하여
가장 적합한 파드 배치를 선택한다. 스케줄러는 사용 중인 스코어링 규칙에 따라
이 점수를 기준으로 필터링에서 통과된 각 노드에 대해 점수를 지정한다.</p>
<p>마지막으로 kube-scheduler는 파드를 순위가 가장 높은 노드에 할당한다.
점수가 같은 노드가 두 개 이상인 경우 kube-scheduler는
이들 중 하나를 임의로 선택한다.</p>
<p>스케줄러의 필터링 및 스코어링 동작을 구성하는 데 지원되는 두 가지
방법이 있다.</p>
<ol>
<li><a href=/ko/docs/reference/scheduling/config/#%ED%94%84%EB%A1%9C%ED%8C%8C%EC%9D%BC>스케줄링 정책</a>을 사용하면 필터링을 위한 <em>단정(Predicates)</em> 및 스코어링을 위한 <em>우선순위(Priorities)</em> 를 구성할 수 있다.</li>
<li><a href=/ko/docs/reference/scheduling/config/#%ED%94%84%EB%A1%9C%ED%8C%8C%EC%9D%BC>스케줄링 프로파일</a>을 사용하면 <code>QueueSort</code>, <code>Filter</code>, <code>Score</code>, <code>Bind</code>, <code>Reserve</code>, <code>Permit</code> 등의 다른 스케줄링 단계를 구현하는 플러그인을 구성할 수 있다. 다른 프로파일을 실행하도록 kube-scheduler를 구성할 수도 있다.</li>
</ol>
<h2 id=다음-내용>다음 내용</h2>
<ul>
<li><a href=/ko/docs/concepts/scheduling-eviction/scheduler-perf-tuning/>스케줄러 성능 튜닝</a>에 대해 읽기</li>
<li><a href=/ko/docs/concepts/workloads/pods/pod-topology-spread-constraints/>파드 토폴로지 분배 제약 조건</a>에 대해 읽기</li>
<li>kube-scheduler의 <a href=/docs/reference/command-line-tools-reference/kube-scheduler/>레퍼런스 문서</a> 읽기</li>
<li><a href=/docs/reference/config-api/kube-scheduler-config.v1beta3/>kube-scheduler 구성(v1beta3)</a> 레퍼런스 읽기</li>
<li><a href=/docs/tasks/extend-kubernetes/configure-multiple-schedulers/>멀티 스케줄러 구성하기</a>에 대해 배우기</li>
<li><a href=/docs/tasks/administer-cluster/topology-manager/>토폴로지 관리 정책</a>에 대해 배우기</li>
<li><a href=/ko/docs/concepts/scheduling-eviction/pod-overhead/>파드 오버헤드</a>에 대해 배우기</li>
<li>볼륨을 사용하는 파드의 스케줄링에 대해 배우기
<ul>
<li><a href=/ko/docs/concepts/storage/storage-classes/#%EB%B3%BC%EB%A5%A8-%EB%B0%94%EC%9D%B8%EB%94%A9-%EB%AA%A8%EB%93%9C>볼륨 토폴리지 지원</a></li>
<li><a href=/ko/docs/concepts/storage/storage-capacity/>스토리지 용량 추적</a></li>
<li><a href=/ko/docs/concepts/storage/storage-limits/>노드별 볼륨 한도</a></li>
</ul>
</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-21169f516071aea5d16734a4c27789a5>9.2 - 노드에 파드 할당하기</h1>
<p>특정한 <a class=glossary-tooltip title="노드는 쿠버네티스의 작업 장비(worker machine)이다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/architecture/nodes/ target=_blank aria-label=노드(들)>노드(들)</a> 집합에서만 동작하도록
<a class=glossary-tooltip title="파드는 클러스터에서 실행 중인 컨테이너의 집합을 나타낸다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/pods/ target=_blank aria-label=파드>파드</a>를 제한할 수 있다.
이를 수행하는 방법에는 여러 가지가 있으며 권장되는 접근 방식은 모두
<a href=/ko/docs/concepts/overview/working-with-objects/labels/>레이블 셀렉터</a>를 사용하여 선택을 용이하게 한다.
보통 스케줄러가 자동으로 합리적인 배치(예: 자원이 부족한 노드에 파드를 배치하지 않도록
노드 간에 파드를 분배하는 등)를 수행하기에 이러한 제약 조건은 필요하지 않지만
간혹 파드가 배포될 노드를 제어해야 하는 경우가 있다.
예를 들어 SSD가 장착된 머신에 파드가 배포되도록 하거나 또는 많은 통신을 하는 두 개의 서로 다른 서비스의 파드를
동일한 가용성 영역(availability zone)에 배치할 수 있다.</p>
<h2 id=노드-셀렉터-nodeselector>노드 셀렉터(nodeSelector)</h2>
<p><code>nodeSelector</code> 는 가장 간단하고 권장되는 노드 선택 제약 조건의 형태이다.
<code>nodeSelector</code> 는 PodSpec의 필드이다. 이는 키-값 쌍의 매핑으로 지정한다. 파드가 노드에서 동작할 수 있으려면,
노드는 키-값의 쌍으로 표시되는 레이블을 각자 가지고 있어야 한다(이는 추가 레이블을 가지고 있을 수 있다).
일반적으로 하나의 키-값 쌍이 사용된다.</p>
<p><code>nodeSelector</code> 를 어떻게 사용하는지 예시를 통해 알아보도록 하자.</p>
<h3 id=0-단계-사전-준비>0 단계: 사전 준비</h3>
<p>이 예시는 쿠버네티스 파드에 대한 기본적인 이해를 하고 있고 <a href=/ko/docs/setup/>쿠버네티스 클러스터가 설정</a>되어 있다고 가정한다.</p>
<h3 id=1-단계-노드에-레이블-붙이기>1 단계: 노드에 레이블 붙이기</h3>
<p><code>kubectl get nodes</code> 를 실행해서 클러스터 노드 이름을 가져온다. 이 중에 레이블을 추가하기 원하는 것 하나를 선택한 다음에 <code>kubectl label nodes &lt;노드 이름> &lt;레이블 키>=&lt;레이블 값></code> 을 실행해서 선택한 노드에 레이블을 추가한다. 예를 들어 노드의 이름이 'kubernetes-foo-node-1.c.a-robinson.internal' 이고, 원하는 레이블이 'disktype=ssd' 라면, <code>kubectl label nodes kubernetes-foo-node-1.c.a-robinson.internal disktype=ssd</code> 를 실행한다.</p>
<p><code>kubectl get nodes --show-labels</code> 를 다시 실행해서 노드가 현재 가진 레이블을 확인하여, 이 작업을 검증할 수 있다. 또한 <code>kubectl describe node "노드 이름"</code> 을 사용해서 노드에 주어진 레이블의 전체 목록을 확인할 수 있다.</p>
<h3 id=2-단계-파드-설정에-nodeselector-필드-추가하기>2 단계: 파드 설정에 nodeSelector 필드 추가하기</h3>
<p>실행하고자 하는 파드의 설정 파일을 가져오고, 이처럼 nodeSelector 섹션을 추가한다. 예를 들어 이것이 파드 설정이라면,</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb> </span>test<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></code></pre></div><p>이 다음에 nodeSelector 를 다음과 같이 추가한다.</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/ko/examples/pods/pod-nginx.yaml download=pods/pod-nginx.yaml><code>pods/pod-nginx.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-pod-nginx-yaml')" title="Copy pods/pod-nginx.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-pod-nginx-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb> </span>test<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>imagePullPolicy</span>:<span style=color:#bbb> </span>IfNotPresent<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>nodeSelector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>disktype</span>:<span style=color:#bbb> </span>ssd<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>그런 다음에 <code>kubectl apply -f https://k8s.io/examples/pods/pod-nginx.yaml</code> 을
실행하면, 레이블이 붙여진 노드에 파드가 스케줄된다.
<code>kubectl get pods -o wide</code> 를 실행해서 파드가 할당된
"NODE" 를 보면 작동하는지 검증할 수 있다.</p>
<h2 id=built-in-node-labels>넘어가기 전에: 내장 노드 레이블들</h2>
<p><a href=#1-%EB%8B%A8%EA%B3%84-%EB%85%B8%EB%93%9C%EC%97%90-%EB%A0%88%EC%9D%B4%EB%B8%94-%EB%B6%99%EC%9D%B4%EA%B8%B0>붙인</a> 레이블뿐만 아니라, 노드에는
표준 레이블 셋이 미리 채워져 있다. 이들 목록은 <a href=/ko/docs/reference/labels-annotations-taints/>잘 알려진 레이블, 어노테이션 및 테인트</a>를 참고한다.</p>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> 이 레이블들의 값은 클라우드 공급자에 따라 다르고 신뢰성이 보장되지 않는다.
예를 들어 <code>kubernetes.io/hostname</code> 은 어떤 환경에서는 노드 이름과 같지만,
다른 환경에서는 다른 값일 수 있다.
</div>
<h2 id=노드-격리-isolation-제한-restriction>노드 격리(isolation)/제한(restriction)</h2>
<p>노드 오브젝트에 레이블을 추가하면 파드가 특정 노드 또는 노드 그룹을 목표 대상으로 할 수 있게 된다.
이는 특정 파드가 어떤 격리, 보안, 또는 규제 속성이 있는 노드에서만 실행되도록 사용할 수 있다.
이 목적으로 레이블을 사용하는 경우, 노드에서 kubelet 프로세스로 수정할 수 없는 레이블 키를 선택하는 것을 권장한다.
이렇게 하면 손상된 노드가 해당 kubelet 자격 증명을 사용해서 해당 레이블을 자체 노드 오브젝트에 설정하고,
스케줄러가 손상된 노드로 워크로드를 스케줄 하는 것을 방지할 수 있다.</p>
<p><code>NodeRestriction</code> 어드미션 플러그인은 kubelet이 <code>node-restriction.kubernetes.io/</code> 접두사로 레이블을 설정 또는 수정하지 못하게 한다.
노드 격리에 해당 레이블 접두사를 사용하려면 다음과 같이 한다.</p>
<ol>
<li><a href=/docs/reference/access-authn-authz/node/>노드 권한부여자</a>를 사용하고 있고, <a href=/docs/reference/access-authn-authz/admission-controllers/#noderestriction>NodeRestriction 어드미션 플러그인</a>을 <em>활성화</em> 해야 한다.</li>
<li>노드 오브젝트의 <code>node-restriction.kubernetes.io/</code> 접두사 아래에 레이블을 추가하고, 해당 레이블을 노드 셀렉터에서 사용한다.
예를 들어, <code>example.com.node-restriction.kubernetes.io/fips=true</code> 또는 <code>example.com.node-restriction.kubernetes.io/pci-dss=true</code> 이다.</li>
</ol>
<h2 id=어피니티-affinity-와-안티-어피니티-anti-affinity>어피니티(affinity)와 안티-어피니티(anti-affinity)</h2>
<p><code>nodeSelector</code> 는 파드를 특정 레이블이 있는 노드로 제한하는 매우 간단한 방법을 제공한다.
어피니티/안티-어피니티 기능은 표현할 수 있는 제약 종류를 크게 확장한다. 주요 개선 사항은 다음과 같다.</p>
<ol>
<li>어피니티/안티-어피니티 언어가 더 표현적이다. 언어는 논리 연산자인 AND 연산으로 작성된
정확한 매칭 항목 이외에 더 많은 매칭 규칙을 제공한다.</li>
<li>규칙이 엄격한 요구 사항이 아니라 "유연한(soft)"/"선호(preference)" 규칙을 나타낼 수 있기에 스케줄러가 규칙을 만족할 수 없더라도,
파드가 계속 스케줄되도록 한다.</li>
<li>노드 자체에 레이블을 붙이기보다는 노드(또는 다른 토폴로지 도메인)에서 실행 중인 다른 파드의 레이블을 제한할 수 있다.
이를 통해 어떤 파드가 함께 위치할 수 있는지와 없는지에 대한 규칙을 적용할 수 있다.</li>
</ol>
<p>어피니티 기능은 "노드 어피니티" 와 "파드 간 어피니티/안티-어피니티" 두 종류의 어피니티로 구성된다.
노드 어피니티는 기존 <code>nodeSelector</code> 와 비슷하지만(그러나 위에서 나열된 첫째와 두 번째 이점이 있다.),
파드 간 어피니티/안티-어피니티는 위에서 나열된 세번째 항목에 설명된 대로
노드 레이블이 아닌 파드 레이블에 대해 제한되고 위에서 나열된 첫 번째와 두 번째 속성을 가진다.</p>
<h3 id=노드-어피니티>노드 어피니티</h3>
<p>노드 어피니티는 개념적으로 <code>nodeSelector</code> 와 비슷하다 -- 이는 노드의 레이블을 기반으로 파드를
스케줄할 수 있는 노드를 제한할 수 있다.</p>
<p>여기에 현재 <code>requiredDuringSchedulingIgnoredDuringExecution</code> 와 <code>preferredDuringSchedulingIgnoredDuringExecution</code> 로 부르는
두 가지 종류의 노드 어피니티가 있다. 전자는 파드가 노드에 스케줄되도록 <em>반드시</em>
규칙을 만족해야 하는 것(<code>nodeSelector</code> 와 비슷하나 보다 표현적인 구문을 사용해서)을 지정하고,
후자는 스케줄러가 시도하려고는 하지만, 보증하지 않는 <em>선호(preferences)</em> 를 지정한다는 점에서
이를 각각 "엄격함(hard)" 과 "유연함(soft)" 으로 생각할 수 있다.
이름의 "IgnoredDuringExecution" 부분은 <code>nodeSelector</code> 작동 방식과 유사하게 노드의
레이블이 런타임 중에 변경되어 파드의 어피니티 규칙이 더 이상 충족되지 않으면 파드가 그 노드에서
동작한다는 의미이다. 향후에는 파드의 노드 어피니티 요구 사항을 충족하지 않는 노드에서 파드를 제거한다는
점을 제외하고는 <code>requiredDuringSchedulingIgnoredDuringExecution</code> 와 동일한 <code>requiredDuringSchedulingRequiredDuringExecution</code> 를 제공할 계획이다.</p>
<p>따라서 <code>requiredDuringSchedulingIgnoredDuringExecution</code> 의 예로는 "인텔 CPU가 있는 노드에서만 파드 실행"이
될 수 있고, <code>preferredDuringSchedulingIgnoredDuringExecution</code> 의 예로는 "장애 조치 영역 XYZ에 파드 집합을 실행하려고
하지만, 불가능하다면 다른 곳에서 일부를 실행하도록 허용"이 있을 것이다.</p>
<p>노드 어피니티는 PodSpec의 <code>affinity</code> 필드의 <code>nodeAffinity</code> 필드에서 지정된다.</p>
<p>여기에 노드 어피니티를 사용하는 파드 예시가 있다.</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/ko/examples/pods/pod-with-node-affinity.yaml download=pods/pod-with-node-affinity.yaml><code>pods/pod-with-node-affinity.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-pod-with-node-affinity-yaml')" title="Copy pods/pod-with-node-affinity.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-pod-with-node-affinity-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>with-node-affinity<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>affinity</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>nodeAffinity</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requiredDuringSchedulingIgnoredDuringExecution</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>nodeSelectorTerms</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>kubernetes.io/e2e-az-name<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span>In<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>values</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span>- e2e-az1<span style=color:#bbb>
</span><span style=color:#bbb>            </span>- e2e-az2<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>preferredDuringSchedulingIgnoredDuringExecution</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>weight</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>preference</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>another-node-label-key<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span>In<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>values</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span>- another-node-label-value<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>with-node-affinity<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/pause:2.0</code></pre></div>
</div>
</div>
<p>이 노드 어피니티 규칙은 키가 <code>kubernetes.io/e2e-az-name</code> 이고 값이 <code>e2e-az1</code> 또는 <code>e2e-az2</code> 인
레이블이 있는 노드에만 파드를 배치할 수 있다고 말한다. 또한, 이 기준을 충족하는 노드들
중에서 키가 <code>another-node-label-key</code> 이고 값이 <code>another-node-label-value</code> 인 레이블이 있는 노드를
선호하도록 한다.</p>
<p>예시에서 연산자 <code>In</code> 이 사용되고 있는 것을 볼 수 있다. 새로운 노드 어피니티 구문은 다음의 연산자들을 지원한다. <code>In</code>, <code>NotIn</code>, <code>Exists</code>, <code>DoesNotExist</code>, <code>Gt</code>, <code>Lt</code>.
<code>NotIn</code> 과 <code>DoesNotExist</code> 를 사용해서 안티-어피니티를 수행하거나,
특정 노드에서 파드를 쫓아내는 <a href=/ko/docs/concepts/scheduling-eviction/taint-and-toleration/>노드 테인트(taint)</a>를 설정할 수 있다.</p>
<p><code>nodeSelector</code> 와 <code>nodeAffinity</code> 를 모두 지정한다면 파드가 후보 노드에 스케줄되기 위해서는
<em>둘 다</em> 반드시 만족해야 한다.</p>
<p><code>nodeAffinity</code> 유형과 연관된 <code>nodeSelectorTerms</code> 를 지정하면, <code>nodeSelectorTerms</code> 중 <strong>하나라도</strong> 만족시키는 노드에 파드가 스케줄된다.</p>
<p><code>nodeSelectorTerms</code> 와 연관된 여러 <code>matchExpressions</code> 를 지정하면, 파드는 <code>matchExpressions</code> 를 <strong>모두</strong> 만족하는 노드에만 스케줄된다.</p>
<p>파드가 스케줄된 노드의 레이블을 지우거나 변경해도 파드는 제거되지 않는다. 다시 말해서 어피니티 선택은 파드를 스케줄링 하는 시점에만 작동한다.</p>
<p><code>preferredDuringSchedulingIgnoredDuringExecution</code> 의 <code>weight</code> 필드의 범위는 1-100이다. 모든 스케줄링 요구 사항 (리소스 요청, RequiredDuringScheduling 어피니티 표현식 등)을 만족하는 각 노드들에 대해 스케줄러는 이 필드의 요소들을 반복해서 합계를 계산하고 노드가 MatchExpressions 에 일치하는 경우 합계에 "가중치(weight)"를 추가한다. 이후에 이 점수는 노드에 대한 다른 우선순위 함수의 점수와 합쳐진다. 전체 점수가 가장 높은 노드를 가장 선호한다.</p>
<h4 id=스케줄링-프로파일당-노드-어피니티>스케줄링 프로파일당 노드 어피니티</h4>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.20 [beta]</code>
</div>
<p>여러 <a href=/ko/docs/reference/scheduling/config/#%EC%97%AC%EB%9F%AC-%ED%94%84%EB%A1%9C%ED%8C%8C%EC%9D%BC>스케줄링 프로파일</a>을 구성할 때
노드 어피니티가 있는 프로파일을 연결할 수 있는데, 이는 프로파일이 특정 노드 집합에만 적용되는 경우 유용하다.
이렇게 하려면 <a href=/ko/docs/reference/scheduling/config/>스케줄러 구성</a>에 있는
<a href=/ko/docs/reference/scheduling/config/#%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81-%ED%94%8C%EB%9F%AC%EA%B7%B8%EC%9D%B8-1><code>NodeAffinity</code> 플러그인</a>의 인수에 <code>addedAffinity</code>를 추가한다. 예를 들면</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>kubescheduler.config.k8s.io/v1beta1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>KubeSchedulerConfiguration<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>profiles</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>schedulerName</span>:<span style=color:#bbb> </span>default-scheduler<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>schedulerName</span>:<span style=color:#bbb> </span>foo-scheduler<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>pluginConfig</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>NodeAffinity<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>addedAffinity</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>requiredDuringSchedulingIgnoredDuringExecution</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>nodeSelectorTerms</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span>- <span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
</span><span style=color:#bbb>                </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>scheduler-profile<span style=color:#bbb>
</span><span style=color:#bbb>                  </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span>In<span style=color:#bbb>
</span><span style=color:#bbb>                  </span><span style=color:green;font-weight:700>values</span>:<span style=color:#bbb>
</span><span style=color:#bbb>                  </span>- foo<span style=color:#bbb>
</span></code></pre></div><p><code>addedAffinity</code>는 <code>.spec.schedulerName</code>을 <code>foo-scheduler</code>로 설정하는 모든 파드에 적용되며
PodSpec에 지정된 NodeAffinity도 적용된다.
즉, 파드를 매칭시키려면, 노드가 <code>addedAffinity</code>와 파드의 <code>.spec.NodeAffinity</code>를 충족해야 한다.</p>
<p><code>addedAffinity</code>는 엔드 유저에게 표시되지 않으므로, 예상치 못한 동작이 일어날 수 있다. 프로파일의
스케줄러 이름과 명확한 상관 관계가 있는 노드 레이블을 사용하는 것이 좋다.</p>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> <a href=/ko/docs/concepts/workloads/controllers/daemonset/#%EA%B8%B0%EB%B3%B8-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%9F%AC%EB%A1%9C-%EC%8A%A4%EC%BC%80%EC%A4%84>데몬셋용 파드를 생성</a>하는 데몬셋 컨트롤러는
스케줄링 프로파일을 인식하지 못한다.
따라서 <code>addedAffinity</code>없이 <code>default-scheduler</code>와 같은 스케줄러 프로파일을 유지하는 것이 좋다. 그런 다음 데몬셋의 파드 템플릿이 스케줄러 이름을 사용해야 한다.
그렇지 않으면, 데몬셋 컨트롤러에 의해 생성된 일부 파드가 스케줄되지 않은 상태로 유지될 수 있다.
</div>
<h3 id=파드간-어피니티와-안티-어피니티>파드간 어피니티와 안티-어피니티</h3>
<p>파드간 어피니티와 안티-어피니티를 사용하면 노드의 레이블을 기반으로 하지 않고, <em>노드에서 이미 실행 중인 파드 레이블을 기반으로</em>
파드가 스케줄될 수 있는 노드를 제한할 수 있다. 규칙은 "X가 규칙 Y를 충족하는 하나 이상의 파드를 이미 실행중인 경우
이 파드는 X에서 실행해야 한다(또는 안티-어피니티가 없는 경우에는 동작하면 안된다)"는 형태이다. Y는
선택적으로 연관된 네임스페이스 목록을 가진 LabelSelector로 표현된다. 노드와는 다르게 파드는 네임스페이스이기에
(그리고 따라서 파드의 레이블은 암암리에 네임스페이스이다) 파드 레이블위의 레이블 셀렉터는 반드시
셀렉터가 적용될 네임스페이스를 지정해야만 한다. 개념적으로 X는 노드, 랙,
클라우드 공급자 영역, 클라우드 공급자 지역 등과 같은 토폴로지 도메인이다. 시스템이 이런 토폴로지
도메인을 나타내는 데 사용하는 노드 레이블 키인 <code>topologyKey</code> 를 사용하여 이를 표현한다.
예: <a href=#built-in-node-labels>넘어가기 전에: 빌트인 노드 레이블</a> 섹션 위에 나열된 레이블 키를 본다.</p>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> 파드간 어피니티와 안티-어피니티에는 상당한 양의 프로세싱이 필요하기에
대규모 클러스터에서는 스케줄링 속도가 크게 느려질 수 있다.
수백 개의 노드를 넘어가는 클러스터에서 이를 사용하는 것은 추천하지 않는다.
</div>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> 파드 안티-어피니티에서는 노드에 일관된 레이블을 지정해야 한다. 즉, 클러스터의 모든 노드는 <code>topologyKey</code> 와 매칭되는 적절한 레이블을 가지고 있어야 한다. 일부 또는 모든 노드에 지정된 <code>topologyKey</code> 레이블이 없는 경우에는 의도하지 않은 동작이 발생할 수 있다.
</div>
<p>노드 어피니티와 마찬가지로 현재 파드 어피니티와 안티-어피니티로 부르는 "엄격함" 대 "유연함"의 요구사항을 나타내는 <code>requiredDuringSchedulingIgnoredDuringExecution</code> 와
<code>preferredDuringSchedulingIgnoredDuringExecution</code> 두 가지 종류가 있다.
앞의 노드 어피니티 섹션의 설명을 본다.
<code>requiredDuringSchedulingIgnoredDuringExecution</code> 어피니티의 예시는
"서로 많은 통신을 하기 때문에 서비스 A와 서비스 B를 같은 영역에 함께 위치시키는 것"이고,
<code>preferredDuringSchedulingIgnoredDuringExecution</code> 안티-어피니티의 예시는 "서비스를 여러 영역에 걸쳐서 분배하는 것"이다
(엄격한 요구사항은 영역보다 파드가 더 많을 수 있기 때문에 엄격한 요구사항은 의미가 없다).</p>
<p>파드간 어피니티는 PodSpec에서 <code>affinity</code> 필드 중 <code>podAffinity</code> 필드로 지정한다.
그리고 파드간 안티-어피니티는 PodSpec에서 <code>affinity</code> 필드 중 <code>podAntiAffinity</code> 필드로 지정한다.</p>
<h4 id=파드-어피니티를-사용하는-파드의-예시>파드 어피니티를 사용하는 파드의 예시</h4>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/ko/examples/pods/pod-with-pod-affinity.yaml download=pods/pod-with-pod-affinity.yaml><code>pods/pod-with-pod-affinity.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-pod-with-pod-affinity-yaml')" title="Copy pods/pod-with-pod-affinity.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-pod-with-pod-affinity-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>with-pod-affinity<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>affinity</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>podAffinity</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requiredDuringSchedulingIgnoredDuringExecution</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>labelSelector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>security<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span>In<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>values</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span>- S1<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>topologyKey</span>:<span style=color:#bbb> </span>topology.kubernetes.io/zone<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>podAntiAffinity</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>preferredDuringSchedulingIgnoredDuringExecution</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>weight</span>:<span style=color:#bbb> </span><span style=color:#666>100</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>podAffinityTerm</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>labelSelector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>security<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span>In<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>values</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span>- S2<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>topologyKey</span>:<span style=color:#bbb> </span>topology.kubernetes.io/zone<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>with-pod-affinity<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/pause:2.0<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>이 파드의 어피니티는 하나의 파드 어피니티 규칙과 하나의 파드 안티-어피니티 규칙을 정의한다.
이 예시에서 <code>podAffinity</code> 는 <code>requiredDuringSchedulingIgnoredDuringExecution</code> 이고 <code>podAntiAffinity</code> 는
<code>preferredDuringSchedulingIgnoredDuringExecution</code> 이다. 파드 어피니티 규칙에 의하면 키 "security" 와 값
"S1"인 레이블이 있는 하나 이상의 이미 실행 중인 파드와 동일한 영역에 있는 경우에만 파드를 노드에 스케줄할 수 있다.
(보다 정확하게는, 클러스터에 키 "security"와 값 "S1"인 레이블을 가지고 있는 실행 중인 파드가 있는 키
<code>topology.kubernetes.io/zone</code> 와 값 V인 노드가 최소 하나 이상 있고,
노드 N이 키 <code>topology.kubernetes.io/zone</code> 와
일부 값이 V인 레이블을 가진다면 파드는 노드 N에서 실행할 수 있다.)
파드 안티-어피니티 규칙에 의하면 파드는 키 "security"와 값 "S2"인 레이블을 가진 파드와
동일한 영역의 노드에 스케줄되지 않는다.
<a href=https://git.k8s.io/community/contributors/design-proposals/scheduling/podaffinity.md>디자인 문서</a>를 통해
<code>requiredDuringSchedulingIgnoredDuringExecution</code> 와 <code>preferredDuringSchedulingIgnoredDuringExecution</code> 의
파드 어피니티와 안티-어피니티에 대한 많은 예시를 맛볼 수 있다.</p>
<p>파드 어피니티와 안티-어피니티의 적합한 연산자는 <code>In</code>, <code>NotIn</code>, <code>Exists</code>, <code>DoesNotExist</code> 이다.</p>
<p>원칙적으로, <code>topologyKey</code> 는 적법한 어느 레이블-키도 될 수 있다.
하지만, 성능과 보안상의 이유로 topologyKey에는 몇 가지 제약조건이 있다.</p>
<ol>
<li>파드 어피니티에서 <code>requiredDuringSchedulingIgnoredDuringExecution</code> 와 <code>preferredDuringSchedulingIgnoredDuringExecution</code> 는
<code>topologyKey</code> 의 빈 값을 허용하지 않는다.</li>
<li>파드 안티-어피니티에서도 <code>requiredDuringSchedulingIgnoredDuringExecution</code> 와 <code>preferredDuringSchedulingIgnoredDuringExecution</code> 는
<code>topologyKey</code> 의 빈 값을 허용하지 않는다.</li>
<li><code>requiredDuringSchedulingIgnoredDuringExecution</code> 파드 안티-어피니티에서 <code>topologyKey</code> 를 <code>kubernetes.io/hostname</code> 로 제한하기 위해 어드미션 컨트롤러 <code>LimitPodHardAntiAffinityTopology</code> 가 도입되었다. 사용자 지정 토폴로지를 사용할 수 있도록 하려면, 어드미션 컨트롤러를 수정하거나 아니면 이를 비활성화해야 한다.</li>
<li>위의 경우를 제외하고, <code>topologyKey</code> 는 적법한 어느 레이블-키도 가능하다.</li>
</ol>
<p><code>labelSelector</code> 와 <code>topologyKey</code> 외에도 <code>labelSelector</code> 와 일치해야 하는 네임스페이스 목록 <code>namespaces</code> 를
선택적으로 지정할 수 있다(이것은 <code>labelSelector</code> 와 <code>topologyKey</code> 와 같은 수준의 정의이다).
생략되어 있거나 비어있을 경우 어피니티/안티-어피니티 정의가 있는 파드의 네임스페이스가 기본 값이다.</p>
<p>파드를 노드에 스케줄하려면 <code>requiredDuringSchedulingIgnoredDuringExecution</code> 어피니티와 안티-어피니티와
연관된 <code>matchExpressions</code> 가 모두 충족되어야 한다.</p>
<h4 id=네임스페이스-셀렉터>네임스페이스 셀렉터</h4>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.22 [beta]</code>
</div>
<p>사용자는 네임스페이스 집합에 대한 레이블 쿼리인 <code>namespaceSelector</code> 를 사용하여 일치하는 네임스페이스를 선택할 수도 있다.
어피니티 용어는 <code>namespaceSelector</code> 에서 선택한 네임스페이스와 <code>namespaces</code> 필드에 나열된 네임스페이스의 결합에 적용된다.
빈 <code>namespaceSelector</code> ({})는 모든 네임스페이스와 일치하는 반면, null 또는 빈 <code>namespaces</code> 목록과
null <code>namespaceSelector</code> 는 "이 파드의 네임스페이스"를 의미한다.</p>
<p>이 기능은 베타이며 기본으로 활성화되어 있다. kube-apiserver 및 kube-scheduler 모두에서
<a href=/ko/docs/reference/command-line-tools-reference/feature-gates/>기능 게이트</a>
<code>PodAffinityNamespaceSelector</code> 를 사용하여 비활성화할 수 있다.</p>
<h4 id=더-실용적인-유스케이스>더 실용적인 유스케이스</h4>
<p>파드간 어피니티와 안티-어피니티는 레플리카셋, 스테이트풀셋, 디플로이먼트 등과 같은
상위 레벨 모음과 함께 사용할 때 더욱 유용할 수 있다. 워크로드 집합이 동일한 노드와 같이
동일하게 정의된 토폴로지와 같은 위치에 배치되도록 쉽게 구성할 수 있다.</p>
<h5 id=항상-같은-노드에-위치시키기>항상 같은 노드에 위치시키기</h5>
<p>세 개의 노드가 있는 클러스터에서 웹 애플리케이션에는 redis와 같은 인-메모리 캐시가 있다. 웹 서버가 가능한 캐시와 함께 위치하기를 원한다.</p>
<p>다음은 세 개의 레플리카와 셀렉터 레이블이 <code>app=store</code> 가 있는 간단한 redis 디플로이먼트의 yaml 스니펫이다. 디플로이먼트에는 스케줄러가 단일 노드에서 레플리카를 함께 배치하지 않도록 <code>PodAntiAffinity</code> 가 구성되어 있다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>redis-cache<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>store<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>store<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>affinity</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>podAntiAffinity</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>requiredDuringSchedulingIgnoredDuringExecution</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span>- <span style=color:green;font-weight:700>labelSelector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>app<span style=color:#bbb>
</span><span style=color:#bbb>                </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span>In<span style=color:#bbb>
</span><span style=color:#bbb>                </span><span style=color:green;font-weight:700>values</span>:<span style=color:#bbb>
</span><span style=color:#bbb>                </span>- store<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>topologyKey</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;kubernetes.io/hostname&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>redis-server<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>redis:3.2-alpine<span style=color:#bbb>
</span></code></pre></div><p>아래 yaml 스니펫의 웹서버 디플로이먼트는 <code>podAntiAffinity</code> 와 <code>podAffinity</code> 설정을 가지고 있다. 이렇게 하면 스케줄러에 모든 레플리카는 셀렉터 레이블이 <code>app=store</code> 인 파드와 함께 위치해야 한다. 또한 각 웹 서버 레플리카가 단일 노드의 같은 위치에 있지 않도록 한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>web-server<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>web-store<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>web-store<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>affinity</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>podAntiAffinity</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>requiredDuringSchedulingIgnoredDuringExecution</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span>- <span style=color:green;font-weight:700>labelSelector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>app<span style=color:#bbb>
</span><span style=color:#bbb>                </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span>In<span style=color:#bbb>
</span><span style=color:#bbb>                </span><span style=color:green;font-weight:700>values</span>:<span style=color:#bbb>
</span><span style=color:#bbb>                </span>- web-store<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>topologyKey</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;kubernetes.io/hostname&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>podAffinity</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>requiredDuringSchedulingIgnoredDuringExecution</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span>- <span style=color:green;font-weight:700>labelSelector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>app<span style=color:#bbb>
</span><span style=color:#bbb>                </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span>In<span style=color:#bbb>
</span><span style=color:#bbb>                </span><span style=color:green;font-weight:700>values</span>:<span style=color:#bbb>
</span><span style=color:#bbb>                </span>- store<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>topologyKey</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;kubernetes.io/hostname&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>web-app<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.16-alpine<span style=color:#bbb>
</span></code></pre></div><p>만약 위의 두 디플로이먼트를 생성하면 세 개의 노드가 있는 클러스터는 다음과 같아야 한다.</p>
<table>
<thead>
<tr>
<th style=text-align:center>node-1</th>
<th style=text-align:center>node-2</th>
<th style=text-align:center>node-3</th>
</tr>
</thead>
<tbody>
<tr>
<td style=text-align:center><em>webserver-1</em></td>
<td style=text-align:center><em>webserver-2</em></td>
<td style=text-align:center><em>webserver-3</em></td>
</tr>
<tr>
<td style=text-align:center><em>cache-1</em></td>
<td style=text-align:center><em>cache-2</em></td>
<td style=text-align:center><em>cache-3</em></td>
</tr>
</tbody>
</table>
<p>여기서 볼 수 있듯이 <code>web-server</code> 의 세 레플리카들이 기대했던 것처럼 자동으로 캐시와 함께 위치하게 된다.</p>
<pre><code>kubectl get pods -o wide
</code></pre><p>출력은 다음과 유사할 것이다.</p>
<pre><code>NAME                           READY     STATUS    RESTARTS   AGE       IP           NODE
redis-cache-1450370735-6dzlj   1/1       Running   0          8m        10.192.4.2   kube-node-3
redis-cache-1450370735-j2j96   1/1       Running   0          8m        10.192.2.2   kube-node-1
redis-cache-1450370735-z73mh   1/1       Running   0          8m        10.192.3.1   kube-node-2
web-server-1287567482-5d4dz    1/1       Running   0          7m        10.192.2.3   kube-node-1
web-server-1287567482-6f7v5    1/1       Running   0          7m        10.192.4.3   kube-node-3
web-server-1287567482-s330j    1/1       Running   0          7m        10.192.3.2   kube-node-2
</code></pre><h5 id=절대-동일한-노드에-위치시키지-않게-하기>절대 동일한 노드에 위치시키지 않게 하기</h5>
<p>위의 예시에서 <code>topologyKey:"kubernetes.io/hostname"</code> 과 함께 <code>PodAntiAffinity</code> 규칙을 사용해서
두 개의 인스터스가 동일한 호스트에 있지 않도록 redis 클러스터를 배포한다.
같은 기술을 사용해서 고 가용성을 위해 안티-어피니티로 구성된 스테이트풀셋의 예시는
<a href=/ko/docs/tutorials/stateful-application/zookeeper/#%EB%85%B8%EB%93%9C-%EC%8B%A4%ED%8C%A8-%EB%B0%A9%EC%A7%80>ZooKeeper 튜토리얼</a>을 본다.</p>
<h2 id=nodename>nodeName</h2>
<p><code>nodeName</code> 은 가장 간단한 형태의 노트 선택 제약 조건이지만,
한계로 인해 일반적으로는 사용하지 않는다.
<code>nodeName</code> 은 PodSpec의 필드이다. 만약 비어있지 않으면, 스케줄러는
파드를 무시하고 명명된 노드에서 실행 중인 kubelet이
파드를 실행하려고 한다. 따라서 만약 PodSpec에 <code>nodeName</code> 가
제공된 경우, 노드 선택을 위해 위의 방법보다 우선한다.</p>
<p><code>nodeName</code> 을 사용해서 노드를 선택할 때의 몇 가지 제한은 다음과 같다.</p>
<ul>
<li>만약 명명된 노드가 없으면, 파드가 실행되지 않고
따라서 자동으로 삭제될 수 있다.</li>
<li>만약 명명된 노드에 파드를 수용할 수 있는
리소스가 없는 경우 파드가 실패하고, 그 이유는 다음과 같이 표시된다.
예: OutOfmemory 또는 OutOfcpu.</li>
<li>클라우드 환경의 노드 이름은 항상 예측 가능하거나
안정적인 것은 아니다.</li>
</ul>
<p>여기에 <code>nodeName</code> 필드를 사용하는 파드 설정 파일 예시가 있다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>nodeName</span>:<span style=color:#bbb> </span>kube-01<span style=color:#bbb>
</span></code></pre></div><p>위 파드는 kube-01 노드에서 실행될 것이다.</p>
<h2 id=다음-내용>다음 내용</h2>
<p><a href=/ko/docs/concepts/scheduling-eviction/taint-and-toleration/>테인트</a>는 노드가 특정 파드들을 <em>쫓아낼</em> 수 있다.</p>
<p><a href=https://git.k8s.io/community/contributors/design-proposals/scheduling/nodeaffinity.md>노드 어피니티</a>와
<a href=https://git.k8s.io/community/contributors/design-proposals/scheduling/podaffinity.md>파드간 어피니티/안티-어피니티</a>에 대한 디자인 문서에는
이러한 기능에 대한 추가 배경 정보가 있다.</p>
<p>파드가 노드에 할당되면 kubelet은 파드를 실행하고 노드의 로컬 리소스를 할당한다.
<a href=/docs/tasks/administer-cluster/topology-manager/>토폴로지 매니저</a>는
노드 수준의 리소스 할당 결정에 참여할 수 있다.</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-da22fe2278df236f71efbe672f392677>9.3 - 파드 오버헤드</h1>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.18 [beta]</code>
</div>
<p>노드 위에서 파드를 구동할 때, 파드는 그 자체적으로 많은 시스템 리소스를 사용한다.
이러한 리소스는 파드 내의 컨테이너들을 구동하기 위한 리소스 이외에 추가적으로 필요한 것이다.
<em>파드 오버헤드</em> 는 컨테이너 리소스 요청과 상한 위에서 파드의 인프라에 의해
소비되는 리소스를 계산하는 기능이다.</p>
<p>쿠버네티스에서 파드의 오버헤드는 파드의
<a href=/ko/docs/concepts/containers/runtime-class/>런타임클래스</a> 와 관련된 오버헤드에 따라
<a href=/docs/reference/access-authn-authz/extensible-admission-controllers/#what-are-admission-webhooks>어드미션</a>
이 수행될 때 지정된다.</p>
<p>파드 오버헤드가 활성화 되면, 파드를 노드에 스케줄링 할 때 컨테이너 리소스 요청의 합에
파드의 오버헤드를 추가해서 스케줄링을 고려한다. 마찬가지로, kubelet은 파드의 cgroups 크기를 변경하거나
파드의 축출 등급을 부여할 때에도 파드의 오버헤드를 포함하여 고려한다.</p>
<h2 id=set-up>파드 오버헤드 활성화하기</h2>
<p>기능 활성화를 위해 클러스터에서
<code>PodOverhead</code> <a href=/ko/docs/reference/command-line-tools-reference/feature-gates/>기능 게이트</a>가 활성화되어 있고(1.18 버전에서는 기본적으로 활성화),
<code>overhead</code> 필드를 정의하는 <code>RuntimeClass</code> 가 사용되고 있는지 확인해야 한다.</p>
<h2 id=사용-예제>사용 예제</h2>
<p>파드 오버헤드 기능을 사용하기 위하여, <code>overhead</code> 필드를 정의하는 런타임클래스가 필요하다.
예를 들어, 가상 머신 및 게스트 OS에 대하여 파드 당 120 MiB를 사용하는
가상화 컨테이너 런타임의 런타임클래스의 경우 다음과 같이 정의 할 수 있다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>RuntimeClass<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>node.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>kata-fc<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>handler</span>:<span style=color:#bbb> </span>kata-fc<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>overhead</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>podFixed</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;120Mi&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;250m&#34;</span><span style=color:#bbb>
</span></code></pre></div><p><code>kata-fc</code> 런타임클래스 핸들러를 지정하는 워크로드는 리소스 쿼터 계산,
노드 스케줄링 및 파드 cgroup 크기 조정을 위하여 메모리와 CPU 오버헤드를 고려한다.</p>
<p>주어진 예제 워크로드 test-pod의 구동을 고려해보자.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>runtimeClassName</span>:<span style=color:#bbb> </span>kata-fc<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>busybox-ctr<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>stdin</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>tty</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span>500m<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>100Mi<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-ctr<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span>1500m<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>100Mi<span style=color:#bbb>
</span></code></pre></div><p>어드미션 수행 시에, <a href=/docs/reference/access-authn-authz/admission-controllers/>어드미션 컨트롤러</a>는
런타임클래스에 기술된 <code>overhead</code> 를 포함하기 위하여 워크로드의 PodSpec 항목을 갱신한다. 만약 PodSpec이 이미 해당 필드에 정의되어 있으면,
파드는 거부된다. 주어진 예제에서, 오직 런타임클래스의 이름만이 정의되어 있기 때문에, 어드미션 컨트롤러는 파드가
<code>overhead</code> 를 포함하도록 변경한다.</p>
<p>런타임클래스의 어드미션 수행 후에, 파드의 스펙이 갱신된 것을 확인할 수 있다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl get pod test-pod -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.spec.overhead}&#39;</span>
</code></pre></div><p>명령 실행 결과는 다음과 같다.</p>
<pre><code>map[cpu:250m memory:120Mi]
</code></pre><p>만약 리소스쿼터 항목이 정의되어 있다면, 컨테이너의 리소스 요청의 합에는
<code>overhead</code> 필드도 추가된다.</p>
<p>kube-scheduler 는 어떤 노드에 파드가 기동 되어야 할지를 정할 때, 파드의 <code>overhead</code> 와
해당 파드에 대한 컨테이너의 리소스 요청의 합을 고려한다. 이 예제에서, 스케줄러는
리소스 요청과 파드의 오버헤드를 더하고, 2.25 CPU와 320 MiB 메모리가 사용 가능한 노드를 찾는다.</p>
<p>일단 파드가 특정 노드에 스케줄링 되면, 해당 노드에 있는 kubelet 은 파드에 대한 새로운 <a class=glossary-tooltip title="선택적으로 리소스를 격리, 관리, 제한하는 리눅스 프로세스의 그룹." data-toggle=tooltip data-placement=top href="/ko/docs/reference/glossary/?all=true#term-cgroup" target=_blank aria-label=cgroup>cgroup</a>을 생성한다.
기본 컨테이너 런타임이 만들어내는 컨테이너들은 이 파드 안에 존재한다.</p>
<p>만약 각 컨테이너에 대하여 QoS가 보장되었거나 향상이 가능하도록 QoS 의 리소스 상한 제한이 걸려있으면,
kubelet 은 해당 리소스(CPU의 경우 cpu.cfs_quota_us, 메모리의 경우 memory.limit_in_bytes)와 연관된 파드의
cgroup 의 상한선을 설정한다. 이 상한선은 컨테이너 리소스 상한과 PodSpec에
정의된 <code>overhead</code> 의 합에 기반한다.</p>
<p>CPU의 경우, 만약 파드가 보장형 또는 버스트형 QoS로 설정되었으면, kubelet은 PodSpec에 정의된 <code>overhead</code> 에 컨테이너의
리소스 요청의 합을 더한 값을 <code>cpu.shares</code> 로 설정한다.</p>
<p>다음의 예제를 참고하여, 워크로드에 대하여 컨테이너의 리소스 요청을 확인하자.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl get pod test-pod -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.spec.containers[*].resources.limits}&#39;</span>
</code></pre></div><p>컨테이너 리소스 요청의 합은 각각 CPU 2000m 와 메모리 200MiB 이다.</p>
<pre><code>map[cpu: 500m memory:100Mi] map[cpu:1500m memory:100Mi]
</code></pre><p>노드에서 측정된 내용과 비교하여 확인해보자.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl describe node | grep test-pod -B2
</code></pre></div><p>CPU 2250m와 메모리 320MiB 가 리소스로 요청되었으며, 이 결과는 파드의 오버헤드를 포함한다.</p>
<pre><code>  Namespace                   Name                CPU Requests  CPU Limits   Memory Requests  Memory Limits  AGE
  ---------                   ----                ------------  ----------   ---------------  -------------  ---
  default                     test-pod            2250m (56%)   2250m (56%)  320Mi (1%)       320Mi (1%)     36m
</code></pre><h2 id=파드-cgroup-상한-확인하기>파드 cgroup 상한 확인하기</h2>
<p>워크로드가 실행 중인 노드에서 파드의 메모리 cgroup들을 확인 해보자. 다음의 예제에서, <a href=https://github.com/kubernetes-sigs/cri-tools/blob/master/docs/crictl.md><code>crictl</code></a>은 노드에서 사용되며,
CRI-호환 컨테이너 런타임을 위해서 노드에서 사용할 수 있는 CLI 를 제공한다.
파드의 오버헤드 동작을 보여주는 좋은 예이며,
사용자가 노드에서 직접 cgroup들을 확인하지 않아도 된다.</p>
<p>먼저 특정 노드에서 파드의 식별자를 확인해 보자.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#080;font-style:italic># 파드가 스케줄 된 노드에서 이것을 실행</span>
<span style=color:#b8860b>POD_ID</span><span style=color:#666>=</span><span style=color:#b44>&#34;</span><span style=color:#a2f;font-weight:700>$(</span>sudo crictl pods --name test-pod -q<span style=color:#a2f;font-weight:700>)</span><span style=color:#b44>&#34;</span>
</code></pre></div><p>여기에서, 파드의 cgroup 경로를 확인할 수 있다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#080;font-style:italic># 파드가 스케줄 된 노드에서 이것을 실행</span>
sudo crictl inspectp -o<span style=color:#666>=</span>json <span style=color:#b8860b>$POD_ID</span> | grep cgroupsPath
</code></pre></div><p>명령의 결과로 나온 cgroup 경로는 파드의 <code>pause</code> 컨테이너를 포함한다. 파드 레벨의 cgroup은 하나의 디렉터리이다.</p>
<pre><code>        &quot;cgroupsPath&quot;: &quot;/kubepods/podd7f4b509-cf94-4951-9417-d1087c92a5b2/7ccf55aee35dd16aca4189c952d83487297f3cd760f1bbf09620e206e7d0c27a&quot;
</code></pre><p>아래의 특정한 경우에, 파드 cgroup 경로는 <code>kubepods/podd7f4b509-cf94-4951-9417-d1087c92a5b2</code> 이다. 메모리의 파드 레벨 cgroup 설정을 확인하자.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#080;font-style:italic># 파드가 스케줄 된 노드에서 이것을 실행.</span>
<span style=color:#080;font-style:italic># 또한 사용자의 파드에 할당된 cgroup 이름에 맞춰 해당 이름을 수정.</span>
 cat /sys/fs/cgroup/memory/kubepods/podd7f4b509-cf94-4951-9417-d1087c92a5b2/memory.limit_in_bytes
</code></pre></div><p>예상대로 320 MiB 이다.</p>
<pre><code>335544320
</code></pre><h3 id=관찰성>관찰성</h3>
<p><code>kube_pod_overhead</code> 항목은 <a href=https://github.com/kubernetes/kube-state-metrics>kube-state-metrics</a>
에서 사용할 수 있어, 파드 오버헤드가 사용되는 시기를 식별하고,
정의된 오버헤드로 실행되는 워크로드의 안정성을 관찰할 수 있다.
이 기능은 kube-state-metrics 의 1.9 릴리스에서는 사용할 수 없지만, 다음 릴리스에서는 가능할 예정이다.
그 전까지는 소스로부터 kube-state-metric 을 빌드해야 한다.</p>
<h2 id=다음-내용>다음 내용</h2>
<ul>
<li><a href=/ko/docs/concepts/containers/runtime-class/>런타임클래스</a></li>
<li><a href=https://github.com/kubernetes/enhancements/tree/master/keps/sig-node/688-pod-overhead>파드오버헤드 디자인</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-ede4960b56a3529ee0bfe7c8fe2d09a5>9.4 - 테인트(Taints)와 톨러레이션(Tolerations)</h1>
<p><a href=/ko/docs/concepts/scheduling-eviction/assign-pod-node/#%EC%96%B4%ED%94%BC%EB%8B%88%ED%8B%B0-affinity-%EC%99%80-%EC%95%88%ED%8B%B0-%EC%96%B4%ED%94%BC%EB%8B%88%ED%8B%B0-anti-affinity><em>노드 어피니티</em></a>는
<a class=glossary-tooltip title="노드는 쿠버네티스의 작업 장비(worker machine)이다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/architecture/nodes/ target=_blank aria-label=노드>노드</a> 셋을
(기본 설정 또는 어려운 요구 사항으로) <em>끌어들이는</em> <a class=glossary-tooltip title="파드는 클러스터에서 실행 중인 컨테이너의 집합을 나타낸다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/pods/ target=_blank aria-label=파드>파드</a>의 속성이다.
<em>테인트</em> 는 그 반대로, 노드가 파드 셋을 제외할 수 있다.</p>
<p><em>톨러레이션</em> 은 파드에 적용되며, 파드를 일치하는 테인트가 있는 노드에
스케줄되게 하지만 필수는 아니다.</p>
<p>테인트와 톨러레이션은 함께 작동하여 파드가 부적절한 노드에 스케줄되지
않게 한다. 하나 이상의 테인트가 노드에 적용된다. 이것은
노드가 테인트를 용인하지 않는 파드를 수용해서는 안 되는 것을 나타낸다.</p>
<h2 id=개요>개요</h2>
<p><a href=/docs/reference/generated/kubectl/kubectl-commands#taint>kubectl taint</a>를 사용하여 노드에 테인트을 추가한다.
예를 들면 다음과 같다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl taint nodes node1 <span style=color:#b8860b>key1</span><span style=color:#666>=</span>value1:NoSchedule
</code></pre></div><p><code>node1</code> 노드에 테인트을 배치한다. 테인트에는 키 <code>key1</code>, 값 <code>value1</code> 및 테인트 이펙트(effect) <code>NoSchedule</code> 이 있다.
이는 일치하는 톨러레이션이 없으면 파드를 <code>node1</code> 에 스케줄할 수 없음을 의미한다.</p>
<p>위의 명령으로 추가한 테인트를 제거하려면, 다음을 실행한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl taint nodes node1 <span style=color:#b8860b>key1</span><span style=color:#666>=</span>value1:NoSchedule-
</code></pre></div><p>PodSpec에서 파드에 대한 톨러레이션를 지정한다. 다음의 톨러레이션은
위의 <code>kubectl taint</code> 라인에 의해 생성된 테인트와 "일치"하므로, 어느 쪽 톨러레이션을 가진 파드이던
<code>node1</code> 에 스케줄 될 수 있다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>tolerations</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;key1&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;Equal&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;value1&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>effect</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;NoSchedule&#34;</span><span style=color:#bbb>
</span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>tolerations</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;key1&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;Exists&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>effect</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;NoSchedule&#34;</span><span style=color:#bbb>
</span></code></pre></div><p>톨러레이션을 사용하는 파드의 예는 다음과 같다.</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/ko/examples/pods/pod-with-toleration.yaml download=pods/pod-with-toleration.yaml><code>pods/pod-with-toleration.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-pod-with-toleration-yaml')" title="Copy pods/pod-with-toleration.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-pod-with-toleration-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb> </span>test<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>imagePullPolicy</span>:<span style=color:#bbb> </span>IfNotPresent<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>tolerations</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;example-key&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;Exists&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>effect</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;NoSchedule&#34;</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>지정하지 않으면 <code>operator</code> 의 기본값은 <code>Equal</code> 이다.</p>
<p>톨러레이션은 키가 동일하고 이펙트가 동일한 경우, 테인트와 "일치"한다. 그리고 다음의 경우에도 마찬가지다.</p>
<ul>
<li><code>operator</code> 가 <code>Exists</code> 인 경우(이 경우 <code>value</code> 를 지정하지 않아야 함), 또는</li>
<li><code>operator</code> 는 <code>Equal</code> 이고 <code>value</code> 는 <code>value</code> 로 같다.</li>
</ul>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> <p>두 가지 특별한 경우가 있다.</p>
<p>operator <code>Exists</code> 가 있는 비어있는 <code>key</code> 는 모든 키, 값 및 이펙트와 일치하므로
모든 것이 톨러레이션 된다.</p>
<p>비어있는 <code>effect</code> 는 모든 이펙트를 키 <code>key1</code> 와 일치시킨다.</p>
</div>
<p>위의 예는 <code>NoSchedule</code> 의 <code>effect</code> 를 사용했다. 또는, <code>PreferNoSchedule</code> 의 <code>effect</code> 를 사용할 수 있다.
이것은 <code>NoSchedule</code> 의 "기본 설정(preference)" 또는 "소프트(soft)" 버전이다. 시스템은 노드의 테인트를 허용하지 않는
파드를 배치하지 않으려고 <em>시도</em> 하지만, 필요하지는 않다. 세 번째 종류의 <code>effect</code> 는
나중에 설명할 <code>NoExecute</code> 이다.</p>
<p>동일한 노드에 여러 테인트를, 동일한 파드에 여러 톨러레이션을 둘 수 있다.
쿠버네티스가 여러 테인트 및 톨러레이션을 처리하는 방식은 필터와 같다.
모든 노드의 테인트로 시작한 다음, 파드에 일치하는 톨러레이션이 있는 것을 무시한다.
무시되지 않은 나머지 테인트는 파드에 표시된 이펙트를 가진다. 특히,</p>
<ul>
<li><code>NoSchedule</code> 이펙트가 있는 무시되지 않은 테인트가 하나 이상 있으면 쿠버네티스는 해당 노드에
파드를 스케줄하지 않는다.</li>
<li><code>NoSchedule</code> 이펙트가 있는 무시되지 않은 테인트가 없지만 <code>PreferNoSchedule</code> 이펙트가 있는
무시되지 않은 테인트가 하나 이상 있으면 쿠버네티스는 파드를 노드에 스케쥴하지 않으려고 <em>시도</em> 한다</li>
<li><code>NoExecute</code> 이펙트가 있는 무시되지 않은 테인트가 하나 이상 있으면
파드가 노드에서 축출되고(노드에서 이미 실행 중인 경우), 노드에서
스케줄되지 않는다(아직 실행되지 않은 경우).</li>
</ul>
<p>예를 들어, 이와 같은 노드를 테인트하는 경우는 다음과 같다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl taint nodes node1 <span style=color:#b8860b>key1</span><span style=color:#666>=</span>value1:NoSchedule
kubectl taint nodes node1 <span style=color:#b8860b>key1</span><span style=color:#666>=</span>value1:NoExecute
kubectl taint nodes node1 <span style=color:#b8860b>key2</span><span style=color:#666>=</span>value2:NoSchedule
</code></pre></div><p>그리고 파드에는 두 가지 톨러레이션이 있다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>tolerations</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;key1&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;Equal&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;value1&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>effect</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;NoSchedule&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;key1&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;Equal&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;value1&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>effect</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;NoExecute&#34;</span><span style=color:#bbb>
</span></code></pre></div><p>이 경우, 세 번째 테인트와 일치하는 톨러레이션이 없기 때문에, 파드는
노드에 스케줄 될 수 없다. 그러나 세 번째 테인트가 파드에서 용인되지 않는 세 가지 중
하나만 있기 때문에, 테인트가 추가될 때 노드에서 이미 실행 중인 경우,
파드는 계속 실행할 수 있다.</p>
<p>일반적으로, <code>NoExecute</code> 이펙트가 있는 테인트가 노드에 추가되면, 테인트를
용인하지 않는 파드는 즉시 축출되고, 테인트를 용인하는 파드는
축출되지 않는다. 그러나 <code>NoExecute</code> 이펙트가 있는 톨러레이션은
테인트가 추가된 후 파드가 노드에 바인딩된 시간을 지정하는
선택적 <code>tolerationSeconds</code> 필드를 지정할 수 있다. 예를 들어,</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>tolerations</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;key1&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;Equal&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;value1&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>effect</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;NoExecute&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>tolerationSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>3600</span><span style=color:#bbb>
</span></code></pre></div><p>이것은 이 파드가 실행 중이고 일치하는 테인트가 노드에 추가되면,
파드는 3600초 동안 노드에 바인딩된 후, 축출된다는 것을 의미한다. 그 전에
테인트를 제거하면, 파드가 축출되지 않는다.</p>
<h2 id=유스케이스-예시>유스케이스 예시</h2>
<p>테인트 및 톨러레이션은 파드를 노드에서 <em>멀어지게</em> 하거나 실행되지 않아야 하는
파드를 축출할 수 있는 유연한 방법이다. 유스케이스 중 일부는 다음과 같다.</p>
<ul>
<li>
<p><strong>전용 노드</strong>: 특정 사용자들이 독점적으로 사용하도록
노드 셋을 전용하려면, 해당 노드에 테인트를 추가(예:
<code>kubectl taint nodes nodename dedicated=groupName:NoSchedule</code>)한 다음 해당
톨러레이션을 그들의 파드에 추가할 수 있다(사용자 정의 [어드미션 컨트롤러]
(/docs/reference/access-authn-authz/admission-controllers/)를 작성하면 가장 쉽게 수행할 수 있음).
그런 다음 톨러레이션이 있는 파드는 테인트된(전용) 노드와
클러스터의 다른 노드를 사용할 수 있다. 노드를 특정 사용자들에게 전용으로 지정하고 <em>그리고</em>
그 사용자들이 전용 노드 <em>만</em> 사용하려면, 동일한 노드 셋에
테인트와 유사한 레이블을 추가해야 하고(예: <code>dedicated=groupName</code>),
어드미션 컨트롤러는 추가로 파드가 <code>dedicated=groupName</code> 으로 레이블이 지정된 노드에만
스케줄될 수 있도록 노드 어피니티를 추가해야 한다.</p>
</li>
<li>
<p><strong>특별한 하드웨어가 있는 노드</strong>: 작은 서브셋의 노드에 특별한
하드웨어(예: GPU)가 있는 클러스터에서는, 특별한 하드웨어가 필요하지 않는 파드를
해당 노드에서 분리하여, 나중에 도착하는 특별한 하드웨어가 필요한 파드를 위한 공간을
남겨두는 것이 바람직하다. 이는 특별한 하드웨어가 있는
노드(예: <code>kubectl taint nodes nodename special=true:NoSchedule</code> 또는
<code>kubectl taint nodes nodename special=true:PreferNoSchedule</code>)에 테인트를 추가하고
특별한 하드웨어를 사용하는 파드에 해당 톨러레이션을 추가하여 수행할 수 있다. 전용 노드 유스케이스에서와 같이,
사용자 정의 <a href=/docs/reference/access-authn-authz/admission-controllers/>어드미션 컨트롤러</a>를
사용하여 톨러레이션를 적용하는 것이 가장 쉬운 방법이다.
예를 들어, <a href=/ko/docs/concepts/configuration/manage-resources-containers/#%ED%99%95%EC%9E%A5%EB%90%9C-%EB%A6%AC%EC%86%8C%EC%8A%A4>확장된
리소스</a>를
사용하여 특별한 하드웨어를 나타내고, 확장된 리소스 이름으로
특별한 하드웨어 노드를 테인트시키고
<a href=/docs/reference/access-authn-authz/admission-controllers/#extendedresourcetoleration>ExtendedResourceToleration</a>
어드미션 컨트롤러를 실행하는 것을 권장한다. 이제, 노드가 테인트되었으므로, 톨러레이션이 없는
파드는 스케줄되지 않는다. 그러나 확장된 리소스를 요청하는 파드를 제출하면,
<code>ExtendedResourceToleration</code> 어드미션 컨트롤러가
파드에 올바른 톨러레이션을 자동으로 추가하고 해당 파드는
특별한 하드웨어 노드에서 스케줄된다. 이렇게 하면 이러한 특별한 하드웨어 노드가
해당 하드웨어를 요청하는 파드가 전용으로 사용하며 파드에 톨러레이션을
수동으로 추가할 필요가 없다.</p>
</li>
<li>
<p><strong>테인트 기반 축출</strong>: 노드 문제가 있을 때 파드별로
구성 가능한 축출 동작은 다음 섹션에서 설명한다.</p>
</li>
</ul>
<h2 id=테인트-기반-축출>테인트 기반 축출</h2>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.18 [stable]</code>
</div>
<p>앞에서 우리는 노드에서 이미 실행 중인 파드에 영향을 주는 <code>NoExecute</code> 테인트 이펙트를
다음과 같이 언급했다.</p>
<ul>
<li>테인트를 용인하지 않는 파드는 즉시 축출된다.</li>
<li>톨러레이션 명세에 <code>tolerationSeconds</code> 를 지정하지 않고
테인트를 용인하는 파드는 계속 바인딩된다.</li>
<li><code>tolerationSeconds</code> 가 지정된 테인트를 용인하는 파드는 지정된
시간 동안 바인딩된 상태로 유지된다.</li>
</ul>
<p>노드 컨트롤러는 특정 컨디션이 참일 때 자동으로
노드를 테인트시킨다. 다음은 빌트인 테인트이다.</p>
<ul>
<li><code>node.kubernetes.io/not-ready</code>: 노드가 준비되지 않았다. 이는 NodeCondition
<code>Ready</code> 가 "<code>False</code>"로 됨에 해당한다.</li>
<li><code>node.kubernetes.io/unreachable</code>: 노드가 노드 컨트롤러에서 도달할 수 없다. 이는
NodeCondition <code>Ready</code> 가 "<code>Unknown</code>"로 됨에 해당한다.</li>
<li><code>node.kubernetes.io/memory-pressure</code>: 노드에 메모리 할당 압박이 있다.</li>
<li><code>node.kubernetes.io/disk-pressure</code>: 노드에 디스크 할당 압박이 있다.</li>
<li><code>node.kubernetes.io/pid-pressure</code>: 노드에 PID 할당 압박이 있다.</li>
<li><code>node.kubernetes.io/network-unavailable</code>: 노드의 네트워크를 사용할 수 없다.</li>
<li><code>node.kubernetes.io/unschedulable</code>: 노드를 스케줄할 수 없다.</li>
<li><code>node.cloudprovider.kubernetes.io/uninitialized</code>: "외부" 클라우드 공급자로
kubelet을 시작하면, 이 테인트가 노드에서 사용 불가능으로 표시되도록
설정된다. 클라우드-컨트롤러-관리자의 컨트롤러가 이 노드를 초기화하면,
kubelet이 이 테인트를 제거한다.</li>
</ul>
<p>노드가 축출될 경우, 노드 컨트롤러 또는 kubelet은 <code>NoExecute</code> 이펙트로 관련
테인트를 추가한다. 장애 상태가 정상으로 돌아오면 kubelet 또는 노드 컨트롤러가
관련 테인트를 제거할 수 있다.</p>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> 콘트롤 플레인은 노드에 새 테인트를 추가하는 비율을 제한한다.
이 비율-제한은 많은 노드가 동시에 도달할 수 없을 때(예를 들어, 네트워크 중단으로)
트리거될 축출 개수를 관리한다.
</div>
<p>이 기능을 <code>tolerationSeconds</code> 와 함께 사용하면, 파드에서
이러한 문제 중 하나 또는 둘 다가 있는 노드에 바인딩된 기간을 지정할 수 있다.</p>
<p>예를 들어, 로컬 상태가 많은 애플리케이션은 네트워크 분할의 장애에서
네트워크가 복구된 후에 파드가 축출되는 것을 피하기 위해
오랫동안 노드에 바인딩된 상태를 유지하려고 할 수 있다.
이 경우 파드가 사용하는 톨러레이션은 다음과 같다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>tolerations</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;node.kubernetes.io/unreachable&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;Exists&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>effect</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;NoExecute&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>tolerationSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>6000</span><span style=color:#bbb>
</span></code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> <p>쿠버네티스는 사용자나 컨트롤러에서 명시적으로 설정하지 않았다면, 자동으로
<code>node.kubernetes.io/not-ready</code> 와 <code>node.kubernetes.io/unreachable</code> 에 대해
<code>tolerationSeconds=300</code> 으로
톨러레이션을 추가한다.</p>
<p>자동으로 추가된 이 톨러레이션은 이러한 문제 중 하나가 감지된 후 5분 동안
파드가 노드에 바인딩된 상태를 유지함을 의미한다.</p>
</div>
<p><a href=/ko/docs/concepts/workloads/controllers/daemonset/>데몬셋</a> 파드는 <code>tolerationSeconds</code> 가 없는
다음 테인트에 대해 <code>NoExecute</code> 톨러레이션를 가지고 생성된다.</p>
<ul>
<li><code>node.kubernetes.io/unreachable</code></li>
<li><code>node.kubernetes.io/not-ready</code></li>
</ul>
<p>이렇게 하면 이러한 문제로 인해 데몬셋 파드가 축출되지 않는다.</p>
<h2 id=컨디션-condition-을-기준으로-노드-테인트하기>컨디션(condition)을 기준으로 노드 테인트하기</h2>
<p>컨트롤 플레인은 노드 <a class=glossary-tooltip title="API 서버를 통해 클러스터의 공유된 상태를 감시하고, 현재 상태를 원하는 상태로 이행시키는 컨트롤 루프." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/architecture/controller/ target=_blank aria-label=컨트롤러>컨트롤러</a>를 이용하여
<a href=/ko/docs/concepts/scheduling-eviction/node-pressure-eviction/#node-conditions>노드 컨디션</a>에 대한 <code>NoSchedule</code> 효과를 사용하여 자동으로 테인트를 생성한다.</p>
<p>스케줄러는 스케줄링 결정을 내릴 때 노드 컨디션을 확인하는 것이 아니라 테인트를 확인한다.
이렇게 하면 노드 컨디션이 스케줄링에 직접적인 영향을 주지 않는다.
예를 들어 <code>DiskPressure</code> 노드 컨디션이 활성화된 경우
컨트롤 플레인은 <code>node.kubernetes.io/disk-pressure</code> 테인트를 추가하고 영향을 받는 노드에 새 파드를 할당하지 않는다.
<code>MemoryPressure</code> 노드 컨디션이 활성화되면
컨트롤 플레인이 <code>node.kubernetes.io/memory-pressure</code> 테인트를 추가한다.</p>
<p>새로 생성된 파드에 파드 톨러레이션을 추가하여 노드 컨디션을 무시하도록 할 수 있다.
또한 컨트롤 플레인은 <code>BestEffort</code> 이외의
<a class=glossary-tooltip title="QoS 클래스(서비스 품질 클래스)는 쿠버네티스가 클러스터 안의 파드들을 여러 클래스로 구분하고, 스케줄링과 축출(eviction)에 대한 결정을 내리는 방법을 제공한다." data-toggle=tooltip data-placement=top href="/ko/docs/reference/glossary/?all=true#term-qos-class" target=_blank aria-label="QoS 클래스">QoS 클래스</a>를 가지는 파드에
<code>node.kubernetes.io/memory-pressure</code> 톨러레이션을 추가한다.
이는 쿠버네티스가 <code>Guaranteed</code> 또는 <code>Burstable</code> QoS 클래스를 갖는 파드(메모리 요청이 설정되지 않은 파드 포함)를
마치 그 파드들이 메모리 압박에 대처 가능한 것처럼 다루는 반면,
새로운 <code>BestEffort</code> 파드는 영향을 받는 노드에 할당하지 않기 때문이다.</p>
<p>데몬셋 컨트롤러는 다음의 <code>NoSchedule</code> 톨러레이션을
모든 데몬에 자동으로 추가하여, 데몬셋이 중단되는 것을 방지한다.</p>
<ul>
<li><code>node.kubernetes.io/memory-pressure</code></li>
<li><code>node.kubernetes.io/disk-pressure</code></li>
<li><code>node.kubernetes.io/pid-pressure</code> (1.14 이상)</li>
<li><code>node.kubernetes.io/unschedulable</code> (1.10 이상)</li>
<li><code>node.kubernetes.io/network-unavailable</code> (<em>호스트 네트워크만 해당</em>)</li>
</ul>
<p>이러한 톨러레이션을 추가하면 이전 버전과의 호환성이 보장된다. 데몬셋에
임의의 톨러레이션을 추가할 수도 있다.</p>
<h2 id=다음-내용>다음 내용</h2>
<ul>
<li><a href=/ko/docs/concepts/scheduling-eviction/node-pressure-eviction/>노드-압박(node-pressure) 축출</a>과 어떻게 구성하는지에 대해 알아보기</li>
<li><a href=/ko/docs/concepts/scheduling-eviction/pod-priority-preemption/>파드 우선순위</a>에 대해 알아보기</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-78e0431b4b7516092662a7c289cbb304>9.5 - 노드-압박 축출</h1>
<p>노드-압박 축출은 <a class=glossary-tooltip title="클러스터의 각 노드에서 실행되는 에이전트. Kubelet은 파드에서 컨테이너가 확실하게 동작하도록 관리한다." data-toggle=tooltip data-placement=top href=/docs/reference/generated/kubelet target=_blank aria-label=kubelet>kubelet</a>이 노드의 자원을 회수하기 위해
파드를 능동적으로 중단시키는 절차이다.</br></p>
<p><a class=glossary-tooltip title="클러스터의 각 노드에서 실행되는 에이전트. Kubelet은 파드에서 컨테이너가 확실하게 동작하도록 관리한다." data-toggle=tooltip data-placement=top href=/docs/reference/generated/kubelet target=_blank aria-label=kubelet>kubelet</a>은
클러스터 노드의 CPU, 메모리, 디스크 공간, 파일시스템 inode와 같은 자원을 모니터링한다.
이러한 자원 중 하나 이상이 특정 소모 수준에 도달하면,
kubelet은 하나 이상의 파드를 능동적으로 중단시켜
자원을 회수하고 고갈 상황을 방지할 수 있다.</p>
<p>노드-압박 축출 과정에서, kubelet은 축출할 파드의 <code>PodPhase</code>를
<code>Failed</code>로 설정한다. 이로써 파드가 종료된다.</p>
<p>노드-압박 축출은
<a href=/ko/docs/concepts/scheduling-eviction/api-eviction/>API를 이용한 축출</a>과는 차이가 있다.</p>
<p>kubelet은 이전에 설정된 <code>PodDisruptionBudget</code> 값이나 파드의 <code>terminationGracePeriodSeconds</code> 값을 따르지 않는다.
<a href=#soft-eviction-thresholds>소프트 축출 임계값</a>을 사용하는 경우,
kubelet은 이전에 설정된 <code>eviction-max-pod-grace-period</code> 값을 따른다.
<a href=#hard-eviction-thresholds>하드 축출 임계값</a>을 사용하는 경우, 파드 종료 시 <code>0s</code> 만큼 기다린 후 종료한다(즉, 기다리지 않고 바로 종료한다).</p>
<p>실패한 파드를 새로운 파드로 교체하는
<a class=glossary-tooltip title="워크로드는 클러스터의 컨테이너를 동작시키고 관리하기 위해 사용하는 오브젝트이다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/ target=_blank aria-label=워크로드>워크로드</a> 리소스(예:
<a class=glossary-tooltip title="내구성이 있는 스토리지와 파드별로 지속성 식별자를 사용해서 파드 집합의 디플로이먼트와 스케일링을 관리한다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/controllers/statefulset/ target=_blank aria-label=스테이트풀셋(StatefulSet)>스테이트풀셋(StatefulSet)</a> 또는
<a class=glossary-tooltip title="클러스터에서 복제된 애플리케이션을 관리한다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/controllers/deployment/ target=_blank aria-label=디플로이먼트(Deployment)>디플로이먼트(Deployment)</a>)가 파드를 관리하는 경우,
컨트롤 플레인이나 <code>kube-controller-manager</code>가 축출된 파드를 대신할 새 파드를 생성한다.</p>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> kubelet은 최종 사용자 파드를 종료하기 전에
먼저 <a href=#reclaim-node-resources>노드 수준 자원을 회수</a>하려고 시도한다.
예를 들어, 디스크 자원이 부족하면 먼저 사용하지 않는 컨테이너 이미지를 제거한다.
</div>
<p>kubelet은 축출 결정을 내리기 위해 다음과 같은 다양한 파라미터를 사용한다.</p>
<ul>
<li>축출 신호</li>
<li>축출 임계값</li>
<li>모니터링 간격</li>
</ul>
<h3 id=eviction-signals>축출 신호</h3>
<p>축출 신호는 특정 시점에서 특정 자원의 현재 상태이다.
Kubelet은 노드에서 사용할 수 있는 리소스의 최소량인
축출 임계값과 축출 신호를 비교하여
축출 결정을 내린다.</p>
<p>Kubelet은 다음과 같은 축출 신호를 사용한다.</p>
<table>
<thead>
<tr>
<th>축출 신호</th>
<th>설명</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>memory.available</code></td>
<td><code>memory.available</code> := <code>node.status.capacity[memory]</code> - <code>node.stats.memory.workingSet</code></td>
</tr>
<tr>
<td><code>nodefs.available</code></td>
<td><code>nodefs.available</code> := <code>node.stats.fs.available</code></td>
</tr>
<tr>
<td><code>nodefs.inodesFree</code></td>
<td><code>nodefs.inodesFree</code> := <code>node.stats.fs.inodesFree</code></td>
</tr>
<tr>
<td><code>imagefs.available</code></td>
<td><code>imagefs.available</code> := <code>node.stats.runtime.imagefs.available</code></td>
</tr>
<tr>
<td><code>imagefs.inodesFree</code></td>
<td><code>imagefs.inodesFree</code> := <code>node.stats.runtime.imagefs.inodesFree</code></td>
</tr>
<tr>
<td><code>pid.available</code></td>
<td><code>pid.available</code> := <code>node.stats.rlimit.maxpid</code> - <code>node.stats.rlimit.curproc</code></td>
</tr>
</tbody>
</table>
<p>이 표에서, <code>설명</code> 열은 kubelet이 축출 신호 값을 계산하는 방법을 나타낸다.
각 축출 신호는 백분율 또는 숫자값을 지원한다.
Kubelet은 총 용량 대비 축출 신호의 백분율 값을
계산한다.</p>
<p><code>memory.available</code> 값은 <code>free -m</code>과 같은 도구가 아니라 cgroupfs로부터 도출된다.
이는 <code>free -m</code>이 컨테이너 안에서는 동작하지 않고, 또한 사용자가
<a href=/docs/tasks/administer-cluster/reserve-compute-resources/#node-allocatable>node allocatable</a>
기능을 사용하는 경우 자원 부족에 대한 결정은 루트 노드뿐만 아니라
cgroup 계층 구조의 최종 사용자 파드 부분에서도 지역적으로 이루어지기 때문에 중요하다.
이 <a href=/examples/admin/resource/memory-available.sh>스크립트</a>는
kubelet이 <code>memory.available</code>을 계산하기 위해 수행하는 동일한 단계들을 재현한다.
kubelet은 메모리 압박 상황에서 메모리가 회수 가능하다고 가정하므로,
inactive_file(즉, 비활성 LRU 목록의 파일 기반 메모리 바이트 수)을
계산에서 제외한다.</p>
<p>kubelet은 다음과 같은 파일시스템 파티션을 지원한다.</p>
<ol>
<li><code>nodefs</code>: 노드의 메인 파일시스템이며, 로컬 디스크 볼륨, emptyDir,
로그 스토리지 등에 사용된다. 예를 들어 <code>nodefs</code>는 <code>/var/lib/kubelet/</code>을 포함한다.</li>
<li><code>imagefs</code>: 컨테이너 런타임이 컨테이너 이미지 및
컨테이너 쓰기 가능 레이어를 저장하는 데 사용하는 선택적 파일시스템이다.</li>
</ol>
<p>Kubelet은 이러한 파일시스템을 자동으로 검색하고 다른 파일시스템은 무시한다.
Kubelet은 다른 구성은 지원하지 않는다.</p>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> 일부 kubelet 가비지 수집 기능은 더 이상 사용되지 않으며 축출로 대체되었다.
사용 중지된 기능의 목록은 <a href=/ko/docs/concepts/architecture/garbage-collection/#containers-images>kubelet 가비지 수집 사용 중단</a>을 참조한다.
</div>
<h3 id=축출-임계값>축출 임계값</h3>
<p>kubelet이 축출 결정을 내릴 때 사용하는 축출 임계값을
사용자가 임의로 설정할 수 있다.</p>
<p>축출 임계값은 <code>[eviction-signal][operator][quantity]</code> 형태를 갖는다.</p>
<ul>
<li><code>eviction-signal</code>에는 사용할 <a href=#eviction-signals>축출 신호</a>를 적는다.</li>
<li><code>operator</code>에는 <a href=https://ko.wikipedia.org/wiki/%EA%B4%80%EA%B3%84%EC%97%B0%EC%82%B0%EC%9E%90#%ED%91%9C%EC%A4%80_%EA%B4%80%EA%B3%84%EC%97%B0%EC%82%B0%EC%9E%90>관계연산자</a>를
적는다(예: <code>&lt;</code> - 미만)</li>
<li><code>quantity</code>에는 <code>1Gi</code>와 같이 축출 임계값 수치를 적는다.
<code>quantity</code>에 들어가는 값은 쿠버네티스가 사용하는 수치 표현 방식과 맞아야 한다.
숫자값 또는 백분율(<code>%</code>)을 사용할 수 있다.</li>
</ul>
<p>예를 들어, 노드에 총 <code>10Gi</code>의 메모리가 있고
<code>1Gi</code> 아래로 내려갔을 때 축출이 시작되도록 만들고 싶으면, 축출 임계값을
<code>memory.available&lt;10%</code> 또는 <code>memory.available&lt;1Gi</code> 형태로 정할 수 있다. 둘을 동시에 사용할 수는 없다.</p>
<p>소프트 축출 임계값과 하드 축출 임계값을 설정할 수 있다.</p>
<h4 id=soft-eviction-thresholds>소프트 축출 임계값</h4>
<p>소프트 축출 임계값은 관리자가 설정하는 유예 시간(필수)과 함께 정의된다.
kubelet은 유예 시간이 초과될 때까지 파드를 제거하지 않는다.
유예 시간이 지정되지 않으면 kubelet 시작 시
오류가 반환된다.</p>
<p>kubelet이 축출 과정에서 사용할 수 있도록,
'소프트 축출 임계값'과 '최대 허용 파드 종료 유예 시간' 둘 다를 설정할 수 있다.
'최대 허용 파드 종료 유예 시간'이 설정되어 있는 상태에서 '소프트 축출 임계값'에 도달하면,
kubelet은 두 유예 시간 중 작은 쪽을 적용한다.
'최대 허용 파드 종료 유예 시간'을 설정하지 않으면,
kubelet은 축출된 파드를 유예 시간 없이 즉시 종료한다.</p>
<p>소프트 축출 임계값을 설정할 때 다음과 같은 플래그를 사용할 수 있다.</p>
<ul>
<li><code>eviction-soft</code>: 축출 임계값(예: <code>memory.available&lt;1.5Gi</code>)의 집합이며,
지정된 유예 시간동안 이 축출 임계값 조건이 충족되면 파드 축출이 트리거된다.</li>
<li><code>eviction-soft-grace-period</code>: 축출 유예 시간의 집합이며,
소프트 축출 임계값 조건이 이 유예 시간동안 충족되면 파드 축출이 트리거된다.</li>
<li><code>eviction-max-pod-grace-period</code>: '최대 허용 파드 종료 유예 시간(단위: 초)'이며,
소프트 축출 임계값 조건이 충족되어 파드를 종료할 때 사용한다.</li>
</ul>
<h4 id=hard-eviction-thresholds>하드 축출 임계값</h4>
<p>하드 축출 임계값에는 유예 시간이 없다. 하드 축출 임계값 조건이 충족되면,
kubelet은 고갈된 자원을 회수하기 위해 파드를 유예 시간 없이
즉시 종료한다.</p>
<p><code>eviction-hard</code> 플래그를 사용하여 하드 축출
임계값(예: <code>memory.available&lt;1Gi</code>)을 설정할 수 있다.</p>
<p>kubelet은 다음과 같은 하드 축출 임계값을 기본적으로 설정하고 있다.</p>
<ul>
<li><code>memory.available&lt;100Mi</code></li>
<li><code>nodefs.available&lt;10%</code></li>
<li><code>imagefs.available&lt;15%</code></li>
<li><code>nodefs.inodesFree&lt;5%</code> (리눅스 노드)</li>
</ul>
<h3 id=축출-모니터링-시간-간격>축출 모니터링 시간 간격</h3>
<p>kubelet은 <code>housekeeping-interval</code>에 설정된 시간 간격(기본값: <code>10s</code>)마다
축출 임계값을 확인한다.</p>
<h3 id=node-conditions>노드 컨디션</h3>
<p>kubelet은 하드/소프트 축출 임계값 조건이 충족되어
노드 압박이 발생했다는 것을 알리기 위해,
설정된 유예 시간과는 관계없이 노드 컨디션을 보고한다.</p>
<p>kubelet은 다음과 같이 노드 컨디션과 축출 신호를 매핑한다.</p>
<table>
<thead>
<tr>
<th>노드 컨디션</th>
<th>축출 신호</th>
<th>설명</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>MemoryPressure</code></td>
<td><code>memory.available</code></td>
<td>노드의 가용 메모리 양이 축출 임계값에 도달함</td>
</tr>
<tr>
<td><code>DiskPressure</code></td>
<td><code>nodefs.available</code>, <code>nodefs.inodesFree</code>, <code>imagefs.available</code>, 또는 <code>imagefs.inodesFree</code></td>
<td>노드의 루트 파일시스템 또는 이미지 파일시스템의 가용 디스크 공간 또는 inode의 수가 축출 임계값에 도달함</td>
</tr>
<tr>
<td><code>PIDPressure</code></td>
<td><code>pid.available</code></td>
<td>(리눅스) 노드의 가용 프로세스 ID(PID)가 축출 임계값 이하로 내려옴</td>
</tr>
</tbody>
</table>
<p>kubelet은 <code>--node-status-update-frequency</code>에 설정된
시간 간격(기본값: <code>10s</code>)마다 노드 컨디션을 업데이트한다.</p>
<h4 id=노드-컨디션-진동-oscillation>노드 컨디션 진동(oscillation)</h4>
<p>경우에 따라, 노드의 축출 신호값이 사전에 설정된 유예 시간 동안 유지되지 않고
소프트 축출 임계값을 중심으로 진동할 수 있다. 이로 인해 노드 컨디션이 계속
<code>true</code>와 <code>false</code>로 바뀌며, 잘못된 축출 결정을 야기할 수 있다.</p>
<p>이러한 진동을 방지하기 위해, <code>eviction-pressure-transition-period</code> 플래그를
사용하여 kubelet이 노드 컨디션을 다른 상태로 바꾸기 위해 기다려야 하는 시간을
설정할 수 있다. 기본값은 <code>5m</code>이다.</p>
<h3 id=reclaim-node-resources>노드-수준 자원 회수하기</h3>
<p>kubelet은 최종 사용자 파드를 축출하기 전에 노드-수준 자원 회수를 시도한다.</p>
<p><code>DiskPressure</code> 노드 컨디션이 보고되면,
kubelet은 노드의 파일시스템을 기반으로 노드-수준 자원을 회수한다.</p>
<h4 id=imagefs-가-있는-경우><code>imagefs</code>가 있는 경우</h4>
<p>컨테이너 런타임이 사용할 전용 <code>imagefs</code> 파일시스템이 노드에 있으면,
kubelet은 다음 작업을 수행한다.</p>
<ul>
<li><code>nodefs</code> 파일시스템이 축출 임계값 조건을 충족하면,
kubelet은 종료된 파드와 컨테이너에 대해 가비지 수집을 수행한다.</li>
<li><code>imagefs</code> 파일시스템이 축출 임계값 조건을 충족하면,
kubelet은 모든 사용중이지 않은 이미지를 삭제한다.</li>
</ul>
<h4 id=imagefs-가-없는-경우><code>imagefs</code>가 없는 경우</h4>
<p>노드에 <code>nodefs</code> 파일시스템만 있고 이것이 축출 임계값 조건을 충족한 경우,
kubelet은 다음 순서로 디스크 공간을 확보한다.</p>
<ol>
<li>종료된 파드와 컨테이너에 대해 가비지 수집을 수행한다.</li>
<li>사용중이지 않은 이미지를 삭제한다.</li>
</ol>
<h3 id=kubelet-축출을-위한-파드-선택>kubelet 축출을 위한 파드 선택</h3>
<p>kubelet이 노드-수준 자원을 회수했음에도 축출 신호가 임계값 아래로 내려가지 않으면,
kubelet은 최종 사용자 파드 축출을 시작한다.</p>
<p>kubelet은 파드 축출 순서를 결정하기 위해 다음의 파라미터를 활용한다.</p>
<ol>
<li>파드의 자원 사용량이 요청량을 초과했는지 여부</li>
<li><a href=/ko/docs/concepts/scheduling-eviction/pod-priority-preemption/>파드 우선순위</a></li>
<li>파드의 자원 요청량 대비 자원 사용량</li>
</ol>
<p>결과적으로, kubelet은 다음과 같은 순서로 파드의 축출 순서를 정하고 축출을 수행한다.</p>
<ol>
<li><code>BestEffort</code> 또는 <code>Burstable</code> 파드 중 자원 사용량이 요청량을 초과한 파드.
이 파드들은 파드들의 우선순위, 그리고 자원 사용량이 요청량을
얼마나 초과했는지에 따라 축출된다.</li>
<li><code>Guaranteed</code>, <code>Burstable</code> 파드 중 자원 사용량이 요청량보다 낮은 파드는
우선순위에 따라 후순위로 축출된다.</li>
</ol>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> kubelet이 파드 축출 순서를 결정할 때 파드의 QoS 클래스는 이용하지 않는다.
메모리 등의 자원을 회수할 때, QoS 클래스를 이용하여 가장 가능성이 높은 파드 축출 순서를 예측할 수는 있다.
QoS는 EphemeralStorage 요청에 적용되지 않으므로,
노드가 예를 들어 <code>DiskPressure</code> 아래에 있는 경우 위의 시나리오가 적용되지 않는다.
</div>
<p><code>Guaranteed</code> 파드는 모든 컨테이너에 대해 자원 요청량과 제한이 명시되고
그 둘이 동일할 때에만 보장(guaranteed)된다. 다른 파드의 자원 사용으로 인해
<code>Guaranteed</code> 파드가 축출되는 일은 발생하지 않는다. 만약 시스템 데몬(예:
<code>kubelet</code>, <code>journald</code>)이 <code>system-reserved</code> 또는 <code>kube-reserved</code>
할당을 통해 예약된 것보다 더 많은 자원을 소비하고, 노드에는 요청량보다 적은 양의
자원을 사용하고 있는 <code>Guaranteed</code> / <code>Burstable</code> 파드만 존재한다면,
kubelet은 노드 안정성을 유지하고 자원 고갈이 다른 파드에 미칠 영향을 통제하기 위해
이러한 파드 중 하나를 골라 축출해야 한다.
이 경우, 가장 낮은 <code>Priority</code>를 갖는 파드가 선택된다.</p>
<p><code>inodes</code>와 <code>PIDs</code>에 대한 요청량은 정의하고 있지 않기 때문에, kubelet이 <code>inode</code>
또는 <code>PID</code> 고갈 때문에 파드를 축출할 때에는 파드의 <code>Priority</code>를 이용하여 축출
순위를 정한다.</p>
<p>노드에 전용 <code>imagefs</code> 파일시스템이 있는지 여부에 따라 kubelet이 파드 축출 순서를
정하는 방식에 차이가 있다.</p>
<h4 id=imagefs-가-있는-경우-1><code>imagefs</code>가 있는 경우</h4>
<p><code>nodefs</code>로 인한 축출의 경우, kubelet은 <code>nodefs</code>
사용량(<code>모든 컨테이너의 로컬 볼륨 + 로그</code>)을 기준으로 축출 순서를 정한다.</p>
<p><code>imagefs</code>로 인한 축출의 경우, kubelet은 모든 컨테이너의
쓰기 가능한 레이어(writable layer) 사용량을 기준으로 축출 순서를 정한다.</p>
<h4 id=imagefs-가-없는-경우-1><code>imagefs</code>가 없는 경우</h4>
<p><code>nodefs</code>로 인한 축출의 경우, kubelet은 각 파드의 총
디스크 사용량(<code>모든 컨테이너의 로컬 볼륨 + 로그 + 쓰기 가능한 레이어</code>)을 기준으로 축출 순서를 정한다.</p>
<h3 id=최소-축출-회수량>최소 축출 회수량</h3>
<p>경우에 따라, 파드를 축출했음에도 적은 양의 자원만이 회수될 수 있다.
이로 인해 kubelet이 반복적으로 축출 임계값 도달을 감지하고
여러 번의 축출을 수행할 수 있다.</p>
<p><code>--eviction-minimum-reclaim</code> 플래그 또는
<a href=/docs/tasks/administer-cluster/kubelet-config-file/>kubelet 설정 파일</a>을 이용하여
각 자원에 대한 최소 회수량을 설정할 수 있다. kubelet이 자원 부족 상황을 감지하면,
앞서 설정한 최소 회수량에 도달할때까지 회수를 계속 진행한다.</p>
<p>예를 들어, 다음 YAML은 최소 회수량을 정의하고 있다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>kubelet.config.k8s.io/v1beta1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>KubeletConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>evictionHard</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>memory.available</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;500Mi&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>nodefs.available</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;1Gi&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>imagefs.available</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;100Gi&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>evictionMinimumReclaim</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>memory.available</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;0Mi&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>nodefs.available</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;500Mi&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>imagefs.available</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2Gi&#34;</span><span style=color:#bbb>
</span></code></pre></div><p>이 예제에서, 만약 <code>nodefs.available</code> 축출 신호가 축출 임계값 조건에 도달하면,
kubelet은 축출 신호가 임계값인 <code>1Gi</code>에 도달할 때까지 자원을 회수하며,
이어서 축출 신호가 <code>1.5Gi</code>에 도달할 때까지 최소 <code>500Mi</code> 이상의 자원을
회수한다.</p>
<p>유사한 방식으로, kubelet은 <code>imagefs.available</code> 축출 신호가
<code>102Gi</code>에 도달할 때까지 <code>imagefs</code> 자원을 회수한다.</p>
<p>모든 자원에 대해 <code>eviction-minimum-reclaim</code>의 기본값은 <code>0</code>이다.</p>
<h3 id=노드-메모리-부족-시의-동작>노드 메모리 부족 시의 동작</h3>
<p>kubelet의 메모리 회수가 가능하기 이전에
노드에 메모리 부족(out of memory, 이하 OOM) 이벤트가 발생하면,
노드는 <a href=https://lwn.net/Articles/391222/>oom_killer</a>에 의존한다.</p>
<p>kubelet은 각 파드에 설정된 QoS를 기반으로 각 컨테이너에 <code>oom_score_adj</code> 값을 설정한다.</p>
<table>
<thead>
<tr>
<th>서비스 품질(Quality of Service)</th>
<th>oom_score_adj</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Guaranteed</code></td>
<td>-997</td>
</tr>
<tr>
<td><code>BestEffort</code></td>
<td>1000</td>
</tr>
<tr>
<td><code>Burstable</code></td>
<td>min(max(2, 1000 - (1000 * memoryRequestBytes) / machineMemoryCapacityBytes), 999)</td>
</tr>
</tbody>
</table>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> 또한, kubelet은 <code>system-node-critical</code> <a class=glossary-tooltip title="Pod Priority indicates the importance of a Pod relative to other Pods." data-toggle=tooltip data-placement=top href=/docs/concepts/scheduling-eviction/pod-priority-preemption/#pod-priority target=_blank aria-label="파드 우선 순위(Priority)">파드 우선 순위(Priority)</a>를 갖는 파드의 컨테이너에
<code>oom_score_adj</code> 값을 <code>-997</code>로 설정한다.
</div>
<p>노드가 OOM을 겪기 전에 kubelet이 메모리를 회수하지 못하면, <code>oom_killer</code>가 노드의
메모리 사용률 백분율을 이용하여 <code>oom_score</code>를 계산하고, 각 컨테이너의 실질
<code>oom_score</code>를 구하기 위해 <code>oom_score_adj</code>를 더한다. 그 뒤 <code>oom_score</code>가 가장 높은
컨테이너부터 종료시킨다.</p>
<p>이는 곧, 스케줄링 요청에 비해 많은 양의 메모리를 사용하면서
QoS가 낮은 파드에 속한 컨테이너가 먼저 종료됨을 의미한다.</p>
<p>파드 축출과 달리, 컨테이너가 OOM으로 인해 종료되면,
<code>kubelet</code>이 컨테이너의 <code>RestartPolicy</code>를 기반으로 컨테이너를 다시 실행할 수 있다.</p>
<h3 id=node-pressure-eviction-good-practices>추천 예시</h3>
<p>아래 섹션에서 축출 설정에 대한 추천 예시를 소개한다.</p>
<h4 id=스케줄-가능한-자원과-축출-정책>스케줄 가능한 자원과 축출 정책</h4>
<p>kubelet에 축출 정책을 설정할 때, 만약 어떤 파드 배치가 즉시 메모리 압박을
야기하기 때문에 축출을 유발한다면 스케줄러가 그 파드 배치를 수행하지 않도록
설정해야 한다.</p>
<p>다음 시나리오를 가정한다.</p>
<ul>
<li>노드 메모리 용량: <code>10Gi</code></li>
<li>운영자는 시스템 데몬(커널, <code>kubelet</code> 등)을 위해 메모리 용량의 10%를 확보해 놓고 싶어 한다.</li>
<li>운영자는 시스템 OOM 발생을 줄이기 위해 메모리 사용률이 95%인 상황에서 파드를 축출하고 싶어한다.</li>
</ul>
<p>이것이 실현되도록, kubelet이 다음과 같이 실행된다.</p>
<pre><code>--eviction-hard=memory.available&lt;500Mi
--system-reserved=memory=1.5Gi
</code></pre><p>이 환경 설정에서, <code>--system-reserved</code> 플래그는 시스템 용으로 <code>1.5Gi</code> 메모리를
확보하는데, 이는 <code>총 메모리의 10% + 축출 임계값</code>에 해당된다.</p>
<p>파드가 요청량보다 많은 메모리를 사용하거나 시스템이 <code>1Gi</code> 이상의 메모리를
사용하여, <code>memory.available</code> 축출 신호가 <code>500Mi</code> 아래로 내려가면 노드가 축출
임계값에 도달할 수 있다.</p>
<h4 id=데몬셋-daemonset>데몬셋(DaemonSet)</h4>
<p>파드 우선 순위(Priority)는 파드 축출 결정을 내릴 때의 주요 요소이다.
kubelet이 <code>DaemonSet</code>에 속하는 파드를 축출하지 않도록 하려면
해당 파드의 파드 스펙에 충분히 높은 <code>priorityClass</code>를 지정한다.
또는 낮은 <code>priorityClass</code>나 기본값을 사용하여
리소스가 충분할 때만 <code>DaemonSet</code> 파드가 실행되도록 허용할 수도 있다.</p>
<h3 id=알려진-이슈>알려진 이슈</h3>
<p>다음 섹션에서는 리소스 부족 처리와 관련된 알려진 이슈에 대해 다룬다.</p>
<h4 id=kubelet이-메모리-압박을-즉시-감지하지-못할-수-있음>kubelet이 메모리 압박을 즉시 감지하지 못할 수 있음</h4>
<p>기본적으로 kubelet은 <code>cAdvisor</code>를 폴링하여
일정한 간격으로 메모리 사용량 통계를 수집한다.
해당 타임 윈도우 내에서 메모리 사용량이 빠르게 증가하면 kubelet이
<code>MemoryPressure</code>를 충분히 빠르게 감지하지 못해 <code>OOMKiller</code>가 계속 호출될 수 있다.</p>
<p><code>--kernel-memcg-notification</code> 플래그를 사용하여
kubelet의 <code>memcg</code> 알림 API가 임계값을 초과할 때 즉시 알림을 받도록
할 수 있다.</p>
<p>사용률(utilization)을 극단적으로 높이려는 것이 아니라 오버커밋(overcommit)에 대한 합리적인 조치만 원하는 경우,
이 문제에 대한 현실적인 해결 방법은 <code>--kube-reserved</code> 및
<code>--system-reserved</code> 플래그를 사용하여 시스템에 메모리를 할당하는 것이다.</p>
<h4 id=active-file-메모리가-사용-가능한-메모리로-간주되지-않음><code>active_file</code> 메모리가 사용 가능한 메모리로 간주되지 않음</h4>
<p>리눅스에서, 커널은 활성 LRU 목록의 파일 지원 메모리 바이트 수를 <code>active_file</code>
통계로 추적한다. kubelet은 <code>active_file</code> 메모리 영역을 회수할 수 없는 것으로
취급한다. 임시 로컬 스토리지를 포함하여 블록 지원 로컬 스토리지를 집중적으로
사용하는 워크로드의 경우 파일 및 블록 데이터의 커널 수준 캐시는 최근에 액세스한
많은 캐시 페이지가 <code>active_file</code>로 계산될 가능성이 있음을 의미한다. 활성 LRU
목록에 이러한 커널 블록 버퍼가 충분히 많으면, kubelet은 이를 높은 자원 사용
상태로 간주하고 노드가 메모리 압박을 겪고 있다고 테인트를 표시할 수 있으며, 이는
파드 축출을 유발한다.</p>
<p>더 자세한 사항은 <a href=https://github.com/kubernetes/kubernetes/issues/43916>https://github.com/kubernetes/kubernetes/issues/43916</a>를 참고한다.</p>
<p>집중적인 I/O 작업을 수행할 가능성이 있는 컨테이너에 대해 메모리 제한량 및 메모리
요청량을 동일하게 설정하여 이 문제를 해결할 수 있다. 해당 컨테이너에 대한 최적의
메모리 제한량을 추정하거나 측정해야 한다.</p>
<h2 id=다음-내용>다음 내용</h2>
<ul>
<li><a href=/ko/docs/concepts/scheduling-eviction/api-eviction/>API를 이용한 축출</a>에 대해 알아본다.</li>
<li><a href=/ko/docs/concepts/scheduling-eviction/pod-priority-preemption/>파드 우선순위와 선점</a>에 대해 알아본다.</li>
<li><a href=/docs/tasks/run-application/configure-pdb/>PodDisruptionBudgets</a>에 대해 알아본다.</li>
<li><a href=/ko/docs/tasks/configure-pod-container/quality-service-pod/>서비스 품질</a>(QoS)에 대해 알아본다.</li>
<li><a href=/docs/reference/generated/kubernetes-api/v1.23/#create-eviction-pod-v1-core>축출 API</a>를 확인한다.</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-b87723bf81b079042860f0ebd37b0a64>9.6 - API를 이용한 축출(Eviction)</h1>
<p>API를 이용한 축출은 <a href=/docs/reference/generated/kubernetes-api/v1.23/#create-eviction-pod-v1-core>축출 API</a>를 사용하여
생성된 <code>Eviction</code> 오브젝트로 파드를 정상 종료한다. </br></p>
<p><code>kubectl drain</code> 명령과 같은 kube-apiserver의 클라이언트를 사용하여,
축출 API를 직접 호출해 축출 요청을 할 수 있다.
그러면 API 서버가 파드를 종료하는 <code>Eviction</code> 오브젝트가 생성된다.</p>
<p>API를 이용한 축출은 구성된 <a href=/docs/tasks/run-application/configure-pdb/><code>PodDisruptionBudgets</code></a> 및 <a href=/ko/docs/concepts/workloads/pods/pod-lifecycle/#pod-termination><code>terminationGracePeriodSeconds</code></a>를 준수한다.</p>
<h2 id=다음-내용>다음 내용</h2>
<ul>
<li><a href=/ko/docs/concepts/scheduling-eviction/node-pressure-eviction/>노드-압박 축출</a>에 대해 더 배우기</li>
<li><a href=/ko/docs/concepts/scheduling-eviction/pod-priority-preemption/>파드 우선순위와 선점</a>에 대해 더 배우기</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-60e5a2861609e0848d58ce8bf99c4a31>9.7 - 파드 우선순위(priority)와 선점(preemption)</h1>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.14 [stable]</code>
</div>
<p><a href=/ko/docs/concepts/workloads/pods/>파드</a>는 <em>우선순위</em> 를 가질 수 있다. 우선순위는
다른 파드에 대한 상대적인 파드의 중요성을 나타낸다. 파드를 스케줄링할 수 없는 경우,
스케줄러는 우선순위가 낮은 파드를 선점(축출)하여 보류 중인 파드를
스케줄링할 수 있게 한다.</p>
<div class="alert alert-danger warning callout" role=alert>
<strong>경고:</strong> <p>모든 사용자를 신뢰할 수 없는 클러스터에서, 악의적인 사용자가 우선순위가
가장 높은 파드를 생성하여 다른 파드가 축출되거나 스케줄링되지
않을 수 있다.
관리자는 리소스쿼터를 사용하여 사용자가 우선순위가 높은 파드를 생성하지
못하게 할 수 있다.</p>
<p>자세한 내용은 <a href=/ko/docs/concepts/policy/resource-quotas/#%EA%B8%B0%EB%B3%B8%EC%A0%81%EC%9C%BC%EB%A1%9C-%EC%9A%B0%EC%84%A0-%EC%88%9C%EC%9C%84-%ED%81%B4%EB%9E%98%EC%8A%A4-%EC%86%8C%EB%B9%84-%EC%A0%9C%ED%95%9C>기본적으로 프라이어리티클래스(Priority Class) 소비 제한</a>을
참고한다.</p>
</div>
<h2 id=우선순위와-선점을-사용하는-방법>우선순위와 선점을 사용하는 방법</h2>
<p>우선순위와 선점을 사용하려면 다음을 참고한다.</p>
<ol>
<li>
<p>하나 이상의 <a href=#%ED%94%84%EB%9D%BC%EC%9D%B4%EC%96%B4%EB%A6%AC%ED%8B%B0%ED%81%B4%EB%9E%98%EC%8A%A4>프라이어리티클래스</a>를 추가한다.</p>
</li>
<li>
<p>추가된 프라이어리티클래스 중 하나에 <a href=#%ED%8C%8C%EB%93%9C-%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84><code>priorityClassName</code></a>이 설정된
파드를 생성한다. 물론 파드를 직접 생성할 필요는 없다.
일반적으로 디플로이먼트와 같은 컬렉션 오브젝트의 파드 템플릿에 <code>priorityClassName</code>
을 추가한다.</p>
</li>
</ol>
<p>이 단계에 대한 자세한 내용은 계속 읽어보자.</p>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> 쿠버네티스는 이미 <code>system-cluster-critical</code> 과 <code>system-node-critical</code>,
두 개의 프라이어리티클래스를 제공한다.
이들은 일반적인 클래스이며 <a href=/ko/docs/tasks/administer-cluster/guaranteed-scheduling-critical-addon-pods/>중요한(critical) 컴포넌트가 항상 먼저 스케줄링이 되도록 하는 데</a> 사용된다.
</div>
<h2 id=프라이어리티클래스>프라이어리티클래스</h2>
<p>프라이어리티클래스는 프라이어리티클래스 이름에서 우선순위의 정수 값으로의 매핑을
정의하는 네임스페이스가 아닌(non-namespaced) 오브젝트이다. 이름은
프라이어리티클래스 오브젝트의 메타데이터의 <code>name</code> 필드에 지정된다. 값은
필수 <code>value</code> 필드에 지정되어 있다. 값이 클수록, 우선순위가
높다.
프라이어리티클래스 오브젝트의 이름은 유효한
<a href=/ko/docs/concepts/overview/working-with-objects/names/#dns-%EC%84%9C%EB%B8%8C%EB%8F%84%EB%A9%94%EC%9D%B8-%EC%9D%B4%EB%A6%84>DNS 서브 도메인 이름</a>이어야 하며,
<code>system-</code> 접두사를 붙일 수 없다.</p>
<p>프라이어리티클래스 오브젝트는 10억 이하의 32비트 정수 값을 가질
수 있다. 일반적으로 선점하거나 축출해서는 안되는 중요한 시스템 파드에는 더 큰 숫자가
예약되어 있다. 클러스터 관리자는 원하는 각 매핑에 대해 프라이어리티클래스 오브젝트를
하나씩 생성해야 한다.</p>
<p>프라이어리티클래스에는 <code>globalDefault</code> 와 <code>description</code> 두 개의 선택적인 필드도 있다.
<code>globalDefault</code> 필드는 이 프라이어리티클래스의 값을 <code>priorityClassName</code> 이 없는
파드에 사용해야 함을 나타낸다. 시스템에서 <code>globalDefault</code> 가 <code>true</code> 로 설정된
프라이어리티클래스는 하나만 존재할 수 있다. <code>globalDefault</code> 가 설정된
프라이어리티클래스가 없을 경우, <code>priorityClassName</code> 이 없는 파드의
우선순위는 0이다.</p>
<p><code>description</code> 필드는 임의의 문자열이다. 이 필드는 이 프라이어리티클래스를 언제
사용해야 하는지를 클러스터 사용자에게 알려주기 위한 것이다.</p>
<h3 id=podpriority와-기존-클러스터에-대한-참고-사항>PodPriority와 기존 클러스터에 대한 참고 사항</h3>
<ul>
<li>
<p>이 기능없이 기존 클러스터를 업그레이드 하는 경우, 기존 파드의
우선순위는 사실상 0이다.</p>
</li>
<li>
<p><code>globalDefault</code> 가 <code>true</code> 로 설정된 프라이어리티클래스를 추가해도 기존 파드의
우선순위는 변경되지 않는다. 이러한 프라이어리티클래스의 값은
프라이어리티클래스를 추가한 후 생성된 파드에만 사용된다.</p>
</li>
<li>
<p>프라이어리티클래스를 삭제하면, 삭제된 프라이어리티클래스의 이름을 사용하는
기존 파드는 변경되지 않고 남아있지만, 삭제된 프라이어리티클래스의 이름을
사용하는 파드는 더 이상 생성할 수 없다.</p>
</li>
</ul>
<h3 id=프라이어리티클래스-예제>프라이어리티클래스 예제</h3>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>scheduling.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PriorityClass<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>high-priority<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#666>1000000</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>globalDefault</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>false</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>description</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;이 프라이어리티클래스는 XYZ 서비스 파드에만 사용해야 한다.&#34;</span><span style=color:#bbb>
</span></code></pre></div><h2 id=non-preempting-priority-class>비-선점 프라이어리티클래스</h2>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.19 [beta]</code>
</div>
<p><code>preemptionPolicy: Never</code> 를 가진 파드는 낮은 우선순위 파드의 스케줄링 대기열의
앞쪽에 배치되지만,
그 파드는 다른 파드를 축출할 수 없다.
스케줄링 대기 중인 비-선점 파드는 충분한 리소스가 확보되고
스케줄링될 수 있을 때까지
스케줄링 대기열에 대기한다.
다른 파드와 마찬가지로,
비-선점 파드는
스케줄러 백오프(back-off)에 종속된다.
이는 스케줄러가 이러한 파드를 스케줄링하려고 시도하고 스케줄링할 수 없는 경우,
더 적은 횟수로 재시도하여,
우선순위가 낮은 다른 파드를 미리 스케줄링할 수 있음을 의미한다.</p>
<p>비-선점 파드는 다른 우선순위가 높은 파드에 의해
축출될 수 있다.</p>
<p><code>preemptionPolicy</code> 는 기본값으로 <code>PreemptLowerPriority</code> 로 설정되어,
해당 프라이어리티클래스의 파드가 우선순위가 낮은 파드를 축출할 수
있다(기존의 기본 동작과 동일).
<code>preemptionPolicy</code> 가 <code>Never</code> 로 설정된 경우,
해당 프라이어리티클래스의 파드는 비-선점될 것이다.</p>
<p>예제 유스케이스는 데이터 과학 관련 워크로드이다.
사용자는 다른 워크로드보다 우선순위가 높은 잡(job)을 제출할 수 있지만,
실행 중인 파드를 축출하여 기존의 작업을 삭제하지는 않을 것이다.
클러스터 리소스가 "자연스럽게" 충분히 사용할 수 있게 되면,
<code>preemptionPolicy: Never</code> 의 우선순위가 높은 잡이
다른 대기 중인 파드보다 먼저 스케줄링된다.</p>
<h3 id=비-선점-프라이어리티클래스-예제>비-선점 프라이어리티클래스 예제</h3>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>scheduling.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PriorityClass<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>high-priority-nonpreempting<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#666>1000000</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>preemptionPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>globalDefault</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>false</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>description</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;이 프라이어리티클래스는 다른 파드를 축출하지 않는다.&#34;</span><span style=color:#bbb>
</span></code></pre></div><h2 id=파드-우선순위>파드 우선순위</h2>
<p>프라이어리티클래스가 하나 이상 있으면, 그것의 명세에서 이들 프라이어리티클래스 이름 중 하나를
지정하는 파드를 생성할 수 있다. 우선순위 어드미션
컨트롤러는 <code>priorityClassName</code> 필드를 사용하고 우선순위의 정수 값을
채운다. 프라이어리티클래스를 찾을 수 없으면, 파드가 거부된다.</p>
<p>다음의 YAML은 이전 예제에서 생성된 프라이어리티클래스를
사용하는 파드 구성의 예이다. 우선순위 어드미션 컨트롤러는
명세를 확인하고 파드의 우선순위를 1000000으로
해석한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb> </span>test<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>imagePullPolicy</span>:<span style=color:#bbb> </span>IfNotPresent<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>priorityClassName</span>:<span style=color:#bbb> </span>high-priority<span style=color:#bbb>
</span></code></pre></div><h3 id=스케줄링-순서에-대한-파드-우선순위의-영향>스케줄링 순서에 대한 파드 우선순위의 영향</h3>
<p>파드 우선순위가 활성화되면, 스케줄러가 우선순위에 따라 보류 중인
파드를 주문하고 보류 중인 파드는 스케줄링 대기열에서
우선순위가 낮은 다른 보류 중인 파드보다 우선한다. 결과적으로, 스케줄링
요구 사항이 충족되는 경우 우선순위가 더 낮은 파드보다 우선순위가 높은 파드가
더 빨리 스케줄링될 수 있다. 이러한 파드를 스케줄링할 수 없는 경우,
스케줄러는 계속 진행하고 우선순위가 낮은 다른 파드를 스케줄링하려고 한다.</p>
<h2 id=선점>선점</h2>
<p>파드가 생성되면, 대기열로 이동하여 스케줄링을 기다린다.
스케줄러가 대기열에서 파드를 선택하여 노드에 스케줄링하려고 한다.
파드의 지정된 모든 요구 사항을 충족하는 노드가 없으면,
보류 중인 파드에 대해 선점 로직이 트리거된다. 보류 중인 파드를 P라 하자.
선점 로직은 P보다 우선순위가 낮은 하나 이상의 파드를 제거하면
해당 노드에서 P를 스케줄링할 수 있는 노드를 찾는다. 이러한
노드가 발견되면, 하나 이상의 우선순위가 낮은 파드가 노드에서 축출된다.
파드가 축출된 후, P는 노드에 스케줄링될 수 있다.</p>
<h3 id=사용자-노출-정보>사용자 노출 정보</h3>
<p>파드 P가 노드 N에서 하나 이상의 파드를 축출할 경우, 파드 P의 상태 <code>nominatedNodeName</code>
필드는 노드 N의 이름으로 설정된다. 이 필드는 스케줄러가 파드 P에
예약된 리소스를 추적하는 데 도움이 되고 사용자에게 클러스터의 선점에 대한
정보를 제공한다.</p>
<p>파드 P는 반드시 "지정된 노드"로 스케줄링되지는 않는다.
피해자 파드가 축출된 후, 그것은 정상적(graceful)으로 종료되는 기간을 갖는다.
스케줄러가 종료될 피해자 파드를 기다리는 동안 다른 노드를 사용할 수
있게 되면, 스케줄러는 파드 P를 스케줄링하기 위해 다른 노드를 사용한다. 그 결과,
파드 스펙의 <code>nominatedNodeName</code> 과 <code>nodeName</code> 은 항상 동일하지 않다. 또한,
스케줄러가 노드 N에서 파드를 축출했지만, 파드 P보다 우선순위가 높은 파드가
도착하면, 스케줄러가 노드 N에 새로운 우선순위가 높은 파드를 제공할 수 있다. 이러한
경우, 스케줄러는 파드 P의 <code>nominatedNodeName</code> 을 지운다. 이렇게하면, 스케줄러는
파드 P가 다른 노드에서 파드를 축출할 수 있도록 한다.</p>
<h3 id=선점의-한계>선점의 한계</h3>
<h4 id=선점-피해자의-정상적인-종료>선점 피해자의 정상적인 종료</h4>
<p>파드가 축출되면, 축출된 피해자 파드는
<a href=/ko/docs/concepts/workloads/pods/pod-lifecycle/#%ED%8C%8C%EB%93%9C%EC%9D%98-%EC%A2%85%EB%A3%8C>정상적인 종료 기간</a>을 가진다.
피해자 파드는 작업을 종료하고 빠져나가는 데(exit) 많은 시간을 가진다. 그렇지 않으면,
파드는 강제종료(kill) 된다. 이 정상적인 종료 기간은 스케줄러가 파드를 축출하는
지점과 보류 중인 파드(P)를 노드(N)에서 스케줄링할 수 있는 시점 사이의
시간 간격을 만든다. 그 동안, 스케줄러는 보류 중인 다른 파드를
계속 스케줄링한다. 피해자 파드가 빠져나가거나 종료되면, 스케줄러는 보류 대기열에서
파드를 스케줄하려고 한다. 따라서, 일반적으로 스케줄러가 피해자 파드를 축출하는 시점과
파드 P가 스케줄링된 시점 사이에 시간 간격이 있다.
이러한 차이를 최소화하기 위해, 우선순위가 낮은 파드의 정상적인 종료 기간을 0 또는
작은 수로 설정할 수 있다.</p>
<h4 id=poddisruptionbudget을-지원하지만-보장하지-않음>PodDisruptionBudget을 지원하지만, 보장하지 않음</h4>
<p><a href=/ko/docs/concepts/workloads/pods/disruptions/>Pod Disruption Budget</a>(PDB)은
애플리케이션 소유자가 자발적 중단에서 동시에 다운된 복제된
애플리케이션의 파드 수를 제한할 수 있다. 쿠버네티스는 파드를
선점할 때 PDB를 지원하지만, PDB를 따르는 것이 최선의 노력이다. 스케줄러는
선점에 의해 PDB를 위반하지 않은 피해자 파드를 찾으려고 하지만, 그러한 피해자 파드가
발견되지 않으면, 선점은 여전히 발생하며, PDB를 위반하더라도 우선순위가
낮은 파드는 제거된다.</p>
<h4 id=우선순위가-낮은-파드에-대한-파드-간-어피니티>우선순위가 낮은 파드에 대한 파드-간 어피니티</h4>
<p>이 질문에 대한 답변이 '예'인 경우에만 노드가 선점 대상으로 간주된다.
"대기 중인 파드보다 우선순위가 낮은 모든 파드가 노드에서
제거되면, 보류 중인 파드를 노드에 스케줄링할 수 있습니까?"</p>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> 선점으로 우선순위가 낮은 모든 파드를 반드시 제거할 필요는
없다. 우선순위가 낮은 모든 파드보다 적은 수를 제거하여 보류 중인 파드를
스케줄링할 수 있는 경우, 우선순위가 낮은 파드의 일부만 제거된다.
그럼에도 불구하고, 앞의 질문에 대한 대답은 '예'여야 한다. 답변이 '아니오'인 경우,
노드가 선점 대상으로 간주되지 않는다.
</div>
<p>보류 중인 파드가 노드에 있는 하나 이상의 우선순위가 낮은 파드에 대한 파드-간 어피니티를
가진 경우에, 우선순위가 낮은 파드가 없을 때 파드-간 어피니티 규칙을
충족할 수 없다. 이 경우, 스케줄러는 노드의 파드를 축출하지
않는다. 대신, 다른 노드를 찾는다. 스케줄러가
적합한 노드를 찾거나 찾지 못할 수 있다. 보류 중인 파드를 스케줄링할 수 있다는
보장은 없다.</p>
<p>이 문제에 대한 권장 솔루션은 우선순위가 같거나 높은 파드에 대해서만 파드-간 어피니티를
생성하는 것이다.</p>
<h4 id=교차-노드-선점>교차 노드 선점</h4>
<p>보류 중인 파드 P가 노드 N에 스케줄링될 수 있도록 노드 N이 선점 대상으로 고려되고
있다고 가정한다. 다른 노드의 파드가 축출된 경우에만 P가 N에서 실행 가능해질 수
있다. 예를 들면 다음과 같다.</p>
<ul>
<li>파드 P는 노드 N에 대해 고려된다.</li>
<li>파드 Q는 노드 N과 동일한 영역의 다른 노드에서 실행 중이다.</li>
<li>파드 P는 파드 Q(<code>topologyKey: topology.kubernetes.io/zone</code>)와 영역(zone) 전체의 안티-어피니티를 갖는다.</li>
<li>영역에서 파드 P와 다른 파드 간의 안티-어피니티에 대한 다른 경우는
없다.</li>
<li>노드 N에서 파드 P를 스케줄링하기 위해, 파드 Q를 축출할 수 있지만, 스케줄러는
교차-노드 선점을 수행하지 않는다. 따라서, 파드 P가 노드 N에서
스케줄링할 수 없는 것으로 간주된다.</li>
</ul>
<p>파드 Q가 노드에서 제거되면, 파드 안티-어피니티 위반이
사라지고, 파드 P는 노드 N에서 스케줄링될 수 있다.</p>
<p>수요가 충분하고 합리적인 성능의 알고리즘을 찾을 경우
향후 버전에서 교차 노드 선점의 추가를 고려할 수 있다.</p>
<h2 id=문제-해결>문제 해결</h2>
<p>파드 우선순위와 선점은 원하지 않는 부작용을 가질 수 있다. 다음은
잠재적 문제의 예시와 이를 해결하는 방법이다.</p>
<h3 id=파드가-불필요하게-선점-축출-됨>파드가 불필요하게 선점(축출)됨</h3>
<p>선점은 우선순위가 높은 보류 중인 파드를 위한 공간을 만들기 위해 리소스 압박을 받고 있는
클러스터에서 기존 파드를 제거한다. 실수로 특정 파드에 높은 우선순위를
부여하면, 의도하지 않은 높은 우선순위 파드가 클러스터에서
선점을 유발할 수 있다. 파드 우선순위는 파드 명세에서
<code>priorityClassName</code> 필드를 설정하여 지정한다. 그런 다음
우선순위의 정수 값이 분석되어 <code>podSpec</code> 의 <code>priority</code> 필드에 채워진다.</p>
<p>문제를 해결하기 위해, 해당 파드가 우선순위가 낮은 클래스를 사용하도록 <code>priorityClassName</code> 을
변경하거나, 해당 필드를 비워둘 수 있다. 빈
<code>priorityClassName</code> 은 기본값이 0으로 해석된다.</p>
<p>파드가 축출되면, 축출된 파드에 대한 이벤트가 기록된다.
선점은 클러스터가 파드에 대한 리소스를 충분히 가지지 못한 경우에만
발생한다. 이러한 경우, 선점은 보류 중인 파드(선점자)의 우선순위가
피해자 파드보다 높은 경우에만 발생한다. 보류 중인 파드가 없거나,
보류 중인 파드의 우선순위가 피해자 파드와 같거나 낮은 경우
선점이 발생하지 않아야 한다. 그러한 시나리오에서 선점이 발생하면, 이슈를 올리기 바란다.</p>
<h3 id=파드가-축출되었지만-선점자는-스케줄링되지-않음>파드가 축출되었지만, 선점자는 스케줄링되지 않음</h3>
<p>파드가 축출되면, 요청된 정상적인 종료
기간(기본적으로 30초)이 주어진다. 이 기간 내에 대상 파드가
종료되지 않으면, 강제 종료된다. 모든 피해자 파드가 사라지면,
선점자 파드를 스케줄링할 수 있다.</p>
<p>선점자 파드가 피해자 파드가 없어지기를 기다리는 동안, 동일한 노드에
적합한 우선순위가 높은 파드가 생성될 수 있다. 이 경우, 스케줄러는
선점자 대신 우선순위가 높은 파드를 스케줄링한다.</p>
<p>이것은 예상된 동작이다. 우선순위가 높은 파드는 우선순위가 낮은 파드를
대체해야 한다.</p>
<h3 id=우선순위가-높은-파드는-우선순위가-낮은-파드보다-우선함>우선순위가 높은 파드는 우선순위가 낮은 파드보다 우선함</h3>
<p>스케줄러가 보류 중인 파드를 실행할 수 있는 노드를 찾으려고 한다. 노드를 찾지
못하면, 스케줄러는 임의의 노드에서 우선순위가 낮은 파드를 제거하여
보류 중인 파드를 위한 공간을 만든다.
우선순위가 낮은 파드가 있는 노드가 보류 중인 파드를 실행할 수 없는 경우, 스케줄러는
선점을 위해 우선순위가 높은 다른 노드(다른 노드의 파드와 비교)를
선택할 수 있다. 피해자 파드는 여전히 선점자 파드보다 우선순위가
낮아야 한다.</p>
<p>선점할 수 있는 여러 노드가 있는 경우, 스케줄러는
우선순위가 가장 낮은 파드 세트를 가진 노드를 선택하려고 한다. 그러나,
이러한 파드가 위반될 PodDisruptionBudget을 가지고 있고 축출된 경우
스케줄러는 우선순위가 높은 파드를 가진 다른 노드를 선택할 수 있다.</p>
<p>선점을 위해 여러 개의 노드가 존재하고 위의 시나리오 중 어느 것도 적용되지 않는 경우,
스케줄러는 우선순위가 가장 낮은 노드를 선택한다.</p>
<h2 id=interactions-of-pod-priority-and-qos>파드 우선순위와 서비스 품질 간의 상호 작용</h2>
<p>파드 우선순위와 <a class=glossary-tooltip title="QoS 클래스(서비스 품질 클래스)는 쿠버네티스가 클러스터 안의 파드들을 여러 클래스로 구분하고, 스케줄링과 축출(eviction)에 대한 결정을 내리는 방법을 제공한다." data-toggle=tooltip data-placement=top href="/ko/docs/reference/glossary/?all=true#term-qos-class" target=_blank aria-label="QoS 클래스">QoS 클래스</a>는
상호 작용이 거의 없고 QoS 클래스를 기반으로 파드 우선순위를 설정하는 데 대한
기본 제한이 없는 두 개의 직교(orthogonal) 기능이다. 스케줄러의
선점 로직은 선점 대상을 선택할 때 QoS를 고려하지 않는다.
선점은 파드 우선순위를 고려하고 우선순위가 가장 낮은 대상 세트를
선택하려고 한다. 우선순위가 가장 높은 파드는 스케줄러가
선점자 파드를 스케줄링할 수 없거나 우선순위가 가장 낮은 파드가
<code>PodDisruptionBudget</code> 으로 보호되는 경우에만, 우선순위가 가장 낮은 파드를
축출 대상으로 고려한다.</p>
<p>kubelet은 우선순위를 사용하여 파드의 <a href=/ko/docs/concepts/scheduling-eviction/node-pressure-eviction/>노드-압박(node-pressure) 축출</a> 순서를 결정한다.
사용자는 QoS 클래스를 사용하여 어떤 파드가 축출될 것인지
예상할 수 있다. kubelet은 다음의 요소들을 통해서 파드의 축출 순위를 매긴다.</p>
<ol>
<li>기아(starved) 리소스 사용량이 요청을 초과하는지 여부</li>
<li>파드 우선순위</li>
<li>요청 대비 리소스 사용량</li>
</ol>
<p>더 자세한 내용은 <a href=/ko/docs/concepts/scheduling-eviction/node-pressure-eviction/#kubelet-%EC%B6%95%EC%B6%9C%EC%9D%84-%EC%9C%84%ED%95%9C-%ED%8C%8C%EB%93%9C-%EC%84%A0%ED%83%9D>kubelet 축출을 위한 파드 선택</a>을
참조한다.</p>
<p>kubelet 노드-압박 축출은 사용량이 요청을 초과하지 않는 경우
파드를 축출하지 않는다. 우선순위가 낮은 파드가 요청을
초과하지 않으면, 축출되지 않는다. 요청을 초과하는 우선순위가
더 높은 다른 파드가 축출될 수 있다.</p>
<h2 id=다음-내용>다음 내용</h2>
<ul>
<li>프라이어리티클래스와 함께 리소스쿼터 사용에 대해 읽기: <a href=/ko/docs/concepts/policy/resource-quotas/#%EA%B8%B0%EB%B3%B8%EC%A0%81%EC%9C%BC%EB%A1%9C-%EC%9A%B0%EC%84%A0-%EC%88%9C%EC%9C%84-%ED%81%B4%EB%9E%98%EC%8A%A4-%EC%86%8C%EB%B9%84-%EC%A0%9C%ED%95%9C>기본으로 프라이어리티 클래스 소비 제한</a></li>
<li><a href=/ko/docs/concepts/workloads/pods/disruptions/>파드 중단(disruption)</a>에 대해 학습한다.</li>
<li><a href=/ko/docs/concepts/scheduling-eviction/api-eviction/>API를 이용한 축출</a>에 대해 학습한다.</li>
<li><a href=/ko/docs/concepts/scheduling-eviction/node-pressure-eviction/>노드-압박(node-pressure) 축출</a>에 대해 학습한다.</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-961126cd43559012893979e568396a49>9.8 - 확장된 리소스를 위한 리소스 빈 패킹(bin packing)</h1>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.16 [alpha]</code>
</div>
<p>kube-scheduler는 <code>RequestedToCapacityRatioResourceAllocation</code>
우선 순위 기능을 사용해서 확장된 리소스와 함께 리소스의 빈 패킹이 가능하도록
구성할 수 있다. 우선 순위 기능을 사용해서 맞춤 요구에 따라
kube-scheduler를 미세 조정할 수 있다.</p>
<h2 id=requestedtocapacityratioresourceallocation을-사용해서-빈-패킹-활성화하기>RequestedToCapacityRatioResourceAllocation을 사용해서 빈 패킹 활성화하기</h2>
<p>쿠버네티스를 사용하면 사용자가 각 리소스에 대한 가중치와 함께 리소스를 지정하여
용량 대비 요청 비율을 기반으로 노드의 점수를 매기는 것을 허용한다. 이를
통해 사용자는 적절한 파라미터를 사용해서 확장된 리소스를 빈 팩으로 만들 수 있어
대규모의 클러스터에서 부족한 리소스의 활용도가 향상된다.
<code>RequestedToCapacityRatioResourceAllocation</code> 우선 순위 기능의
동작은 <code>RequestedToCapacityRatioArgs</code>라는
구성 옵션으로 제어할 수 있다. 이 인수는 <code>shape</code>와 <code>resources</code>
두 개의 파라미터로 구성된다. <code>shape</code> 파라미터는 사용자가 <code>utilization</code>과
<code>score</code> 값을 기반으로 최소 요청 또는 최대 요청된 대로 기능을
조정할 수 있게 한다. <code>resources</code> 파라미터는 점수를 매길 때 고려할
리소스의 <code>name</code> 과 각 리소스의 가중치를 지정하는 <code>weight</code> 로
구성된다.</p>
<p>다음은 확장된 리소스 <code>intel.com/foo</code> 와 <code>intel.com/bar</code> 에 대한
<code>requestedToCapacityRatioArguments</code> 를 빈 패킹 동작으로
설정하는 구성의 예시이다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>kubescheduler.config.k8s.io/v1beta1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>KubeSchedulerConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>profiles</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>pluginConfig</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>RequestedToCapacityRatio<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb> 
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>shape</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>utilization</span>:<span style=color:#bbb> </span><span style=color:#666>0</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>score</span>:<span style=color:#bbb> </span><span style=color:#666>10</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>utilization</span>:<span style=color:#bbb> </span><span style=color:#666>100</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>score</span>:<span style=color:#bbb> </span><span style=color:#666>0</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>intel.com/foo<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>weight</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>intel.com/bar<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>weight</span>:<span style=color:#bbb> </span><span style=color:#666>5</span><span style=color:#bbb>
</span></code></pre></div><p>kube-scheduler 플래그 <code>--config=/path/to/config/file</code> 을 사용하여
<code>KubeSchedulerConfiguration</code> 파일을 참조하면 구성이 스케줄러에
전달된다.</p>
<p><strong>이 기능은 기본적으로 비활성화되어 있다.</strong></p>
<h3 id=우선-순위-기능-튜닝하기>우선 순위 기능 튜닝하기</h3>
<p><code>shape</code> 는 <code>RequestedToCapacityRatioPriority</code> 기능의
동작을 지정하는 데 사용된다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>shape</span>:<span style=color:#bbb>
</span><span style=color:#bbb> </span>- <span style=color:green;font-weight:700>utilization</span>:<span style=color:#bbb> </span><span style=color:#666>0</span><span style=color:#bbb>
</span><span style=color:#bbb>   </span><span style=color:green;font-weight:700>score</span>:<span style=color:#bbb> </span><span style=color:#666>0</span><span style=color:#bbb>
</span><span style=color:#bbb> </span>- <span style=color:green;font-weight:700>utilization</span>:<span style=color:#bbb> </span><span style=color:#666>100</span><span style=color:#bbb>
</span><span style=color:#bbb>   </span><span style=color:green;font-weight:700>score</span>:<span style=color:#bbb> </span><span style=color:#666>10</span><span style=color:#bbb>
</span></code></pre></div><p>위의 인수는 <code>utilization</code> 이 0%인 경우 <code>score</code> 는 0, <code>utilization</code> 이
100%인 경우 10으로 하여, 빈 패킹 동작을 활성화한다. 최소 요청을
활성화하려면 점수 값을 다음과 같이 변경해야 한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>shape</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>utilization</span>:<span style=color:#bbb> </span><span style=color:#666>0</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>score</span>:<span style=color:#bbb> </span><span style=color:#666>10</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>utilization</span>:<span style=color:#bbb> </span><span style=color:#666>100</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>score</span>:<span style=color:#bbb> </span><span style=color:#666>0</span><span style=color:#bbb>
</span></code></pre></div><p><code>resources</code> 는 기본적으로 다음과 같이 설정되는 선택적인 파라미터이다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cpu<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>weight</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>memory<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>weight</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></code></pre></div><p>다음과 같이 확장된 리소스를 추가하는 데 사용할 수 있다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>intel.com/foo<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>weight</span>:<span style=color:#bbb> </span><span style=color:#666>5</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cpu<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>weight</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>memory<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>weight</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></code></pre></div><p><code>weight</code> 파라미터는 선택 사항이며 지정되지 않은 경우 1로 설정 된다. 또한,
<code>weight</code> 는 음수로 설정할 수 없다.</p>
<h3 id=용량-할당을-위해-노드에-점수-매기기>용량 할당을 위해 노드에 점수 매기기</h3>
<p>이 섹션은 이 기능 내부의 세부적인 사항을 이해하려는 사람들을
위한 것이다.
아래는 주어진 값의 집합에 대해 노드 점수가 계산되는 방법의 예시이다.</p>
<p>요청된 리소스는 다음과 같다.</p>
<pre><code>intel.com/foo : 2
memory: 256MB
cpu: 2
</code></pre><p>리소스의 가중치는 다음과 같다.</p>
<pre><code>intel.com/foo : 5
memory: 1
cpu: 3
</code></pre><p>FunctionShapePoint {{0, 0}, {100, 10}}</p>
<p>노드 1의 사양은 다음과 같다.</p>
<pre><code>Available:
  intel.com/foo: 4
  memory: 1 GB
  cpu: 8

Used:
  intel.com/foo: 1
  memory: 256MB
  cpu: 1
</code></pre><p>노드 점수는 다음과 같다.</p>
<pre><code>intel.com/foo  = resourceScoringFunction((2+1),4)
               = (100 - ((4-3)*100/4)
               = (100 - 25)
               = 75                       # requested + used = 75% * available
               = rawScoringFunction(75) 
               = 7                        # floor(75/10) 

memory         = resourceScoringFunction((256+256),1024)
               = (100 -((1024-512)*100/1024))
               = 50                       # requested + used = 50% * available
               = rawScoringFunction(50)
               = 5                        # floor(50/10)

cpu            = resourceScoringFunction((2+1),8)
               = (100 -((8-3)*100/8))
               = 37.5                     # requested + used = 37.5% * available
               = rawScoringFunction(37.5)
               = 3                        # floor(37.5/10)

NodeScore   =  (7 * 5) + (5 * 1) + (3 * 3) / (5 + 1 + 3)
            =  5
</code></pre><p>노드 2의 사양은 다음과 같다.</p>
<pre><code>Available:
  intel.com/foo: 8
  memory: 1GB
  cpu: 8
Used:
  intel.com/foo: 2
  memory: 512MB
  cpu: 6
</code></pre><p>노드 점수는 다음과 같다.</p>
<pre><code>intel.com/foo  = resourceScoringFunction((2+2),8)
               =  (100 - ((8-4)*100/8)
               =  (100 - 50)
               =  50
               =  rawScoringFunction(50)
               = 5

Memory         = resourceScoringFunction((256+512),1024)
               = (100 -((1024-768)*100/1024))
               = 75
               = rawScoringFunction(75)
               = 7

cpu            = resourceScoringFunction((2+6),8)
               = (100 -((8-8)*100/8))
               = 100
               = rawScoringFunction(100)
               = 10

NodeScore   =  (5 * 5) + (7 * 1) + (10 * 3) / (5 + 1 + 3)
            =  7

</code></pre><h2 id=다음-내용>다음 내용</h2>
<ul>
<li><a href=/docs/concepts/scheduling-eviction/scheduling-framework/>스케줄링 프레임워크</a>에 대해 더 읽어본다.</li>
<li><a href=/ko/docs/reference/scheduling/config/>스케줄러 구성</a>에 대해 더 읽어본다.</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-d9574a30fcbc631b0d2a57850e161e89>9.9 - 스케줄러 성능 튜닝</h1>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes 1.14 [beta]</code>
</div>
<p><a href=/ko/docs/concepts/scheduling-eviction/kube-scheduler/#kube-scheduler>kube-scheduler</a>는
쿠버네티스의 기본 스케줄러이다. 그것은 클러스터의
노드에 파드를 배치하는 역할을 한다.</p>
<p>파드의 스케줄링 요건을 충족하는
클러스터의 노드를 파드에 <em>적합한(feasible)</em> 노드라고 한다. 스케줄러는
파드에 대해 적합한 노드를 찾고 기능 셋을 실행하여 해당 노드의 점수를
측정한다. 그리고 스케줄러는 파드를 실행하는데 적합한 모든 노드 중 가장
높은 점수를 가진 노드를 선택한다. 이후 스케줄러는 <em>바인딩</em> 이라는 프로세스로
API 서버에 해당 결정을 통지한다.</p>
<p>본 페이지에서는 상대적으로 큰 규모의 쿠버네티스 클러스터에 대한 성능 튜닝
최적화에 대해 설명한다.</p>
<p>큰 규모의 클러스터에서는 스케줄러의 동작을 튜닝하여 응답 시간
(새 파드가 빠르게 배치됨)과 정확도(스케줄러가 배치 결정을 잘 못하는 경우가 드물게 됨)
사이에서의 스케줄링 결과를 균형 잡을 수 있다.</p>
<p>kube-scheduler 의 <code>percentageOfNodesToScore</code> 설정을 통해
이 튜닝을 구성 한다. 이 KubeSchedulerConfiguration 설정에 따라 클러스터의
노드를 스케줄링할 수 있는 임계값이 결정된다.</p>
<h3 id=임계값-설정하기>임계값 설정하기</h3>
<p><code>percentageOfNodesToScore</code> 옵션은 0과 100 사이의 값을
허용한다. 값 0은 kube-scheduler가 컴파일 된 기본값을
사용한다는 것을 나타내는 특별한 숫자이다.
<code>percentageOfNodesToScore</code> 를 100 보다 높게 설정해도 kube-scheduler는
마치 100을 설정한 것처럼 작동한다.</p>
<p>값을 변경하려면,
<a href=/docs/reference/config-api/kube-scheduler-config.v1beta3/>kube-scheduler 구성 파일</a>을
편집한 다음 스케줄러를 재시작한다.
대부분의 경우, 구성 파일은 <code>/etc/kubernetes/config/kube-scheduler.yaml</code> 에서 찾을 수 있다.</p>
<p>이를 변경한 후에 다음을 실행해서</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl get pods -n kube-system | grep kube-scheduler
</code></pre></div><p>kube-scheduler 컴포넌트가 정상인지 확인할 수 있다.</p>
<h2 id=percentage-of-nodes-to-score>노드 스코어링(scoring) 임계값</h2>
<p>스케줄링 성능을 향상시키기 위해 kube-scheduler는 실행 가능한
노드가 충분히 발견되면 이를 찾는 것을 중단할 수 있다. 큰 규모의 클러스터에서는
모든 노드를 고려하는 고지식한 접근 방식에 비해 시간이 절약된다.</p>
<p>클러스터에 있는 모든 노드의 정수 백분율로 충분한 노두의 수에
대한 임계값을 지정한다. kube-scheduler는 이 값을 노드의
정수 값(숫자)로 변환 한다. 스케줄링 중에 kube-scheduler가 구성된
비율을 초과 할만큼 충분히 실행 가능한 노드를 식별한 경우, kube-scheduler는
더 실행 가능한 노드를 찾는 검색을 중지하고
<a href=/ko/docs/concepts/scheduling-eviction/kube-scheduler/#kube-scheduler-implementation>스코어링 단계</a>를 진행한다.</p>
<p><a href=#%EC%8A%A4%EC%BC%80%EC%A4%84%EB%9F%AC%EA%B0%80-%EB%85%B8%EB%93%9C-%ED%83%90%EC%83%89%EC%9D%84-%EB%B0%98%EB%B3%B5-iterate-%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95>스케줄러가 노드 탐색을 반복(iterate)하는 방법</a>
은 이 프로세스를 자세히 설명한다.</p>
<h3 id=기본-임계값>기본 임계값</h3>
<p>임계값을 지정하지 않으면 쿠버네티스는 100 노드 클러스터인
경우 50%, 5000 노드 클러스터인 경우 10%를 산출하는
선형 공식을 사용하여 수치를 계산한다. 자동 값의 하한선은 5% 이다.</p>
<p>즉, <code>percentageOfNodesToScore</code> 를 명시적으로 5보다 작게 설정하지
않은 경우 클러스터가 아무리 크더라도 kube-scheduler는
항상 클러스터의 최소 5%를 스코어링을 한다.</p>
<p>스케줄러가 클러스터의 모든 노드에 스코어링을 하려면
<code>percentageOfNodesToScore</code> 를 100으로 설정 한다.</p>
<h2 id=예시>예시</h2>
<p>아래는 <code>percentageOfNodesToScore</code>를 50%로 설정하는 구성 예시이다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>kubescheduler.config.k8s.io/v1alpha1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>KubeSchedulerConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>algorithmSource</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>provider</span>:<span style=color:#bbb> </span>DefaultProvider<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>percentageOfNodesToScore</span>:<span style=color:#bbb> </span><span style=color:#666>50</span><span style=color:#bbb>
</span></code></pre></div><h3 id=percentageofnodestoscore-튜닝>percentageOfNodesToScore 튜닝</h3>
<p><code>percentageOfNodesToScore</code>는 1과 100 사이의 값이어야 하며
기본값은 클러스터 크기에 따라 계산된다. 또한 50 노드로 하드 코딩된
최솟값도 있다.</p>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> <p>클러스터에서 적합한 노드가 50 미만인 경우, 스케줄러는 여전히
모든 노드를 확인한다. 그 이유는 스케줄러가 탐색을 조기 중단하기에는 적합한
노드의 수가 충분하지 않기 때문이다.</p>
<p>규모가 작은 클러스터에서는 <code>percentageOfNodesToScore</code> 에 낮은 값을 설정하면,
비슷한 이유로 변경 사항이 거의 또는 전혀 영향을 미치지 않게 된다.</p>
<p>클러스터에 수백 개 이하의 노드가 있는 경우 이 구성 옵션을
기본값으로 둔다. 이는 변경사항을 적용하더라도 스케줄러의
성능이 크게 향상되지 않는다.</p>
</div>
<p>이 값을 세팅할 때 중요하고 자세한 사항은, 클러스터에서
적은 수의 노드에 대해서만 적합성을 확인하면, 주어진 파드에 대해서
일부 노드의 점수는 측정이되지 않는다는 것이다. 결과적으로, 주어진 파드를 실행하는데
가장 높은 점수를 가질 가능성이 있는 노드가 점수 측정 단계로 조차 넘어가지
않을 수 있다. 이것은 파드의 이상적인 배치보다 낮은 결과를 초래할 것이다.</p>
<p><code>percentageOfNodesToScore</code> 를 매우 낮게 설정해서 kube-scheduler가
파드 배치 결정을 잘못 내리지 않도록 해야 한다. 스케줄러의 처리량에
대해 애플리케이션이 중요하고 노드 점수가 중요하지 않은 경우가 아니라면
백분율을 10% 미만으로 설정하지 말아야 한다. 즉, 가능한 한
모든 노드에서 파드를 실행하는 것이 좋다.</p>
<h2 id=스케줄러가-노드-탐색을-반복-iterate-하는-방법>스케줄러가 노드 탐색을 반복(iterate)하는 방법</h2>
<p>이 섹션은 이 특징의 상세한 내부 방식을 이해하고 싶은 사람들을
위해 작성되었다.</p>
<p>클러스터의 모든 노드가 파드 실행 대상으로 고려되어 공정한 기회를
가지도록, 스케줄러는 라운드 로빈(round robin) 방식으로 모든 노드에 대해서 탐색을
반복한다. 모든 노드가 배열에 나열되어 있다고 생각해보자. 스케줄러는 배열의
시작부터 시작하여 <code>percentageOfNodesToScore</code>에 명시된 충분한 수의 노드를
찾을 때까지 적합성을 확인한다. 그 다음 파드에 대해서는, 스케줄러가
이전 파드를 위한 노드 적합성 확인이 마무리된 지점인 노드 배열의 마지막
포인트부터 확인을 재개한다.</p>
<p>만약 노드들이 다중의 영역(zone)에 있다면, 다른 영역에 있는 노드들이 적합성
확인의 대상이 되도록 스케줄러는 다양한 영역에 있는 노드에 대해서
탐색을 반복한다. 예제로, 2개의 영역에 있는 6개의 노드를 생각해보자.</p>
<pre><code>영역 1: 노드 1, 노드 2, 노드 3, 노드 4
영역 2: 노드 5, 노드 6
</code></pre><p>스케줄러는 노드의 적합성 평가를 다음의 순서로 실행한다.</p>
<pre><code>노드 1, 노드 5, 노드 2, 노드 6, 노드 3, 노드 4
</code></pre><p>모든 노드를 검토한 후, 노드 1로 돌아간다.</p>
<h2 id=다음-내용>다음 내용</h2>
<ul>
<li><a href=/docs/reference/config-api/kube-scheduler-config.v1beta3/>kube-scheduler 구성 레퍼런스(v1beta3)</a> 확인</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-ac9161c6d952925b083ad9602b4e8e7f>10 - 정책</h1>
<div class=lead>리소스의 그룹에 적용되도록 구성할 수 있는 정책</div>
</div>
<div class=td-content>
<h1 id=pg-a935ff8c59eb116b43494255cc67f69a>10.1 - 리밋 레인지(Limit Range)</h1>
<p>기본적으로 컨테이너는 쿠버네티스 클러스터에서 무제한 <a href=/ko/docs/concepts/configuration/manage-resources-containers/>컴퓨팅 리소스</a>로 실행된다.
리소스 쿼터을 사용하면 클러스터 관리자는 <a class=glossary-tooltip title="쿠버네티스에서 동일한 물리 클러스터에서 다중의 가상 클러스터를 지원하기 위해 사용하는 추상화." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/overview/working-with-objects/namespaces target=_blank aria-label=네임스페이스>네임스페이스</a>별로 리소스 사용과 생성을 제한할 수 있다.
네임스페이스 내에서 파드나 컨테이너는 네임스페이스의 리소스 쿼터에 정의된 만큼의 CPU와 메모리를 사용할 수 있다. 하나의 파드 또는 컨테이너가 사용 가능한 모든 리소스를 독점할 수 있다는 우려가 있다. 리밋레인지는 네임스페이스에서 리소스 할당(파드 또는 컨테이너)을 제한하는 정책이다.</p>
<p><em>리밋레인지</em> 는 다음과 같은 제약 조건을 제공한다.</p>
<ul>
<li>네임스페이스에서 파드 또는 컨테이너별 최소 및 최대 컴퓨팅 리소스 사용량을 지정한다.</li>
<li>네임스페이스에서 스토리지클래스별 최소 및 최대 스토리지 요청을 지정한다.</li>
<li>네임스페이스에서 리소스에 대한 요청과 제한 사이의 비율을 지정한다.</li>
<li>네임스페이스에서 컴퓨팅 리소스에 대한 기본 요청/제한을 설정하고 런타임에 있는 컨테이너에 자동으로 설정한다.</li>
</ul>
<h2 id=리밋레인지-활성화>리밋레인지 활성화</h2>
<p>쿠버네티스 1.10 버전부터 리밋레인지 지원이 기본적으로 활성화되었다.</p>
<p>해당 네임스페이스에 리밋레인지 오브젝트가 있는 경우
특정 네임스페이스에 리밋레인지가 지정된다.</p>
<p>리밋레인지 오브젝트의 이름은 유효한
<a href=/ko/docs/concepts/overview/working-with-objects/names/#dns-%EC%84%9C%EB%B8%8C%EB%8F%84%EB%A9%94%EC%9D%B8-%EC%9D%B4%EB%A6%84>DNS 서브도메인 이름</a>이어야 한다.</p>
<h3 id=리밋-레인지-개요>리밋 레인지 개요</h3>
<ul>
<li>관리자는 하나의 네임스페이스에 하나의 리밋레인지를 만든다.</li>
<li>사용자는 네임스페이스에서 파드, 컨테이너 및 퍼시스턴트볼륨클레임과 같은 리소스를 생성한다.</li>
<li><code>LimitRanger</code> 어드미션 컨트롤러는 컴퓨팅 리소스 요청 사항을 설정하지 않은 모든 파드와 컨테이너에 대한 기본값과 제한을 지정하고 네임스페이스의 리밋레인지에 정의된 리소스의 최소, 최대 및 비율을 초과하지 않도록 사용량을 추적한다.</li>
<li>리밋레인지 제약 조건을 위반하는 리소스(파드, 컨테이너, 퍼시스턴트볼륨클레임)를 생성하거나 업데이트하는 경우 HTTP 상태 코드 <code>403 FORBIDDEN</code> 및 위반된 제약 조건을 설명하는 메시지와 함께 API 서버에 대한 요청이 실패한다.</li>
<li><code>cpu</code>, <code>memory</code>와 같은 컴퓨팅 리소스의 네임스페이스에서 리밋레인지가 활성화된 경우 사용자는 해당 값에
대한 요청 또는 제한을 지정해야 한다. 그렇지 않으면 시스템에서 파드 생성이 거부될 수 있다.</li>
<li>리밋레인지 유효성 검사는 파드 실행 단계가 아닌 파드 어드미션 단계에서만 발생한다.</li>
</ul>
<p>리밋 레인지를 사용하여 생성할 수 있는 정책의 예는 다음과 같다.</p>
<ul>
<li>용량이 8GiB RAM과 16 코어인 2 노드 클러스터에서 네임스페이스의 파드를 제한하여 CPU의 최대 제한이 500m인 CPU 100m를 요청하고 메모리의 최대 제한이 600M인 메모리 200Mi를 요청하라.</li>
<li>스펙에 CPU 및 메모리 요청없이 시작된 컨테이너에 대해 기본 CPU 제한 및 요청을 150m로, 메모리 기본 요청을 300Mi로 정의하라.</li>
</ul>
<p>네임스페이스의 총 제한이 파드/컨테이너의 제한 합보다 작은 경우 리소스에 대한 경합이 있을 수 있다.
이 경우 컨테이너 또는 파드가 생성되지 않는다.</p>
<p>경합이나 리밋레인지 변경은 이미 생성된 리소스에 영향을 미치지 않는다.</p>
<h2 id=다음-내용>다음 내용</h2>
<p>자세한 내용은 <a href=https://git.k8s.io/community/contributors/design-proposals/resource-management/admission_control_limit_range.md>LimitRanger 디자인 문서</a>를 참조한다.</p>
<p>제한의 사용에 대한 예시는 다음을 참조한다.</p>
<ul>
<li><a href=/ko/docs/tasks/administer-cluster/manage-resources/cpu-constraint-namespace/>네임스페이스당 최소 및 최대 CPU 제약 조건을 설정하는 방법</a>.</li>
<li><a href=/ko/docs/tasks/administer-cluster/manage-resources/memory-constraint-namespace/>네임스페이스당 최소 및 최대 메모리 제약 조건을 설정하는 방법</a>.</li>
<li><a href=/ko/docs/tasks/administer-cluster/manage-resources/cpu-default-namespace/>네임스페이스당 기본 CPU 요청과 제한을 설정하는 방법</a>.</li>
<li><a href=/ko/docs/tasks/administer-cluster/manage-resources/memory-default-namespace/>네임스페이스당 기본 메모리 요청과 제한을 설정하는 방법</a>.</li>
<li><a href=/docs/tasks/administer-cluster/limit-storage-consumption/#limitrange-to-limit-requests-for-storage>네임스페이스당 최소 및 최대 스토리지 사용량을 설정하는 방법</a>.</li>
<li><a href=/ko/docs/tasks/administer-cluster/manage-resources/quota-memory-cpu-namespace/>네임스페이스당 할당량을 설정하는 자세한 예시</a>.</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-94ddc6e901c30f256138db11d09f05a3>10.2 - 리소스 쿼터</h1>
<p>여러 사용자나 팀이 정해진 수의 노드로 클러스터를 공유할 때
한 팀이 공정하게 분배된 리소스보다 많은 리소스를 사용할 수 있다는 우려가 있다.</p>
<p>리소스 쿼터는 관리자가 이 문제를 해결하기 위한 도구이다.</p>
<p><code>ResourceQuota</code> 오브젝트로 정의된 리소스 쿼터는 네임스페이스별 총 리소스 사용을 제한하는
제약 조건을 제공한다. 유형별로 네임스페이스에서 만들 수 있는 오브젝트 수와
해당 네임스페이스의 리소스가 사용할 수 있는 총 컴퓨트 리소스의 양을
제한할 수 있다.</p>
<p>리소스 쿼터는 다음과 같이 작동한다.</p>
<ul>
<li>
<p>다른 팀은 다른 네임스페이스에서 작동한다. 현재 이것은 자발적이지만 ACL을 통해 이 필수 사항을
적용하기 위한 지원이 계획되어 있다.</p>
</li>
<li>
<p>관리자는 각 네임스페이스에 대해 하나의 리소스쿼터를 생성한다.</p>
</li>
<li>
<p>사용자는 네임스페이스에서 리소스(파드, 서비스 등)를 생성하고 쿼터 시스템은
사용량을 추적하여 리소스쿼터에 정의된 하드(hard) 리소스 제한을 초과하지 않도록 한다.</p>
</li>
<li>
<p>리소스를 생성하거나 업데이트할 때 쿼터 제약 조건을 위반하면 위반된 제약 조건을 설명하는
메시지와 함께 HTTP 상태 코드 <code>403 FORBIDDEN</code>으로 요청이 실패한다.</p>
</li>
<li>
<p><code>cpu</code>, <code>memory</code>와 같은 컴퓨트 리소스에 대해 네임스페이스에서 쿼터가 활성화된 경우
사용자는 해당값에 대한 요청 또는 제한을 지정해야 한다. 그렇지 않으면 쿼터 시스템이
파드 생성을 거부할 수 있다. 힌트: 컴퓨트 리소스 요구 사항이 없는 파드를 기본값으로 설정하려면 <code>LimitRanger</code> 어드미션 컨트롤러를 사용하자.</p>
<p>이 문제를 회피하는 방법에 대한 예제는
<a href=/ko/docs/tasks/administer-cluster/manage-resources/quota-memory-cpu-namespace/>연습</a>을 참고하길 바란다.</p>
</li>
</ul>
<p>리소스쿼터 오브젝트의 이름은 유효한
<a href=/ko/docs/concepts/overview/working-with-objects/names#dns-%EC%84%9C%EB%B8%8C%EB%8F%84%EB%A9%94%EC%9D%B8-%EC%9D%B4%EB%A6%84>DNS 서브도메인 이름</a>이어야 한다.</p>
<p>네임스페이스와 쿼터를 사용하여 만들 수 있는 정책의 예는 다음과 같다.</p>
<ul>
<li>용량이 32GiB RAM, 16 코어인 클러스터에서 A 팀이 20GiB 및 10 코어를 사용하고
B 팀은 10GiB 및 4 코어를 사용하게 하고 2GiB 및 2 코어를 향후 할당을 위해 보유하도록 한다.</li>
<li>"testing" 네임스페이스를 1 코어 및 1GiB RAM을 사용하도록 제한한다.
"production" 네임스페이스에는 원하는 양을 사용하도록 한다.</li>
</ul>
<p>클러스터의 총 용량이 네임스페이스의 쿼터 합보다 작은 경우 리소스에 대한 경합이 있을 수 있다.
이것은 선착순으로 처리된다.</p>
<p>경합이나 쿼터 변경은 이미 생성된 리소스에 영향을 미치지 않는다.</p>
<h2 id=리소스-쿼터-활성화>리소스 쿼터 활성화</h2>
<p>많은 쿠버네티스 배포판에 기본적으로 리소스 쿼터 지원이 활성화되어 있다.
<a class=glossary-tooltip title="쿠버네티스 API를 제공하는 컨트롤 플레인 컴포넌트." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/overview/components/#kube-apiserver target=_blank aria-label="API 서버">API 서버</a>
<code>--enable-admission-plugins=</code> 플래그의 인수 중 하나로
<code>ResourceQuota</code>가 있는 경우 활성화된다.</p>
<p>해당 네임스페이스에 리소스쿼터가 있는 경우 특정 네임스페이스에
리소스 쿼터가 적용된다.</p>
<h2 id=컴퓨트-리소스-쿼터>컴퓨트 리소스 쿼터</h2>
<p>지정된 네임스페이스에서 요청할 수 있는 총
<a href=/ko/docs/concepts/configuration/manage-resources-containers/>컴퓨트 리소스</a>
합을 제한할 수 있다.</p>
<p>다음과 같은 리소스 유형이 지원된다.</p>
<table>
<thead>
<tr>
<th>리소스 이름</th>
<th>설명</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>limits.cpu</code></td>
<td>터미널이 아닌 상태의 모든 파드에서 CPU 제한의 합은 이 값을 초과할 수 없음.</td>
</tr>
<tr>
<td><code>limits.memory</code></td>
<td>터미널이 아닌 상태의 모든 파드에서 메모리 제한의 합은 이 값을 초과할 수 없음.</td>
</tr>
<tr>
<td><code>requests.cpu</code></td>
<td>터미널이 아닌 상태의 모든 파드에서 CPU 요청의 합은 이 값을 초과할 수 없음.</td>
</tr>
<tr>
<td><code>requests.memory</code></td>
<td>터미널이 아닌 상태의 모든 파드에서 메모리 요청의 합은 이 값을 초과할 수 없음.</td>
</tr>
<tr>
<td><code>hugepages-&lt;size></code></td>
<td>터미널 상태가 아닌 모든 파드에 걸쳐서, 지정된 사이즈의 휴즈 페이지 요청은 이 값을 초과하지 못함.</td>
</tr>
<tr>
<td><code>cpu</code></td>
<td><code>requests.cpu</code> 와 같음.</td>
</tr>
<tr>
<td><code>memory</code></td>
<td><code>requests.memory</code> 와 같음.</td>
</tr>
</tbody>
</table>
<h3 id=확장된-리소스에-대한-리소스-쿼터>확장된 리소스에 대한 리소스 쿼터</h3>
<p>위에서 언급한 리소스 외에도 릴리스 1.10에서는
<a href=/ko/docs/concepts/configuration/manage-resources-containers/#%ED%99%95%EC%9E%A5%EB%90%9C-%EB%A6%AC%EC%86%8C%EC%8A%A4>확장된 리소스</a>에 대한 쿼터 지원이 추가되었다.</p>
<p>확장된 리소스에는 오버커밋(overcommit)이 허용되지 않으므로 하나의 쿼터에서
동일한 확장된 리소스에 대한 <code>requests</code>와 <code>limits</code>을 모두 지정하는 것은 의미가 없다. 따라서 확장된
리소스의 경우 지금은 접두사 <code>requests.</code>이 있는 쿼터 항목만 허용된다.</p>
<p>예를 들어, 리소스 이름이 <code>nvidia.com/gpu</code>이고 네임스페이스에서 요청된 총 GPU 수를 4개로 제한하려는 경우,
GPU 리소스를 다음과 같이 쿼터를 정의할 수 있다.</p>
<ul>
<li><code>requests.nvidia.com/gpu: 4</code></li>
</ul>
<p>자세한 내용은 <a href=#%EC%BF%BC%ED%84%B0-%EB%B3%B4%EA%B8%B0-%EB%B0%8F-%EC%84%A4%EC%A0%95>쿼터 보기 및 설정</a>을 참고하길 바란다.</p>
<h2 id=스토리지-리소스-쿼터>스토리지 리소스 쿼터</h2>
<p>지정된 네임스페이스에서 요청할 수 있는 총 <a href=/ko/docs/concepts/storage/persistent-volumes/>스토리지 리소스</a> 합을 제한할 수 있다.</p>
<p>또한 연관된 스토리지 클래스를 기반으로 스토리지 리소스 사용을 제한할 수 있다.</p>
<table>
<thead>
<tr>
<th>리소스 이름</th>
<th>설명</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>requests.storage</code></td>
<td>모든 퍼시스턴트 볼륨 클레임에서 스토리지 요청의 합은 이 값을 초과할 수 없음</td>
</tr>
<tr>
<td><code>persistentvolumeclaims</code></td>
<td>네임스페이스에 존재할 수 있는 총 <a href=/ko/docs/concepts/storage/persistent-volumes/#%ED%8D%BC%EC%8B%9C%EC%8A%A4%ED%84%B4%ED%8A%B8%EB%B3%BC%EB%A5%A8%ED%81%B4%EB%A0%88%EC%9E%84>퍼시스턴트 볼륨 클레임</a> 수</td>
</tr>
<tr>
<td><code>&lt;storage-class-name>.storageclass.storage.k8s.io/requests.storage</code></td>
<td>storage-class-name과 관련된 모든 퍼시스턴트 볼륨 클레임에서 스토리지 요청의 합은 이 값을 초과할 수 없음</td>
</tr>
<tr>
<td><code>&lt;storage-class-name>.storageclass.storage.k8s.io/persistentvolumeclaims</code></td>
<td><code>&lt;storage-class-name></code> 과 관련된 모든 퍼시스턴트 볼륨 클레임에서 네임스페이스에 존재할 수 있는 총 <a href=/ko/docs/concepts/storage/persistent-volumes/#%ED%8D%BC%EC%8B%9C%EC%8A%A4%ED%84%B4%ED%8A%B8%EB%B3%BC%EB%A5%A8%ED%81%B4%EB%A0%88%EC%9E%84>퍼시스턴트 볼륨 클레임</a> 수</td>
</tr>
</tbody>
</table>
<p>예를 들어, 운영자가 <code>bronze</code> 스토리지 클래스와 별도로 <code>gold</code> 스토리지 클래스를 사용하여 스토리지에 쿼터를 지정하려는 경우 운영자는 다음과 같이
쿼터를 정의할 수 있다.</p>
<ul>
<li><code>gold.storageclass.storage.k8s.io/requests.storage: 500Gi</code></li>
<li><code>bronze.storageclass.storage.k8s.io/requests.storage: 100Gi</code></li>
</ul>
<p>릴리스 1.8에서는 로컬 임시 스토리지에 대한 쿼터 지원이 알파 기능으로 추가되었다.</p>
<table>
<thead>
<tr>
<th>리소스 이름</th>
<th>설명</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>requests.ephemeral-storage</code></td>
<td>네임스페이스의 모든 파드에서 로컬 임시 스토리지 요청의 합은 이 값을 초과할 수 없음.</td>
</tr>
<tr>
<td><code>limits.ephemeral-storage</code></td>
<td>네임스페이스의 모든 파드에서 로컬 임시 스토리지 제한의 합은 이 값을 초과할 수 없음.</td>
</tr>
<tr>
<td><code>ephemeral-storage</code></td>
<td><code>requests.ephemeral-storage</code> 와 같음.</td>
</tr>
</tbody>
</table>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> CRI 컨테이너 런타임을 사용할 때, 컨테이너 로그는 임시 스토리지 쿼터에 포함된다.
이로 인해 스토리지 쿼터를 소진한 파드가 예기치 않게 축출될 수 있다.
자세한 내용은 <a href=/ko/docs/concepts/cluster-administration/logging/>로깅 아키텍처</a>를 참조한다.
</div>
<h2 id=오브젝트-수-쿼터>오브젝트 수 쿼터</h2>
<p>다음 구문을 사용하여 모든 표준 네임스페이스 처리된(namespaced) 리소스 유형에 대한
특정 리소스 전체 수에 대하여 쿼터를 지정할 수 있다.</p>
<ul>
<li>코어 그룹이 아닌(non-core) 리소스를 위한 <code>count/&lt;resource>.&lt;group></code></li>
<li>코어 그룹의 리소스를 위한 <code>count/&lt;resource></code></li>
</ul>
<p>다음은 사용자가 오브젝트 수 쿼터 아래에 배치하려는 리소스 셋의 예이다.</p>
<ul>
<li><code>count/persistentvolumeclaims</code></li>
<li><code>count/services</code></li>
<li><code>count/secrets</code></li>
<li><code>count/configmaps</code></li>
<li><code>count/replicationcontrollers</code></li>
<li><code>count/deployments.apps</code></li>
<li><code>count/replicasets.apps</code></li>
<li><code>count/statefulsets.apps</code></li>
<li><code>count/jobs.batch</code></li>
<li><code>count/cronjobs.batch</code></li>
</ul>
<p>사용자 정의 리소스를 위해 동일한 구문을 사용할 수 있다.
예를 들어 <code>example.com</code> API 그룹에서 <code>widgets</code> 사용자 정의 리소스에 대한 쿼터를 생성하려면 <code>count/widgets.example.com</code>을 사용한다.</p>
<p><code>count/*</code> 리소스 쿼터를 사용할 때 서버 스토리지 영역에 있다면 오브젝트는 쿼터에 대해 과금된다.
이러한 유형의 쿼터는 스토리지 리소스 고갈을 방지하는 데 유용하다. 예를 들어,
크기가 큰 서버에서 시크릿 수에 쿼터를 지정할 수 있다. 클러스터에 시크릿이 너무 많으면 실제로 서버와
컨트롤러가 시작되지 않을 수 있다. 잘못 구성된 크론 잡으로부터의 보호를 위해
잡의 쿼터를 설정할 수 있다. 네임스페이스 내에서 너무 많은 잡을 생성하는 크론 잡은 서비스 거부를 유발할 수 있다.</p>
<p>또한 제한된 리소스 셋에 대해서 일반 오브젝트 수(generic object count) 쿼터를 적용하는 것도 가능하다.
다음 유형이 지원된다.</p>
<table>
<thead>
<tr>
<th>리소스 이름</th>
<th>설명</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>configmaps</code></td>
<td>네임스페이스에 존재할 수 있는 총 컨피그맵 수</td>
</tr>
<tr>
<td><code>persistentvolumeclaims</code></td>
<td>네임스페이스에 존재할 수 있는 총 <a href=/ko/docs/concepts/storage/persistent-volumes/#%ED%8D%BC%EC%8B%9C%EC%8A%A4%ED%84%B4%ED%8A%B8%EB%B3%BC%EB%A5%A8%ED%81%B4%EB%A0%88%EC%9E%84>퍼시스턴트 볼륨 클레임</a> 수</td>
</tr>
<tr>
<td><code>pods</code></td>
<td>네임스페이스에 존재할 수 있는 터미널이 아닌 상태의 파드의 총 수. <code>.status.phase in (Failed, Succeeded)</code>가 true인 경우 파드는 터미널 상태임</td>
</tr>
<tr>
<td><code>replicationcontrollers</code></td>
<td>네임스페이스에 존재할 수 있는 총 레플리케이션컨트롤러 수</td>
</tr>
<tr>
<td><code>resourcequotas</code></td>
<td>네임스페이스에 존재할 수 있는 총 리소스쿼터 수</td>
</tr>
<tr>
<td><code>services</code></td>
<td>네임스페이스에 존재할 수 있는 총 서비스 수</td>
</tr>
<tr>
<td><code>services.loadbalancers</code></td>
<td>네임스페이스에 존재할 수 있는 <code>LoadBalancer</code> 유형의 총 서비스 수</td>
</tr>
<tr>
<td><code>services.nodeports</code></td>
<td>네임스페이스에 존재할 수 있는 <code>NodePort</code> 유형의 총 서비스 수</td>
</tr>
<tr>
<td><code>secrets</code></td>
<td>네임스페이스에 존재할 수 있는 총 시크릿 수</td>
</tr>
</tbody>
</table>
<p>예를 들어, <code>pods</code> 쿼터는 터미널이 아닌 단일 네임스페이스에서 생성된 <code>pods</code> 수를
계산하고 최댓값을 적용한다. 사용자가 작은 파드를 많이 생성하여 클러스터의 파드 IP
공급이 고갈되는 경우를 피하기 위해 네임스페이스에
<code>pods</code> 쿼터를 설정할 수 있다.</p>
<h2 id=쿼터-범위>쿼터 범위</h2>
<p>각 쿼터에는 연결된 <code>scopes</code> 셋이 있을 수 있다. 쿼터는 열거된 범위의 교차 부분과 일치하는 경우에만
리소스 사용량을 측정한다.</p>
<p>범위가 쿼터에 추가되면 해당 범위와 관련된 리소스를 지원하는 리소스 수가 제한된다.
허용된 셋 이외의 쿼터에 지정된 리소스는 유효성 검사 오류가 발생한다.</p>
<table>
<thead>
<tr>
<th>범위</th>
<th>설명</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Terminating</code></td>
<td><code>.spec.activeDeadlineSeconds >= 0</code>에 일치하는 파드</td>
</tr>
<tr>
<td><code>NotTerminating</code></td>
<td><code>.spec.activeDeadlineSeconds is nil</code>에 일치하는 파드</td>
</tr>
<tr>
<td><code>BestEffort</code></td>
<td>최상의 서비스 품질을 제공하는 파드</td>
</tr>
<tr>
<td><code>NotBestEffort</code></td>
<td>서비스 품질이 나쁜 파드</td>
</tr>
<tr>
<td><code>PriorityClass</code></td>
<td>지정된 <a href=/ko/docs/concepts/scheduling-eviction/pod-priority-preemption/>프라이어리티클래스</a>를 참조하여 일치하는 파드.</td>
</tr>
<tr>
<td><code>CrossNamespacePodAffinity</code></td>
<td>크로스-네임스페이스 파드 [(안티)어피니티 용어]가 있는 파드</td>
</tr>
</tbody>
</table>
<p><code>BestEffort</code> 범위는 다음의 리소스를 추적하도록 쿼터를 제한한다.</p>
<ul>
<li><code>pods</code></li>
</ul>
<p><code>Terminating</code>, <code>NotTerminating</code>, <code>NotBestEffort</code> 및 <code>PriorityClass</code>
범위는 쿼터를 제한하여 다음의 리소스를 추적한다.</p>
<ul>
<li><code>pods</code></li>
<li><code>cpu</code></li>
<li><code>memory</code></li>
<li><code>requests.cpu</code></li>
<li><code>requests.memory</code></li>
<li><code>limits.cpu</code></li>
<li><code>limits.memory</code></li>
</ul>
<p><code>Terminating</code> 과 <code>NotTerminating</code> 범위를 동일한 쿼터 내에 모두
명시하지는 못하며, 마찬가지로 <code>BestEffort</code> 와
<code>NotBestEffort</code> 범위도 동일한 쿼터 내에서 모두 명시하지는 못한다.</p>
<p><code>scopeSelector</code> 는 <code>operator</code> 필드에 다음의 값을 지원한다.</p>
<ul>
<li><code>In</code></li>
<li><code>NotIn</code></li>
<li><code>Exists</code></li>
<li><code>DoesNotExist</code></li>
</ul>
<p><code>scopeSelector</code> 를 정의할 때, <code>scopeName</code> 으로 다음의 값 중 하나를 사용하는
경우, <code>operator</code> 는 <code>Exists</code> 이어야 한다.</p>
<ul>
<li><code>Terminating</code></li>
<li><code>NotTerminating</code></li>
<li><code>BestEffort</code></li>
<li><code>NotBestEffort</code></li>
</ul>
<p>만약 <code>operator</code> 가 <code>In</code> 또는 <code>NotIn</code> 인 경우, <code>values</code> 필드는 적어도 하나의 값은
가져야 한다. 예를 들면 다음과 같다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#bbb>  </span><span style=color:green;font-weight:700>scopeSelector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>scopeName</span>:<span style=color:#bbb> </span>PriorityClass<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span>In<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>values</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span>- middle<span style=color:#bbb>
</span></code></pre></div><p>만약 <code>operator</code> 가 <code>Exists</code> 또는 <code>DoesNotExist</code> 이라면, <code>values</code> 필드는 명시되면
<em>안된다</em>.</p>
<h3 id=priorityclass별-리소스-쿼터>PriorityClass별 리소스 쿼터</h3>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.17 [stable]</code>
</div>
<p>특정 <a href=/ko/docs/concepts/scheduling-eviction/pod-priority-preemption/#%ED%8C%8C%EB%93%9C-%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84>우선 순위</a>로 파드를 생성할 수 있다.
쿼터 스펙의 <code>scopeSelector</code> 필드를 사용하여 파드의 우선 순위에 따라 파드의 시스템 리소스 사용을
제어할 수 있다.</p>
<p>쿼터 스펙의 <code>scopeSelector</code>가 파드를 선택한 경우에만 쿼터가 일치하고 사용된다.</p>
<p><code>scopeSelector</code> 필드를 사용하여 우선 순위 클래스의 쿼터 범위를 지정하면,
쿼터 오브젝트는 다음의 리소스만 추적하도록 제한된다.</p>
<ul>
<li><code>pods</code></li>
<li><code>cpu</code></li>
<li><code>memory</code></li>
<li><code>ephemeral-storage</code></li>
<li><code>limits.cpu</code></li>
<li><code>limits.memory</code></li>
<li><code>limits.ephemeral-storage</code></li>
<li><code>requests.cpu</code></li>
<li><code>requests.memory</code></li>
<li><code>requests.ephemeral-storage</code></li>
</ul>
<p>이 예에서는 쿼터 오브젝트를 생성하여 특정 우선 순위의 파드와 일치시킨다.
예제는 다음과 같이 작동한다.</p>
<ul>
<li>클러스터의 파드는 "low(낮음)", "medium(중간)", "high(높음)"의 세 가지 우선 순위 클래스 중 하나를 가진다.</li>
<li>각 우선 순위마다 하나의 쿼터 오브젝트가 생성된다.</li>
</ul>
<p>다음 YAML을 <code>quota.yml</code> 파일에 저장한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>List<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>items</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ResourceQuota<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pods-high<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>hard</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;1000&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>200Gi<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>pods</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;10&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>scopeSelector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>operator </span>:<span style=color:#bbb> </span>In<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>scopeName</span>:<span style=color:#bbb> </span>PriorityClass<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>values</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;high&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ResourceQuota<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pods-medium<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>hard</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;10&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>20Gi<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>pods</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;10&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>scopeSelector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>operator </span>:<span style=color:#bbb> </span>In<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>scopeName</span>:<span style=color:#bbb> </span>PriorityClass<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>values</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;medium&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ResourceQuota<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pods-low<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>hard</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;5&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>10Gi<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>pods</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;10&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>scopeSelector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>operator </span>:<span style=color:#bbb> </span>In<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>scopeName</span>:<span style=color:#bbb> </span>PriorityClass<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>values</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;low&#34;</span>]<span style=color:#bbb>
</span></code></pre></div><p><code>kubectl create</code>를 사용하여 YAML을 적용한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create -f ./quota.yml
</code></pre></div><pre><code>resourcequota/pods-high created
resourcequota/pods-medium created
resourcequota/pods-low created
</code></pre><p><code>kubectl describe quota</code>를 사용하여 <code>Used</code> 쿼터가 <code>0</code>인지 확인하자.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe quota
</code></pre></div><pre><code>Name:       pods-high
Namespace:  default
Resource    Used  Hard
--------    ----  ----
cpu         0     1k
memory      0     200Gi
pods        0     10


Name:       pods-low
Namespace:  default
Resource    Used  Hard
--------    ----  ----
cpu         0     5
memory      0     10Gi
pods        0     10


Name:       pods-medium
Namespace:  default
Resource    Used  Hard
--------    ----  ----
cpu         0     10
memory      0     20Gi
pods        0     10
</code></pre><p>우선 순위가 "high"인 파드를 생성한다. 다음 YAML을
<code>high-priority-pod.yml</code> 파일에 저장한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>high-priority<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>high-priority<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>ubuntu<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;/bin/sh&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;-c&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;while true; do echo hello; sleep 10;done&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;10Gi&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;500m&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;10Gi&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;500m&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>priorityClassName</span>:<span style=color:#bbb> </span>high<span style=color:#bbb>
</span></code></pre></div><p><code>kubectl create</code>로 적용하자.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create -f ./high-priority-pod.yml
</code></pre></div><p>"high" 우선 순위 쿼터가 적용된 <code>pods-high</code>에 대한 "Used" 통계가 변경되었고
다른 두 쿼터는 변경되지 않았는지 확인한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe quota
</code></pre></div><pre><code>Name:       pods-high
Namespace:  default
Resource    Used  Hard
--------    ----  ----
cpu         500m  1k
memory      10Gi  200Gi
pods        1     10


Name:       pods-low
Namespace:  default
Resource    Used  Hard
--------    ----  ----
cpu         0     5
memory      0     10Gi
pods        0     10


Name:       pods-medium
Namespace:  default
Resource    Used  Hard
--------    ----  ----
cpu         0     10
memory      0     20Gi
pods        0     10
</code></pre><h3 id=네임스페이스-간-파드-어피니티-쿼터>네임스페이스 간 파드 어피니티 쿼터</h3>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.22 [beta]</code>
</div>
<p>오퍼레이터는 네임스페이스를 교차하는 어피니티가 있는 파드를 가질 수 있는 네임스페이스를
제한하기 위해 <code>CrossNamespacePodAffinity</code> 쿼터 범위를 사용할 수 있다. 특히, 파드 어피니티 용어의
<code>namespaces</code> 또는 <code>namespaceSelector</code> 필드를 설정할 수 있는 파드를 제어한다.</p>
<p>안티-어피니티 제약 조건이 있는 파드는 장애 도메인에서 다른 모든 네임스페이스의 파드가 예약되지 않도록
차단할 수 있으므로 사용자가 네임스페이스 간 어피니티 용어를
사용하지 못하도록 하는 것이 바람직할 수 있다.</p>
<p>이 범위 오퍼레이터를 사용하면 <code>CrossNamespaceAffinity</code> 범위와 하드(hard) 제한이 0인
네임스페이스에 리소스 쿼터 오브젝트를 생성하여 특정 네임스페이스(아래 예에서 <code>foo-ns</code>)가 네임스페이스 간 파드 어피니티를
사용하는 파드를 사용하지 못하도록 방지할 수 있다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ResourceQuota<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>disable-cross-namespace-affinity<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>foo-ns<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>hard</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>pods</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;0&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>scopeSelector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>scopeName</span>:<span style=color:#bbb> </span>CrossNamespaceAffinity<span style=color:#bbb>
</span></code></pre></div><p>오퍼레이터가 기본적으로 <code>namespaces</code> 및 <code>namespaceSelector</code> 사용을 허용하지 않고,
특정 네임스페이스에만 허용하려는 경우, kube-apiserver 플래그 --admission-control-config-file를
다음의 구성 파일의 경로로 설정하여 <code>CrossNamespaceAffinity</code> 를
제한된 리소스로 구성할 수 있다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apiserver.config.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>AdmissionConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>plugins</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;ResourceQuota&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>configuration</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apiserver.config.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ResourceQuotaConfiguration<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>limitedResources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>resource</span>:<span style=color:#bbb> </span>pods<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>matchScopes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>scopeName</span>:<span style=color:#bbb> </span>CrossNamespaceAffinity<span style=color:#bbb>
</span></code></pre></div><p>위의 구성을 사용하면, 파드는 생성된 네임스페이스에 <code>CrossNamespaceAffinity</code> 범위가 있는 리소스 쿼터 오브젝트가 있고,
해당 필드를 사용하는 파드 수보다 크거나 같은 하드 제한이 있는 경우에만
파드 어피니티에서 <code>namespaces</code> 및 <code>namespaceSelector</code> 를 사용할 수 있다.</p>
<p>이 기능은 베타이며 기본으로 활성화되어 있다. kube-apiserver 및 kube-scheduler 모두에서
<a href=/ko/docs/reference/command-line-tools-reference/feature-gates/>기능 게이트</a>
<code>PodAffinityNamespaceSelector</code> 를 사용하여 비활성화할 수 있다.</p>
<h2 id=requests-vs-limits>요청과 제한의 비교</h2>
<p>컴퓨트 리소스를 할당할 때 각 컨테이너는 CPU 또는 메모리에 대한 요청과 제한값을 지정할 수 있다.
쿼터는 값에 대한 쿼터를 지정하도록 구성할 수 있다.</p>
<p>쿼터에 <code>requests.cpu</code>나 <code>requests.memory</code>에 지정된 값이 있으면 들어오는 모든
컨테이너가 해당 리소스에 대한 명시적인 요청을 지정해야 한다. 쿼터에 <code>limits.cpu</code>나
<code>limits.memory</code>에 지정된 값이 있으면 들어오는 모든 컨테이너가 해당 리소스에 대한 명시적인 제한을 지정해야 한다.</p>
<h2 id=쿼터-보기-및-설정>쿼터 보기 및 설정</h2>
<p>Kubectl은 쿼터 생성, 업데이트 및 보기를 지원한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create namespace myspace
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>cat <span style=color:#b44>&lt;&lt;EOF &gt; compute-resources.yaml
</span><span style=color:#b44>apiVersion: v1
</span><span style=color:#b44>kind: ResourceQuota
</span><span style=color:#b44>metadata:
</span><span style=color:#b44>  name: compute-resources
</span><span style=color:#b44>spec:
</span><span style=color:#b44>  hard:
</span><span style=color:#b44>    requests.cpu: &#34;1&#34;
</span><span style=color:#b44>    requests.memory: 1Gi
</span><span style=color:#b44>    limits.cpu: &#34;2&#34;
</span><span style=color:#b44>    limits.memory: 2Gi
</span><span style=color:#b44>    requests.nvidia.com/gpu: 4
</span><span style=color:#b44>EOF</span>
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create -f ./compute-resources.yaml --namespace<span style=color:#666>=</span>myspace
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>cat <span style=color:#b44>&lt;&lt;EOF &gt; object-counts.yaml
</span><span style=color:#b44>apiVersion: v1
</span><span style=color:#b44>kind: ResourceQuota
</span><span style=color:#b44>metadata:
</span><span style=color:#b44>  name: object-counts
</span><span style=color:#b44>spec:
</span><span style=color:#b44>  hard:
</span><span style=color:#b44>    configmaps: &#34;10&#34;
</span><span style=color:#b44>    persistentvolumeclaims: &#34;4&#34;
</span><span style=color:#b44>    pods: &#34;4&#34;
</span><span style=color:#b44>    replicationcontrollers: &#34;20&#34;
</span><span style=color:#b44>    secrets: &#34;10&#34;
</span><span style=color:#b44>    services: &#34;10&#34;
</span><span style=color:#b44>    services.loadbalancers: &#34;2&#34;
</span><span style=color:#b44>EOF</span>
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create -f ./object-counts.yaml --namespace<span style=color:#666>=</span>myspace
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get quota --namespace<span style=color:#666>=</span>myspace
</code></pre></div><pre><code class=language-none data-lang=none>NAME                    AGE
compute-resources       30s
object-counts           32s
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe quota compute-resources --namespace<span style=color:#666>=</span>myspace
</code></pre></div><pre><code class=language-none data-lang=none>Name:                    compute-resources
Namespace:               myspace
Resource                 Used  Hard
--------                 ----  ----
limits.cpu               0     2
limits.memory            0     2Gi
requests.cpu             0     1
requests.memory          0     1Gi
requests.nvidia.com/gpu  0     4
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe quota object-counts --namespace<span style=color:#666>=</span>myspace
</code></pre></div><pre><code class=language-none data-lang=none>Name:                   object-counts
Namespace:              myspace
Resource                Used    Hard
--------                ----    ----
configmaps              0       10
persistentvolumeclaims  0       4
pods                    0       4
replicationcontrollers  0       20
secrets                 1       10
services                0       10
services.loadbalancers  0       2
</code></pre><p>Kubectl은 <code>count/&lt;resource>.&lt;group></code> 구문을 사용하여 모든 표준 네임스페이스 리소스에 대한
오브젝트 수 쿼터를 지원한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create namespace myspace
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create quota <span style=color:#a2f>test</span> --hard<span style=color:#666>=</span>count/deployments.apps<span style=color:#666>=</span>2,count/replicasets.apps<span style=color:#666>=</span>4,count/pods<span style=color:#666>=</span>3,count/secrets<span style=color:#666>=</span><span style=color:#666>4</span> --namespace<span style=color:#666>=</span>myspace
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create deployment nginx --image<span style=color:#666>=</span>nginx --namespace<span style=color:#666>=</span>myspace --replicas<span style=color:#666>=</span><span style=color:#666>2</span>
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe quota --namespace<span style=color:#666>=</span>myspace
</code></pre></div><pre><code>Name:                         test
Namespace:                    myspace
Resource                      Used  Hard
--------                      ----  ----
count/deployments.apps        1     2
count/pods                    2     3
count/replicasets.apps        1     4
count/secrets                 1     4
</code></pre><h2 id=쿼터-및-클러스터-용량>쿼터 및 클러스터 용량</h2>
<p>리소스쿼터는 클러스터 용량과 무관하다. 그것들은 절대 단위로 표현된다.
따라서 클러스터에 노드를 추가해도 각 네임스페이스에 더 많은 리소스를
사용할 수 있는 기능이 자동으로 부여되지는 <em>않는다</em>.</p>
<p>가끔 다음과 같은 보다 복잡한 정책이 필요할 수 있다.</p>
<ul>
<li>여러 팀으로 전체 클러스터 리소스를 비례적으로 나눈다.</li>
<li>각 테넌트가 필요에 따라 리소스 사용량을 늘릴 수 있지만, 실수로 리소스가 고갈되는 것을
막기 위한 충분한 제한이 있다.</li>
<li>하나의 네임스페이스에서 요구를 감지하고 노드를 추가하며 쿼터를 늘린다.</li>
</ul>
<p>이러한 정책은 쿼터 사용을 감시하고 다른 신호에 따라 각 네임스페이스의 쿼터 하드 제한을
조정하는 "컨트롤러"를 작성하여 <code>ResourceQuotas</code>를 구성 요소로
사용하여 구현할 수 있다.</p>
<p>리소스 쿼터는 통합된 클러스터 리소스를 분할하지만 노드에 대한 제한은 없다.
여러 네임스페이스의 파드가 동일한 노드에서 실행될 수 있다.</p>
<h2 id=기본적으로-우선-순위-클래스-소비-제한>기본적으로 우선 순위 클래스 소비 제한</h2>
<p>파드가 특정 우선 순위, 예를 들어 일치하는 쿼터 오브젝트가 존재하는
경우에만 "cluster-services"가 네임스페이스에 허용되어야 한다.</p>
<p>이 메커니즘을 통해 운영자는 특정 우선 순위가 높은 클래스의 사용을
제한된 수의 네임스페이스로 제한할 수 있으며 모든 네임스페이스가
기본적으로 이러한 우선 순위 클래스를 사용할 수 있는 것은 아니다.</p>
<p>이를 적용하려면 kube-apiserver 플래그 <code>--admission-control-config-file</code> 을
사용하여 다음 구성 파일의 경로를 전달해야 한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apiserver.config.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>AdmissionConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>plugins</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;ResourceQuota&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>configuration</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apiserver.config.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ResourceQuotaConfiguration<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>limitedResources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>resource</span>:<span style=color:#bbb> </span>pods<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>matchScopes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>scopeName</span>:<span style=color:#bbb> </span>PriorityClass<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span>In<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>values</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;cluster-services&#34;</span>]<span style=color:#bbb>
</span></code></pre></div><p>그리고, <code>kube-system</code> 네임스페이스에 리소스 쿼터 오브젝트를 생성한다.</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/ko/examples/policy/priority-class-resourcequota.yaml download=policy/priority-class-resourcequota.yaml><code>policy/priority-class-resourcequota.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('policy-priority-class-resourcequota-yaml')" title="Copy policy/priority-class-resourcequota.yaml to clipboard">
</img>
</div>
<div class=includecode id=policy-priority-class-resourcequota-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ResourceQuota<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pods-cluster-services<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>scopeSelector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>operator </span>:<span style=color:#bbb> </span>In<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>scopeName</span>:<span style=color:#bbb> </span>PriorityClass<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>values</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;cluster-services&#34;</span>]</code></pre></div>
</div>
</div>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/policy/priority-class-resourcequota.yaml -n kube-system
</code></pre></div><pre><code class=language-none data-lang=none>resourcequota/pods-cluster-services created
</code></pre><p>이 경우, 파드 생성은 다음의 조건을 만족해야 허용될 것이다.</p>
<ol>
<li>파드의 <code>priorityClassName</code> 가 명시되지 않음.</li>
<li>파드의 <code>priorityClassName</code> 가 <code>cluster-services</code> 이외의 다른 값으로 명시됨.</li>
<li>파드의 <code>priorityClassName</code> 가 <code>cluster-services</code> 로 설정되고, 파드가 <code>kube-system</code>
네임스페이스에 생성되었으며 리소스 쿼터 검증을 통과함.</li>
</ol>
<p>파드 생성 요청은 <code>priorityClassName</code> 가 <code>cluster-services</code> 로 명시되고
<code>kube-system</code> 이외의 다른 네임스페이스에 생성되는 경우, 거절된다.</p>
<h2 id=다음-내용>다음 내용</h2>
<ul>
<li>자세한 내용은 <a href=https://git.k8s.io/community/contributors/design-proposals/resource-management/admission_control_resource_quota.md>리소스쿼터 디자인 문서</a>를 참고한다.</li>
<li><a href=/docs/tasks/administer-cluster/quota-api-object/>리소스 쿼터를 사용하는 방법에 대한 자세한 예</a>를 참고한다.</li>
<li><a href=https://github.com/kubernetes/community/blob/master/contributors/design-proposals/scheduling/pod-priority-resourcequota.md>우선 순위 클래스에 대한 쿼터 지원 디자인 문서</a>를 읽는다.</li>
<li><a href=https://github.com/kubernetes/kubernetes/pull/36765>제한된 자원</a>을 참고한다.</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-59977cbac423e20437db079757cb03df>10.3 - 파드 시큐리티 폴리시</h1>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.21 [deprecated]</code>
</div>
<p>파드시큐리티폴리시(PodSecurityPolicy)는 쿠버네티스 v1.21부터 더 이상 사용되지 않으며, v1.25에서 제거될 예정이다.
파드시큐리티폴리시는 <a href=/docs/concepts/security/pod-security-admission/>파드 시큐리티 어드미션</a>으로 대체되었다.
사용 중단에 대한 상세 사항은 <a href=/blog/2021/04/06/podsecuritypolicy-deprecation-past-present-and-future/>파드시큐리티폴리시 사용 중단: 과거, 현재, 그리고 미래</a>를 참조한다.</p>
<p>파드 시큐리티 폴리시를 사용하면 파드 생성 및 업데이트에 대한 세분화된 권한을
부여할 수 있다.</p>
<h2 id=파드-시큐리티-폴리시란>파드 시큐리티 폴리시란?</h2>
<p><em>Pod Security Policy</em> 는 파드 명세의 보안 관련 측면을 제어하는 클러스터-레벨의
리소스이다. <a href=/docs/reference/generated/kubernetes-api/v1.23/#podsecuritypolicy-v1beta1-policy>파드시큐리티폴리시</a> 오브젝트는
관련 필드에 대한 기본값뿐만 아니라 시스템에 적용하기 위해 파드가 실행해야만 하는
조건 셋을 정의한다. 관리자는
다음을 제어할 수 있다.</p>
<table>
<thead>
<tr>
<th>제어 측면</th>
<th>필드 이름</th>
</tr>
</thead>
<tbody>
<tr>
<td>특권을 가진(privileged) 컨테이너의 실행</td>
<td><a href=#%ED%8A%B9%EA%B6%8C%EC%9D%84-%EA%B0%80%EC%A7%84><code>privileged</code></a></td>
</tr>
<tr>
<td>호스트 네임스페이스의 사용</td>
<td><a href=#%ED%98%B8%EC%8A%A4%ED%8A%B8-%EB%84%A4%EC%9E%84%EC%8A%A4%ED%8E%98%EC%9D%B4%EC%8A%A4><code>hostPID</code>, <code>hostIPC</code></a></td>
</tr>
<tr>
<td>호스트 네트워킹과 포트의 사용</td>
<td><a href=#%ED%98%B8%EC%8A%A4%ED%8A%B8-%EB%84%A4%EC%9E%84%EC%8A%A4%ED%8E%98%EC%9D%B4%EC%8A%A4><code>hostNetwork</code>, <code>hostPorts</code></a></td>
</tr>
<tr>
<td>볼륨 유형의 사용</td>
<td><a href=#%EB%B3%BC%EB%A5%A8-%EB%B0%8F-%ED%8C%8C%EC%9D%BC%EC%8B%9C%EC%8A%A4%ED%85%9C><code>volumes</code></a></td>
</tr>
<tr>
<td>호스트 파일시스템의 사용</td>
<td><a href=#%EB%B3%BC%EB%A5%A8-%EB%B0%8F-%ED%8C%8C%EC%9D%BC%EC%8B%9C%EC%8A%A4%ED%85%9C><code>allowedHostPaths</code></a></td>
</tr>
<tr>
<td>특정 FlexVolume 드라이버의 허용</td>
<td><a href=#flexvolume-%EB%93%9C%EB%9D%BC%EC%9D%B4%EB%B2%84><code>allowedFlexVolumes</code></a></td>
</tr>
<tr>
<td>파드 볼륨을 소유한 FSGroup 할당</td>
<td><a href=#%EB%B3%BC%EB%A5%A8-%EB%B0%8F-%ED%8C%8C%EC%9D%BC%EC%8B%9C%EC%8A%A4%ED%85%9C><code>fsGroup</code></a></td>
</tr>
<tr>
<td>읽기 전용 루트 파일시스템 사용 필요</td>
<td><a href=#%EB%B3%BC%EB%A5%A8-%EB%B0%8F-%ED%8C%8C%EC%9D%BC%EC%8B%9C%EC%8A%A4%ED%85%9C><code>readOnlyRootFilesystem</code></a></td>
</tr>
<tr>
<td>컨테이너의 사용자 및 그룹 ID</td>
<td><a href=#%EC%82%AC%EC%9A%A9%EC%9E%90-%EB%B0%8F-%EA%B7%B8%EB%A3%B9><code>runAsUser</code>, <code>runAsGroup</code>, <code>supplementalGroups</code></a></td>
</tr>
<tr>
<td>루트 특권으로의 에스컬레이션 제한</td>
<td><a href=#%EA%B6%8C%ED%95%9C-%EC%97%90%EC%8A%A4%EC%BB%AC%EB%A0%88%EC%9D%B4%EC%85%98><code>allowPrivilegeEscalation</code>, <code>defaultAllowPrivilegeEscalation</code></a></td>
</tr>
<tr>
<td>리눅스 기능</td>
<td><a href=#%EA%B8%B0%EB%8A%A5><code>defaultAddCapabilities</code>, <code>requiredDropCapabilities</code>, <code>allowedCapabilities</code></a></td>
</tr>
<tr>
<td>컨테이너의 SELinux 컨텍스트</td>
<td><a href=#selinux><code>seLinux</code></a></td>
</tr>
<tr>
<td>컨테이너에 허용된 Proc 마운트 유형</td>
<td><a href=#allowedprocmounttypes><code>allowedProcMountTypes</code></a></td>
</tr>
<tr>
<td>컨테이너가 사용하는 AppArmor 프로파일</td>
<td><a href=#apparmor>어노테이션</a></td>
</tr>
<tr>
<td>컨테이너가 사용하는 seccomp 프로파일</td>
<td><a href=#seccomp>어노테이션</a></td>
</tr>
<tr>
<td>컨테이너가 사용하는 sysctl 프로파일</td>
<td><a href=#sysctl><code>forbiddenSysctls</code>,<code>allowedUnsafeSysctls</code></a></td>
</tr>
</tbody>
</table>
<h2 id=파드-시큐리티-폴리시-활성화>파드 시큐리티 폴리시 활성화</h2>
<p>파드 시큐리티 폴리시 제어는 선택 사항인 <a href=/docs/reference/access-authn-authz/admission-controllers/#podsecuritypolicy>어드미션
컨트롤러</a>로 구현된다.
<a href=/docs/reference/access-authn-authz/admission-controllers/#how-do-i-turn-on-an-admission-control-plug-in>어드미션 컨트롤러를 활성화</a>하면
파드시큐리티폴리시가 적용되지만,
정책을 승인하지 않고 활성화하면 클러스터에
<strong>파드가 생성되지 않는다.</strong></p>
<p>파드 시큐리티 폴리시 API(<code>policy/v1beta1/podsecuritypolicy</code>)는
어드미션 컨트롤러와 독립적으로 활성화되므로 기존 클러스터의 경우
어드미션 컨트롤러를 활성화하기 전에 정책을 추가하고 권한을
부여하는 것이 좋다.</p>
<h2 id=정책-승인>정책 승인</h2>
<p>파드시큐리티폴리시 리소스가 생성되면 아무 것도 수행하지 않는다. 이를 사용하려면
요청 사용자 또는 대상 파드의
<a href=/docs/tasks/configure-pod-container/configure-service-account/>서비스 어카운트</a>는
정책에서 <code>use</code> 동사를 허용하여 정책을 사용할 권한이 있어야 한다.</p>
<p>대부분의 쿠버네티스 파드는 사용자가 직접 만들지 않는다. 대신 일반적으로
컨트롤러 관리자를 통해
<a href=/ko/docs/concepts/workloads/controllers/deployment/>디플로이먼트</a>,
<a href=/ko/docs/concepts/workloads/controllers/replicaset/>레플리카셋</a>, 또는 기타
템플릿 컨트롤러의 일부로 간접적으로 생성된다. 컨트롤러에 정책에 대한 접근 권한을 부여하면
해당 컨트롤러에 의해 생성된 <em>모든</em> 파드에 대한 접근 권한이 부여되므로 정책을 승인하는
기본 방법은 파드의 서비스 어카운트에 대한 접근 권한을
부여하는 것이다(<a href=#%EB%8B%A4%EB%A5%B8-%ED%8C%8C%EB%93%9C%EB%A5%BC-%EC%8B%A4%ED%96%89>예</a> 참고).</p>
<h3 id=rbac을-통한-방법>RBAC을 통한 방법</h3>
<p><a href=/docs/reference/access-authn-authz/rbac/>RBAC</a>은 표준 쿠버네티스 권한 부여 모드이며,
정책 사용 권한을 부여하는 데 쉽게 사용할 수 있다.</p>
<p>먼저, <code>Role</code> 또는 <code>ClusterRole</code>은 원하는 정책을 <code>use</code> 하려면 접근 권한을 부여해야 한다.
접근 권한을 부여하는 규칙은 다음과 같다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>&lt;role name&gt;<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#39;policy&#39;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#39;podsecuritypolicies&#39;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>     </span>[<span style=color:#b44>&#39;use&#39;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resourceNames</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- &lt;list of policies to authorize&gt;<span style=color:#bbb>
</span></code></pre></div><p>그런 다음 <code>(Cluster)Role</code>이 승인된 사용자에게 바인딩된다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRoleBinding<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>&lt;binding name&gt;<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>roleRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>&lt;role name&gt;<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>subjects</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># 네임스페이스의 모든 서비스 어카운트 승인(권장):</span><span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Group<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>system:serviceaccounts:&lt;authorized namespace&gt;<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># 특정 서비스 어카운트 승인(권장하지 않음):</span><span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ServiceAccount<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>&lt;authorized service account name&gt;<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>&lt;authorized pod namespace&gt;<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># 특정 사용자 승인(권장하지 않음):</span><span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>User<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>&lt;authorized user name&gt;<span style=color:#bbb>
</span></code></pre></div><p><code>RoleBinding</code>(<code>ClusterRoleBinding</code> 아님)을 사용하는 경우, 바인딩과 동일한 네임스페이스에서
실행되는 파드에 대해서만 사용 권한을 부여한다. 네임스페이스에서 실행되는 모든 파드에 접근 권한을
부여하기 위해 시스템 그룹과 쌍을 이룰 수 있다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#080;font-style:italic># 네임스페이스의 모든 서비스 어카운트 승인:</span><span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Group<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>system:serviceaccounts<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># 또는 동일하게, 네임스페이스의 모든 승인된 사용자에게 사용 권한 부여</span><span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Group<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>system:authenticated<span style=color:#bbb>
</span></code></pre></div><p>RBAC 바인딩에 대한 자세한 예는,
<a href=/docs/reference/access-authn-authz/rbac#role-binding-examples>역할 바인딩 예제</a>를 참고한다.
파드시큐리티폴리시 인증에 대한 전체 예제는
<a href=#%EC%98%88%EC%A0%9C>아래</a>를 참고한다.</p>
<h3 id=추천-예제>추천 예제</h3>
<p>파드시큐리티폴리시는 새롭고 간결해진 <code>PodSecurity</code> <a class=glossary-tooltip title="쿠버네티스 API 서버에서 요청을 처리하여 오브젝트가 지속되기 전에 그 요청을 가로채는 코드 조각." data-toggle=tooltip data-placement=top href=/docs/reference/access-authn-authz/admission-controllers/ target=_blank aria-label="어드미션 컨트롤러">어드미션 컨트롤러</a>로 대체되고 있다.
이 변경에 대한 상세사항은
<a href=/blog/2021/04/06/podsecuritypolicy-deprecation-past-present-and-future/>파드시큐리티폴리시 사용 중단: 과거, 현재, 그리고 미래</a>를 참조한다.
다음 가이드라인을 참조하여 파드시큐리티폴리시를 새로운 어드미션 컨트롤러로 쉽게 전환할 수 있다.</p>
<ol>
<li>
<p>파드시큐리티폴리시를 <a href=/docs/concepts/security/pod-security-standards/>파드 보안 표준</a>에 의해 정의된 폴리시로 한정한다.</p>
<ul>
<li>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/policy/privileged-psp.yaml download=policy/privileged-psp.yaml>Privileged</a>
</li>
<li>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/policy/baseline-psp.yaml download=policy/baseline-psp.yaml>Baseline</a>
</li>
<li>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/policy/restricted-psp.yaml download=policy/restricted-psp.yaml>Restricted</a>
</li>
</ul>
</li>
<li>
<p><code>system:serviceaccounts:&lt;namespace></code> (여기서 <code>&lt;namespace></code>는 타겟 네임스페이스) 그룹을 사용하여
파드시큐리티폴리시를 전체 네임스페이스에만 바인드한다. 예시는 다음과 같다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># 이 클러스터롤바인딩(ClusterRoleBinding)을 통해 &#34;development&#34; 네임스페이스의 모든 파드가 기준 파드시큐리티폴리시(PSP)를 사용할 수 있다.</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRoleBinding<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>psp-baseline-namespaces<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>roleRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>psp-baseline<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>subjects</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Group<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>system:serviceaccounts:development<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Group<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>system:serviceaccounts:canary<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span></code></pre></div></li>
</ol>
<h3 id=문제-해결>문제 해결</h3>
<ul>
<li><a href=/docs/reference/command-line-tools-reference/kube-controller-manager/>컨트롤러 관리자</a>는
보안 API 포트에 대해 실행되어야 하며 수퍼유저 권한이 없어야 한다.
API 서버 접근 제어에 대한 자세한 내용은
<a href=/ko/docs/concepts/security/controlling-access>쿠버네티스 API에 대한 접근 제어</a>를 참고하길 바란다.
컨트롤러 관리자가 신뢰할 수 있는 API 포트(<code>localhost</code> 리스너라고도 함)를
통해 연결된 경우, 요청이 인증 및 권한 부여 모듈을 우회하고,
모든 파드시큐리티폴리시 오브젝트가 허용되며 사용자는 특권을 가진 컨테이너를
만들 수 있는 권한을 부여할 수 있다.</li>
</ul>
<p>컨트롤러 관리자 권한 구성에 대한 자세한 내용은
<a href=/docs/reference/access-authn-authz/rbac/#controller-roles>컨트롤러 역할</a>을 참고하기 바란다.</p>
<h2 id=정책-순서>정책 순서</h2>
<p>파드 생성 및 업데이트를 제한할 뿐만 아니라 파드 시큐리티 폴리시를 사용하여
제어하는 많은 필드에 기본값을 제공할 수도 있다. 여러 정책을
사용할 수 있는 경우 파드 시큐리티 폴리시 컨트롤러는
다음 기준에 따라 정책을 선택한다.</p>
<ol>
<li>기본 설정을 변경하거나 파드를 변경하지 않고 파드를 있는 그대로 허용하는 파드시큐리티폴리시가
선호된다. 이러한 비-변이(non-mutating) 파드시큐리티폴리시의
순서는 중요하지 않다.</li>
<li>파드를 기본값으로 설정하거나 변경해야 하는 경우, 파드를 허용할 첫 번째 파드시큐리티폴리시
(이름순)가 선택된다.</li>
</ol>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> 업데이트 작업 중(파드 스펙에 대한 변경이 허용되지 않는 동안) 비-변이 파드시큐리티폴리시만
파드의 유효성을 검사하는 데 사용된다.
</div>
<h2 id=예제>예제</h2>
<p><em>이 예에서는 파드시큐리티폴리시 어드미션 컨트롤러가 활성화된 클러스터가 실행 중이고
클러스터 관리자 권한이 있다고 가정한다.</em></p>
<h3 id=설정>설정</h3>
<p>이 예제와 같이 네임스페이스와 서비스 어카운트를 설정한다.
이 서비스 어카운트를 사용하여 관리자가 아닌 사용자를 조정한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create namespace psp-example
kubectl create serviceaccount -n psp-example fake-user
kubectl create rolebinding -n psp-example fake-editor --clusterrole<span style=color:#666>=</span>edit --serviceaccount<span style=color:#666>=</span>psp-example:fake-user
</code></pre></div><p>어떤 사용자로 활동하고 있는지 명확하게 하고 입력 내용을 저장하려면 2개의 별칭(alias)을
만든다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#a2f>alias</span> kubectl-admin<span style=color:#666>=</span><span style=color:#b44>&#39;kubectl -n psp-example&#39;</span>
<span style=color:#a2f>alias</span> kubectl-user<span style=color:#666>=</span><span style=color:#b44>&#39;kubectl --as=system:serviceaccount:psp-example:fake-user -n psp-example&#39;</span>
</code></pre></div><h3 id=정책과-파드-생성>정책과 파드 생성</h3>
<p>파일에서 예제 파드시큐리티폴리시 오브젝트를 정의한다. 이는 특권있는 파드를
만들지 못하게 하는 정책이다.
파드시큐리티폴리시 오브젝트의 이름은 유효한
<a href=/ko/docs/concepts/overview/working-with-objects/names#dns-%EC%84%9C%EB%B8%8C%EB%8F%84%EB%A9%94%EC%9D%B8-%EC%9D%B4%EB%A6%84>DNS 서브도메인 이름</a>이어야 한다.</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/ko/examples/policy/example-psp.yaml download=policy/example-psp.yaml><code>policy/example-psp.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('policy-example-psp-yaml')" title="Copy policy/example-psp.yaml to clipboard">
</img>
</div>
<div class=includecode id=policy-example-psp-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>policy/v1beta1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PodSecurityPolicy<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>example<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>privileged</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>false</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 특권을 가진 파드는 허용금지!</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 나머지는 일부 필수 필드를 채운다.</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>seLinux</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>rule</span>:<span style=color:#bbb> </span>RunAsAny<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>supplementalGroups</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>rule</span>:<span style=color:#bbb> </span>RunAsAny<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>runAsUser</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>rule</span>:<span style=color:#bbb> </span>RunAsAny<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>fsGroup</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>rule</span>:<span style=color:#bbb> </span>RunAsAny<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:#b44>&#39;*&#39;</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>그리고 kubectl로 생성한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl-admin create -f example-psp.yaml
</code></pre></div><p>이제 권한이 없는 사용자로서 간단한 파드를 생성해보자.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl-user create -f- <span style=color:#b44>&lt;&lt;EOF
</span><span style=color:#b44>apiVersion: v1
</span><span style=color:#b44>kind: Pod
</span><span style=color:#b44>metadata:
</span><span style=color:#b44>  name: pause
</span><span style=color:#b44>spec:
</span><span style=color:#b44>  containers:
</span><span style=color:#b44>    - name: pause
</span><span style=color:#b44>      image: k8s.gcr.io/pause
</span><span style=color:#b44>EOF</span>
</code></pre></div><p>이것의 출력은 다음과 같을 것이다.</p>
<pre><code>Error from server (Forbidden): error when creating &quot;STDIN&quot;: pods &quot;pause&quot; is forbidden: unable to validate against any pod security policy: []
</code></pre><p><strong>무슨 일이 일어났나?</strong> 파드시큐리티폴리시가 생성되었지만, 파드의 서비스 어카운트나 <code>fake-user</code>는
새 정책을 사용할 권한이 없다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl-user auth can-i use podsecuritypolicy/example
no
</code></pre></div><p>예제 정책에서 <code>fake-user</code>에게 <code>use</code> 동사를 부여하는 rolebinding을
생성한다.</p>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> 이 방법은 권장하지 않는다! 선호하는 방법은 <a href=#%EB%8B%A4%EB%A5%B8-%ED%8C%8C%EB%93%9C%EB%A5%BC-%EC%8B%A4%ED%96%89>다음 절</a>을
참고하길 바란다.
</div>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl-admin create role psp:unprivileged <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>    --verb<span style=color:#666>=</span>use <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>    --resource<span style=color:#666>=</span>podsecuritypolicy <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>    --resource-name<span style=color:#666>=</span>example
role <span style=color:#b44>&#34;psp:unprivileged&#34;</span> created

kubectl-admin create rolebinding fake-user:psp:unprivileged <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>    --role<span style=color:#666>=</span>psp:unprivileged <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>    --serviceaccount<span style=color:#666>=</span>psp-example:fake-user
rolebinding <span style=color:#b44>&#34;fake-user:psp:unprivileged&#34;</span> created

kubectl-user auth can-i use podsecuritypolicy/example
yes
</code></pre></div><p>이제 파드 생성을 다시 시도하자.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl-user create -f- <span style=color:#b44>&lt;&lt;EOF
</span><span style=color:#b44>apiVersion: v1
</span><span style=color:#b44>kind: Pod
</span><span style=color:#b44>metadata:
</span><span style=color:#b44>  name: pause
</span><span style=color:#b44>spec:
</span><span style=color:#b44>  containers:
</span><span style=color:#b44>    - name: pause
</span><span style=color:#b44>      image: k8s.gcr.io/pause
</span><span style=color:#b44>EOF</span>
</code></pre></div><p>이것의 출력은 다음과 같을 것이다.</p>
<pre><code>pod &quot;pause&quot; created
</code></pre><p>예상대로 작동한다! 그러나 특권있는 파드를 만들려는 시도는 여전히
거부되어야 한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl-user create -f- <span style=color:#b44>&lt;&lt;EOF
</span><span style=color:#b44>apiVersion: v1
</span><span style=color:#b44>kind: Pod
</span><span style=color:#b44>metadata:
</span><span style=color:#b44>  name: privileged
</span><span style=color:#b44>spec:
</span><span style=color:#b44>  containers:
</span><span style=color:#b44>    - name: pause
</span><span style=color:#b44>      image: k8s.gcr.io/pause
</span><span style=color:#b44>      securityContext:
</span><span style=color:#b44>        privileged: true
</span><span style=color:#b44>EOF</span>
</code></pre></div><p>이것의 출력은 다음과 같을 것이다.</p>
<pre><code>Error from server (Forbidden): error when creating &quot;STDIN&quot;: pods &quot;privileged&quot; is forbidden: unable to validate against any pod security policy: [spec.containers[0].securityContext.privileged: Invalid value: true: Privileged containers are not allowed]
</code></pre><p>계속 진행하기 전에 파드를 삭제하자.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl-user delete pod pause
</code></pre></div><h3 id=다른-파드를-실행>다른 파드를 실행</h3>
<p>약간 다르게 다시 시도해보자.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl-user create deployment pause --image<span style=color:#666>=</span>k8s.gcr.io/pause
deployment <span style=color:#b44>&#34;pause&#34;</span> created

kubectl-user get pods
No resources found.

kubectl-user get events | head -n <span style=color:#666>2</span>
LASTSEEN   FIRSTSEEN   COUNT     NAME              KIND         SUBOBJECT                TYPE      REASON                  SOURCE                                  MESSAGE
1m         2m          <span style=color:#666>15</span>        pause-7774d79b5   ReplicaSet                            Warning   FailedCreate            replicaset-controller                   Error creating: pods <span style=color:#b44>&#34;pause-7774d79b5-&#34;</span> is forbidden: no providers available to validate pod request
</code></pre></div><p><strong>무슨 일이 일어났나?</strong> 우리는 이미 <code>fake-user</code>에 대해 <code>psp:unprivileged</code> 역할을 바인딩했는데,
<code>Error creating: pods "pause-7774d79b5-" is forbidden: no providers available to validate pod request</code> 오류가
발생하는 이유는 무엇인가? 그 답은 소스인 <code>replicaset-controller</code>에 있다. Fake-user가
디플로이먼트를 성공적으로 생성했지만(레플리카셋을 성공적으로 생성했음), 레플리카셋이
파드를 생성했을 때 podsecuritypolicy 예제를
사용할 권한이 없었다.</p>
<p>이 문제를 해결하려면 <code>psp:unprivileged</code> 역할을 파드의 서비스 어카운트에 대신
바인딩한다. 이 경우(지정하지 않았으므로) 서비스 어카운트는
<code>default</code>이다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl-admin create rolebinding default:psp:unprivileged <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>    --role<span style=color:#666>=</span>psp:unprivileged <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>    --serviceaccount<span style=color:#666>=</span>psp-example:default
rolebinding <span style=color:#b44>&#34;default:psp:unprivileged&#34;</span> created
</code></pre></div><p>이제 다시 한번 해본다면 replicaset-controller가
파드를 성공적으로 생성할 것이다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl-user get pods --watch
NAME                    READY     STATUS    RESTARTS   AGE
pause-7774d79b5-qrgcb   0/1       Pending   <span style=color:#666>0</span>         1s
pause-7774d79b5-qrgcb   0/1       Pending   <span style=color:#666>0</span>         1s
pause-7774d79b5-qrgcb   0/1       ContainerCreating   <span style=color:#666>0</span>         1s
pause-7774d79b5-qrgcb   1/1       Running   <span style=color:#666>0</span>         2s
</code></pre></div><h3 id=정리>정리</h3>
<p>네임스페이스를 삭제하여 대부분의 예제 리소스를 정리한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl-admin delete ns psp-example
namespace <span style=color:#b44>&#34;psp-example&#34;</span> deleted
</code></pre></div><p><code>PodSecurityPolicy</code> 리소스는 네임스페이스에 포함되지 않으므로 별도로
정리해야 한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl-admin delete psp example
podsecuritypolicy <span style=color:#b44>&#34;example&#34;</span> deleted
</code></pre></div><h3 id=정책-예제>정책 예제</h3>
<p>다음은 파드 시큐리티 폴리시 어드미션 컨트롤러를 사용하지 않는 것과 동일하게 만들 수 있는
최소한의 제한 정책이다.</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/ko/examples/policy/privileged-psp.yaml download=policy/privileged-psp.yaml><code>policy/privileged-psp.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('policy-privileged-psp-yaml')" title="Copy policy/privileged-psp.yaml to clipboard">
</img>
</div>
<div class=includecode id=policy-privileged-psp-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>policy/v1beta1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PodSecurityPolicy<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>privileged<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>seccomp.security.alpha.kubernetes.io/allowedProfileNames</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;*&#39;</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>privileged</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>allowPrivilegeEscalation</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>allowedCapabilities</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:#b44>&#39;*&#39;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:#b44>&#39;*&#39;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>hostNetwork</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>hostPorts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>min</span>:<span style=color:#bbb> </span><span style=color:#666>0</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>max</span>:<span style=color:#bbb> </span><span style=color:#666>65535</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>hostIPC</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>hostPID</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>runAsUser</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>rule</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;RunAsAny&#39;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>seLinux</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>rule</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;RunAsAny&#39;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>supplementalGroups</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>rule</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;RunAsAny&#39;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>fsGroup</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>rule</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;RunAsAny&#39;</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>다음은 권한이 없는 사용자로서의 실행을 필요로 하고, 루트로의 에스컬레이션(escalation) 가능성을 차단하고,
여러 보안 메커니즘을 사용을 필요로 하는 제한적
정책의 예제이다.</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/ko/examples/policy/restricted-psp.yaml download=policy/restricted-psp.yaml><code>policy/restricted-psp.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('policy-restricted-psp-yaml')" title="Copy policy/restricted-psp.yaml to clipboard">
</img>
</div>
<div class=includecode id=policy-restricted-psp-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>policy/v1beta1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PodSecurityPolicy<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>restricted<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>seccomp.security.alpha.kubernetes.io/allowedProfileNames</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;docker/default,runtime/default&#39;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apparmor.security.beta.kubernetes.io/allowedProfileNames</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;runtime/default&#39;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apparmor.security.beta.kubernetes.io/defaultProfileName</span>:<span style=color:#bbb>  </span><span style=color:#b44>&#39;runtime/default&#39;</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>privileged</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>false</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 루트로의 에스컬레이션을 방지하는 데 필요하다.</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>allowPrivilegeEscalation</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>false</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>requiredDropCapabilities</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- ALL<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 기본 볼륨 유형을 허용한다.</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:#b44>&#39;configMap&#39;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:#b44>&#39;emptyDir&#39;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:#b44>&#39;projected&#39;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:#b44>&#39;secret&#39;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:#b44>&#39;downwardAPI&#39;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 클러스터 관리자에 의해 구성된 휘발성 CSI 드라이버와 퍼시스턴트볼륨(PersistentVolume)의 사용은 안전하다고 가정한다.</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:#b44>&#39;csi&#39;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:#b44>&#39;persistentVolumeClaim&#39;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:#b44>&#39;ephemeral&#39;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>hostNetwork</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>false</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>hostIPC</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>false</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>hostPID</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>false</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>runAsUser</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 루트 권한없이 컨테이너를 실행해야 한다.</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>rule</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;MustRunAsNonRoot&#39;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>seLinux</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 이 정책은 노드가 SELinux가 아닌 AppArmor를 사용한다고 가정한다.</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>rule</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;RunAsAny&#39;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>supplementalGroups</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>rule</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;MustRunAs&#39;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>ranges</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 루트 그룹을 추가하지 않는다.</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>min</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>max</span>:<span style=color:#bbb> </span><span style=color:#666>65535</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>fsGroup</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>rule</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;MustRunAs&#39;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>ranges</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 루트 그룹을 추가하지 않는다.</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>min</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>max</span>:<span style=color:#bbb> </span><span style=color:#666>65535</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>readOnlyRootFilesystem</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>false</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>더 많은 예제는 <a href=/docs/concepts/security/pod-security-standards/#policy-instantiation>파드 보안 표준</a>을 본다.</p>
<h2 id=정책-레퍼런스>정책 레퍼런스</h2>
<h3 id=특권을-가진>특권을 가진</h3>
<p><strong>Privileged</strong> - 파드의 컨테이너가 특권 모드를 사용할 수 있는지 여부를 결정한다.
기본적으로 컨테이너는 호스트의 모든 장치에 접근할 수 없지만
"특권을 가진" 컨테이너는 호스트의 모든 장치에 접근할 수 있다. 이것은
컨테이너가 호스트에서 실행되는 프로세스와 거의 동일한 접근을 허용한다.
이것은 네트워크 스택 조작 및 장치 접근과 같은
리눅스 기능을 사용하려는 컨테이너에 유용하다.</p>
<h3 id=호스트-네임스페이스>호스트 네임스페이스</h3>
<p><strong>HostPID</strong> - 파드 컨테이너가 호스트 프로세스 ID 네임스페이스를 공유할 수 있는지 여부를
제어한다. ptrace와 함께 사용하면 컨테이너 외부로 권한을 에스컬레이션하는 데 사용할 수
있다(ptrace는 기본적으로 금지되어 있음).</p>
<p><strong>HostIPC</strong> - 파드 컨테이너가 호스트 IPC 네임스페이스를 공유할 수 있는지 여부를
제어한다.</p>
<p><strong>HostNetwork</strong> - 파드가 노드 네트워크 네임스페이스를 사용할 수 있는지 여부를 제어한다.
이렇게 하면 파드에 루프백 장치에 접근 권한을 주고, 서비스는 로컬호스트(localhost)를 리스닝할 수 있으며,
동일한 노드에 있는 다른 파드의 네트워크 활동을 스누핑(snoop)하는 데
사용할 수 있다.</p>
<p><strong>HostPorts</strong> - 호스트 네트워크 네임스페이스에 허용되는 포트 범위의 목록을
제공한다. <code>min</code>과 <code>max</code>를 포함하여 <code>HostPortRange</code>의 목록으로 정의된다.
기본값은 허용하는 호스트 포트 없음(no allowed host ports)이다.</p>
<h3 id=볼륨-및-파일시스템>볼륨 및 파일시스템</h3>
<p><strong>Volumes</strong> - 허용되는 볼륨 유형의 목록을 제공한다. 허용 가능한 값은
볼륨을 생성할 때 정의된 볼륨 소스에 따른다. 볼륨 유형의 전체 목록은
<a href=/ko/docs/concepts/storage/volumes/#%EB%B3%BC%EB%A5%A8-%EC%9C%A0%ED%98%95%EB%93%A4>볼륨 유형들</a>에서 참고한다.
또한 <code>*</code>를 사용하여 모든 볼륨 유형을
허용할 수 있다.</p>
<p>새 PSP에 허용되는 볼륨의 <strong>최소 권장 셋</strong> 은 다음과 같다.</p>
<ul>
<li>컨피그맵</li>
<li>다운워드API</li>
<li>emptyDir</li>
<li>퍼시스턴트볼륨클레임</li>
<li>시크릿</li>
<li>프로젝티드(projected)</li>
</ul>
<div class="alert alert-danger warning callout" role=alert>
<strong>경고:</strong> 파드시큐리티폴리시는 <code>PersistentVolumeClaim</code>이 참조할 수 있는 <code>PersistentVolume</code>
오브젝트의 유형을 제한하지 않으며 hostPath 유형
<code>PersistentVolumes</code>은 읽기-전용 접근 모드를 지원하지 않는다. 신뢰할 수 있는 사용자만
<code>PersistentVolume</code> 오브젝트를 생성할 수 있는 권한을 부여 받아야 한다.
</div>
<p><strong>FSGroup</strong> - 일부 볼륨에 적용되는 보충 그룹(supplemental group)을 제어한다.</p>
<ul>
<li><em>MustRunAs</em> - 하나 이상의 <code>range</code>를 지정해야 한다. 첫 번째 범위의 최솟값을
기본값으로 사용한다. 모든 범위에 대해 검증한다.</li>
<li><em>MayRunAs</em> - 하나 이상의 <code>range</code>를 지정해야 한다. 기본값을 제공하지 않고
<code>FSGroups</code>을 설정하지 않은 상태로 둘 수 있다. <code>FSGroups</code>이 설정된 경우 모든 범위에 대해
유효성을 검사한다.</li>
<li><em>RunAsAny</em> - 기본값은 제공되지 않는다. 어떠한 <code>fsGroup</code> ID의 지정도 허용한다.</li>
</ul>
<p><strong>AllowedHostPaths</strong> - hostPath 볼륨에서 사용할 수 있는 호스트 경로의 목록을
지정한다. 빈 목록은 사용되는 호스트 경로에 제한이 없음을 의미한다.
이는 단일 <code>pathPrefix</code> 필드가 있는 오브젝트 목록으로 정의되며, hostPath 볼륨은
허용된 접두사로 시작하는 경로를 마운트할 수 있으며 <code>readOnly</code> 필드는
읽기-전용으로 마운트 되어야 함을 나타낸다.
예를 들면 다음과 같습니다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#bbb> </span><span style=color:green;font-weight:700>allowedHostPaths</span>:<span style=color:#bbb>
</span><span style=color:#bbb>   </span><span style=color:#080;font-style:italic># 이 정책은 &#34;/foo&#34;, &#34;/foo/&#34;, &#34;/foo/bar&#34; 등을 허용하지만,</span><span style=color:#bbb>
</span><span style=color:#bbb>   </span><span style=color:#080;font-style:italic># &#34;/fool&#34;, &#34;/etc/foo&#34; 등은 허용하지 않는다.</span><span style=color:#bbb>
</span><span style=color:#bbb>   </span><span style=color:#080;font-style:italic># &#34;/foo/../&#34; 는 절대 유효하지 않다.</span><span style=color:#bbb>
</span><span style=color:#bbb>   </span>- <span style=color:green;font-weight:700>pathPrefix</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/foo&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb> </span><span style=color:#080;font-style:italic># 읽기 전용 마운트만 허용</span><span style=color:#bbb>
</span></code></pre></div><div class="alert alert-danger warning callout" role=alert>
<strong>경고:</strong> <p>호스트 파일시스템에 제한없는 접근을 부여하며, 컨테이너가 특권을 에스컬레이션
(다른 컨테이너들에 있는 데이터를 읽고, 시스템 서비스의 자격 증명을 어뷰징(abusing)하는 등)할
수 있도록 만드는 다양한 방법이 있다. 예를 들면, Kubelet과 같다.</p>
<p>쓰기 가능한 hostPath 디렉터리 볼륨을 사용하면, 컨테이너가 <code>pathPrefix</code> 외부의
호스트 파일시스템에 대한 통행을 허용하는 방식으로 컨테이너의 파일시스템 쓰기(write)를 허용한다.
쿠버네티스 1.11 이상 버전에서 사용 가능한 <code>readOnly: true</code>는 지정된 <code>pathPrefix</code>에 대한
접근을 효과적으로 제한하기 위해 <strong>모든</strong> <code>allowedHostPaths</code>에서 사용해야 한다.</p>
</div>
<p><strong>ReadOnlyRootFilesystem</strong> - 컨테이너는 읽기-전용 루트 파일시스템(즉, 쓰기 가능한 레이어 없음)으로
실행해야 한다.</p>
<h3 id=flexvolume-드라이버>FlexVolume 드라이버</h3>
<p>flexvolume에서 사용할 수 있는 FlexVolume 드라이버의 목록을 지정한다.
빈 목록 또는 nil은 드라이버에 제한이 없음을 의미한다.
<a href=#%EB%B3%BC%EB%A5%A8-%EB%B0%8F-%ED%8C%8C%EC%9D%BC%EC%8B%9C%EC%8A%A4%ED%85%9C><code>volumes</code></a> 필드에 <code>flexVolume</code> 볼륨 유형이 포함되어
있는지 확인한다. 그렇지 않으면 FlexVolume 드라이버가 허용되지 않는다.</p>
<p>예를 들면 다음과 같다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>policy/v1beta1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PodSecurityPolicy<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>allow-flex-volumes<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># ... 다른 스펙 필드</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- flexVolume<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>allowedFlexVolumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>driver</span>:<span style=color:#bbb> </span>example/lvm<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>driver</span>:<span style=color:#bbb> </span>example/cifs<span style=color:#bbb>
</span></code></pre></div><h3 id=사용자-및-그룹>사용자 및 그룹</h3>
<p><strong>RunAsUser</strong> - 컨테이너를 실행할 사용자 ID를 제어힌다.</p>
<ul>
<li><em>MustRunAs</em> - 하나 이상의 <code>range</code>를 지정해야 한다. 첫 번째 범위의 최솟값을
기본값으로 사용한다. 모든 범위에 대해 검증한다.</li>
<li><em>MustRunAsNonRoot</em> - 파드가 0이 아닌 <code>runAsUser</code>로 제출되거나
이미지에 <code>USER</code> 지시문이 정의되어 있어야 한다(숫자 UID 사용). <code>runAsNonRoot</code> 또는
<code>runAsUser</code> 설정을 지정하지 않은 파드는 <code>runAsNonRoot=true</code>를 설정하도록
변경되므로 컨테이너에 0이 아닌 숫자가 정의된 <code>USER</code> 지시문이
필요하다. 기본값은 제공되지 않는다.
이 전략에서는 <code>allowPrivilegeEscalation=false</code>를 설정하는 것이 좋다.</li>
<li><em>RunAsAny</em> - 기본값은 제공되지 않는다. 어떠한 <code>runAsUser</code>의 지정도 허용한다.</li>
</ul>
<p><strong>RunAsGroup</strong> - 컨테이너가 실행될 기본 그룹 ID를 제어한다.</p>
<ul>
<li><em>MustRunAs</em> - 하나 이상의 <code>range</code>를 지정해야 한다. 첫 번째 범위의 최솟값을
기본값으로 사용한다. 모든 범위에 대해 검증한다.</li>
<li><em>MayRunAs</em> - <code>RunAsGroup</code>을 지정할 필요가 없다. 그러나 <code>RunAsGroup</code>을 지정하면
정의된 범위에 속해야 한다.</li>
<li><em>RunAsAny</em> - 기본값은 제공되지 않는다. 어떠한 <code>runAsGroup</code>의 지정도 허용한다.</li>
</ul>
<p><strong>SupplementalGroups</strong> - 컨테이너가 추가할 그룹 ID를 제어한다.</p>
<ul>
<li><em>MustRunAs</em> - 하나 이상의 <code>range</code>를 지정해야 한다. 첫 번째 범위의 최솟값을
기본값으로 사용한다. 모든 범위에 대해 검증한다.</li>
<li><em>MayRunAs</em> - 하나 이상의 <code>range</code>를 지정해야 한다. <code>supplementalGroups</code>에
기본값을 제공하지 않고 설정하지 않은 상태로 둘 수 있다.
<code>supplementalGroups</code>가 설정된 경우 모든 범위에 대해 유효성을 검증한다.</li>
<li><em>RunAsAny</em> - 기본값은 제공되지 않는다. 어떠한 <code>supplementalGroups</code>의 지정도
허용한다.</li>
</ul>
<h3 id=권한-에스컬레이션>권한 에스컬레이션</h3>
<p>이 옵션은 <code>allowPrivilegeEscalation</code> 컨테이너 옵션을 제어한다. 이 bool은
컨테이너 프로세스에서
<a href=https://www.kernel.org/doc/Documentation/prctl/no_new_privs.txt><code>no_new_privs</code></a>
플래그가 설정되는지 여부를 직접 제어한다. 이 플래그는 <code>setuid</code> 바이너리가
유효 사용자 ID를 변경하지 못하게 하고 파일에 추가 기능을 활성화하지 못하게
한다(예: <code>ping</code> 도구 사용을 못하게 함). <code>MustRunAsNonRoot</code>를 효과적으로
강제하려면 이 동작이 필요하다.</p>
<p><strong>AllowPrivilegeEscalation</strong> - 사용자가 컨테이너의 보안 컨텍스트를
<code>allowPrivilegeEscalation=true</code>로 설정할 수 있는지 여부를 게이트한다.
이 기본값은 setuid 바이너리를 중단하지 않도록 허용한다. 이를 <code>false</code>로 설정하면
컨테이너의 하위 프로세스가 상위 프로세스보다 더 많은 권한을 얻을 수 없다.</p>
<p><strong>DefaultAllowPrivilegeEscalation</strong> - <code>allowPrivilegeEscalation</code> 옵션의
기본값을 설정한다. 이것이 없는 기본 동작은 setuid 바이너리를 중단하지 않도록
권한 에스컬레이션을 허용하는 것이다. 해당 동작이 필요하지 않은 경우 이 필드를 사용하여
기본적으로 허용하지 않도록 설정할 수 있지만 파드는 여전히 <code>allowPrivilegeEscalation</code>을
명시적으로 요청할 수 있다.</p>
<h3 id=기능>기능</h3>
<p>리눅스 기능은 전통적으로 슈퍼유저와 관련된 권한을 보다 세밀하게 분류한다.
이러한 기능 중 일부는 권한 에스컬레이션 또는 컨테이너 분류에 사용될 수 있으며
파드시큐리티폴리시에 의해 제한될 수 있다. 리눅스 기능에 대한 자세한 내용은
<a href=https://man7.org/linux/man-pages/man7/capabilities.7.html>기능(7)</a>을
참고하길 바란다.</p>
<p>다음 필드는 대문자로 표기된 기능 이름 목록을
<code>CAP_</code> 접두사 없이 가져온다.</p>
<p><strong>AllowedCapabilities</strong> - 컨테이너에 추가될 수 있는 기능의 목록을
제공한다. 기본적인 기능 셋은 암시적으로 허용된다. 비어있는 셋은
기본 셋을 넘어서는 추가 기능이 추가되지 않는 것을
의미한다. <code>*</code>는 모든 기능을 허용하는 데 사용할 수 있다.</p>
<p><strong>RequiredDropCapabilities</strong> - 컨테이너에서 삭제해야 하는 기능이다.
이러한 기능은 기본 셋에서 제거되며 추가해서는 안된다.
<code>RequiredDropCapabilities</code>에 나열된 기능은 <code>AllowedCapabilities</code> 또는
<code>DefaultAddCapabilities</code>에 포함되지 않아야 한다.</p>
<p><strong>DefaultAddCapabilities</strong> - 런타임 기본값 외에 기본적으로 컨테이너에 추가되는 기능이다.
도커 런타임을 사용할 때 기본 기능 목록은
<a href=https://docs.docker.com/engine/reference/run/#runtime-privilege-and-linux-capabilities>도커 문서</a>를
참고하길 바란다.</p>
<h3 id=selinux>SELinux</h3>
<ul>
<li><em>MustRunAs</em> - <code>seLinuxOptions</code>을 구성해야 한다.
<code>seLinuxOptions</code>을 기본값으로 사용한다. <code>seLinuxOptions</code>에 대해 유효성을 검사한다.</li>
<li><em>RunAsAny</em> - 기본값은 제공되지 않는다. 어떠한 <code>seLinuxOptions</code>의 지정도
허용한다.</li>
</ul>
<h3 id=allowedprocmounttypes>AllowedProcMountTypes</h3>
<p><code>allowedProcMountTypes</code>는 허용된 ProcMountTypes의 목록이다.
비어 있거나 nil은 <code>DefaultProcMountType</code>만 사용할 수 있음을 나타낸다.</p>
<p><code>DefaultProcMount</code>는 /proc의 읽기 전용 및 마스킹(masking)된 경로에 컨테이너 런타임
기본값을 사용한다. 대부분의 컨테이너 런타임은 특수 장치나 정보가 실수로 보안에
노출되지 않도록 /proc의 특정 경로를 마스킹한다. 이것은 문자열
<code>Default</code>로 표시된다.</p>
<p>유일하게 다른 ProcMountType은 <code>UnmaskedProcMount</code>로, 컨테이너 런타임의
기본 마스킹 동작을 무시하고 새로 작성된 /proc 컨테이너가 수정없이
그대로 유지되도록 한다. 이 문자열은
<code>Unmasked</code>로 표시된다.</p>
<h3 id=apparmor>AppArmor</h3>
<p>파드시큐리티폴리시의 어노테이션을 통해 제어된다. <a href=/ko/docs/tutorials/clusters/apparmor/#podsecuritypolicy-annotations>AppArmor
문서</a>를 참고하길 바란다.</p>
<h3 id=seccomp>Seccomp</h3>
<p>쿠버네티스 v1.19부터 파드나 컨테이너의 <code>securityContext</code> 에서
<code>seccompProfile</code> 필드를 사용하여 <a href=/docs/tutorials/clusters/seccomp>seccomp 프로파일 사용을
제어</a>할 수 있다. 이전 버전에서는, 파드에
어노테이션을 추가하여 seccomp를 제어했다. 두 버전에서 동일한 파드시큐리티폴리시를 사용하여
이러한 필드나 어노테이션이 적용되는 방식을 적용할 수 있다.</p>
<p><strong>seccomp.security.alpha.kubernetes.io/defaultProfileName</strong> - 컨테이너에
적용할 기본 seccomp 프로파일을 지정하는 어노테이션이다. 가능한 값은
다음과 같다.</p>
<ul>
<li><code>unconfined</code> - 대안이 제공되지 않으면 Seccomp가 컨테이너 프로세스에 적용되지
않는다(쿠버네티스의 기본값임).</li>
<li><code>runtime/default</code> - 기본 컨테이너 런타임 프로파일이 사용된다.</li>
<li><code>docker/default</code> - 도커 기본 seccomp 프로파일이 사용된다. 쿠버네티스 1.11 부터 사용 중단(deprecated)
되었다. 대신 <code>runtime/default</code> 사용을 권장한다.</li>
<li><code>localhost/&lt;path></code> - <code>&lt;seccomp_root>/&lt;path></code>에 있는 노드에서 파일을 프로파일로
지정한다. 여기서 <code>&lt;seccomp_root></code>는 Kubelet의 <code>--seccomp-profile-root</code> 플래그를
통해 정의된다. <code>--seccomp-profile-root</code> 플래그가
정의되어 있지 않으면, <code>&lt;root-dir></code> 이 <code>--root-dir</code> 플래그로
지정된 <code>&lt;root-dir>/seccomp</code> 기본 경로가 사용된다.</li>
</ul>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> <code>--seccomp-profile-root</code> 플래그는 쿠버네티스 v1.19부터 더 이상 사용되지
않는다. 사용자는 기본 경로를 사용하는 것이 좋다.
</div>
<p><strong>seccomp.security.alpha.kubernetes.io/allowedProfileNames</strong> - 파드 seccomp
어노테이션에 허용되는 값을 지정하는 어노테이션. 쉼표로 구분된
허용된 값의 목록으로 지정된다. 가능한 값은 위에 나열된 값과
모든 프로파일을 허용하는 <code>*</code> 이다.
이 주석이 없으면 기본값을 변경할 수 없다.</p>
<h3 id=sysctl>Sysctl</h3>
<p>기본적으로 모든 안전한 sysctls가 허용된다.</p>
<ul>
<li><code>forbiddenSysctls</code> - 특정 sysctls를 제외한다. 목록에서 안전한 것과 안전하지 않은 sysctls의 조합을 금지할 수 있다. 모든 sysctls 설정을 금지하려면 자체적으로 <code>*</code>를 사용한다.</li>
<li><code>allowedUnsafeSysctls</code> - <code>forbiddenSysctls</code>에 나열되지 않는 한 기본 목록에서 허용하지 않은 특정 sysctls를 허용한다.</li>
</ul>
<p><a href=/ko/docs/tasks/administer-cluster/sysctl-cluster/#%ED%8C%8C%EB%93%9C%EC%8B%9C%ED%81%90%EB%A6%AC%ED%8B%B0%ED%8F%B4%EB%A6%AC%EC%8B%9C-podsecuritypolicy>Sysctl 문서</a>를 참고하길 바란다.</p>
<h2 id=다음-내용>다음 내용</h2>
<ul>
<li>
<p><a href=/blog/2021/04/06/podsecuritypolicy-deprecation-past-present-and-future/>파드시큐리티폴리시 사용 중단: 과거, 현재, 그리고
미래</a>에서
파드시큐리티폴리시의 미래에 대해 알아본다.</p>
</li>
<li>
<p>폴리시 권장 사항에 대해서는 <a href=/docs/concepts/security/pod-security-standards/>파드 보안 표준</a>을 참조한다.</p>
</li>
<li>
<p>API 세부 정보는 <a href=/docs/reference/generated/kubernetes-api/v1.23/#podsecuritypolicy-v1beta1-policy>파드 시큐리티 폴리시 레퍼런스</a> 참조한다.</p>
</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-b528c4464c030f3f044124b38d778f04>10.4 - 노드 리소스 매니저</h1>
<p>쿠버네티스는 지연 시간에 민감하고 처리량이 많은 워크로드를 지원하기 위해 리소스 매니저 세트를 제공한다. 매니저는 CPU, 장치 및 메모리 (hugepages) 리소스와 같은 특정한 요구 사항으로 구성된 파드를 위해 노드의 리소스 할당을 조정하고 최적화하는 것을 목표로 한다.</p>
<p>주 매니저인 토폴로지 매니저는 <a href=/docs/tasks/administer-cluster/topology-manager/>정책</a>을 통해 전체 리소스 관리 프로세스를 조정하는 Kubelet 컴포넌트이다.</p>
<p>개별 매니저의 구성은 다음의 문서에 자세히 기술되어 있다.</p>
<ul>
<li><a href=/docs/tasks/administer-cluster/cpu-management-policies/>CPU 관리 정책</a></li>
<li><a href=/ko/docs/concepts/extend-kubernetes/compute-storage-net/device-plugins/#%ED%86%A0%ED%8F%B4%EB%A1%9C%EC%A7%80-%EA%B4%80%EB%A6%AC%EC%9E%90%EC%99%80-%EC%9E%A5%EC%B9%98-%ED%94%8C%EB%9F%AC%EA%B7%B8%EC%9D%B8-%ED%86%B5%ED%95%A9>장치 매니저</a></li>
<li><a href=/docs/tasks/administer-cluster/memory-manager/>메모리 관리 정책</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-285a3785fd3d20f437c28d87ca4dadca>11 - 클러스터 관리</h1>
<div class=lead>쿠버네티스 클러스터 생성 또는 관리에 관련된 로우-레벨(lower-level)의 세부 정보를 설명한다.</div>
<p>클러스터 관리 개요는 쿠버네티스 클러스터를 생성하거나 관리하는 모든 사람들을 위한 것이다.
핵심 쿠버네티스 <a href=/ko/docs/concepts/>개념</a>에 어느 정도 익숙하다고 가정한다.</p>
<h2 id=클러스터-계획>클러스터 계획</h2>
<p>쿠버네티스 클러스터를 계획, 설정 및 구성하는 방법에 대한 예는 <a href=/ko/docs/setup/>시작하기</a>에 있는 가이드를 참고한다. 이 문서에 나열된 솔루션을 <em>배포판</em> 이라고 한다.</p>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> 모든 배포판이 활발하게 유지되는 것은 아니다. 최신 버전의 쿠버네티스에서 테스트된 배포판을 선택한다.
</div>
<p>가이드를 선택하기 전에 고려해야 할 사항은 다음과 같다.</p>
<ul>
<li>컴퓨터에서 쿠버네티스를 한번 사용해보고 싶은가? 아니면, 고가용 멀티 노드 클러스터를 만들고 싶은가? 사용자의 필요에 따라 가장 적합한 배포판을 선택한다.</li>
<li><a href=https://cloud.google.com/kubernetes-engine/>구글 쿠버네티스 엔진(Google Kubernetes Engine)</a>과 같은 클라우드 제공자의 <strong>쿠버네티스 클러스터 호스팅</strong> 을 사용할 것인가? 아니면, <strong>자체 클러스터를 호스팅</strong> 할 것인가?</li>
<li>클러스터가 <strong>온-프레미스 환경</strong> 에 있나? 아니면, <strong>클라우드(IaaS)</strong> 에 있나? 쿠버네티스는 하이브리드 클러스터를 직접 지원하지는 않는다. 대신 여러 클러스터를 설정할 수 있다.</li>
<li><strong>온-프레미스 환경에 쿠버네티스</strong> 를 구성하는 경우, 어떤 <a href=/ko/docs/concepts/cluster-administration/networking/>네트워킹 모델</a>이 가장 적합한 지 고려한다.</li>
<li>쿠버네티스를 <strong>"베어 메탈" 하드웨어</strong> 에서 실행할 것인가? 아니면, <strong>가상 머신(VM)</strong> 에서 실행할 것인가?</li>
<li><strong>클러스터만 실행할 것인가?</strong> 아니면, <strong>쿠버네티스 프로젝트 코드를 적극적으로 개발</strong> 하는 것을 기대하는가? 만약
후자라면, 활발하게 개발이 진행되고 있는 배포판을 선택한다. 일부 배포판은 바이너리 릴리스만 사용하지만,
더 다양한 선택을 제공한다.</li>
<li>클러스터를 실행하는 데 필요한 <a href=/ko/docs/concepts/overview/components/>컴포넌트</a>에 익숙해지자.</li>
</ul>
<h2 id=클러스터-관리>클러스터 관리</h2>
<ul>
<li>
<p><a href=/ko/docs/concepts/architecture/nodes/>노드 관리</a> 방법을 배운다.</p>
</li>
<li>
<p>공유 클러스터에 대한 <a href=/ko/docs/concepts/policy/resource-quotas/>리소스 쿼터</a>를 설정하고 관리하는 방법을 배운다.</p>
</li>
</ul>
<h2 id=클러스터-보안>클러스터 보안</h2>
<ul>
<li>
<p><a href=/ko/docs/tasks/administer-cluster/certificates/>인증서 생성</a>은 다른 툴 체인을 사용하여 인증서를 생성하는 단계를 설명한다.</p>
</li>
<li>
<p><a href=/ko/docs/concepts/containers/container-environment/>쿠버네티스 컨테이너 환경</a>은 쿠버네티스 노드에서 Kubelet으로 관리하는 컨테이너에 대한 환경을 설명한다.</p>
</li>
<li>
<p><a href=/ko/docs/concepts/security/controlling-access>쿠버네티스 API에 대한 접근 제어</a>는 쿠버네티스가 자체 API에 대한 접근 제어를 구현하는 방법을 설명한다.</p>
</li>
<li>
<p><a href=/docs/reference/access-authn-authz/authentication/>인증</a>은 다양한 인증 옵션을 포함한 쿠버네티스에서의 인증에 대해 설명한다.</p>
</li>
<li>
<p><a href=/ko/docs/reference/access-authn-authz/authorization/>인가</a>는 인증과는 별개로, HTTP 호출 처리 방법을 제어한다.</p>
</li>
<li>
<p><a href=/docs/reference/access-authn-authz/admission-controllers/>어드미션 컨트롤러 사용하기</a>는 인증과 권한 부여 후 쿠버네티스 API 서버에 대한 요청을 가로채는 플러그인에 대해 설명한다.</p>
</li>
<li>
<p><a href=/ko/docs/tasks/administer-cluster/sysctl-cluster/>쿠버네티스 클러스터에서 Sysctls 사용하기</a>는 관리자가 <code>sysctl</code> 커맨드라인 도구를 사용하여 커널 파라미터를 설정하는 방법에 대해 설명한다.</p>
</li>
<li>
<p><a href=/docs/tasks/debug-application-cluster/audit/>감사(audit)</a>는 쿠버네티스의 감사 로그를 다루는 방법에 대해 설명한다.</p>
</li>
</ul>
<h3 id=kubelet-보안>kubelet 보안</h3>
<ul>
<li><a href=/ko/docs/concepts/architecture/control-plane-node-communication/>컨트롤 플레인-노드 통신</a></li>
<li><a href=/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/>TLS 부트스트래핑(bootstrapping)</a></li>
<li><a href=/ko/docs/reference/command-line-tools-reference/kubelet-authentication-authorization/>Kubelet 인증/인가</a></li>
</ul>
<h2 id=선택적-클러스터-서비스>선택적 클러스터 서비스</h2>
<ul>
<li>
<p><a href=/ko/docs/concepts/services-networking/dns-pod-service/>DNS 통합</a>은 DNS 이름을 쿠버네티스 서비스로 직접 확인하는 방법을 설명한다.</p>
</li>
<li>
<p><a href=/ko/docs/concepts/cluster-administration/logging/>클러스터 액티비티 로깅과 모니터링</a>은 쿠버네티스에서의 로깅이 어떻게 작동하는지와 구현 방법에 대해 설명한다.</p>
</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-2bf9a93ab5ba014fb6ff70b22c29d432>11.1 - 인증서</h1>
<p>클러스터를 위한 인증서를 생성하기 위해서는, <a href=/ko/docs/tasks/administer-cluster/certificates/>인증서</a>를 참고한다.</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-3aeeecf7cdb2a21eb4b31db7a71c81e2>11.2 - 리소스 관리</h1>
<p>애플리케이션을 배포하고 서비스를 통해 노출했다. 이제 무엇을 해야 할까? 쿠버네티스는 확장과 업데이트를 포함하여, 애플리케이션 배포를 관리하는 데 도움이 되는 여러 도구를 제공한다. 더 자세히 설명할 기능 중에는 <a href=/ko/docs/concepts/configuration/overview/>구성 파일</a>과 <a href=/ko/docs/concepts/overview/working-with-objects/labels/>레이블</a>이 있다.</p>
<h2 id=리소스-구성-구성하기>리소스 구성 구성하기</h2>
<p>많은 애플리케이션들은 디플로이먼트 및 서비스와 같은 여러 리소스를 필요로 한다. 여러 리소스의 관리는 동일한 파일에 그룹화하여 단순화할 수 있다(YAML에서 <code>---</code> 로 구분). 예를 들면 다음과 같다.</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/ko/examples/application/nginx-app.yaml download=application/nginx-app.yaml><code>application/nginx-app.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('application-nginx-app-yaml')" title="Copy application/nginx-app.yaml to clipboard">
</img>
</div>
<div class=includecode id=application-nginx-app-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-nginx-svc<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>LoadBalancer<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-nginx<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.14.2<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>단일 리소스와 동일한 방식으로 여러 리소스를 생성할 수 있다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/application/nginx-app.yaml
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>service/my-nginx-svc created
deployment.apps/my-nginx created
</code></pre></div><p>리소스는 파일에 표시된 순서대로 생성된다. 따라서, 스케줄러가 디플로이먼트와 같은 컨트롤러에서 생성한 서비스와 관련된 파드를 분산시킬 수 있으므로, 서비스를 먼저 지정하는 것이 가장 좋다.</p>
<p><code>kubectl apply</code> 는 여러 개의 <code>-f</code> 인수도 허용한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/application/nginx/nginx-svc.yaml -f https://k8s.io/examples/application/nginx/nginx-deployment.yaml
</code></pre></div><p>그리고 개별 파일 대신 또는 추가로 디렉터리를 지정할 수 있다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/application/nginx/
</code></pre></div><p><code>kubectl</code> 은 접미사가 <code>.yaml</code>, <code>.yml</code> 또는 <code>.json</code> 인 파일을 읽는다.</p>
<p>동일한 마이크로서비스 또는 애플리케이션 티어(tier)와 관련된 리소스를 동일한 파일에 배치하고, 애플리케이션과 연관된 모든 파일을 동일한 디렉터리에 그룹화하는 것이 좋다. 애플리케이션의 티어가 DNS를 사용하여 서로 바인딩되면, 스택의 모든 컴포넌트를 함께 배포할 수 있다.</p>
<p>URL을 구성 소스로 지정할 수도 있다. 이는 GitHub에 체크인된 구성 파일에서 직접 배포하는 데 편리하다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://raw.githubusercontent.com/kubernetes/website/main/content/en/examples/application/nginx/nginx-deployment.yaml
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>deployment.apps/my-nginx created
</code></pre></div><h2 id=kubectl에서의-대량-작업>kubectl에서의 대량 작업</h2>
<p><code>kubectl</code> 이 대량으로 수행할 수 있는 작업은 리소스 생성만이 아니다. 또한 다른 작업을 수행하기 위해, 특히 작성한 동일한 리소스를 삭제하기 위해 구성 파일에서 리소스 이름을 추출할 수도 있다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete -f https://k8s.io/examples/application/nginx-app.yaml
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>deployment.apps <span style=color:#b44>&#34;my-nginx&#34;</span> deleted
service <span style=color:#b44>&#34;my-nginx-svc&#34;</span> deleted
</code></pre></div><p>두 개의 리소스가 있는 경우, 리소스/이름 구문을 사용하여 커맨드 라인에서 둘다 모두 지정할 수도 있다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete deployments/my-nginx services/my-nginx-svc
</code></pre></div><p>리소스가 많을 경우, <code>-l</code> 또는 <code>--selector</code> 를 사용하여 지정된 셀렉터(레이블 쿼리)를 지정하여 레이블별로 리소스를 필터링하는 것이 더 쉽다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete deployment,services -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>nginx
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>deployment.apps <span style=color:#b44>&#34;my-nginx&#34;</span> deleted
service <span style=color:#b44>&#34;my-nginx-svc&#34;</span> deleted
</code></pre></div><p><code>kubectl</code> 은 입력을 받아들이는 것과 동일한 구문으로 리소스 이름을 출력하므로, <code>$()</code> 또는 <code>xargs</code> 를 사용하여 작업을 연결할 수 있다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get <span style=color:#a2f;font-weight:700>$(</span>kubectl create -f docs/concepts/cluster-administration/nginx/ -o name | grep service<span style=color:#a2f;font-weight:700>)</span>
kubectl create -f docs/concepts/cluster-administration/nginx/ -o name | grep service | xargs -i kubectl get <span style=color:#666>{}</span>
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>NAME           TYPE           CLUSTER-IP   EXTERNAL-IP   PORT<span style=color:#666>(</span>S<span style=color:#666>)</span>      AGE
my-nginx-svc   LoadBalancer   10.0.0.208   &lt;pending&gt;     80/TCP       0s
</code></pre></div><p>위의 명령을 사용하여, 먼저 <code>examples/application/nginx/</code> 에 리소스를 생성하고 <code>-o name</code> 출력 형식으로 생성한 리소스를 출력한다(각 리소스를 resource/name으로 출력).
그런 다음 "service"만 <code>grep</code> 한 다음 <code>kubectl get</code> 으로 출력한다.</p>
<p>특정 디렉터리 내의 여러 서브 디렉터리에서 리소스를 구성하는 경우, <code>--filename,-f</code> 플래그와 함께 <code>--recursive</code> 또는 <code>-R</code> 을 지정하여, 서브 디렉터리에 대한 작업을 재귀적으로 수행할 수도 있다.</p>
<p>예를 들어, 리소스 유형별로 구성된 개발 환경에 필요한 모든 <a class=glossary-tooltip title="A serialized specification of one or more Kubernetes API objects." data-toggle=tooltip data-placement=top href="/ko/docs/reference/glossary/?all=true#term-manifest" target=_blank aria-label=매니페스트>매니페스트</a>를 보유하는 <code>project/k8s/development</code> 디렉터리가 있다고 가정하자.</p>
<pre><code>project/k8s/development
├── configmap
│   └── my-configmap.yaml
├── deployment
│   └── my-deployment.yaml
└── pvc
    └── my-pvc.yaml
</code></pre><p>기본적으로, <code>project/k8s/development</code> 에서 대량 작업을 수행하면, 서브 디렉터리를 처리하지 않고, 디렉터리의 첫 번째 레벨에서 중지된다. 다음 명령을 사용하여 이 디렉터리에 리소스를 생성하려고 하면, 오류가 발생할 것이다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f project/k8s/development
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>error: you must provide one or more resources by argument or filename <span style=color:#666>(</span>.json|.yaml|.yml|stdin<span style=color:#666>)</span>
</code></pre></div><p>대신, 다음과 같이 <code>--filename,-f</code> 플래그와 함께 <code>--recursive</code> 또는 <code>-R</code> 플래그를 지정한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f project/k8s/development --recursive
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>configmap/my-config created
deployment.apps/my-deployment created
persistentvolumeclaim/my-pvc created
</code></pre></div><p><code>--recursive</code> 플래그는 <code>kubectl {create,get,delete,describe,rollout}</code> 등과 같이 <code>--filename,-f</code> 플래그를 허용하는 모든 작업에서 작동한다.</p>
<p><code>--recursive</code> 플래그는 여러 개의 <code>-f</code> 인수가 제공될 때도 작동한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f project/k8s/namespaces -f project/k8s/development --recursive
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>namespace/development created
namespace/staging created
configmap/my-config created
deployment.apps/my-deployment created
persistentvolumeclaim/my-pvc created
</code></pre></div><p><code>kubectl</code> 에 대해 더 자세히 알고 싶다면, <a href=/ko/docs/reference/kubectl/overview/>kubectl 개요</a>를 참조한다.</p>
<h2 id=효과적인-레이블-사용>효과적인 레이블 사용</h2>
<p>지금까지 사용한 예는 모든 리소스에 최대 한 개의 레이블만 적용하는 것이었다. 세트를 서로 구별하기 위해 여러 레이블을 사용해야 하는 많은 시나리오가 있다.</p>
<p>예를 들어, 애플리케이션마다 <code>app</code> 레이블에 다른 값을 사용하지만, <a href=https://github.com/kubernetes/examples/tree/master/guestbook/>방명록 예제</a>와 같은 멀티-티어 애플리케이션은 각 티어를 추가로 구별해야 한다. 프론트엔드는 다음의 레이블을 가질 수 있다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#bbb>     </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>guestbook<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>tier</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span></code></pre></div><p>Redis 마스터와 슬레이브는 프론트엔드와 다른 <code>tier</code> 레이블을 가지지만, 아마도 추가로 <code>role</code> 레이블을 가질 것이다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#bbb>     </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>guestbook<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>tier</span>:<span style=color:#bbb> </span>backend<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>role</span>:<span style=color:#bbb> </span>master<span style=color:#bbb>
</span></code></pre></div><p>그리고</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#bbb>     </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>guestbook<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>tier</span>:<span style=color:#bbb> </span>backend<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>role</span>:<span style=color:#bbb> </span>slave<span style=color:#bbb>
</span></code></pre></div><p>레이블은 레이블로 지정된 차원에 따라 리소스를 분할하고 사용할 수 있게 한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f examples/guestbook/all-in-one/guestbook-all-in-one.yaml
kubectl get pods -Lapp -Ltier -Lrole
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>NAME                           READY     STATUS    RESTARTS   AGE       APP         TIER       ROLE
guestbook-fe-4nlpb             1/1       Running   <span style=color:#666>0</span>          1m        guestbook   frontend   &lt;none&gt;
guestbook-fe-ght6d             1/1       Running   <span style=color:#666>0</span>          1m        guestbook   frontend   &lt;none&gt;
guestbook-fe-jpy62             1/1       Running   <span style=color:#666>0</span>          1m        guestbook   frontend   &lt;none&gt;
guestbook-redis-master-5pg3b   1/1       Running   <span style=color:#666>0</span>          1m        guestbook   backend    master
guestbook-redis-slave-2q2yf    1/1       Running   <span style=color:#666>0</span>          1m        guestbook   backend    slave
guestbook-redis-slave-qgazl    1/1       Running   <span style=color:#666>0</span>          1m        guestbook   backend    slave
my-nginx-divi2                 1/1       Running   <span style=color:#666>0</span>          29m       nginx       &lt;none&gt;     &lt;none&gt;
my-nginx-o0ef1                 1/1       Running   <span style=color:#666>0</span>          29m       nginx       &lt;none&gt;     &lt;none&gt;
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods -lapp<span style=color:#666>=</span>guestbook,role<span style=color:#666>=</span>slave
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>NAME                          READY     STATUS    RESTARTS   AGE
guestbook-redis-slave-2q2yf   1/1       Running   <span style=color:#666>0</span>          3m
guestbook-redis-slave-qgazl   1/1       Running   <span style=color:#666>0</span>          3m
</code></pre></div><h2 id=카나리-canary-디플로이먼트>카나리(canary) 디플로이먼트</h2>
<p>여러 레이블이 필요한 또 다른 시나리오는 동일한 컴포넌트의 다른 릴리스 또는 구성의 디플로이먼트를 구별하는 것이다. 새 릴리스가 완전히 롤아웃되기 전에 실제 운영 트래픽을 수신할 수 있도록 새로운 애플리케이션 릴리스(파드 템플리트의 이미지 태그를 통해 지정됨)의 <em>카나리</em> 를 이전 릴리스와 나란히 배포하는 것이 일반적이다.</p>
<p>예를 들어, <code>track</code> 레이블을 사용하여 다른 릴리스를 구별할 수 있다.</p>
<p>기본(primary), 안정(stable) 릴리스에는 값이 <code>stable</code> 인 <code>track</code> 레이블이 있다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#bbb>     </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span><span style=color:#bbb>     </span>...<span style=color:#bbb>
</span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>guestbook<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>tier</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>track</span>:<span style=color:#bbb> </span>stable<span style=color:#bbb>
</span><span style=color:#bbb>     </span>...<span style=color:#bbb>
</span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>gb-frontend:v3<span style=color:#bbb>
</span></code></pre></div><p>그런 다음 서로 다른 값(예: <code>canary</code>)으로 <code>track</code> 레이블을 전달하는 방명록 프론트엔드의 새 릴리스를 생성하여, 두 세트의 파드가 겹치지 않도록 할 수 있다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#bbb>     </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>frontend-canary<span style=color:#bbb>
</span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span><span style=color:#bbb>     </span>...<span style=color:#bbb>
</span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>guestbook<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>tier</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>track</span>:<span style=color:#bbb> </span>canary<span style=color:#bbb>
</span><span style=color:#bbb>     </span>...<span style=color:#bbb>
</span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>gb-frontend:v4<span style=color:#bbb>
</span></code></pre></div><p>프론트엔드 서비스는 레이블의 공통 서브셋을 선택하여(즉, <code>track</code> 레이블 생략) 두 레플리카 세트에 걸쳐 있으므로, 트래픽이 두 애플리케이션으로 리디렉션된다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>guestbook<span style=color:#bbb>
</span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>tier</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span></code></pre></div><p>안정 및 카나리 릴리스의 레플리카 수를 조정하여 실제 운영 트래픽을 수신할 각 릴리스의 비율을 결정한다(이 경우, 3:1).
확신이 들면, 안정 릴리스의 track을 새로운 애플리케이션 릴리스로 업데이트하고 카나리를 제거할 수 있다.</p>
<p>보다 구체적인 예시는, <a href=https://github.com/kelseyhightower/talks/tree/master/kubecon-eu-2016/demo#deploy-a-canary>Ghost 배포에 대한 튜토리얼</a>을 확인한다.</p>
<h2 id=레이블-업데이트>레이블 업데이트</h2>
<p>새로운 리소스를 만들기 전에 기존 파드 및 기타 리소스의 레이블을 다시 지정해야 하는 경우가 있다. 이것은 <code>kubectl label</code> 로 수행할 수 있다.
예를 들어, 모든 nginx 파드에 프론트엔드 티어로 레이블을 지정하려면, 다음과 같이 실행한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl label pods -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>nginx <span style=color:#b8860b>tier</span><span style=color:#666>=</span>fe
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>pod/my-nginx-2035384211-j5fhi labeled
pod/my-nginx-2035384211-u2c7e labeled
pod/my-nginx-2035384211-u3t6x labeled
</code></pre></div><p>먼저 "app=nginx" 레이블이 있는 모든 파드를 필터링한 다음, "tier=fe" 레이블을 지정한다.
레이블을 지정한 파드를 보려면, 다음을 실행한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>nginx -L tier
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>NAME                        READY     STATUS    RESTARTS   AGE       TIER
my-nginx-2035384211-j5fhi   1/1       Running   <span style=color:#666>0</span>          23m       fe
my-nginx-2035384211-u2c7e   1/1       Running   <span style=color:#666>0</span>          23m       fe
my-nginx-2035384211-u3t6x   1/1       Running   <span style=color:#666>0</span>          23m       fe
</code></pre></div><p>그러면 파드 티어의 추가 레이블 열(<code>-L</code> 또는 <code>--label-columns</code> 로 지정)과 함께, 모든 "app=nginx" 파드가 출력된다.</p>
<p>더 자세한 내용은, <a href=/ko/docs/concepts/overview/working-with-objects/labels/>레이블</a> 및 <a href=/docs/reference/generated/kubectl/kubectl-commands/#label>kubectl label</a>을 참고하길 바란다.</p>
<h2 id=어노테이션-업데이트>어노테이션 업데이트</h2>
<p>때로는 어노테이션을 리소스에 첨부하려고 할 수도 있다. 어노테이션은 도구, 라이브러리 등과 같은 API 클라이언트가 검색할 수 있는 임의의 비-식별 메타데이터이다. 이는 <code>kubectl annotate</code> 으로 수행할 수 있다. 예를 들면 다음과 같다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl annotate pods my-nginx-v4-9gw19 <span style=color:#b8860b>description</span><span style=color:#666>=</span><span style=color:#b44>&#39;my frontend running nginx&#39;</span>
kubectl get pods my-nginx-v4-9gw19 -o yaml
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>apiVersion: v1
kind: pod
metadata:
  annotations:
    description: my frontend running nginx
...
</code></pre></div><p>더 자세한 내용은, <a href=/ko/docs/concepts/overview/working-with-objects/annotations/>어노테이션</a> 및 <a href=/docs/reference/generated/kubectl/kubectl-commands/#annotate>kubectl annotate</a> 문서를 참고하길 바란다.</p>
<h2 id=애플리케이션-스케일링>애플리케이션 스케일링</h2>
<p>애플리케이션의 로드가 증가하거나 축소되면, <code>kubectl</code> 을 사용하여 애플리케이션을 스케일링한다. 예를 들어, nginx 레플리카 수를 3에서 1로 줄이려면, 다음을 수행한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl scale deployment/my-nginx --replicas<span style=color:#666>=</span><span style=color:#666>1</span>
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>deployment.apps/my-nginx scaled
</code></pre></div><p>이제 디플로이먼트가 관리하는 파드가 하나만 있다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>nginx
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>NAME                        READY     STATUS    RESTARTS   AGE
my-nginx-2035384211-j5fhi   1/1       Running   <span style=color:#666>0</span>          30m
</code></pre></div><p>시스템이 필요에 따라 1에서 3까지의 범위에서 nginx 레플리카 수를 자동으로 선택하게 하려면, 다음을 수행한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl autoscale deployment/my-nginx --min<span style=color:#666>=</span><span style=color:#666>1</span> --max<span style=color:#666>=</span><span style=color:#666>3</span>
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>horizontalpodautoscaler.autoscaling/my-nginx autoscaled
</code></pre></div><p>이제 nginx 레플리카가 필요에 따라 자동으로 확장되거나 축소된다.</p>
<p>더 자세한 내용은, <a href=/docs/reference/generated/kubectl/kubectl-commands/#scale>kubectl scale</a>, <a href=/docs/reference/generated/kubectl/kubectl-commands/#autoscale>kubectl autoscale</a> 및 <a href=/ko/docs/tasks/run-application/horizontal-pod-autoscale/>horizontal pod autoscaler</a> 문서를 참고하길 바란다.</p>
<h2 id=리소스-인플레이스-in-place-업데이트>리소스 인플레이스(in-place) 업데이트</h2>
<p>때로는 자신이 만든 리소스를 필요한 부분만, 중단없이 업데이트해야 할 때가 있다.</p>
<h3 id=kubectl-apply>kubectl apply</h3>
<p>구성 파일 셋을 소스 제어에서 유지하는 것이 좋으며
(<a href=https://martinfowler.com/bliki/InfrastructureAsCode.html>코드로서의 구성</a> 참조),
그렇게 하면 구성하는 리소스에 대한 코드와 함께 버전을 지정하고 유지할 수 있다.
그런 다음, <a href=/docs/reference/generated/kubectl/kubectl-commands/#apply><code>kubectl apply</code></a>를 사용하여 구성 변경 사항을 클러스터로 푸시할 수 있다.</p>
<p>이 명령은 푸시하려는 구성의 버전을 이전 버전과 비교하고 지정하지 않은 속성에 대한 자동 변경 사항을 덮어쓰지 않은 채 수정한 변경 사항을 적용한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/application/nginx/nginx-deployment.yaml
deployment.apps/my-nginx configured
</code></pre></div><p>참고로 <code>kubectl apply</code> 는 이전의 호출 이후 구성의 변경 사항을 판별하기 위해 리소스에 어노테이션을 첨부한다. 호출되면, <code>kubectl apply</code> 는 리소스를 수정하는 방법을 결정하기 위해, 이전 구성과 제공된 입력 및 리소스의 현재 구성 간에 3-way diff를 수행한다.</p>
<p>현재, 이 어노테이션 없이 리소스가 생성되므로, <code>kubectl apply</code> 의 첫 번째 호출은 제공된 입력과 리소스의 현재 구성 사이의 2-way diff로 대체된다. 이 첫 번째 호출 중에는, 리소스를 생성할 때 설정된 특성의 삭제를 감지할 수 없다. 이러한 이유로, 그 특성들을 삭제하지 않는다.</p>
<p><code>kubectl apply</code> 에 대한 모든 후속 호출, 그리고 <code>kubectl replace</code> 및 <code>kubectl edit</code> 와 같이 구성을 수정하는 다른 명령은, 어노테이션을 업데이트하여, <code>kubectl apply</code> 에 대한 후속 호출이 3-way diff를 사용하여 삭제를 감지하고 수행할 수 있도록 한다.</p>
<h3 id=kubectl-edit>kubectl edit</h3>
<p>또는, <code>kubectl edit</code>로 리소스를 업데이트할 수도 있다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl edit deployment/my-nginx
</code></pre></div><p>이것은 먼저 리소스를 <code>get</code> 하여, 텍스트 편집기에서 편집한 다음, 업데이트된 버전으로 리소스를 <code>apply</code> 하는 것과 같다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get deployment my-nginx -o yaml &gt; /tmp/nginx.yaml
vi /tmp/nginx.yaml
<span style=color:#080;font-style:italic># 편집한 다음, 파일을 저장한다.</span>

kubectl apply -f /tmp/nginx.yaml
deployment.apps/my-nginx configured

rm /tmp/nginx.yaml
</code></pre></div><p>이를 통해 보다 중요한 변경을 더 쉽게 수행할 수 있다. 참고로 <code>EDITOR</code> 또는 <code>KUBE_EDITOR</code> 환경 변수를 사용하여 편집기를 지정할 수 있다.</p>
<p>더 자세한 내용은, <a href=/docs/reference/generated/kubectl/kubectl-commands/#edit>kubectl edit</a> 문서를 참고하길 바란다.</p>
<h3 id=kubectl-patch>kubectl patch</h3>
<p><code>kubectl patch</code> 를 사용하여 API 오브젝트를 인플레이스 업데이트할 수 있다. 이 명령은 JSON 패치,
JSON 병합 패치 그리고 전략적 병합 패치를 지원한다.
<a href=/docs/tasks/manage-kubernetes-objects/update-api-object-kubectl-patch/>kubectl patch를 사용한 인플레이스 API 오브젝트 업데이트</a>와
<a href=/docs/reference/generated/kubectl/kubectl-commands/#patch>kubectl patch</a>를
참조한다.</p>
<h2 id=파괴적-disruptive-업데이트>파괴적(disruptive) 업데이트</h2>
<p>경우에 따라, 한 번 초기화하면 업데이트할 수 없는 리소스 필드를 업데이트해야 하거나, 디플로이먼트에서 생성된 손상된 파드를 고치는 등의 재귀적 변경을 즉시 원할 수도 있다. 이러한 필드를 변경하려면, <code>replace --force</code> 를 사용하여 리소스를 삭제하고 다시 만든다. 이 경우, 원래 구성 파일을 수정할 수 있다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl replace -f https://k8s.io/examples/application/nginx/nginx-deployment.yaml --force
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>deployment.apps/my-nginx deleted
deployment.apps/my-nginx replaced
</code></pre></div><h2 id=서비스-중단없이-애플리케이션-업데이트>서비스 중단없이 애플리케이션 업데이트</h2>
<p>언젠가는, 위의 카나리 디플로이먼트 시나리오에서와 같이, 일반적으로 새 이미지 또는 이미지 태그를 지정하여, 배포된 애플리케이션을 업데이트해야 한다. <code>kubectl</code> 은 여러 가지 업데이트 작업을 지원하며, 각 업데이트 작업은 서로 다른 시나리오에 적용할 수 있다.</p>
<p>디플로이먼트를 사용하여 애플리케이션을 생성하고 업데이트하는 방법을 안내한다.</p>
<p>nginx 1.14.2 버전을 실행한다고 가정해 보겠다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create deployment my-nginx --image<span style=color:#666>=</span>nginx:1.14.2
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>deployment.apps/my-nginx created
</code></pre></div><p>3개의 레플리카를 포함한다(이전과 새 개정판이 공존할 수 있음).</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl scale deployment my-nginx --current-replicas<span style=color:#666>=</span><span style=color:#666>1</span> --replicas<span style=color:#666>=</span><span style=color:#666>3</span>
</code></pre></div><pre><code>deployment.apps/my-nginx scaled
</code></pre><p>1.16.1 버전으로 업데이트하려면, 위에서 배운 kubectl 명령을 사용하여 <code>.spec.template.spec.containers[0].image</code> 를 <code>nginx:1.14.2</code> 에서 <code>nginx:1.16.1</code> 로 변경한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl edit deployment/my-nginx
</code></pre></div><p>이것으로 끝이다! 디플로이먼트는 배포된 nginx 애플리케이션을 배후에서 점차적으로 업데이트한다. 업데이트되는 동안 특정 수의 이전 레플리카만 중단될 수 있으며, 원하는 수의 파드 위에 특정 수의 새 레플리카만 생성될 수 있다. 이에 대한 더 자세한 내용을 보려면, <a href=/ko/docs/concepts/workloads/controllers/deployment/>디플로이먼트 페이지</a>를 방문한다.</p>
<h2 id=다음-내용>다음 내용</h2>
<ul>
<li><a href=/docs/tasks/debug-application-cluster/debug-application-introspection/>애플리케이션 검사 및 디버깅에 <code>kubectl</code> 을 사용하는 방법</a>에 대해 알아본다.</li>
<li><a href=/ko/docs/concepts/configuration/overview/>구성 모범 사례 및 팁</a>을 참고한다.</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-d649067a69d8d5c7e71564b42b96909e>11.3 - 클러스터 네트워킹</h1>
<p>네트워킹은 쿠버네티스의 중심적인 부분이지만, 어떻게 작동하는지 정확하게
이해하기가 어려울 수 있다. 쿠버네티스에는 4가지 대응해야 할 네트워킹
문제가 있다.</p>
<ol>
<li>고도로 결합된 컨테이너 간의 통신: 이 문제는
<a class=glossary-tooltip title="파드는 클러스터에서 실행 중인 컨테이너의 집합을 나타낸다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/pods/ target=_blank aria-label=파드>파드</a>와 <code>localhost</code> 통신으로 해결된다.</li>
<li>파드 간 통신: 이 문제가 이 문서의 주요 초점이다.</li>
<li>파드와 서비스 간 통신: 이 문제는 <a href=/ko/docs/concepts/services-networking/service/>서비스</a>에서 다룬다.</li>
<li>외부와 서비스 간 통신: 이 문제는 <a href=/ko/docs/concepts/services-networking/service/>서비스</a>에서 다룬다.</li>
</ol>
<p>쿠버네티스는 애플리케이션 간에 머신을 공유하는 것이다. 일반적으로,
머신을 공유하려면 두 애플리케이션이 동일한 포트를 사용하지 않도록
해야 한다. 여러 개발자 간에 포트를 조정하는 것은 대규모로 실시하기가 매우 어렵고,
사용자가 통제할 수 없는 클러스터 수준의 문제에 노출된다.</p>
<p>동적 포트 할당은 시스템에 많은 복잡성을 야기한다. 모든
애플리케이션은 포트를 플래그로 가져와야 하며, API 서버는 동적 포트 번호를
구성 블록에 삽입하는 방법을 알아야 하고, 서비스는 서로를
찾는 방법 등을 알아야 한다. 쿠버네티스는 이런 것들을 다루는 대신
다른 접근법을 취한다.</p>
<p>쿠버네티스 네트워킹 모델에 대한 상세 정보는 <a href=/ko/docs/concepts/services-networking/>여기</a>를 참고한다.</p>
<h2 id=쿠버네티스-네트워크-모델의-구현-방법>쿠버네티스 네트워크 모델의 구현 방법</h2>
<p>이 네트워크 모델을 구현할 수 있는 방법에는 여러 가지가 있다. 이
문서는 다양한 방법에 대한 철저한 연구는 아니지만, 다양한 기술에 대한
소개로 활용되며 도약하는 포인트로 사용되기를 바란다.</p>
<p>이 목록은 알파벳 순으로 정렬되어 있으며, 정렬된 순서가
우선 상태를 의미하는 것은 아니다.</p>
<div class="alert alert-secondary callout third-party-content" role=alert><strong>참고:</strong>
이 섹션은 쿠버네티스에 필요한 기능을 제공하는 써드파티 프로젝트와 관련이 있다. 쿠버네티스 프로젝트 작성자는 써드파티 프로젝트에 책임이 없다. 이 페이지는 <a href=https://github.com/cncf/foundation/blob/master/website-guidelines.md target=_blank>CNCF 웹사이트 가이드라인</a>에 따라 프로젝트를 알파벳 순으로 나열한다. 이 목록에 프로젝트를 추가하려면 변경사항을 제출하기 전에 <a href=/contribute/style/content-guide/#third-party-content>콘텐츠 가이드</a>를 읽어본다.</div>
<h3 id=aci>ACI</h3>
<p><a href=https://www.cisco.com/c/en/us/solutions/data-center-virtualization/application-centric-infrastructure/index.html>Cisco 애플리케이션 센트릭 인프라스트럭처(Application Centric Infrastructure)</a>는 컨테이너, 가상 머신 및 베어메탈 서버를 지원하는 통합 오버레이 및 언더레이 SDN 솔루션을 제공한다. <a href=https://www.github.com/noironetworks/aci-containers>ACI</a>는 ACI를 위한 컨테이너 네트워킹 통합을 제공한다. 통합의 개요는 <a href=https://www.cisco.com/c/dam/en/us/solutions/collateral/data-center-virtualization/application-centric-infrastructure/solution-overview-c22-739493.pdf>여기</a>에서 제공된다.</p>
<h3 id=antrea>Antrea</h3>
<p>프로젝트 <a href=https://github.com/vmware-tanzu/antrea>Antrea</a>는 쿠버네티스 고유의 오픈소스 쿠버네티스 네트워킹 솔루션이다. 네트워킹 데이터 플레인으로 Open vSwitch를 활용한다. Open vSwitch는 리눅스와 윈도우를 모두 지원하는 고성능의 프로그래밍이 가능한 가상 스위치이다. Antrea는 Open vSwitch를 통해 쿠버네티스 네트워크 정책을 고성능의 효율적인 방식으로 구현할 수 있다.
Antrea는 Open vSwitch의 "프로그래밍이 가능한" 특성으로 인해 Open vSwitch 위에 광범위한 네트워킹 및 보안 기능과 서비스를 구현할 수 있다.</p>
<h3 id=쿠버네티스용-aws-vpc-cni>쿠버네티스용 AWS VPC CNI</h3>
<p><a href=https://github.com/aws/amazon-vpc-cni-k8s>AWS VPC CNI</a>는 쿠버네티스 클러스터를 위한 통합된 AWS 버추얼 프라이빗 클라우드(Virtual Private Cloud, VPC) 네트워킹을 제공한다. 이 CNI 플러그인은 높은 처리량과 가용성, 낮은 레이턴시(latency) 그리고 최소 네트워크 지터(jitter)를 제공한다. 또한, 사용자는 쿠버네티스 클러스터를 구축하기 위한 기존의 AWS VPC 네트워킹 및 보안 모범 사례를 적용할 수 있다. 여기에는 VPC 플로우 로그, VPC 라우팅 정책과 네트워크 트래픽 격리를 위한 보안 그룹을 사용하는 기능이 포함되어 있다.</p>
<p>이 CNI 플러그인을 사용하면 쿠버네티스 파드는 VPC 네트워크와 동일한 IP 주소를 파드 내부에 가질 수 있다. CNI는 각 쿠버네티스 노드에 AWS 엘라스틱 네트워킹 인터페이스(Elastic Networking Interfaces, ENI)를 할당하고 노드의 파드에 대해 각 ENI의 보조 IP 범위를 사용한다. CNI에는 파드를 빠르게 시작하기 위해 ENI와 IP 주소의 사전 할당 제어 기능이 포함되어 있으며 최대 2,000개의 노드로 구성된 대규모 클러스터가 가능하다.</p>
<p>또한, CNI는 <a href=https://docs.aws.amazon.com/eks/latest/userguide/calico.html>네트워크 폴리시 적용을 위해 캘리코(Calico)</a>와 함께 실행할 수 있다. AWS VPC CNI 프로젝트는 <a href=https://github.com/aws/amazon-vpc-cni-k8s>GitHub의 문서</a>와 함께 오픈소스로 공개되어 있다.</p>
<h3 id=쿠버네티스용-azure-cni>쿠버네티스용 Azure CNI</h3>
<p><a href=https://docs.microsoft.com/en-us/azure/virtual-network/container-networking-overview>Azure CNI</a>는 VM과 동등한 네트워크 성능을 제공하는 Azure 버추얼 네트워크(VNet이라고도 알려진)와 쿠버네티스 파드를 통합하는 <a href=https://github.com/Azure/azure-container-networking/blob/master/docs/cni.md>오픈소스</a> 플러그인이다. 파드는 피어링된 VNet과 Express Route 또는 사이트 간 VPN을 통해 온-프레미스에 연결할 수 있으며 이러한 네트워크에서 직접 연결할 수도 있다. 파드는 서비스 엔드포인트 또는 프라이빗 링크로 보호되는 스토리지와 SQL과 같은 Azure 서비스에 접근할 수 있다. VNet 보안 정책과 라우팅을 사용하여 파드 트래픽을 필터링할 수 있다. 플러그인은 쿠버네티스 노드의 네트워크 인터페이스에 사전 구성된 보조 IP 풀을 활용하여 VNet IP를 파드에 할당한다.</p>
<p>Azure CNI는 <a href=https://docs.microsoft.com/en-us/azure/aks/configure-azure-cni>Azure 쿠버네티스 서비스(Azure Kubernetes Service, AKS)</a>에서 기본적으로 사용할 수 있다.</p>
<h3 id=캘리코>캘리코</h3>
<p><a href=https://projectcalico.docs.tigera.io/about/about-calico/>캘리코</a>는 컨테이너, 가상 시스템 및 기본 호스트 기반 워크로드를 위한 오픈소스 네트워킹 및 네트워크 보안 솔루션이다. 캘리코는 순수 리눅스 eBPF 데이터플레인, 표준 리눅스 네트워킹 데이터플레인, 윈도우 HNS 데이터플레인을 포함한 여러 데이터플레인을 지원한다. 캘리코는 완전한 네트워킹 스택을 제공하지만, <a href=https://projectcalico.docs.tigera.io/networking/determine-best-networking#calico-compatible-cni-plugins-and-cloud-provider-integrations>클라우드 제공자 CNI</a>와 함께 사용하여 네트워크 정책 시행을 제공할 수도 있다.</p>
<h3 id=실리움-cilium>실리움(Cilium)</h3>
<p><a href=https://github.com/cilium/cilium>실리움</a>은 애플리케이션 컨테이너 간에
네트워크 연결을 제공하고 투명하게 보호하기 위한 오픈소스 소프트웨어이다.
실리움은 L7/HTTP를 인식하며 네트워크 주소 지정에서 분리된 ID 기반 보안 모델을 사용하여 L3-L7에서
네트워크 정책을 적용할 수 있으며,
다른 CNI 플러그인과 함께 사용할 수 있다.</p>
<h3 id=화웨이의-cni-genie>화웨이의 CNI-Genie</h3>
<p><a href=https://github.com/cni-genie/CNI-Genie>CNI-Genie</a>는 쿠버네티스가 런타임 시 <a href=/ko/docs/concepts/cluster-administration/networking/#%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EB%AA%A8%EB%8D%B8>쿠버네티스 네트워크 모델</a>의 <a href=https://github.com/cni-genie/CNI-Genie/blob/master/docs/multiple-cni-plugins/README.md#what-cni-genie-feature-1-multiple-cni-plugins-enables>서로 다른 구현에 동시에 접근</a>할 수 있는 CNI 플러그인이다. 여기에는 <a href=https://github.com/flannel-io/flannel#flannel>플라넬(Flannel)</a>, <a href=https://projectcalico.docs.tigera.io/about/about-calico/>캘리코</a>, <a href=https://www.weave.works/oss/net/>위브넷(Weave-net)</a>과 같은 <a href=https://github.com/containernetworking/cni#3rd-party-plugins>CNI 플러그인</a>으로 실행되는 모든 구현이 포함된다.</p>
<p>CNI-Genie는 각각 다른 CNI 플러그인에서 <a href=https://github.com/cni-genie/CNI-Genie/blob/master/docs/multiple-ips/README.md#feature-2-extension-cni-genie-multiple-ip-addresses-per-pod>하나의 파드에 여러 IP 주소를 할당</a>하는 것도 지원한다.</p>
<h3 id=cni-ipvlan-vpc-k8s>cni-ipvlan-vpc-k8s</h3>
<p><a href=https://github.com/lyft/cni-ipvlan-vpc-k8s>cni-ipvlan-vpc-k8s</a>는
L2 모드에서 리눅스 커널의 IPvlan 드라이버를 사용하여 Amazon 엘라스틱 네트워크 인터페이스(ENI)를
사용하고 AWS 매니지드 IP를 파드에 바인딩하는
Amazon 버추얼 프라이빗 클라우드(VPC) 환경 내에서 쿠버네티스를 위한
간단하고, 호스트 로컬, 낮은 레이턴시, 높은 처리량 및 호환 네트워킹 스택을 제공하는
CNI와 IPAM 플러그인 셋을 포함한다.</p>
<p>플러그인은 VPC 내에서 구성하고 배포할 수 있도록 간단하게 설계되었다.
Kubelets는 오버레이 네트워크 관리, BGP 관리, 소스/대상 확인 비활성화 또는
VPC 라우팅 테이블을 조정하여 각 호스트에 인스턴스별 서브넷을
제공(VPC별 50-100개 항목으로 제한)하는 등의 자주 권장되는 복잡성을 요구하지 않고
부팅한 다음 필요에 따라 IP 사용량을 자체 구성하고 확장할
수 있다. 즉, cni-ipvlan-vpc-k8s는 AWS 내에서 쿠버네티스를
대규모로 배포하는 데 필요한 네트워크 복잡성을 크게 줄인다.</p>
<h3 id=coil>Coil</h3>
<p><a href=https://github.com/cybozu-go/coil>Coil</a>은 통합이 용이하도록 설계된 CNI 플러그인으로 유연한 이그레스(egress) 네트워킹을 제공한다.
Coil은 베어메탈에 비해 낮은 오버헤드로 작동하며, 외부 네트워크에 대해 임의의 이그레스 NAT 게이트웨이를 정의할 수 있다.</p>
<h3 id=콘티브-vpp-contiv-vpp>콘티브-VPP(Contiv-VPP)</h3>
<p><a href=https://contivpp.io/>Contiv-VPP</a>는 유저 스페이스에서 동작하고 성능을 중시하는 쿠버네티스 네트워크 플러그인이며,
데이터 플레인으로 <a href=https://fd.io/>fd.io</a>를 사용한다.</p>
<h3 id=콘트레일-contrail-텅스텐-패브릭-tungsten-fabric>콘트레일(Contrail) / 텅스텐 패브릭(Tungsten Fabric)</h3>
<p><a href=https://tungsten.io>텅스텐 패브릭</a>을 기반으로 하는 <a href=https://www.juniper.net/us/en/products-services/sdn/contrail/contrail-networking/>콘트레일</a>은 진정한 개방형 멀티 클라우드 네트워크 가상화 및 정책 관리 플랫폼이다. 콘트레일 및 텅스텐 패브릭은 쿠버네티스, OpenShift, OpenStack 및 Mesos와 같은 다양한 오케스트레이션 시스템과 통합되어 있으며, 가상 머신, 컨테이너/파드 및 베어메탈 워크로드에 대해 서로 다른 격리 모드를 제공한다.</p>
<h3 id=danm>DANM</h3>
<p><a href=https://github.com/nokia/danm>DANM</a>은 쿠버네티스 클러스터에서 실행되는 통신사 워크로드를 위한 네트워킹 솔루션이다. 다음의 컴포넌트로 구성된다.</p>
<ul>
<li>고급 기능들로 IPVLAN 인터페이스를 프로비저닝할 수 있는 CNI 플러그인</li>
<li>여러 클러스터 전체의 불연속 L3 네트워크를 관리하고 요청 시 동적, 정적 또는 IP를 할당하지 않는 방식을 제공하는 내장 IPAM 모듈</li>
<li>자체 CNI를 통해서, 또는 SRI-OV나 플라넬과 같은 널리 사용되는 CNI 솔루션에 잡을 동시에 위임하여 여러 네트워크 인터페이스를 컨테이너에 연결할 수 있는 CNI 메타플러그인</li>
<li>모든 쿠버네티스 호스트의 VxLAN 및 VLAN 인터페이스를 중앙에서 관리할 수 있는 쿠버네티스 컨트롤러</li>
<li>쿠버네티스의 서비스 기반의 서비스 검색 개념을 확장하여 파드의 모든 네트워크 인터페이스에서 작동하는 다른 쿠버네티스 컨트롤러</li>
</ul>
<p>이 도구 셋을 통해 DANM은 여러 개의 분리된 네트워크 인터페이스를 제공할 수 있으며, 파드에 다른 네트워킹 백엔드 및 고급 IPAM 기능을 사용할 수 있다.</p>
<h3 id=플라넬>플라넬</h3>
<p><a href=https://github.com/flannel-io/flannel#flannel>플라넬</a>은 쿠버네티스 요구 사항을
충족하는 매우 간단한 오버레이 네트워크이다. 많은
경우에 쿠버네티스와 플라넬은 성공적으로 적용이 가능하다.</p>
<h3 id=hybridnet>Hybridnet</h3>
<p><a href=https://github.com/alibaba/hybridnet>Hybridnet</a>은 하이브리드 클라우드를 위해 디자인된 오픈소스 CNI 플러그인이며 하나 또는 다수의 클러스터에 있는 컨테이너를 위한 오버레이 및 언더레이 네트워킹을 제공한다. 오버레이 및 언더레이 컨테이너는 동일한 노드에서 실행될 수 있으며 클러스터 범위의 양방향 네트워크 연결성을 가진다.</p>
<h3 id=재규어-jaguar>재규어(Jaguar)</h3>
<p><a href=https://gitlab.com/sdnlab/jaguar>재규어</a>는 OpenDaylight 기반의 쿠버네티스 네트워크를 위한 오픈소스 솔루션이다. 재규어는 vxlan을 사용하여 오버레이 네트워크를 제공하고 재규어 CNI 플러그인은 파드별로 하나의 IP 주소를 제공한다.</p>
<h3 id=k-vswitch>k-vswitch</h3>
<p><a href=https://github.com/k-vswitch/k-vswitch>k-vswitch</a>는 <a href=https://www.openvswitch.org/>Open vSwitch</a> 기반의 간단한 쿠버네티스 네트워킹 플러그인이다. Open vSwitch의 기존 기능을 활용하여 운영하기 쉽고, 성능이 뛰어나고 안전한 강력한 네트워킹 플러그인을 제공한다.</p>
<h3 id=knitter>Knitter</h3>
<p><a href=https://github.com/ZTE/Knitter/>Knitter</a>는 쿠버네티스에서 여러 네트워킹을 지원하는 네트워크 솔루션이다. 테넌트 관리 및 네트워크 관리 기능을 제공한다. Knitter에는 애플리케이션의 IP 주소 유지, IP 주소 마이그레이션 등과 같은 여러 네트워크 플레인 외에 엔드-투-엔드 NFV 컨테이너 네트워킹 솔루션 셋이 포함되어 있다.</p>
<h3 id=kube-ovn>Kube-OVN</h3>
<p><a href=https://github.com/alauda/kube-ovn>Kube-OVN</a>은 기업을 위한 OVN 기반 쿠버네티스 네트워크 패브릭이다. OVN/OVS의 도움으로, 서브넷, QoS, 고정 IP 할당, 트래픽 미러링, 게이트웨이, 오픈플로우 기반 네트워크 정책 및 서비스 프록시와 같은 고급 오버레이 네트워크 기능을 제공한다.</p>
<h3 id=kube-router>Kube-router</h3>
<p><a href=https://github.com/cloudnativelabs/kube-router>kube-router</a>는 쿠버네티스를 위한 특수 목적의 네트워킹 솔루션으로 고성능 및 운영 단순성을 제공한다. 큐브 라우터는 리눅스 <a href=https://www.linuxvirtualserver.org/software/ipvs.html>LVS/IPVS</a> 기반 서비스 프록시, 오버레이가 없는 리눅스 커널 포워딩 기반의 파드 간 네트워킹 솔루션 그리고 iptables/ipset 기반 네트워크 정책 집행도구를 제공한다.</p>
<h3 id=l2-네트워크-및-리눅스-브릿지>L2 네트워크 및 리눅스 브릿지</h3>
<p>"베어메탈" 환경의 간단한 스위치와 같은 "더미(dumb)" L2 네트워크가 있는 경우,
위의 GCE 설정과 비슷한 작업을 수행할 수 있어야 한다.
이 방법은 매우 우연히 시도되었고 작동하는 것으로 보이지만
철저히 테스트되지 않았다. 이 기술을 사용하여
프로세스를 완료한 경우, 알려주길 바란다.</p>
<p>Lars Kellogg-Stedman이 제공하는
<a href=https://blog.oddbit.com/2014/08/11/four-ways-to-connect-a-docker/>이 훌륭한 튜토리얼</a>의
"With Linux Bridge devices" 섹션을 참고한다.</p>
<h3 id=multus-멀티-네트워크-플러그인>Multus(멀티 네트워크 플러그인)</h3>
<p>Multus는 쿠버네티스의 CRD 기반 네트워크 오브젝트를 사용하여 쿠버네티스에서 멀티 네트워킹 기능을 지원하는 멀티 CNI 플러그인이다.</p>
<p>Multus는 CNI 명세를 구현하는 모든 <a href=https://github.com/containernetworking/plugins>레퍼런스 플러그인</a>(예: <a href=https://github.com/containernetworking/cni.dev/blob/main/content/plugins/v0.9/meta/flannel.md>플라넬</a>, <a href=https://github.com/containernetworking/plugins/tree/master/plugins/ipam/dhcp>DHCP</a>, <a href=https://github.com/containernetworking/plugins/tree/master/plugins/main/macvlan>Macvlan</a>) 및 써드파티 플러그인(예: <a href=https://github.com/projectcalico/cni-plugin>캘리코</a>, <a href=https://github.com/weaveworks/weave>위브(Weave)</a>, <a href=https://github.com/cilium/cilium>실리움</a>, <a href=https://github.com/contiv/netplugin>콘티브</a>)을 지원한다. 또한, Multus는 쿠버네티스의 클라우드 네이티브 애플리케이션과 NFV 기반 애플리케이션을 통해 쿠버네티스의 <a href=https://github.com/hustcat/sriov-cni>SRIOV</a>, <a href=https://github.com/Intel-Corp/sriov-cni>DPDK</a>, <a href=https://github.com/intel/vhost-user-net-plugin>OVS-DPDK 및 VPP</a> 워크로드를 지원한다.</p>
<h3 id=ovn4nfv-k8s-plugin-ovn-기반의-cni-컨트롤러-플러그인>OVN4NFV-K8s-Plugin (OVN 기반의 CNI 컨트롤러 & 플러그인)</h3>
<p><a href=https://github.com/opnfv/ovn4nfv-k8s-plugin>OVN4NFV-K8S-Plugin</a>은 OVN 기반의 CNI 컨트롤러 플러그인으로 클라우드 네이티브 기반 서비스 기능 체인(Service function chaining(SFC)), 다중 OVN 오버레이 네트워킹, 동적 서브넷 생성, 동적 가상 네트워크 생성, VLAN 공급자 네트워크, 직접 공급자 네트워크와 멀티 클러스터 네트워킹의 엣지 기반 클라우드 등 네이티브 워크로드에 이상적인 멀티 네티워크 플러그인이다.</p>
<h3 id=nsx-t>NSX-T</h3>
<p><a href=https://docs.vmware.com/en/VMware-NSX-T/index.html>VMware NSX-T</a>는 네트워크 가상화 및 보안 플랫폼이다. NSX-T는 멀티 클라우드 및 멀티 하이퍼바이저 환경에 네트워크 가상화를 제공할 수 있으며 이기종 엔드포인트와 기술 스택이 있는 새로운 애플리케이션 프레임워크 및 아키텍처에 중점을 둔다. vSphere 하이퍼바이저 외에도, 이러한 환경에는 KVM, 컨테이너 및 베어메탈과 같은 다른 하이퍼바이저가 포함된다.</p>
<p><a href=https://docs.vmware.com/en/VMware-NSX-T/2.0/nsxt_20_ncp_kubernetes.pdf>NSX-T 컨테이너 플러그인(NCP)</a>은 NSX-T와 쿠버네티스와 같은 컨테이너 오케스트레이터 사이의 통합은 물론, NSX-T와 Pivotal 컨테이너 서비스(PKS) 및 OpenShift와 같은 컨테이너 기반 CaaS/PaaS 플랫폼 간의 통합을 제공한다.</p>
<h3 id=ovn-오픈-버추얼-네트워킹>OVN(오픈 버추얼 네트워킹)</h3>
<p>OVN은 Open vSwitch 커뮤니티에서 개발한 오픈소스 네트워크
가상화 솔루션이다. 논리적 스위치, 논리적 라우터, 스테이트풀 ACL, 로드 밸런서 등을 생성하여
서로 다른 가상 네트워킹 토폴로지를 구축할 수 있다. 이 프로젝트에는
<a href=https://github.com/openvswitch/ovn-kubernetes>ovn-kubernetes</a>에
특정 쿠버네티스 플러그인 및 문서가 있다.</p>
<h3 id=weaveworks의-위브넷>Weaveworks의 위브넷</h3>
<p><a href=https://www.weave.works/oss/net/>위브넷</a>은
쿠버네티스 및 호스팅된 애플리케이션을 위한 탄력적이고 사용하기 쉬운 네트워크이다.
위브넷은 <a href=https://www.weave.works/docs/net/latest/cni-plugin/>CNI 플러그인</a> 또는
독립형으로 실행된다. 두 버전에서, 실행하기 위해 구성이나 추가 코드가 필요하지 않으며,
두 경우 모두, 쿠버네티스의 표준과 같이 네트워크에서 파드별로 하나의 IP 주소를 제공한다.</p>
<h2 id=다음-내용>다음 내용</h2>
<p>네트워크 모델의 초기 설계와 그 근거 및 미래의 계획은
<a href=https://git.k8s.io/community/contributors/design-proposals/network/networking.md>네트워킹 디자인 문서</a>에
자세히 설명되어 있다.</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-c4b1e87a84441f8a90699a345ce48d68>11.4 - 로깅 아키텍처</h1>
<p>애플리케이션 로그는 애플리케이션 내부에서 발생하는 상황을 이해하는 데 도움이 된다. 로그는 문제를 디버깅하고 클러스터 활동을 모니터링하는 데 특히 유용하다. 대부분의 최신 애플리케이션에는 일종의 로깅 메커니즘이 있다. 마찬가지로, 컨테이너 엔진들도 로깅을 지원하도록 설계되었다. 컨테이너화된 애플리케이션에 가장 쉽고 가장 널리 사용되는 로깅 방법은 표준 출력과 표준 에러 스트림에 작성하는 것이다.</p>
<p>그러나, 일반적으로 컨테이너 엔진이나 런타임에서 제공하는 기본 기능은 완전한 로깅 솔루션으로 충분하지 않다.
예를 들어, 컨테이너가 크래시되거나, 파드가 축출되거나, 노드가 종료된 경우에도 애플리케이션의 로그에 접근하고 싶을 것이다.
클러스터에서 로그는 노드, 파드 또는 컨테이너와는 독립적으로 별도의 스토리지와 라이프사이클을 가져야 한다. 이 개념을 <em>클러스터-레벨-로깅</em> 이라고 한다.</p>
<p>클러스터-레벨 로깅은 로그를 저장, 분석, 쿼리하기 위해서는 별도의 백엔드가 필요하다. 쿠버네티스가
로그 데이터를 위한 네이티브 스토리지 솔루션을 제공하지는 않지만,
쿠버네티스에 통합될 수 있는 기존의 로깅 솔루션이 많이 있다.</p>
<h2 id=쿠버네티스의-기본-로깅>쿠버네티스의 기본 로깅</h2>
<p>이 예시는 텍스트를 초당 한 번씩 표준 출력에 쓰는
컨테이너에 대한 <code>Pod</code> 명세를 사용한다.</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/ko/examples/debug/counter-pod.yaml download=debug/counter-pod.yaml><code>debug/counter-pod.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('debug-counter-pod-yaml')" title="Copy debug/counter-pod.yaml to clipboard">
</img>
</div>
<div class=includecode id=debug-counter-pod-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>counter<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>count<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb> </span>[/bin/sh, -c,<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:#b44>&#39;i=0; while true; do echo &#34;$i: $(date)&#34;; i=$((i+1)); sleep 1; done&#39;</span>]<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>이 파드를 실행하려면, 다음의 명령을 사용한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/debug/counter-pod.yaml
</code></pre></div><p>출력은 다음과 같다.</p>
<pre><code class=language-console data-lang=console>pod/counter created
</code></pre><p>로그를 가져오려면, 다음과 같이 <code>kubectl logs</code> 명령을 사용한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl logs counter
</code></pre></div><p>출력은 다음과 같다.</p>
<pre><code class=language-console data-lang=console>0: Mon Jan  1 00:00:00 UTC 2001
1: Mon Jan  1 00:00:01 UTC 2001
2: Mon Jan  1 00:00:02 UTC 2001
...
</code></pre><p><code>kubectl logs --previous</code> 를 사용해서 컨테이너의 이전 인스턴스에 대한 로그를 검색할 수 있다. 파드에 여러 컨테이너가 있는 경우, 명령에 컨테이너 이름을 추가하여 접근하려는 컨테이너 로그를 지정해야 한다. 자세한 내용은 <a href=/docs/reference/generated/kubectl/kubectl-commands#logs><code>kubectl logs</code> 문서</a>를 참조한다.</p>
<h2 id=노드-레벨에서의-로깅>노드 레벨에서의 로깅</h2>
<p><img src=/images/docs/user-guide/logging/logging-node-level.png alt="노드 레벨 로깅"></p>
<p>컨테이너화된 애플리케이션의 <code>stdout(표준 출력)</code> 및 <code>stderr(표준 에러)</code> 스트림에 의해 생성된 모든 출력은 컨테이너 엔진이 처리 및 리디렉션 한다.
예를 들어, 도커 컨테이너 엔진은 이 두 스트림을 <a href=https://docs.docker.com/engine/admin/logging/overview>로깅 드라이버</a>로 리디렉션 한다. 이 드라이버는 쿠버네티스에서 JSON 형식의 파일에 작성하도록 구성된다.</p>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> 도커 JSON 로깅 드라이버는 각 라인을 별도의 메시지로 취급한다. 도커 로깅 드라이버를 사용하는 경우, 멀티-라인 메시지를 직접 지원하지 않는다. 로깅 에이전트 레벨 이상에서 멀티-라인 메시지를 처리해야 한다.
</div>
<p>기본적으로, 컨테이너가 다시 시작되면, kubelet은 종료된 컨테이너 하나를 로그와 함께 유지한다. 파드가 노드에서 축출되면, 해당하는 모든 컨테이너도 로그와 함께 축출된다.</p>
<p>노드-레벨 로깅에서 중요한 고려 사항은 로그 로테이션을 구현하여,
로그가 노드에서 사용 가능한 모든 스토리지를 사용하지 않도록 하는 것이다. 쿠버네티스는
로그 로테이션에 대한 의무는 없지만, 디플로이먼트 도구로
이를 해결하기 위한 솔루션을 설정해야 한다.
예를 들어, <code>kube-up.sh</code> 스크립트에 의해 배포된 쿠버네티스 클러스터에는,
매시간 실행되도록 구성된 <a href=https://linux.die.net/man/8/logrotate><code>logrotate</code></a>
도구가 있다. 애플리케이션의 로그를 자동으로
로테이션하도록 컨테이너 런타임을 설정할 수도 있다.</p>
<p>예를 들어, <code>kube-up.sh</code> 가 GCP의 COS 이미지 로깅을 설정하는 방법은
<a href=https://github.com/kubernetes/kubernetes/blob/master/cluster/gce/gci/configure-helper.sh><code>configure-helper</code> 스크립트</a>를 통해
자세히 알 수 있다.</p>
<p><strong>CRI 컨테이너 런타임</strong> 을 사용할 때, kubelet은 로그를 로테이션하고 로깅 디렉터리 구조를 관리한다.
kubelet은 이 정보를 CRI 컨테이너 런타임에 전송하고 런타임은 컨테이너 로그를 지정된 위치에 기록한다.
<a href=/docs/tasks/administer-cluster/kubelet-config-file/>kubelet config file</a>에 있는
두 개의 kubelet 파라미터 <a href=/docs/reference/config-api/kubelet-config.v1beta1/#kubelet-config-k8s-io-v1beta1-KubeletConfiguration><code>containerLogMaxSize</code> 및 <code>containerLogMaxFiles</code></a>를
사용하여 각 로그 파일의 최대 크기와 각 컨테이너에 허용되는 최대 파일 수를 각각 구성할 수 있다.</p>
<p>기본 로깅 예제에서와 같이 <a href=/docs/reference/generated/kubectl/kubectl-commands#logs><code>kubectl logs</code></a>를
실행하면, 노드의 kubelet이 요청을 처리하고
로그 파일에서 직접 읽는다. kubelet은 로그 파일의 내용을 반환한다.</p>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> 만약, 일부 외부 시스템이 로테이션을 수행했거나 CRI 컨테이너 런타임이 사용된 경우,
<code>kubectl logs</code> 를 통해 최신 로그 파일의 내용만
사용할 수 있다. 예를 들어, 10MB 파일이 있으면, <code>logrotate</code> 가
로테이션을 수행하고 두 개의 파일이 생긴다. (크기가 10MB인 파일 하나와 비어있는 파일)
<code>kubectl logs</code> 는 이 예시에서는 빈 응답에 해당하는 최신 로그 파일을 반환한다.
</div>
<h3 id=시스템-컴포넌트-로그>시스템 컴포넌트 로그</h3>
<p>시스템 컴포넌트에는 컨테이너에서 실행되는 것과 컨테이너에서 실행되지 않는 두 가지 유형이 있다.
예를 들면 다음과 같다.</p>
<ul>
<li>쿠버네티스 스케줄러와 kube-proxy는 컨테이너에서 실행된다.</li>
<li>Kubelet과 컨테이너 런타임은 컨테이너에서 실행되지 않는다.</li>
</ul>
<p>systemd를 사용하는 시스템에서는, kubelet과 컨테이너 런타임은 journald에 작성한다.
systemd를 사용하지 않으면, kubelet과 컨테이너 런타임은 <code>/var/log</code> 디렉터리의
<code>.log</code> 파일에 작성한다. 컨테이너 내부의 시스템 컴포넌트는 기본 로깅 메커니즘을 무시하고,
항상 <code>/var/log</code> 디렉터리에 기록한다.
시스템 컴포넌트는 <a href=https://github.com/kubernetes/klog>klog</a>
로깅 라이브러리를 사용한다. <a href=https://github.com/kubernetes/community/blob/master/contributors/devel/sig-instrumentation/logging.md>로깅에 대한 개발 문서</a>에서
해당 컴포넌트의 로깅 심각도(severity)에 대한 규칙을 찾을 수 있다.</p>
<p>컨테이너 로그와 마찬가지로, <code>/var/log</code> 디렉터리의 시스템 컴포넌트 로그를
로테이트해야 한다. <code>kube-up.sh</code> 스크립트로 구축한 쿠버네티스 클러스터에서
로그는 매일 또는 크기가 100MB를 초과하면
<code>logrotate</code> 도구에 의해 로테이트가 되도록 구성된다.</p>
<h2 id=클러스터-레벨-로깅-아키텍처>클러스터 레벨 로깅 아키텍처</h2>
<p>쿠버네티스는 클러스터-레벨 로깅을 위한 네이티브 솔루션을 제공하지 않지만, 고려해야 할 몇 가지 일반적인 접근 방법을 고려할 수 있다. 여기 몇 가지 옵션이 있다.</p>
<ul>
<li>모든 노드에서 실행되는 노드-레벨 로깅 에이전트를 사용한다.</li>
<li>애플리케이션 파드에 로깅을 위한 전용 사이드카 컨테이너를 포함한다.</li>
<li>애플리케이션 내에서 로그를 백엔드로 직접 푸시한다.</li>
</ul>
<h3 id=노드-로깅-에이전트-사용>노드 로깅 에이전트 사용</h3>
<p><img src=/images/docs/user-guide/logging/logging-with-node-agent.png alt="노드 레벨 로깅 에이전트 사용"></p>
<p>각 노드에 <em>노드-레벨 로깅 에이전트</em> 를 포함시켜 클러스터-레벨 로깅을 구현할 수 있다. 로깅 에이전트는 로그를 노출하거나 로그를 백엔드로 푸시하는 전용 도구이다. 일반적으로, 로깅 에이전트는 해당 노드의 모든 애플리케이션 컨테이너에서 로그 파일이 있는 디렉터리에 접근할 수 있는 컨테이너이다.</p>
<p>로깅 에이전트는 모든 노드에서 실행되어야 하므로, 에이전트를
<code>DaemonSet</code> 으로 동작시키는 것을 추천한다.</p>
<p>노드-레벨 로깅은 노드별 하나의 에이전트만 생성하며, 노드에서 실행되는 애플리케이션에 대한 변경은 필요로 하지 않는다.</p>
<p>컨테이너는 stdout과 stderr를 동의되지 않은 포맷으로 작성한다. 노드-레벨 에이전트는 이러한 로그를 수집하고 취합을 위해 전달한다.</p>
<h3 id=sidecar-container-with-logging-agent>로깅 에이전트와 함께 사이드카 컨테이너 사용</h3>
<p>다음 중 한 가지 방법으로 사이드카 컨테이너를 사용할 수 있다.</p>
<ul>
<li>사이드카 컨테이너는 애플리케이션 로그를 자체 <code>stdout</code> 으로 스트리밍한다.</li>
<li>사이드카 컨테이너는 로깅 에이전트를 실행하며, 애플리케이션 컨테이너에서 로그를 가져오도록 구성된다.</li>
</ul>
<h4 id=사이드카-컨테이너-스트리밍>사이드카 컨테이너 스트리밍</h4>
<p><img src=/images/docs/user-guide/logging/logging-with-streaming-sidecar.png alt="스트리밍 컨테이너가 있는 사이드카 컨테이너"></p>
<p>사이드카 컨테이너가 자체 <code>stdout</code> 및 <code>stderr</code> 스트림으로
쓰도록 하면, 각 노드에서 이미 실행 중인 kubelet과 로깅 에이전트를
활용할 수 있다. 사이드카 컨테이너는 파일, 소켓 또는 journald에서 로그를 읽는다.
각 사이드카 컨테이너는 자체 <code>stdout</code> 또는 <code>stderr</code> 스트림에 로그를 출력한다.</p>
<p>이 방법을 사용하면 애플리케이션의 다른 부분에서 여러 로그 스트림을
분리할 수 있고, 이 중 일부는 <code>stdout</code> 또는 <code>stderr</code> 에
작성하기 위한 지원이 부족할 수 있다. 로그를 리디렉션하는 로직은
최소화되어 있기 때문에, 심각한 오버헤드가 아니다. 또한,
<code>stdout</code> 및 <code>stderr</code> 가 kubelet에서 처리되므로, <code>kubectl logs</code> 와 같은
빌트인 도구를 사용할 수 있다.</p>
<p>예를 들어, 파드는 단일 컨테이너를 실행하고, 컨테이너는
서로 다른 두 가지 형식을 사용하여 서로 다른 두 개의 로그 파일에 기록한다. 파드에 대한
구성 파일은 다음과 같다.</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/ko/examples/admin/logging/two-files-counter-pod.yaml download=admin/logging/two-files-counter-pod.yaml><code>admin/logging/two-files-counter-pod.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('admin-logging-two-files-counter-pod-yaml')" title="Copy admin/logging/two-files-counter-pod.yaml to clipboard">
</img>
</div>
<div class=includecode id=admin-logging-two-files-counter-pod-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>counter<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>count<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- /bin/sh<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- -c<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- &gt;<span style=color:#b44;font-style:italic>
</span><span style=color:#b44;font-style:italic>      i=0;
</span><span style=color:#b44;font-style:italic>      while true;
</span><span style=color:#b44;font-style:italic>      do
</span><span style=color:#b44;font-style:italic>        echo &#34;$i: $(date)&#34; &gt;&gt; /var/log/1.log;
</span><span style=color:#b44;font-style:italic>        echo &#34;$(date) INFO $i&#34; &gt;&gt; /var/log/2.log;
</span><span style=color:#b44;font-style:italic>        i=$((i+1));
</span><span style=color:#b44;font-style:italic>        sleep 1;
</span><span style=color:#b44;font-style:italic>      done</span><span style=color:#bbb>      
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>varlog<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/var/log<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>varlog<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>emptyDir</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>두 컴포넌트를 컨테이너의 <code>stdout</code> 스트림으로 리디렉션한 경우에도, 동일한 로그
스트림에 서로 다른 형식의 로그 항목을 작성하는 것은
추천하지 않는다. 대신, 두 개의 사이드카 컨테이너를 생성할 수 있다. 각 사이드카
컨테이너는 공유 볼륨에서 특정 로그 파일을 테일(tail)한 다음 로그를
자체 <code>stdout</code> 스트림으로 리디렉션할 수 있다.</p>
<p>다음은 사이드카 컨테이너가 두 개인 파드에 대한 구성 파일이다.</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/ko/examples/admin/logging/two-files-counter-pod-streaming-sidecar.yaml download=admin/logging/two-files-counter-pod-streaming-sidecar.yaml><code>admin/logging/two-files-counter-pod-streaming-sidecar.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('admin-logging-two-files-counter-pod-streaming-sidecar-yaml')" title="Copy admin/logging/two-files-counter-pod-streaming-sidecar.yaml to clipboard">
</img>
</div>
<div class=includecode id=admin-logging-two-files-counter-pod-streaming-sidecar-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>counter<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>count<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- /bin/sh<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- -c<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- &gt;<span style=color:#b44;font-style:italic>
</span><span style=color:#b44;font-style:italic>      i=0;
</span><span style=color:#b44;font-style:italic>      while true;
</span><span style=color:#b44;font-style:italic>      do
</span><span style=color:#b44;font-style:italic>        echo &#34;$i: $(date)&#34; &gt;&gt; /var/log/1.log;
</span><span style=color:#b44;font-style:italic>        echo &#34;$(date) INFO $i&#34; &gt;&gt; /var/log/2.log;
</span><span style=color:#b44;font-style:italic>        i=$((i+1));
</span><span style=color:#b44;font-style:italic>        sleep 1;
</span><span style=color:#b44;font-style:italic>      done</span><span style=color:#bbb>      
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>varlog<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/var/log<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>count-log-1<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb> </span>[/bin/sh, -c, &#39;tail -n+1 -f /var/log/1.log&#39;]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>varlog<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/var/log<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>count-log-2<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb> </span>[/bin/sh, -c, &#39;tail -n+1 -f /var/log/2.log&#39;]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>varlog<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/var/log<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>varlog<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>emptyDir</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>이제 이 파드를 실행하면, 다음의 명령을 실행하여 각 로그 스트림에
개별적으로 접근할 수 있다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl logs counter count-log-1
</code></pre></div><p>출력은 다음과 같다.</p>
<pre><code class=language-console data-lang=console>0: Mon Jan  1 00:00:00 UTC 2001
1: Mon Jan  1 00:00:01 UTC 2001
2: Mon Jan  1 00:00:02 UTC 2001
...
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl logs counter count-log-2
</code></pre></div><p>출력은 다음과 같다.</p>
<pre><code class=language-console data-lang=console>Mon Jan  1 00:00:00 UTC 2001 INFO 0
Mon Jan  1 00:00:01 UTC 2001 INFO 1
Mon Jan  1 00:00:02 UTC 2001 INFO 2
...
</code></pre><p>클러스터에 설치된 노드-레벨 에이전트는 추가 구성없이
자동으로 해당 로그 스트림을 선택한다. 원한다면, 소스 컨테이너에
따라 로그 라인을 파싱(parse)하도록 에이전트를 구성할 수 있다.</p>
<p>참고로, CPU 및 메모리 사용량이 낮음에도 불구하고(cpu에 대한 몇 밀리코어의
요구와 메모리에 대한 몇 메가바이트의 요구), 로그를 파일에 기록한 다음
<code>stdout</code> 으로 스트리밍하면 디스크 사용량은 두 배가 될 수 있다. 단일 파일에
쓰는 애플리케이션이 있는 경우, 일반적으로 스트리밍
사이드카 컨테이너 방식을 구현하는 대신 <code>/dev/stdout</code> 을 대상으로
설정하는 것을 추천한다.</p>
<p>사이드카 컨테이너를 사용하여 애플리케이션 자체에서 로테이션할 수 없는
로그 파일을 로테이션할 수도 있다. 이 방법의 예시는 정기적으로 <code>logrotate</code> 를 실행하는 작은 컨테이너를 두는 것이다.
그러나, <code>stdout</code> 및 <code>stderr</code> 을 직접 사용하고 로테이션과
유지 정책을 kubelet에 두는 것이 권장된다.</p>
<h4 id=로깅-에이전트가-있는-사이드카-컨테이너>로깅 에이전트가 있는 사이드카 컨테이너</h4>
<p><img src=/images/docs/user-guide/logging/logging-with-sidecar-agent.png alt="로깅 에이전트가 있는 사이드카 컨테이너"></p>
<p>노드-레벨 로깅 에이전트가 상황에 맞게 충분히 유연하지 않은 경우,
애플리케이션과 함께 실행하도록 특별히 구성된 별도의 로깅 에이전트를 사용하여
사이드카 컨테이너를 생성할 수 있다.</p>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> 사이드카 컨테이너에서 로깅 에이전트를 사용하면
상당한 리소스 소비로 이어질 수 있다. 게다가, kubelet에 의해
제어되지 않기 때문에, <code>kubectl logs</code> 를 사용하여 해당 로그에
접근할 수 없다.
</div>
<p>여기에 로깅 에이전트가 포함된 사이드카 컨테이너를 구현하는 데 사용할 수 있는 두 가지 구성 파일이 있다. 첫 번째 파일에는
fluentd를 구성하기 위한 <a href=/docs/tasks/configure-pod-container/configure-pod-configmap/><code>ConfigMap</code></a>이 포함되어 있다.</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/ko/examples/admin/logging/fluentd-sidecar-config.yaml download=admin/logging/fluentd-sidecar-config.yaml><code>admin/logging/fluentd-sidecar-config.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('admin-logging-fluentd-sidecar-config-yaml')" title="Copy admin/logging/fluentd-sidecar-config.yaml to clipboard">
</img>
</div>
<div class=includecode id=admin-logging-fluentd-sidecar-config-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>fluentd-config<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>fluentd.conf</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span><span style=color:#b44;font-style:italic>    &lt;source&gt;
</span><span style=color:#b44;font-style:italic>      type tail
</span><span style=color:#b44;font-style:italic>      format none
</span><span style=color:#b44;font-style:italic>      path /var/log/1.log
</span><span style=color:#b44;font-style:italic>      pos_file /var/log/1.log.pos
</span><span style=color:#b44;font-style:italic>      tag count.format1
</span><span style=color:#b44;font-style:italic>    &lt;/source&gt;
</span><span style=color:#b44;font-style:italic>
</span><span style=color:#b44;font-style:italic>    &lt;source&gt;
</span><span style=color:#b44;font-style:italic>      type tail
</span><span style=color:#b44;font-style:italic>      format none
</span><span style=color:#b44;font-style:italic>      path /var/log/2.log
</span><span style=color:#b44;font-style:italic>      pos_file /var/log/2.log.pos
</span><span style=color:#b44;font-style:italic>      tag count.format2
</span><span style=color:#b44;font-style:italic>    &lt;/source&gt;
</span><span style=color:#b44;font-style:italic>
</span><span style=color:#b44;font-style:italic>    &lt;match **&gt;
</span><span style=color:#b44;font-style:italic>      type google_cloud
</span><span style=color:#b44;font-style:italic>    &lt;/match&gt;</span><span style=color:#bbb>    
</span></code></pre></div>
</div>
</div>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> fluentd를 구성하는 것에 대한 자세한 내용은, <a href=https://docs.fluentd.org/>fluentd 문서</a>를 참고한다.
</div>
<p>두 번째 파일은 fluentd가 실행되는 사이드카 컨테이너가 있는 파드를 설명한다.
파드는 fluentd가 구성 데이터를 가져올 수 있는 볼륨을 마운트한다.</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/ko/examples/admin/logging/two-files-counter-pod-agent-sidecar.yaml download=admin/logging/two-files-counter-pod-agent-sidecar.yaml><code>admin/logging/two-files-counter-pod-agent-sidecar.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('admin-logging-two-files-counter-pod-agent-sidecar-yaml')" title="Copy admin/logging/two-files-counter-pod-agent-sidecar.yaml to clipboard">
</img>
</div>
<div class=includecode id=admin-logging-two-files-counter-pod-agent-sidecar-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>counter<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>count<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- /bin/sh<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- -c<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- &gt;<span style=color:#b44;font-style:italic>
</span><span style=color:#b44;font-style:italic>      i=0;
</span><span style=color:#b44;font-style:italic>      while true;
</span><span style=color:#b44;font-style:italic>      do
</span><span style=color:#b44;font-style:italic>        echo &#34;$i: $(date)&#34; &gt;&gt; /var/log/1.log;
</span><span style=color:#b44;font-style:italic>        echo &#34;$(date) INFO $i&#34; &gt;&gt; /var/log/2.log;
</span><span style=color:#b44;font-style:italic>        i=$((i+1));
</span><span style=color:#b44;font-style:italic>        sleep 1;
</span><span style=color:#b44;font-style:italic>      done</span><span style=color:#bbb>      
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>varlog<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/var/log<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>count-agent<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/fluentd-gcp:1.30<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>FLUENTD_ARGS<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span>-c /etc/fluentd-config/fluentd.conf<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>varlog<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/var/log<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>config-volume<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/etc/fluentd-config<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>varlog<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>emptyDir</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>config-volume<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>configMap</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>fluentd-config<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>이 예시 구성에서, 사용자는 애플리케이션 컨테이너 내의 모든 소스을 읽는 fluentd를 다른 로깅 에이전트로 대체할 수 있다.</p>
<h3 id=애플리케이션에서-직접-로그-노출>애플리케이션에서 직접 로그 노출</h3>
<p><img src=/images/docs/user-guide/logging/logging-from-application.png alt="애플리케이션에서 직접 로그 노출"></p>
<p>애플리케이션에서 직접 로그를 노출하거나 푸시하는 클러스터-로깅은 쿠버네티스의 범위를 벗어난다.</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-5cc31ecfba86467f8884856412cfb6b2>11.5 - 시스템 로그</h1>
<p>시스템 컴포넌트 로그는 클러스터에서 발생하는 이벤트를 기록하며, 이는 디버깅에 아주 유용하다.
더 많거나 적은 세부 정보를 표시하도록 다양하게 로그를 설정할 수 있다.
로그는 컴포넌트 내에서 오류를 표시하는 것 처럼 간단하거나, 이벤트의 단계적 추적(예: HTTP 엑세스 로그, 파드의 상태 변경, 컨트롤러 작업 또는 스케줄러의 결정)을 표시하는 것처럼 세밀할 수 있다.</p>
<h2 id=klog>Klog</h2>
<p>klog는 쿠버네티스의 로깅 라이브러리다. <a href=https://github.com/kubernetes/klog>klog</a>는
쿠버네티스 시스템 컴포넌트의 로그 메시지를 생성한다.</p>
<p>klog 설정에 대한 더 많은 정보는, <a href=/ko/docs/reference/command-line-tools-reference/>커맨드라인 툴</a>을 참고한다.</p>
<p>쿠버네티스는 각 컴포넌트의 로깅을 간소화하는 중에 있다.
다음 klog 명령줄 플래그는 쿠버네티스 1.23에서
<a href=https://github.com/kubernetes/enhancements/tree/master/keps/sig-instrumentation/2845-deprecate-klog-specific-flags-in-k8s-components>사용 중단</a>되었으며
이후 릴리스에서 제거될 것이다.</p>
<ul>
<li><code>--add-dir-header</code></li>
<li><code>--alsologtostderr</code></li>
<li><code>--log-backtrace-at</code></li>
<li><code>--log-dir</code></li>
<li><code>--log-file</code></li>
<li><code>--log-file-max-size</code></li>
<li><code>--logtostderr</code></li>
<li><code>--one-output</code></li>
<li><code>--skip-headers</code></li>
<li><code>--skip-log-headers</code></li>
<li><code>--stderrthreshold</code></li>
</ul>
<p>출력은 출력 형식에 관계없이 항상 표준 에러(stderr)에 기록될 것이다.
출력 리다이렉션은 쿠버네티스 컴포넌트를 호출하는 컴포넌트가 담당할 것으로 기대된다.
이는 POSIX 셸 또는 systemd와 같은 도구일 수
있다.</p>
<p>배포판과 무관한(distroless) 컨테이너 또는 윈도우 시스템 서비스와 같은 몇몇 경우에서,
위의 옵션은 사용할 수 없다.
그런 경우 출력을 리다이렉트하기 위해
<a href=https://github.com/kubernetes/kubernetes/blob/d2a8a81639fcff8d1221b900f66d28361a170654/staging/src/k8s.io/component-base/logs/kube-log-runner/README.md><code>kube-log-runner</code></a>
바이너리를 쿠버네티스 컴포넌트의 래퍼(wrapper)로 사용할 수 있다.
미리 빌드된 바이너리가 몇몇 쿠버네티스 베이스 이미지에 기본 이름 <code>/go-runner</code> 와
서버 및 노드 릴리스 아카이브에는 <code>kube-log-runner</code>라는 이름으로 포함되어 있다.</p>
<p>다음 표는 각 <code>kube-log-runner</code> 실행법이 어떤 셸 리다이렉션에 해당되는지 보여준다.</p>
<table>
<thead>
<tr>
<th>사용법</th>
<th>POSIX 셸 (예:) bash)</th>
<th><code>kube-log-runner &lt;options> &lt;cmd></code></th>
</tr>
</thead>
<tbody>
<tr>
<td>stderr와 stdout을 합치고, stdout으로 출력</td>
<td><code>2>&1</code></td>
<td><code>kube-log-runner</code> (기본 동작))</td>
</tr>
<tr>
<td>stderr와 stdout을 로그 파일에 기록</td>
<td><code>1>>/tmp/log 2>&1</code></td>
<td><code>kube-log-runner -log-file=/tmp/log</code></td>
</tr>
<tr>
<td>로그 파일에 기록하면서 stdout으로 출력</td>
<td><code>2>&1 | tee -a /tmp/log</code></td>
<td><code>kube-log-runner -log-file=/tmp/log -also-stdout</code></td>
</tr>
<tr>
<td>stdout만 로그 파일에 기록</td>
<td><code>>/tmp/log</code></td>
<td><code>kube-log-runner -log-file=/tmp/log -redirect-stderr=false</code></td>
</tr>
</tbody>
</table>
<h3 id=klog-출력>Klog 출력</h3>
<p>klog 네이티브 형식 예 :</p>
<pre><code>I1025 00:15:15.525108       1 httplog.go:79] GET /api/v1/namespaces/kube-system/pods/metrics-server-v0.3.1-57c75779f-9p8wg: (1.512ms) 200 [pod_nanny/v0.0.0 (linux/amd64) kubernetes/$Format 10.56.1.19:51756]
</code></pre><p>메시지 문자열은 줄바꿈을 포함하고 있을 수도 있다.</p>
<pre><code>I1025 00:15:15.525108       1 example.go:79] This is a message
which has a line break.
</code></pre><h3 id=구조화된-로깅>구조화된 로깅</h3>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.23 [beta]</code>
</div>
<div class="alert alert-danger warning callout" role=alert>
<strong>경고:</strong> <p>구조화된 로그메시지로 마이그레이션은 진행중인 작업이다. 이 버전에서는 모든 로그 메시지가 구조화되지 않는다. 로그 파일을 파싱할 때, 구조화되지 않은 로그 메시지도 처리해야 한다.</p>
<p>로그 형식 및 값 직렬화는 변경될 수 있다.</p>
</div>
<p>구조화된 로깅은 로그 메시지에 통일된 구조를 적용하여 정보를 쉽게 추출하고,
로그를 보다 쉽고 저렴하게 저장하고 처리하는 작업이다.
새로운 메시지 형식은 이전 버전과 호환되며 기본적으로 활성화 된다.</p>
<p>구조화된 로그 메시지의 기본 형식은 텍스트이며,
기존 klog와 하위 호환되는 형식이다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ini data-lang=ini><span style=color:#b44>&lt;klog header&gt; &#34;&lt;message&gt;&#34; &lt;key1&gt;</span><span style=color:#666>=</span><span style=color:#b44>&#34;&lt;value1&gt;&#34; &lt;key2&gt;=&#34;&lt;value2&gt;&#34; ...</span>
</code></pre></div><p>예시:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ini data-lang=ini><span style=color:#b44>I1025 00:15:15.525108       1 controller_utils.go:116] &#34;Pod status updated&#34; pod</span><span style=color:#666>=</span><span style=color:#b44>&#34;kube-system/kubedns&#34; status=&#34;ready&#34;</span>
</code></pre></div><p>문자열은 따옴표로 감싸진다. 다른 값들은
<a href=https://pkg.go.dev/fmt#hdr-Printing><code>%+v</code></a>로 포맷팅되며, 이로 인해
<a href=https://github.com/kubernetes/kubernetes/issues/106428>데이터에 따라</a> 로그 메시지가 다음 줄로 이어질 수 있다.</p>
<pre><code>I1025 00:15:15.525108       1 example.go:116] &quot;Example&quot; data=&quot;This is text with a line break\nand \&quot;quotation marks\&quot;.&quot; someInt=1 someFloat=0.1 someStruct={StringField: First line,
second line.}
</code></pre><h3 id=json-로그-형식>JSON 로그 형식</h3>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.19 [alpha]</code>
</div>
<div class="alert alert-danger warning callout" role=alert>
<strong>경고:</strong> <p>JSON 출력은 많은 표준 klog 플래그를 지원하지 않는다. 지원하지 않는 klog 플래그 목록은, <a href=/ko/docs/reference/command-line-tools-reference/>커맨드라인 툴</a>을 참고한다.</p>
<p>모든 로그가 JSON 형식으로 작성되는 것은 아니다(예: 프로세스 시작 중). 로그를 파싱하려는 경우 JSON 형식이 아닌 로그 행을 처리할 수 있는지 확인해야 한다.</p>
<p>필드 이름과 JSON 직렬화는 변경될 수 있다.</p>
</div>
<p><code>--logging-format=json</code> 플래그는 로그 형식을 klog 기본 형식에서 JSON 형식으로 변경한다.
JSON 로그 형식 예시(보기좋게 출력된 형태)는 다음과 같다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
   <span style=color:green;font-weight:700>&#34;ts&#34;</span>: <span style=color:#666>1580306777.04728</span>,
   <span style=color:green;font-weight:700>&#34;v&#34;</span>: <span style=color:#666>4</span>,
   <span style=color:green;font-weight:700>&#34;msg&#34;</span>: <span style=color:#b44>&#34;Pod status updated&#34;</span>,
   <span style=color:green;font-weight:700>&#34;pod&#34;</span>:{
      <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;nginx-1&#34;</span>,
      <span style=color:green;font-weight:700>&#34;namespace&#34;</span>: <span style=color:#b44>&#34;default&#34;</span>
   },
   <span style=color:green;font-weight:700>&#34;status&#34;</span>: <span style=color:#b44>&#34;ready&#34;</span>
}
</code></pre></div><p>특별한 의미가 있는 키:</p>
<ul>
<li><code>ts</code> - Unix 시간의 타임스탬프 (필수, 부동 소수점)</li>
<li><code>v</code> - 자세한 정도 (필수, 정수, 기본 값 0)</li>
<li><code>err</code> - 오류 문자열 (선택 사항, 문자열)</li>
<li><code>msg</code> - 메시지 (필수, 문자열)</li>
</ul>
<p>현재 JSON 형식을 지원하는 컴포넌트 목록:</p>
<ul>
<li><a class=glossary-tooltip title="컨트롤러 프로세스를 실행하는 컨트롤 플레인 컴포넌트." data-toggle=tooltip data-placement=top href=/docs/reference/command-line-tools-reference/kube-controller-manager/ target=_blank aria-label=kube-controller-manager>kube-controller-manager</a></li>
<li><a class=glossary-tooltip title="쿠버네티스 API를 제공하는 컨트롤 플레인 컴포넌트." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/overview/components/#kube-apiserver target=_blank aria-label=kube-apiserver>kube-apiserver</a></li>
<li><a class=glossary-tooltip title="노드가 배정되지 않은 새로 생성된 파드를 감지하고, 실행할 노드를 선택하는 컨트롤 플레인 컴포넌트." data-toggle=tooltip data-placement=top href=/docs/reference/command-line-tools-reference/kube-scheduler/ target=_blank aria-label=kube-scheduler>kube-scheduler</a></li>
<li><a class=glossary-tooltip title="클러스터의 각 노드에서 실행되는 에이전트. Kubelet은 파드에서 컨테이너가 확실하게 동작하도록 관리한다." data-toggle=tooltip data-placement=top href=/docs/reference/generated/kubelet target=_blank aria-label=kubelet>kubelet</a></li>
</ul>
<h3 id=로그-정리-sanitization>로그 정리(sanitization)</h3>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.20 [alpha]</code>
</div>
<div class="alert alert-danger warning callout" role=alert>
<strong>경고:</strong> 로그 정리(sanitization)는 상당한 오버 헤드를 발생시킬 수 있으므로 프로덕션 환경에서는 사용하지 않아야한다.
</div>
<p><code>--experimental-logging-sanitization</code> 플래그는 klog 정리(sanitization) 필터를 활성화한다.
활성화된 경우 모든 로그 인자에서 민감한 데이터(예: 비밀번호, 키, 토큰)가 표시된 필드를 검사하고 이러한 필드의 로깅이 방지된다.</p>
<p>현재 로그 정리(sanitization)를 지원하는 컴포넌트 목록:</p>
<ul>
<li>kube-controller-manager</li>
<li>kube-apiserver</li>
<li>kube-scheduler</li>
<li>kubelet</li>
</ul>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> 로그 정리(sanitization) 필터는 사용자 작업 로그로부터 민감한 데이터가 유출되는 것을 방지할 수 없다.
</div>
<h3 id=로그-상세-레벨-verbosity>로그 상세 레벨(verbosity)</h3>
<p><code>-v</code> 플래그로 로그 상세 레벨(verbosity)을 제어한다. 값을 늘리면 기록된 이벤트 수가 증가한다. 값을 줄이면 기록된 이벤트 수가 줄어든다.
로그 상세 레벨(verbosity)를 높이면 점점 덜 심각한 이벤트가 기록된다. 로그 상세 레벨(verbosity)을 0으로 설정하면 중요한 이벤트만 기록된다.</p>
<h3 id=로그-위치>로그 위치</h3>
<p>시스템 컴포넌트에는 컨테이너에서 실행되는 것과 컨테이너에서 실행되지 않는 두 가지 유형이 있다.
예를 들면 다음과 같다.</p>
<ul>
<li>쿠버네티스 스케줄러와 kube-proxy는 컨테이너에서 실행된다.</li>
<li>kubelet과 <a class=glossary-tooltip title="컨테이너 런타임은 컨테이너 실행을 담당하는 소프트웨어이다." data-toggle=tooltip data-placement=top href=/ko/docs/setup/production-environment/container-runtimes/ target=_blank aria-label="컨테이너 런타임">컨테이너 런타임</a>은
컨테이너에서 실행되지 않는다.</li>
</ul>
<p>systemd를 사용하는 시스템에서는, kubelet과 컨테이너 런타임은 jounald에 기록한다.
그 외 시스템에서는, <code>/var/log</code> 디렉터리의 <code>.log</code> 파일에 기록한다.
컨테이너 내부의 시스템 컴포넌트들은 기본 로깅 메커니즘을 무시하고,
항상 <code>/var/log</code> 디렉터리의 <code>.log</code> 파일에 기록한다.
컨테이너 로그와 마찬가지로, <code>/var/log</code> 디렉터리의 시스템 컴포넌트 로그들은 로테이트해야 한다.
<code>kube-up.sh</code> 스크립트로 생성된 쿠버네티스 클러스터에서는, <code>logrotate</code> 도구로 로그가 로테이트되도록 설정된다.
<code>logrotate</code> 도구는 로그가 매일 또는 크기가 100MB 보다 클 때 로테이트된다.</p>
<h2 id=다음-내용>다음 내용</h2>
<ul>
<li><a href=/ko/docs/concepts/cluster-administration/logging/>쿠버네티스 로깅 아키텍처</a> 알아보기</li>
<li><a href=https://github.com/kubernetes/enhancements/tree/master/keps/sig-instrumentation/1602-structured-logging>구조화된 로깅</a> 알아보기</li>
<li><a href=https://github.com/kubernetes/enhancements/tree/master/keps/sig-instrumentation/2845-deprecate-klog-specific-flags-in-k8s-components>klog 플래그 사용 중단</a> 알아보기</li>
<li><a href=https://github.com/kubernetes/community/blob/master/contributors/devel/sig-instrumentation/logging.md>로깅 심각도(serverity) 규칙</a> 알아보기</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-cbfd3654996eae9fcdef009f70fa83f0>11.6 - 쿠버네티스 시스템 컴포넌트에 대한 메트릭</h1>
<p>시스템 컴포넌트 메트릭으로 내부에서 발생하는 상황을 더 잘 파악할 수 있다. 메트릭은 대시보드와 경고를 만드는 데 특히 유용하다.</p>
<p>쿠버네티스 컴포넌트의 메트릭은 <a href=https://prometheus.io/docs/instrumenting/exposition_formats/>프로메테우스 형식</a>으로 출력된다.
이 형식은 구조화된 평문으로 디자인되어 있으므로 사람과 기계 모두가 쉽게 읽을 수 있다.</p>
<h2 id=쿠버네티스의-메트릭>쿠버네티스의 메트릭</h2>
<p>대부분의 경우 메트릭은 HTTP 서버의 <code>/metrics</code> 엔드포인트에서 사용할 수 있다. 기본적으로 엔드포인트를 노출하지 않는 컴포넌트의 경우 <code>--bind-address</code> 플래그를 사용하여 활성화할 수 있다.</p>
<p>해당 컴포넌트의 예는 다음과 같다.</p>
<ul>
<li><a class=glossary-tooltip title="컨트롤러 프로세스를 실행하는 컨트롤 플레인 컴포넌트." data-toggle=tooltip data-placement=top href=/docs/reference/command-line-tools-reference/kube-controller-manager/ target=_blank aria-label=kube-controller-manager>kube-controller-manager</a></li>
<li><a class=glossary-tooltip title="kube-proxy는 클러스터의 각 노드에서 실행되는 네트워크 프록시이다." data-toggle=tooltip data-placement=top href=/ko/docs/reference/command-line-tools-reference/kube-proxy/ target=_blank aria-label=kube-proxy>kube-proxy</a></li>
<li><a class=glossary-tooltip title="쿠버네티스 API를 제공하는 컨트롤 플레인 컴포넌트." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/overview/components/#kube-apiserver target=_blank aria-label=kube-apiserver>kube-apiserver</a></li>
<li><a class=glossary-tooltip title="노드가 배정되지 않은 새로 생성된 파드를 감지하고, 실행할 노드를 선택하는 컨트롤 플레인 컴포넌트." data-toggle=tooltip data-placement=top href=/docs/reference/command-line-tools-reference/kube-scheduler/ target=_blank aria-label=kube-scheduler>kube-scheduler</a></li>
<li><a class=glossary-tooltip title="클러스터의 각 노드에서 실행되는 에이전트. Kubelet은 파드에서 컨테이너가 확실하게 동작하도록 관리한다." data-toggle=tooltip data-placement=top href=/docs/reference/generated/kubelet target=_blank aria-label=kubelet>kubelet</a></li>
</ul>
<p>프로덕션 환경에서는 이러한 메트릭을 주기적으로 수집하고 시계열 데이터베이스에서 사용할 수 있도록
<a href=https://prometheus.io/>프로메테우스 서버</a> 또는 다른 메트릭 수집기(scraper)를 구성할 수 있다.</p>
<p>참고로 <a class=glossary-tooltip title="클러스터의 각 노드에서 실행되는 에이전트. Kubelet은 파드에서 컨테이너가 확실하게 동작하도록 관리한다." data-toggle=tooltip data-placement=top href=/docs/reference/generated/kubelet target=_blank aria-label=kubelet>kubelet</a>도 <code>/metrics/cadvisor</code>, <code>/metrics/resource</code> 그리고 <code>/metrics/probes</code> 엔드포인트에서 메트릭을 노출한다. 이러한 메트릭은 동일한 라이프사이클을 가지지 않는다.</p>
<p>클러스터가 <a class=glossary-tooltip title="인가 결정을 관리하며, 운영자가 쿠버네티스 API를 통해서 동적으로 엑세스 정책을 설정하게 한다." data-toggle=tooltip data-placement=top href=/docs/reference/access-authn-authz/rbac/ target=_blank aria-label=RBAC>RBAC</a>을 사용하는 경우, 메트릭을 읽으려면 <code>/metrics</code> 에 접근을 허용하는 클러스터롤(ClusterRole)을 가지는 사용자, 그룹 또는 서비스어카운트(ServiceAccount)를 통한 권한이 필요하다.
예를 들면, 다음과 같다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>prometheus<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>nonResourceURLs</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:#b44>&#34;/metrics&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- get<span style=color:#bbb>
</span></code></pre></div><h2 id=메트릭-라이프사이클>메트릭 라이프사이클</h2>
<p>알파(Alpha) 메트릭 → 안정적인(Stable) 메트릭 → 사용 중단된(Deprecated) 메트릭 → 히든(Hidden) 메트릭 → 삭제된(Deleted) 메트릭</p>
<p>알파 메트릭은 안정성을 보장하지 않는다. 따라서 언제든지 수정되거나 삭제될 수 있다.</p>
<p>안정적인 메트릭은 변경되지 않는다는 것을 보장한다. 이것은 다음을 의미한다.</p>
<ul>
<li>사용 중단 표기가 없는 안정적인 메트릭은, 이름이 변경되거나 삭제되지 않는다.</li>
<li>안정적인 메트릭의 유형(type)은 수정되지 않는다.</li>
</ul>
<p>사용 중단된 메트릭은 해당 메트릭이 결국 삭제된다는 것을 나타내지만, 아직은 사용 가능하다는 뜻이다.
이 메트릭은 어느 버전에서부터 사용 중단된 것인지를 표시하는 어노테이션을 포함한다.</p>
<p>예를 들면,</p>
<ul>
<li>사용 중단 이전에는 다음과 같다.</li>
</ul>
<pre><code># HELP some_counter this counts things
# TYPE some_counter counter
some_counter 0
</code></pre><ul>
<li>사용 중단 이후에는 다음과 같다.</li>
</ul>
<pre><code># HELP some_counter (Deprecated since 1.15.0) this counts things
# TYPE some_counter counter
some_counter 0
</code></pre><p>히든 메트릭은 깔끔함(scraping)을 위해 더 이상 게시되지는 않지만, 여전히 사용은 가능하다. 히든 메트릭을 사용하려면, <a href=#%ED%9E%88%EB%93%A0-%EB%A9%94%ED%8A%B8%EB%A6%AD-%ED%91%9C%EC%8B%9C>히든 메트릭 표시</a> 섹션을 참고한다.</p>
<p>삭제된 메트릭은 더 이상 게시되거나 사용할 수 없다.</p>
<h2 id=히든-메트릭-표시>히든 메트릭 표시</h2>
<p>위에서 설명한 것처럼, 관리자는 특정 바이너리의 커맨드 라인 플래그를 통해 히든 메트릭을 활성화할 수 있다. 관리자가 지난 릴리스에서 사용 중단된 메트릭의 마이그레이션을 놓친 경우 관리자를 위한 임시방편으로 사용된다.</p>
<p><code>show-hidden-metrics-for-version</code> 플래그는 해당 릴리스에서 사용 중단된 메트릭을 보여주려는 버전을 사용한다. 버전은 xy로 표시되며, 여기서 x는 메이저(major) 버전이고, y는 마이너(minor) 버전이다. 패치 릴리스에서 메트릭이 사용 중단될 수 있지만, 패치 버전은 필요하지 않다. 그 이유는 메트릭 사용 중단 정책이 마이너 릴리스에 대해 실행되기 때문이다.</p>
<p>플래그는 그 값으로 이전의 마이너 버전만 사용할 수 있다. 관리자가 이전 버전을 <code>show-hidden-metrics-for-version</code> 에 설정하면 이전 버전의 모든 히든 메트릭이 생성된다. 사용 중단 메트릭 정책을 위반하기 때문에 너무 오래된 버전은 허용되지 않는다.</p>
<p>1.n 버전에서 사용 중단되었다고 가정한 메트릭 <code>A</code> 를 예로 들어보겠다. 메트릭 사용 중단 정책에 따르면, 다음과 같은 결론에 도달할 수 있다.</p>
<ul>
<li><code>1.n</code> 릴리스에서는 메트릭이 사용 중단되었으며, 기본적으로 생성될 수 있다.</li>
<li><code>1.n+1</code> 릴리스에서는 기본적으로 메트릭이 숨겨져 있으며, <code>show-hidden-metrics-for-version=1.n</code> 커맨드 라인에 의해서 생성될 수 있다.</li>
<li><code>1.n+2</code> 릴리스에서는 코드베이스에서 메트릭이 제거되어야 한다. 더이상 임시방편은 존재하지 않는다.</li>
</ul>
<p>릴리스 <code>1.12</code> 에서 <code>1.13</code> 으로 업그레이드 중이지만, <code>1.12</code> 에서 사용 중단된 메트릭 <code>A</code> 를 사용하고 있다면, 커맨드 라인에서 <code>--show-hidden-metrics=1.12</code> 플래그로 히든 메트릭을 설정해야 하고, <code>1.14</code> 로 업그레이드하기 전에 이 메트릭을 사용하지 않도록 의존성을 제거하는 것을 기억해야 한다.</p>
<h2 id=액셀러레이터-메트릭-비활성화>액셀러레이터 메트릭 비활성화</h2>
<p>kubelet은 cAdvisor를 통해 액셀러레이터 메트릭을 수집한다. NVIDIA GPU와 같은 액셀러레이터의 경우, 이러한 메트릭을 수집하기 위해 kubelet은 드라이버에 열린 핸들을 가진다. 이는 인프라 변경(예: 드라이버 업데이트)을 수행하기 위해 클러스터 관리자가 kubelet 에이전트를 중지해야 함을 의미한다.</p>
<p>액셀러레이터 메트릭을 수집하는 책임은 이제 kubelet이 아닌 공급 업체에 있다. 공급 업체는 메트릭을 수집하여 메트릭 서비스(예: 프로메테우스)에 노출할 컨테이너를 제공해야 한다.</p>
<p>[<code>DisableAcceleratorUsageMetrics</code> 기능 게이트](/ko/docs/reference/command-line-tools-reference/feature-gates/#알파-또는-베타-기능을-위한-기능-게이트:~:text= DisableAcceleratorUsageMetrics,-false)는 <a href=https://github.com/kubernetes/enhancements/tree/411e51027db842355bd489691af897afc1a41a5e/keps/sig-node/1867-disable-accelerator-usage-metrics#graduation-criteria>이 기능을 기본적으로 사용하도록 설정하는 타임라인</a>를 사용하여 kubelet에서 수집한 메트릭을 비활성화한다.</p>
<h2 id=컴포넌트-메트릭>컴포넌트 메트릭</h2>
<h3 id=kube-controller-manager-메트릭>kube-controller-manager 메트릭</h3>
<p>컨트롤러 관리자 메트릭은 컨트롤러 관리자의 성능과 상태에 대한 중요한 인사이트를 제공한다.
이러한 메트릭에는 go_routine 수와 같은 일반적인 Go 언어 런타임 메트릭과
etcd 요청 대기 시간 또는 Cloudprovider(AWS, GCE, OpenStack) API 대기 시간과 같은 컨트롤러 특정 메트릭이 포함되어
클러스터의 상태를 측정하는 데 사용할 수 있다.</p>
<p>쿠버네티스 1.7부터 GCE, AWS, Vsphere 및 OpenStack의 스토리지 운영에 대한 상세한 Cloudprovider 메트릭을 사용할 수 있다.
이 메트릭은 퍼시스턴트 볼륨 동작의 상태를 모니터링하는 데 사용할 수 있다.</p>
<p>예를 들어, GCE의 경우 이러한 메트릭을 다음과 같이 호출한다.</p>
<pre><code>cloudprovider_gce_api_request_duration_seconds { request = &quot;instance_list&quot;}
cloudprovider_gce_api_request_duration_seconds { request = &quot;disk_insert&quot;}
cloudprovider_gce_api_request_duration_seconds { request = &quot;disk_delete&quot;}
cloudprovider_gce_api_request_duration_seconds { request = &quot;attach_disk&quot;}
cloudprovider_gce_api_request_duration_seconds { request = &quot;detach_disk&quot;}
cloudprovider_gce_api_request_duration_seconds { request = &quot;list_disk&quot;}
</code></pre><h3 id=kube-scheduler-메트릭>kube-scheduler 메트릭</h3>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.21 [beta]</code>
</div>
<p>스케줄러는 실행 중인 모든 파드의 요청(request)된 리소스와 요구되는 제한(limit)을 보고하는 선택적 메트릭을 노출한다. 이러한 메트릭은 용량 계획(capacity planning) 대시보드를 구축하고, 현재 또는 과거 스케줄링 제한을 평가하고, 리소스 부족으로 스케줄할 수 없는 워크로드를 빠르게 식별하고, 실제 사용량을 파드의 요청과 비교하는 데 사용할 수 있다.</p>
<p>kube-scheduler는 각 파드에 대해 구성된 리소스 <a href=/ko/docs/concepts/configuration/manage-resources-containers/>요청과 제한</a>을 식별한다. 요청 또는 제한이 0이 아닌 경우 kube-scheduler는 메트릭 시계열을 보고한다. 시계열에는 다음과 같은 레이블이 지정된다.</p>
<ul>
<li>네임스페이스</li>
<li>파드 이름</li>
<li>파드가 스케줄된 노드 또는 아직 스케줄되지 않은 경우 빈 문자열</li>
<li>우선순위</li>
<li>해당 파드에 할당된 스케줄러</li>
<li>리소스 이름 (예: <code>cpu</code>)</li>
<li>알려진 경우 리소스 단위 (예: <code>cores</code>)</li>
</ul>
<p>파드가 완료되면 (<code>Never</code> 또는 <code>OnFailure</code>의 <code>restartPolicy</code>가 있고 <code>Succeeded</code> 또는 <code>Failed</code> 파드 단계에 있거나, 삭제되고 모든 컨테이너가 종료된 상태에 있음) 스케줄러가 이제 다른 파드를 실행하도록 스케줄할 수 있으므로 시리즈가 더 이상 보고되지 않는다. 두 메트릭을 <code>kube_pod_resource_request</code> 및 <code>kube_pod_resource_limit</code> 라고 한다.</p>
<p>메트릭은 HTTP 엔드포인트 <code>/metrics/resources</code>에 노출되며 스케줄러의 <code>/metrics</code> 엔드포인트
와 동일한 인증이 필요하다. 이러한 알파 수준의 메트릭을 노출시키려면 <code>--show-hidden-metrics-for-version=1.20</code> 플래그를 사용해야 한다.</p>
<h2 id=메트릭-비활성화>메트릭 비활성화</h2>
<p>커맨드 라인 플래그 <code>--disabled-metrics</code> 를 통해 메트릭을 명시적으로 끌 수 있다. 이 방법이 필요한 이유는 메트릭이 성능 문제를 일으키는 경우을 예로 들 수 있다. 입력값은 비활성화되는 메트릭 목록이다(예: <code>--disabled-metrics=metric1,metric2</code>).</p>
<h2 id=메트릭-카디널리티-cardinality-적용>메트릭 카디널리티(cardinality) 적용</h2>
<p>제한되지 않은 차원의 메트릭은 계측하는 컴포넌트에서 메모리 문제를 일으킬 수 있다. 리소스 사용을 제한하려면, <code>--allow-label-value</code> 커맨드 라인 옵션을 사용하여 메트릭 항목에 대한 레이블 값의 허용 목록(allow-list)을 동적으로 구성한다.</p>
<p>알파 단계에서, 플래그는 메트릭 레이블 허용 목록으로 일련의 매핑만 가져올 수 있다.
각 매핑은 <code>&lt;metric_name>,&lt;label_name>=&lt;allowed_labels></code> 형식이다. 여기서
<code>&lt;allowed_labels></code> 는 허용되는 레이블 이름의 쉼표로 구분된 목록이다.</p>
<p>전체 형식은 다음과 같다.
<code>--allow-label-value &lt;metric_name>,&lt;label_name>='&lt;allow_value1>, &lt;allow_value2>...', &lt;metric_name2>,&lt;label_name>='&lt;allow_value1>, &lt;allow_value2>...', ...</code>.</p>
<p>예시는 다음과 같다.
<code>--allow-label-value number_count_metric,odd_number='1,3,5', number_count_metric,even_number='2,4,6', date_gauge_metric,weekend='Saturday,Sunday'</code></p>
<h2 id=다음-내용>다음 내용</h2>
<ul>
<li>메트릭에 대한 <a href=https://github.com/prometheus/docs/blob/master/content/docs/instrumenting/exposition_formats.md#text-based-format>프로메테우스 텍스트 형식</a>에 대해 읽어본다</li>
<li><a href=https://github.com/kubernetes/kubernetes/blob/master/test/instrumentation/testdata/stable-metrics-list.yaml>안정 버전의 쿠버네티스 메트릭</a> 목록을 살펴본다</li>
<li><a href=/docs/reference/using-api/deprecation-policy/#deprecating-a-feature-or-behavior>쿠버네티스 사용 중단 정책</a>에 대해 읽어본다</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-08e94e6a480e0d6b2de72d84a1b97617>11.7 - 쿠버네티스에서 프락시(Proxy)</h1>
<p>이 페이지는 쿠버네티스에서 함께 사용되는 프락시(Proxy)를 설명한다.</p>
<h2 id=프락시>프락시</h2>
<p>쿠버네티스를 이용할 때에 사용할 수 있는 여러 프락시가 있다.</p>
<ol>
<li>
<p><a href=/ko/docs/tasks/access-application-cluster/access-cluster/#rest-api%EC%97%90-%EC%A7%81%EC%A0%91-%EC%95%A1%EC%84%B8%EC%8A%A4>kubectl proxy</a>:</p>
<ul>
<li>사용자의 데스크탑이나 파드 안에서 실행한다.</li>
<li>로컬 호스트 주소에서 쿠버네티스의 API 서버로 프락시한다.</li>
<li>클라이언트로 프락시는 HTTP를 사용한다.</li>
<li>API 서버로 프락시는 HTTPS를 사용한다.</li>
<li>API 서버를 찾는다.</li>
<li>인증 헤더를 추가한다.</li>
</ul>
</li>
<li>
<p><a href=/ko/docs/tasks/access-application-cluster/access-cluster/#%EB%B9%8C%ED%8A%B8%EC%9D%B8-%EC%84%9C%EB%B9%84%EC%8A%A4%EB%93%A4%EC%9D%98-%EB%B0%9C%EA%B2%AC>apiserver proxy</a>:</p>
<ul>
<li>API 서버에 내장된 요새(bastion)이다.</li>
<li>클러스터 외부의 사용자가 도달할 수 없는 클러스터 IP 주소로 연결한다.</li>
<li>API 서버 프로세스에서 실행한다.</li>
<li>클라이언트로 프락시는 HTTPS(또는 API서버에서 HTTP로 구성된 경우는 HTTP)를 사용한다.</li>
<li>사용 가능한 정보를 이용하여 프락시에 의해 선택한 HTTP나 HTTPS를 사용할 수 있는 대상이다.</li>
<li>노드, 파드, 서비스에 도달하는데 사용할 수 있다.</li>
<li>서비스에 도달할 때에는 로드 밸런싱을 수행한다.</li>
</ul>
</li>
<li>
<p><a href=/ko/docs/concepts/services-networking/service/#ips-and-vips>kube proxy</a>:</p>
<ul>
<li>각 노드에서 실행한다.</li>
<li>UDP, TCP, SCTP를 이용하여 프락시 한다.</li>
<li>HTTP는 이해하지 못한다.</li>
<li>로드 밸런싱을 제공한다.</li>
<li>서비스에 도달하는데만 사용한다.</li>
</ul>
</li>
<li>
<p>API 서버 앞단의 프락시/로드밸런서</p>
<ul>
<li>존재 및 구현은 클러스터 마다 다르다. (예: nginx)</li>
<li>모든 클라이언트와 하나 이상의 API 서버에 위치한다.</li>
<li>여러 API 서버가 있는 경우 로드 밸런서로서 작동한다.</li>
</ul>
</li>
<li>
<p>외부 서비스의 클라우드 로드 밸런서</p>
<ul>
<li>일부 클라우드 제공자는 제공한다. (예: AWS ELB, 구글 클라우드 로드 밸런서)</li>
<li>쿠버네티스 서비스로 <code>LoadBalancer</code> 유형이 있으면 자동으로 생성된다.</li>
<li>일반적으로 UDP/TCP만 지원한다.</li>
<li>SCTP 지원은 클라우드 제공자의 구현에 달려 있다.</li>
<li>구현은 클라우드 제공자에 따라 다양하다.</li>
</ul>
</li>
</ol>
<p>쿠버네티스 사용자는 보통 처음 두 가지 유형 외의 것은 걱정할 필요없다.
클러스터 관리자는 일반적으로 후자의 유형이 올바르게 구성되었는지 확인한다.</p>
<h2 id=요청을-리다이렉트하기>요청을 리다이렉트하기</h2>
<p>프락시는 리다이렉트 기능을 대체했다. 리다이렉트는 더 이상 사용하지 않는다.</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-85d633ae590aa20ec024f1b7af1d74fc>11.8 - 애드온 설치</h1>
<div class="alert alert-secondary callout third-party-content" role=alert><strong>참고:</strong>
이 섹션은 쿠버네티스에 필요한 기능을 제공하는 써드파티 프로젝트와 관련이 있다. 쿠버네티스 프로젝트 작성자는 써드파티 프로젝트에 책임이 없다. 이 페이지는 <a href=https://github.com/cncf/foundation/blob/master/website-guidelines.md target=_blank>CNCF 웹사이트 가이드라인</a>에 따라 프로젝트를 알파벳 순으로 나열한다. 이 목록에 프로젝트를 추가하려면 변경사항을 제출하기 전에 <a href=/contribute/style/content-guide/#third-party-content>콘텐츠 가이드</a>를 읽어본다.</div>
<p>애드온은 쿠버네티스의 기능을 확장한다.</p>
<p>이 페이지는 사용 가능한 일부 애드온과 관련 설치 지침 링크를 나열한다.</p>
<h2 id=네트워킹과-네트워크-폴리시>네트워킹과 네트워크 폴리시</h2>
<ul>
<li><a href=https://www.github.com/noironetworks/aci-containers>ACI</a>는 Cisco ACI로 통합 컨테이너 네트워킹 및 네트워크 보안을 제공한다.</li>
<li><a href=https://antrea.io/>Antrea</a>는 레이어 3/4에서 작동하여 쿠버네티스를 위한 네트워킹 및 보안 서비스를 제공하며, Open vSwitch를 네트워킹 데이터 플레인으로 활용한다.</li>
<li><a href=https://docs.projectcalico.org/latest/introduction/>Calico</a>는 네트워킹 및 네트워크 폴리시 제공자이다. Calico는 유연한 네트워킹 옵션을 지원하므로 BGP 유무에 관계없이 비-오버레이 및 오버레이 네트워크를 포함하여 가장 상황에 맞는 옵션을 선택할 수 있다. Calico는 동일한 엔진을 사용하여 서비스 메시 계층(service mesh layer)에서 호스트, 파드 및 (이스티오(istio)와 Envoy를 사용하는 경우) 애플리케이션에 대한 네트워크 폴리시를 적용한다.</li>
<li><a href=https://github.com/tigera/canal/tree/master/k8s-install>Canal</a>은 Flannel과 Calico를 통합하여 네트워킹 및 네트워크 폴리시를 제공한다.</li>
<li><a href=https://github.com/cilium/cilium>Cilium</a>은 L3 네트워크 및 네트워크 폴리시 플러그인으로 HTTP/API/L7 폴리시를 투명하게 시행할 수 있다. 라우팅 및 오버레이/캡슐화 모드를 모두 지원하며, 다른 CNI 플러그인 위에서 작동할 수 있다.</li>
<li><a href=https://github.com/Huawei-PaaS/CNI-Genie>CNI-Genie</a>를 사용하면 쿠버네티스는 Calico, Canal, Flannel, Romana 또는 Weave와 같은 CNI 플러그인을 완벽하게 연결할 수 있다.</li>
<li><a href=https://contivpp.io/>Contiv</a>는 다양한 유스케이스와 풍부한 폴리시 프레임워크를 위해 구성 가능한 네트워킹(BGP를 사용하는 네이티브 L3, vxlan을 사용하는 오버레이, 클래식 L2 그리고 Cisco-SDN/ACI)을 제공한다. Contiv 프로젝트는 완전히 <a href=https://github.com/contiv>오픈소스</a>이다. <a href=https://github.com/contiv/install>인스톨러</a>는 kubeadm을 이용하거나, 그렇지 않은 경우에 대해서도 설치 옵션을 모두 제공한다.</li>
<li><a href=https://www.juniper.net/us/en/products-services/sdn/contrail/contrail-networking/>Contrail</a>은 <a href=https://tungsten.io>Tungsten Fabric</a>을 기반으로 하며, 오픈소스이고, 멀티 클라우드 네트워크 가상화 및 폴리시 관리 플랫폼이다. Contrail과 Tungsten Fabric은 쿠버네티스, OpenShift, OpenStack 및 Mesos와 같은 오케스트레이션 시스템과 통합되어 있으며, 가상 머신, 컨테이너/파드 및 베어 메탈 워크로드에 대한 격리 모드를 제공한다.</li>
<li><a href=https://github.com/flannel-io/flannel#deploying-flannel-manually>Flannel</a>은 쿠버네티스와 함께 사용할 수 있는 오버레이 네트워크 제공자이다.</li>
<li><a href=https://github.com/ZTE/Knitter/>Knitter</a>는 쿠버네티스 파드에서 여러 네트워크 인터페이스를 지원하는 플러그인이다.</li>
<li>Multus는 쿠버네티스의 다중 네트워크 지원을 위한 멀티 플러그인이며, 모든 CNI 플러그인(예: Calico, Cilium, Contiv, Flannel)과 쿠버네티스 상의 SRIOV, DPDK, OVS-DPDK 및 VPP 기반 워크로드를 지원한다.</li>
<li><a href=https://github.com/ovn-org/ovn-kubernetes/>OVN-Kubernetes</a>는 Open vSwitch(OVS) 프로젝트에서 나온 가상 네트워킹 구현인 <a href=https://github.com/ovn-org/ovn/>OVN(Open Virtual Network)</a>을 기반으로 하는 쿠버네티스용 네트워킹 제공자이다. OVN-Kubernetes는 OVS 기반 로드 밸런싱과 네트워크 폴리시 구현을 포함하여 쿠버네티스용 오버레이 기반 네트워킹 구현을 제공한다.</li>
<li><a href=https://github.com/opnfv/ovn4nfv-k8s-plugin>OVN4NFV-K8S-Plugin</a>은 OVN 기반의 CNI 컨트롤러 플러그인으로 클라우드 네이티브 기반 서비스 기능 체인(Service function chaining(SFC)), 다중 OVN 오버레이 네트워킹, 동적 서브넷 생성, 동적 가상 네트워크 생성, VLAN 공급자 네트워크, 직접 공급자 네트워크와 멀티 클러스터 네트워킹의 엣지 기반 클라우드 등 네이티브 워크로드에 이상적인 멀티 네티워크 플러그인이다.</li>
<li><a href=https://docs.vmware.com/en/VMware-NSX-T/2.0/nsxt_20_ncp_kubernetes.pdf>NSX-T</a> 컨테이너 플러그인(NCP)은 VMware NSX-T와 쿠버네티스와 같은 컨테이너 오케스트레이터 간의 통합은 물론 NSX-T와 PKS(Pivotal 컨테이너 서비스) 및 OpenShift와 같은 컨테이너 기반 CaaS/PaaS 플랫폼 간의 통합을 제공한다.</li>
<li><a href=https://github.com/nuagenetworks/nuage-kubernetes/blob/v5.1.1-1/docs/kubernetes-1-installation.rst>Nuage</a>는 가시성과 보안 모니터링 기능을 통해 쿠버네티스 파드와 비-쿠버네티스 환경 간에 폴리시 기반 네트워킹을 제공하는 SDN 플랫폼이다.</li>
<li><a href=https://github.com/romana/romana>Romana</a>는 <a href=/ko/docs/concepts/services-networking/network-policies/>네트워크폴리시 API</a>도 지원하는 파드 네트워크용 Layer 3 네트워킹 솔루션이다. Kubeadm 애드온 설치에 대한 세부 정보는 <a href=https://github.com/romana/romana/tree/master/containerize>여기</a>에 있다.</li>
<li><a href=https://www.weave.works/docs/net/latest/kubernetes/kube-addon/>Weave Net</a>은 네트워킹 및 네트워크 폴리시를 제공하고, 네트워크 파티션의 양면에서 작업을 수행하며, 외부 데이터베이스는 필요하지 않다.</li>
</ul>
<h2 id=서비스-검색>서비스 검색</h2>
<ul>
<li><a href=https://coredns.io>CoreDNS</a>는 유연하고 확장 가능한 DNS 서버로, 파드를 위한 클러스터 내 DNS로 <a href=https://github.com/coredns/deployment/tree/master/kubernetes>설치</a>할 수 있다.</li>
</ul>
<h2 id=시각화-amp-제어>시각화 & 제어</h2>
<ul>
<li><a href=https://github.com/kubernetes/dashboard#kubernetes-dashboard>대시보드</a>는 쿠버네티스를 위한 대시보드 웹 인터페이스이다.</li>
<li><a href=https://www.weave.works/documentation/scope-latest-installing/#k8s>Weave Scope</a>는 컨테이너, 파드, 서비스 등을 그래픽으로 시각화하는 도구이다. <a href=https://cloud.weave.works/>Weave Cloud 어카운트</a>와 함께 사용하거나 UI를 직접 호스팅한다.</li>
</ul>
<h2 id=인프라스트럭처>인프라스트럭처</h2>
<ul>
<li><a href=https://kubevirt.io/user-guide/#/installation/installation>KubeVirt</a>는 쿠버네티스에서 가상 머신을 실행하기 위한 애드온이다. 일반적으로 베어 메탈 클러스터에서 실행한다.</li>
<li><a href=https://github.com/kubernetes/node-problem-detector>node problem detector</a>는
리눅스 노드에서 실행되며,
시스템 이슈를
<a href=/docs/reference/kubernetes-api/cluster-resources/event-v1/>이벤트</a> 또는
<a href=/ko/docs/concepts/architecture/nodes/#condition>노드 컨디션</a> 형태로 보고한다.</li>
</ul>
<h2 id=레거시-애드온>레거시 애드온</h2>
<p>더 이상 사용되지 않는 <a href=https://git.k8s.io/kubernetes/cluster/addons>cluster/addons</a> 디렉터리에 다른 여러 애드온이 문서화되어 있다.</p>
<p>잘 관리된 것들이 여기에 연결되어 있어야 한다. PR을 환영한다!</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-7e0d97616b15e2c383c6a0a96ec442cb>12 - 쿠버네티스 확장</h1>
<div class=lead>쿠버네티스 클러스터의 동작을 변경하는 다양한 방법</div>
<p>쿠버네티스는 매우 유연하게 구성할 수 있고 확장 가능하다. 결과적으로
쿠버네티스 프로젝트를 포크하거나 코드에 패치를 제출할 필요가
거의 없다.</p>
<p>이 가이드는 쿠버네티스 클러스터를 사용자 정의하기 위한 옵션을 설명한다.
쿠버네티스 클러스터를 업무 환경의 요구에 맞게
조정하는 방법을 이해하려는 <a class=glossary-tooltip title="A person who configures, controls, and monitors clusters." data-toggle=tooltip data-placement=top href="/ko/docs/reference/glossary/?all=true#term-cluster-operator" target=_blank aria-label="클러스터 운영자">클러스터 운영자</a>를 대상으로 한다.
잠재적인 <a class=glossary-tooltip title="A person who customizes the Kubernetes platform to fit the needs of their project." data-toggle=tooltip data-placement=top href="/ko/docs/reference/glossary/?all=true#term-platform-developer" target=_blank aria-label="플랫폼 개발자">플랫폼 개발자</a> 또는 쿠버네티스 프로젝트 <a class=glossary-tooltip title="쿠버네티스 프로젝트 또는 커뮤니티를 돕기 위해 코드, 문서 또는 시간을 기부하는 사람." data-toggle=tooltip data-placement=top href="/ko/docs/reference/glossary/?all=true#term-contributor" target=_blank aria-label=컨트리뷰터>컨트리뷰터</a>인 개발자에게도
어떤 익스텐션(extension) 포인트와 패턴이 있는지,
그리고 그것의 트레이드오프와 제약을 이해하는 데 도움이 될 것이다.</p>
<h2 id=개요>개요</h2>
<p>사용자 정의 방식은 크게 플래그, 로컬 구성 파일 또는 API 리소스 변경만 포함하는 <em>구성</em> 과 추가 프로그램이나 서비스 실행과 관련된 <em>익스텐션</em> 으로 나눌 수 있다. 이 문서는 주로 익스텐션에 관한 것이다.</p>
<h2 id=구성>구성</h2>
<p><em>구성 파일</em> 및 <em>플래그</em> 는 온라인 문서의 레퍼런스 섹션에 각 바이너리 별로 문서화되어 있다.</p>
<ul>
<li><a href=/docs/reference/command-line-tools-reference/kubelet/>kubelet</a></li>
<li><a href=/docs/reference/command-line-tools-reference/kube-apiserver/>kube-apiserver</a></li>
<li><a href=/docs/reference/command-line-tools-reference/kube-controller-manager/>kube-controller-manager</a></li>
<li><a href=/docs/reference/command-line-tools-reference/kube-scheduler/>kube-scheduler</a>.</li>
</ul>
<p>호스팅된 쿠버네티스 서비스 또는 매니지드 설치 환경의 배포판에서 플래그 및 구성 파일을 항상 변경할 수 있는 것은 아니다. 변경 가능한 경우 일반적으로 클러스터 관리자만 변경할 수 있다. 또한 향후 쿠버네티스 버전에서 변경될 수 있으며, 이를 설정하려면 프로세스를 다시 시작해야 할 수도 있다. 이러한 이유로 다른 옵션이 없는 경우에만 사용해야 한다.</p>
<p><a href=/ko/docs/concepts/policy/resource-quotas/>리소스쿼터</a>, <a href=/ko/docs/concepts/policy/pod-security-policy/>파드시큐리티폴리시(PodSecurityPolicy)</a>, <a href=/ko/docs/concepts/services-networking/network-policies/>네트워크폴리시</a> 및 역할 기반 접근 제어(<a href=/docs/reference/access-authn-authz/rbac/>RBAC</a>)와 같은 <em>빌트인 정책 API(built-in Policy API)</em> 는 기본적으로 제공되는 쿠버네티스 API이다. API는 일반적으로 호스팅된 쿠버네티스 서비스 및 매니지드 쿠버네티스 설치 환경과 함께 사용된다. 그것들은 선언적이며 파드와 같은 다른 쿠버네티스 리소스와 동일한 규칙을 사용하므로, 새로운 클러스터 구성을 반복할 수 있고 애플리케이션과 동일한 방식으로 관리할 수 있다. 또한, 이들 API가 안정적인 경우, 다른 쿠버네티스 API와 같이 <a href=/docs/reference/using-api/deprecation-policy/>정의된 지원 정책</a>을 사용할 수 있다. 이러한 이유로 인해 <em>구성 파일</em> 과 <em>플래그</em> 보다 선호된다.</p>
<h2 id=익스텐션>익스텐션</h2>
<p>익스텐션은 쿠버네티스를 확장하고 쿠버네티스와 긴밀하게 통합되는 소프트웨어 컴포넌트이다.
이들 컴포넌트는 쿠버네티스가 새로운 유형과 새로운 종류의 하드웨어를 지원할 수 있게 해준다.</p>
<p>많은 클러스터 관리자가 호스팅 또는 배포판 쿠버네티스 인스턴스를 사용한다.
이러한 클러스터들은 미리 설치된 익스텐션을 포함한다. 결과적으로 대부분의
쿠버네티스 사용자는 익스텐션을 설치할 필요가 없고, 새로운 익스텐션을 만들 필요가 있는 사용자는 더 적다.</p>
<h2 id=익스텐션-패턴>익스텐션 패턴</h2>
<p>쿠버네티스는 클라이언트 프로그램을 작성하여 자동화 되도록 설계되었다.
쿠버네티스 API를 읽고 쓰는 프로그램은 유용한 자동화를 제공할 수 있다.
<em>자동화</em> 는 클러스터 상에서 또는 클러스터 밖에서 실행할 수 있다. 이 문서의 지침에 따라
고가용성과 강력한 자동화를 작성할 수 있다.
자동화는 일반적으로 호스트 클러스터 및 매니지드 설치 환경을 포함한 모든
쿠버네티스 클러스터에서 작동한다.</p>
<p>쿠버네티스와 잘 작동하는 클라이언트 프로그램을 작성하기 위한 특정 패턴은 <em>컨트롤러</em> 패턴이라고 한다.
컨트롤러는 일반적으로 오브젝트의 <code>.spec</code>을 읽고, 가능한 경우 수행한 다음
오브젝트의 <code>.status</code>를 업데이트 한다.</p>
<p>컨트롤러는 쿠버네티스의 클라이언트이다. 쿠버네티스가 클라이언트이고
원격 서비스를 호출할 때 이를 <em>웹훅(Webhook)</em> 이라고 한다. 원격 서비스를
<em>웹훅 백엔드</em> 라고 한다. 컨트롤러와 마찬가지로 웹훅은 장애 지점을
추가한다.</p>
<p>웹훅 모델에서 쿠버네티스는 원격 서비스에 네트워크 요청을 한다.
<em>바이너리 플러그인</em> 모델에서 쿠버네티스는 바이너리(프로그램)를 실행한다.
바이너리 플러그인은 kubelet(예:
<a href=/ko/docs/concepts/storage/volumes/#flexvolume>Flex Volume 플러그인</a>과
<a href=/ko/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/>네트워크 플러그인</a>)과
kubectl에서 사용한다.</p>
<p>아래는 익스텐션 포인트가 쿠버네티스 컨트롤 플레인과 상호 작용하는 방법을
보여주는 다이어그램이다.</p>
<p><img src=/ko/docs/concepts/extend-kubernetes/control-plane.png alt="익스텐션 포인트와 컨트롤 플레인"></p>
<h2 id=익스텐션-포인트>익스텐션 포인트</h2>
<p>이 다이어그램은 쿠버네티스 시스템의 익스텐션 포인트를 보여준다.</p>
<p><img src=/docs/concepts/extend-kubernetes/extension-points.png alt="익스텐션 포인트"></p>
<ol>
<li>사용자는 종종 <code>kubectl</code>을 사용하여 쿠버네티스 API와 상호 작용한다. <a href=/ko/docs/tasks/extend-kubectl/kubectl-plugins/>Kubectl 플러그인</a>은 kubectl 바이너리를 확장한다. 개별 사용자의 로컬 환경에만 영향을 미치므로 사이트 전체 정책을 적용할 수는 없다.</li>
<li>apiserver는 모든 요청을 처리한다. apiserver의 여러 유형의 익스텐션 포인트는 요청을 인증하거나, 콘텐츠를 기반으로 요청을 차단하거나, 콘텐츠를 편집하고, 삭제 처리를 허용한다. 이 내용은 <a href=#api-%EC%A0%91%EA%B7%BC-%EC%9D%B5%EC%8A%A4%ED%85%90%EC%85%98>API 접근 익스텐션</a> 섹션에 설명되어 있다.</li>
<li>apiserver는 다양한 종류의 <em>리소스</em> 를 제공한다. <code>pods</code>와 같은 <em>빌트인 리소스 종류</em> 는 쿠버네티스 프로젝트에 의해 정의되며 변경할 수 없다. 직접 정의한 리소스를 추가할 수도 있고, <a href=#%EC%82%AC%EC%9A%A9%EC%9E%90-%EC%A0%95%EC%9D%98-%EC%9C%A0%ED%98%95>커스텀 리소스</a> 섹션에 설명된 대로 <em>커스텀 리소스</em> 라고 부르는 다른 프로젝트에서 정의한 리소스를 추가할 수도 있다. 커스텀 리소스는 종종 API 접근 익스텐션과 함께 사용된다.</li>
<li>쿠버네티스 스케줄러는 파드를 배치할 노드를 결정한다. 스케줄링을 확장하는 몇 가지 방법이 있다. 이들은 <a href=#%EC%8A%A4%EC%BC%80%EC%A4%84%EB%9F%AC-%EC%9D%B5%EC%8A%A4%ED%85%90%EC%85%98>스케줄러 익스텐션</a> 섹션에 설명되어 있다.</li>
<li>쿠버네티스의 많은 동작은 API-Server의 클라이언트인 컨트롤러(Controller)라는 프로그램으로 구현된다. 컨트롤러는 종종 커스텀 리소스와 함께 사용된다.</li>
<li>kubelet은 서버에서 실행되며 파드가 클러스터 네트워크에서 자체 IP를 가진 가상 서버처럼 보이도록 한다. <a href=#%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%ED%94%8C%EB%9F%AC%EA%B7%B8%EC%9D%B8>네트워크 플러그인</a>을 사용하면 다양한 파드 네트워킹 구현이 가능하다.</li>
<li>kubelet은 컨테이너의 볼륨을 마운트 및 마운트 해제한다. 새로운 유형의 스토리지는 <a href=#%EC%8A%A4%ED%86%A0%EB%A6%AC%EC%A7%80-%ED%94%8C%EB%9F%AC%EA%B7%B8%EC%9D%B8>스토리지 플러그인</a>을 통해 지원될 수 있다.</li>
</ol>
<p>어디서부터 시작해야 할지 모르겠다면, 이 플로우 차트가 도움이 될 수 있다. 일부 솔루션에는 여러 유형의 익스텐션이 포함될 수 있다.</p>
<p><img src=/ko/docs/concepts/extend-kubernetes/flowchart.png alt="익스텐션 플로우차트"></p>
<h2 id=api-익스텐션>API 익스텐션</h2>
<h3 id=사용자-정의-유형>사용자 정의 유형</h3>
<p>새 컨트롤러, 애플리케이션 구성 오브젝트 또는 기타 선언적 API를 정의하고 <code>kubectl</code> 과 같은 쿠버네티스 도구를 사용하여 관리하려면 쿠버네티스에 커스텀 리소스를 추가하자.</p>
<p>애플리케이션, 사용자 또는 모니터링 데이터의 데이터 저장소로 커스텀 리소스를 사용하지 않는다.</p>
<p>커스텀 리소스에 대한 자세한 내용은 <a href=/ko/docs/concepts/extend-kubernetes/api-extension/custom-resources/>커스텀 리소스 개념 가이드</a>를 참고하길 바란다.</p>
<h3 id=새로운-api와-자동화의-결합>새로운 API와 자동화의 결합</h3>
<p>사용자 정의 리소스 API와 컨트롤 루프의 조합을 <a href=/ko/docs/concepts/extend-kubernetes/operator/>오퍼레이터(operator) 패턴</a>이라고 한다. 오퍼레이터 패턴은 특정 애플리케이션, 일반적으로 스테이트풀(stateful) 애플리케이션을 관리하는 데 사용된다. 이러한 사용자 정의 API 및 컨트롤 루프를 사용하여 스토리지나 정책과 같은 다른 리소스를 제어할 수도 있다.</p>
<h3 id=빌트인-리소스-변경>빌트인 리소스 변경</h3>
<p>사용자 정의 리소스를 추가하여 쿠버네티스 API를 확장하면 추가된 리소스는 항상 새로운 API 그룹에 속한다. 기존 API 그룹을 바꾸거나 변경할 수 없다.
API를 추가해도 기존 API(예: 파드)의 동작에 직접 영향을 미치지는 않지만 API 접근 익스텐션은 영향을 준다.</p>
<h3 id=api-접근-익스텐션>API 접근 익스텐션</h3>
<p>요청이 쿠버네티스 API 서버에 도달하면 먼저 인증이 되고, 그런 다음 승인된 후 다양한 유형의 어드미션 컨트롤이 적용된다. 이 흐름에 대한 자세한 내용은 <a href=/ko/docs/concepts/security/controlling-access/>쿠버네티스 API에 대한 접근 제어</a>를 참고하길 바란다.</p>
<p>이러한 각 단계는 익스텐션 포인트를 제공한다.</p>
<p>쿠버네티스에는 이를 지원하는 몇 가지 빌트인 인증 방법이 있다. 또한 인증 프록시 뒤에 있을 수 있으며 인증 헤더에서 원격 서비스로 토큰을 전송하여 확인할 수 있다(웹훅). 이러한 방법은 모두 <a href=/docs/reference/access-authn-authz/authentication/>인증 설명서</a>에 설명되어 있다.</p>
<h3 id=인증>인증</h3>
<p><a href=/docs/reference/access-authn-authz/authentication/>인증</a>은 모든 요청의 헤더 또는 인증서를 요청하는 클라이언트의 사용자 이름에 매핑한다.</p>
<p>쿠버네티스는 몇 가지 빌트인 인증 방법과 필요에 맞지 않는 경우 <a href=/docs/reference/access-authn-authz/authentication/#webhook-token-authentication>인증 웹훅</a> 방법을 제공한다.</p>
<h3 id=인가>인가</h3>
<p><a href=/ko/docs/reference/access-authn-authz/authorization/>인가</a>는 특정 사용자가 API 리소스에서 읽고, 쓰고, 다른 작업을 수행할 수 있는지를 결정한다. 전체 리소스 레벨에서 작동하며 임의의 오브젝트 필드를 기준으로 구별하지 않는다. 빌트인 인증 옵션이 사용자의 요구를 충족시키지 못하면 <a href=/docs/reference/access-authn-authz/webhook/>인가 웹훅</a>을 통해 사용자가 제공한 코드를 호출하여 인증 결정을 내릴 수 있다.</p>
<h3 id=동적-어드미션-컨트롤>동적 어드미션 컨트롤</h3>
<p>요청이 승인된 후, 쓰기 작업인 경우 <a href=/docs/reference/access-authn-authz/admission-controllers/>어드미션 컨트롤</a> 단계도 수행된다. 빌트인 단계 외에도 몇 가지 익스텐션이 있다.</p>
<ul>
<li><a href=/docs/reference/access-authn-authz/admission-controllers/#imagepolicywebhook>이미지 정책 웹훅</a>은 컨테이너에서 실행할 수 있는 이미지를 제한한다.</li>
<li>임의의 어드미션 컨트롤 결정을 내리기 위해 일반적인 <a href=/docs/reference/access-authn-authz/extensible-admission-controllers/#admission-webhooks>어드미션 웹훅</a>을 사용할 수 있다. 어드미션 웹훅은 생성 또는 업데이트를 거부할 수 있다.</li>
</ul>
<h2 id=인프라스트럭처-익스텐션>인프라스트럭처 익스텐션</h2>
<h3 id=스토리지-플러그인>스토리지 플러그인</h3>
<p><a href=https://github.com/kubernetes/community/blob/master/contributors/design-proposals/storage/flexvolume-deployment.md>Flex Volumes</a>을 사용하면
Kubelet이 바이너리 플러그인을 호출하여 볼륨을 마운트하도록 함으로써
빌트인 지원 없이 볼륨 유형을 마운트 할 수 있다.</p>
<p>FlexVolume은 쿠버네티스 v1.23부터 사용 중단(deprecated)되었다. Out-of-tree CSI 드라이버가 쿠버네티스에서 볼륨 드라이버를 작성할 때 추천하는 방식이다. 자세한 정보는 <a href=https://github.com/kubernetes/community/blob/master/sig-storage/volume-plugin-faq.md#kubernetes-volume-plugin-faq-for-storage-vendors>스토리지 업체를 위한 쿠버네티스 볼륨 플러그인 FAQ</a>에서 찾을 수 있다.</p>
<h3 id=장치-플러그인>장치 플러그인</h3>
<p>장치 플러그인은 노드가 <a href=/ko/docs/concepts/extend-kubernetes/compute-storage-net/device-plugins/>장치 플러그인</a>을
통해 새로운 노드 리소스(CPU 및 메모리와 같은 빌트인 자원 외에)를
발견할 수 있게 해준다.</p>
<h3 id=네트워크-플러그인>네트워크 플러그인</h3>
<p>노드-레벨의 <a href=/ko/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/>네트워크 플러그인</a>
을 통해 다양한 네트워킹 패브릭을 지원할 수 있다.</p>
<h3 id=스케줄러-익스텐션>스케줄러 익스텐션</h3>
<p>스케줄러는 파드를 감시하고 파드를 노드에 할당하는 특수한 유형의
컨트롤러이다. 다른 쿠버네티스 컴포넌트를 계속 사용하면서
기본 스케줄러를 완전히 교체하거나,
<a href=/docs/tasks/extend-kubernetes/configure-multiple-schedulers/>여러 스케줄러</a>를
동시에 실행할 수 있다.</p>
<p>이것은 중요한 부분이며, 거의 모든 쿠버네티스 사용자는 스케줄러를 수정할
필요가 없다는 것을 알게 된다.</p>
<p>스케줄러는 또한 웹훅 백엔드(스케줄러 익스텐션)가
파드에 대해 선택된 노드를 필터링하고 우선 순위를 지정할 수 있도록 하는
<a href=https://github.com/kubernetes/community/blob/master/contributors/design-proposals/scheduling/scheduler_extender.md>웹훅</a>을
지원한다.</p>
<h2 id=다음-내용>다음 내용</h2>
<ul>
<li><a href=/ko/docs/concepts/extend-kubernetes/api-extension/custom-resources/>커스텀 리소스</a>에 대해 더 알아보기</li>
<li><a href=/docs/reference/access-authn-authz/extensible-admission-controllers/>동적 어드미션 컨트롤</a>에 대해 알아보기</li>
<li>인프라스트럭처 익스텐션에 대해 더 알아보기
<ul>
<li><a href=/ko/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/>네트워크 플러그인</a></li>
<li><a href=/ko/docs/concepts/extend-kubernetes/compute-storage-net/device-plugins/>장치 플러그인</a></li>
</ul>
</li>
<li><a href=/ko/docs/tasks/extend-kubectl/kubectl-plugins/>kubectl 플러그인</a>에 대해 알아보기</li>
<li><a href=/ko/docs/concepts/extend-kubernetes/operator/>오퍼레이터 패턴</a>에 대해 알아보기</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-0af41d3bd7c785621b58b7564793396a>12.1 - 쿠버네티스 API 확장하기</h1>
</div>
<div class=td-content>
<h1 id=pg-342388440304e19ce30c0f8ada1c77ce>12.1.1 - 커스텀 리소스</h1>
<p><em>커스텀 리소스</em> 는 쿠버네티스 API의 익스텐션이다. 이 페이지에서는 쿠버네티스 클러스터에
커스텀 리소스를 추가할 시기와 독립형 서비스를 사용하는 시기에 대해 설명한다. 커스텀 리소스를
추가하는 두 가지 방법과 이들 중에서 선택하는 방법에 대해 설명한다.</p>
<h2 id=커스텀-리소스>커스텀 리소스</h2>
<p><em>리소스</em> 는 <a href=/ko/docs/concepts/overview/kubernetes-api/>쿠버네티스 API</a>에서 특정 종류의
<a href=/ko/docs/concepts/overview/working-with-objects/kubernetes-objects/>API 오브젝트</a> 모음을 저장하는 엔드포인트이다. 예를 들어 빌트인 <em>파드</em> 리소스에는 파드 오브젝트 모음이 포함되어 있다.</p>
<p><em>커스텀 리소스</em> 는 쿠버네티스 API의 익스텐션으로, 기본 쿠버네티스 설치에서 반드시
사용할 수 있는 것은 아니다. 이는 특정 쿠버네티스 설치에 수정이 가해졌음을 나타낸다. 그러나
많은 핵심 쿠버네티스 기능은 이제 커스텀 리소스를 사용하여 구축되어, 쿠버네티스를 더욱 모듈화한다.</p>
<p>동적 등록을 통해 실행 중인 클러스터에서 커스텀 리소스가 나타나거나 사라질 수 있으며
클러스터 관리자는 클러스터 자체와 독립적으로 커스텀 리소스를 업데이트 할 수 있다.
커스텀 리소스가 설치되면 사용자는 <em>파드</em> 와 같은 빌트인 리소스와 마찬가지로
<a href=/ko/docs/reference/kubectl/overview/>kubectl</a>을 사용하여 해당 오브젝트를 생성하고
접근할 수 있다.</p>
<h2 id=커스텀-컨트롤러>커스텀 컨트롤러</h2>
<p>자체적으로 커스텀 리소스를 사용하면 구조화된 데이터를 저장하고 검색할 수 있다.
커스텀 리소스를 <em>커스텀 컨트롤러</em> 와 결합하면, 커스텀 리소스가 진정한
<em>선언적(declarative) API</em> 를 제공하게 된다.</p>
<p>쿠버네티스 <a href=/ko/docs/concepts/overview/kubernetes-api/>선언적 API</a>는
책임의 분리를 강제한다. 사용자는 리소스의 의도한 상태를 선언한다.
쿠버네티스 컨트롤러는 쿠버네티스 오브젝트의 현재 상태가
선언한 의도한 상태에 동기화 되도록 한다.
이는 서버에 무엇을 해야할지 <em>지시하는</em> 명령적인 API와는 대조된다.</p>
<p>클러스터 라이프사이클과 관계없이 실행 중인 클러스터에 커스텀 컨트롤러를 배포하고
업데이트할 수 있다. 커스텀 컨트롤러는 모든 종류의 리소스와 함께 작동할 수 있지만
커스텀 리소스와 결합할 때 특히 효과적이다.
<a href=/ko/docs/concepts/extend-kubernetes/operator/>오퍼레이터 패턴</a>은 사용자 정의
리소스와 커스텀 컨트롤러를 결합한다. 커스텀 컨트롤러를 사용하여 특정 애플리케이션에 대한 도메인 지식을
쿠버네티스 API의 익스텐션으로 인코딩할 수 있다.</p>
<h2 id=쿠버네티스-클러스터에-커스텀-리소스를-추가해야-하나>쿠버네티스 클러스터에 커스텀 리소스를 추가해야 하나?</h2>
<p>새로운 API를 생성할 때
<a href=/ko/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/>쿠버네티스 클러스터 API와 생성한 API를 애그리게이트</a>할 것인지
아니면 생성한 API를 독립적으로 유지할 것인지 고려하자.</p>
<table>
<thead>
<tr>
<th>API 애그리게이트를 고려할 경우</th>
<th>독립 API를 고려할 경우</th>
</tr>
</thead>
<tbody>
<tr>
<td>API가 <a href=#%EC%84%A0%EC%96%B8%EC%A0%81-api>선언적</a>이다.</td>
<td>API가 <a href=#%EC%84%A0%EC%96%B8%EC%A0%81-api>선언적</a> 모델에 맞지 않다.</td>
</tr>
<tr>
<td><code>kubectl</code>을 사용하여 새로운 타입을 읽고 쓸 수 있기를 원한다.</td>
<td><code>kubectl</code> 지원이 필요하지 않다.</td>
</tr>
<tr>
<td>쿠버네티스 UI(예: 대시보드)에서 빌트인 타입과 함께 새로운 타입을 보길 원한다.</td>
<td>쿠버네티스 UI 지원이 필요하지 않다.</td>
</tr>
<tr>
<td>새로운 API를 개발 중이다.</td>
<td>생성한 API를 제공하는 프로그램이 이미 있고 잘 작동하고 있다.</td>
</tr>
<tr>
<td>API 그룹 및 네임스페이스와 같은 REST 리소스 경로에 적용하는 쿠버네티스의 형식 제한을 기꺼이 수용한다. (<a href=/ko/docs/concepts/overview/kubernetes-api/>API 개요</a>를 참고한다.)</td>
<td>이미 정의된 REST API와 호환되도록 특정 REST 경로가 있어야 한다.</td>
</tr>
<tr>
<td>자체 리소스는 자연스럽게 클러스터 또는 클러스터의 네임스페이스로 범위가 지정된다.</td>
<td>클러스터 또는 네임스페이스 범위의 리소스는 적합하지 않다. 특정 리소스 경로를 제어해야 한다.</td>
</tr>
<tr>
<td><a href=#%EC%9D%BC%EB%B0%98%EC%A0%81%EC%9D%B8-%EA%B8%B0%EB%8A%A5>쿠버네티스 API 지원 기능</a>을 재사용하려고 한다.</td>
<td>이러한 기능이 필요하지 않다.</td>
</tr>
</tbody>
</table>
<h3 id=선언적-api>선언적 API</h3>
<p>선언적 API에서는 다음의 특성이 있다.</p>
<ul>
<li>API는 상대적으로 적은 수의 상대적으로 작은 오브젝트(리소스)로 구성된다.</li>
<li>오브젝트는 애플리케이션 또는 인프라의 구성을 정의한다.</li>
<li>오브젝트는 비교적 드물게 업데이트 된다.</li>
<li>사람이 종종 오브젝트를 읽고 쓸 필요가 있다.</li>
<li>오브젝트의 주요 작업은 CRUD-y(생성, 읽기, 업데이트 및 삭제)이다.</li>
<li>오브젝트 간 트랜잭션은 필요하지 않다. API는 정확한(exact) 상태가 아니라 의도한 상태를 나타낸다.</li>
</ul>
<p>명령형 API는 선언적이지 않다.
자신의 API가 선언적이지 않을 수 있다는 징후는 다음과 같다.</p>
<ul>
<li>클라이언트는 "이 작업을 수행한다"라고 말하고 완료되면 동기(synchronous) 응답을 받는다.</li>
<li>클라이언트는 "이 작업을 수행한다"라고 말한 다음 작업 ID를 다시 가져오고 별도의 오퍼레이션(operation) 오브젝트를 확인하여 요청의 완료 여부를 결정해야 한다.</li>
<li>RPC(원격 프로시저 호출)에 대해 얘기한다.</li>
<li>대량의 데이터를 직접 저장한다. 예: > 오브젝트별 몇 kB 또는 > 1000개의 오브젝트.</li>
<li>높은 대역폭 접근(초당 10개의 지속적인 요청)이 필요하다.</li>
<li>최종 사용자 데이터(예: 이미지, PII 등) 또는 애플리케이션에서 처리한 기타 대규모 데이터를 저장한다.</li>
<li>오브젝트에 대한 자연스러운 조작은 CRUD-y가 아니다.</li>
<li>API는 오브젝트로 쉽게 모델링되지 않는다.</li>
<li>작업 ID 또는 작업 오브젝트로 보류 중인 작업을 나타내도록 선택했다.</li>
</ul>
<h2 id=컨피그맵을-사용해야-하나-커스텀-리소스를-사용해야-하나>컨피그맵을 사용해야 하나, 커스텀 리소스를 사용해야 하나?</h2>
<p>다음 중 하나에 해당하면 컨피그맵을 사용하자.</p>
<ul>
<li><code>mysql.cnf</code> 또는 <code>pom.xml</code>과 같이 잘 문서화된 기존 구성 파일 형식이 있다.</li>
<li>전체 구성 파일을 컨피그맵의 하나의 키에 넣고 싶다.</li>
<li>구성 파일의 주요 용도는 클러스터의 파드에서 실행 중인 프로그램이 파일을 사용하여 자체 구성하는 것이다.</li>
<li>파일 사용자는 쿠버네티스 API가 아닌 파드의 환경 변수 또는 파드의 파일을 통해 사용하는 것을 선호한다.</li>
<li>파일이 업데이트될 때 디플로이먼트 등을 통해 롤링 업데이트를 수행하려고 한다.</li>
</ul>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> 민감한 데이터에는 <a href=/ko/docs/concepts/configuration/secret/>시크릿</a>을 사용하자. 이는 컨피그맵과 비슷하지만 더 안전한다.
</div>
<p>다음 중 대부분이 적용되는 경우 커스텀 리소스(CRD 또는 애그리게이트 API(aggregated API))를 사용하자.</p>
<ul>
<li>쿠버네티스 클라이언트 라이브러리 및 CLI를 사용하여 새 리소스를 만들고 업데이트하려고 한다.</li>
<li><code>kubectl</code> 의 최상위 지원을 원한다. 예: <code>kubectl get my-object object-name</code>.</li>
<li>새 오브젝트에 대한 업데이트를 감시한 다음 다른 오브젝트를 CRUD하거나 그 반대로 하는 새로운 자동화를 구축하려고 한다.</li>
<li>오브젝트의 업데이트를 처리하는 자동화를 작성하려고 한다.</li>
<li><code>.spec</code>, <code>.status</code> 및 <code>.metadata</code>와 같은 쿠버네티스 API 규칙을 사용하려고 한다.</li>
<li>제어된 리소스의 콜렉션 또는 다른 리소스의 요약에 대한 오브젝트가 되기를 원한다.</li>
</ul>
<h2 id=커스텀-리소스-추가>커스텀 리소스 추가</h2>
<p>쿠버네티스는 클러스터에 커스텀 리소스를 추가하는 두 가지 방법을 제공한다.</p>
<ul>
<li>CRD는 간단하며 프로그래밍 없이 만들 수 있다.</li>
<li><a href=/ko/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/>API 애그리게이션</a>에는 프로그래밍이 필요하지만, 데이터 저장 방법 및 API 버전 간 변환과 같은 API 동작을 보다 강력하게 제어할 수 있다.</li>
</ul>
<p>쿠버네티스는 다양한 사용자의 요구를 충족시키기 위해 이 두 가지 옵션을 제공하므로 사용의 용이성이나 유연성이 저하되지 않는다.</p>
<p>애그리게이트 API는 기본 API 서버 뒤에 있는 하위 API 서버이며 프록시 역할을 한다. 이 배치를 <a href=/ko/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/>API 애그리게이션</a>(AA)이라고 한다. 사용자에게는 쿠버네티스 API가 확장된 것으로 나타난다.</p>
<p>CRD를 사용하면 다른 API 서버를 추가하지 않고도 새로운 타입의 리소스를 생성할 수 있다. CRD를 사용하기 위해 API 애그리게이션을 이해할 필요는 없다.</p>
<p>설치 방법에 관계없이 새 리소스는 커스텀 리소스라고 하며 빌트인 쿠버네티스 리소스(파드 등)와 구별된다.</p>
<h2 id=커스텀리소스데피니션>커스텀리소스데피니션</h2>
<p><a href=/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/>커스텀리소스데피니션</a>
API 리소스를 사용하면 커스텀 리소스를 정의할 수 있다.
CRD 오브젝트를 정의하면 지정한 이름과 스키마를 사용하여 새 커스텀 리소스가 만들어진다.
쿠버네티스 API는 커스텀 리소스의 스토리지를 제공하고 처리한다.
CRD 오브젝트의 이름은 유효한
<a href=/ko/docs/concepts/overview/working-with-objects/names#dns-%EC%84%9C%EB%B8%8C%EB%8F%84%EB%A9%94%EC%9D%B8-%EC%9D%B4%EB%A6%84>DNS 서브도메인 이름</a>이어야 한다.</p>
<p>따라서 커스텀 리소스를 처리하기 위해 자신의 API 서버를 작성할 수 없지만
구현의 일반적인 특성으로 인해
<a href=#api-%EC%84%9C%EB%B2%84-%EC%95%A0%EA%B7%B8%EB%A6%AC%EA%B2%8C%EC%9D%B4%EC%85%98>API 서버 애그리게이션</a>보다 유연성이 떨어진다.</p>
<p>새 커스텀 리소스를 등록하고 새 리소스 타입의 인스턴스에 대해 작업하고
컨트롤러를 사용하여 이벤트를 처리하는 방법에 대한 예제는
<a href=https://github.com/kubernetes/sample-controller>커스텀 컨트롤러 예제</a>를 참고한다.</p>
<h2 id=api-서버-애그리게이션>API 서버 애그리게이션</h2>
<p>일반적으로 쿠버네티스 API의 각 리소스에는 REST 요청을 처리하고 오브젝트의 퍼시스턴트 스토리지를 관리하는 코드가 필요하다. 주요 쿠버네티스 API 서버는 <em>파드</em> 및 <em>서비스</em> 와 같은 빌트인 리소스를 처리하고, 일반적으로 <a href=#%EC%BB%A4%EC%8A%A4%ED%85%80%EB%A6%AC%EC%86%8C%EC%8A%A4%EB%8D%B0%ED%94%BC%EB%8B%88%EC%85%98>CRD</a>를 통해 커스텀 리소스를 처리할 수 있다.</p>
<p><a href=/ko/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/>애그리게이션 레이어</a>를 사용하면 자체 API 서버를
작성하고 배포하여 커스텀 리소스에 대한 특수한 구현을 제공할 수 있다.
주(main) API 서버는 사용자의 커스텀 리소스에 대한 요청을 사용자의 자체 API 서버에 위임하여
모든 클라이언트가 사용할 수 있게 한다.</p>
<h2 id=커스텀-리소스를-추가할-방법-선택>커스텀 리소스를 추가할 방법 선택</h2>
<p>CRD는 사용하기가 더 쉽다. 애그리게이트 API가 더 유연하다. 자신의 요구에 가장 잘 맞는 방법을 선택하자.</p>
<p>일반적으로 CRD는 다음과 같은 경우에 적합하다.</p>
<ul>
<li>필드가 몇 개 되지 않는다</li>
<li>회사 내에서 또는 소규모 오픈소스 프로젝트의 일부인(상용 제품이 아닌) 리소스를 사용하고 있다.</li>
</ul>
<h3 id=사용-편의성-비교>사용 편의성 비교</h3>
<p>CRD는 애그리게이트 API보다 생성하기가 쉽다.</p>
<table>
<thead>
<tr>
<th>CRD</th>
<th>애그리게이트 API</th>
</tr>
</thead>
<tbody>
<tr>
<td>프로그래밍이 필요하지 않다. 사용자는 CRD 컨트롤러에 대한 모든 언어를 선택할 수 있다.</td>
<td>프로그래밍하고 바이너리와 이미지를 빌드해야 한다.</td>
</tr>
<tr>
<td>실행할 추가 서비스가 없다. CR은 API 서버에서 처리한다.</td>
<td>추가 서비스를 생성하면 실패할 수 있다.</td>
</tr>
<tr>
<td>CRD가 생성된 후에는 지속적인 지원이 없다. 모든 버그 픽스는 일반적인 쿠버네티스 마스터 업그레이드의 일부로 선택된다.</td>
<td>업스트림에서 버그 픽스를 주기적으로 선택하고 애그리게이트 API 서버를 다시 빌드하고 업데이트해야 할 수 있다.</td>
</tr>
<tr>
<td>여러 버전의 API를 처리할 필요가 없다. 예를 들어, 이 리소스에 대한 클라이언트를 제어할 때 API와 동기화하여 업그레이드할 수 있다.</td>
<td>인터넷에 공유할 익스텐션을 개발할 때와 같이 여러 버전의 API를 처리해야 한다.</td>
</tr>
</tbody>
</table>
<h3 id=고급-기능-및-유연성>고급 기능 및 유연성</h3>
<p>애그리게이트 API는 보다 고급 API 기능과 스토리지 레이어와 같은 다른 기능의 사용자 정의를 제공한다.</p>
<table>
<thead>
<tr>
<th>기능</th>
<th>설명</th>
<th>CRD</th>
<th>애그리게이트 API</th>
</tr>
</thead>
<tbody>
<tr>
<td>유효성 검사</td>
<td>사용자가 오류를 방지하고 클라이언트와 독립적으로 API를 발전시킬 수 있도록 도와준다. 이러한 기능은 동시에 많은 클라이언트를 모두 업데이트할 수 없는 경우에 아주 유용하다.</td>
<td>예. <a href=/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/#validation>OpenAPI v3.0 유효성 검사</a>를 사용하여 CRD에서 대부분의 유효성 검사를 지정할 수 있다. <a href=/docs/reference/access-authn-authz/admission-controllers/#validatingadmissionwebhook-alpha-in-1-8-beta-in-1-9>웹훅 유효성 검사</a>를 추가해서 다른 모든 유효성 검사를 지원한다.</td>
<td>예, 임의의 유효성 검사를 지원한다.</td>
</tr>
<tr>
<td>기본 설정</td>
<td>위를 참고하자.</td>
<td>예, <a href=/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/#defaulting>OpenAPI v3.0 유효성 검사</a>의 <code>default</code> 키워드(1.17에서 GA) 또는 <a href=/docs/reference/access-authn-authz/admission-controllers/#mutatingadmissionwebhook>웹훅 변형(mutating)</a>(이전 오브젝트의 etcd에서 읽을 때는 실행되지 않음)을 통해 지원한다.</td>
<td>예</td>
</tr>
<tr>
<td>다중 버전 관리</td>
<td>두 가지 API 버전을 통해 동일한 오브젝트를 제공할 수 있다. 필드 이름 바꾸기와 같은 API 변경을 쉽게 할 수 있다. 클라이언트 버전을 제어하는 경우는 덜 중요하다.</td>
<td><a href=/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definition-versioning>예</a></td>
<td>예</td>
</tr>
<tr>
<td>사용자 정의 스토리지</td>
<td>다른 성능 모드(예를 들어, 키-값 저장소 대신 시계열 데이터베이스)나 보안에 대한 격리(예를 들어, 암호화된 시크릿이나 다른 암호화) 기능을 가진 스토리지가 필요한 경우</td>
<td>아니오</td>
<td>예</td>
</tr>
<tr>
<td>사용자 정의 비즈니스 로직</td>
<td>오브젝트를 생성, 읽기, 업데이트 또는 삭제를 할 때 임의의 점검 또는 조치를 수행한다.</td>
<td>예, <a href=/docs/reference/access-authn-authz/extensible-admission-controllers/#admission-webhooks>웹훅</a>을 사용한다.</td>
<td>예</td>
</tr>
<tr>
<td>서브리소스 크기 조정</td>
<td>HorizontalPodAutoscaler 및 PodDisruptionBudget과 같은 시스템이 새로운 리소스와 상호 작용할 수 있다.</td>
<td><a href=/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/#scale-subresource>예</a></td>
<td>예</td>
</tr>
<tr>
<td>서브리소스 상태</td>
<td>사용자가 스펙 섹션을 작성하고 컨트롤러가 상태 섹션을 작성하는 세분화된 접근 제어를 허용한다. 커스텀 리소스 데이터 변형 시 오브젝트 생성을 증가시킨다(리소스에서 별도의 스펙과 상태 섹션 필요).</td>
<td><a href=/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/#status-subresource>예</a></td>
<td>예</td>
</tr>
<tr>
<td>기타 서브리소스</td>
<td>"logs" 또는 "exec"과 같은 CRUD 이외의 작업을 추가한다.</td>
<td>아니오</td>
<td>예</td>
</tr>
<tr>
<td>strategic-merge-patch</td>
<td>새로운 엔드포인트는 <code>Content-Type: application/strategic-merge-patch+json</code> 형식의 PATCH를 지원한다. 로컬 및 서버 양쪽에서 수정할 수도 있는 오브젝트를 업데이트하는 데 유용하다. 자세한 내용은 <a href=/docs/tasks/manage-kubernetes-objects/update-api-object-kubectl-patch/>"kubectl 패치를 사용한 API 오브젝트 업데이트"</a>를 참고한다.</td>
<td>아니오</td>
<td>예</td>
</tr>
<tr>
<td>프로토콜 버퍼</td>
<td>새로운 리소스는 프로토콜 버퍼를 사용하려는 클라이언트를 지원한다.</td>
<td>아니오</td>
<td>예</td>
</tr>
<tr>
<td>OpenAPI 스키마</td>
<td>서버에서 동적으로 가져올 수 있는 타입에 대한 OpenAPI(스웨거(swagger)) 스키마가 있는가? 허용된 필드만 설정하여 맞춤법이 틀린 필드 이름으로부터 사용자를 보호하는가? 타입이 적용되는가(즉, <code>string</code> 필드에 <code>int</code>를 넣지 않는가?)</td>
<td>예, <a href=/docs/tasks/access-kubernetes-api/extend-api-custom-resource-definitions/#validation>OpenAPI v3.0 유효성 검사</a>를 기반으로 하는 스키마(1.16에서 GA)</td>
<td>예</td>
</tr>
</tbody>
</table>
<h3 id=일반적인-기능>일반적인 기능</h3>
<p>CRD 또는 AA를 통해 커스텀 리소스를 생성하면 쿠버네티스 플랫폼 외부에서 구현하는 것과 비교하여 API에 대한 많은 기능이 제공된다.</p>
<table>
<thead>
<tr>
<th>기능</th>
<th>설명</th>
</tr>
</thead>
<tbody>
<tr>
<td>CRUD</td>
<td>새로운 엔드포인트는 HTTP 및 <code>kubectl</code>을 통해 CRUD 기본 작업을 지원한다.</td>
</tr>
<tr>
<td>감시</td>
<td>새로운 엔드포인트는 HTTP를 통해 쿠버네티스 감시 작업을 지원한다.</td>
</tr>
<tr>
<td>디스커버리</td>
<td>kubectl 및 대시보드와 같은 클라이언트는 리소스에 대해 목록, 표시 및 필드 수정 작업을 자동으로 제공한다.</td>
</tr>
<tr>
<td>json-patch</td>
<td>새로운 엔드포인트는 <code>Content-Type: application/json-patch+json</code> 형식의 PATCH를 지원한다.</td>
</tr>
<tr>
<td>merge-patch</td>
<td>새로운 엔드포인트는 <code>Content-Type: application/merge-patch+json</code> 형식의 PATCH를 지원한다.</td>
</tr>
<tr>
<td>HTTPS</td>
<td>새로운 엔드포인트는 HTTPS를 사용한다.</td>
</tr>
<tr>
<td>빌트인 인증</td>
<td>익스텐션에 대한 접근은 인증을 위해 기본 API 서버(애그리게이션 레이어)를 사용한다.</td>
</tr>
<tr>
<td>빌트인 권한 부여</td>
<td>익스텐션에 접근하면 기본 API 서버(예: RBAC)에서 사용하는 권한을 재사용할 수 있다.</td>
</tr>
<tr>
<td>Finalizer</td>
<td>외부 정리가 발생할 때까지 익스텐션 리소스의 삭제를 차단한다.</td>
</tr>
<tr>
<td>어드미션 웹훅</td>
<td>생성/업데이트/삭제 작업 중에 기본값을 설정하고 익스텐션 리소스의 유효성 검사를 한다.</td>
</tr>
<tr>
<td>UI/CLI 디스플레이</td>
<td>Kubectl, 대시보드는 익스텐션 리소스를 표시할 수 있다.</td>
</tr>
<tr>
<td>설정하지 않음(unset)과 비어있음(empty)</td>
<td>클라이언트는 값이 없는 필드 중에서 설정되지 않은 필드를 구별할 수 있다.</td>
</tr>
<tr>
<td>클라이언트 라이브러리 생성</td>
<td>쿠버네티스는 일반 클라이언트 라이브러리와 타입별 클라이언트 라이브러리를 생성하는 도구를 제공한다.</td>
</tr>
<tr>
<td>레이블 및 어노테이션</td>
<td>공통 메타데이터는 핵심 및 커스텀 리소스를 수정하는 방법을 알고 있는 도구이다.</td>
</tr>
</tbody>
</table>
<h2 id=커스텀-리소스-설치-준비>커스텀 리소스 설치 준비</h2>
<p>클러스터에 커스텀 리소스를 추가하기 전에 알아야 할 몇 가지 사항이 있다.</p>
<h3 id=써드파티-코드-및-새로운-장애-포인트>써드파티 코드 및 새로운 장애 포인트</h3>
<p>CRD를 생성해도 새로운 장애 포인트(예를 들어, API 서버에서 장애를 유발하는 써드파티 코드가 실행됨)가 자동으로 추가되지는 않지만, 패키지(예: 차트(Charts)) 또는 기타 설치 번들에는 CRD 및 새로운 커스텀 리소스에 대한 비즈니스 로직을 구현하는 써드파티 코드의 디플로이먼트가 포함되는 경우가 종종 있다.</p>
<p>애그리게이트 API 서버를 설치하려면 항상 새 디플로이먼트를 실행해야 한다.</p>
<h3 id=스토리지>스토리지</h3>
<p>커스텀 리소스는 컨피그맵과 동일한 방식으로 스토리지 공간을 사용한다. 너무 많은 커스텀 리소스를 생성하면 API 서버의 스토리지 공간이 과부하될 수 있다.</p>
<p>애그리게이트 API 서버는 기본 API 서버와 동일한 스토리지를 사용할 수 있으며 이 경우 동일한 경고가 적용된다.</p>
<h3 id=인증-권한-부여-및-감사>인증, 권한 부여 및 감사</h3>
<p>CRD는 항상 API 서버의 빌트인 리소스와 동일한 인증, 권한 부여 및 감사 로깅을 사용한다.</p>
<p>권한 부여에 RBAC를 사용하는 경우 대부분의 RBAC 역할은 새로운 리소스에 대한 접근 권한을 부여하지 않는다(클러스터 관리자 역할 또는 와일드 카드 규칙으로 생성된 역할 제외). 새로운 리소스에 대한 접근 권한을 명시적으로 부여해야 한다. CRD 및 애그리게이트 API는 종종 추가하는 타입에 대한 새로운 역할 정의와 함께 제공된다.</p>
<p>애그리게이트 API 서버는 기본 API 서버와 동일한 인증, 권한 부여 및 감사를 사용하거나 사용하지 않을 수 있다.</p>
<h2 id=커스텀-리소스에-접근>커스텀 리소스에 접근</h2>
<p>쿠버네티스 <a href=/ko/docs/reference/using-api/client-libraries/>클라이언트 라이브러리</a>를 사용하여 커스텀 리소스에 접근할 수 있다. 모든 클라이언트 라이브러리가 커스텀 리소스를 지원하는 것은 아니다. <em>Go</em> 와 <em>python</em> 클라이언트 라이브러리가 지원한다.</p>
<p>커스텀 리소스를 추가하면 다음을 사용하여 접근할 수 있다.</p>
<ul>
<li><code>kubectl</code></li>
<li>쿠버네티스 동적 클라이언트</li>
<li>작성한 REST 클라이언트</li>
<li><a href=https://github.com/kubernetes/code-generator>쿠버네티스 클라이언트 생성 도구</a>를 사용하여 생성된 클라이언트(하나를 생성하는 것은 고급 기능이지만, 일부 프로젝트는 CRD 또는 AA와 함께 클라이언트를 제공할 수 있다).</li>
</ul>
<h2 id=다음-내용>다음 내용</h2>
<ul>
<li>
<p><a href=/ko/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/>애그리게이션 레이어(aggregation layer)로 쿠버네티스 API 확장</a>하는 방법에 대해 배우기.</p>
</li>
<li>
<p><a href=/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/>커스텀리소스데피니션으로 쿠버네티스 API 확장</a>하는 방법에 대해 배우기.</p>
</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-1ea4977c0ebf97569bf54a477faa7fa5>12.1.2 - 쿠버네티스 API 애그리게이션 레이어(aggregation layer)</h1>
<p>애그리게이션 레이어는 코어 쿠버네티스 API가 제공하는 기능 이외에 더 많은 기능을 제공할 수 있도록 추가 API를 더해 쿠버네티스를 확장할 수 있게 해준다.
추가 API는 <a href=https://github.com/kubernetes-sigs/metrics-server>메트릭 서버</a>와 같이 미리 만들어진 솔루션이거나 사용자가 직접 개발한 API일 수 있다.</p>
<p>애그리게이션 레이어는 <a href=/ko/docs/concepts/extend-kubernetes/api-extension/custom-resources/>사용자 정의 리소스</a>와는 다르며, 애그리게이션 레이어는 <a class=glossary-tooltip title="쿠버네티스 API를 제공하는 컨트롤 플레인 컴포넌트." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/overview/components/#kube-apiserver target=_blank aria-label=kube-apiserver>kube-apiserver</a> 가 새로운 종류의 오브젝트를 인식하도록 하는 방법이다.</p>
<h2 id=애그리게이션-레이어>애그리게이션 레이어</h2>
<p>애그리게이션 레이어는 kube-apiserver 프로세스 안에서 구동된다. 확장 리소스가 등록되기 전까지, 애그리게이션 레이어는 아무 일도 하지 않는다. API를 등록하기 위해서, 사용자는 쿠버네티스 API 내에서 URL 경로를 "요구하는(claim)" APIService 오브젝트를 추가해야 한다. 이때, 애그리게이션 레이어는 해당 API 경로(예: /apis/myextensions.mycompany.io/v1/...)로 전송되는 모든 것을 등록된 APIService로 프록시하게 된다.</p>
<p>APIService를 구현하는 가장 일반적인 방법은 클러스터 내에 실행되고 있는 파드에서 <em>extension API server</em> 를 실행하는 것이다. extension API server를 사용해서 클러스터의 리소스를 관리하는 경우 extension API server("extension-apiserver" 라고도 한다)는 일반적으로 하나 이상의 <a class=glossary-tooltip title="API 서버를 통해 클러스터의 공유된 상태를 감시하고, 현재 상태를 원하는 상태로 이행시키는 컨트롤 루프." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/architecture/controller/ target=_blank aria-label=컨트롤러>컨트롤러</a>와 쌍을 이룬다. apiserver-builder 라이브러리는 extension API server와 연관된 컨틀로러에 대한 스켈레톤을 제공한다.</p>
<h3 id=응답-레이턴시>응답 레이턴시</h3>
<p>Extension-apiserver는 kube-apiserver로 오가는 연결의 레이턴시가 낮아야 한다.
kube-apiserver로 부터의 디스커버리 요청은 왕복 레이턴시가 5초 이내여야 한다.</p>
<p>extention API server가 레이턴시 요구 사항을 달성할 수 없는 경우 이를 충족할 수 있도록 변경하는 것을 고려한다.</p>
<h2 id=다음-내용>다음 내용</h2>
<ul>
<li>사용자의 환경에서 Aggregator를 동작시키려면, <a href=/docs/tasks/extend-kubernetes/configure-aggregation-layer/>애그리게이션 레이어를 설정한다</a>.</li>
<li>다음에, <a href=/ko/docs/tasks/extend-kubernetes/setup-extension-api-server/>확장 API 서버를 구성해서</a> 애그리게이션 레이어와 연계한다.</li>
<li>API 레퍼런스에서 <a href=/docs/reference/generated/kubernetes-api/v1.23/#apiservice-v1-apiregistration-k8s-io>API 서비스</a>에 대해 읽어본다.</li>
</ul>
<p>대안으로, 어떻게 <a href=/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/>쿠버네티스 API를 커스텀 리소스 데피니션으로 확장하는지</a>를 배워본다.</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-3131452556176159fb269593c1a52012>12.2 - 오퍼레이터(operator) 패턴</h1>
<p>오퍼레이터(Operator)는
<a href=/ko/docs/concepts/extend-kubernetes/api-extension/custom-resources/>사용자 정의 리소스</a>를
사용하여 애플리케이션 및 해당 컴포넌트를 관리하는 쿠버네티스의 소프트웨어 익스텐션이다. 오퍼레이터는
쿠버네티스 원칙, 특히 <a href=/ko/docs/concepts/architecture/controller/>컨트롤 루프</a>를 따른다.</p>
<h2 id=동기-부여>동기 부여</h2>
<p>오퍼레이터 패턴은 서비스 또는 서비스 셋을 관리하는 운영자의
주요 목표를 포착하는 것을 목표로 한다. 특정 애플리케이션 및
서비스를 돌보는 운영자는 시스템의 작동 방식, 배포 방법 및 문제가 있는 경우
대처 방법에 대해 깊이 알고 있다.</p>
<p>쿠버네티스에서 워크로드를 실행하는 사람들은 종종 반복 가능한 작업을 처리하기 위해
자동화를 사용하는 것을 좋아한다. 오퍼레이터 패턴은 쿠버네티스 자체가 제공하는 것 이상의
작업을 자동화하기 위해 코드를 작성하는 방법을 포착한다.</p>
<h2 id=쿠버네티스의-오퍼레이터>쿠버네티스의 오퍼레이터</h2>
<p>쿠버네티스는 자동화를 위해 설계되었다. 기본적으로 쿠버네티스의 중추를 통해 많은
빌트인 자동화 기능을 사용할 수 있다. 쿠버네티스를 사용하여 워크로드 배포
및 실행을 자동화할 수 있고, <em>또한</em> 쿠버네티스가 수행하는 방식을
자동화할 수 있다.</p>
<p>쿠버네티스의 <a class=glossary-tooltip title="A specialized controller used to manage a custom resource" data-toggle=tooltip data-placement=top href=/docs/concepts/extend-kubernetes/operator/ target=_blank aria-label="오퍼레이터 패턴">오퍼레이터 패턴</a> 개념을 통해 쿠버네티스 코드 자체를 수정하지 않고도 <a class=glossary-tooltip title="API 서버를 통해 클러스터의 공유된 상태를 감시하고, 현재 상태를 원하는 상태로 이행시키는 컨트롤 루프." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/architecture/controller/ target=_blank aria-label=컨트롤러>컨트롤러</a>를 하나 이상의 사용자 정의 리소스(custom resource)에 연결하여 클러스터의 동작을 확장할 수 있다.
오퍼레이터는 <a href=/ko/docs/concepts/extend-kubernetes/api-extension/custom-resources/>사용자 정의 리소스</a>의
컨트롤러 역할을 하는 쿠버네티스 API의 클라이언트이다.</p>
<h2 id=example>오퍼레이터 예시</h2>
<p>오퍼레이터를 사용하여 자동화할 수 있는 몇 가지 사항은 다음과 같다.</p>
<ul>
<li>주문형 애플리케이션 배포</li>
<li>해당 애플리케이션의 상태를 백업하고 복원</li>
<li>데이터베이스 스키마 또는 추가 구성 설정과 같은 관련 변경 사항에 따른
애플리케이션 코드 업그레이드 처리</li>
<li>쿠버네티스 API를 지원하지 않는 애플리케이션에 서비스를
게시하여 검색을 지원</li>
<li>클러스터의 전체 또는 일부에서 장애를 시뮬레이션하여 가용성 테스트</li>
<li>내부 멤버 선출 절차없이 분산 애플리케이션의
리더를 선택</li>
</ul>
<p>오퍼레이터의 모습을 더 자세하게 볼 수 있는 방법은 무엇인가? 예시는 다음과 같다.</p>
<ol>
<li>클러스터에 구성할 수 있는 SampleDB라는 사용자 정의 리소스.</li>
<li>오퍼레이터의 컨트롤러 부분이 포함된 파드의 실행을
보장하는 디플로이먼트.</li>
<li>오퍼레이터 코드의 컨테이너 이미지.</li>
<li>컨트롤 플레인을 쿼리하여 어떤 SampleDB 리소스가 구성되어 있는지
알아내는 컨트롤러 코드.</li>
<li>오퍼레이터의 핵심은 API 서버에 구성된 리소스와 현재 상태를
일치시키는 방법을 알려주는 코드이다.
<ul>
<li>새 SampleDB를 추가하면 오퍼레이터는 퍼시스턴트볼륨클레임을
설정하여 내구성있는 데이터베이스 스토리지, SampleDB를 실행하는 스테이트풀셋 및
초기 구성을 처리하는 잡을 제공한다.</li>
<li>SampleDB를 삭제하면 오퍼레이터는 스냅샷을 생성한 다음 스테이트풀셋과 볼륨도
제거되었는지 확인한다.</li>
</ul>
</li>
<li>오퍼레이터는 정기적인 데이터베이스 백업도 관리한다. 오퍼레이터는 각 SampleDB
리소스에 대해 데이터베이스에 연결하고 백업을 수행할 수 있는 파드를 생성하는
시기를 결정한다. 이 파드는 데이터베이스 연결 세부 정보 및 자격 증명이 있는
컨피그맵 및 / 또는 시크릿에 의존한다.</li>
<li>오퍼레이터는 관리하는 리소스에 견고한 자동화를 제공하는 것을 목표로 하기 때문에
추가 지원 코드가 있다. 이 예제에서 코드는 데이터베이스가 이전 버전을 실행 중인지
확인하고, 업그레이드된 경우 이를 업그레이드하는
잡 오브젝트를 생성한다.</li>
</ol>
<h2 id=오퍼레이터-배포>오퍼레이터 배포</h2>
<p>오퍼레이터를 배포하는 가장 일반적인 방법은
커스텀 리소스 데피니션의 정의 및 연관된 컨트롤러를 클러스터에 추가하는 것이다.
컨테이너화된 애플리케이션을 실행하는 것처럼
컨트롤러는 일반적으로 <a class=glossary-tooltip title="컨테이너의 라이프사이클을 정의, 배포, 관리하기 위한 API와 인터페이스들을 노출하는 컨테이너 오케스트레이션 레이어." data-toggle=tooltip data-placement=top href="/ko/docs/reference/glossary/?all=true#term-control-plane" target=_blank aria-label="컨트롤 플레인">컨트롤 플레인</a>
외부에서 실행된다.
예를 들어 클러스터에서 컨트롤러를 디플로이먼트로 실행할 수 있다.</p>
<h2 id=using-operators>오퍼레이터 사용</h2>
<p>오퍼레이터가 배포되면 오퍼레이터가 사용하는 리소스의 종류를 추가, 수정 또는
삭제하여 사용한다. 위의 예에 따라 오퍼레이터 자체에 대한
디플로이먼트를 설정한 후 다음을 수행한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get SampleDB                   <span style=color:#080;font-style:italic># 구성된 데이터베이스 찾기</span>

kubectl edit SampleDB/example-database <span style=color:#080;font-style:italic># 일부 설정을 수동으로 변경하기</span>
</code></pre></div><p>…이것으로 끝이다! 오퍼레이터는 변경 사항을 적용하고 기존 서비스를
양호한 상태로 유지한다.</p>
<h2 id=writing-operator>자신만의 오퍼레이터 작성</h2>
<p>에코시스템에 원하는 동작을 구현하는 오퍼레이터가 없다면
직접 코딩할 수 있다.</p>
<p>또한 <a href=/ko/docs/reference/using-api/client-libraries/>쿠버네티스 API의 클라이언트</a>
역할을 할 수 있는 모든 언어 / 런타임을 사용하여 오퍼레이터(즉, 컨트롤러)를 구현한다.</p>
<p>다음은 클라우드 네이티브 오퍼레이터를 작성하는 데 사용할 수 있는
몇 가지 라이브러리와 도구들이다.</p>
<div class="alert alert-secondary callout third-party-content" role=alert><strong>참고:</strong>
이 섹션은 쿠버네티스에 필요한 기능을 제공하는 써드파티 프로젝트와 관련이 있다. 쿠버네티스 프로젝트 작성자는 써드파티 프로젝트에 책임이 없다. 이 페이지는 <a href=https://github.com/cncf/foundation/blob/master/website-guidelines.md target=_blank>CNCF 웹사이트 가이드라인</a>에 따라 프로젝트를 알파벳 순으로 나열한다. 이 목록에 프로젝트를 추가하려면 변경사항을 제출하기 전에 <a href=/contribute/style/content-guide/#third-party-content>콘텐츠 가이드</a>를 읽어본다.</div>
<ul>
<li><a href=https://juju.is/>Charmed Operator Framework</a></li>
<li><a href=https://book.kubebuilder.io/>kubebuilder</a> 사용하기</li>
<li><a href=https://buehler.github.io/dotnet-operator-sdk/>KubeOps</a> (.NET 오퍼레이터 SDK)</li>
<li><a href=https://kudo.dev/>KUDO</a> (Kubernetes Universal Declarative Operator)</li>
<li>웹훅(WebHook)과 함께 <a href=https://metacontroller.github.io/metacontroller/intro.html>Metacontroller</a>를
사용하여 직접 구현하기</li>
<li><a href=https://operatorframework.io>오퍼레이터 프레임워크</a></li>
<li><a href=https://github.com/flant/shell-operator>shell-operator</a></li>
</ul>
<h2 id=다음-내용>다음 내용</h2>
<ul>
<li><a class=glossary-tooltip title="Cloud Native Computing Foundation" data-toggle=tooltip data-placement=top href=https://cncf.io/ target=_blank aria-label=CNCF>CNCF</a> <a href=https://github.com/cncf/tag-app-delivery/blob/eece8f7307f2970f46f100f51932db106db46968/operator-wg/whitepaper/Operator-WhitePaper_v1-0.md>오퍼레이터 백서</a> 읽어보기</li>
<li><a href=/ko/docs/concepts/extend-kubernetes/api-extension/custom-resources/>사용자 정의 리소스</a>에 대해 더 알아보기</li>
<li><a href=https://operatorhub.io/>OperatorHub.io</a>에서 유스케이스에 맞는 이미 만들어진 오퍼레이터 찾기</li>
<li>다른 사람들이 사용할 수 있도록 자신의 오퍼레이터를 <a href=https://operatorhub.io/>게시</a>하기</li>
<li>오퍼레이터 패턴을 소개한 <a href=https://web.archive.org/web/20170129131616/https://coreos.com/blog/introducing-operators.html>CoreOS 원본 글</a> 읽기 (이 링크는 원본 글에 대한 보관 버전임)</li>
<li>오퍼레이터 구축을 위한 모범 사례에 대한 구글 클라우드(Google Cloud)의 <a href=https://cloud.google.com/blog/products/containers-kubernetes/best-practices-for-building-kubernetes-operators-and-stateful-apps>기사</a> 읽기</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-c8937cdc9df96f3328becf04f8211292>12.3 - 컴퓨트, 스토리지 및 네트워킹 익스텐션</h1>
</div>
<div class=td-content>
<h1 id=pg-1ac2260db9ecccbf0303a899bc27ce6d>12.3.1 - 네트워크 플러그인</h1>
<p>쿠버네티스의 네트워크 플러그인은 몇 가지 종류가 있다.</p>
<ul>
<li>CNI 플러그인: 상호 운용성을 위해 설계된 <a href=https://github.com/containernetworking/cni>컨테이너 네트워크 인터페이스</a>(CNI) 명세를 준수한다.</li>
<li>쿠버네티스는 CNI 명세의 <a href=https://github.com/containernetworking/cni/blob/spec-v0.4.0/SPEC.md>v0.4.0</a> 릴리스를 따른다.</li>
<li>Kubenet 플러그인: <code>bridge</code> 와 <code>host-local</code> CNI 플러그인을 사용하여 기본 <code>cbr0</code> 구현한다.</li>
</ul>
<h2 id=설치>설치</h2>
<p>kubelet에는 단일 기본 네트워크 플러그인과 전체 클러스터에 공통된 기본 네트워크가 있다. 플러그인은 시작할 때 플러그인을 검색하고, 찾은 것을 기억하며, 파드 라이프사이클에서 적절한 시간에 선택한 플러그인을 실행한다(CRI는 자체 CNI 플러그인을 관리하므로 도커에만 해당됨). 플러그인 사용 시 명심해야 할 두 가지 Kubelet 커맨드라인 파라미터가 있다.</p>
<ul>
<li><code>cni-bin-dir</code>: Kubelet은 시작할 때 플러그인에 대해 이 디렉터리를 검사한다.</li>
<li><code>network-plugin</code>: <code>cni-bin-dir</code> 에서 사용할 네트워크 플러그인. 플러그인 디렉터리에서 검색한 플러그인이 보고된 이름과 일치해야 한다. CNI 플러그인의 경우, 이는 "cni"이다.</li>
</ul>
<h2 id=네트워크-플러그인-요구-사항>네트워크 플러그인 요구 사항</h2>
<p>파드 네트워킹을 구성하고 정리하기 위해 <a href=https://github.com/kubernetes/kubernetes/tree/v1.23.17/pkg/kubelet/dockershim/network/plugins.go><code>NetworkPlugin</code> 인터페이스</a>를 제공하는 것 외에도, 플러그인은 kube-proxy에 대한 특정 지원이 필요할 수 있다. iptables 프록시는 분명히 iptables에 의존하며, 플러그인은 컨테이너 트래픽이 iptables에 사용 가능하도록 해야 한다. 예를 들어, 플러그인이 컨테이너를 리눅스 브릿지에 연결하는 경우, 플러그인은 <code>net/bridge/bridge-nf-call-iptables</code> sysctl을 <code>1</code> 로 설정하여 iptables 프록시가 올바르게 작동하는지 확인해야 한다. 플러그인이 리눅스 브리지를 사용하지 않는 경우(그러나 Open vSwitch나 다른 메커니즘과 같은 기능을 사용함) 컨테이너 트래픽이 프록시에 대해 적절하게 라우팅되도록 해야 한다.</p>
<p>kubelet 네트워크 플러그인이 지정되지 않은 경우, 기본적으로 <code>noop</code> 플러그인이 사용되며, <code>net/bridge/bridge-nf-call-iptables=1</code> 을 설정하여 간단한 구성(브릿지가 있는 도커 등)이 iptables 프록시에서 올바르게 작동하도록 한다.</p>
<h3 id=cni>CNI</h3>
<p>CNI 플러그인은 Kubelet에 <code>--network-plugin=cni</code> 커맨드라인 옵션을 전달하여 선택된다. Kubelet은 <code>--cni-conf-dir</code>(기본값은 <code>/etc/cni/net.d</code>)에서 파일을 읽고 해당 파일의 CNI 구성을 사용하여 각 파드의 네트워크를 설정한다. CNI 구성 파일은 <a href=https://github.com/containernetworking/cni/blob/master/SPEC.md#network-configuration>CNI 명세</a>와 일치해야 하며, 구성에서 참조하는 필수 CNI 플러그인은 <code>--cni-bin-dir</code>(기본값은 <code>/opt/cni/bin</code>)에 있어야 한다.</p>
<p>디렉터리에 여러 CNI 구성 파일이 있는 경우, kubelet은 이름별 알파벳 순으로 구성 파일을 사용한다.</p>
<p>구성 파일에 지정된 CNI 플러그인 외에도, 쿠버네티스는 최소 0.2.0 버전의 표준 CNI <a href=https://github.com/containernetworking/plugins/blob/master/plugins/main/loopback/loopback.go><code>lo</code></a> 플러그인이 필요하다.</p>
<h4 id=hostport-지원>hostPort 지원</h4>
<p>CNI 네트워킹 플러그인은 <code>hostPort</code> 를 지원한다. CNI 플러그인 팀이 제공하는 공식 <a href=https://github.com/containernetworking/plugins/tree/master/plugins/meta/portmap>포트맵(portmap)</a>
플러그인을 사용하거나 portMapping 기능이 있는 자체 플러그인을 사용할 수 있다.</p>
<p><code>hostPort</code> 지원을 사용하려면, <code>cni-conf-dir</code> 에 <code>portMappings capability</code> 를 지정해야 한다.
예를 들면 다음과 같다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
  <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;k8s-pod-network&#34;</span>,
  <span style=color:green;font-weight:700>&#34;cniVersion&#34;</span>: <span style=color:#b44>&#34;0.3.0&#34;</span>,
  <span style=color:green;font-weight:700>&#34;plugins&#34;</span>: [
    {
      <span style=color:green;font-weight:700>&#34;type&#34;</span>: <span style=color:#b44>&#34;calico&#34;</span>,
      <span style=color:green;font-weight:700>&#34;log_level&#34;</span>: <span style=color:#b44>&#34;info&#34;</span>,
      <span style=color:green;font-weight:700>&#34;datastore_type&#34;</span>: <span style=color:#b44>&#34;kubernetes&#34;</span>,
      <span style=color:green;font-weight:700>&#34;nodename&#34;</span>: <span style=color:#b44>&#34;127.0.0.1&#34;</span>,
      <span style=color:green;font-weight:700>&#34;ipam&#34;</span>: {
        <span style=color:green;font-weight:700>&#34;type&#34;</span>: <span style=color:#b44>&#34;host-local&#34;</span>,
        <span style=color:green;font-weight:700>&#34;subnet&#34;</span>: <span style=color:#b44>&#34;usePodCidr&#34;</span>
      },
      <span style=color:green;font-weight:700>&#34;policy&#34;</span>: {
        <span style=color:green;font-weight:700>&#34;type&#34;</span>: <span style=color:#b44>&#34;k8s&#34;</span>
      },
      <span style=color:green;font-weight:700>&#34;kubernetes&#34;</span>: {
        <span style=color:green;font-weight:700>&#34;kubeconfig&#34;</span>: <span style=color:#b44>&#34;/etc/cni/net.d/calico-kubeconfig&#34;</span>
      }
    },
    {
      <span style=color:green;font-weight:700>&#34;type&#34;</span>: <span style=color:#b44>&#34;portmap&#34;</span>,
      <span style=color:green;font-weight:700>&#34;capabilities&#34;</span>: {<span style=color:green;font-weight:700>&#34;portMappings&#34;</span>: <span style=color:#a2f;font-weight:700>true</span>}
    }
  ]
}
</code></pre></div><h4 id=트래픽-셰이핑-지원>트래픽 셰이핑 지원</h4>
<p><strong>실험적인 기능입니다</strong></p>
<p>CNI 네트워킹 플러그인은 파드 수신 및 송신 트래픽 셰이핑도 지원한다. CNI 플러그인 팀에서 제공하는 공식 <a href=https://github.com/containernetworking/plugins/tree/master/plugins/meta/bandwidth>대역폭(bandwidth)</a>
플러그인을 사용하거나 대역폭 제어 기능이 있는 자체 플러그인을 사용할 수 있다.</p>
<p>트래픽 셰이핑 지원을 활성화하려면, CNI 구성 파일 (기본값 <code>/etc/cni/net.d</code>)에 <code>bandwidth</code> 플러그인을
추가하고, 바이너리가 CNI 실행 파일 디렉터리(기본값: <code>/opt/cni/bin</code>)에 포함되어 있는지 확인한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
  <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;k8s-pod-network&#34;</span>,
  <span style=color:green;font-weight:700>&#34;cniVersion&#34;</span>: <span style=color:#b44>&#34;0.3.0&#34;</span>,
  <span style=color:green;font-weight:700>&#34;plugins&#34;</span>: [
    {
      <span style=color:green;font-weight:700>&#34;type&#34;</span>: <span style=color:#b44>&#34;calico&#34;</span>,
      <span style=color:green;font-weight:700>&#34;log_level&#34;</span>: <span style=color:#b44>&#34;info&#34;</span>,
      <span style=color:green;font-weight:700>&#34;datastore_type&#34;</span>: <span style=color:#b44>&#34;kubernetes&#34;</span>,
      <span style=color:green;font-weight:700>&#34;nodename&#34;</span>: <span style=color:#b44>&#34;127.0.0.1&#34;</span>,
      <span style=color:green;font-weight:700>&#34;ipam&#34;</span>: {
        <span style=color:green;font-weight:700>&#34;type&#34;</span>: <span style=color:#b44>&#34;host-local&#34;</span>,
        <span style=color:green;font-weight:700>&#34;subnet&#34;</span>: <span style=color:#b44>&#34;usePodCidr&#34;</span>
      },
      <span style=color:green;font-weight:700>&#34;policy&#34;</span>: {
        <span style=color:green;font-weight:700>&#34;type&#34;</span>: <span style=color:#b44>&#34;k8s&#34;</span>
      },
      <span style=color:green;font-weight:700>&#34;kubernetes&#34;</span>: {
        <span style=color:green;font-weight:700>&#34;kubeconfig&#34;</span>: <span style=color:#b44>&#34;/etc/cni/net.d/calico-kubeconfig&#34;</span>
      }
    },
    {
      <span style=color:green;font-weight:700>&#34;type&#34;</span>: <span style=color:#b44>&#34;bandwidth&#34;</span>,
      <span style=color:green;font-weight:700>&#34;capabilities&#34;</span>: {<span style=color:green;font-weight:700>&#34;bandwidth&#34;</span>: <span style=color:#a2f;font-weight:700>true</span>}
    }
  ]
}
</code></pre></div><p>이제 파드에 <code>kubernetes.io/ingress-bandwidth</code> 와 <code>kubernetes.io/egress-bandwidth</code> 어노테이션을 추가할 수 있다.
예를 들면 다음과 같다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubernetes.io/ingress-bandwidth</span>:<span style=color:#bbb> </span>1M<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubernetes.io/egress-bandwidth</span>:<span style=color:#bbb> </span>1M<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></code></pre></div><h3 id=kubenet>kubenet</h3>
<p>Kubenet은 리눅스에서만 사용할 수 있는 매우 기본적이고, 간단한 네트워크 플러그인이다. 그 자체로는, 크로스-노드 네트워킹 또는 네트워크 정책과 같은 고급 기능을 구현하지 않는다. 일반적으로 노드 간, 또는 단일 노드 환경에서 통신을 위한 라우팅 규칙을 설정하는 클라우드 제공자와 함께 사용된다.</p>
<p>Kubenet은 <code>cbr0</code> 라는 리눅스 브리지를 만들고 각 쌍의 호스트 끝이 <code>cbr0</code> 에 연결된 각 파드에 대한 veth 쌍을 만든다. 쌍의 파드 끝에는 구성 또는 컨트롤러 관리자를 통해 노드에 할당된 범위 내에서 할당된 IP 주소가 지정된다. <code>cbr0</code> 에는 호스트에서 활성화된 일반 인터페이스의 가장 작은 MTU와 일치하는 MTU가 지정된다.</p>
<p>플러그인에는 몇 가지 사항이 필요하다.</p>
<ul>
<li>표준 CNI <code>bridge</code>, <code>lo</code> 및 <code>host-local</code> 플러그인은 최소 0.2.0 버전이 필요하다. Kubenet은 먼저 <code>/opt/cni/bin</code> 에서 검색한다. 추가 검색 경로를 제공하려면 <code>cni-bin-dir</code> 을 지정한다. 처음 검색된 디렉터리가 적용된다.</li>
<li>플러그인을 활성화하려면 Kubelet을 <code>--network-plugin=kubenet</code> 인수와 함께 실행해야 한다.</li>
<li>Kubelet은 <code>--non-masquerade-cidr=&lt;clusterCidr></code> 인수와 함께 실행하여 이 범위 밖 IP로의 트래픽이 IP 마스커레이드(masquerade)를 사용하도록 해야 한다.</li>
<li><code>--pod-cidr</code> kubelet 커맨드라인 옵션 또는 <code>--allocate-node-cidrs=true --cluster-cidr=&lt;cidr></code> 컨트롤러 관리자 커맨드라인 옵션을 통해 노드에 IP 서브넷을 할당해야 한다.</li>
</ul>
<h3 id=mtu-사용자-정의-kubenet-사용>MTU 사용자 정의 (kubenet 사용)</h3>
<p>최상의 네트워킹 성능을 얻으려면 MTU를 항상 올바르게 구성해야 한다. 네트워크 플러그인은 일반적으로 합리적인 MTU를
유추하려고 시도하지만, 때로는 로직에 따라 최적의 MTU가 지정되지 않는다. 예를 들어,
도커 브리지나 다른 인터페이스에 작은 MTU가 지정되어 있으면, kubenet은 현재 해당 MTU를 선택한다. 또는
IPSEC 캡슐화를 사용하는 경우, MTU를 줄여야 하며, 이 계산은 대부분의
네트워크 플러그인에서 범위를 벗어난다.</p>
<p>필요한 경우, <code>network-plugin-mtu</code> kubelet 옵션을 사용하여 MTU를 명시 적으로 지정할 수 있다. 예를 들어,
AWS에서 <code>eth0</code> MTU는 일반적으로 9001이므로, <code>--network-plugin-mtu=9001</code> 을 지정할 수 있다. IPSEC를 사용하는 경우
캡슐화 오버헤드를 허용하도록 <code>--network-plugin-mtu=8873</code> 과 같이 IPSEC을 줄일 수 있다.</p>
<p>이 옵션은 네트워크 플러그인에 제공된다. 현재 <strong>kubenet만 <code>network-plugin-mtu</code> 를 지원한다</strong>.</p>
<h2 id=용법-요약>용법 요약</h2>
<ul>
<li><code>--network-plugin=cni</code> 는 <code>--cni-bin-dir</code>(기본값 <code>/opt/cni/bin</code>)에 있는 실제 CNI 플러그인 바이너리와 <code>--cni-conf-dir</code>(기본값 <code>/etc/cni/net.d</code>)에 있는 CNI 플러그인 구성과 함께 <code>cni</code> 네트워크 플러그인을 사용하도록 지정한다.</li>
<li><code>--network-plugin=kubenet</code> 은 <code>/opt/cni/bin</code> 또는 <code>cni-bin-dir</code> 에 있는 CNI <code>bridge</code>, <code>lo</code> 및 <code>host-local</code> 플러그인과 함께 <code>kubenet</code> 네트워크 플러그인을 사용하도록 지정한다.</li>
<li>현재 kubenet 네트워크 플러그인에서만 사용하는 <code>--network-plugin-mtu=9001</code> 은 사용할 MTU를 지정한다.</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-53e1ea8892ceca307ba19e8d6a7b8d32>12.3.2 - 장치 플러그인</h1>
<div class=lead>장치 플러그인을 사용하여 GPU, NIC, FPGA, 또는 비휘발성 주 메모리와 같이 공급 업체별 설정이 필요한 장치 또는 리소스를 클러스터에서 지원하도록 설정할 수 있다.</div>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.10 [beta]</code>
</div>
<p>쿠버네티스는 시스템 하드웨어 리소스를 <a class=glossary-tooltip title="클러스터의 각 노드에서 실행되는 에이전트. Kubelet은 파드에서 컨테이너가 확실하게 동작하도록 관리한다." data-toggle=tooltip data-placement=top href=/docs/reference/generated/kubelet target=_blank aria-label=Kubelet>Kubelet</a>에 알리는 데 사용할 수 있는
<a href=https://github.com/kubernetes/community/blob/master/contributors/design-proposals/resource-management/device-plugin.md>장치 플러그인 프레임워크</a>를
제공한다.</p>
<p>공급 업체는 쿠버네티스 자체의 코드를 커스터마이징하는 대신, 수동 또는
<a class=glossary-tooltip title="파드의 복제본을 클러스터 노드 집합에서 동작하게 한다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/controllers/daemonset target=_blank aria-label=데몬셋>데몬셋</a>으로 배포하는 장치 플러그인을 구현할 수 있다.
대상이 되는 장치에는 GPU, 고성능 NIC, FPGA, InfiniBand 어댑터
및 공급 업체별 초기화 및 설정이 필요할 수 있는 기타 유사한 컴퓨팅 리소스가
포함된다.</p>
<h2 id=장치-플러그인-등록>장치 플러그인 등록</h2>
<p>kubelet은 <code>Registration</code> gRPC 서비스를 노출시킨다.</p>
<pre><code class=language-gRPC data-lang=gRPC>service Registration {
	rpc Register(RegisterRequest) returns (Empty) {}
}
</code></pre><p>장치 플러그인은 이 gRPC 서비스를 통해 kubelet에 자체 등록할 수 있다.
등록하는 동안, 장치 플러그인은 다음을 보내야 한다.</p>
<ul>
<li>유닉스 소켓의 이름.</li>
<li>빌드된 장치 플러그인 API 버전.</li>
<li>알리려는 <code>ResourceName</code>. 여기서 <code>ResourceName</code> 은
<a href=/ko/docs/concepts/configuration/manage-resources-containers/#%ED%99%95%EC%9E%A5%EB%90%9C-%EB%A6%AC%EC%86%8C%EC%8A%A4>확장된 리소스 네이밍 체계</a>를
<code>vendor-domain/resourcetype</code> 의 형식으로 따라야 한다.
(예를 들어, NVIDIA GPU는 <code>nvidia.com/gpu</code> 로 알려진다.)</li>
</ul>
<p>성공적으로 등록하고 나면, 장치 플러그인은 kubelet이 관리하는
장치 목록을 전송한 다음, kubelet은 kubelet 노드 상태 업데이트의 일부로
해당 자원을 API 서버에 알리는 역할을 한다.
예를 들어, 장치 플러그인이 kubelet에 <code>hardware-vendor.example/foo</code> 를 등록하고
노드에 두 개의 정상 장치를 보고하고 나면, 노드 상태가 업데이트되어
노드에 2개의 "Foo" 장치가 설치되어 사용 가능함을 알릴 수 있다.</p>
<p>그러고 나면, 사용자가 장치를 파드 스펙의 일부로 요청할 수
있다(<a href=/docs/reference/kubernetes-api/workload-resources/pod-v1/#Container><code>container</code></a> 참조).
확장 리소스를 요청하는 것은 다른 자원의 요청 및 제한을 관리하는 것과 비슷하지만,
다음과 같은 차이점이 존재한다.</p>
<ul>
<li>확장된 리소스는 정수(integer) 형태만 지원되며 오버커밋(overcommit) 될 수 없다.</li>
<li>컨테이너간에 장치를 공유할 수 없다.</li>
</ul>
<h3 id=example-pod>예제</h3>
<p>쿠버네티스 클러스터가 특정 노드에서 <code>hardware-vendor.example/foo</code> 리소스를 알리는 장치 플러그인을 실행한다고
가정해 보자. 다음은 데모 워크로드를 실행하기 위해 이 리소스를 요청하는 파드의 예이다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>demo-pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>demo-container-1<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/pause:2.0<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>hardware-vendor.example/foo</span>:<span style=color:#bbb> </span><span style=color:#666>2</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic>#</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># 이 파드는 2개의 hardware-vendor.example/foo 장치가 필요하며</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># 해당 요구를 충족할 수 있는 노드에만</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># 예약될 수 있다.</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic>#</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># 노드에 2개 이상의 사용 가능한 장치가 있는 경우</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># 나머지는 다른 파드에서 사용할 수 있다.</span><span style=color:#bbb>
</span></code></pre></div><h2 id=장치-플러그인-구현>장치 플러그인 구현</h2>
<p>장치 플러그인의 일반적인 워크플로우에는 다음 단계가 포함된다.</p>
<ul>
<li>
<p>초기화. 이 단계에서, 장치 플러그인은 공급 업체별 초기화 및 설정을 수행하여
장치가 준비 상태에 있는지 확인한다.</p>
</li>
<li>
<p>플러그인은 다음의 인터페이스를 구현하는 호스트 경로 <code>/var/lib/kubelet/device-plugins/</code>
아래에 유닉스 소켓과 함께 gRPC 서비스를 시작한다.</p>
<pre><code class=language-gRPC data-lang=gRPC>service DevicePlugin {
          // GetDevicePluginOptions는 장치 관리자와 통신할 옵션을 반환한다.
      rpc GetDevicePluginOptions(Empty) returns (DevicePluginOptions) {}

          // ListAndWatch는 장치 목록 스트림을 반환한다.
          // 장치 상태가 변경되거나 장치가 사라질 때마다, ListAndWatch는
          // 새 목록을 반환한다.
      rpc ListAndWatch(Empty) returns (stream ListAndWatchResponse) {}

              // 컨테이너를 생성하는 동안 Allocate가 호출되어 장치
              // 플러그인이 장치별 작업을 실행하고 Kubelet에 장치를
              // 컨테이너에서 사용할 수 있도록 하는 단계를 지시할 수 있다.
      rpc Allocate(AllocateRequest) returns (AllocateResponse) {}

      // GetPreferredAllocation은 사용 가능한 장치 목록에서 할당할
              // 기본 장치 집합을 반환한다. 그 결과로 반환된 선호하는 할당은
              // devicemanager가 궁극적으로 수행하는 할당이 되는 것을 보장하지
              // 않는다. 가능한 경우 devicemanager가 정보에 입각한 할당 결정을
              // 내릴 수 있도록 설계되었다.
      rpc GetPreferredAllocation(PreferredAllocationRequest) returns (PreferredAllocationResponse) {}

      // PreStartContainer는 등록 단계에서 장치 플러그인에 의해 표시되면 각 컨테이너가
              // 시작되기 전에 호출된다. 장치 플러그인은 장치를 컨테이너에서 사용할 수 있도록 하기 전에
              // 장치 재설정과 같은 장치별 작업을 실행할 수 있다.
      rpc PreStartContainer(PreStartContainerRequest) returns (PreStartContainerResponse) {}
}
</code></pre><div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> <code>GetPreferredAllocation()</code> 또는 <code>PreStartContainer()</code> 에 대한 유용한 구현을
제공하기 위해 플러그인이 필요하지 않다. 이러한 호출(있는 경우) 중
사용할 수 있는 경우를 나타내는 플래그는 <code>GetDevicePluginOptions()</code>
호출에 의해 다시 전송된 <code>DevicePluginOptions</code> 메시지에 설정되어야 한다. <code>kubelet</code> 은
항상 <code>GetDevicePluginOptions()</code> 를 호출하여 사용할 수 있는
선택적 함수를 확인한 후 직접 호출한다.
</div>
</li>
<li>
<p>플러그인은 호스트 경로 <code>/var/lib/kubelet/device-plugins/kubelet.sock</code> 에서
유닉스 소켓을 통해 kubelet에 직접 등록한다.</p>
</li>
<li>
<p>성공적으로 등록하고 나면, 장치 플러그인은 서빙(serving) 모드에서 실행되며, 그 동안 플러그인은 장치 상태를
모니터링하고 장치 상태 변경 시 kubelet에 다시 보고한다.
또한 gRPC 요청 <code>Allocate</code> 를 담당한다. <code>Allocate</code> 하는 동안, 장치 플러그인은
GPU 정리 또는 QRNG 초기화와 같은 장치별 준비를 수행할 수 있다.
작업이 성공하면, 장치 플러그인은 할당된 장치에 접근하기 위한 컨테이너 런타임 구성이 포함된
<code>AllocateResponse</code> 를 반환한다. kubelet은 이 정보를
컨테이너 런타임에 전달한다.</p>
</li>
</ul>
<h3 id=kubelet-재시작-처리>kubelet 재시작 처리</h3>
<p>장치 플러그인은 일반적으로 kubelet의 재시작을 감지하고 새로운
kubelet 인스턴스에 자신을 다시 등록할 것으로 기대된다. 현재의 구현에서, 새 kubelet 인스턴스는 시작될 때
<code>/var/lib/kubelet/device-plugins</code> 아래에 있는 모든 기존의 유닉스 소켓을 삭제한다. 장치 플러그인은 유닉스 소켓의
삭제를 모니터링하고 이러한 이벤트가 발생하면 다시 자신을 등록할 수 있다.</p>
<h2 id=장치-플러그인-배포>장치 플러그인 배포</h2>
<p>장치 플러그인을 데몬셋, 노드 운영 체제의 패키지
또는 수동으로 배포할 수 있다.</p>
<p>표준 디렉터리 <code>/var/lib/kubelet/device-plugins</code> 에는 특권을 가진 접근이 필요하므로,
장치 플러그인은 특권을 가진 보안 컨텍스트에서 실행해야 한다.
장치 플러그인을 데몬셋으로 배포하는 경우, 플러그인의
<a href=/docs/reference/generated/kubernetes-api/v1.23/#podspec-v1-core>PodSpec</a>에서
<code>/var/lib/kubelet/device-plugins</code> 를
<a class=glossary-tooltip title="데이터를 포함하고 있는 디렉터리이며, 파드의 컨테이너에서 접근 가능하다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/storage/volumes/ target=_blank aria-label=볼륨>볼륨</a>으로 마운트해야 한다.</p>
<p>데몬셋 접근 방식을 선택하면 쿠버네티스를 사용하여 장치 플러그인의 파드를 노드에 배치하고,
장애 후 데몬 파드를 다시 시작하고, 업그레이드를 자동화할 수 있다.</p>
<h2 id=api-호환성>API 호환성</h2>
<p>쿠버네티스 장치 플러그인 지원은 베타 버전이다. 호환되지 않는 방식으로 안정화 전에 API가
변경될 수 있다. 프로젝트로서, 쿠버네티스는 장치 플러그인 개발자에게 다음 사항을 권장한다.</p>
<ul>
<li>향후 릴리스에서 변경 사항을 확인하자.</li>
<li>이전/이후 버전과의 호환성을 위해 여러 버전의 장치 플러그인 API를 지원한다.</li>
</ul>
<p>최신 장치 플러그인 API 버전의 쿠버네티스 릴리스로 업그레이드해야 하는 노드에서 DevicePlugins 기능을 활성화하고
장치 플러그인을 실행하는 경우, 이 노드를 업그레이드하기 전에
두 버전을 모두 지원하도록 장치 플러그인을 업그레이드한다. 이 방법을 사용하면
업그레이드 중에 장치 할당이 지속적으로 작동한다.</p>
<h2 id=장치-플러그인-리소스-모니터링>장치 플러그인 리소스 모니터링</h2>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.15 [beta]</code>
</div>
<p>장치 플러그인에서 제공하는 리소스를 모니터링하려면, 모니터링 에이전트가
노드에서 사용 중인 장치 셋을 검색하고 메트릭과 연관될 컨테이너를 설명하는
메타데이터를 얻을 수 있어야 한다. 장치 모니터링 에이전트에 의해 노출된
<a href=https://prometheus.io/>프로메테우스</a> 지표는
<a href=https://github.com/kubernetes/community/blob/master/contributors/devel/sig-instrumentation/instrumentation.md>쿠버네티스 Instrumentation 가이드라인</a>을 따라
<code>pod</code>, <code>namespace</code> 및 <code>container</code> 프로메테우스 레이블을 사용하여 컨테이너를 식별해야 한다.</p>
<p>kubelet은 gRPC 서비스를 제공하여 사용 중인 장치를 검색하고, 이러한 장치에 대한 메타데이터를
제공한다.</p>
<pre><code class=language-gRPC data-lang=gRPC>// PodResourcesLister는 kubelet에서 제공하는 서비스로, 노드의 포드 및 컨테이너가
// 사용한 노드 리소스에 대한 정보를 제공한다.
service PodResourcesLister {
    rpc List(ListPodResourcesRequest) returns (ListPodResourcesResponse) {}
    rpc GetAllocatableResources(AllocatableResourcesRequest) returns (AllocatableResourcesResponse) {}
}
</code></pre><h3 id=grpc-endpoint-list><code>List</code> gRPC 엔드포인트</h3>
<p><code>List</code> 엔드포인트는 실행 중인 파드의 리소스에 대한 정보를 제공하며,
독점적으로 할당된 CPU의 ID, 장치 플러그인에 의해 보고된 장치 ID,
이러한 장치가 할당된 NUMA 노드의 ID와 같은 세부 정보를 함께 제공한다. 또한, NUMA 기반 머신의 경우, 컨테이너를 위해 예약된 메모리와 hugepage에 대한 정보를 포함한다.</p>
<pre><code class=language-gRPC data-lang=gRPC>// ListPodResourcesResponse는 List 함수가 반환하는 응답이다.
message ListPodResourcesResponse {
    repeated PodResources pod_resources = 1;
}

// PodResources에는 파드에 할당된 노드 리소스에 대한 정보가 포함된다.
message PodResources {
    string name = 1;
    string namespace = 2;
    repeated ContainerResources containers = 3;
}

// ContainerResources는 컨테이너에 할당된 리소스에 대한 정보를 포함한다.
message ContainerResources {
    string name = 1;
    repeated ContainerDevices devices = 2;
    repeated int64 cpu_ids = 3;
    repeated ContainerMemory memory = 4;
}

// ContainerMemory는 컨테이너에 할당된 메모리와 hugepage에 대한 정보를 포함한다.
message ContainerMemory {
    string memory_type = 1;
    uint64 size = 2;
    TopologyInfo topology = 3;
}

// 토폴로지는 리소스의 하드웨어 토폴로지를 설명한다.
message TopologyInfo {
        repeated NUMANode nodes = 1;
}

// NUMA 노드의 NUMA 표현
message NUMANode {
        int64 ID = 1;
}

// ContainerDevices는 컨테이너에 할당된 장치에 대한 정보를 포함한다.
message ContainerDevices {
    string resource_name = 1;
    repeated string device_ids = 2;
    TopologyInfo topology = 3;
}
</code></pre><div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> <p><code>List</code> 엔드포인트의 <code>ContainerResources</code> 내부에 있는 cpu_ids은 특정 컨테이너에 할당된
독점 CPU들에 해당한다. 만약 공유 풀(shared pool)에 있는 CPU들을 확인(evaluate)하는 것이 목적이라면, 해당 <code>List</code>
엔드포인트는 다음에 설명된 것과 같이, <code>GetAllocatableResources</code> 엔드포인트와 함께 사용되어야
한다.</p>
<ol>
<li><code>GetAllocatableResources</code>를 호출하여 할당 가능한 모든 CPU 목록을 조회</li>
<li>시스템의 모든 <code>ContainerResources</code>에서 <code>GetCpuIds</code>를 호출</li>
<li><code>GetAllocateableResources</code> 호출에서 <code>GetCpuIds</code> 호출로 얻은 모든 CPU를 빼기</li>
</ol>
</div>
<h3 id=grpc-endpoint-getallocatableresources><code>GetAllocatableResources</code> gRPC 엔드포인트</h3>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.23 [beta]</code>
</div>
<p>GetAllocatableResources는 워커 노드에서 처음 사용할 수 있는 리소스에 대한 정보를 제공한다.
kubelet이 APIServer로 내보내는 것보다 더 많은 정보를 제공한다.</p>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> <code>GetAllocatableResources</code>는 <a href=/docs/tasks/administer-cluster/reserve-compute-resources/#node-allocatable>할당 가능(allocatable)</a> 리소스를 확인(evaluate)하기 위해서만
사용해야 한다. 만약 목적이 free/unallocated 리소스를 확인하기 위한 것이라면
List() 엔드포인트와 함께 사용되어야 한다. <code>GetAllocableResources</code>로 얻은 결과는 kubelet에
노출된 기본 리소스가 변경되지 않는 한 동일하게 유지된다. 이러한 변경은 드물지만, 발생하게 된다면
(예를 들면: hotplug/hotunplug, 장치 상태 변경) 클라이언트가 <code>GetAlloctableResources</code> 엔드포인트를
호출할 것으로 가정한다.
그러나 CPU 및/또는 메모리가 갱신된 경우 <code>GetAllocateableResources</code> 엔드포인트를 호출하는 것만으로는
충분하지 않으며, Kubelet을 다시 시작하여 올바른 리소스 용량과 할당 가능(allocatable) 리소스를 반영해야 한다.
</div>
<pre><code class=language-gRPC data-lang=gRPC>// AllocatableResourcesResponses에는 kubelet이 알고 있는 모든 장치에 대한 정보가 포함된다.
message AllocatableResourcesResponse {
    repeated ContainerDevices devices = 1;
    repeated int64 cpu_ids = 2;
    repeated ContainerMemory memory = 3;
}

</code></pre><p>쿠버네티스 v1.23부터, <code>GetAllocatableResources</code>가 기본으로 활성화된다.
이를 비활성화하려면 <code>KubeletPodResourcesGetAllocatable</code> <a href=/ko/docs/reference/command-line-tools-reference/feature-gates/>기능 게이트(feature gate)</a>를
끄면 된다.</p>
<p>쿠버네티스 v1.23 이전 버전에서 이 기능을 활성화하려면 <code>kubelet</code>이 다음 플래그를 가지고 시작되어야 한다.</p>
<p><code>--feature-gates=KubeletPodResourcesGetAllocatable=true</code></p>
<p><code>ContainerDevices</code> 는 장치가 어떤 NUMA 셀과 연관되는지를 선언하는 토폴로지 정보를 노출한다.
NUMA 셀은 불분명한(opaque) 정수 ID를 사용하여 식별되며, 이 값은
<a href=/ko/docs/concepts/extend-kubernetes/compute-storage-net/device-plugins/#%ED%86%A0%ED%8F%B4%EB%A1%9C%EC%A7%80-%EA%B4%80%EB%A6%AC%EC%9E%90%EB%A1%9C-%EC%9E%A5%EC%B9%98-%ED%94%8C%EB%9F%AC%EA%B7%B8%EC%9D%B8-%ED%86%B5%ED%95%A9>kubelet에 등록할 때</a> 장치 플러그인이 보고하는 것과 일치한다.</p>
<p>gRPC 서비스는 <code>/var/lib/kubelet/pod-resources/kubelet.sock</code> 의 유닉스 소켓을 통해 제공된다.
장치 플러그인 리소스에 대한 모니터링 에이전트는 데몬 또는 데몬셋으로 배포할 수 있다.
표준 디렉터리 <code>/var/lib/kubelet/pod-resources</code> 에는 특권을 가진 접근이 필요하므로, 모니터링
에이전트는 특권을 가진 보안 컨텍스트에서 실행해야 한다. 장치 모니터링 에이전트가
데몬셋으로 실행 중인 경우, 해당 장치 모니터링 에이전트의 <a href=/docs/reference/generated/kubernetes-api/v1.23/#podspec-v1-core>PodSpec</a>에서
<code>/var/lib/kubelet/pod-resources</code> 를
<a class=glossary-tooltip title="데이터를 포함하고 있는 디렉터리이며, 파드의 컨테이너에서 접근 가능하다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/storage/volumes/ target=_blank aria-label=볼륨>볼륨</a>으로 마운트해야 한다.</p>
<p><code>PodResourcesLister service</code> 를 지원하려면 <code>KubeletPodResources</code> <a href=/ko/docs/reference/command-line-tools-reference/feature-gates/>기능 게이트</a>를 활성화해야 한다.
이것은 쿠버네티스 1.15부터 기본으로 활성화되어 있으며, 쿠버네티스 1.20부터는 v1 상태이다.</p>
<h2 id=토폴로지-관리자로-장치-플러그인-통합>토폴로지 관리자로 장치 플러그인 통합</h2>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.18 [beta]</code>
</div>
<p>토폴로지 관리자는 Kubelet 컴포넌트로, 리소스를 토폴로지 정렬 방식으로 조정할 수 있다. 이를 위해, 장치 플러그인 API가 <code>TopologyInfo</code> 구조체를 포함하도록 확장되었다.</p>
<pre><code class=language-gRPC data-lang=gRPC>message TopologyInfo {
	repeated NUMANode nodes = 1;
}

message NUMANode {
    int64 ID = 1;
}
</code></pre><p>토폴로지 관리자를 활용하려는 장치 플러그인은 장치 ID 및 장치의 정상 상태와 함께 장치 등록의 일부로 채워진 TopologyInfo 구조체를 다시 보낼 수 있다. 그런 다음 장치 관리자는 이 정보를 사용하여 토폴로지 관리자와 상의하고 리소스 할당 결정을 내린다.</p>
<p><code>TopologyInfo</code> 는 <code>nil</code>(기본값) 또는 NUMA 노드 목록인 <code>nodes</code> 필드를 지원한다. 이를 통해 NUMA 노드에 걸쳐있을 수 있는 장치 플러그인을 게시할 수 있다.</p>
<p>장치 플러그인으로 장치에 대해 채워진 <code>TopologyInfo</code> 구조체의 예는 다음과 같다.</p>
<pre><code>pluginapi.Device{ID: &quot;25102017&quot;, Health: pluginapi.Healthy, Topology:&amp;pluginapi.TopologyInfo{Nodes: []*pluginapi.NUMANode{&amp;pluginapi.NUMANode{ID: 0,},}}}
</code></pre><h2 id=examples>장치 플러그인 예시</h2>
<div class="alert alert-secondary callout third-party-content" role=alert><strong>참고:</strong>
이 섹션은 쿠버네티스에 필요한 기능을 제공하는 써드파티 프로젝트와 관련이 있다. 쿠버네티스 프로젝트 작성자는 써드파티 프로젝트에 책임이 없다. 이 페이지는 <a href=https://github.com/cncf/foundation/blob/master/website-guidelines.md target=_blank>CNCF 웹사이트 가이드라인</a>에 따라 프로젝트를 알파벳 순으로 나열한다. 이 목록에 프로젝트를 추가하려면 변경사항을 제출하기 전에 <a href=/contribute/style/content-guide/#third-party-content>콘텐츠 가이드</a>를 읽어본다.</div>
<p>다음은 장치 플러그인 구현의 예이다.</p>
<ul>
<li><a href=https://github.com/RadeonOpenCompute/k8s-device-plugin>AMD GPU 장치 플러그인</a></li>
<li>인텔 GPU, FPGA 및 QuickAssist 장치용 <a href=https://github.com/intel/intel-device-plugins-for-kubernetes>인텔 장치 플러그인</a></li>
<li>하드웨어 지원 가상화를 위한 <a href=https://github.com/kubevirt/kubernetes-device-plugins>KubeVirt 장치 플러그인</a></li>
<li><a href=https://github.com/NVIDIA/k8s-device-plugin>NVIDIA GPU 장치 플러그인</a>
<ul>
<li>GPU를 지원하는 Docker 컨테이너를 실행할 수 있는 <a href=https://github.com/NVIDIA/nvidia-docker>nvidia-docker</a> 2.0이 필요하다.</li>
</ul>
</li>
<li><a href=https://github.com/GoogleCloudPlatform/container-engine-accelerators/tree/master/cmd/nvidia_gpu>컨테이너에 최적화된 OS를 위한 NVIDIA GPU 장치 플러그인</a></li>
<li><a href=https://github.com/hustcat/k8s-rdma-device-plugin>RDMA 장치 플러그인</a></li>
<li><a href=https://github.com/vikaschoudhary16/sfc-device-plugin>Solarflare 장치 플러그인</a></li>
<li><a href=https://github.com/intel/sriov-network-device-plugin>SR-IOV 네트워크 장치 플러그인</a></li>
<li>Xilinx FPGA 장치용 <a href=https://github.com/Xilinx/FPGA_as_a_Service/tree/master/k8s-fpga-device-plugin>Xilinx FPGA 장치 플러그인</a></li>
</ul>
<h2 id=다음-내용>다음 내용</h2>
<ul>
<li>장치 플러그인을 사용한 <a href=/ko/docs/tasks/manage-gpus/scheduling-gpus/>GPU 리소스 스케줄링</a>에 대해 알아보기</li>
<li>노드에서의 <a href=/ko/docs/tasks/administer-cluster/extended-resource-node/>확장 리소스 알리기</a>에 대해 배우기</li>
<li><a href=/docs/tasks/administer-cluster/topology-manager/>토폴로지 관리자</a>에 대해 알아보기</li>
<li>쿠버네티스에서 <a href=/blog/2019/04/24/hardware-accelerated-ssl/tls-termination-in-ingress-controllers-using-kubernetes-device-plugins-and-runtimeclass/>TLS 인그레스에 하드웨어 가속</a> 사용에 대해 읽기</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-b26fcf43d01abc16c8110766026dafed>12.4 - 서비스 카탈로그</h1>
<p><p>서비스 카탈로그는 쿠버네티스 클러스터 내에서 실행되는 응용 프로그램이 클라우드 공급자가 제공하는 데이터 저장소 서비스와 같은 외부 관리 소프트웨어 제품을 쉽게 사용할 수 있도록하는 확장 API이다.</p></p>
<p>서비스 생성 또는 관리에 대한 자세한 지식 없이도 <a class=glossary-tooltip title="서드파티에서 제공하고 유지 관리하는 일련의 매니지드 서비스에 대한 엔드포인트이다." data-toggle=tooltip data-placement=top href="/ko/docs/reference/glossary/?all=true#term-service-broker" target=_blank aria-label="서비스 브로커">서비스 브로커</a>를 통해 외부의 <a class=glossary-tooltip title="타사 공급자가 유지보수하는 소프트웨어." data-toggle=tooltip data-placement=top href="/ko/docs/reference/glossary/?all=true#term-managed-service" target=_blank aria-label="매니지드 서비스">매니지드 서비스</a>의 목록과 프로비전, 바인딩하는 방법을 제공한다.</p>
<p><a href=https://github.com/openservicebrokerapi/servicebroker/blob/v2.13/spec.md>오픈 서비스 브로커 API 명세</a>에 정의된 서비스 브로커는 AWS, GCP 또는 Azure와 같은 타사 클라우드 공급자에 의해 제공되고 관리되는 매니지드 서비스의 세트에 대한 엔드포인트다.
매니지드 서비스의 예로 Microsoft Azure Cloud Queue, Amazon Simple Quere Service, Google Cloud Pub/Sub이 있으나 애플리케이션에서 사용할 수 있는 모든 소프트웨어 제품일 수 있다.</p>
<p><a class=glossary-tooltip title="A person who configures, controls, and monitors clusters." data-toggle=tooltip data-placement=top href="/ko/docs/reference/glossary/?all=true#term-cluster-operator" target=_blank aria-label="클러스터 오퍼레이터">클러스터 오퍼레이터</a>는 서비스 카탈로그를 사용하여 서비스 브로커가 제공하는 매니지드 서비스 목록을 탐색하거나 매니지드 서비스 인스턴스를 프로비저닝하고, 쿠버네티스 클러스터 내의 애플리케이션에서 사용할 수 있도록 바인딩할 수 있다.</p>
<h2 id=유스케이스-예제>유스케이스 예제</h2>
<p>한 <a class=glossary-tooltip title="A person who writes an application that runs in a Kubernetes cluster." data-toggle=tooltip data-placement=top href="/ko/docs/reference/glossary/?all=true#term-application-developer" target=_blank aria-label="애플리케이션 개발자">애플리케이션 개발자</a>가 쿠버네티스 클러스터 내에서 실행되는 애플리케이션 중 일부로 메시지 큐를 사용하기를 원한다.
그러나 그러한 서비스에 대한 설정과 관리에는 부담이 따른다.
다행히 서비스 브로커를 통해 메시지 큐를 매니지드 서비스로 제공하는 클라우드 공급자가 있다.</p>
<p>클러스터 운영자는 서비스 카탈로그를 설정하고 이를 이용하여 클라우드 공급자의 서비스 브로커와 통신하여 메시지 큐 서비스의 인스턴스를 프로비저닝하고 쿠버네티스 클러스터 내의 애플리케이션에서 사용할 수 있게 한다.
따라서 애플리케이션 개발자는 메시지 큐의 세부 구현 또는 관리에 신경 쓸 필요가 없다.
애플리케이션은 메시지 큐에 서비스로 접속할 수 있다.</p>
<h2 id=아키텍처>아키텍처</h2>
<p>서비스 카탈로그는 <a href=https://github.com/openservicebrokerapi/servicebroker>오픈 서비스 브로커 API</a>를 사용하여 쿠버네티스 API 서버가 초기 프로비저닝을 협상하고 애플리케이션이 매니지드 서비스를 사용하는데 필요한 자격 증명을 검색하는 중개자 역할을 하는 서비스 브로커와 통신한다.</p>
<p>이는 <a href=/ko/docs/concepts/extend-kubernetes/api-extension/custom-resources/#%EC%BB%A4%EC%8A%A4%ED%85%80-%EB%A6%AC%EC%86%8C%EC%8A%A4>CRD 기반</a> 아키텍처를 사용해서 구현되었다.</p>
<br>
<p><img src=/images/docs/service-catalog-architecture.svg alt="Service Catalog Architecture"></p>
<h3 id=api-리소스>API 리소스</h3>
<p>서비스 카탈로그는 <code>servicecatalog.k8s.io</code> API를 설치하고 다음 쿠버네티스 리소스를 제공한다.</p>
<ul>
<li><code>ClusterServiceBroker</code>: 서버 연결 세부 사항을 캡슐화한, 서비스 브로커의 클러스터 내부 대표.
이들은 클러스터 내에서 새로운 유형의 매니지드 서비스를 사용할 수 있도록 하려는 클러스터 운영자가 만들고 관리한다.</li>
<li><code>ClusterServiceClass</code>: 특정 서비스 브로커가 제공하는 매니지드 서비스.
새로운 <code>ClusterServiceBroker</code> 리소스가 클러스터에 추가되면 서비스 카탈로그 컨트롤러는 서비스 브로커에 연결해서 사용 가능한 매니지드 서비스 목록을 얻는다. 그 다음 각 매니지드 서비스에 해당하는 새로운 <code>ClusterServiceClass</code> 리소스를 만든다.</li>
<li><code>ClusterServicePlan</code>: 매니지드 서비스의 특별 요청. 예를 들어, 매니지드 서비스는 무료 혹은 유료 티어와 같이 사용 가능한 서로 다른 상품이 있거나, SSD 스토리지를 사용하거나 더 많은 리소스를 갖는 등 다른 구성 옵션을 가질 수 있다. <code>ClusterServiceClass</code>와 유사하게, 새로운 <code>ClusterServiceBroker</code>가 클러스터에 추가되면, 서비스 카탈로그는 각 매니지드 서비스에 사용 가능한 서비스 플랜에 해당하는 새로운 <code>ClusterServicePlan</code> 리소스를 작성한다.</li>
<li><code>ServiceInstance</code>: <code>ClusterServiceClass</code>의 프로비저닝된 인스턴스.
클러스터 운영자가 하나 이상의 클러스터 애플리케이션에서 사용할 수 있도록 매니지드 서비스의 특정 인스턴스를 사용하기 위해 생성한다.
새로운 <code>ServiceInstance</code>리소스가 생성되면, 서비스 카탈로그 컨트롤러는 해당 서비스 브로커에 연결하여 서비스 인스턴스를 프로비저닝하도록 지시한다.</li>
<li><code>ServiceBinding</code>: <code>ServiceInstance</code>에 대한 자격 증명에 액세스한다.
자신의 애플리케이션이 <code>ServiceInstance</code>를 사용하기를 원하는 클러스터 운영자가 이들을 생성한다.
서비스 카탈로그 컨트롤러는 생성 시 파드에 마운트될 수 있는 서비스 인스턴스에 대한 연결 세부 정보와 자격 증명이 포함된 쿠버네티스 '시크릿(secret)'을 생성한다.</li>
</ul>
<h3 id=인증>인증</h3>
<p>서비스 카탈로그는 다음의 인증 방법을 지원한다.</p>
<ul>
<li>기본 (username/password)</li>
<li><a href=https://tools.ietf.org/html/rfc6750>OAuth 2.0 Bearer Token</a></li>
</ul>
<h2 id=사용법>사용법</h2>
<p>클러스터 운영자는 서비스 카탈로그 API 리소스를 사용하여 매니지드 서비스를 프로비저닝하여 쿠버네티스 클러스터 내에서 사용할 수 있게 한다. 관련 단계는 다음과 같다.</p>
<ol>
<li>서비스 브로커에서 사용 가능한 매니지드 서비스와 서비스 플랜을 나열.</li>
<li>매니지드 서비스의 새 인스턴스 프로비저닝.</li>
<li>연결 자격 증명을 반환하는 매니지드 서비스에 바인딩.</li>
<li>연결 자격 증명을 애플리케이션에 매핑.</li>
</ol>
<h3 id=매니지드-서비스와-서비스-플랜-나열>매니지드 서비스와 서비스 플랜 나열</h3>
<p>먼저, 클러스터 운영자는 <code>servicecatalog.k8s.io</code> 그룹 내에 <code>ClusterServiceBroker</code> 리소스를 생성해야 한다. 이 리소스는 서비스 브로커 엔드포인트에 접근하는데 필요한 URL과 연결 세부 사항을 포함한다.</p>
<p>다음은 <code>ClusterServiceBroker</code> 리소스 예시이다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>servicecatalog.k8s.io/v1beta1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterServiceBroker<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cloud-broker<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 서비스 브로커의 엔드포인트를 가리킨다. (이 예시는 동작하지 않는 URL이다.)</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>url</span>:<span style=color:#bbb>  </span>https://servicebroker.somecloudprovider.com/v1alpha1/projects/service-catalog/brokers/default<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic>#####</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># bearer 토큰 정보 혹은 TLS용 caBundle과 같은</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 서비스 브로커와 통신하는데 사용될 수 있는 값을 여기에 추가할 수 있다.</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic>#####</span><span style=color:#bbb>
</span></code></pre></div><p>다음은 서비스 브로커에서 사용 가능한 매니지드 서비스와 플랜을 나열하는 단계를 설명하는 시퀀스 다이어그램이다.</p>
<p><img src=/images/docs/service-catalog-list.svg alt="List Services"></p>
<ol>
<li>
<p><code>ClusterServiceBroker</code> 리소스가 서비스 카탈로그에 추가되면, 사용 가능한 서비스 목록에 대한 외부 서비스 브로커에 대한 호출을 발생시킨다.</p>
</li>
<li>
<p>서비스 브로커는 사용 가능한 매니지드 서비스 목록과 서비스 플랜 목록을 반환한다. 이 목록은 각각 로컬 <code>ClusterServiceClass</code>와 <code>ClusterServicePlan</code> 리소스로 캐시된다.</p>
</li>
<li>
<p>그런 다음 클러스터 운영자는 다음의 명령어를 사용하여 가용한 관리 서비스 목록을 얻을 수 있다.</p>
<pre><code> kubectl get clusterserviceclasses -o=custom-columns=SERVICE\ NAME:.metadata.name,EXTERNAL\ NAME:.spec.externalName
</code></pre>
<p>아래와 같은 형태의 서비스 이름 목록이 출력된다.</p>
<pre><code> SERVICE NAME                           EXTERNAL NAME
 4f6e6cf6-ffdd-425f-a2c7-3c9258ad2468   cloud-provider-service
 ...                                    ...
</code></pre>
<p>또한 다음의 명령어를 사용하여 가용한 서비스 플랜을 볼 수 있다.</p>
<pre><code> kubectl get clusterserviceplans -o=custom-columns=PLAN\ NAME:.metadata.name,EXTERNAL\ NAME:.spec.externalName
</code></pre>
<p>아래와 같은 형태의 플랜 이름 목록이 출력된다.</p>
<pre><code> PLAN NAME                              EXTERNAL NAME
 86064792-7ea2-467b-af93-ac9694d96d52   service-plan-name
 ...                                    ...
</code></pre>
</li>
</ol>
<h3 id=새-인스턴스-프로비저닝>새 인스턴스 프로비저닝</h3>
<p>클러스터 운영자는 <code>ServiceInstance</code> 리소스를 생성하여 새 인스턴스 프로비저닝을 시작할 수 있다.</p>
<p>다음은 <code>ServiceInstance</code> 리소스의 예시이다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>servicecatalog.k8s.io/v1beta1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ServiceInstance<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cloud-queue-instance<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>cloud-apps<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 이전에 반환된 서비스 중 하나를 참조</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>clusterServiceClassExternalName</span>:<span style=color:#bbb> </span>cloud-provider-service<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>clusterServicePlanExternalName</span>:<span style=color:#bbb> </span>service-plan-name<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic>#####</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 이곳에 서비스 브로커가 사용할 수 있는</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 파라미터를 추가할 수 있다.</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic>#####</span><span style=color:#bbb>
</span></code></pre></div><p>다음의 시퀀스 다이어그램은 매니지드 서비스의 새 인스턴스 프로비저닝과 관련된 일련의 단계를 보여준다.</p>
<p><img src=/images/docs/service-catalog-provision.svg alt="Provision a Service"></p>
<ol>
<li><code>ServiceInstance</code> 리소스가 생성되면, 서비스 카탈로그는 서비스 인스턴스를 프로비저닝하기 위해 외부의 서비스 브로커 호출을 초기화한다.</li>
<li>서비스 브로커는 새로운 매니지드 서비스 인스턴스를 생성하고 HTTP 응답을 리턴한다.</li>
<li>그 후 클러스터 운영자는 인스턴스 상태가 준비되었는지 점검할 수 있다.</li>
</ol>
<h3 id=매니지드-서비스에-바인딩>매니지드 서비스에 바인딩</h3>
<p>새 인스턴스가 프로비저닝된 후, 클러스터 운영자는 애플리케이션이 서비스를 사용하는데 필요한 자격 증명을 얻기 위해 매니지드 서비스에 바인드해야 한다. 이것은 <code>ServiceBinding</code> 리소스를 생성하는 것으로 이루어진다.</p>
<p>다음은 <code>ServiceBinding</code> 리소스의 예시다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>servicecatalog.k8s.io/v1beta1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ServiceBinding<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cloud-queue-binding<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>cloud-apps<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>instanceRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cloud-queue-instance<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic>#####</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 서비스 브로커가 사용할 수 있는 secretName, 서비스 어카운트 파라미터 등의</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 추가 정보를 여기에 추가할 수 있다.</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic>#####</span><span style=color:#bbb>
</span></code></pre></div><p>다음의 시퀀스 다이어그램은 매니지드 서비스 인스턴스에 바인딩하는 단계를 보여준다.</p>
<p><img src=/images/docs/service-catalog-bind.svg alt="Bind to a managed service"></p>
<ol>
<li><code>ServiceBinding</code>이 생성된 이후, 서비스 카탈로그는 서비스 인스턴스와 바인딩하는데 필요한 정보를 요청하는 외부 서비스 브로커를 호출한다.</li>
<li>서비스 브로커는 적절한 서비스 어카운트에 대한 애플리케이션 권한/역할을 활성화한다.</li>
<li>서비스 브로커는 매니지드 서비스 인스턴스에 연결하고 액세스하는데 필요한 정보를 리턴한다. 이는 제공자와 서비스에 특화되어 있으므로 서비스 프로바이더와 매니지드 서비스에 따라 다를 수 있다.</li>
</ol>
<h3 id=연결-자격-증명-매핑>연결 자격 증명 매핑</h3>
<p>바인딩 후 마지막 단계는 연결 자격 증명과 서비스 특화 정보를 애플리케이션에 매핑하는 것이다.
이런 정보는 클러스터의 애플리케이션이 액세스하여 매니지드 서비스와 직접 연결하는데 사용할 수 있는 시크릿으로 저장된다.</p>
<br>
<p><img src=/images/docs/service-catalog-map.svg alt="Map connection credentials"></p>
<h4 id=파드-구성-파일>파드 구성 파일</h4>
<p>이 매핑을 수행하는 한 가지 방법은 선언적 파드 구성을 사용하는 것이다.</p>
<p>다음 예시는 서비스 자격 증명을 애플리케이션에 매핑하는 방법을 설명한다. <code>sa-key</code>라는 키는 <code>provider-cloud-key</code>라는 볼륨에 저장되며, 애플리케이션은 이 볼륨을 <code>/var/secrets/provider/key.json</code>에 마운트한다. 환경 변수 <code>PROVIDER_APPLICATION_CREDENTIALS</code>는 마운트된 파일의 값에서 매핑된다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>provider-cloud-key<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>secret</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>secretName</span>:<span style=color:#bbb> </span>sa-key<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>provider-cloud-key<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/var/secrets/provider<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>PROVIDER_APPLICATION_CREDENTIALS<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/var/secrets/provider/key.json&#34;</span><span style=color:#bbb>
</span></code></pre></div><p>다음 예시는 시크릿 값을 애플리케이션 환경 변수에 매핑하는 방법을 설명한다. 이 예시에서 메시지 큐 토픽 이름은 <code>topic</code> 라는 키의 <code>provider-queue-credentials</code> 시크릿에서 환경 변수 <code>TOPIC</code>에 매핑된다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;TOPIC&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
</span><span style=color:#bbb>                </span><span style=color:green;font-weight:700>secretKeyRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>                   </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>provider-queue-credentials<span style=color:#bbb>
</span><span style=color:#bbb>                   </span><span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>topic<span style=color:#bbb>
</span></code></pre></div><h2 id=다음-내용>다음 내용</h2>
<ul>
<li>만약 당신이 <a class=glossary-tooltip title="A package of pre-configured Kubernetes resources that can be managed with the Helm tool." data-toggle=tooltip data-placement=top href=https://helm.sh/docs/topics/charts/ target=_blank aria-label="Helm Charts">Helm Charts</a>에 익숙하다면, 당신의 쿠버네티스 클러스터에 <a href=/docs/tasks/service-catalog/install-service-catalog-using-helm/>Helm을 이용하여 서비스 카탈로그를 설치</a>할 수 있다. 다른 방법으로 <a href=/ko/docs/tasks/service-catalog/install-service-catalog-using-sc/>SC tool을 이용하여 서비스 카탈로그를 설치</a>할 수 있다.</li>
<li><a href=https://github.com/openservicebrokerapi/servicebroker/blob/master/gettingStarted.md#sample-service-brokers>샘플 서비스 브로커</a> 살펴보기</li>
<li><a href=https://github.com/kubernetes-sigs/service-catalog>kubernetes-sigs/service-catalog</a> 프로젝트 탐색</li>
<li><a href=https://svc-cat.io/docs/>svc-cat.io</a> 살펴보기</li>
</ul>
</div>
</main>
</div>
</div>
<footer class=d-print-none>
<div class=footer__links>
<nav>
<a class=text-white href=/ko/docs/home/>홈</a>
<a class=text-white href=/ko/blog/>블로그</a>
<a class=text-white href=/ko/training/>교육</a>
<a class=text-white href=/ko/partners/>파트너</a>
<a class=text-white href=/ko/community/>커뮤니티</a>
<a class=text-white href=/ko/case-studies/>사례 연구</a>
</nav>
</div>
<div class=container-fluid>
<div class=row>
<div class="col-6 col-sm-2 text-xs-center order-sm-2">
<ul class="list-inline mb-0">
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="User mailing list" aria-label="User mailing list">
<a class=text-white target=_blank href=https://discuss.kubernetes.io>
<i class="fa fa-envelope"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Twitter aria-label=Twitter>
<a class=text-white target=_blank href=https://twitter.com/kubernetesio>
<i class="fab fa-twitter"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Calendar aria-label=Calendar>
<a class=text-white target=_blank href="https://calendar.google.com/calendar/embed?src=calendar%40kubernetes.io">
<i class="fas fa-calendar-alt"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Youtube aria-label=Youtube>
<a class=text-white target=_blank href=https://youtube.com/kubernetescommunity>
<i class="fab fa-youtube"></i>
</a>
</li>
</ul>
</div>
<div class="col-6 col-sm-2 text-right text-xs-center order-sm-3">
<ul class="list-inline mb-0">
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub>
<a class=text-white target=_blank href=https://github.com/kubernetes/kubernetes>
<i class="fab fa-github"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Slack aria-label=Slack>
<a class=text-white target=_blank href=https://slack.k8s.io>
<i class="fab fa-slack"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Contribute aria-label=Contribute>
<a class=text-white target=_blank href=https://git.k8s.io/community/contributors/guide>
<i class="fas fa-edit"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Stack Overflow" aria-label="Stack Overflow">
<a class=text-white target=_blank href=https://stackoverflow.com/questions/tagged/kubernetes>
<i class="fab fa-stack-overflow"></i>
</a>
</li>
</ul>
</div>
<div class="col-12 col-sm-8 text-center order-sm-2">
<small class=text-white>&copy; 2023 The Kubernetes Authors | Documentation Distributed under <a href=https://git.k8s.io/website/LICENSE class=light-text>CC BY 4.0</a></small>
<br>
<small class=text-white>Copyright &copy; 2023 The Linux Foundation &reg;. All rights reserved. The Linux Foundation has registered trademarks and uses trademarks. For a list of trademarks of The Linux Foundation, please see our <a href=https://www.linuxfoundation.org/trademark-usage class=light-text>Trademark Usage page</a></small>
<br>
<small class=text-white>ICP license: 京ICP备17074266号-3</small>
</div>
</div>
</div>
</footer>
</div>
<script src=/js/popper-1.14.3.min.js integrity=sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49 crossorigin=anonymous></script>
<script src=/js/bootstrap-4.3.1.min.js integrity=sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM crossorigin=anonymous></script>
<script src=/js/main.min.40616251a9b6e4b689e7769be0340661efa4d7ebb73f957404e963e135b4ed52.js integrity="sha256-QGFiUam25LaJ53ab4DQGYe+k1+u3P5V0BOlj4TW07VI=" crossorigin=anonymous></script>
</body>
</html>