<!doctype html><html lang=zh class=no-js>
<head>
<meta name=ROBOTS content="NOINDEX, NOFOLLOW">
<script async src="https://www.googletagmanager.com/gtag/js?id=G-JPP6RFM2BP"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-JPP6RFM2BP')</script>
<link rel=alternate hreflang=en href=https://kubernetes.io/docs/concepts/extend-kubernetes/>
<link rel=alternate hreflang=ko href=https://kubernetes.io/ko/docs/concepts/extend-kubernetes/>
<link rel=alternate hreflang=ja href=https://kubernetes.io/ja/docs/concepts/extend-kubernetes/>
<link rel=alternate hreflang=fr href=https://kubernetes.io/fr/docs/concepts/extend-kubernetes/>
<link rel=alternate hreflang=de href=https://kubernetes.io/de/docs/concepts/extend-kubernetes/>
<link rel=alternate hreflang=pt-br href=https://kubernetes.io/pt-br/docs/concepts/extend-kubernetes/>
<link rel=alternate hreflang=es href=https://kubernetes.io/es/docs/concepts/extend-kubernetes/>
<link rel=alternate hreflang=id href=https://kubernetes.io/id/docs/concepts/extend-kubernetes/>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=generator content="Hugo 0.87.0">
<link rel=canonical type=text/html href=https://kubernetes.io/zh/docs/concepts/extend-kubernetes/>
<link rel="shortcut icon" type=image/png href=/images/favicon.png>
<link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180>
<link rel=manifest href=/manifest.webmanifest>
<link rel=apple-touch-icon href=/images/kubernetes-192x192.png>
<title>扩展 Kubernetes | Kubernetes</title><meta property="og:title" content="扩展 Kubernetes">
<meta property="og:description" content="改变你的 Kubernetes 集群的行为的若干方法。">
<meta property="og:type" content="website">
<meta property="og:url" content="https://kubernetes.io/zh/docs/concepts/extend-kubernetes/"><meta property="og:site_name" content="Kubernetes">
<meta itemprop=name content="扩展 Kubernetes">
<meta itemprop=description content="改变你的 Kubernetes 集群的行为的若干方法。"><meta name=twitter:card content="summary">
<meta name=twitter:title content="扩展 Kubernetes">
<meta name=twitter:description content="改变你的 Kubernetes 集群的行为的若干方法。">
<link href=/scss/main.css rel=stylesheet>
<script src=/js/jquery-3.3.1.min.js integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin=anonymous></script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","url":"https://kubernetes.io","logo":"https://kubernetes.io/images/favicon.png"}</script>
<meta name=theme-color content="#326ce5">
<link rel=stylesheet href=/css/feature-states.css>
<meta name=description content="改变你的 Kubernetes 集群的行为的若干方法。">
<meta property="og:description" content="改变你的 Kubernetes 集群的行为的若干方法。">
<meta name=twitter:description content="改变你的 Kubernetes 集群的行为的若干方法。">
<meta property="og:url" content="https://kubernetes.io/zh/docs/concepts/extend-kubernetes/">
<meta property="og:title" content="扩展 Kubernetes">
<meta name=twitter:title content="扩展 Kubernetes">
<meta name=twitter:image content="https://kubernetes.io/images/favicon.png">
<meta name=twitter:image:alt content="Kubernetes">
<meta property="og:image" content="/images/kubernetes-horizontal-color.png">
<meta property="og:type" content="article">
<script src=/js/script.js></script>
</head>
<body class=td-section>
<header>
<nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar" data-auto-burger=primary>
<a class=navbar-brand href=/zh/></a>
<div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar>
<ul class="navbar-nav mt-2 mt-lg-0">
<li class="nav-item mr-2 mb-lg-0">
<a class="nav-link active" href=/zh/docs/>文档</a>
</li>
<li class="nav-item mr-2 mb-lg-0">
<a class=nav-link href=/zh/blog/>Kubernetes 博客</a>
</li>
<li class="nav-item mr-2 mb-lg-0">
<a class=nav-link href=/zh/training/>培训</a>
</li>
<li class="nav-item mr-2 mb-lg-0">
<a class=nav-link href=/zh/partners/>合作伙伴</a>
</li>
<li class="nav-item mr-2 mb-lg-0">
<a class=nav-link href=/zh/community/>社区</a>
</li>
<li class="nav-item mr-2 mb-lg-0">
<a class=nav-link href=/zh/case-studies/>案例分析</a>
</li>
<li class="nav-item dropdown">
<a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>
Versions
</a>
<div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink>
<a class=dropdown-item href=/releases>Release Information</a>
<a class=dropdown-item href=https://kubernetes.io/zh/docs/concepts/extend-kubernetes/>v1.27</a>
<a class=dropdown-item href=https://v1-26.docs.kubernetes.io/zh/docs/concepts/extend-kubernetes/>v1.26</a>
<a class=dropdown-item href=https://v1-25.docs.kubernetes.io/zh/docs/concepts/extend-kubernetes/>v1.25</a>
<a class=dropdown-item href=https://v1-24.docs.kubernetes.io/zh/docs/concepts/extend-kubernetes/>v1.24</a>
<a class=dropdown-item href=https://v1-23.docs.kubernetes.io/zh/docs/concepts/extend-kubernetes/>v1.23</a>
</div>
</li>
<li class="nav-item dropdown">
<a class="nav-link dropdown-toggle" href=# id=navbarDropdownMenuLink role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>
中文 Chinese
</a>
<div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink>
<a class=dropdown-item href=/docs/concepts/extend-kubernetes/>English</a>
<a class=dropdown-item href=/ko/docs/concepts/extend-kubernetes/>한국어 Korean</a>
<a class=dropdown-item href=/ja/docs/concepts/extend-kubernetes/>日本語 Japanese</a>
<a class=dropdown-item href=/fr/docs/concepts/extend-kubernetes/>Français</a>
<a class=dropdown-item href=/de/docs/concepts/extend-kubernetes/>Deutsch</a>
<a class=dropdown-item href=/pt-br/docs/concepts/extend-kubernetes/>Português</a>
<a class=dropdown-item href=/es/docs/concepts/extend-kubernetes/>Español</a>
<a class=dropdown-item href=/id/docs/concepts/extend-kubernetes/>Bahasa Indonesia</a>
</div>
</li>
</ul>
</div>
<button id=hamburger onclick=kub.toggleMenu() data-auto-burger-exclude><div></div></button>
</nav>
</header>
<div class="container-fluid td-outer">
<div class=td-main>
<div class="row flex-xl-nowrap">
<main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main>
<div class=td-content>
<div class="pageinfo pageinfo-primary d-print-none">
<p>
这是本节的多页打印视图。
<a href=# onclick="return print(),!1">点击此处打印</a>.
</p><p>
<a href=/zh/docs/concepts/extend-kubernetes/>返回本页常规视图</a>.
</p>
</div>
<h1 class=title>扩展 Kubernetes</h1>
<div class=lead>改变你的 Kubernetes 集群的行为的若干方法。</div>
<ul>
<li>1: <a href=#pg-0af41d3bd7c785621b58b7564793396a>扩展 Kubernetes API</a></li>
<ul>
<li>1.1: <a href=#pg-342388440304e19ce30c0f8ada1c77ce>定制资源</a></li>
<li>1.2: <a href=#pg-1ea4977c0ebf97569bf54a477faa7fa5>通过聚合层扩展 Kubernetes API</a></li>
</ul>
<li>2: <a href=#pg-3131452556176159fb269593c1a52012>Operator 模式</a></li>
<li>3: <a href=#pg-c8937cdc9df96f3328becf04f8211292>计算、存储和网络扩展</a></li>
<ul>
<li>3.1: <a href=#pg-1ac2260db9ecccbf0303a899bc27ce6d>网络插件</a></li>
<li>3.2: <a href=#pg-53e1ea8892ceca307ba19e8d6a7b8d32>设备插件</a></li>
</ul>
<li>4: <a href=#pg-b26fcf43d01abc16c8110766026dafed>服务目录</a></li>
</ul>
<div class=content>
<p>Kubernetes 是高度可配置且可扩展的。因此，大多数情况下，你不需要
派生自己的 Kubernetes 副本或者向项目代码提交补丁。</p>
<p>本指南描述定制 Kubernetes 的可选方式。主要针对的读者是希望了解如何针对自身工作环境
需要来调整 Kubernetes 的<a class=glossary-tooltip title=配置、控制、监控集群的人。 data-toggle=tooltip data-placement=top href="/zh/docs/reference/glossary/?all=true#term-cluster-operator" target=_blank aria-label=集群管理者>集群管理者</a>。
对于那些充当<a class=glossary-tooltip title="定制 Kubernetes 平台以满足自己的项目需求的人。" data-toggle=tooltip data-placement=top href="/zh/docs/reference/glossary/?all=true#term-platform-developer" target=_blank aria-label=平台开发人员>平台开发人员</a>
的开发人员或 Kubernetes 项目的<a class=glossary-tooltip title="通过贡献代码、文档或者投入时间等方式来帮助 Kubernetes 项目或社区的人。" data-toggle=tooltip data-placement=top href="/zh/docs/reference/glossary/?all=true#term-contributor" target=_blank aria-label=贡献者>贡献者</a>
而言，他们也会在本指南中找到有用的介绍信息，了解系统中存在哪些扩展点和扩展模式，
以及它们所附带的各种权衡和约束等等。</p>
<h2 id=overview>概述 </h2>
<p>定制化的方法主要可分为 <em>配置（Configuration）</em> 和 <em>扩展（Extensions）</em> 两种。
前者主要涉及改变参数标志、本地配置文件或者 API 资源；
后者则需要额外运行一些程序或服务。
本文主要关注扩展。</p>
<h2 id=configuration>配置 </h2>
<p>配置文件和参数标志的说明位于在线文档的参考章节，按可执行文件组织：</p>
<ul>
<li><a href=/zh/docs/reference/command-line-tools-reference/kubelet/>kubelet</a></li>
<li><a href=/zh/docs/reference/command-line-tools-reference/kube-proxy/>kube-proxy</a></li>
<li><a href=/zh/docs/reference/command-line-tools-reference/kube-apiserver/>kube-apiserver</a></li>
<li><a href=/zh/docs/reference/command-line-tools-reference/kube-controller-manager/>kube-controller-manager</a></li>
<li><a href=/zh/docs/reference/command-line-tools-reference/kube-scheduler/>kube-scheduler</a>.</li>
</ul>
<p>在托管的 Kubernetes 服务中或者受控安装的发行版本中，参数标志和配置文件不总是可以
修改的。即使它们是可修改的，通常其修改权限也仅限于集群管理员。
此外，这些内容在将来的 Kubernetes 版本中很可能发生变化，设置新参数或配置文件可能
需要重启进程。
有鉴于此，通常应该在没有其他替代方案时才应考虑更改参数标志和配置文件。</p>
<p><em>内置的策略 API</em>，例如<a href=/zh/docs/concepts/policy/resource-quotas/>ResourceQuota</a>、
<a href=/zh/docs/concepts/security/pod-security-policy/>PodSecurityPolicies</a>、
<a href=/zh/docs/concepts/services-networking/network-policies/>NetworkPolicy</a>
和基于角色的访问控制（<a href=/zh/docs/reference/access-authn-authz/rbac/>RBAC</a>）
等等都是内置的 Kubernetes API。
API 通常用于托管的 Kubernetes 服务和受控的 Kubernetes 安装环境中。
这些 API 是声明式的，与 Pod 这类其他 Kubernetes 资源遵从相同的约定，
所以新的集群配置是可复用的，并且可以当作应用程序来管理。
此外，对于稳定版本的 API 而言，它们与其他 Kubernetes API 一样，
采纳的是一种<a href=/zh/docs/reference/using-api/deprecation-policy/>预定义的支持策略</a>。
出于以上原因，在条件允许的情况下，基于 API 的方案应该优先于配置文件和参数标志。</p>
<h2 id=extensions>扩展 </h2>
<p>扩展（Extensions）是一些扩充 Kubernetes 能力并与之深度集成的软件组件。
它们调整 Kubernetes 的工作方式使之支持新的类型和新的硬件种类。</p>
<p>大多数集群管理员会使用一种托管的 Kubernetes 服务或者其某种发行版本。
这类集群通常都预先安装了扩展。因此，大多数 Kubernetes 用户不需要安装扩展，
至于需要自己编写新的扩展的情况就更少了。</p>
<h2 id=extension-patterns>扩展模式 </h2>
<p>Kubernetes 从设计上即支持通过编写客户端程序来将其操作自动化。
任何能够对 Kubernetes API 发出读写指令的程序都可以提供有用的自动化能力。
<em>自动化组件</em>可以运行在集群上，也可以运行在集群之外。
通过遵从本文中的指南，你可以编写高度可用的、运行稳定的自动化组件。
自动化组件通常可以用于所有 Kubernetes 集群，包括托管的集群和受控的安装环境。</p>
<p>编写客户端程序有一种特殊的 Controller（控制器）模式，能够与 Kubernetes
很好地协同工作。控制器通常会读取某个对象的 <code>.spec</code>，或许还会执行一些操作，
之后更新对象的 <code>.status</code>。</p>
<p>Controller 是 Kubernetes 的客户端。当 Kubernetes 充当客户端，
调用某远程服务时，对应的远程组件称作 <em>Webhook</em>，远程服务称作 Webhook 后端。
与控制器模式相似，Webhook 也会在整个架构中引入新的失效点（Point of Failure）。</p>
<p>在 Webhook 模式中，Kubernetes 向远程服务发起网络请求。
在 <strong>可执行文件插件（Binary Plugin）</strong> 模式中，Kubernetes
执行某个可执行文件（程序）。可执行文件插件在 kubelet （例如，
<a href=/zh/docs/concepts/storage/volumes/#flexvolume>FlexVolume 插件</a>)
和<a href=/zh/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/>网络插件</a>）
和 kubectl 中使用。</p>
<p>下面的示意图中展示了这些扩展点如何与 Kubernetes 控制面交互。</p>
<p><img src=/docs/concepts/extend-kubernetes/control-plane.png alt=扩展点与控制面></p>
<h2 id=extension-points>扩展点 </h2>
<p>此示意图显示的是 Kubernetes 系统中的扩展点。</p>
<p><img src=/docs/concepts/extend-kubernetes/extension-points.png alt=扩展点></p>
<ol>
<li>
<p>用户通常使用 <code>kubectl</code> 与 Kubernetes API 交互。
<a href=/zh/docs/tasks/extend-kubectl/kubectl-plugins/>kubectl 插件</a>能够扩展 kubectl 程序的行为。
这些插件只会影响到每个用户的本地环境，因此无法用来强制实施整个站点范围的策略。</p>
</li>
<li>
<p>API 服务器处理所有请求。API 服务器中的几种扩展点能够使用户对请求执行身份认证、
基于其内容阻止请求、编辑请求内容、处理删除操作等等。
这些扩展点在 <a href=#api-access-extensions>API 访问扩展</a>节详述。</p>
</li>
<li>
<p>API 服务器向外提供不同类型的资源（resources）。
内置的资源类型，如 <code>pods</code>，是由 Kubernetes 项目所定义的，无法改变。
你也可以添加自己定义的或者其他项目所定义的称作自定义资源（Custom Resources）
的资源，正如<a href=#user-defined-types>自定义资源</a>节所描述的那样。
自定义资源通常与 API 访问扩展点结合使用。</p>
</li>
<li>
<p>Kubernetes 调度器负责决定 Pod 要放置到哪些节点上执行。
有几种方式来扩展调度行为。这些方法将在
<a href=#scheduler-extensions>调度器扩展</a>节中展开。</p>
</li>
<li>
<p>Kubernetes 中的很多行为都是通过称为控制器（Controllers）的程序来实现的，
这些程序也都是 API 服务器的客户端。控制器常常与自定义资源结合使用。</p>
</li>
<li>
<p>组件 kubelet 运行在各个节点上，帮助 Pod 展现为虚拟的服务器并在集群网络中拥有自己的 IP。
<a href=#network-plugins>网络插件</a>使得 Kubernetes 能够采用不同实现技术来连接
Pod 网络。</p>
</li>
<li>
<p>组件 kubelet 也会为容器增加或解除存储卷的挂载。
通过<a href=#storage-plugins>存储插件</a>，可以支持新的存储类型。</p>
</li>
</ol>
<p>如果你无法确定从何处入手，下面的流程图可能对你有些帮助。
注意，某些方案可能需要同时采用几种类型的扩展。</p>
<p><img src=/docs/concepts/extend-kubernetes/flowchart.png alt=扩展流程图></p>
<h2 id=api-extensions>API 扩展 </h2>
<h3 id=user-defined-types>用户定义的类型 </h3>
<p>如果你想要定义新的控制器、应用配置对象或者其他声明式 API，并且使用 Kubernetes
工具（如 <code>kubectl</code>）来管理它们，可以考虑向 Kubernetes 添加自定义资源。</p>
<p>不要使用自定义资源来充当应用、用户或者监控数据的数据存储。</p>
<p>关于自定义资源的更多信息，可参见<a href=/zh/docs/concepts/extend-kubernetes/api-extension/custom-resources/>自定义资源概念指南</a>。</p>
<h3 id=combinding-new-apis-with-automation>结合使用新 API 与自动化组件</h3>
<p>自定义资源 API 与控制回路的组合称作
<a href=/zh/docs/concepts/extend-kubernetes/operator/>Operator 模式</a>。
Operator 模式用来管理特定的、通常是有状态的应用。
这些自定义 API 和控制回路也可用来控制其他资源，如存储或策略。</p>
<h3 id=changing-built-in-resources>更改内置资源 </h3>
<p>当你通过添加自定义资源来扩展 Kubernetes 时，所添加的资源通常会被放在一个新的
API 组中。你不可以替换或更改现有的 API 组。
添加新的 API 不会直接让你影响现有 API （如 Pods）的行为，不过 API
访问扩展能够实现这点。</p>
<h3 id=api-access-extensions>API 访问扩展 </h3>
<p>当请求到达 Kubernetes API 服务器时，首先要经过身份认证，之后是鉴权操作，
再之后要经过若干类型的准入控制器的检查。
参见<a href=/zh/docs/concepts/security/controlling-access/>控制 Kubernetes API 访问</a>
以了解此流程的细节。</p>
<p>这些步骤中都存在扩展点。</p>
<p>Kubernetes 提供若干内置的身份认证方法。它也可以运行在某种身份认证代理的后面，
并且可以将来自鉴权头部的令牌发送到某个远程服务（Webhook）来执行验证操作。
所有这些方法都在<a href=/zh/docs/reference/access-authn-authz/authentication/>身份认证文档</a>
中有详细论述。</p>
<h3 id=authentication>身份认证 </h3>
<p><a href=/zh/docs/reference/access-authn-authz/authentication/>身份认证</a>负责将所有请求中
的头部或证书映射到发出该请求的客户端的用户名。</p>
<p>Kubernetes 提供若干种内置的认证方法，以及
<a href=/zh/docs/reference/access-authn-authz/authentication/#webhook-token-authentication>认证 Webhook</a>
方法以备内置方法无法满足你的要求。</p>
<h3 id=authorization>鉴权 </h3>
<p><a href=/zh/docs/reference/access-authn-authz/authorization/>鉴权</a>
操作负责确定特定的用户是否可以读、写 API 资源或对其执行其他操作。
此操作仅在整个资源集合的层面进行。
换言之，它不会基于对象的特定字段作出不同的判决。
如果内置的鉴权选项无法满足你的需要，你可以使用
<a href=/zh/docs/reference/access-authn-authz/webhook/>鉴权 Webhook</a>来调用用户提供
的代码，执行定制的鉴权操作。</p>
<h3 id=dynamic-admission-control>动态准入控制 </h3>
<p>请求的鉴权操作结束之后，如果请求的是写操作，还会经过
<a href=/zh/docs/reference/access-authn-authz/admission-controllers/>准入控制</a>处理步骤。
除了内置的处理步骤，还存在一些扩展点：</p>
<ul>
<li><a href=/zh/docs/reference/access-authn-authz/admission-controllers/#imagepolicywebhook>镜像策略 Webhook</a>
能够限制容器中可以运行哪些镜像。</li>
<li>为了执行任意的准入控制，可以使用一种通用的
<a href=/zh/docs/reference/access-authn-authz/extensible-admission-controllers/#admission-webhooks>准入 Webhook</a>
机制。这类 Webhook 可以拒绝对象创建或更新请求。</li>
</ul>
<h2 id=infrastructure-extensions>基础设施扩展 </h2>
<h3 id=storage-plugins>存储插件 </h3>
<p><a href=https://github.com/kubernetes/community/blob/master/contributors/design-proposals/storage/flexvolume-deployment.md>FlexVolumes</a>
卷可以让用户挂载无需内建支持的卷类型，
kubelet 会调用可执行文件插件来挂载对应的存储卷。</p>
<p>从 Kubernetes v1.23 开始，FlexVolume 被弃用。
在 Kubernetes 中编写卷驱动的推荐方式是使用树外（Out-of-tree）CSI 驱动。
详细信息可参阅 <a href=https://github.com/kubernetes/community/blob/master/sig-storage/volume-plugin-faq.md#kubernetes-volume-plugin-faq-for-storage-vendors>Kubernetes Volume Plugin FAQ for Storage Vendors</a>。</p>
<h3 id=device-plugins>设备插件 </h3>
<p>使用<a href=/zh/docs/concepts/extend-kubernetes/compute-storage-net/device-plugins/>设备插件</a>，
节点能够发现新的节点资源（除了内置的类似 CPU 和内存这类资源）。</p>
<h3 id=network-plugins>网络插件 </h3>
<p>通过节点层面的<a href=/zh/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/>网络插件</a>，
可以支持不同的网络设施。</p>
<h3 id=scheduler-extensions>调度器扩展 </h3>
<p>调度器是一种特殊的控制器，负责监视 Pod 变化并将 Pod 分派给节点。
默认的调度器可以被整体替换掉，同时继续使用其他 Kubernetes 组件。
或者也可以在同一时刻使用
<a href=/zh/docs/tasks/extend-kubernetes/configure-multiple-schedulers/>多个调度器</a>。</p>
<p>这是一项非同小可的任务，几乎绝大多数 Kubernetes
用户都会发现其实他们不需要修改调度器。</p>
<p>调度器也支持一种
<a href=https://github.com/kubernetes/community/blob/master/contributors/design-proposals/scheduling/scheduler_extender.md>Webhook</a>，
允许使用某种 Webhook 后端（调度器扩展）来为 Pod 可选的节点执行过滤和优先排序操作。</p>
<h2 id=what-s-next>What's next</h2>
<ul>
<li>进一步了解<a href=/zh/docs/concepts/extend-kubernetes/api-extension/custom-resources/>自定义资源</a></li>
<li>了解<a href=/zh/docs/reference/access-authn-authz/extensible-admission-controllers/>动态准入控制</a></li>
<li>进一步了解基础设施扩展
<ul>
<li><a href=/zh/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/>网络插件</a></li>
<li><a href=/zh/docs/concepts/extend-kubernetes/compute-storage-net/device-plugins/>设备插件</a></li>
</ul>
</li>
<li>了解 <a href=/zh/docs/tasks/extend-kubectl/kubectl-plugins/>kubectl 插件</a></li>
<li>了解 <a href=/zh/docs/concepts/extend-kubernetes/operator/>Operator 模式</a></li>
</ul>
</div>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-0af41d3bd7c785621b58b7564793396a>1 - 扩展 Kubernetes API</h1>
</div>
<div class=td-content>
<h1 id=pg-342388440304e19ce30c0f8ada1c77ce>1.1 - 定制资源</h1>
<p><em>定制资源（Custom Resource）</em> 是对 Kubernetes API 的扩展。
本页讨论何时向 Kubernetes 集群添加定制资源，何时使用独立的服务。
本页描述添加定制资源的两种方法以及怎样在二者之间做出抉择。</p>
<h2 id=定制资源>定制资源</h2>
<p><em>资源（Resource）</em> 是
<a href=/zh/docs/concepts/overview/kubernetes-api/>Kubernetes API</a> 中的一个端点，
其中存储的是某个类别的
<a href=/zh/docs/concepts/overview/working-with-objects/kubernetes-objects/>API 对象</a>
的一个集合。
例如内置的 <em>pods</em> 资源包含一组 Pod 对象。</p>
<p><em>定制资源（Custom Resource）</em> 是对 Kubernetes API 的扩展，不一定在默认的
Kubernetes 安装中就可用。定制资源所代表的是对特定 Kubernetes 安装的一种定制。
不过，很多 Kubernetes 核心功能现在都用定制资源来实现，这使得 Kubernetes
更加模块化。</p>
<p>定制资源可以通过动态注册的方式在运行中的集群内或出现或消失，集群管理员可以独立于集群
更新定制资源。一旦某定制资源被安装，用户可以使用
<a href=/docs/reference/kubectl/>kubectl</a>
来创建和访问其中的对象，就像他们为 <em>pods</em> 这种内置资源所做的一样。</p>
<h2 id=custom-controllers>定制控制器 </h2>
<p>就定制资源本身而言，它只能用来存取结构化的数据。
当你将定制资源与 <em>定制控制器（Custom Controller）</em> 相结合时，定制资源就能够
提供真正的 <em>声明式 API（Declarative API）</em>。</p>
<p>使用<a href=/zh/docs/concepts/overview/kubernetes-api/>声明式 API</a>，
你可以 <em>声明</em> 或者设定你的资源的期望状态，并尝试让 Kubernetes 对象的当前状态
同步到其期望状态。控制器负责将结构化的数据解释为用户所期望状态的记录，并
持续地维护该状态。</p>
<p>你可以在一个运行中的集群上部署和更新定制控制器，这类操作与集群的生命周期无关。
定制控制器可以用于任何类别的资源，不过它们与定制资源结合起来时最为有效。
<a href=/zh/docs/concepts/extend-kubernetes/operator/>Operator 模式</a>就是将定制资源
与定制控制器相结合的。你可以使用定制控制器来将特定于某应用的领域知识组织
起来，以编码的形式构造对 Kubernetes API 的扩展。</p>
<h2 id=我是否应该向我的-kubernetes-集群添加定制资源>我是否应该向我的 Kubernetes 集群添加定制资源？</h2>
<p>在创建新的 API 时，请考虑是
<a href=/zh/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/>将你的 API 与 Kubernetes 集群 API 聚合起来</a>
还是让你的 API 独立运行。</p>
<table>
<thead>
<tr>
<th>考虑 API 聚合的情况</th>
<th>优选独立 API 的情况</th>
</tr>
</thead>
<tbody>
<tr>
<td>你的 API 是<a href=#declarative-apis>声明式的</a>。</td>
<td>你的 API 不符合<a href=#declarative-apis>声明式</a>模型。</td>
</tr>
<tr>
<td>你希望可以是使用 <code>kubectl</code> 来读写你的新资源类别。</td>
<td>不要求 <code>kubectl</code> 支持。</td>
</tr>
<tr>
<td>你希望在 Kubernetes UI （如仪表板）中和其他内置类别一起查看你的新资源类别。</td>
<td>不需要 Kubernetes UI 支持。</td>
</tr>
<tr>
<td>你在开发新的 API。</td>
<td>你已经有一个提供 API 服务的程序并且工作良好。</td>
</tr>
<tr>
<td>你有意愿取接受 Kubernetes 对 REST 资源路径所作的格式限制，例如 API 组和名字空间。（参阅 <a href=/zh/docs/concepts/overview/kubernetes-api/>API 概述</a>）</td>
<td>你需要使用一些特殊的 REST 路径以便与已经定义的 REST API 保持兼容。</td>
</tr>
<tr>
<td>你的资源可以自然地界定为集群作用域或集群中某个名字空间作用域。</td>
<td>集群作用域或名字空间作用域这种二分法很不合适；你需要对资源路径的细节进行控制。</td>
</tr>
<tr>
<td>你希望复用 <a href=#common-features>Kubernetes API 支持特性</a>。</td>
<td>你不需要这类特性。</td>
</tr>
</tbody>
</table>
<h3 id=declarative-apis>声明式 APIs</h3>
<p>典型地，在声明式 API 中：</p>
<ul>
<li>你的 API 包含相对而言为数不多的、尺寸较小的对象（资源）。</li>
<li>对象定义了应用或者基础设施的配置信息。</li>
<li>对象更新操作频率较低。</li>
<li>通常需要人来读取或写入对象。</li>
<li>对象的主要操作是 CRUD 风格的（创建、读取、更新和删除）。</li>
<li>不需要跨对象的事务支持：API 对象代表的是期望状态而非确切实际状态。</li>
</ul>
<p>命令式 API（Imperative API）与声明式有所不同。
以下迹象表明你的 API 可能不是声明式的：</p>
<ul>
<li>客户端发出“做这个操作”的指令，之后在该操作结束时获得同步响应。</li>
<li>客户端发出“做这个操作”的指令，并获得一个操作 ID，之后需要检查一个 Operation（操作）
对象来判断请求是否成功完成。</li>
<li>你会将你的 API 类比为远程过程调用（Remote Procedure Call，RPCs）。</li>
<li>直接存储大量数据；例如每个对象几 kB，或者存储上千个对象。</li>
<li>需要较高的访问带宽（长期保持每秒数十个请求）。</li>
<li>存储有应用来处理的最终用户数据（如图片、个人标识信息（PII）等）或者其他大规模数据。</li>
<li>在对象上执行的常规操作并非 CRUD 风格。</li>
<li>API 不太容易用对象来建模。</li>
<li>你决定使用操作 ID 或者操作对象来表现悬决的操作。</li>
</ul>
<h2 id=我应该使用一个-configmap-还是一个定制资源>我应该使用一个 ConfigMap 还是一个定制资源？</h2>
<p>如果满足以下条件之一，应该使用 ConfigMap：</p>
<ul>
<li>存在一个已有的、文档完备的配置文件格式约定，例如 <code>mysql.cnf</code> 或 <code>pom.xml</code>。</li>
<li>你希望将整个配置文件放到某 configMap 中的一个主键下面。</li>
<li>配置文件的主要用途是针对运行在集群中 Pod 内的程序，供后者依据文件数据配置自身行为。</li>
<li>文件的使用者期望以 Pod 内文件或者 Pod 内环境变量的形式来使用文件数据，
而不是通过 Kubernetes API。</li>
<li>你希望当文件被更新时通过类似 Deployment 之类的资源完成滚动更新操作。</li>
</ul>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 请使用 <a href=/zh/docs/concepts/configuration/secret/>Secret</a> 来保存敏感数据。
Secret 类似于 configMap，但更为安全。
</div>
<p>如果以下条件中大多数都被满足，你应该使用定制资源（CRD 或者 聚合 API）：</p>
<ul>
<li>你希望使用 Kubernetes 客户端库和 CLI 来创建和更改新的资源。</li>
<li>你希望 <code>kubectl</code> 能够直接支持你的资源；例如，<code>kubectl get my-object object-name</code>。</li>
<li>你希望构造新的自动化机制，监测新对象上的更新事件，并对其他对象执行 CRUD
操作，或者监测后者更新前者。</li>
<li>你希望编写自动化组件来处理对对象的更新。</li>
<li>你希望使用 Kubernetes API 对诸如 <code>.spec</code>、<code>.status</code> 和 <code>.metadata</code> 等字段的约定。</li>
<li>你希望对象是对一组受控资源的抽象，或者对其他资源的归纳提炼。</li>
</ul>
<h2 id=adding-custom-resources>添加定制资源 </h2>
<p>Kubernetes 提供了两种方式供你向集群中添加定制资源：</p>
<ul>
<li>CRD 相对简单，创建 CRD 可以不必编程。</li>
<li><a href=/zh/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/>API 聚合</a>
需要编程，但支持对 API 行为进行更多的控制，例如数据如何存储以及在不同 API 版本间如何转换等。</li>
</ul>
<p>Kubernetes 提供这两种选项以满足不同用户的需求，这样就既不会牺牲易用性也不会牺牲灵活性。</p>
<p>聚合 API 指的是一些下位的 API 服务器，运行在主 API 服务器后面；主 API
服务器以代理的方式工作。这种组织形式称作
<a href=/zh/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/>API 聚合（API Aggregation，AA）</a> 。
对用户而言，看起来仅仅是 Kubernetes API 被扩展了。</p>
<p>CRD 允许用户创建新的资源类别同时又不必添加新的 API 服务器。
使用 CRD 时，你并不需要理解 API 聚合。</p>
<p>无论以哪种方式安装定制资源，新的资源都会被当做定制资源，以便与内置的
Kubernetes 资源（如 Pods）相区分。</p>
<h2 id=customresourcedefinitions>CustomResourceDefinitions</h2>
<p><a href=/zh/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/>CustomResourceDefinition</a>
API 资源允许你定义定制资源。
定义 CRD 对象的操作会使用你所设定的名字和模式定义（Schema）创建一个新的定制资源，
Kubernetes API 负责为你的定制资源提供存储和访问服务。
CRD 对象的名称必须是合法的
<a href=/zh/docs/concepts/overview/working-with-objects/names#dns-subdomain-names>DNS 子域名</a>。</p>
<p>CRD 使得你不必编写自己的 API 服务器来处理定制资源，不过其背后实现的通用性也意味着
你所获得的灵活性要比 <a href=#api-server-aggregation>API 服务器聚合</a>少很多。</p>
<p>关于如何注册新的定制资源、使用新资源类别的实例以及如何使用控制器来处理事件，
相关的例子可参见<a href=https://github.com/kubernetes/sample-controller>定制控制器示例</a>。</p>
<h2 id=api-server-aggregation>API 服务器聚合 </h2>
<p>通常，Kubernetes API 中的每个资源都需要处理 REST 请求和管理对象持久性存储的代码。
Kubernetes API 主服务器能够处理诸如 <em>pods</em> 和 <em>services</em> 这些内置资源，也可以
按通用的方式通过 <a href=#customresourcedefinitions>CRD</a> 来处理定制资源。</p>
<p><a href=/zh/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/>聚合层（Aggregation Layer）</a>
使得你可以通过编写和部署你自己的 API 服务器来为定制资源提供特殊的实现。
主 API 服务器将针对你要处理的定制资源的请求全部委托给你自己的 API 服务器来处理，同时将这些资源
提供给其所有客户端。</p>
<h2 id=选择添加定制资源的方法>选择添加定制资源的方法</h2>
<p>CRD 更为易用；聚合 API 则更为灵活。请选择最符合你的需要的方法。</p>
<p>通常，如何存在以下情况，CRD 可能更合适：</p>
<ul>
<li>定制资源的字段不多；</li>
<li>你在组织内部使用该资源或者在一个小规模的开源项目中使用该资源，而不是
在商业产品中使用。</li>
</ul>
<h3 id=compare-ease-of-use>比较易用性 </h3>
<p>CRD 比聚合 API 更容易创建</p>
<table>
<thead>
<tr>
<th>CRDs</th>
<th>聚合 API</th>
</tr>
</thead>
<tbody>
<tr>
<td>无需编程。用户可选择任何语言来实现 CRD 控制器。</td>
<td>需要使用 Go 来编程，并构建可执行文件和镜像。</td>
</tr>
<tr>
<td>无需额外运行服务；CRD 由 API 服务器处理。</td>
<td>需要额外创建服务，且该服务可能失效。</td>
</tr>
<tr>
<td>一旦 CRD 被创建，不需要持续提供支持。Kubernetes 主控节点升级过程中自动会带入缺陷修复。</td>
<td>可能需要周期性地从上游提取缺陷修复并更新聚合 API 服务器。</td>
</tr>
<tr>
<td>无需处理 API 的多个版本；例如，当你控制资源的客户端时，你可以更新它使之与 API 同步。</td>
<td>你需要处理 API 的多个版本；例如，在开发打算与很多人共享的扩展时。</td>
</tr>
</tbody>
</table>
<h3 id=advanced-features-and-flexibility>高级特性与灵活性 </h3>
<p>聚合 API 可提供更多的高级 API 特性，也可对其他特性实行定制；例如，对存储层进行定制。</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>描述</th>
<th>CRDs</th>
<th>聚合 API</th>
</tr>
</thead>
<tbody>
<tr>
<td>合法性检查</td>
<td>帮助用户避免错误，允许你独立于客户端版本演化 API。这些特性对于由很多无法同时更新的客户端的场合。</td>
<td>可以。大多数验证可以使用 <a href=/zh/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/#validation>OpenAPI v3.0 合法性检查</a> 来设定。其他合法性检查操作可以通过添加<a href=/zh/docs/reference/access-authn-authz/admission-controllers/#validatingadmissionwebhook-alpha-in-1-8-beta-in-1-9>合法性检查 Webhook</a>来实现。</td>
<td>可以，可执行任何合法性检查。</td>
</tr>
<tr>
<td>默认值设置</td>
<td>同上</td>
<td>可以。可通过 <a href=/zh/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/#defaulting>OpenAPI v3.0 合法性检查</a>的 <code>default</code> 关键词（自 1.17 正式发布）或<a href=/zh/docs/reference/access-authn-authz/admission-controllers/#mutatingadmissionwebhook>更改性（Mutating）Webhook</a>来实现（不过从 etcd 中读取老的对象时不会执行这些 Webhook）。</td>
<td>可以。</td>
</tr>
<tr>
<td>多版本支持</td>
<td>允许通过两个 API 版本同时提供同一对象。可帮助简化类似字段更名这类 API 操作。如果你能控制客户端版本，这一特性将不再重要。</td>
<td><a href=/zh/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definition-versioning>可以</a>。</td>
<td>可以。</td>
</tr>
<tr>
<td>定制存储</td>
<td>支持使用具有不同性能模式的存储（例如，要使用时间序列数据库而不是键值存储），或者因安全性原因对存储进行隔离（例如对敏感信息执行加密）。</td>
<td>不可以。</td>
<td>可以。</td>
</tr>
<tr>
<td>定制业务逻辑</td>
<td>在创建、读取、更新或删除对象时，执行任意的检查或操作。</td>
<td>可以。要使用 <a href=/zh/docs/reference/access-authn-authz/extensible-admission-controllers/#admission-webhooks>Webhook</a>。</td>
<td>可以。</td>
</tr>
<tr>
<td>支持 scale 子资源</td>
<td>允许 HorizontalPodAutoscaler 和 PodDisruptionBudget 这类子系统与你的新资源交互。</td>
<td><a href=/zh/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/#scale-subresource>可以</a>。</td>
<td>可以。</td>
</tr>
<tr>
<td>支持 status 子资源</td>
<td>允许在用户写入 spec 部分而控制器写入 status 部分时执行细粒度的访问控制。允许在对定制资源的数据进行更改时增加对象的代际（Generation）；这需要资源对 spec 和 status 部分有明确划分。</td>
<td><a href=/zh/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/#status-subresource>可以</a>。</td>
<td>可以。</td>
</tr>
<tr>
<td>其他子资源</td>
<td>添加 CRUD 之外的操作，例如 "logs" 或 "exec"。</td>
<td>不可以。</td>
<td>可以。</td>
</tr>
<tr>
<td>strategic-merge-patch</td>
<td>新的端点要支持标记了 <code>Content-Type: application/strategic-merge-patch+json</code> 的 PATCH 操作。对于更新既可在本地更改也可在服务器端更改的对象而言是有用的。要了解更多信息，可参见<a href=/zh/docs/tasks/manage-kubernetes-objects/update-api-object-kubectl-patch/>使用 <code>kubectl patch</code> 来更新 API 对象</a>。</td>
<td>不可以。</td>
<td>可以。</td>
</tr>
<tr>
<td>支持协议缓冲区</td>
<td>新的资源要支持想要使用协议缓冲区（Protocol Buffer）的客户端。</td>
<td>不可以。</td>
<td>可以。</td>
</tr>
<tr>
<td>OpenAPI Schema</td>
<td>是否存在新资源类别的 OpenAPI（Swagger）Schema 可供动态从服务器上读取？是否存在机制确保只能设置被允许的字段以避免用户犯字段拼写错误？是否实施了字段类型检查（换言之，不允许在 <code>string</code> 字段设置 <code>int</code> 值）？</td>
<td>可以，依据 <a href=/zh/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/#validation>OpenAPI v3.0 合法性检查</a> 模式（1.16 中进入正式发布状态）。</td>
<td>可以。</td>
</tr>
</tbody>
</table>
<h3 id=common-features>公共特性 </h3>
<p>与在 Kubernetes 平台之外实现定制资源相比，
无论是通过 CRD 还是通过聚合 API 来创建定制资源，你都会获得很多 API 特性：</p>
<table>
<thead>
<tr>
<th>功能特性</th>
<th>具体含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>CRUD</td>
<td>新的端点支持通过 HTTP 和 <code>kubectl</code> 发起的 CRUD 基本操作</td>
</tr>
<tr>
<td>监测（Watch）</td>
<td>新的端点支持通过 HTTP 发起的 Kubernetes Watch 操作</td>
</tr>
<tr>
<td>发现（Discovery）</td>
<td>类似 <code>kubectl</code> 和仪表盘（Dashboard）这类客户端能够自动提供列举、显示、在字段级编辑你的资源的操作</td>
</tr>
<tr>
<td>json-patch</td>
<td>新的端点支持带 <code>Content-Type: application/json-patch+json</code> 的 PATCH 操作</td>
</tr>
<tr>
<td>merge-patch</td>
<td>新的端点支持带 <code>Content-Type: application/merge-patch+json</code> 的 PATCH 操作</td>
</tr>
<tr>
<td>HTTPS</td>
<td>新的端点使用 HTTPS</td>
</tr>
<tr>
<td>内置身份认证</td>
<td>对扩展的访问会使用核心 API 服务器（聚合层）来执行身份认证操作</td>
</tr>
<tr>
<td>内置鉴权授权</td>
<td>对扩展的访问可以复用核心 API 服务器所使用的鉴权授权机制；例如，RBAC</td>
</tr>
<tr>
<td>Finalizers</td>
<td>在外部清除工作结束之前阻止扩展资源被删除</td>
</tr>
<tr>
<td>准入 Webhooks</td>
<td>在创建、更新和删除操作中对扩展资源设置默认值和执行合法性检查</td>
</tr>
<tr>
<td>UI/CLI 展示</td>
<td><code>kubectl</code> 和仪表盘（Dashboard）可以显示扩展资源</td>
</tr>
<tr>
<td>区分未设置值和空值</td>
<td>客户端能够区分哪些字段是未设置的，哪些字段的值是被显式设置为零值的。</td>
</tr>
<tr>
<td>生成客户端库</td>
<td>Kubernetes 提供通用的客户端库，以及用来生成特定类别客户端库的工具</td>
</tr>
<tr>
<td>标签和注解</td>
<td>提供涵盖所有对象的公共元数据结构，且工具知晓如何编辑核心资源和定制资源的这些元数据</td>
</tr>
</tbody>
</table>
<h2 id=准备安装定制资源>准备安装定制资源</h2>
<p>在向你的集群添加定制资源之前，有些事情需要搞清楚。</p>
<h3 id=第三方代码和新的失效点的问题>第三方代码和新的失效点的问题</h3>
<p>尽管添加新的 CRD 不会自动带来新的失效点（Point of
Failure），例如导致第三方代码被在 API 服务器上运行，
类似 Helm Charts 这种软件包或者其他安装包通常在提供 CRD 的同时还包含带有第三方
代码的 Deployment，负责实现新的定制资源的业务逻辑。</p>
<p>安装聚合 API 服务器时，也总会牵涉到运行一个新的 Deployment。</p>
<h3 id=存储>存储</h3>
<p>定制资源和 ConfigMap 一样也会消耗存储空间。创建过多的定制资源可能会导致
API 服务器上的存储空间超载。</p>
<p>聚合 API 服务器可以使用主 API 服务器的同一存储。如果是这样，你也要注意
此警告。</p>
<h3 id=身份认证-鉴权授权以及审计>身份认证、鉴权授权以及审计</h3>
<p>CRD 通常与 API 服务器上的内置资源一样使用相同的身份认证、鉴权授权
和审计日志机制。</p>
<p>如果你使用 RBAC 来执行鉴权授权，大多数 RBAC 角色都会授权对新资源的访问
（除了 cluster-admin 角色以及使用通配符规则创建的其他角色）。
你要显式地为新资源的访问授权。CRD 和聚合 API 通常在交付时会包含
针对所添加的类别的新的角色定义。</p>
<p>聚合 API 服务器可能会使用主 API 服务器相同的身份认证、鉴权授权和审计
机制，也可能不会。</p>
<h2 id=访问定制资源>访问定制资源</h2>
<p>Kubernetes <a href=/zh/docs/reference/using-api/client-libraries/>客户端库</a>可用来访问定制资源。
并非所有客户端库都支持定制资源。<em>Go</em> 和 <em>Python</em> 客户端库是支持的。</p>
<p>当你添加了新的定制资源后，可以用如下方式之一访问它们：</p>
<ul>
<li><code>kubectl</code></li>
<li>Kubernetes 动态客户端</li>
<li>你所编写的 REST 客户端</li>
<li>使用 <a href=https://github.com/kubernetes/code-generator>Kubernetes 客户端生成工具</a>
所生成的客户端。生成客户端的工作有些难度，不过某些项目可能会随着 CRD 或
聚合 API 一起提供一个客户端</li>
</ul>
<h2 id=what-s-next>What's next</h2>
<ul>
<li>了解如何<a href=/zh/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/>使用聚合层扩展 Kubernetes API</a></li>
<li>了解如何<a href=/zh/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/>使用 CustomResourceDefinition 来扩展 Kubernetes API</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-1ea4977c0ebf97569bf54a477faa7fa5>1.2 - 通过聚合层扩展 Kubernetes API</h1>
<p>使用聚合层（Aggregation Layer），用户可以通过额外的 API 扩展 Kubernetes，
而不局限于 Kubernetes 核心 API 提供的功能。</p>
<p>这里的附加 API 可以是现成的解决方案比如
<a href=https://github.com/kubernetes-sigs/metrics-server>metrics server</a>,
或者你自己开发的 API。</p>
<p>聚合层不同于
<a href=/zh/docs/concepts/extend-kubernetes/api-extension/custom-resources/>定制资源（Custom Resources）</a>。
后者的目的是让 <a class=glossary-tooltip title="提供 Kubernetes API 服务的控制面组件。" data-toggle=tooltip data-placement=top href=/zh/docs/reference/command-line-tools-reference/kube-apiserver/ target=_blank aria-label=kube-apiserver>kube-apiserver</a>
能够认识新的对象类别（Kind）。</p>
<h2 id=aggregation-layer>聚合层 </h2>
<p>聚合层在 kube-apiserver 进程内运行。在扩展资源注册之前，聚合层不做任何事情。
要注册 API，用户必须添加一个 APIService 对象，用它来“申领” Kubernetes API 中的 URL 路径。
自此以后，聚合层将会把发给该 API 路径的所有内容（例如 <code>/apis/myextension.mycompany.io/v1/…</code>）
转发到已注册的 APIService。</p>
<p>APIService 的最常见实现方式是在集群中某 Pod 内运行 <em>扩展 API 服务器</em>。
如果你在使用扩展 API 服务器来管理集群中的资源，该扩展 API 服务器（也被写成“extension-apiserver”）
一般需要和一个或多个<a class=glossary-tooltip title="控制器通过 apiserver 监控集群的公共状态，并致力于将当前状态转变为期望的状态。" data-toggle=tooltip data-placement=top href=/zh/docs/concepts/architecture/controller/ target=_blank aria-label=控制器>控制器</a>一起使用。
apiserver-builder 库同时提供构造扩展 API 服务器和控制器框架代码。</p>
<h3 id=response-latency>反应延迟 </h3>
<p>扩展 API 服务器与 kube-apiserver 之间需要存在低延迟的网络连接。
发现请求需要在五秒钟或更短的时间内完成到 kube-apiserver 的往返。</p>
<p>如果你的扩展 API 服务器无法满足这一延迟要求，应考虑如何更改配置以满足需要。</p>
<h2 id=what-s-next>What's next</h2>
<ul>
<li>阅读<a href=/zh/docs/tasks/extend-kubernetes/configure-aggregation-layer/>配置聚合层</a> 文档，
了解如何在自己的环境中启用聚合器。</li>
<li>接下来，了解<a href=/zh/docs/tasks/extend-kubernetes/setup-extension-api-server/>安装扩展 API 服务器</a>，
开始使用聚合层。</li>
<li>从 API 参考资料中研究关于 <a href=/docs/reference/kubernetes-api/cluster-resources/api-service-v1/>APIService</a> 的内容。</li>
</ul>
<p>或者，学习如何<a href=/zh/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/>使用自定义资源定义扩展 Kubernetes API</a>。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-3131452556176159fb269593c1a52012>2 - Operator 模式</h1>
<p>Operator 是 Kubernetes 的扩展软件，它利用
<a href=/zh/docs/concepts/extend-kubernetes/api-extension/custom-resources/>定制资源</a>
管理应用及其组件。
Operator 遵循 Kubernetes 的理念，特别是在<a href=/zh/docs/concepts/architecture/controller/>控制器</a>
方面。</p>
<h2 id=初衷>初衷</h2>
<p>Operator 模式旨在捕获（正在管理一个或一组服务的）运维人员的关键目标。
负责特定应用和 service 的运维人员，在系统应该如何运行、如何部署以及出现问题时如何处理等方面有深入的了解。</p>
<p>在 Kubernetes 上运行工作负载的人们都喜欢通过自动化来处理重复的任务。
Operator 模式会封装你编写的（Kubernetes 本身提供功能以外的）任务自动化代码。</p>
<h2 id=kubernetes-上的-operator>Kubernetes 上的 Operator</h2>
<p>Kubernetes 为自动化而生。无需任何修改，你即可以从 Kubernetes 核心中获得许多内置的自动化功能。
你可以使用 Kubernetes 自动化部署和运行工作负载， <em>甚至</em> 可以自动化 Kubernetes 自身。</p>
<p>Kubernetes 的 <a class=glossary-tooltip title=一种用于管理自定义资源的专用控制器 data-toggle=tooltip data-placement=top href=/zh/docs/concepts/extend-kubernetes/operator/ target=_blank aria-label="Operator 模式">Operator 模式</a>概念允许你在不修改
Kubernetes 自身代码的情况下，通过为一个或多个自定义资源关联<a class=glossary-tooltip title="控制器通过 apiserver 监控集群的公共状态，并致力于将当前状态转变为期望的状态。" data-toggle=tooltip data-placement=top href=/zh/docs/concepts/architecture/controller/ target=_blank aria-label=控制器>控制器</a>
来扩展集群的能力。
Operator 是 Kubernetes API 的客户端，充当
<a href=/zh/docs/concepts/extend-kubernetes/api-extension/custom-resources/>自定义资源</a>
的控制器。</p>
<h2 id=example>Operator 示例</h2>
<p>使用 Operator 可以自动化的事情包括：</p>
<ul>
<li>按需部署应用</li>
<li>获取/还原应用状态的备份</li>
<li>处理应用代码的升级以及相关改动。例如，数据库 schema 或额外的配置设置</li>
<li>发布一个 service，要求不支持 Kubernetes API 的应用也能发现它</li>
<li>模拟整个或部分集群中的故障以测试其稳定性</li>
<li>在没有内部成员选举程序的情况下，为分布式应用选择首领角色</li>
</ul>
<p>想要更详细的了解 Operator？下面是一个示例：</p>
<ol>
<li>有一个名为 SampleDB 的自定义资源，你可以将其配置到集群中。</li>
<li>一个包含 Operator 控制器部分的 Deployment，用来确保 Pod 处于运行状态。</li>
<li>Operator 代码的容器镜像。</li>
<li>控制器代码，负责查询控制平面以找出已配置的 SampleDB 资源。</li>
<li>Operator 的核心是告诉 API 服务器，如何使现实与代码里配置的资源匹配。
<ul>
<li>如果添加新的 SampleDB，Operator 将设置 PersistentVolumeClaims 以提供
持久化的数据库存储，设置 StatefulSet 以运行 SampleDB，并设置 Job
来处理初始配置。</li>
<li>如果你删除它，Operator 将建立快照，然后确保 StatefulSet 和 Volume 已被删除。</li>
</ul>
</li>
<li>Operator 也可以管理常规数据库的备份。对于每个 SampleDB 资源，Operator
会确定何时创建（可以连接到数据库并进行备份的）Pod。这些 Pod 将依赖于
ConfigMap 和/或具有数据库连接详细信息和凭据的 Secret。</li>
<li>由于 Operator 旨在为其管理的资源提供强大的自动化功能，因此它还需要一些
额外的支持性代码。在这个示例中，代码将检查数据库是否正运行在旧版本上，
如果是，则创建 Job 对象为你升级数据库。</li>
</ol>
<h2 id=部署-operator>部署 Operator</h2>
<p>部署 Operator 最常见的方法是将自定义资源及其关联的控制器添加到你的集群中。
跟运行容器化应用一样，控制器通常会运行在
<a class=glossary-tooltip title="控制平面是指容器编排层，它暴露 API 和接口来定义、部署容器和管理容器的生命周期。" data-toggle=tooltip data-placement=top href="/zh/docs/reference/glossary/?all=true#term-control-plane" target=_blank aria-label=控制平面>控制平面</a> 之外。
例如，你可以在集群中将控制器作为 Deployment 运行。</p>
<h2 id=using-operators>使用 Operator</h2>
<p>部署 Operator 后，你可以对 Operator 所使用的资源执行添加、修改或删除操作。
按照上面的示例，你将为 Operator 本身建立一个 Deployment，然后：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get SampleDB                   <span style=color:#080;font-style:italic># 查找所配置的数据库</span>

kubectl edit SampleDB/example-database <span style=color:#080;font-style:italic># 手动修改某些配置</span>
</code></pre></div>
<p>可以了！Operator 会负责应用所作的更改并保持现有服务处于良好的状态。</p>
<h2 id=writing-operator>编写你自己的 Operator</h2>
<p>如果生态系统中没可以实现你目标的 Operator，你可以自己编写代码。</p>
<p>你还可以使用任何支持 <a href=/zh/docs/reference/using-api/client-libraries/>Kubernetes API 客户端</a>
的语言或运行时来实现 Operator（即控制器）。</p>
<p>以下是一些库和工具，你可用于编写自己的云原生 Operator。</p>
<div class="alert alert-secondary callout third-party-content" role=alert><strong>Note:</strong>
This section links to third party projects that provide functionality required by Kubernetes. The Kubernetes project authors aren't responsible for these projects, which are listed alphabetically. To add a project to this list, read the <a href=/docs/contribute/style/content-guide/#third-party-content>content guide</a> before submitting a change. <a href=#third-party-content-disclaimer>More information.</a></div>
<ul>
<li><a href=https://juju.is/>Charmed Operator Framework</a></li>
<li><a href=https://github.com/nolar/kopf>Kopf</a> (Kubernetes Operator Pythonic Framework)</li>
<li><a href=https://book.kubebuilder.io/>kubebuilder</a></li>
<li><a href=https://buehler.github.io/dotnet-operator-sdk/>KubeOps</a> (dotnet operator SDK)</li>
<li><a href=https://kudo.dev/>KUDO</a> (Kubernetes 通用声明式 Operator)</li>
<li><a href=https://metacontroller.github.io/metacontroller/intro.html>Metacontroller</a>，可与 Webhooks 结合使用，以实现自己的功能。</li>
<li><a href=https://operatorframework.io>Operator Framework</a></li>
<li><a href=https://github.com/flant/shell-operator>shell-operator</a></li>
</ul>
<h2 id=what-s-next>What's next</h2>
<ul>
<li>阅读 <a class=glossary-tooltip title=云原生计算基金会 data-toggle=tooltip data-placement=top href=https://cncf.io/ target=_blank aria-label=CNCF>CNCF</a> <a href=https://github.com/cncf/tag-app-delivery/blob/eece8f7307f2970f46f100f51932db106db46968/operator-wg/whitepaper/Operator-WhitePaper_v1-0.md>Operator 白皮书</a>。</li>
<li>详细了解 <a href=/zh/docs/concepts/extend-kubernetes/api-extension/custom-resources/>定制资源</a></li>
<li>在 <a href=https://operatorhub.io/>OperatorHub.io</a> 上找到现成的、适合你的 Operator</li>
<li><a href=https://operatorhub.io/>发布</a>你的 Operator，让别人也可以使用</li>
<li>阅读 <a href=https://web.archive.org/web/20170129131616/https://coreos.com/blog/introducing-operators.html>CoreOS 原始文章</a>，它介绍了 Operator 模式（这是一个存档版本的原始文章）。</li>
<li>阅读这篇来自谷歌云的关于构建 Operator 最佳实践的
<a href=https://cloud.google.com/blog/products/containers-kubernetes/best-practices-for-building-kubernetes-operators-and-stateful-apps>文章</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-c8937cdc9df96f3328becf04f8211292>3 - 计算、存储和网络扩展</h1>
</div>
<div class=td-content>
<h1 id=pg-1ac2260db9ecccbf0303a899bc27ce6d>3.1 - 网络插件</h1>
<p>Kubernetes中的网络插件有几种类型：</p>
<ul>
<li>CNI 插件：遵守<a href=https://github.com/containernetworking/cni>容器网络接口（Container Network Interface，CNI）</a>
规范，其设计上偏重互操作性。
<ul>
<li>Kubernetes 遵从 CNI 规范的
<a href=https://github.com/containernetworking/cni/blob/spec-v0.4.0/SPEC.md>v0.4.0</a>
版本。</li>
</ul>
</li>
<li>Kubenet 插件：使用 <code>bridge</code> 和 <code>host-local</code> CNI 插件实现了基本的 <code>cbr0</code>。</li>
</ul>
<h2 id=安装>安装</h2>
<p>kubelet 有一个单独的默认网络插件，以及一个对整个集群通用的默认网络。
它在启动时探测插件，记住找到的内容，并在 Pod 生命周期的适当时间执行
所选插件（这仅适用于 Docker，因为 CRI 管理自己的 CNI 插件）。
在使用插件时，需要记住两个 kubelet 命令行参数：</p>
<ul>
<li><code>cni-bin-dir</code>： kubelet 在启动时探测这个目录中的插件</li>
<li><code>network-plugin</code>： 要使用的网络插件来自 <code>cni-bin-dir</code>。
它必须与从插件目录探测到的插件报告的名称匹配。
对于 CNI 插件，其值为 "cni"。</li>
</ul>
<h2 id=网络插件要求>网络插件要求</h2>
<p>除了提供
<a href=https://github.com/kubernetes/kubernetes/tree/v1.23.17/pkg/kubelet/dockershim/network/plugins.go><code>NetworkPlugin</code> 接口</a>
来配置和清理 Pod 网络之外，该插件还可能需要对 kube-proxy 的特定支持。
iptables 代理显然依赖于 iptables，插件可能需要确保 iptables 能够监控容器的网络通信。
例如，如果插件将容器连接到 Linux 网桥，插件必须将 <code>net/bridge/bridge-nf-call-iptables</code>
系统参数设置为<code>1</code>，以确保 iptables 代理正常工作。
如果插件不使用 Linux 网桥（而是类似于 Open vSwitch 或者其它一些机制），
它应该确保为代理对容器通信执行正确的路由。</p>
<p>默认情况下，如果未指定 kubelet 网络插件，则使用 <code>noop</code> 插件，
该插件设置 <code>net/bridge/bridge-nf-call-iptables=1</code>，以确保简单的配置
（如带网桥的 Docker ）与 iptables 代理正常工作。</p>
<h3 id=cni>CNI</h3>
<p>通过给 Kubelet 传递 <code>--network-plugin=cni</code> 命令行选项可以选择 CNI 插件。
Kubelet 从 <code>--cni-conf-dir</code> （默认是 <code>/etc/cni/net.d</code>） 读取文件并使用
该文件中的 CNI 配置来设置各个 Pod 的网络。
CNI 配置文件必须与
<a href=https://github.com/containernetworking/cni/blob/master/SPEC.md#network-configuration>CNI 规约</a>
匹配，并且配置所引用的所有所需的 CNI 插件都应存在于
<code>--cni-bin-dir</code>（默认是 <code>/opt/cni/bin</code>）下。</p>
<p>如果这个目录中有多个 CNI 配置文件，kubelet 将会使用按文件名的字典顺序排列
的第一个作为配置文件。</p>
<p>除了配置文件指定的 CNI 插件外，Kubernetes 还需要标准的 CNI
<a href=https://github.com/containernetworking/plugins/blob/master/plugins/main/loopback/loopback.go><code>lo</code></a>
插件，最低版本是0.2.0。</p>
<h4 id=支持-hostport>支持 hostPort</h4>
<p>CNI 网络插件支持 <code>hostPort</code>。 你可以使用官方
<a href=https://github.com/containernetworking/plugins/tree/master/plugins/meta/portmap>portmap</a>
插件，它由 CNI 插件团队提供，或者使用你自己的带有 portMapping 功能的插件。</p>
<p>如果你想要启动 <code>hostPort</code> 支持，则必须在 <code>cni-conf-dir</code> 指定 <code>portMappings capability</code>。
例如：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
  <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;k8s-pod-network&#34;</span>,
  <span style=color:green;font-weight:700>&#34;cniVersion&#34;</span>: <span style=color:#b44>&#34;0.3.0&#34;</span>,
  <span style=color:green;font-weight:700>&#34;plugins&#34;</span>: [
    {
      <span style=color:green;font-weight:700>&#34;type&#34;</span>: <span style=color:#b44>&#34;calico&#34;</span>,
      <span style=color:green;font-weight:700>&#34;log_level&#34;</span>: <span style=color:#b44>&#34;info&#34;</span>,
      <span style=color:green;font-weight:700>&#34;datastore_type&#34;</span>: <span style=color:#b44>&#34;kubernetes&#34;</span>,
      <span style=color:green;font-weight:700>&#34;nodename&#34;</span>: <span style=color:#b44>&#34;127.0.0.1&#34;</span>,
      <span style=color:green;font-weight:700>&#34;ipam&#34;</span>: {
        <span style=color:green;font-weight:700>&#34;type&#34;</span>: <span style=color:#b44>&#34;host-local&#34;</span>,
        <span style=color:green;font-weight:700>&#34;subnet&#34;</span>: <span style=color:#b44>&#34;usePodCidr&#34;</span>
      },
      <span style=color:green;font-weight:700>&#34;policy&#34;</span>: {
        <span style=color:green;font-weight:700>&#34;type&#34;</span>: <span style=color:#b44>&#34;k8s&#34;</span>
      },
      <span style=color:green;font-weight:700>&#34;kubernetes&#34;</span>: {
        <span style=color:green;font-weight:700>&#34;kubeconfig&#34;</span>: <span style=color:#b44>&#34;/etc/cni/net.d/calico-kubeconfig&#34;</span>
      }
    },
    {
      <span style=color:green;font-weight:700>&#34;type&#34;</span>: <span style=color:#b44>&#34;portmap&#34;</span>,
      <span style=color:green;font-weight:700>&#34;capabilities&#34;</span>: {<span style=color:green;font-weight:700>&#34;portMappings&#34;</span>: <span style=color:#a2f;font-weight:700>true</span>}
    }
  ]
}
</code></pre></div>
<h4 id=支持流量整形>支持流量整形</h4>
<p><strong>实验功能</strong></p>
<p>CNI 网络插件还支持 pod 入口和出口流量整形。
你可以使用 CNI 插件团队提供的
<a href=https://github.com/containernetworking/plugins/tree/master/plugins/meta/bandwidth>bandwidth</a>
插件，也可以使用你自己的具有带宽控制功能的插件。</p>
<p>如果你想要启用流量整形支持，你必须将 <code>bandwidth</code> 插件添加到 CNI 配置文件
（默认是 <code>/etc/cni/net.d</code>）并保证该可执行文件包含在你的 CNI 的 bin
文件夹内 (默认为 <code>/opt/cni/bin</code>)。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
  <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;k8s-pod-network&#34;</span>,
  <span style=color:green;font-weight:700>&#34;cniVersion&#34;</span>: <span style=color:#b44>&#34;0.3.0&#34;</span>,
  <span style=color:green;font-weight:700>&#34;plugins&#34;</span>: [
    {
      <span style=color:green;font-weight:700>&#34;type&#34;</span>: <span style=color:#b44>&#34;calico&#34;</span>,
      <span style=color:green;font-weight:700>&#34;log_level&#34;</span>: <span style=color:#b44>&#34;info&#34;</span>,
      <span style=color:green;font-weight:700>&#34;datastore_type&#34;</span>: <span style=color:#b44>&#34;kubernetes&#34;</span>,
      <span style=color:green;font-weight:700>&#34;nodename&#34;</span>: <span style=color:#b44>&#34;127.0.0.1&#34;</span>,
      <span style=color:green;font-weight:700>&#34;ipam&#34;</span>: {
        <span style=color:green;font-weight:700>&#34;type&#34;</span>: <span style=color:#b44>&#34;host-local&#34;</span>,
        <span style=color:green;font-weight:700>&#34;subnet&#34;</span>: <span style=color:#b44>&#34;usePodCidr&#34;</span>
      },
      <span style=color:green;font-weight:700>&#34;policy&#34;</span>: {
        <span style=color:green;font-weight:700>&#34;type&#34;</span>: <span style=color:#b44>&#34;k8s&#34;</span>
      },
      <span style=color:green;font-weight:700>&#34;kubernetes&#34;</span>: {
        <span style=color:green;font-weight:700>&#34;kubeconfig&#34;</span>: <span style=color:#b44>&#34;/etc/cni/net.d/calico-kubeconfig&#34;</span>
      }
    },
    {
      <span style=color:green;font-weight:700>&#34;type&#34;</span>: <span style=color:#b44>&#34;bandwidth&#34;</span>,
      <span style=color:green;font-weight:700>&#34;capabilities&#34;</span>: {<span style=color:green;font-weight:700>&#34;bandwidth&#34;</span>: <span style=color:#a2f;font-weight:700>true</span>}
    }
  ]
}
</code></pre></div>
<p>现在，你可以将 <code>kubernetes.io/ingress-bandwidth</code> 和 <code>kubernetes.io/egress-bandwidth</code>
注解添加到 pod 中。例如：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubernetes.io/ingress-bandwidth</span>:<span style=color:#bbb> </span>1M<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubernetes.io/egress-bandwidth</span>:<span style=color:#bbb> </span>1M<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></code></pre></div>
<h3 id=kubenet>kubenet</h3>
<p>Kubenet 是一个非常基本的、简单的网络插件，仅适用于 Linux。
它本身并不实现更高级的功能，如跨节点网络或网络策略。
它通常与云驱动一起使用，云驱动为节点间或单节点环境中的通信设置路由规则。</p>
<p>Kubenet 创建名为 <code>cbr0</code> 的网桥，并为每个 pod 创建了一个 veth 对，
每个 Pod 的主机端都连接到 <code>cbr0</code>。
这个 veth 对的 Pod 端会被分配一个 IP 地址，该 IP 地址隶属于节点所被分配的 IP
地址范围内。节点的 IP 地址范围则通过配置或控制器管理器来设置。
<code>cbr0</code> 被分配一个 MTU，该 MTU 匹配主机上已启用的正常接口的最小 MTU。</p>
<p>使用此插件还需要一些其他条件：</p>
<ul>
<li>需要标准的 CNI <code>bridge</code>、<code>lo</code> 以及 <code>host-local</code> 插件，最低版本是0.2.0。
kubenet 首先在 <code>/opt/cni/bin</code> 中搜索它们。 指定 <code>cni-bin-dir</code> 以提供
其它搜索路径。首次找到的匹配将生效。</li>
<li>Kubelet 必须和 <code>--network-plugin=kubenet</code> 参数一起运行，才能启用该插件。</li>
<li>Kubelet 还应该和 <code>--non-masquerade-cidr=&lt;clusterCidr></code> 参数一起运行，
以确保超出此范围的 IP 流量将使用 IP 伪装。</li>
<li>节点必须被分配一个 IP 子网，通过kubelet 命令行的 <code>--pod-cidr</code> 选项或
控制器管理器的命令行选项 <code>--allocate-node-cidrs=true --cluster-cidr=&lt;cidr></code>
来设置。</li>
</ul>
<h3 id=自定义-mtu-使用-kubenet>自定义 MTU（使用 kubenet）</h3>
<p>要获得最佳的网络性能，必须确保 MTU 的取值配置正确。
网络插件通常会尝试推断出一个合理的 MTU，但有时候这个逻辑不会产生一个最优的 MTU。
例如，如果 Docker 网桥或其他接口有一个小的 MTU, kubenet 当前将选择该 MTU。
或者如果你正在使用 IPSEC 封装，则必须减少 MTU，并且这种计算超出了大多数网络插件的能力范围。</p>
<p>如果需要，你可以使用 <code>network-plugin-mtu</code> kubelet 选项显式的指定 MTU。
例如：在 AWS 上 <code>eth0</code> MTU 通常是 9001，因此你可以指定 <code>--network-plugin-mtu=9001</code>。
如果你正在使用 IPSEC ，你可以减少它以允许封装开销，例如 <code>--network-plugin-mtu=8873</code>。</p>
<p>此选项会传递给网络插件； 当前 <strong>仅 kubenet 支持 <code>network-plugin-mtu</code></strong>。</p>
<h2 id=用法总结>用法总结</h2>
<ul>
<li><code>--network-plugin=cni</code> 用来表明我们要使用 <code>cni</code> 网络插件，实际的 CNI 插件
可执行文件位于 <code>--cni-bin-dir</code>（默认是 <code>/opt/cni/bin</code>）下， CNI 插件配置位于
<code>--cni-conf-dir</code>（默认是 <code>/etc/cni/net.d</code>）下。</li>
<li><code>--network-plugin=kubenet</code> 用来表明我们要使用 <code>kubenet</code> 网络插件，CNI <code>bridge</code>，<code>lo</code>
和 <code>host-local</code> 插件位于 <code>/opt/cni/bin</code> 或 <code>cni-bin-dir</code> 中。</li>
<li><code>--network-plugin-mtu=9001</code> 指定了我们使用的 MTU，当前仅被 <code>kubenet</code> 网络插件使用。</li>
</ul>
<h2 id=what-s-next>What's next</h2>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-53e1ea8892ceca307ba19e8d6a7b8d32>3.2 - 设备插件</h1>
<div class=lead>使用 Kubernetes 设备插件框架来实现适用于 GPU、NIC、FPGA、InfiniBand 以及类似的需要特定于供应商设置的资源的插件。</div>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.10 [beta]</code>
</div>
<p>Kubernetes 提供了一个
<a href=https://github.com/kubernetes/community/blob/master/contributors/design-proposals/resource-management/device-plugin.md>设备插件框架</a>，你可以用它来将系统硬件资源发布到 <a class=glossary-tooltip title="一个在集群中每个节点上运行的代理。它保证容器都运行在 Pod 中。" data-toggle=tooltip data-placement=top href=/docs/reference/generated/kubelet target=_blank aria-label=Kubelet>Kubelet</a>。</p>
<p>供应商可以实现设备插件，由你手动部署或作为 <a class=glossary-tooltip title="确保 Pod 的副本在集群中的一组节点上运行。" data-toggle=tooltip data-placement=top href=/zh/docs/concepts/workloads/controllers/daemonset/ target=_blank aria-label=DaemonSet>DaemonSet</a>
来部署，而不必定制 Kubernetes 本身的代码。目标设备包括 GPU、高性能 NIC、FPGA、
InfiniBand 适配器以及其他类似的、可能需要特定于供应商的初始化和设置的计算资源。</p>
<h2 id=device-plugin-registration>注册设备插件 </h2>
<p><code>kubelet</code> 提供了一个 <code>Registration</code> 的 gRPC 服务：</p>
<pre><code class=language-gRPC data-lang=gRPC>service Registration {
 rpc Register(RegisterRequest) returns (Empty) {}
}
</code></pre>
<p>设备插件可以通过此 gRPC 服务在 kubelet 进行注册。在注册期间，设备插件需要发送下面几样内容：</p>
<ul>
<li>设备插件的 Unix 套接字。</li>
<li>设备插件的 API 版本。</li>
<li><code>ResourceName</code> 是需要公布的。这里 <code>ResourceName</code> 需要遵循
<a href=/zh/docs/concepts/configuration/manage-resources-containers/#extended-resources>扩展资源命名方案</a>，
类似于 <code>vendor-domain/resourcetype</code>。（比如 NVIDIA GPU 就被公布为 <code>nvidia.com/gpu</code>。）</li>
</ul>
<p>成功注册后，设备插件就向 kubelet 发送它所管理的设备列表，然后 kubelet
负责将这些资源发布到 API 服务器，作为 kubelet 节点状态更新的一部分。</p>
<p>比如，设备插件在 kubelet 中注册了 <code>hardware-vendor.example/foo</code> 并报告了
节点上的两个运行状况良好的设备后，节点状态将更新以通告该节点已安装 2 个
"Foo" 设备并且是可用的。</p>
<p>然后用户需要请求其他类型的资源的时候，就可以在
<a href=/docs/reference/generated/kubernetes-api/v1.23/#container-v1-core>Container</a>
规范请求这类设备，但是有以下的限制：</p>
<ul>
<li>扩展资源仅可作为整数资源使用，并且不能被过量使用</li>
<li>设备不能在容器之间共享</li>
</ul>
<h3 id=example-pod>示例</h3>
<p>假设 Kubernetes 集群正在运行一个设备插件，该插件在一些节点上公布的资源为 <code>hardware-vendor.example/foo</code>。
下面就是一个 Pod 示例，请求此资源以运行一个工作负载的示例：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>demo-pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>demo-container-1<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/pause:2.0<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>hardware-vendor.example/foo</span>:<span style=color:#bbb> </span><span style=color:#666>2</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic>#</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># 这个 pod 需要两个 hardware-vendor.example/foo 设备</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># 而且只能够调度到满足需求的节点上</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic>#</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># 如果该节点中有 2 个以上的设备可用，其余的可供其他 Pod 使用</span><span style=color:#bbb>
</span></code></pre></div>
<h2 id=device-plugin-implementation>设备插件的实现 </h2>
<p>设备插件的常规工作流程包括以下几个步骤：</p>
<ul>
<li>
<p>初始化。在这个阶段，设备插件将执行供应商特定的初始化和设置，
以确保设备处于就绪状态。</p>
</li>
<li>
<p>插件使用主机路径 <code>/var/lib/kubelet/device-plugins/</code> 下的 Unix 套接字启动
一个 gRPC 服务，该服务实现以下接口：</p>
<pre><code class=language-gRPC data-lang=gRPC>service DevicePlugin {
      // GetDevicePluginOptions 返回与设备管理器沟通的选项。
      rpc GetDevicePluginOptions(Empty) returns (DevicePluginOptions) {}

      // ListAndWatch 返回 Device 列表构成的数据流。
      // 当 Device 状态发生变化或者 Device 消失时，ListAndWatch
      // 会返回新的列表。
      rpc ListAndWatch(Empty) returns (stream ListAndWatchResponse) {}

      // Allocate 在容器创建期间调用，这样设备插件可以运行一些特定于设备的操作，
      // 并告诉 kubelet 如何令 Device 可在容器中访问的所需执行的具体步骤
      rpc Allocate(AllocateRequest) returns (AllocateResponse) {}

      // GetPreferredAllocation 从一组可用的设备中返回一些优选的设备用来分配，
      // 所返回的优选分配结果不一定会是设备管理器的最终分配方案。
      // 此接口的设计仅是为了让设备管理器能够在可能的情况下做出更有意义的决定。
      rpc GetPreferredAllocation(PreferredAllocationRequest) returns (PreferredAllocationResponse) {}

      // PreStartContainer 在设备插件注册阶段根据需要被调用，调用发生在容器启动之前。
      // 在将设备提供给容器使用之前，设备插件可以运行一些诸如重置设备之类的特定于
      // 具体设备的操作，
      rpc PreStartContainer(PreStartContainerRequest) returns (PreStartContainerResponse) {}
}
</code></pre><div class="alert alert-info note callout" role=alert>
<strong>Note:</strong>
<p>插件并非必须为 <code>GetPreferredAllocation()</code> 或 <code>PreStartContainer()</code> 提供有用
的实现逻辑，调用 <code>GetDevicePluginOptions()</code> 时所返回的 <code>DevicePluginOptions</code>
消息中应该设置这些调用是否可用。<code>kubelet</code> 在真正调用这些函数之前，总会调用
<code>GetDevicePluginOptions()</code> 来查看是否存在这些可选的函数。
</div>
</li>
</ul>
<ul>
<li>插件通过 Unix socket 在主机路径 <code>/var/lib/kubelet/device-plugins/kubelet.sock</code>
处向 kubelet 注册自身。</li>
<li>成功注册自身后，设备插件将以服务模式运行，在此期间，它将持续监控设备运行状况，
并在设备状态发生任何变化时向 kubelet 报告。它还负责响应 <code>Allocate</code> gRPC 请求。
在 <code>Allocate</code> 期间，设备插件可能还会做一些设备特定的准备；例如 GPU 清理或 QRNG 初始化。
如果操作成功，则设备插件将返回 <code>AllocateResponse</code>，其中包含用于访问被分配的设备容器运行时的配置。
kubelet 将此信息传递到容器运行时。</li>
</ul>
<h3 id=处理-kubelet-重启>处理 kubelet 重启</h3>
<p>设备插件应能监测到 kubelet 重启，并且向新的 kubelet 实例来重新注册自己。
在当前实现中，当 kubelet 重启的时候，新的 kubelet 实例会删除 <code>/var/lib/kubelet/device-plugins</code>
下所有已经存在的 Unix 套接字。
设备插件需要能够监控到它的 Unix 套接字被删除，并且当发生此类事件时重新注册自己。</p>
<h2 id=设备插件部署>设备插件部署</h2>
<p>你可以将你的设备插件作为节点操作系统的软件包来部署、作为 DaemonSet 来部署或者手动部署。</p>
<p>规范目录 <code>/var/lib/kubelet/device-plugins</code> 是需要特权访问的，所以设备插件
必须要在被授权的安全的上下文中运行。
如果你将设备插件部署为 DaemonSet，<code>/var/lib/kubelet/device-plugins</code> 目录必须要在插件的
<a href=/docs/reference/generated/kubernetes-api/v1.23/#podspec-v1-core>PodSpec</a>
中声明作为 <a class=glossary-tooltip title="包含可被 Pod 中容器访问的数据的目录。" data-toggle=tooltip data-placement=top href=/zh/docs/concepts/storage/volumes/ target=_blank aria-label=卷（Volume）>卷（Volume）</a> 被挂载到插件中。</p>
<p>如果你选择 DaemonSet 方法，你可以通过 Kubernetes 进行以下操作：
将设备插件的 Pod 放置在节点上，在出现故障后重新启动守护进程 Pod，来进行自动升级。</p>
<h2 id=api-兼容性>API 兼容性</h2>
<p>Kubernetes 设备插件支持还处于 beta 版本。所以在稳定版本出来之前 API 会以不兼容的方式进行更改。
作为一个项目，Kubernetes 建议设备插件开发者：</p>
<ul>
<li>注意未来版本的更改</li>
<li>支持多个版本的设备插件 API，以实现向后/向前兼容性。</li>
</ul>
<p>如果你启用 DevicePlugins 功能，并在需要升级到 Kubernetes 版本来获得较新的设备插件 API
版本的节点上运行设备插件，请在升级这些节点之前先升级设备插件以支持这两个版本。
采用该方法将确保升级期间设备分配的连续运行。</p>
<h2 id=监控设备插件资源>监控设备插件资源</h2>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.15 [beta]</code>
</div>
<p>为了监控设备插件提供的资源，监控代理程序需要能够发现节点上正在使用的设备，
并获取元数据来描述哪个指标与容器相关联。
设备监控代理暴露给 <a href=https://prometheus.io/>Prometheus</a> 的指标应该遵循
<a href=https://github.com/kubernetes/community/blob/master/contributors/devel/sig-instrumentation/instrumentation.md>Kubernetes Instrumentation Guidelines</a>，
使用 <code>pod</code>、<code>namespace</code> 和 <code>container</code> 标签来标识容器。</p>
<p>kubelet 提供了 gRPC 服务来使得正在使用中的设备被发现，并且还未这些设备提供了元数据：</p>
<pre><code class=language-gRPC data-lang=gRPC>// PodResourcesLister 是一个由 kubelet 提供的服务，用来提供供节点上 
// Pods 和容器使用的节点资源的信息
service PodResourcesLister {
    rpc List(ListPodResourcesRequest) returns (ListPodResourcesResponse) {}
    rpc GetAllocatableResources(AllocatableResourcesRequest) returns (AllocatableResourcesResponse) {}
}
</code></pre><h3 id=grpc-endpoint-list><code>List</code> gRPC 端点</h3>
<p>这一 <code>List</code> 端点提供运行中 Pods 的资源信息，包括类似独占式分配的
CPU ID、设备插件所报告的设备 ID 以及这些设备分配所处的 NUMA 节点 ID。
此外，对于基于 NUMA 的机器，它还会包含为容器保留的内存和大页的信息。</p>
<pre><code class=language-gRPC data-lang=gRPC>// ListPodResourcesResponse 是 List 函数的响应
message ListPodResourcesResponse {
    repeated PodResources pod_resources = 1;
}

// PodResources 包含关于分配给 Pod 的节点资源的信息
message PodResources {
    string name = 1;
    string namespace = 2;
    repeated ContainerResources containers = 3;
}

// ContainerResources 包含分配给容器的资源的信息
message ContainerResources {
    string name = 1;
    repeated ContainerDevices devices = 2;
    repeated int64 cpu_ids = 3;
    repeated ContainerMemory memory = 4;
}

// ContainerMemory 包含分配给容器的内存和大页信息
message ContainerMemory {
    string memory_type = 1;
    uint64 size = 2;
    TopologyInfo topology = 3;
}

// Topology 描述资源的硬件拓扑结构
message TopologyInfo {
        repeated NUMANode nodes = 1;
}

// NUMA 代表的是 NUMA 节点
message NUMANode {
        int64 ID = 1;
}

// ContainerDevices 包含分配给容器的设备信息
message ContainerDevices {
    string resource_name = 1;
    repeated string device_ids = 2;
    TopologyInfo topology = 3;
}
</code></pre>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> <p><code>List</code> 端点中的 <code>ContainerResources</code> 中的 cpu_ids 对应于分配给某个容器的专属 CPU。
如果要统计共享池中的 CPU，<code>List</code> 端点需要与 <code>GetAllocatableResources</code> 端点一起使用，如下所述:</p>
<ol>
<li>调用 <code>GetAllocatableResources</code> 获取所有可用的 CPUs。</li>
<li>在系统中所有的 <code>ContainerResources</code> 上调用 <code>GetCpuIds</code>。</li>
<li>用 <code>GetAllocatableResources</code> 获取的 CPU 数减去 <code>GetCpuIds</code> 获取的 CPU 数。</li>
</ol>
</div>
<h3 id=grpc-endpoint-getallocatableresources><code>GetAllocatableResources</code> gRPC 端点</h3>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.23 [beta]</code>
</div>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> <code>GetAllocatableResources</code> 应该仅被用于评估一个节点上的<a href=/zh/docs/tasks/administer-cluster/reserve-compute-resources/#node-allocatable>可分配的</a>
资源。如果目标是评估空闲/未分配的资源，此调用应该与 List() 端点一起使用。
除非暴露给 kubelet 的底层资源发生变化 否则 <code>GetAllocatableResources</code> 得到的结果将保持不变。
这种情况很少发生，但当发生时（例如：热插拔，设备健康状况改变），客户端应该调用 <code>GetAlloctableResources</code> 端点。
然而，调用 <code>GetAllocatableResources</code> 端点在 cpu、内存被更新的情况下是不够的，
Kubelet 需要重新启动以获取正确的资源容量和可分配的资源。
</div>
<p>端点 <code>GetAllocatableResources</code> 提供最初在工作节点上可用的资源的信息。
此端点所提供的信息比导出给 API 服务器的信息更丰富。</p>
<pre><code class=language-gRPC data-lang=gRPC>// AllocatableResourcesResponses 包含 kubelet 所了解到的所有设备的信息
message AllocatableResourcesResponse {
    repeated ContainerDevices devices = 1;
    repeated int64 cpu_ids = 2;
    repeated ContainerMemory memory = 3;
}

</code></pre>
<p>从 Kubernetes v1.23 开始，<code>GetAllocatableResources</code> 被默认启用。
你可以通过关闭 <code>KubeletPodResourcesGetAllocatable</code>
<a href=/zh/docs/reference/command-line-tools-reference/feature-gates/>特性门控</a> 来禁用。</p>
<p>在 Kubernetes v1.23 之前，要启用这一功能，<code>kubelet</code> 必须用以下标志启动：</p>
<p><code>--feature-gates=KubeletPodResourcesGetAllocatable=true</code></p>
<p><code>ContainerDevices</code> 会向外提供各个设备所隶属的 NUMA 单元这类拓扑信息。
NUMA 单元通过一个整数 ID 来标识，其取值与设备插件所报告的一致。
<a href=/zh/docs/concepts/extend-kubernetes/compute-storage-net/device-plugins/>设备插件注册到 kubelet 时</a>
会报告这类信息。</p>
<p>gRPC 服务通过 <code>/var/lib/kubelet/pod-resources/kubelet.sock</code> 的 UNIX 套接字来提供服务。
设备插件资源的监控代理程序可以部署为守护进程或者 DaemonSet。
规范的路径 <code>/var/lib/kubelet/pod-resources</code> 需要特权来进入，
所以监控代理程序必须要在获得授权的安全的上下文中运行。
如果设备监控代理以 DaemonSet 形式运行，必须要在插件的
<a href=/docs/reference/generated/kubernetes-api/v1.23/#podspec-v1-core>PodSpec</a>
中声明将 <code>/var/lib/kubelet/pod-resources</code> 目录以
<a class=glossary-tooltip title="包含可被 Pod 中容器访问的数据的目录。" data-toggle=tooltip data-placement=top href=/zh/docs/concepts/storage/volumes/ target=_blank aria-label=卷>卷</a>的形式被挂载到设备监控代理中。</p>
<p>对“PodResourcesLister 服务”的支持要求启用 <code>KubeletPodResources</code>
<a href=/zh/docs/reference/command-line-tools-reference/feature-gates/>特性门控</a>。
从 Kubernetes 1.15 开始默认启用，自从 Kubernetes 1.20 开始为 v1。</p>
<h2 id=设备插件与拓扑管理器的集成>设备插件与拓扑管理器的集成</h2>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.18 [beta]</code>
</div>
<p>拓扑管理器是 Kubelet 的一个组件，它允许以拓扑对齐方式来调度资源。
为了做到这一点，设备插件 API 进行了扩展来包括一个 <code>TopologyInfo</code> 结构体。</p>
<pre><code class=language-gRPC data-lang=gRPC>message TopologyInfo {
 repeated NUMANode nodes = 1;
}

message NUMANode {
    int64 ID = 1;
}
</code></pre>
<p>设备插件希望拓扑管理器可以将填充的 TopologyInfo 结构体作为设备注册的一部分以及设备 ID
和设备的运行状况发送回去。然后设备管理器将使用此信息来咨询拓扑管理器并做出资源分配决策。</p>
<p><code>TopologyInfo</code> 支持定义 <code>nodes</code> 字段，允许为 <code>nil</code>（默认）或者是一个 NUMA 节点的列表。
这样就可以使设备插件可以跨越 NUMA 节点去发布。</p>
<p>下面是一个由设备插件为设备填充 <code>TopologyInfo</code> 结构体的示例：</p>
<pre><code>pluginapi.Device{ID: &quot;25102017&quot;, Health: pluginapi.Healthy, Topology:&amp;pluginapi.TopologyInfo{Nodes: []*pluginapi.NUMANode{&amp;pluginapi.NUMANode{ID: 0,},}}}
</code></pre>
<h2 id=examples>设备插件示例</h2>
<p>下面是一些设备插件实现的示例：</p>
<ul>
<li><a href=https://github.com/RadeonOpenCompute/k8s-device-plugin>AMD GPU 设备插件</a></li>
<li><a href=https://github.com/intel/intel-device-plugins-for-kubernetes>Intel 设备插件</a> 支持 Intel GPU、FPGA 和 QuickAssist 设备</li>
<li><a href=https://github.com/kubevirt/kubernetes-device-plugins>KubeVirt 设备插件</a> 用于硬件辅助的虚拟化</li>
<li>The <a href=https://github.com/NVIDIA/k8s-device-plugin>NVIDIA GPU 设备插件</a></li>
<li>需要 <a href=https://github.com/NVIDIA/nvidia-docker>nvidia-docker</a> 2.0，以允许运行 Docker 容器的时候启用 GPU。</li>
<li><a href=https://github.com/GoogleCloudPlatform/container-engine-accelerators/tree/master/cmd/nvidia_gpu>为 Container-Optimized OS 所提供的 NVIDIA GPU 设备插件</a></li>
<li><a href=https://github.com/hustcat/k8s-rdma-device-plugin>RDMA 设备插件</a></li>
<li><a href=https://github.com/collabora/k8s-socketcan>SocketCAN 设备插件</a></li>
<li><a href=https://github.com/vikaschoudhary16/sfc-device-plugin>Solarflare 设备插件</a></li>
<li><a href=https://github.com/intel/sriov-network-device-plugin>SR-IOV 网络设备插件</a></li>
<li><a href=https://github.com/Xilinx/FPGA_as_a_Service/tree/master/k8s-fpga-device-plugin>Xilinx FPGA 设备插件</a></li>
</ul>
<h2 id=what-s-next>What's next</h2>
<ul>
<li>查看<a href=/zh/docs/tasks/manage-gpus/scheduling-gpus/>调度 GPU 资源</a> 来学习使用设备插件</li>
<li>查看在上如何<a href=/zh/docs/tasks/administer-cluster/extended-resource-node/>公布节点上的扩展资源</a></li>
<li>阅读如何在 Kubernetes 中使用 <a href=https://kubernetes.io/blog/2019/04/24/hardware-accelerated-ssl/tls-termination-in-ingress-controllers-using-kubernetes-device-plugins-and-runtimeclass/>TLS Ingress 的硬件加速</a></li>
<li>学习<a href=/zh/docs/tasks/administer-cluster/topology-manager/>拓扑管理器</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-b26fcf43d01abc16c8110766026dafed>4 - 服务目录</h1>
<p><p>服务目录（Service Catalog）是 服务目录是一种扩展 API，它能让 Kubernetes 集群中运行的应用易于使用外部托管的的软件服务，例如云供应商提供的数据仓库服务。</p></p>
<p>服务目录可以检索、供应、和绑定由 <a class=glossary-tooltip title=由第三方提供并维护的一组托管服务的访问端点。 data-toggle=tooltip data-placement=top href="/zh/docs/reference/glossary/?all=true#term-service-broker" target=_blank aria-label="服务代理人（Service Brokers）">服务代理人（Service Brokers）</a>
提供的外部<a class=glossary-tooltip title=由第三方供应商负责维护的一种软件产品。 data-toggle=tooltip data-placement=top href="/zh/docs/reference/glossary/?all=true#term-managed-service" target=_blank aria-label="托管服务（Managed Services）">托管服务（Managed Services）</a>，
而无需知道那些服务具体是怎样创建和托管的。</p>
<p>服务代理（Service Broker）是由<a href=https://github.com/openservicebrokerapi/servicebroker/blob/v2.13/spec.md>Open Service Broker API 规范</a>定义的一组托管服务的端点，这些服务由第三方提供并维护，其中的第三方可以是 AWS、GCP 或 Azure 等云服务提供商。
托管服务的一些示例是 Microsoft Azure Cloud Queue、Amazon Simple Queue Service 和 Google Cloud Pub/Sub，但它们可以是应用程序能够使用的任何软件交付物。</p>
<p>使用服务目录，<a class=glossary-tooltip title=配置、控制、监控集群的人。 data-toggle=tooltip data-placement=top href="/zh/docs/reference/glossary/?all=true#term-cluster-operator" target=_blank aria-label=集群操作员>集群操作员</a>
可以浏览某服务代理所提供的托管服务列表，供应托管服务实例并与之绑定，
以使其可以被 Kubernetes 集群中的应用程序使用。</p>
<h2 id=示例用例>示例用例</h2>
<p><a class=glossary-tooltip title="编写可以在 Kubernetes 集群上运行的应用的人。" data-toggle=tooltip data-placement=top href="/zh/docs/reference/glossary/?all=true#term-application-developer" target=_blank aria-label=应用开发人员>应用开发人员</a>，
希望使用消息队列，作为其在 Kubernetes 集群中运行的应用程序的一部分。
但是，他们不想承受构造这种服务的开销，也不想自行管理。
幸运的是，有一家云服务提供商通过其服务代理以托管服务的形式提供消息队列服务。</p>
<p>集群操作员可以设置服务目录并使用它与云服务提供商的服务代理通信，进而部署消息队列服务的实例
并使其对 Kubernetes 中的应用程序可用。
应用开发者于是可以不关心消息队列的实现细节，也不用对其进行管理。
他们的应用程序可以简单的将其作为服务使用。</p>
<h2 id=architecture>架构 </h2>
<p>服务目录使用<a href=https://github.com/openservicebrokerapi/servicebroker>Open Service Broker API</a>
与服务代理进行通信，并作为 Kubernetes API 服务器的中介，以便协商启动部署和获取
应用程序使用托管服务时必须的凭据。</p>
<p>它是<a href=/zh/docs/concepts/extend-kubernetes/api-extension/custom-resources/#custom-resources>基于 CRDs</a>
架构实现的。</p>
<p><img src=/images/docs/service-catalog-architecture.svg alt=服务目录架构></p>
<h2 id=api-resources>API 资源</h2>
<p>服务目录安装 <code>servicecatalog.k8s.io</code> API 并提供以下 Kubernetes 资源：</p>
<ul>
<li><code>ClusterServiceBroker</code>：服务目录的集群内表现形式，封装了其服务连接细节。集群运维人员创建和管理这些资源，并希望使用该代理服务在集群中提供新类型的托管服务。</li>
<li><code>ClusterServiceClass</code>：由特定服务代理提供的托管服务。当新的 <code>ClusterServiceBroker</code> 资源被添加到集群时，服务目录控制器将连接到服务代理以获取可用的托管服务列表。然后为每个托管服务创建对应的新 <code>ClusterServiceClass</code> 资源。</li>
<li><code>ClusterServicePlan</code>：托管服务的特定产品。例如托管服务可能有不同的计划可用，如免费版本和付费版本，或者可能有不同的配置选项，例如使用 SSD 存储或拥有更多资源。与 <code>ClusterServiceClass</code> 类似，当一个新的 <code>ClusterServiceBroker</code> 被添加到集群时，服务目录会为每个托管服务的每个可用服务计划创建对应的新 <code>ClusterServicePlan</code> 资源。</li>
<li><code>ServiceInstance</code>：<code>ClusterServiceClass</code> 提供的示例。由集群运维人员创建，以使托管服务的特定实例可供一个或多个集群内应用程序使用。当创建一个新的 <code>ServiceInstance</code> 资源时，服务目录控制器将连接到相应的服务代理并指示它调配服务实例。</li>
<li><code>ServiceBinding</code>：<code>ServiceInstance</code> 的访问凭据。由希望其应用程序使用服务 <code>ServiceInstance</code> 的集群运维人员创建。创建之后，服务目录控制器将创建一个 Kubernetes <code>Secret</code>，其中包含服务实例的连接细节和凭据，可以挂载到 Pod 中。</li>
</ul>
<h3 id=authentication>认证 </h3>
<p>服务目录支持这些认证方法：</p>
<ul>
<li>基本认证（用户名/密码）</li>
<li><a href=https://tools.ietf.org/html/rfc6750>OAuth 2.0 不记名令牌</a></li>
</ul>
<h2 id=使用方式>使用方式</h2>
<p>集群运维人员可以使用服务目录 API 资源来供应托管服务并使其在 Kubernetes 集群内可用。涉及的步骤有：</p>
<ol>
<li>列出服务代理提供的托管服务和服务计划。</li>
<li>配置托管服务的新实例。</li>
<li>绑定到托管服务，它将返回连接凭证。</li>
<li>将连接凭证映射到应用程序中。</li>
</ol>
<h3 id=列出托管服务和服务计划>列出托管服务和服务计划</h3>
<p>首先，集群运维人员在 <code>servicecatalog.k8s.io</code> 组内创建一个 <code>ClusterServiceBroker</code> 资源。此资源包含访问服务代理终结点所需的 URL 和连接详细信息。</p>
<p>这是一个 <code>ClusterServiceBroker</code> 资源的例子：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>servicecatalog.k8s.io/v1beta1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterServiceBroker<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cloud-broker<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 指向服务代理的末端。(这里的 URL 是无法使用的。)</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>url</span>:<span style=color:#bbb>  </span>https://servicebroker.somecloudprovider.com/v1alpha1/projects/service-catalog/brokers/default<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic>#####</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 这里可以添加额外的用来与服务代理通信的属性值,</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 例如持有者令牌信息或者 TLS 的 CA 包。</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic>#####</span><span style=color:#bbb>
</span></code></pre></div>
<p>下面的时序图展示了从服务代理列出可用托管服务和计划所涉及的各个步骤：</p>
<p><img src=/images/docs/service-catalog-list.svg alt=列举服务></p>
<ol>
<li>一旦 <code>ClusterServiceBroker</code> 资源被添加到了服务目录之后，将会触发一个到外部服务代理的
调用，以列举所有可用服务；</li>
<li>服务代理返回可用的托管服务和服务计划列表，这些列表将本地缓存在 <code>ClusterServiceClass</code>
和 <code>ClusterServicePlan</code> 资源中。</li>
<li>集群运维人员接下来可以使用以下命令获取可用托管服务的列表：</li>
</ol>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get clusterserviceclasses <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  -o<span style=color:#666>=</span>custom-columns<span style=color:#666>=</span>SERVICE<span style=color:#b62;font-weight:700>\ </span>NAME:.metadata.name,EXTERNAL<span style=color:#b62;font-weight:700>\ </span>NAME:.spec.externalName
</code></pre></div><p>它应该输出一个和以下格式类似的服务名称列表：</p>
<pre><code>SERVICE NAME                           EXTERNAL NAME
4f6e6cf6-ffdd-425f-a2c7-3c9258ad2468   cloud-provider-service
...                                    ...
</code></pre><p>他们还可以使用以下命令查看可用的服务计划：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get clusterserviceplans <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>   -o<span style=color:#666>=</span>custom-columns<span style=color:#666>=</span>PLAN<span style=color:#b62;font-weight:700>\ </span>NAME:.metadata.name,EXTERNAL<span style=color:#b62;font-weight:700>\ </span>NAME:.spec.externalName
</code></pre></div><pre><code>它应该输出一个和以下格式类似的服务计划列表：
</code></pre>
<pre><code>PLAN NAME                              EXTERNAL NAME
86064792-7ea2-467b-af93-ac9694d96d52   service-plan-name
...                                    ...
</code></pre>
<h3 id=供应一个新实例>供应一个新实例</h3>
<p>集群运维人员 可以通过创建一个 <code>ServiceInstance</code> 资源来启动一个新实例的配置。</p>
<p>下面是一个 <code>ServiceInstance</code> 资源的例子：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>servicecatalog.k8s.io/v1beta1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ServiceInstance<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cloud-queue-instance<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>cloud-apps<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 引用之前返回的服务之一</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>clusterServiceClassExternalName</span>:<span style=color:#bbb> </span>cloud-provider-service<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>clusterServicePlanExternalName</span>:<span style=color:#bbb> </span>service-plan-name<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic>#####</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 这里可添加额外的参数，供服务代理使用</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic>#####</span><span style=color:#bbb>
</span></code></pre></div>
<p>以下时序图展示了配置托管服务新实例所涉及的步骤：</p>
<p><img src=/images/docs/service-catalog-provision.svg alt=供应服务></p>
<ol>
<li>创建 <code>ServiceInstance</code> 资源时，服务目录将启动一个到外部服务代理的调用，
请求供应一个实例。</li>
<li>服务代理创建一个托管服务的新实例并返回 HTTP 响应。</li>
<li>接下来，集群运维人员可以检查实例的状态是否就绪。</li>
</ol>
<h3 id=绑定到托管服务>绑定到托管服务</h3>
<p>在设置新实例之后，集群运维人员必须绑定到托管服务才能获取应用程序使用服务所需的连接凭据和服务账户的详细信息。该操作通过创建一个 <code>ServiceBinding</code> 资源完成。</p>
<p>以下是 <code>ServiceBinding</code> 资源的示例：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>servicecatalog.k8s.io/v1beta1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ServiceBinding<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cloud-queue-binding<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>cloud-apps<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>instanceRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cloud-queue-instance<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic>#####</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 这里可以添加供服务代理使用的额外信息，例如 Secret 名称或者服务账号参数，</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic>#####</span><span style=color:#bbb>
</span></code></pre></div>
<p>以下顺序图展示了绑定到托管服务实例的步骤：</p>
<p><img src=/images/docs/service-catalog-bind.svg alt=绑定到托管服务></p>
<ol>
<li>在创建 <code>ServiceBinding</code> 之后，服务目录调用外部服务代理，请求绑定服务实例所需的信息。</li>
<li>服务代理为相应服务账户启用应用权限/角色。</li>
<li>服务代理返回连接和访问托管服务示例所需的信息。这是由提供商和服务特定的，故返回的信息可能因服务提供商和其托管服务而有所不同。</li>
</ol>
<h3 id=映射连接凭据>映射连接凭据</h3>
<p>完成绑定之后的最后一步就是将连接凭据和服务特定的信息映射到应用程序中。这些信息存储在 secret 中，集群中的应用程序可以访问并使用它们直接与托管服务进行连接。</p>
<br>
<p><img src=/images/docs/service-catalog-map.svg alt=映射连接凭据></p>
<h4 id=pod-配置文件>Pod 配置文件</h4>
<p>执行此映射的一种方法是使用声明式 Pod 配置。</p>
<p>以下示例描述了如何将服务账户凭据映射到应用程序中。名为 <code>sa-key</code> 的密钥保存在一个名为
<code>provider-cloud-key</code> 的卷中，应用程序会将该卷挂载在 <code>/var/secrets/provider/key.json</code>
路径下。环境变量 <code>PROVIDER_APPLICATION_CREDENTIALS</code> 将映射为挂载文件的路径。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>provider-cloud-key<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>secret</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>secretName</span>:<span style=color:#bbb> </span>sa-key<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>provider-cloud-key<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/var/secrets/provider<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>PROVIDER_APPLICATION_CREDENTIALS<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/var/secrets/provider/key.json&#34;</span><span style=color:#bbb>
</span></code></pre></div>
<p>以下示例描述了如何将 Secret 值映射为应用程序的环境变量。
在这个示例中，消息队列的主题名从 Secret <code>provider-queue-credentials</code> 中名为
<code>topic</code> 的主键映射到环境变量 <code>TOPIC</code> 中。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;TOPIC&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
</span><span style=color:#bbb>                </span><span style=color:green;font-weight:700>secretKeyRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>                   </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>provider-queue-credentials<span style=color:#bbb>
</span><span style=color:#bbb>                   </span><span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>topic<span style=color:#bbb>
</span></code></pre></div><h2 id=what-s-next>What's next</h2>
<ul>
<li>如果你熟悉 <a class=glossary-tooltip title="Helm Chart 是一组预先配置的 Kubernetes 资源所构成的包，可以使用 Helm 工具对其进行管理。" data-toggle=tooltip data-placement=top href=https://github.com/kubernetes/helm/blob/master/docs/charts.md target=_blank aria-label="Helm Charts">Helm Charts</a>，
可以<a href=/zh/docs/tasks/service-catalog/install-service-catalog-using-helm/>使用 Helm 安装服务目录</a>
到 Kubernetes 集群中。或者，你可以
<a href=/zh/docs/tasks/service-catalog/install-service-catalog-using-sc/>使用 SC 工具安装服务目录</a>。</li>
<li>查看<a href=https://github.com/openservicebrokerapi/servicebroker/blob/master/gettingStarted.md#sample-service-brokers>服务代理示例</a></li>
<li>浏览 <a href=https://github.com/kubernetes-sigs/service-catalog>kubernetes-sigs/service-catalog</a> 项目</li>
</ul>
</div>
</main>
</div>
</div>
<footer class=d-print-none>
<div class=footer__links>
<nav>
<a class=text-white href=/zh/docs/home/>主页</a>
<a class=text-white href=/zh/blog/>博客</a>
<a class=text-white href=/zh/training/>培训</a>
<a class=text-white href=/zh/partners/>合作伙伴</a>
<a class=text-white href=/zh/community/>社区</a>
<a class=text-white href=/zh/case-studies/>案例分析</a>
</nav>
</div>
<div class=container-fluid>
<div class=row>
<div class="col-6 col-sm-2 text-xs-center order-sm-2">
<ul class="list-inline mb-0">
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="User mailing list" aria-label="User mailing list">
<a class=text-white target=_blank href=https://discuss.kubernetes.io>
<i class="fa fa-envelope"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Twitter aria-label=Twitter>
<a class=text-white target=_blank href=https://twitter.com/kubernetesio>
<i class="fab fa-twitter"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Calendar aria-label=Calendar>
<a class=text-white target=_blank href="https://calendar.google.com/calendar/embed?src=calendar%40kubernetes.io">
<i class="fas fa-calendar-alt"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Youtube aria-label=Youtube>
<a class=text-white target=_blank href=https://youtube.com/kubernetescommunity>
<i class="fab fa-youtube"></i>
</a>
</li>
</ul>
</div>
<div class="col-6 col-sm-2 text-right text-xs-center order-sm-3">
<ul class="list-inline mb-0">
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub>
<a class=text-white target=_blank href=https://github.com/kubernetes/kubernetes>
<i class="fab fa-github"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Slack aria-label=Slack>
<a class=text-white target=_blank href=https://slack.k8s.io>
<i class="fab fa-slack"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Contribute aria-label=Contribute>
<a class=text-white target=_blank href=https://git.k8s.io/community/contributors/guide>
<i class="fas fa-edit"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Stack Overflow" aria-label="Stack Overflow">
<a class=text-white target=_blank href=https://stackoverflow.com/questions/tagged/kubernetes>
<i class="fab fa-stack-overflow"></i>
</a>
</li>
</ul>
</div>
<div class="col-12 col-sm-8 text-center order-sm-2">
<small class=text-white>&copy; 2023 The Kubernetes Authors | Documentation Distributed under <a href=https://git.k8s.io/website/LICENSE class=light-text>CC BY 4.0</a></small>
<br>
<small class=text-white>Copyright &copy; 2023 The Linux Foundation &reg;. All rights reserved. The Linux Foundation has registered trademarks and uses trademarks. For a list of trademarks of The Linux Foundation, please see our <a href=https://www.linuxfoundation.org/trademark-usage class=light-text>Trademark Usage page</a></small>
<br>
<small class=text-white>ICP license: 京ICP备17074266号-3</small>
</div>
</div>
</div>
</footer>
</div>
<script src=/js/popper-1.14.3.min.js integrity=sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49 crossorigin=anonymous></script>
<script src=/js/bootstrap-4.3.1.min.js integrity=sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM crossorigin=anonymous></script>
<script src=/js/main.min.40616251a9b6e4b689e7769be0340661efa4d7ebb73f957404e963e135b4ed52.js integrity="sha256-QGFiUam25LaJ53ab4DQGYe+k1+u3P5V0BOlj4TW07VI=" crossorigin=anonymous></script>
</body>
</html>