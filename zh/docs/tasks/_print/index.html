<!doctype html><html lang=zh class=no-js>
<head>
<meta name=ROBOTS content="NOINDEX, NOFOLLOW">
<script async src="https://www.googletagmanager.com/gtag/js?id=G-JPP6RFM2BP"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-JPP6RFM2BP')</script>
<link rel=alternate hreflang=en href=https://kubernetes.io/docs/tasks/>
<link rel=alternate hreflang=ko href=https://kubernetes.io/ko/docs/tasks/>
<link rel=alternate hreflang=ja href=https://kubernetes.io/ja/docs/tasks/>
<link rel=alternate hreflang=fr href=https://kubernetes.io/fr/docs/tasks/>
<link rel=alternate hreflang=de href=https://kubernetes.io/de/docs/tasks/>
<link rel=alternate hreflang=es href=https://kubernetes.io/es/docs/tasks/>
<link rel=alternate hreflang=pt-br href=https://kubernetes.io/pt-br/docs/tasks/>
<link rel=alternate hreflang=id href=https://kubernetes.io/id/docs/tasks/>
<link rel=alternate hreflang=pl href=https://kubernetes.io/pl/docs/tasks/>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=generator content="Hugo 0.87.0">
<link rel=canonical type=text/html href=https://kubernetes.io/zh/docs/tasks/>
<link rel="shortcut icon" type=image/png href=/images/favicon.png>
<link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180>
<link rel=manifest href=/manifest.webmanifest>
<link rel=apple-touch-icon href=/images/kubernetes-192x192.png>
<title>任务 | Kubernetes</title><meta property="og:title" content="任务">
<meta property="og:description" content="生产级别的容器编排系统">
<meta property="og:type" content="website">
<meta property="og:url" content="https://kubernetes.io/zh/docs/tasks/"><meta property="og:site_name" content="Kubernetes">
<meta itemprop=name content="任务">
<meta itemprop=description content="生产级别的容器编排系统"><meta name=twitter:card content="summary">
<meta name=twitter:title content="任务">
<meta name=twitter:description content="生产级别的容器编排系统">
<link href=/scss/main.css rel=stylesheet>
<script src=/js/jquery-3.3.1.min.js integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin=anonymous></script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","url":"https://kubernetes.io","logo":"https://kubernetes.io/images/favicon.png"}</script>
<meta name=theme-color content="#326ce5">
<link rel=stylesheet href=/css/feature-states.css>
<meta name=description content="Kubernetes 文档这一部分包含的一些页面展示如何去完成单个任务。 每个任务页面是一般通过给出若干步骤展示如何执行完成某事。
如果你希望编写一个任务页面，参考 创建一个文档拉取请求。">
<meta property="og:description" content="Kubernetes 文档这一部分包含的一些页面展示如何去完成单个任务。 每个任务页面是一般通过给出若干步骤展示如何执行完成某事。
如果你希望编写一个任务页面，参考 创建一个文档拉取请求。">
<meta name=twitter:description content="Kubernetes 文档这一部分包含的一些页面展示如何去完成单个任务。 每个任务页面是一般通过给出若干步骤展示如何执行完成某事。
如果你希望编写一个任务页面，参考 创建一个文档拉取请求。">
<meta property="og:url" content="https://kubernetes.io/zh/docs/tasks/">
<meta property="og:title" content="任务">
<meta name=twitter:title content="任务">
<meta name=twitter:image content="https://kubernetes.io/images/favicon.png">
<meta name=twitter:image:alt content="Kubernetes">
<meta property="og:image" content="/images/kubernetes-horizontal-color.png">
<meta property="og:type" content="article">
<script src=/js/script.js></script>
</head>
<body class=td-section>
<header>
<nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar" data-auto-burger=primary>
<a class=navbar-brand href=/zh/></a>
<div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar>
<ul class="navbar-nav mt-2 mt-lg-0">
<li class="nav-item mr-2 mb-lg-0">
<a class="nav-link active" href=/zh/docs/>文档</a>
</li>
<li class="nav-item mr-2 mb-lg-0">
<a class=nav-link href=/zh/blog/>Kubernetes 博客</a>
</li>
<li class="nav-item mr-2 mb-lg-0">
<a class=nav-link href=/zh/training/>培训</a>
</li>
<li class="nav-item mr-2 mb-lg-0">
<a class=nav-link href=/zh/partners/>合作伙伴</a>
</li>
<li class="nav-item mr-2 mb-lg-0">
<a class=nav-link href=/zh/community/>社区</a>
</li>
<li class="nav-item mr-2 mb-lg-0">
<a class=nav-link href=/zh/case-studies/>案例分析</a>
</li>
<li class="nav-item dropdown">
<a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>
Versions
</a>
<div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink>
<a class=dropdown-item href=/releases>Release Information</a>
<a class=dropdown-item href=https://kubernetes.io/zh/docs/tasks/>v1.27</a>
<a class=dropdown-item href=https://v1-26.docs.kubernetes.io/zh/docs/tasks/>v1.26</a>
<a class=dropdown-item href=https://v1-25.docs.kubernetes.io/zh/docs/tasks/>v1.25</a>
<a class=dropdown-item href=https://v1-24.docs.kubernetes.io/zh/docs/tasks/>v1.24</a>
<a class=dropdown-item href=https://v1-23.docs.kubernetes.io/zh/docs/tasks/>v1.23</a>
</div>
</li>
<li class="nav-item dropdown">
<a class="nav-link dropdown-toggle" href=# id=navbarDropdownMenuLink role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>
中文 Chinese
</a>
<div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink>
<a class=dropdown-item href=/docs/tasks/>English</a>
<a class=dropdown-item href=/ko/docs/tasks/>한국어 Korean</a>
<a class=dropdown-item href=/ja/docs/tasks/>日本語 Japanese</a>
<a class=dropdown-item href=/fr/docs/tasks/>Français</a>
<a class=dropdown-item href=/de/docs/tasks/>Deutsch</a>
<a class=dropdown-item href=/es/docs/tasks/>Español</a>
<a class=dropdown-item href=/pt-br/docs/tasks/>Português</a>
<a class=dropdown-item href=/id/docs/tasks/>Bahasa Indonesia</a>
<a class=dropdown-item href=/pl/docs/tasks/>Polski</a>
</div>
</li>
</ul>
</div>
<button id=hamburger onclick=kub.toggleMenu() data-auto-burger-exclude><div></div></button>
</nav>
</header>
<div class="container-fluid td-outer">
<div class=td-main>
<div class="row flex-xl-nowrap">
<main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main>
<div class=td-content>
<div class="pageinfo pageinfo-primary d-print-none">
<p>
这是本节的多页打印视图。
<a href=# onclick="return print(),!1">点击此处打印</a>.
</p><p>
<a href=/zh/docs/tasks/>返回本页常规视图</a>.
</p>
</div>
<h1 class=title>任务</h1>
<ul>
<li>1: <a href=#pg-57bf66f59d9a642b82eebeabbc66470b>安装工具</a></li>
<ul>
<li>1.1: <a href=#pg-37b6179f23c8ad977cb9daa6d2da748a>在 Linux 系统中安装并设置 kubectl</a></li>
<li>1.2: <a href=#pg-961fc70b732cb8df4fd11a3463b6545c>在 macOS 系统上安装和设置 kubectl</a></li>
<li>1.3: <a href=#pg-2cc93d3011d707aeb6564bab02048f7a>在 Windows 上安装 kubectl</a></li>
<li>1.4: <a href=#pg-91639f08dfa86a6c88cf0099b2e097bc>内含的工具</a></li>
<ul>
<li>1.4.1: <a href=#pg-643b1104b7b31ae10b173acfb447843a>fish 自动补全</a></li>
<li>1.4.2: <a href=#pg-d4ebbbe0a2ddce15850a36dfede9ba52>kubectl-convert 概述</a></li>
<li>1.4.3: <a href=#pg-2d600cc8ec4dec69673b5f9577b6da22>Linux 系统中的 bash 自动补全功能</a></li>
<li>1.4.4: <a href=#pg-68808b3ec5807517ed64fd8ae32a7d1b>macOS 系统上的 bash 自动补全</a></li>
<li>1.4.5: <a href=#pg-730f5a835775a8e94bd1c481d3f1a349>PowerShell 自动补全</a></li>
<li>1.4.6: <a href=#pg-9ab27577326839cb4793fd670a916364>zsh 自动补全</a></li>
<li>1.4.7: <a href=#pg-99d563e9521796074ba3ca7f15a613ce>后续内容</a></li>
<li>1.4.8: <a href=#pg-b2d43b2ae3e8f26eefa83de2db4ba782>验证 kubectl 的安装效果</a></li>
</ul>
</ul>
<li>2: <a href=#pg-5ff0cdcf7701f887e45d629f5cfe0424>资源指标管道</a></li>
<li>3: <a href=#pg-34a810f1516ad9d99b2697e36e9b0d0f>管理集群</a></li>
<ul>
<li>3.1: <a href=#pg-adb6c52e773f4d890595e14a9251f59b>从 dockershim 迁移</a></li>
<ul>
<li>3.1.1: <a href=#pg-b8acce0768c2f92cdb8eaa31e8072353>将节点上的容器运行时从 Docker Engine 改为 containerd</a></li>
<li>3.1.2: <a href=#pg-d79db9ed1698f75ec5f2228987290e49>查明节点上所使用的容器运行时</a></li>
<li>3.1.3: <a href=#pg-58702e4818c09c9b3d574349c1a71cb3>检查弃用 Dockershim 对你的影响</a></li>
<li>3.1.4: <a href=#pg-eb3e279a6c5e1224e744080a52ee3f28>从 dockershim 迁移遥测和安全代理</a></li>
</ul>
<li>3.2: <a href=#pg-8e16d69617b175d61e2e7a6e1642c9d6>用 kubeadm 进行管理</a></li>
<ul>
<li>3.2.1: <a href=#pg-f62fba1de4084f3be070785757c8079c>使用 kubeadm 进行证书管理</a></li>
<li>3.2.2: <a href=#pg-6134c5061298affa145ddb801b5c29da>配置 cgroup 驱动</a></li>
<li>3.2.3: <a href=#pg-98530eb3653d28fef34bff4543364aa7>重新配置 kubeadm 集群</a></li>
<li>3.2.4: <a href=#pg-2e173356df5179cab9eec90a606f0aa4>升级 kubeadm 集群</a></li>
<li>3.2.5: <a href=#pg-9133578f1e75663bb031e5a377ca896d>添加 Windows 节点</a></li>
<li>3.2.6: <a href=#pg-e805c7d8d4ad6195cb82dbbc843bfc29>升级 Windows 节点</a></li>
</ul>
<li>3.3: <a href=#pg-47be5dd51f686017f1766e6ec7aa6f41>管理内存，CPU 和 API 资源</a></li>
<ul>
<li>3.3.1: <a href=#pg-337620c76587e4aeb32009cb23be46de>为命名空间配置默认的内存请求和限制</a></li>
<li>3.3.2: <a href=#pg-320af95e480962c538ebef7ae205845c>为命名空间配置默认的 CPU 请求和限制</a></li>
<li>3.3.3: <a href=#pg-adb489b1ab985c9215657b0d4c6ae92b>配置命名空间的最小和最大内存约束</a></li>
<li>3.3.4: <a href=#pg-a87cbd1f9379dac7a48ae320da68a9ad>为命名空间配置 CPU 最小和最大约束</a></li>
<li>3.3.5: <a href=#pg-fe3283559a3df299aae3ee00ecea2fad>为命名空间配置内存和 CPU 配额</a></li>
<li>3.3.6: <a href=#pg-40e30a9209e0c9f4153707e43243e9d7>配置命名空间下 Pod 配额</a></li>
</ul>
<li>3.4: <a href=#pg-7743f043c43f7b12e8654e2227dbc658>证书</a></li>
<li>3.5: <a href=#pg-8c31aafd38fad5b0de0bd191758d6f93>安装网络策略驱动</a></li>
<ul>
<li>3.5.1: <a href=#pg-b4418905b0c14630e4e9cb1368241534>使用 Antrea 提供 NetworkPolicy</a></li>
<li>3.5.2: <a href=#pg-1239a77618c6278373832a142cd85519>使用 Calico 提供 NetworkPolicy</a></li>
<li>3.5.3: <a href=#pg-95039241255a31df196beaa405b68eba>使用 Cilium 提供 NetworkPolicy</a></li>
<li>3.5.4: <a href=#pg-505a0a6a7e6eff361bbb3be81c84b2e0>使用 kube-router 提供 NetworkPolicy</a></li>
<li>3.5.5: <a href=#pg-2842eac98aa0e229a5c6755c4c83d2a7>使用 Romana 提供 NetworkPolicy</a></li>
<li>3.5.6: <a href=#pg-ac075c3fdfd0d41aa753cc70e42be064>使用 Weave Net 提供 NetworkPolicy</a></li>
</ul>
<li>3.6: <a href=#pg-b45f024608e1b367cdacb1fd9d77278a>IP Masquerade Agent 用户指南</a></li>
<li>3.7: <a href=#pg-ce4cd28c8feb9faa783e79b48af37961>Kubernetes 云管理控制器</a></li>
<li>3.8: <a href=#pg-c4d0832845adc92b7ccd54aed63fc932>为 Kubernetes 运行 etcd 集群</a></li>
<li>3.9: <a href=#pg-b64a1d2bb3f4ed9f7021134e09a75c36>为系统守护进程预留计算资源</a></li>
<li>3.10: <a href=#pg-a8f6511197efcd7d0db80ade49620f9d>为节点发布扩展资源</a></li>
<li>3.11: <a href=#pg-f6f3b8f9789fda4286bf410b8e108f69>以非root用户身份运行 Kubernetes 节点组件</a></li>
<li>3.12: <a href=#pg-e1afcdac8d5e8458274b3c481c5ebcda>使用 CoreDNS 进行服务发现</a></li>
<li>3.13: <a href=#pg-669c88964b4a9eb2b040057266e4b60d>使用 KMS 驱动进行数据加密</a></li>
<li>3.14: <a href=#pg-e77685d5b88d2db5c7631a27b9472eea>使用 Kubernetes API 访问集群</a></li>
<li>3.15: <a href=#pg-778055e4a4415ca195169b42cd42ddf9>使用 NUMA 感知的内存管理器</a></li>
<li>3.16: <a href=#pg-12001be83d15fcd7f3242313a55777df>保护集群</a></li>
<li>3.17: <a href=#pg-4a02bcca41439e16655f43fa37c81da4>关键插件 Pod 的调度保证</a></li>
<li>3.18: <a href=#pg-fe6b50655c29ab0b7c1ee549ff64c138>升级集群</a></li>
<li>3.19: <a href=#pg-56de8c25b1486599777034111645b803>名字空间演练</a></li>
<li>3.20: <a href=#pg-09cc2cf3e0f23a3996e6cb31dc4d867c>启用/禁用 Kubernetes API</a></li>
<li>3.21: <a href=#pg-9ceed97f912df7289ed8872e290cfbad>在 Kubernetes 集群中使用 NodeLocal DNSCache</a></li>
<li>3.22: <a href=#pg-fe5ad73163d38596340536ec03a205f0>在 Kubernetes 集群中使用 sysctl</a></li>
<li>3.23: <a href=#pg-eec61e72c300dbfbf7302400ca966432>在运行中的集群上重新配置节点的 kubelet</a></li>
<li>3.24: <a href=#pg-4e9de5bc3973e5d2bb8f09ff940c3319>在集群中使用级联删除</a></li>
<li>3.25: <a href=#pg-a3790dfb57271d13517e549dffa805b9>声明网络策略</a></li>
<li>3.26: <a href=#pg-b35b8ddb9bbc15620ce9636f4346c05c>安全地清空一个节点</a></li>
<li>3.27: <a href=#pg-9585dc0efb0450fd68728e7511754717>开发云控制器管理器</a></li>
<li>3.28: <a href=#pg-00733cc3747eb3f5fe1c9e0439262967>开启服务拓扑</a></li>
<li>3.29: <a href=#pg-7127e6b7344b315b30b1ce8c4d8bfc55>控制节点上的 CPU 管理策略</a></li>
<li>3.30: <a href=#pg-8060aed5bf1172fa62199a4c306a4cd1>控制节点上的拓扑管理策略</a></li>
<li>3.31: <a href=#pg-2bffd7f3571cdd609bd97fb2e1bdb2fe>改变默认 StorageClass</a></li>
<li>3.32: <a href=#pg-fbc9136f53eccd6eb8c80f4bbea3b8f4>更改 PersistentVolume 的回收策略</a></li>
<li>3.33: <a href=#pg-966cd1cc69c69410d8698b3ac74abce2>自动扩缩集群 DNS 服务</a></li>
<li>3.34: <a href=#pg-3d0cd7d2f13d4759094f281504cf57b8>自定义 DNS 服务</a></li>
<li>3.35: <a href=#pg-8bcf4aeb5bbb6d6969a146e5ab97557b>调试 DNS 问题</a></li>
<li>3.36: <a href=#pg-a24171610b6ea75a142cb9c8c7882390>迁移多副本的控制面以使用云控制器管理器</a></li>
<li>3.37: <a href=#pg-1e966f5d0540bbee0876f9d0d08d54dc>通过名字空间共享集群</a></li>
<li>3.38: <a href=#pg-f58763cc9447491b6c40f939a02d441d>通过配置文件设置 Kubelet 参数</a></li>
<li>3.39: <a href=#pg-5e59f5575dce11fdaed640afdbeedfc1>配置 API 对象配额</a></li>
<li>3.40: <a href=#pg-a02f35804917d7a269c38d7e2c475005>限制存储消耗</a></li>
<li>3.41: <a href=#pg-6b4e7ca6586f448c8533a120c29bdd25>静态加密 Secret 数据</a></li>
</ul>
<li>4: <a href=#pg-20165c8269bed123bfb94fb6e7f85643>节点健康监测</a></li>
<li>5: <a href=#pg-f5da33b976758a9183018c421eb83f58>配置 Pods 和容器</a></li>
<ul>
<li>5.1: <a href=#pg-e6dd9300cf3a955f7cdfe77fb5d15292>为容器和 Pod 分配内存资源</a></li>
<li>5.2: <a href=#pg-aa522472483f900008124a2809f2114b>为 Windows Pod 和容器配置 GMSA</a></li>
<li>5.3: <a href=#pg-f5da7517bee8a8807431d9fc65263b39>为 Windows 的 Pod 和容器配置 RunAsUserName</a></li>
<li>5.4: <a href=#pg-8555af270ae7122cc0464bab3f5d1609>为容器和 Pods 分配 CPU 资源</a></li>
<li>5.5: <a href=#pg-3fbf113e9e5f4b46f8ccb91a048509c0>创建 Windows HostProcess Pod</a></li>
<li>5.6: <a href=#pg-904cea8c8efd5c0d33adbfe579ec2dd2>配置 Pod 的服务质量</a></li>
<li>5.7: <a href=#pg-4219ac6ab56a3b88d20305083d57d03c>为容器分派扩展资源</a></li>
<li>5.8: <a href=#pg-484833fb880d1e179cc2965d15f84da5>配置 Pod 以使用卷进行存储</a></li>
<li>5.9: <a href=#pg-528d2422215cb9632b7b45e886b023b5>配置 Pod 以使用 PersistentVolume 作为存储</a></li>
<li>5.10: <a href=#pg-4621938ba53c04a77f51b5938a583439>配置 Pod 使用投射卷作存储</a></li>
<li>5.11: <a href=#pg-abd895c0803315e9717e6ff9ec4e3d30>为 Pod 或容器配置安全上下文</a></li>
<li>5.12: <a href=#pg-2c0d882359718c4c69c67099bed2156c>为 Pod 配置服务账户</a></li>
<li>5.13: <a href=#pg-d385b86a7cb496d3b1c3b2a47280ca70>从私有仓库拉取镜像</a></li>
<li>5.14: <a href=#pg-eb54daf87df373096b5e830680194dfc>配置存活、就绪和启动探测器</a></li>
<li>5.15: <a href=#pg-bbc17480da6d051c696489654c64064a>将 Pod 分配给节点</a></li>
<li>5.16: <a href=#pg-fc3f4777ae8ea685d2b54e175277ac01>用节点亲和性把 Pods 分配到节点</a></li>
<li>5.17: <a href=#pg-1e7baac1825631a5af5d2aebcf059249>配置 Pod 初始化</a></li>
<li>5.18: <a href=#pg-efbc43486296f0439d1a89c12d944d94>为容器的生命周期事件设置处理函数</a></li>
<li>5.19: <a href=#pg-ed34e761c3dbd00fa79577fa78e30020>配置 Pod 使用 ConfigMap</a></li>
<li>5.20: <a href=#pg-3d7b9cb24a647c36ba63f7a02ec49010>在 Pod 中的容器之间共享进程命名空间</a></li>
<li>5.21: <a href=#pg-42a59b878d4c58e5c6f4bb87483dda93>创建静态 Pod</a></li>
<li>5.22: <a href=#pg-1bb997c61a85de753d9994e7a312a291>将 Docker Compose 文件转换为 Kubernetes 资源</a></li>
<li>5.23: <a href=#pg-0a91fdc1445a8c7f3563c41a9b9b3370>从 PodSecurityPolicy 迁移到内置的 PodSecurity 准入控制器</a></li>
<li>5.24: <a href=#pg-9c9966a13899846a35113763603cd6db>使用名字空间标签来实施 Pod 安全性标准</a></li>
<li>5.25: <a href=#pg-108be708e50a97cae1cc0b67d5f360b7>通过配置内置准入控制器实施 Pod 安全标准</a></li>
</ul>
<li>6: <a href=#pg-aa0731e8aa8e2f6cc9e3c1a5e9895863>管理 Kubernetes 对象</a></li>
<ul>
<li>6.1: <a href=#pg-df206392be6f4d19bd8da41cee7170fa>使用配置文件对 Kubernetes 对象进行声明式管理</a></li>
<li>6.2: <a href=#pg-11aa6950fcb203094823c8e2cbdd517f>使用 Kustomize 对 Kubernetes 对象进行声明式管理</a></li>
<li>6.3: <a href=#pg-80c83fe9b80d0fef2681c8d59c0aa197>使用指令式命令管理 Kubernetes 对象</a></li>
<li>6.4: <a href=#pg-b18886277c410fc6f32ce068e2160537>使用配置文件对 Kubernetes 对象进行命令式管理</a></li>
<li>6.5: <a href=#pg-d4d4414dc91b63cfe0f65ca4f0c2fe31>使用 kubectl patch 更新 API 对象</a></li>
</ul>
<li>7: <a href=#pg-94f49ece137035764368f22a98942872>管理 Secrets</a></li>
<ul>
<li>7.1: <a href=#pg-0ed63ce3c9665aed7ff5a560ff1da843>使用 kubectl 管理 Secret</a></li>
<li>7.2: <a href=#pg-e841cf91fd3566db1e86143ed7a9e13c>使用配置文件管理 Secret</a></li>
<li>7.3: <a href=#pg-a0ff2e3ba8af5670d5dc3d94c4bd0a68>使用 Kustomize 管理 Secret</a></li>
</ul>
<li>8: <a href=#pg-866924fa095f897ede8dfdcab9e97942>给应用注入数据</a></li>
<ul>
<li>8.1: <a href=#pg-c9af1e81bb6e109f6c41febe44f0931b>为容器设置启动时要执行的命令和参数</a></li>
<li>8.2: <a href=#pg-82c93897176489678232542102daea40>为容器设置环境变量</a></li>
<li>8.3: <a href=#pg-eff97c25c917cdb414eda016df0e2bca>定义相互依赖的环境变量</a></li>
<li>8.4: <a href=#pg-66c0456fdbef5e5116dd606d1e6f73cc>通过环境变量将 Pod 信息呈现给容器</a></li>
<li>8.5: <a href=#pg-bcf93d1cd019501fd0b7649e9fbcaf60>通过文件将 Pod 信息呈现给容器</a></li>
<li>8.6: <a href=#pg-7f9454a1e775548c23ee5b300a9218a3>使用 Secret 安全地分发凭证</a></li>
</ul>
<li>9: <a href=#pg-a78a5e7e765fd8c49c8f7c0d72499f72>运行应用</a></li>
<ul>
<li>9.1: <a href=#pg-790ea02857492b3a822e981e93e3a98b>使用 Deployment 运行一个无状态应用</a></li>
<li>9.2: <a href=#pg-43398a6f5dc7ce19df59f5f4c2e7922d>运行一个单实例有状态应用</a></li>
<li>9.3: <a href=#pg-95b3d561509c573e53bec2368264cf6a>运行一个有状态的应用程序</a></li>
<li>9.4: <a href=#pg-c43537b0ee1da992ecb7488f87e6c934>删除 StatefulSet</a></li>
<li>9.5: <a href=#pg-f5f2f7a74377a9d45325c5253353fa8f>强制删除 StatefulSet 中的 Pods</a></li>
<li>9.6: <a href=#pg-0c0bb1bd76d2a9069e50e2cec6d20c2a>Pod 水平自动扩缩</a></li>
<li>9.7: <a href=#pg-8138226ce9660ac8e3e82ff86fff8ad2>Horizontal Pod Autoscaler 演练</a></li>
<li>9.8: <a href=#pg-fbe2744f00d1aa4df4cdf4eea6a082d4>为应用程序设置干扰预算（Disruption Budget）</a></li>
<li>9.9: <a href=#pg-52cd10ee3fc7c74a6c31043a2d489878>从 Pod 中访问 Kubernetes API</a></li>
<li>9.10: <a href=#pg-7a9b5779e228083ba3fdeaf414fe704e>扩缩 StatefulSet</a></li>
</ul>
<li>10: <a href=#pg-ca3bc4e31dfe46d5044a3b93eb804ee9>运行 Jobs</a></li>
<ul>
<li>10.1: <a href=#pg-964bdff888520740e5e221695245678d>使用 CronJob 运行自动化任务</a></li>
<li>10.2: <a href=#pg-1058efa4d70f13c015e6a2094ff85068>使用工作队列进行粗粒度并行处理</a></li>
<li>10.3: <a href=#pg-457c9dd93aed2b05615ed28dc38075d3>使用工作队列进行精细的并行处理</a></li>
<li>10.4: <a href=#pg-9e63850014876afaebd1561f70bb8f6b>使用索引作业完成静态工作分配下的并行处理</a></li>
<li>10.5: <a href=#pg-da7c2b067953d239eb4457e8978ad8f6>使用展开的方式进行并行处理</a></li>
</ul>
<li>11: <a href=#pg-b74b959f5a531003dd0653dfbfc2e88b>访问集群中的应用程序</a></li>
<ul>
<li>11.1: <a href=#pg-777447042cd4e81df3fa5beb3357a485>部署和访问 Kubernetes 仪表板（Dashboard）</a></li>
<li>11.2: <a href=#pg-6a8d9e9e05f2b6825afbb8889c957370>访问集群</a></li>
<li>11.3: <a href=#pg-72d3dddbc0c166c9a364e753d2b31ff0>使用端口转发来访问集群中的应用</a></li>
<li>11.4: <a href=#pg-312f29f850826b74618634cd877aa065>使用服务来访问集群中的应用</a></li>
<li>11.5: <a href=#pg-f3dac629bea950fc026d920306f09fb4>使用 Service 把前端连接到后端</a></li>
<li>11.6: <a href=#pg-21cd8f87563675fb0278d3694ba9ecb0>创建外部负载均衡器</a></li>
<li>11.7: <a href=#pg-48e8f306f919c5b81265e265a2b76ab4>列出集群中所有运行容器的镜像</a></li>
<li>11.8: <a href=#pg-1839d8468a083839ed1cc8d18fe1142e>在 Minikube 环境中使用 NGINX Ingress 控制器配置 Ingress</a></li>
<li>11.9: <a href=#pg-322786b38586b210fab68f785259c5f6>为集群配置 DNS</a></li>
<li>11.10: <a href=#pg-7c319a9981586e5fbcfa21b392720650>同 Pod 内的容器使用共享卷通信</a></li>
<li>11.11: <a href=#pg-43591bb11cc02c39e278cf07f6546810>访问集群上运行的服务</a></li>
<li>11.12: <a href=#pg-5a233e14205d77fe1294917d2da6f876>配置对多集群的访问</a></li>
</ul>
<li>12: <a href=#pg-f6a755efe831d24956501e4bcd49ff96>监控、日志和排错</a></li>
<ul>
<li>12.1: <a href=#pg-731bb8b338c16aebfb9590ba2bd3fdd1></a></li>
<li>12.2: <a href=#pg-5e4a82f171ec2c11da7360a67efb4abf>使用 crictl 对 Kubernetes 节点进行调试</a></li>
<li>12.3: <a href=#pg-cbd33a50cc4779f855318a0dd00d7b06>审计</a></li>
<li>12.4: <a href=#pg-3556c4dbd027b9e90a5b3d72649003fb>应用故障排查</a></li>
<li>12.5: <a href=#pg-434e0133d71583a27478b10fc1d3d105>故障诊断</a></li>
<li>12.6: <a href=#pg-ef360b1f8e65236251826db478cfcab3>确定 Pod 失败的原因</a></li>
<li>12.7: <a href=#pg-9713ac27b6d9e3034033200d968221f2>获取正在运行容器的 Shell</a></li>
<li>12.8: <a href=#pg-06bb252f25983de12f635c806d180d30>调试 Init 容器</a></li>
<li>12.9: <a href=#pg-858517cd46a1b5a1fd2e650edd785cea>调试 Pods 和 ReplicationControllers</a></li>
<li>12.10: <a href=#pg-f79645981e310858111bd5673614cab6>调试 Service</a></li>
<li>12.11: <a href=#pg-a070b1250ee142402d492b505a56ca83>调试StatefulSet</a></li>
<li>12.12: <a href=#pg-c0ec963f381296ca26b839cdf0a6f242>调试运行中的 Pod</a></li>
<li>12.13: <a href=#pg-9e6e1b706f11386fe2c4b4ffda1409e4>资源监控工具</a></li>
<li>12.14: <a href=#pg-47290c80fb8b00accec6729f3da49734>集群故障排查</a></li>
</ul>
<li>13: <a href=#pg-11a6d16334428909c99e7208ab8fa5e9>扩展 Kubernetes</a></li>
<ul>
<li>13.1: <a href=#pg-8f1f7f0d3a1cc21537506bd4f9103a29>使用自定义资源</a></li>
<ul>
<li>13.1.1: <a href=#pg-dc64883f1fd119402b112d3ff6733452>使用 CustomResourceDefinition 扩展 Kubernetes API</a></li>
<li>13.1.2: <a href=#pg-7d2e2400f208b1637530752794e5a3bd>CustomResourceDefinition 的版本</a></li>
</ul>
<li>13.2: <a href=#pg-2bd28753e62a14a597073fa8ea18a5d8>配置聚合层</a></li>
<li>13.3: <a href=#pg-c4798e42eaccc051e396542befb3c57b>安装一个扩展的 API server</a></li>
<li>13.4: <a href=#pg-c00a2767fac9dbfafce583cf489cc423>配置多个调度器</a></li>
<li>13.5: <a href=#pg-1707517970dd390995f760308c2e2de6>使用 HTTP 代理访问 Kubernetes API</a></li>
<li>13.6: <a href=#pg-61cf1f2f0fbe98e7635fce65f04a775f>设置 Konnectivity 服务</a></li>
</ul>
<li>14: <a href=#pg-d3c88a8663f58e9ec0bed73faff5b670>TLS</a></li>
<ul>
<li>14.1: <a href=#pg-1272b18ac0c008f6ffc2c62a29fa929f>为 kubelet 配置证书轮换</a></li>
<li>14.2: <a href=#pg-43d5e2b1fc2a7e104e66d481d08578dc>手动轮换 CA 证书</a></li>
<li>14.3: <a href=#pg-9a87de8ee8332cb487f34a05debb1125>管理集群中的 TLS 认证</a></li>
</ul>
<li>15: <a href=#pg-ba58efa15c6d46f10e34d799be220965>管理集群守护进程</a></li>
<ul>
<li>15.1: <a href=#pg-bcfd795e4b59420f7db275a0482af37c>对 DaemonSet 执行滚动更新</a></li>
<li>15.2: <a href=#pg-f1bf7e426f482a85e1a417d1fd9ea7b7>对 DaemonSet 执行回滚</a></li>
</ul>
<li>16: <a href=#pg-5266308e17490aeee8b018316bf47e03>安装服务目录</a></li>
<ul>
<li>16.1: <a href=#pg-f741b6fc36e27a6f79c1c3d02a40d8f9>使用 Helm 安装 Service Catalog</a></li>
<li>16.2: <a href=#pg-d85a30635b5c3578487b9f6f214c07ea>使用 SC 安装服务目录</a></li>
</ul>
<li>17: <a href=#pg-a701e71f3b32dae474c63ae4c596c856>网络</a></li>
<ul>
<li>17.1: <a href=#pg-2edb5b02ea1e646c333c9fe4d5f02ff1>使用 HostAliases 向 Pod /etc/hosts 文件添加条目</a></li>
<li>17.2: <a href=#pg-eebac062766222247063d6513f95c7b2>验证 IPv4/IPv6 双协议栈</a></li>
</ul>
<li>18: <a href=#pg-6ca4f22ef4d1713577ada4815f0a3b5a>使用 crictl 对 Kubernetes 节点进行调试</a></li>
<li>19: <a href=#pg-60dca0ec8d41f0045e7d73e1d6bd7bce>使用 telepresence 在本地开发和调试服务</a></li>
<li>20: <a href=#pg-38387ad04dd284933cb502944ea3515b>审计</a></li>
<li>21: <a href=#pg-f34d6e348a8e677d6c6eb155cd1a99aa>用插件扩展 kubectl</a></li>
<li>22: <a href=#pg-fdfb2a2cba62a1e624897eaebac0168e>管理巨页（HugePages）</a></li>
<li>23: <a href=#pg-5ab7bc7f14942c5c4b29d19f4a87271c>调度 GPUs</a></li>
<li>24: <a href=#pg-cb9e28c208c6cfbabdb15ba2e42e9ef0>资源监控工具</a></li>
<li>25: <a href=#pg-0c4484d31ad3902880897e694bbd306f>配置 kubelet 镜像凭据提供程序</a></li>
</ul>
<div class=content>
<p>Kubernetes 文档这一部分包含的一些页面展示如何去完成单个任务。
每个任务页面是一般通过给出若干步骤展示如何执行完成某事。</p>
<p>如果你希望编写一个任务页面，参考
<a href=/zh/docs/contribute/new-content/open-a-pr/>创建一个文档拉取请求</a>。</p>
</div>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-57bf66f59d9a642b82eebeabbc66470b>1 - 安装工具</h1>
<div class=lead>在你的计算机上设置 Kubernetes 工具。</div>
<h2 id=kubectl>kubectl</h2>
<p>Kubernetes 命令行工具，<a href=/docs/reference/kubectl/kubectl/>kubectl</a>，使得你可以对 Kubernetes 集群运行命令。
你可以使用 kubectl 来部署应用、监测和管理集群资源以及查看日志。</p>
<p>有关更多信息，包括 kubectl 操作的完整列表，请参见<a href=/zh/docs/reference/kubectl/><code>kubectl</code>
参考文件</a>。</p>
<p>kubectl 可安装在各种 Linux 平台、 macOS 和 Windows 上。
在下面找到你喜欢的操作系统。</p>
<ul>
<li><a href=/zh/docs/tasks/tools/install-kubectl-linux>在 Linux 上安装 kubectl</a></li>
<li><a href=/zh/docs/tasks/tools/install-kubectl-macos>在 macOS 上安装 kubectl</a></li>
<li><a href=/zh/docs/tasks/tools/install-kubectl-windows>在 Windows 上安装 kubectl</a></li>
</ul>
<h2 id=kind>kind</h2>
<p><a href=https://kind.sigs.k8s.io/docs/><code>kind</code></a> 让你能够在本地计算机上运行 Kubernetes。
<code>kind</code> 要求你安装并配置好 <a href=https://docs.docker.com/get-docker/>Docker</a>。</p>
<p>kind <a href=https://kind.sigs.k8s.io/docs/user/quick-start/>快速入门</a>页面展示了
开始使用 <code>kind</code> 所需要完成的操作。</p>
<p><a class="btn btn-primary" href=https://kind.sigs.k8s.io/docs/user/quick-start/ role=button aria-label="查看 kind 的快速入门指南">
查看 kind 的快速入门指南
</a></p>
<h2 id=minikube>minikube</h2>
<p>与 <code>kind</code> 类似，<a href=https://minikube.sigs.k8s.io/><code>minikube</code></a> 是一个工具，
能让你在本地运行 Kubernetes。
<code>minikube</code> 在你本地的个人计算机（包括 Windows、macOS 和 Linux PC）运行一个单节点的
Kubernetes 集群，以便你来尝试 Kubernetes 或者开展每天的开发工作。</p>
<p>如果你关注如何安装此工具，可以按官方的
<a href=https://minikube.sigs.k8s.io/docs/start/>Get Started!</a>指南操作。</p>
<p><a class="btn btn-primary" href=https://minikube.sigs.k8s.io/docs/start/ role=button aria-label="查看 minikube 快速入门指南">
查看 minikube 快速入门指南
</a></p>
<p>当你拥有了可工作的 <code>minikube</code> 时，就可以用它来
<a href=/zh/docs/tutorials/hello-minikube/>运行示例应用</a>了。</p>
<h2 id=kubeadm>kubeadm</h2>
<p>你可以使用 <a class=glossary-tooltip title="用来快速安装 Kubernetes 并搭建安全稳定的集群的工具。" data-toggle=tooltip data-placement=top href=/zh/docs/setup/production-environment/tools/kubeadm/ target=_blank aria-label=kubeadm>kubeadm</a> 工具来
创建和管理 Kubernetes 集群。
该工具能够执行必要的动作并用一种用户友好的方式启动一个可用的、安全的集群。</p>
<p><a href=/zh/docs/setup/production-environment/tools/kubeadm/install-kubeadm/>安装 kubeadm</a>
展示了如何安装 kubeadm 的过程。
一旦安装了 kubeadm，你就可以使用它来
<a href=/zh/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/>创建一个集群</a>。</p>
<p><a class="btn btn-primary" href=/zh/docs/setup/production-environment/tools/kubeadm/install-kubeadm/ role=button aria-label="查看 kubeadm 安装指南">查看 kubeadm 安装指南</a></p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-37b6179f23c8ad977cb9daa6d2da748a>1.1 - 在 Linux 系统中安装并设置 kubectl</h1>
<h2 id=before-you-begin>Before you begin</h2>
<p>kubectl 版本和集群版本之间的差异必须在一个小版本号内。
例如：v1.23 版本的客户端能与 v1.22、
v1.23 和 v1.24 版本的控制面通信。
用最新兼容版的 kubectl 有助于避免不可预见的问题。</p>
<h2 id=install-kubectl-on-linux>在 Linux 系统中安装 kubectl</h2>
<p>在 Linux 系统中安装 kubectl 有如下几种方法：</p>
<ul>
<li><a href=#install-kubectl-binary-with-curl-on-linux>用 curl 在 Linux 系统中安装 kubectl</a></li>
<li><a href=#install-using-native-package-management>用原生包管理工具安装</a></li>
<li><a href=#install-using-other-package-management>用其他包管理工具安装</a></li>
</ul>
<h3 id=install-kubectl-binary-with-curl-on-linux>用 curl 在 Linux 系统中安装 kubectl</h3>
<ol>
<li>
<p>用以下命令下载最新发行版：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>curl -LO <span style=color:#b44>&#34;https://dl.k8s.io/release/</span><span style=color:#a2f;font-weight:700>$(</span>curl -L -s https://dl.k8s.io/release/stable.txt<span style=color:#a2f;font-weight:700>)</span><span style=color:#b44>/bin/linux/amd64/kubectl&#34;</span>
</code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>Note:</strong>
<p>如需下载某个指定的版本，请用指定版本号替换该命令的这一部分：
<code>$(curl -L -s https://dl.k8s.io/release/stable.txt)</code>。</p>
<p>例如，要在 Linux 中下载 v1.23.17 版本，请输入：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>curl -LO https://dl.k8s.io/release/v1.23.17/bin/linux/amd64/kubectl
</code></pre></div>
</div>
</li>
</ol>
<ol start=2>
<li>
<p>验证该可执行文件（可选步骤）</p>
<p>下载 kubectl 校验和文件：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>curl -LO <span style=color:#b44>&#34;https://dl.k8s.io/</span><span style=color:#a2f;font-weight:700>$(</span>curl -L -s https://dl.k8s.io/release/stable.txt<span style=color:#a2f;font-weight:700>)</span><span style=color:#b44>/bin/linux/amd64/kubectl.sha256&#34;</span>
</code></pre></div>
<p>基于校验和文件，验证 kubectl 的可执行文件：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#a2f>echo</span> <span style=color:#b44>&#34;</span><span style=color:#a2f;font-weight:700>$(</span>cat kubectl.sha256<span style=color:#a2f;font-weight:700>)</span><span style=color:#b44>  kubectl&#34;</span> | sha256sum --check
</code></pre></div>
<p>验证通过时，输出为：</p>
<pre><code class=language-console data-lang=console>kubectl: OK
</code></pre>
<p>验证失败时，<code>sha256</code> 将以非零值退出，并打印如下输出：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl: FAILED
sha256sum: WARNING: <span style=color:#666>1</span> computed checksum did NOT match
</code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>Note:</strong>
<p>下载的 kubectl 与校验和文件版本必须相同。
</div>
</li>
</ol>
<ol start=3>
<li>
<p>安装 kubectl</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>sudo install -o root -g root -m <span style=color:#666>0755</span> kubectl /usr/local/bin/kubectl
</code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>Note:</strong>
<p>即使你没有目标系统的 root 权限，仍然可以将 kubectl 安装到目录 <code>~/.local/bin</code> 中：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>chmod +x kubectl
mkdir -p ~/.local/bin
mv ./kubectl ~/.local/bin/kubectl
<span style=color:#080;font-style:italic># 之后将 ~/.local/bin 附加（或前置）到 $PATH</span>
</code></pre></div>
</div>
</li>
</ol>
<ol start=4>
<li>
<p>执行测试，以保障你安装的版本是最新的：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl version --client
</code></pre></div><p>或者使用如下命令来查看版本的详细信息：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cmd data-lang=cmd>kubectl version --client --output=yaml
</code></pre></div></li>
</ol>
<h3 id=install-using-native-package-management>用原生包管理工具安装</h3>
<ul class="nav nav-tabs" id=kubectl-install role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#kubectl-install-0 role=tab aria-controls=kubectl-install-0 aria-selected=true>Ubuntu、Debian 或 HypriotOS</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#kubectl-install-1 role=tab aria-controls=kubectl-install-1>基于 Red Hat 的发行版</a></li></ul>
<div class=tab-content id=kubectl-install><div id=kubectl-install-0 class="tab-pane show active" role=tabpanel aria-labelledby=kubectl-install-0>
<p>
<ol>
<li>
<p>更新 <code>apt</code> 包索引，并安装使用 Kubernetes <code>apt</code> 仓库所需要的包：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>sudo apt-get update
sudo apt-get install -y apt-transport-https ca-certificates curl
</code></pre></div></li>
</ol>
<ol start=2>
<li>
<p>下载 Google Cloud 公开签名秘钥：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>sudo curl -fsSLo /usr/share/keyrings/kubernetes-archive-keyring.gpg https://packages.cloud.google.com/apt/doc/apt-key.gpg
</code></pre></div></li>
</ol>
<ol start=3>
<li>
<p>添加 Kubernetes <code>apt</code> 仓库：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#a2f>echo</span> <span style=color:#b44>&#34;deb [signed-by=/usr/share/keyrings/kubernetes-archive-keyring.gpg] https://apt.kubernetes.io/ kubernetes-xenial main&#34;</span> | sudo tee /etc/apt/sources.list.d/kubernetes.list
</code></pre></div></li>
</ol>
<ol start=4>
<li>
<p>更新 <code>apt</code> 包索引，使之包含新的仓库并安装 kubectl：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>sudo apt-get update
sudo apt-get install -y kubectl
</code></pre></div></li>
</ol>
</div>
<div id=kubectl-install-1 class=tab-pane role=tabpanel aria-labelledby=kubectl-install-1>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>cat <span style=color:#b44>&lt;&lt;EOF | sudo tee /etc/yum.repos.d/kubernetes.repo
</span><span style=color:#b44>[kubernetes]
</span><span style=color:#b44>name=Kubernetes
</span><span style=color:#b44>baseurl=https://packages.cloud.google.com/yum/repos/kubernetes-el7-x86_64
</span><span style=color:#b44>enabled=1
</span><span style=color:#b44>gpgcheck=1
</span><span style=color:#b44>repo_gpgcheck=1
</span><span style=color:#b44>gpgkey=https://packages.cloud.google.com/yum/doc/yum-key.gpg https://packages.cloud.google.com/yum/doc/rpm-package-key.gpg
</span><span style=color:#b44>EOF</span>
sudo yum install -y kubectl
</code></pre></div></div></div>
<h3 id=install-using-other-package-management>用其他包管理工具安装</h3>
<ul class="nav nav-tabs" id=other-kubectl-install role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#other-kubectl-install-0 role=tab aria-controls=other-kubectl-install-0 aria-selected=true>Snap</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#other-kubectl-install-1 role=tab aria-controls=other-kubectl-install-1>Homebrew</a></li></ul>
<div class=tab-content id=other-kubectl-install><div id=other-kubectl-install-0 class="tab-pane show active" role=tabpanel aria-labelledby=other-kubectl-install-0>
<p>
<p>如果你使用的 Ubuntu 或其他 Linux 发行版，内建支持
<a href=https://snapcraft.io/docs/core/install>snap</a> 包管理工具，
则可用 <a href=https://snapcraft.io/>snap</a> 命令安装 kubectl。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>snap install kubectl --classic
kubectl version --client
</code></pre></div></div>
<div id=other-kubectl-install-1 class=tab-pane role=tabpanel aria-labelledby=other-kubectl-install-1>
<p>
<p>如果你使用 Linux 系统，并且装了 <a href=https://docs.brew.sh/Homebrew-on-Linux>Homebrew</a>
包管理工具，
则可以使用这种方式<a href=https://docs.brew.sh/Homebrew-on-Linux#install>安装</a> kubectl。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>brew install kubectl
kubectl version --client
</code></pre></div></div></div>
<h2 id=verify-kubectl-configration>验证 kubectl 配置</h2>
<p>为了让 kubectl 能发现并访问 Kubernetes 集群，你需要一个
<a href=/docs/zh/concepts/configuration/organize-cluster-access-kubeconfig/>kubeconfig 文件</a>，
该文件在
<a href=https://github.com/kubernetes/kubernetes/blob/master/cluster/kube-up.sh>kube-up.sh</a>
创建集群时，或成功部署一个 Miniube 集群时，均会自动生成。
通常，kubectl 的配置信息存放于文件 <code>~/.kube/config</code> 中。</p>
<p>通过获取集群状态的方法，检查是否已恰当的配置了 kubectl：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl cluster-info
</code></pre></div>
<p>如果返回一个 URL，则意味着 kubectl 成功的访问到了你的集群。</p>
<p>如果你看到如下所示的消息，则代表 kubectl 配置出了问题，或无法连接到 Kubernetes 集群。</p>
<pre><code>The connection to the server &lt;server-name:port&gt; was refused - did you specify the right host or port?
（访问 &lt;server-name:port&gt; 被拒绝 - 你指定的主机和端口是否有误？）
</code></pre>
<p>例如，如果你想在自己的笔记本上（本地）运行 Kubernetes 集群，你需要先安装一个 Minikube 这样的工具，然后再重新运行上面的命令。</p>
<p>如果命令 <code>kubectl cluster-info</code> 返回了 url，但你还不能访问集群，那可以用以下命令来检查配置是否妥当：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl cluster-info dump
</code></pre></div>
<h2 id=optional-kubectl-configurations>kubectl 的可选配置和插件</h2>
<h3 id=enable-shell-autocompletion>启用 shell 自动补全功能</h3>
<p>kubectl 为 Bash、Zsh、Fish 和 PowerShell 提供自动补全功能，可以为你节省大量的输入。</p>
<p>下面是为 Bash、Fish 和 Zsh 设置自动补全功能的操作步骤。</p>
<ul class="nav nav-tabs" id=kubectl-autocompletion role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#kubectl-autocompletion-0 role=tab aria-controls=kubectl-autocompletion-0 aria-selected=true>Bash</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#kubectl-autocompletion-1 role=tab aria-controls=kubectl-autocompletion-1>Fish</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#kubectl-autocompletion-2 role=tab aria-controls=kubectl-autocompletion-2>Zsh</a></li></ul>
<div class=tab-content id=kubectl-autocompletion><div id=kubectl-autocompletion-0 class="tab-pane show active" role=tabpanel aria-labelledby=kubectl-autocompletion-0>
<p>
<h3 id=introduction>简介</h3>
<p>kubectl 的 Bash 补全脚本可以用命令 <code>kubectl completion bash</code> 生成。
在 shell 中导入（Sourcing）补全脚本，将启用 kubectl 自动补全功能。</p>
<p>然而，补全脚本依赖于工具 <a href=https://github.com/scop/bash-completion><strong>bash-completion</strong></a>，
所以要先安装它（可以用命令 <code>type _init_completion</code> 检查 bash-completion 是否已安装）。</p>
<h3 id=install-bash-comletion>安装 bash-completion</h3>
<p>很多包管理工具均支持 bash-completion（参见<a href=https://github.com/scop/bash-completion#installation>这里</a>）。
可以通过 <code>apt-get install bash-completion</code> 或 <code>yum install bash-completion</code> 等命令来安装它。</p>
<p>上述命令将创建文件 <code>/usr/share/bash-completion/bash_completion</code>，它是 bash-completion 的主脚本。
依据包管理工具的实际情况，你需要在 <code>~/.bashrc</code> 文件中手工导入此文件。</p>
<p>要查看结果，请重新加载你的 shell，并运行命令 <code>type _init_completion</code>。
如果命令执行成功，则设置完成，否则将下面内容添加到文件 <code>~/.bashrc</code> 中：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#a2f>source</span> /usr/share/bash-completion/bash_completion
</code></pre></div>
<p>重新加载 shell，再输入命令 <code>type _init_completion</code> 来验证 bash-completion 的安装状态。</p>
<h3 id=enable-kubectl-autocompletion>启动 kubectl 自动补全功能</h3>
<h4 id=bash>Bash</h4>
<p>你现在需要确保一点：kubectl 补全脚本已经导入（sourced）到 shell 会话中。
可以通过以下两种方法进行设置：</p>
<ul class="nav nav-tabs" id=kubectl-bash-autocompletion role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#kubectl-bash-autocompletion-0 role=tab aria-controls=kubectl-bash-autocompletion-0 aria-selected=true>当前用户</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#kubectl-bash-autocompletion-1 role=tab aria-controls=kubectl-bash-autocompletion-1>系统全局</a></li></ul>
<div class=tab-content id=kubectl-bash-autocompletion><div id=kubectl-bash-autocompletion-0 class="tab-pane show active" role=tabpanel aria-labelledby=kubectl-bash-autocompletion-0>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>
<span style=color:#a2f>echo</span> <span style=color:#b44>&#39;source &lt;(kubectl completion bash)&#39;</span> &gt;&gt;~/.bashrc
</code></pre></div></div>
<div id=kubectl-bash-autocompletion-1 class=tab-pane role=tabpanel aria-labelledby=kubectl-bash-autocompletion-1>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>
kubectl completion bash | sudo tee /etc/bash_completion.d/kubectl &gt; /dev/null
</code></pre></div></div></div>
<p>如果 kubectl 有关联的别名，你可以扩展 shell 补全来适配此别名：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#a2f>echo</span> <span style=color:#b44>&#39;alias k=kubectl&#39;</span> &gt;&gt;~/.bashrc
<span style=color:#a2f>echo</span> <span style=color:#b44>&#39;complete -F __start_kubectl k&#39;</span> &gt;&gt;~/.bashrc
</code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>Note:</strong>
<p>bash-completion 负责导入 <code>/etc/bash_completion.d</code> 目录中的所有补全脚本。
</div>
<p>两种方式的效果相同。重新加载 shell 后，kubectl 自动补全功能即可生效。</p>
</div>
<div id=kubectl-autocompletion-1 class=tab-pane role=tabpanel aria-labelledby=kubectl-autocompletion-1>
<p>
<p>kubectl 通过命令 <code>kubectl completion fish</code> 生成 Fish 自动补全脚本。
在 shell 中导入（Sourcing）该自动补全脚本，将启动 kubectl 自动补全功能。</p>
<p>为了在所有的 shell 会话中实现此功能，请将下面内容加入到文件 <code>~/.config/fish/config.fish</code> 中。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl completion fish | <span style=color:#a2f>source</span>
</code></pre></div>
<p>重新加载 shell 后，kubectl 自动补全功能将立即生效。</p>
</div>
<div id=kubectl-autocompletion-2 class=tab-pane role=tabpanel aria-labelledby=kubectl-autocompletion-2>
<p>
<p>kubectl 通过命令 <code>kubectl completion zsh</code> 生成 Zsh 自动补全脚本。
在 shell 中导入（Sourcing）该自动补全脚本，将启动 kubectl 自动补全功能。</p>
<p>为了在所有的 shell 会话中实现此功能，请将下面内容加入到文件 <code>~/.zshrc</code> 中。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-zsh data-lang=zsh><span style=color:#a2f>source</span> &lt;<span style=color:#666>(</span>kubectl completion zsh<span style=color:#666>)</span>
</code></pre></div>
<p>如果你为 kubectl 定义了别名，kubectl 自动补全将自动使用它。</p>
<p>重新加载 shell 后，kubectl 自动补全功能将立即生效。</p>
<p>如果你收到 <code>2: command not found: compdef</code> 这样的错误提示，那请将下面内容添加到 <code>~/.zshrc</code> 文件的开头：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-zsh data-lang=zsh>autoload -Uz compinit
compinit
</code></pre></div></div></div>
<h3 id=安装-kubectl-convert-插件>安装 <code>kubectl convert</code> 插件</h3>
<p>一个 Kubernetes 命令行工具 <code>kubectl</code> 的插件，允许你将清单在不同 API 版本间转换。
这对于将清单迁移到新的 Kubernetes 发行版上未被废弃的 API 版本时尤其有帮助。
更多信息请访问 <a href=/zh/docs/reference/using-api/deprecation-guide/#migrate-to-non-deprecated-apis>迁移到非弃用 API</a></p>
<ol>
<li>
<p>用以下命令下载最新发行版：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>curl -LO <span style=color:#b44>&#34;https://dl.k8s.io/release/</span><span style=color:#a2f;font-weight:700>$(</span>curl -L -s https://dl.k8s.io/release/stable.txt<span style=color:#a2f;font-weight:700>)</span><span style=color:#b44>/bin/linux/amd64/kubectl-convert&#34;</span>
</code></pre></div></li>
</ol>
<ol start=2>
<li>
<p>验证该可执行文件（可选步骤）</p>
<p>下载 kubectl-convert 校验和文件：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>curl -LO <span style=color:#b44>&#34;https://dl.k8s.io/</span><span style=color:#a2f;font-weight:700>$(</span>curl -L -s https://dl.k8s.io/release/stable.txt<span style=color:#a2f;font-weight:700>)</span><span style=color:#b44>/bin/linux/amd64/kubectl-convert.sha256&#34;</span>
</code></pre></div>
<p>基于校验和，验证 kubectl-convert 的可执行文件：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#a2f>echo</span> <span style=color:#b44>&#34;</span><span style=color:#a2f;font-weight:700>$(</span>cat kubectl-convert.sha256<span style=color:#a2f;font-weight:700>)</span><span style=color:#b44> kubectl-convert&#34;</span> | sha256sum --check
</code></pre></div>
<p>验证通过时，输出为：</p>
<pre><code class=language-console data-lang=console>kubectl-convert: OK
</code></pre>
<p>验证失败时，<code>sha256</code> 将以非零值退出，并打印输出类似于：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl-convert: FAILED
sha256sum: WARNING: <span style=color:#666>1</span> computed checksum did NOT match
</code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>Note:</strong>
<p>下载相同版本的可执行文件和校验和。
</div>
</li>
</ol>
<ol start=3>
<li>
<p>安装 kubectl-convert</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>sudo install -o root -g root -m <span style=color:#666>0755</span> kubectl-convert /usr/local/bin/kubectl-convert
</code></pre></div></li>
</ol>
<ol start=4>
<li>
<p>验证插件是否安装成功</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl convert --help
</code></pre></div>
<p>如果你没有看到任何错误就代表插件安装成功了。</p>
</li>
</ol>
<h2 id=what-s-next>What's next</h2>
<ul>
<li><a href=https://minikube.sigs.k8s.io/docs/start/>安装 Minikube</a></li>
<li>有关创建集群的更多信息，请参阅<a href=/zh/docs/setup/>入门指南</a>.</li>
<li><a href=/zh/docs/tasks/access-application-cluster/service-access-application-cluster/>学习如何启动并对外公开你的应用程序。</a></li>
<li>如果你需要访问其他人创建的集群，请参阅
<a href=/zh/docs/tasks/access-application-cluster/configure-access-multiple-clusters/>共享集群接入文档</a>.</li>
<li>阅读 <a href=/zh/docs/reference/kubectl/kubectl/>kubectl 参考文档</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-961fc70b732cb8df4fd11a3463b6545c>1.2 - 在 macOS 系统上安装和设置 kubectl</h1>
<h2 id=before-you-begin>Before you begin</h2>
<p>kubectl 版本和集群之间的差异必须在一个小版本号之内。
例如：v1.23 版本的客户端能与 v1.22、
v1.23 和 v1.24 版本的控制面通信。
用最新兼容版本的 kubectl 有助于避免不可预见的问题。</p>
<h2 id=install-kubectl-on-macos>在 macOS 系统上安装 kubectl</h2>
<p>在 macOS 系统上安装 kubectl 有如下方法：</p>
<ul>
<li><a href=#install-kubectl-binary-with-curl-on-macos>用 curl 在 macOS 系统上安装 kubectl</a></li>
<li><a href=#install-with-homebrew-on-macos>用 Homebrew 在 macOS 系统上安装</a></li>
<li><a href=#install-with-macports-on-macos>用 Macports 在 macOS 上安装</a></li>
<li><a href=#install-on-macos-as-part-of-the-google-cloud-sdk>作为谷歌云 SDK 的一部分，在 macOS 上安装</a></li>
</ul>
<h3 id=install-kubectl-binary-with-curl-on-macos>用 curl 在 macOS 系统上安装 kubectl</h3>
<ol>
<li>
<p>下载最新的发行版：</p>
<ul class="nav nav-tabs" id=download-binary-macos role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#download-binary-macos-0 role=tab aria-controls=download-binary-macos-0 aria-selected=true>Intel</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#download-binary-macos-1 role=tab aria-controls=download-binary-macos-1>Apple Silicon</a></li></ul>
<div class=tab-content id=download-binary-macos><div id=download-binary-macos-0 class="tab-pane show active" role=tabpanel aria-labelledby=download-binary-macos-0>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>
   curl -LO <span style=color:#b44>&#34;https://dl.k8s.io/release/</span><span style=color:#a2f;font-weight:700>$(</span>curl -L -s https://dl.k8s.io/release/stable.txt<span style=color:#a2f;font-weight:700>)</span><span style=color:#b44>/bin/darwin/amd64/kubectl&#34;</span>
   </code></pre></div></div>
<div id=download-binary-macos-1 class=tab-pane role=tabpanel aria-labelledby=download-binary-macos-1>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>
   curl -LO <span style=color:#b44>&#34;https://dl.k8s.io/release/</span><span style=color:#a2f;font-weight:700>$(</span>curl -L -s https://dl.k8s.io/release/stable.txt<span style=color:#a2f;font-weight:700>)</span><span style=color:#b44>/bin/darwin/arm64/kubectl&#34;</span>
   </code></pre></div></div></div>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong>
<p>如果需要下载某个指定的版本，用该指定版本号替换掉命令的这个部分：<code>$(curl -L -s https://dl.k8s.io/release/stable.txt)</code>。
例如：要为 Intel macOS 系统下载 v1.23.17 版本，则输入：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>curl -LO <span style=color:#b44>&#34;https://dl.k8s.io/release/v1.23.17/bin/darwin/amd64/kubectl&#34;</span>
</code></pre></div>
<p>对于 Apple Silicon 版本的 macOS，输入：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>curl -LO <span style=color:#b44>&#34;https://dl.k8s.io/release/v1.23.17/bin/darwin/arm64/kubectl&#34;</span>
</code></pre></div>
</div>
</li>
</ol>
<ol start=2>
<li>
<p>验证可执行文件（可选操作）</p>
<p>下载 kubectl 的校验和文件：</p>
<ul class="nav nav-tabs" id=download-checksum-macos role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#download-checksum-macos-0 role=tab aria-controls=download-checksum-macos-0 aria-selected=true>Intel</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#download-checksum-macos-1 role=tab aria-controls=download-checksum-macos-1>Apple Silicon</a></li></ul>
<div class=tab-content id=download-checksum-macos><div id=download-checksum-macos-0 class="tab-pane show active" role=tabpanel aria-labelledby=download-checksum-macos-0>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>
   curl -LO <span style=color:#b44>&#34;https://dl.k8s.io/release/</span><span style=color:#a2f;font-weight:700>$(</span>curl -L -s https://dl.k8s.io/release/stable.txt<span style=color:#a2f;font-weight:700>)</span><span style=color:#b44>/bin/darwin/amd64/kubectl.sha256&#34;</span>
   </code></pre></div></div>
<div id=download-checksum-macos-1 class=tab-pane role=tabpanel aria-labelledby=download-checksum-macos-1>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>
   curl -LO <span style=color:#b44>&#34;https://dl.k8s.io/release/</span><span style=color:#a2f;font-weight:700>$(</span>curl -L -s https://dl.k8s.io/release/stable.txt<span style=color:#a2f;font-weight:700>)</span><span style=color:#b44>/bin/darwin/arm64/kubectl.sha256&#34;</span>
   </code></pre></div></div></div>
<p>根据校验和文件，验证 kubectl：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#a2f>echo</span> <span style=color:#b44>&#34;</span><span style=color:#a2f;font-weight:700>$(</span>cat kubectl.sha256<span style=color:#a2f;font-weight:700>)</span><span style=color:#b44>  kubectl&#34;</span> | shasum -a <span style=color:#666>256</span> --check
</code></pre></div>
<p>验证通过时，输出如下：</p>
<pre><code class=language-console data-lang=console>kubectl: OK
</code></pre>
<p>验证失败时，<code>shasum</code> 将以非零值退出，并打印如下输出：</p>
<pre><code>kubectl: FAILED
shasum: WARNING: 1 computed checksum did NOT match
</code></pre><div class="alert alert-info note callout" role=alert>
<strong>Note:</strong>
<p>下载的 kubectl 与校验和文件版本要相同。
</div>
</li>
</ol>
<ol start=3>
<li>
<p>将 kubectl 置为可执行文件：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>chmod +x ./kubectl
</code></pre></div></li>
</ol>
<ol start=4>
<li>
<p>将可执行文件 kubectl 移动到系统可寻址路径 <code>PATH</code> 内的一个位置：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>sudo mv ./kubectl /usr/local/bin/kubectl
sudo chown root: /usr/local/bin/kubectl
</code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>Note:</strong>
<p>确保 <code>/usr/local/bin</code> 在你的 PATH 环境变量中。
</div>
</li>
</ol>
<ol start=5>
<li>
<p>测试一下，确保你安装的是最新的版本：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl version --client
</code></pre></div><p>或者使用下面命令来查看版本的详细信息：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cmd data-lang=cmd>kubectl version --client --output=yaml
</code></pre></div></li>
</ol>
<h3 id=install-with-homebrew-on-macos>用 Homebrew 在 macOS 系统上安装</h3>
<p>如果你是 macOS 系统，且用的是 <a href=https://brew.sh/>Homebrew</a> 包管理工具，
则可以用 Homebrew 安装 kubectl。</p>
<ol>
<li>
<p>运行安装命令：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>brew install kubectl 
</code></pre></div><p>或</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>brew install kubernetes-cli
</code></pre></div></li>
</ol>
<ol start=2>
<li>
<p>测试一下，确保你安装的是最新的版本：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl version --client
</code></pre></div></li>
</ol>
<h3 id=install-with-macports-on-macos>用 Macports 在 macOS 上安装</h3>
<p>如果你用的是 macOS，且用 <a href=https://macports.org/>Macports</a> 包管理工具，则你可以用 Macports 安装kubectl。</p>
<ol>
<li>
<p>运行安装命令：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>sudo port selfupdate
sudo port install kubectl
</code></pre></div></li>
</ol>
<ol start=2>
<li>
<p>测试一下，确保你安装的是最新的版本：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl version --client
</code></pre></div></li>
</ol>
<h2 id=verify-kubectl-configuration>验证 kubectl 配置</h2>
<p>为了让 kubectl 能发现并访问 Kubernetes 集群，你需要一个
<a href=/docs/zh/concepts/configuration/organize-cluster-access-kubeconfig/>kubeconfig 文件</a>，
该文件在
<a href=https://github.com/kubernetes/kubernetes/blob/master/cluster/kube-up.sh>kube-up.sh</a>
创建集群时，或成功部署一个 Miniube 集群时，均会自动生成。
通常，kubectl 的配置信息存放于文件 <code>~/.kube/config</code> 中。</p>
<p>通过获取集群状态的方法，检查是否已恰当的配置了 kubectl：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl cluster-info
</code></pre></div>
<p>如果返回一个 URL，则意味着 kubectl 成功的访问到了你的集群。</p>
<p>如果你看到如下所示的消息，则代表 kubectl 配置出了问题，或无法连接到 Kubernetes 集群。</p>
<pre><code>The connection to the server &lt;server-name:port&gt; was refused - did you specify the right host or port?
（访问 &lt;server-name:port&gt; 被拒绝 - 你指定的主机和端口是否有误？）
</code></pre>
<p>例如，如果你想在自己的笔记本上（本地）运行 Kubernetes 集群，你需要先安装一个 Minikube 这样的工具，然后再重新运行上面的命令。</p>
<p>如果命令 <code>kubectl cluster-info</code> 返回了 url，但你还不能访问集群，那可以用以下命令来检查配置是否妥当：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl cluster-info dump
</code></pre></div>
<h2 id=optional-kubectl-configurations-and-plugins>可选的 kubectl 配置和插件</h2>
<h3 id=enable-shell-autocompletion>启用 shell 自动补全功能</h3>
<p>kubectl 为 Bash、Zsh、Fish 和 PowerShell 提供自动补全功能，可以为你节省大量的输入。</p>
<p>下面是为 Bash、Fish 和 Zsh 设置自动补全功能的操作步骤。</p>
<ul class="nav nav-tabs" id=kubectl-autocompletion role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#kubectl-autocompletion-0 role=tab aria-controls=kubectl-autocompletion-0 aria-selected=true>Bash</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#kubectl-autocompletion-1 role=tab aria-controls=kubectl-autocompletion-1>Fish</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#kubectl-autocompletion-2 role=tab aria-controls=kubectl-autocompletion-2>Zsh</a></li></ul>
<div class=tab-content id=kubectl-autocompletion><div id=kubectl-autocompletion-0 class="tab-pane show active" role=tabpanel aria-labelledby=kubectl-autocompletion-0>
<p>
<h3 id=简介>简介</h3>
<p>kubectl 的 Bash 补全脚本可以通过 <code>kubectl completion bash</code> 命令生成。
在你的 shell 中导入（Sourcing）这个脚本即可启用补全功能。</p>
<p>此外，kubectl 补全脚本依赖于工具 <a href=https://github.com/scop/bash-completion><strong>bash-completion</strong></a>，
所以你必须先安装它。</p>
<div class="alert alert-danger warning callout" role=alert>
<strong>Warning:</strong>
<p>bash-completion 有两个版本：v1 和 v2。v1 对应 Bash3.2（也是 macOS 的默认安装版本），v2 对应 Bash 4.1+。
kubectl 的补全脚本<strong>无法适配</strong> bash-completion v1 和 Bash 3.2。
必须为它配备 <strong>bash-completion v2</strong> 和 <strong>Bash 4.1+</strong>。
有鉴于此，为了在 macOS 上使用 kubectl 补全功能，你必须要安装和使用 Bash 4.1+
(<a href=https://itnext.io/upgrading-bash-on-macos-7138bd1066ba><em>说明</em></a>)。
后续说明假定你用的是 Bash 4.1+（也就是 Bash 4.1 或更新的版本）
</div>
<h3 id=升级-bash>升级 Bash</h3>
<p>后续说明假定你已使用 Bash 4.1+。你可以运行以下命令检查 Bash 版本：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#a2f>echo</span> <span style=color:#b8860b>$BASH_VERSION</span>
</code></pre></div>
<p>如果版本太旧，可以用 Homebrew 安装/升级：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>brew install bash
</code></pre></div>
<p>重新加载 shell，并验证所需的版本已经生效：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#a2f>echo</span> <span style=color:#b8860b>$BASH_VERSION</span> <span style=color:#b8860b>$SHELL</span>
</code></pre></div>
<p>Homebrew 通常把它安装为 <code>/usr/local/bin/bash</code>。</p>
<h3 id=安装-bash-completion>安装 bash-completion</h3>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong>
<p>如前所述，本说明假定你使用的 Bash 版本为 4.1+，这意味着你要安装 bash-completion v2
（不同于 Bash 3.2 和 bash-completion v1，kubectl 的补全功能在该场景下无法工作）。
</div>
<p>你可以用命令 <code>type _init_completion</code> 测试 bash-completion v2 是否已经安装。
如未安装，用 Homebrew 来安装它：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>brew install bash-completion@2
</code></pre></div>
<p>如命令的输出信息所显示的，将如下内容添加到文件 <code>~/.bash_profile</code> 中：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#a2f>export</span> <span style=color:#b8860b>BASH_COMPLETION_COMPAT_DIR</span><span style=color:#666>=</span><span style=color:#b44>&#34;/usr/local/etc/bash_completion.d&#34;</span>
<span style=color:#666>[[</span> -r <span style=color:#b44>&#34;/usr/local/etc/profile.d/bash_completion.sh&#34;</span> <span style=color:#666>]]</span> <span style=color:#666>&amp;&amp;</span> . <span style=color:#b44>&#34;/usr/local/etc/profile.d/bash_completion.sh&#34;</span>
</code></pre></div>
<p>重新加载 shell，并用命令 <code>type _init_completion</code> 验证 bash-completion v2 已经恰当的安装。</p>
<h3 id=启用-kubectl-自动补全功能>启用 kubectl 自动补全功能</h3>
<p>你现在需要确保在所有的 shell 环境中均已导入（sourced） kubectl 的补全脚本，
有若干种方法可以实现这一点：</p>
<ul>
<li>
<p>在文件 <code>~/.bash_profile</code> 中导入（Source）补全脚本：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#a2f>echo</span> <span style=color:#b44>&#39;source &lt;(kubectl completion bash)&#39;</span> &gt;&gt;~/.bash_profile
</code></pre></div></li>
</ul>
<ul>
<li>
<p>将补全脚本添加到目录 <code>/usr/local/etc/bash_completion.d</code> 中：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl completion bash &gt;/usr/local/etc/bash_completion.d/kubectl
</code></pre></div></li>
</ul>
<ul>
<li>
<p>如果你为 kubectl 定义了别名，则可以扩展 shell 补全来兼容该别名：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#a2f>echo</span> <span style=color:#b44>&#39;alias k=kubectl&#39;</span> &gt;&gt;~/.bash_profile
<span style=color:#a2f>echo</span> <span style=color:#b44>&#39;complete -F __start_kubectl k&#39;</span> &gt;&gt;~/.bash_profile
</code></pre></div></li>
</ul>
<ul>
<li>
<p>如果你是用 Homebrew 安装的 kubectl（如
<a href=/zh/docs/tasks/install-with-homebrew-on-macos/#install-with-homebrew-on-macos>此页面</a>
所描述），则kubectl 补全脚本应该已经安装到目录 <code>/usr/local/etc/bash_completion.d/kubectl</code>
中了。这种情况下，你什么都不需要做。</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong>
<p>用 Hommbrew 安装的 bash-completion v2 会初始化 目录 <code>BASH_COMPLETION_COMPAT_DIR</code>
中的所有文件，这就是后两种方法能正常工作的原因。
</div>
</li>
</ul>
<p>总之，重新加载 shell 之后，kubectl 补全功能将立即生效。</p>
</div>
<div id=kubectl-autocompletion-1 class=tab-pane role=tabpanel aria-labelledby=kubectl-autocompletion-1>
<p>
<p>kubectl 通过命令 <code>kubectl completion fish</code> 生成 Fish 自动补全脚本。
在 shell 中导入（Sourcing）该自动补全脚本，将启动 kubectl 自动补全功能。</p>
<p>为了在所有的 shell 会话中实现此功能，请将下面内容加入到文件 <code>~/.config/fish/config.fish</code> 中。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl completion fish | <span style=color:#a2f>source</span>
</code></pre></div>
<p>重新加载 shell 后，kubectl 自动补全功能将立即生效。</p>
</div>
<div id=kubectl-autocompletion-2 class=tab-pane role=tabpanel aria-labelledby=kubectl-autocompletion-2>
<p>
<p>kubectl 通过命令 <code>kubectl completion zsh</code> 生成 Zsh 自动补全脚本。
在 shell 中导入（Sourcing）该自动补全脚本，将启动 kubectl 自动补全功能。</p>
<p>为了在所有的 shell 会话中实现此功能，请将下面内容加入到文件 <code>~/.zshrc</code> 中。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-zsh data-lang=zsh><span style=color:#a2f>source</span> &lt;<span style=color:#666>(</span>kubectl completion zsh<span style=color:#666>)</span>
</code></pre></div>
<p>如果你为 kubectl 定义了别名，kubectl 自动补全将自动使用它。</p>
<p>重新加载 shell 后，kubectl 自动补全功能将立即生效。</p>
<p>如果你收到 <code>2: command not found: compdef</code> 这样的错误提示，那请将下面内容添加到 <code>~/.zshrc</code> 文件的开头：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-zsh data-lang=zsh>autoload -Uz compinit
compinit
</code></pre></div></div></div>
<h3 id=安装-kubectl-convert-插件>安装 <code>kubectl convert</code> 插件</h3>
<p>一个 Kubernetes 命令行工具 <code>kubectl</code> 的插件，允许你将清单在不同 API 版本间转换。
这对于将清单迁移到新的 Kubernetes 发行版上未被废弃的 API 版本时尤其有帮助。
更多信息请访问 <a href=/zh/docs/reference/using-api/deprecation-guide/#migrate-to-non-deprecated-apis>迁移到非弃用 API</a></p>
<ol>
<li>
<p>用以下命令下载最新发行版：</p>
<ul class="nav nav-tabs" id=download-convert-binary-macos role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#download-convert-binary-macos-0 role=tab aria-controls=download-convert-binary-macos-0 aria-selected=true>Intel</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#download-convert-binary-macos-1 role=tab aria-controls=download-convert-binary-macos-1>Apple Silicon</a></li></ul>
<div class=tab-content id=download-convert-binary-macos><div id=download-convert-binary-macos-0 class="tab-pane show active" role=tabpanel aria-labelledby=download-convert-binary-macos-0>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>
   curl -LO <span style=color:#b44>&#34;https://dl.k8s.io/release/</span><span style=color:#a2f;font-weight:700>$(</span>curl -L -s https://dl.k8s.io/release/stable.txt<span style=color:#a2f;font-weight:700>)</span><span style=color:#b44>/bin/darwin/amd64/kubectl-convert&#34;</span>
   </code></pre></div></div>
<div id=download-convert-binary-macos-1 class=tab-pane role=tabpanel aria-labelledby=download-convert-binary-macos-1>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>
   curl -LO <span style=color:#b44>&#34;https://dl.k8s.io/release/</span><span style=color:#a2f;font-weight:700>$(</span>curl -L -s https://dl.k8s.io/release/stable.txt<span style=color:#a2f;font-weight:700>)</span><span style=color:#b44>/bin/darwin/arm64/kubectl-convert&#34;</span>
   </code></pre></div></div></div>
</li>
</ol>
<ol>
<li>
<p>验证该可执行文件（可选步骤）</p>
<p>下载 kubectl-convert 校验和文件：</p>
<ul class="nav nav-tabs" id=download-convert-checksum-macos role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#download-convert-checksum-macos-0 role=tab aria-controls=download-convert-checksum-macos-0 aria-selected=true>Intel</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#download-convert-checksum-macos-1 role=tab aria-controls=download-convert-checksum-macos-1>Apple Silicon</a></li></ul>
<div class=tab-content id=download-convert-checksum-macos><div id=download-convert-checksum-macos-0 class="tab-pane show active" role=tabpanel aria-labelledby=download-convert-checksum-macos-0>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>
   curl -LO <span style=color:#b44>&#34;https://dl.k8s.io/release/</span><span style=color:#a2f;font-weight:700>$(</span>curl -L -s https://dl.k8s.io/release/stable.txt<span style=color:#a2f;font-weight:700>)</span><span style=color:#b44>/bin/darwin/amd64/kubectl-convert.sha256&#34;</span>
   </code></pre></div></div>
<div id=download-convert-checksum-macos-1 class=tab-pane role=tabpanel aria-labelledby=download-convert-checksum-macos-1>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>
   curl -LO <span style=color:#b44>&#34;https://dl.k8s.io/release/</span><span style=color:#a2f;font-weight:700>$(</span>curl -L -s https://dl.k8s.io/release/stable.txt<span style=color:#a2f;font-weight:700>)</span><span style=color:#b44>/bin/darwin/arm64/kubectl-convert.sha256&#34;</span>
   </code></pre></div></div></div>
<p>基于校验和，验证 kubectl-convert 的可执行文件：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#a2f>echo</span> <span style=color:#b44>&#34;</span><span style=color:#a2f;font-weight:700>$(</span>cat kubectl-convert.sha256<span style=color:#a2f;font-weight:700>)</span><span style=color:#b44>  kubectl-convert&#34;</span> | shasum -a <span style=color:#666>256</span> --check
</code></pre></div>
<p>验证通过时，输出为：</p>
<pre><code class=language-console data-lang=console>kubectl-convert: OK
</code></pre>
<p>验证失败时，<code>sha256</code> 将以非零值退出，并打印输出类似于：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl-convert: FAILED
shasum: WARNING: <span style=color:#666>1</span> computed checksum did NOT match
</code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>Note:</strong>
<p>下载相同版本的可执行文件和校验和。
</div>
</li>
</ol>
<ol>
<li>
<p>使 kubectl-convert 二进制文件可执行</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>chmod +x ./kubectl-convert
</code></pre></div></li>
</ol>
<ol>
<li>
<p>将 kubectl-convert 可执行文件移动到系统 <code>PATH</code> 环境变量中的一个位置。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>sudo mv ./kubectl-convert /usr/local/bin/kubectl-convert
sudo chown root: /usr/local/bin/kubectl-convert
</code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>Note:</strong>
<p>确保你的 PATH 环境变量中存在 <code>/usr/local/bin</code>
</div>
</li>
</ol>
<ol>
<li>
<p>验证插件是否安装成功</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl convert --help
</code></pre></div>
<p>如果你没有看到任何错误就代表插件安装成功了。</p>
</li>
</ol>
<h2 id=what-s-next>What's next</h2>
<ul>
<li><a href=https://minikube.sigs.k8s.io/docs/start/>安装 Minikube</a></li>
<li>有关创建集群的更多信息，请参阅<a href=/zh/docs/setup/>入门指南</a>.</li>
<li><a href=/zh/docs/tasks/access-application-cluster/service-access-application-cluster/>学习如何启动并对外公开你的应用程序。</a></li>
<li>如果你需要访问其他人创建的集群，请参阅
<a href=/zh/docs/tasks/access-application-cluster/configure-access-multiple-clusters/>共享集群接入文档</a>.</li>
<li>阅读 <a href=/zh/docs/reference/kubectl/kubectl/>kubectl 参考文档</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-2cc93d3011d707aeb6564bab02048f7a>1.3 - 在 Windows 上安装 kubectl</h1>
<h2 id=before-you-begin>Before you begin</h2>
<p>kubectl 版本和集群版本之间的差异必须在一个小版本号内。
例如：v1.23 版本的客户端能与 v1.22、
v1.23 和 v1.24 版本的控制面通信。
用最新兼容版的 kubectl 有助于避免不可预见的问题。</p>
<h2 id=install-kubectl-on-windows>在 Windows 上安装 kubectl</h2>
<p>在 Windows 系统中安装 kubectl 有如下几种方法：</p>
<ul>
<li><a href=#install-kubectl-binary-with-curl-on-windows>用 curl 在 Windows 上安装 kubectl</a></li>
<li><a href=#install-on-windows-using-chocolatey-or-scoop>在 Windows 上用 Chocolatey 或 Scoop 安装</a></li>
</ul>
<h3 id=install-kubectl-binary-with-curl-on-windows>用 curl 在 Windows 上安装 kubectl</h3>
<ol>
<li>
<p>下载 <a href=https://dl.k8s.io/release/v1.23.17/bin/windows/amd64/kubectl.exe>最新发行版 v1.23.17</a>。</p>
<p>如果你已安装了 <code>curl</code>,也可以使用此命令：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=color:#a2f>curl </span>-LO <span style=color:#b44>&#34;https://dl.k8s.io/release/v1.23.17/bin/windows/amd64/kubectl.exe&#34;</span>
</code></pre></div>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 要想找到最新稳定的版本（例如：为了编写脚本），可以看看这里 <a href=https://dl.k8s.io/release/stable.txt>https://dl.k8s.io/release/stable.txt</a>。
</div>
</li>
<li>
<p>验证该可执行文件（可选步骤）</p>
<p>下载 <code>kubectl</code> 校验和文件：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=color:#a2f>curl </span>-LO <span style=color:#b44>&#34;https://dl.k8s.io/v1.23.17/bin/windows/amd64/kubectl.exe.sha256&#34;</span>
</code></pre></div>
<p>基于校验和文件，验证 <code>kubectl</code> 的可执行文件：</p>
<ul>
<li>
<p>在命令行环境中，手工对比 <code>CertUtil</code> 命令的输出与校验和文件：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cmd data-lang=cmd>CertUtil -hashfile kubectl.exe SHA256
<span style=color:#a2f;font-weight:700>type</span> kubectl.exe.sha256
</code></pre></div></li>
</ul>
<ul>
<li>
<p>用 PowerShell 自动验证，用运算符 <code>-eq</code> 来直接取得 <code>True</code> 或 <code>False</code> 的结果：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell>$($(CertUtil -hashfile .\kubectl.exe SHA256)[1] <span style=color:#666>-replace</span> <span style=color:#b44>&#34; &#34;</span>, <span style=color:#b44>&#34;&#34;</span>) <span style=color:#666>-eq</span> $(<span style=color:#a2f>type </span>.\kubectl.exe.sha256)
</code></pre></div></li>
</ul>
</li>
<li>
<p>将 <code>kubectl</code> 二进制文件夹追加或插入到你的 <code>PATH</code> 环境变量中。</p>
</li>
<li>
<p>测试一下，确保此 <code>kubectl</code> 的版本和期望版本一致：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cmd data-lang=cmd>kubectl version --client
</code></pre></div><p>或者使用下面命令来查看版本的详细信息：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cmd data-lang=cmd>kubectl version --client --output=yaml
</code></pre></div></li>
</ol>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> <a href=https://docs.docker.com/docker-for-windows/#kubernetes>Windows 版的 Docker Desktop</a>
将其自带版本的 <code>kubectl</code> 添加到 <code>PATH</code>。
如果你之前安装过 Docker Desktop，可能需要把此 <code>PATH</code> 条目置于 Docker Desktop 安装的条目之前，
或者直接删掉 Docker Desktop 的 <code>kubectl</code>。
</div>
<h3 id=install-on-windows-using-chocolatey-or-scoop>在 Windows 上用 Chocolatey 或 Scoop 安装</h3>
<ol>
<li>
<p>要在 Windows 上安装 kubectl，你可以使用包管理器 <a href=https://chocolatey.org>Chocolatey</a>
或是命令行安装器 <a href=https://scoop.sh>Scoop</a>。</p>
<ul class="nav nav-tabs" id=kubectl-win-install role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#kubectl-win-install-0 role=tab aria-controls=kubectl-win-install-0 aria-selected=true>choco</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#kubectl-win-install-1 role=tab aria-controls=kubectl-win-install-1>scoop</a></li></ul>
<div class=tab-content id=kubectl-win-install><div id=kubectl-win-install-0 class="tab-pane show active" role=tabpanel aria-labelledby=kubectl-win-install-0>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell>choco install <span style=color:#a2f>kubernetes-cli</span>
</code></pre></div></div>
<div id=kubectl-win-install-1 class=tab-pane role=tabpanel aria-labelledby=kubectl-win-install-1>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell>scoop install kubectl
</code></pre></div></div></div>
</li>
<li>
<p>测试一下，确保安装的是最新版本：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell>kubectl version --client
</code></pre></div>
</li>
<li>
<p>导航到你的 home 目录：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=color:#080;font-style:italic># 当你用 cmd.exe 时，则运行： cd %USERPROFILE%</span>
<span style=color:#a2f>cd </span>~
</code></pre></div>
</li>
<li>
<p>创建目录 <code>.kube</code>：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell>mkdir .kube
</code></pre></div>
</li>
<li>
<p>切换到新创建的目录 <code>.kube</code></p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=color:#a2f>cd </span>.kube
</code></pre></div>
</li>
<li>
<p>配置 kubectl，以接入远程的 Kubernetes 集群：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=color:#a2f>New-Item</span> config -type file
</code></pre></div></li>
</ol>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 编辑配置文件，你需要先选择一个文本编辑器，比如 Notepad。
</div>
<h2 id=verify-kubectl-configration>验证 kubectl 配置</h2>
<p>为了让 kubectl 能发现并访问 Kubernetes 集群，你需要一个
<a href=/docs/zh/concepts/configuration/organize-cluster-access-kubeconfig/>kubeconfig 文件</a>，
该文件在
<a href=https://github.com/kubernetes/kubernetes/blob/master/cluster/kube-up.sh>kube-up.sh</a>
创建集群时，或成功部署一个 Miniube 集群时，均会自动生成。
通常，kubectl 的配置信息存放于文件 <code>~/.kube/config</code> 中。</p>
<p>通过获取集群状态的方法，检查是否已恰当的配置了 kubectl：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl cluster-info
</code></pre></div>
<p>如果返回一个 URL，则意味着 kubectl 成功的访问到了你的集群。</p>
<p>如果你看到如下所示的消息，则代表 kubectl 配置出了问题，或无法连接到 Kubernetes 集群。</p>
<pre><code>The connection to the server &lt;server-name:port&gt; was refused - did you specify the right host or port?
（访问 &lt;server-name:port&gt; 被拒绝 - 你指定的主机和端口是否有误？）
</code></pre>
<p>例如，如果你想在自己的笔记本上（本地）运行 Kubernetes 集群，你需要先安装一个 Minikube 这样的工具，然后再重新运行上面的命令。</p>
<p>如果命令 <code>kubectl cluster-info</code> 返回了 url，但你还不能访问集群，那可以用以下命令来检查配置是否妥当：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl cluster-info dump
</code></pre></div>
<h2 id=optional-kubectl-configurations>kubectl 可选配置和插件</h2>
<h3 id=enable-shell-autocompletion>启用 shell 自动补全功能</h3>
<p>kubectl 为 Bash、Zsh、Fish 和 PowerShell 提供自动补全功能，可以为你节省大量的输入。</p>
<p>下面是设置 PowerShell 自动补全功能的操作步骤。</p>
<p>使用命令 <code>kubectl completion powershell</code> 生成 PowerShell 的 kubectl 自动补全脚本。</p>
<p>如果需要自动补全在所有 shell 会话中生效，请将以下命令添加到 <code>$PROFILE</code> 文件中：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell>kubectl completion powershell | <span style=color:#a2f>Out-String</span> | <span style=color:#a2f>Invoke-Expression</span>
</code></pre></div>
<p>此命令将在每次 PowerShell 启动时重新生成自动补全脚本。你还可以将生成的自动补全脚本添加到 <code>$PROFILE</code> 文件中。</p>
<p>如果需要将自动补全脚本直接添加到 <code>$PROFILE</code> 文件中，请在 PowerShell 终端运行以下命令：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell>kubectl completion powershell &gt;&gt; <span style=color:#b8860b>$PROFILE</span>
</code></pre></div>
<p>完成上述操作后重启 shell，kubectl的自动补全就可以工作了。</p>
<h3 id=安装-kubectl-convert-插件>安装 <code>kubectl convert</code> 插件</h3>
<p>一个 Kubernetes 命令行工具 <code>kubectl</code> 的插件，允许你将清单在不同 API 版本间转换。
这对于将清单迁移到新的 Kubernetes 发行版上未被废弃的 API 版本时尤其有帮助。
更多信息请访问 <a href=/zh/docs/reference/using-api/deprecation-guide/#migrate-to-non-deprecated-apis>迁移到非弃用 API</a></p>
<ol>
<li>
<p>用以下命令下载最新发行版：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=color:#a2f>curl </span>-LO <span style=color:#b44>&#34;https://dl.k8s.io/release/v1.23.17/bin/windows/amd64/kubectl-convert.exe&#34;</span>
</code></pre></div></li>
</ol>
<ol>
<li>
<p>验证该可执行文件（可选步骤）</p>
<p>下载 <code>kubectl-convert</code> 校验和文件：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=color:#a2f>curl </span>-LO <span style=color:#b44>&#34;https://dl.k8s.io/v1.23.17/bin/windows/amd64/kubectl-convert.exe.sha256&#34;</span>
</code></pre></div>
<p>基于校验和，验证 <code>kubectl-convert</code> 的可执行文件：</p>
<ul>
<li>
<p>用提示的命令对 <code>CertUtil</code> 的输出和下载的校验和文件进行手动比较。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cmd data-lang=cmd>CertUtil -hashfile kubectl-convert.exe SHA256
<span style=color:#a2f;font-weight:700>type</span> kubectl-convert.exe.sha256
</code></pre></div></li>
</ul>
<ul>
<li>
<p>使用 PowerShell <code>-eq</code> 操作使验证自动化，获得 <code>True</code> 或者 <code>False</code> 的结果：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell>$($(CertUtil -hashfile .\<span style=color:#a2f>kubectl-convert</span>.exe SHA256)[1] <span style=color:#666>-replace</span> <span style=color:#b44>&#34; &#34;</span>, <span style=color:#b44>&#34;&#34;</span>) <span style=color:#666>-eq</span> $(<span style=color:#a2f>type </span>.\<span style=color:#a2f>kubectl-convert</span>.exe.sha256)
</code></pre></div></li>
</ul>
</li>
</ol>
<ol>
<li>
<p>将 <code>kubectl-convert</code> 二进制文件夹附加或添加到你的 <code>PATH</code> 环境变量中。</p>
</li>
<li>
<p>验证插件是否安装成功</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl convert --help
</code></pre></div>
<p>如果你没有看到任何错误就代表插件安装成功了。</p>
</li>
</ol>
<h2 id=what-s-next>What's next</h2>
<ul>
<li><a href=https://minikube.sigs.k8s.io/docs/start/>安装 Minikube</a></li>
<li>有关创建集群的更多信息，请参阅<a href=/zh/docs/setup/>入门指南</a>.</li>
<li><a href=/zh/docs/tasks/access-application-cluster/service-access-application-cluster/>学习如何启动并对外公开你的应用程序。</a></li>
<li>如果你需要访问其他人创建的集群，请参阅
<a href=/zh/docs/tasks/access-application-cluster/configure-access-multiple-clusters/>共享集群接入文档</a>.</li>
<li>阅读 <a href=/zh/docs/reference/kubectl/kubectl/>kubectl 参考文档</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-91639f08dfa86a6c88cf0099b2e097bc>1.4 - 内含的工具</h1>
<div class=lead>在页面 kubectl-installs-*.md 中包含的代码片段</div>
</div>
<div class=td-content>
<h1 id=pg-643b1104b7b31ae10b173acfb447843a>1.4.1 - fish 自动补全</h1>
<div class=lead>启用 fish 自动补全的可选配置。</div>
<p>kubectl 通过命令 <code>kubectl completion fish</code> 生成 Fish 自动补全脚本。
在 shell 中导入（Sourcing）该自动补全脚本，将启动 kubectl 自动补全功能。</p>
<p>为了在所有的 shell 会话中实现此功能，请将下面内容加入到文件 <code>~/.config/fish/config.fish</code> 中。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl completion fish | <span style=color:#a2f>source</span>
</code></pre></div>
<p>重新加载 shell 后，kubectl 自动补全功能将立即生效。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-d4ebbbe0a2ddce15850a36dfede9ba52>1.4.2 - kubectl-convert 概述</h1>
<div class=lead>一个 kubectl 插件，允许你将清单从一个 Kubernetes API 版本转换到不同的版本。</div>
<p>一个 Kubernetes 命令行工具 <code>kubectl</code> 的插件，允许你将清单在不同 API 版本间转换。
这对于将清单迁移到新的 Kubernetes 发行版上未被废弃的 API 版本时尤其有帮助。
更多信息请访问 <a href=/zh/docs/reference/using-api/deprecation-guide/#migrate-to-non-deprecated-apis>迁移到非弃用 API</a></p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-2d600cc8ec4dec69673b5f9577b6da22>1.4.3 - Linux 系统中的 bash 自动补全功能</h1>
<div class=lead>Linux 系统中 bash 自动补全功能的一些可选配置。</div>
<h3 id=introduction>简介</h3>
<p>kubectl 的 Bash 补全脚本可以用命令 <code>kubectl completion bash</code> 生成。
在 shell 中导入（Sourcing）补全脚本，将启用 kubectl 自动补全功能。</p>
<p>然而，补全脚本依赖于工具 <a href=https://github.com/scop/bash-completion><strong>bash-completion</strong></a>，
所以要先安装它（可以用命令 <code>type _init_completion</code> 检查 bash-completion 是否已安装）。</p>
<h3 id=install-bash-comletion>安装 bash-completion</h3>
<p>很多包管理工具均支持 bash-completion（参见<a href=https://github.com/scop/bash-completion#installation>这里</a>）。
可以通过 <code>apt-get install bash-completion</code> 或 <code>yum install bash-completion</code> 等命令来安装它。</p>
<p>上述命令将创建文件 <code>/usr/share/bash-completion/bash_completion</code>，它是 bash-completion 的主脚本。
依据包管理工具的实际情况，你需要在 <code>~/.bashrc</code> 文件中手工导入此文件。</p>
<p>要查看结果，请重新加载你的 shell，并运行命令 <code>type _init_completion</code>。
如果命令执行成功，则设置完成，否则将下面内容添加到文件 <code>~/.bashrc</code> 中：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#a2f>source</span> /usr/share/bash-completion/bash_completion
</code></pre></div>
<p>重新加载 shell，再输入命令 <code>type _init_completion</code> 来验证 bash-completion 的安装状态。</p>
<h3 id=enable-kubectl-autocompletion>启动 kubectl 自动补全功能</h3>
<h4 id=bash>Bash</h4>
<p>你现在需要确保一点：kubectl 补全脚本已经导入（sourced）到 shell 会话中。
可以通过以下两种方法进行设置：</p>
<ul class="nav nav-tabs" id=kubectl-bash-autocompletion role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#kubectl-bash-autocompletion-0 role=tab aria-controls=kubectl-bash-autocompletion-0 aria-selected=true>当前用户</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#kubectl-bash-autocompletion-1 role=tab aria-controls=kubectl-bash-autocompletion-1>系统全局</a></li></ul>
<div class=tab-content id=kubectl-bash-autocompletion><div id=kubectl-bash-autocompletion-0 class="tab-pane show active" role=tabpanel aria-labelledby=kubectl-bash-autocompletion-0>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>
<span style=color:#a2f>echo</span> <span style=color:#b44>&#39;source &lt;(kubectl completion bash)&#39;</span> &gt;&gt;~/.bashrc
</code></pre></div></div>
<div id=kubectl-bash-autocompletion-1 class=tab-pane role=tabpanel aria-labelledby=kubectl-bash-autocompletion-1>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>
kubectl completion bash | sudo tee /etc/bash_completion.d/kubectl &gt; /dev/null
</code></pre></div></div></div>
<p>如果 kubectl 有关联的别名，你可以扩展 shell 补全来适配此别名：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#a2f>echo</span> <span style=color:#b44>&#39;alias k=kubectl&#39;</span> &gt;&gt;~/.bashrc
<span style=color:#a2f>echo</span> <span style=color:#b44>&#39;complete -F __start_kubectl k&#39;</span> &gt;&gt;~/.bashrc
</code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>Note:</strong>
<p>bash-completion 负责导入 <code>/etc/bash_completion.d</code> 目录中的所有补全脚本。
</div>
<p>两种方式的效果相同。重新加载 shell 后，kubectl 自动补全功能即可生效。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-68808b3ec5807517ed64fd8ae32a7d1b>1.4.4 - macOS 系统上的 bash 自动补全</h1>
<div class=lead>在 macOS 上实现 Bash 自动补全的一些可选配置。</div>
<h3 id=简介>简介</h3>
<p>kubectl 的 Bash 补全脚本可以通过 <code>kubectl completion bash</code> 命令生成。
在你的 shell 中导入（Sourcing）这个脚本即可启用补全功能。</p>
<p>此外，kubectl 补全脚本依赖于工具 <a href=https://github.com/scop/bash-completion><strong>bash-completion</strong></a>，
所以你必须先安装它。</p>
<div class="alert alert-danger warning callout" role=alert>
<strong>Warning:</strong>
<p>bash-completion 有两个版本：v1 和 v2。v1 对应 Bash3.2（也是 macOS 的默认安装版本），v2 对应 Bash 4.1+。
kubectl 的补全脚本<strong>无法适配</strong> bash-completion v1 和 Bash 3.2。
必须为它配备 <strong>bash-completion v2</strong> 和 <strong>Bash 4.1+</strong>。
有鉴于此，为了在 macOS 上使用 kubectl 补全功能，你必须要安装和使用 Bash 4.1+
(<a href=https://itnext.io/upgrading-bash-on-macos-7138bd1066ba><em>说明</em></a>)。
后续说明假定你用的是 Bash 4.1+（也就是 Bash 4.1 或更新的版本）
</div>
<h3 id=升级-bash>升级 Bash</h3>
<p>后续说明假定你已使用 Bash 4.1+。你可以运行以下命令检查 Bash 版本：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#a2f>echo</span> <span style=color:#b8860b>$BASH_VERSION</span>
</code></pre></div>
<p>如果版本太旧，可以用 Homebrew 安装/升级：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>brew install bash
</code></pre></div>
<p>重新加载 shell，并验证所需的版本已经生效：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#a2f>echo</span> <span style=color:#b8860b>$BASH_VERSION</span> <span style=color:#b8860b>$SHELL</span>
</code></pre></div>
<p>Homebrew 通常把它安装为 <code>/usr/local/bin/bash</code>。</p>
<h3 id=安装-bash-completion>安装 bash-completion</h3>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong>
<p>如前所述，本说明假定你使用的 Bash 版本为 4.1+，这意味着你要安装 bash-completion v2
（不同于 Bash 3.2 和 bash-completion v1，kubectl 的补全功能在该场景下无法工作）。
</div>
<p>你可以用命令 <code>type _init_completion</code> 测试 bash-completion v2 是否已经安装。
如未安装，用 Homebrew 来安装它：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>brew install bash-completion@2
</code></pre></div>
<p>如命令的输出信息所显示的，将如下内容添加到文件 <code>~/.bash_profile</code> 中：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#a2f>export</span> <span style=color:#b8860b>BASH_COMPLETION_COMPAT_DIR</span><span style=color:#666>=</span><span style=color:#b44>&#34;/usr/local/etc/bash_completion.d&#34;</span>
<span style=color:#666>[[</span> -r <span style=color:#b44>&#34;/usr/local/etc/profile.d/bash_completion.sh&#34;</span> <span style=color:#666>]]</span> <span style=color:#666>&amp;&amp;</span> . <span style=color:#b44>&#34;/usr/local/etc/profile.d/bash_completion.sh&#34;</span>
</code></pre></div>
<p>重新加载 shell，并用命令 <code>type _init_completion</code> 验证 bash-completion v2 已经恰当的安装。</p>
<h3 id=启用-kubectl-自动补全功能>启用 kubectl 自动补全功能</h3>
<p>你现在需要确保在所有的 shell 环境中均已导入（sourced） kubectl 的补全脚本，
有若干种方法可以实现这一点：</p>
<ul>
<li>
<p>在文件 <code>~/.bash_profile</code> 中导入（Source）补全脚本：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#a2f>echo</span> <span style=color:#b44>&#39;source &lt;(kubectl completion bash)&#39;</span> &gt;&gt;~/.bash_profile
</code></pre></div></li>
</ul>
<ul>
<li>
<p>将补全脚本添加到目录 <code>/usr/local/etc/bash_completion.d</code> 中：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl completion bash &gt;/usr/local/etc/bash_completion.d/kubectl
</code></pre></div></li>
</ul>
<ul>
<li>
<p>如果你为 kubectl 定义了别名，则可以扩展 shell 补全来兼容该别名：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#a2f>echo</span> <span style=color:#b44>&#39;alias k=kubectl&#39;</span> &gt;&gt;~/.bash_profile
<span style=color:#a2f>echo</span> <span style=color:#b44>&#39;complete -F __start_kubectl k&#39;</span> &gt;&gt;~/.bash_profile
</code></pre></div></li>
</ul>
<ul>
<li>
<p>如果你是用 Homebrew 安装的 kubectl（如
<a href=/zh/docs/tasks/install-with-homebrew-on-macos/#install-with-homebrew-on-macos>此页面</a>
所描述），则kubectl 补全脚本应该已经安装到目录 <code>/usr/local/etc/bash_completion.d/kubectl</code>
中了。这种情况下，你什么都不需要做。</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong>
<p>用 Hommbrew 安装的 bash-completion v2 会初始化 目录 <code>BASH_COMPLETION_COMPAT_DIR</code>
中的所有文件，这就是后两种方法能正常工作的原因。
</div>
</li>
</ul>
<p>总之，重新加载 shell 之后，kubectl 补全功能将立即生效。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-730f5a835775a8e94bd1c481d3f1a349>1.4.5 - PowerShell 自动补全</h1>
<div class=lead>powershell 自动补全的一些可选配置。</div>
<p>使用命令 <code>kubectl completion powershell</code> 生成 PowerShell 的 kubectl 自动补全脚本。</p>
<p>如果需要自动补全在所有 shell 会话中生效，请将以下命令添加到 <code>$PROFILE</code> 文件中：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell>kubectl completion powershell | <span style=color:#a2f>Out-String</span> | <span style=color:#a2f>Invoke-Expression</span>
</code></pre></div>
<p>此命令将在每次 PowerShell 启动时重新生成自动补全脚本。你还可以将生成的自动补全脚本添加到 <code>$PROFILE</code> 文件中。</p>
<p>如果需要将自动补全脚本直接添加到 <code>$PROFILE</code> 文件中，请在 PowerShell 终端运行以下命令：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell>kubectl completion powershell &gt;&gt; <span style=color:#b8860b>$PROFILE</span>
</code></pre></div>
<p>完成上述操作后重启 shell，kubectl的自动补全就可以工作了。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-9ab27577326839cb4793fd670a916364>1.4.6 - zsh 自动补全</h1>
<div class=lead>zsh 自动补全的一些可选配置</div>
<p>kubectl 通过命令 <code>kubectl completion zsh</code> 生成 Zsh 自动补全脚本。
在 shell 中导入（Sourcing）该自动补全脚本，将启动 kubectl 自动补全功能。</p>
<p>为了在所有的 shell 会话中实现此功能，请将下面内容加入到文件 <code>~/.zshrc</code> 中。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-zsh data-lang=zsh><span style=color:#a2f>source</span> &lt;<span style=color:#666>(</span>kubectl completion zsh<span style=color:#666>)</span>
</code></pre></div>
<p>如果你为 kubectl 定义了别名，kubectl 自动补全将自动使用它。</p>
<p>重新加载 shell 后，kubectl 自动补全功能将立即生效。</p>
<p>如果你收到 <code>2: command not found: compdef</code> 这样的错误提示，那请将下面内容添加到 <code>~/.zshrc</code> 文件的开头：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-zsh data-lang=zsh>autoload -Uz compinit
compinit
</code></pre></div>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-99d563e9521796074ba3ca7f15a613ce>1.4.7 - 后续内容</h1>
<div class=lead>安装 kubectl 之后，还可以做些什么？</div>
<ul>
<li><a href=https://minikube.sigs.k8s.io/docs/start/>安装 Minikube</a></li>
<li>有关创建集群的更多信息，请参阅<a href=/zh/docs/setup/>入门指南</a>.</li>
<li><a href=/zh/docs/tasks/access-application-cluster/service-access-application-cluster/>学习如何启动并对外公开你的应用程序。</a></li>
<li>如果你需要访问其他人创建的集群，请参阅
<a href=/zh/docs/tasks/access-application-cluster/configure-access-multiple-clusters/>共享集群接入文档</a>.</li>
<li>阅读 <a href=/zh/docs/reference/kubectl/kubectl/>kubectl 参考文档</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-b2d43b2ae3e8f26eefa83de2db4ba782>1.4.8 - 验证 kubectl 的安装效果</h1>
<div class=lead>如何验证 kubectl。</div>
<p>为了让 kubectl 能发现并访问 Kubernetes 集群，你需要一个
<a href=/docs/zh/concepts/configuration/organize-cluster-access-kubeconfig/>kubeconfig 文件</a>，
该文件在
<a href=https://github.com/kubernetes/kubernetes/blob/master/cluster/kube-up.sh>kube-up.sh</a>
创建集群时，或成功部署一个 Miniube 集群时，均会自动生成。
通常，kubectl 的配置信息存放于文件 <code>~/.kube/config</code> 中。</p>
<p>通过获取集群状态的方法，检查是否已恰当的配置了 kubectl：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl cluster-info
</code></pre></div>
<p>如果返回一个 URL，则意味着 kubectl 成功的访问到了你的集群。</p>
<p>如果你看到如下所示的消息，则代表 kubectl 配置出了问题，或无法连接到 Kubernetes 集群。</p>
<pre><code>The connection to the server &lt;server-name:port&gt; was refused - did you specify the right host or port?
（访问 &lt;server-name:port&gt; 被拒绝 - 你指定的主机和端口是否有误？）
</code></pre>
<p>例如，如果你想在自己的笔记本上（本地）运行 Kubernetes 集群，你需要先安装一个 Minikube 这样的工具，然后再重新运行上面的命令。</p>
<p>如果命令 <code>kubectl cluster-info</code> 返回了 url，但你还不能访问集群，那可以用以下命令来检查配置是否妥当：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl cluster-info dump
</code></pre></div>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-5ff0cdcf7701f887e45d629f5cfe0424>2 - 资源指标管道</h1>
<p>对于 Kubernetes，<em>Metrics API</em> 提供了一组基本的指标，以支持自动伸缩和类似的用例。
该 API 提供有关节点和 Pod 的资源使用情况的信息，
包括 CPU 和内存的指标。如果将 Metrics API 部署到集群中，
那么 Kubernetes API 的客户端就可以查询这些信息，并且可以使用 Kubernetes 的访问控制机制来管理权限。</p>
<p><a href=/zh/docs/tasks/run-application/horizontal-pod-autoscale/>HorizontalPodAutoscaler</a> (HPA) 和
<a href=https://github.com/kubernetes/autoscaler/tree/master/vertical-pod-autoscaler#readme>VerticalPodAutoscaler</a> (VPA)
使用 metrics API 中的数据调整工作负载副本和资源，以满足客户需求。</p>
<p>你也可以通过 <a href=/zh/docs/reference/generated/kubectl/kubectl-commands#top><code>kubectl top</code></a> 命令来查看资源指标。</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong>
<p>Metrics API 及其启用的指标管道仅提供最少的 CPU 和内存指标，以启用使用 HPA 和/或 VPA 的自动扩展。
如果你想提供更完整的指标集，你可以通过部署使用 <em>Custom Metrics API</em> 的第二个
<a href=/zh/docs/tasks/debug-application-cluster/resource-usage-monitoring/#full-metrics-pipeline>指标管道</a> 来作为简单的 Metrics API 的补充。
</div>
<p>图 1 说明了资源指标管道的架构。</p>
<figure>
<div class=mermaid>
flowchart RL
subgraph cluster[Cluster]
direction RL
S[ <br><br> ]
A[Metrics-<br>Server]
subgraph B[Nodes]
direction TB
D[cAdvisor] --> C[kubelet]
E[Container<br>runtime] --> D
E1[Container<br>runtime] --> D
P[pod data] -.- C
end
L[API<br>server]
W[HPA]
C ---->|Summary<br>API| A -->|metrics<br>API| L --> W
end
L ---> K[kubectl<br>top]
classDef box fill:#fff,stroke:#000,stroke-width:1px,color:#000;
class W,B,P,K,cluster,D,E,E1 box
classDef spacewhite fill:#ffffff,stroke:#fff,stroke-width:0px,color:#000
class S spacewhite
classDef k8s fill:#326ce5,stroke:#fff,stroke-width:1px,color:#fff;
class A,L,C k8s
</div>
</figure>
<noscript>
<div class="alert alert-secondary callout" role=alert>
<em class=javascript-required>JavaScript must be <a href=https://www.enable-javascript.com/>enabled</a> to view this content</em>
</div>
</noscript>
<p>图 1. 资源指标管道</p>
<p>图中从右到左的架构组件包括以下内容：</p>
<ul>
<li>
<p><a href=https://github.com/google/cadvisor>cAdvisor</a>: 用于收集、聚合和公开 Kubelet 中包含的容器指标的守护程序。</p>
</li>
<li>
<p><a href=/zh/docs/concepts/overview/components/#kubelet>kubelet</a>: 用于管理容器资源的节点代理。
可以使用 <code>/metrics/resource</code> 和 <code>/stats</code> kubelet API 端点访问资源指标。</p>
</li>
<li>
<p><a href=#summary-api-source>Summary API</a>: kubelet 提供的 API，用于发现和检索可通过 <code>/stats</code> 端点获得的每个节点的汇总统计信息。</p>
</li>
<li>
<p><a href=#metrics-server>metrics-server</a>: 集群插件组件，用于收集和聚合从每个 kubelet 中提取的资源指标。
API 服务器提供 Metrics API 以供 HPA、VPA 和 <code>kubectl top</code> 命令使用。 Metrics Server 是 Metrics API 的参考实现。</p>
</li>
<li>
<p><a href=#metrics-api>Metrics API</a>: Kubernetes API 支持访问用于工作负载自动缩放的 CPU 和内存。
要在你的集群中进行这项工作，你需要一个提供 Metrics API 的 API 扩展服务器。</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> cAdvisor 支持从 cgroups 读取指标，它适用于 Linux 上的典型容器运行时。
如果你使用基于其他资源隔离机制的容器运行时，例如虚拟化，那么该容器运行时必须支持
<a href=https://github.com/kubernetes/community/blob/master/contributors/devel/sig-node/cri-container-stats.md>CRI 容器指标</a>
以便 kubelet 可以使用指标。
</div>
</li>
</ul>
<h2 id=the-metrics-api>Metrics API </h2>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes 1.8 [beta]</code>
</div>
<p>metrics-server 实现了 Metrics API。此 API 允许你访问集群中节点和 Pod 的 CPU 和内存使用情况。
它的主要作用是将资源使用指标提供给 K8s 自动缩放器组件。</p>
<p>下面是一个 <code>minikube</code> 节点的 Metrics API 请求示例，通过 <code>jq</code> 管道处理以便于阅读：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get --raw <span style=color:#b44>&#34;/apis/metrics.k8s.io/v1beta1/nodes/minikube&#34;</span> | jq <span style=color:#b44>&#39;.&#39;</span>
</code></pre></div>
<p>这是使用 <code>curl</code> 来执行的相同 API 调用：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>curl http://localhost:8080/apis/metrics.k8s.io/v1beta1/nodes/minikube
</code></pre></div>
<p>响应示例：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;NodeMetrics&#34;</span>,
  <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;metrics.k8s.io/v1beta1&#34;</span>,
  <span style=color:green;font-weight:700>&#34;metadata&#34;</span>: {
    <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;minikube&#34;</span>,
    <span style=color:green;font-weight:700>&#34;selfLink&#34;</span>: <span style=color:#b44>&#34;/apis/metrics.k8s.io/v1beta1/nodes/minikube&#34;</span>,
    <span style=color:green;font-weight:700>&#34;creationTimestamp&#34;</span>: <span style=color:#b44>&#34;2022-01-27T18:48:43Z&#34;</span>
  },
  <span style=color:green;font-weight:700>&#34;timestamp&#34;</span>: <span style=color:#b44>&#34;2022-01-27T18:48:33Z&#34;</span>,
  <span style=color:green;font-weight:700>&#34;window&#34;</span>: <span style=color:#b44>&#34;30s&#34;</span>,
  <span style=color:green;font-weight:700>&#34;usage&#34;</span>: {
    <span style=color:green;font-weight:700>&#34;cpu&#34;</span>: <span style=color:#b44>&#34;487558164n&#34;</span>,
    <span style=color:green;font-weight:700>&#34;memory&#34;</span>: <span style=color:#b44>&#34;732212Ki&#34;</span>
  }
}
</code></pre></div>
<p>下面是一个 <code>kube-system</code> 命名空间中的 <code>kube-scheduler-minikube</code> Pod 的 Metrics API 请求示例，
通过 <code>jq</code> 管道处理以便于阅读：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get --raw <span style=color:#b44>&#34;/apis/metrics.k8s.io/v1beta1/namespaces/kube-system/pods/kube-scheduler-minikube&#34;</span> | jq <span style=color:#b44>&#39;.&#39;</span>
</code></pre></div>
<p>这是使用 <code>curl</code> 来完成的相同 API 调用：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>curl http://localhost:8080/apis/metrics.k8s.io/v1beta1/namespaces/kube-system/pods/kube-scheduler-minikube
</code></pre></div>
<p>响应示例：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;PodMetrics&#34;</span>,
  <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;metrics.k8s.io/v1beta1&#34;</span>,
  <span style=color:green;font-weight:700>&#34;metadata&#34;</span>: {
    <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;kube-scheduler-minikube&#34;</span>,
    <span style=color:green;font-weight:700>&#34;namespace&#34;</span>: <span style=color:#b44>&#34;kube-system&#34;</span>,
    <span style=color:green;font-weight:700>&#34;selfLink&#34;</span>: <span style=color:#b44>&#34;/apis/metrics.k8s.io/v1beta1/namespaces/kube-system/pods/kube-scheduler-minikube&#34;</span>,
    <span style=color:green;font-weight:700>&#34;creationTimestamp&#34;</span>: <span style=color:#b44>&#34;2022-01-27T19:25:00Z&#34;</span>
  },
  <span style=color:green;font-weight:700>&#34;timestamp&#34;</span>: <span style=color:#b44>&#34;2022-01-27T19:24:31Z&#34;</span>,
  <span style=color:green;font-weight:700>&#34;window&#34;</span>: <span style=color:#b44>&#34;30s&#34;</span>,
  <span style=color:green;font-weight:700>&#34;containers&#34;</span>: [
    {
      <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;kube-scheduler&#34;</span>,
      <span style=color:green;font-weight:700>&#34;usage&#34;</span>: {
        <span style=color:green;font-weight:700>&#34;cpu&#34;</span>: <span style=color:#b44>&#34;9559630n&#34;</span>,
        <span style=color:green;font-weight:700>&#34;memory&#34;</span>: <span style=color:#b44>&#34;22244Ki&#34;</span>
      }
    }
  ]
}
</code></pre></div>
<p>Metrics API 在 <a href=https://github.com/kubernetes/metrics>k8s.io/metrics</a> 代码库中定义。
你必须启用 <a href=/zh/docs/tasks/extend-kubernetes/configure-aggregation-layer/>API 聚合层</a>并为
<code>metrics.k8s.io</code> API 注册一个 <a href=/zh/docs/reference/kubernetes-api/cluster-resources/api-service-v1/>APIService</a>。</p>
<p>要了解有关 Metrics API 的更多信息，
请参阅资源 <a href=https://github.com/kubernetes/design-proposals-archive/blob/main/instrumentation/resource-metrics-api.md>Resource Metrics API Design</a>、
<a href=https://github.com/kubernetes-sigs/metrics-server>metrics-server 代码库</a> 和
<a href=https://github.com/kubernetes/metrics#resource-metrics-api>Resource Metrics API</a>。</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 你必须部署提供 Metrics API 服务的 metrics-server 或其他适配器才能访问它。
</div>
<h2 id=measuring-resource-usage>度量资源用量 </h2>
<h3 id=cpu>CPU</h3>
<p>CPU 报告为以 cpu 为单位测量的平均核心使用率。在 Kubernetes 中，
一个 cpu 相当于云提供商的 1 个 vCPU/Core，以及裸机 Intel 处理器上的 1 个超线程。</p>
<p>该值是通过对内核提供的累积 CPU 计数器（在 Linux 和 Windows 内核中）取一个速率得出的。
用于计算 CPU 的时间窗口显示在 Metrics API 的窗口字段下。</p>
<p>要了解更多关于 Kubernetes 如何分配和测量 CPU 资源的信息，请参阅
<a href=/zh/docs/concepts/configuration/manage-resources-containers/#meaning-of-cpu>CPU 的含义</a>。</p>
<h3 id=memory>内存 </h3>
<p>内存报告为在收集度量标准的那一刻的工作集大小，以字节为单位。</p>
<p>在理想情况下，“工作集”是在内存压力下无法释放的正在使用的内存量。
然而，工作集的计算因主机操作系统而异，并且通常大量使用启发式算法来产生估计。</p>
<p>Kubernetes 模型中，容器工作集是由容器运行时计算的与相关容器关联的匿名内存。
工作集指标通常还包括一些缓存（文件支持）内存，因为主机操作系统不能总是回收页面。</p>
<p>要了解有关 Kubernetes 如何分配和测量内存资源的更多信息，
请参阅<a href=/zh/docs/concepts/configuration/manage-resources-containers/#meaning-of-memory>内存的含义</a>。</p>
<h2 id=metrics-server>Metrics 服务器 </h2>
<p>metrics-server 从 kubelet 中获取资源指标，并通过 Metrics API 在 Kubernetes API 服务器中公开它们，以供 HPA 和 VPA 使用。
你还可以使用 <code>kubectl top</code> 命令查看这些指标。</p>
<p>metrics-server 使用 Kubernetes API 来跟踪集群中的节点和 Pod。metrics-server 服务器通过 HTTP 查询每个节点以获取指标。
metrics-server 还构建了 Pod 元数据的内部视图，并维护 Pod 健康状况的缓存。
缓存的 Pod 健康信息可通过 metrics-server 提供的扩展 API 获得。</p>
<p>例如，对于 HPA 查询，metrics-server 需要确定哪些 Pod 满足 Deployment 中的标签选择器。</p>
<p>metrics-server 调用 <a href=/zh/docs/reference/command-line-tools-reference/kubelet/>kubelet</a> API
从每个节点收集指标。根据它使用的度量服务器版本：</p>
<ul>
<li>版本 v0.6.0+ 中，使用指标资源端点 <code>/metrics/resource</code></li>
<li>旧版本中使用 Summary API 端点 <code>/stats/summary</code></li>
</ul>
<p>了解更多 metrics-server，参阅 <a href=https://github.com/kubernetes-sigs/metrics-server>metrics-server 代码库</a>。</p>
<p>你还可以查看以下内容：</p>
<ul>
<li><a href=https://github.com/kubernetes/community/blob/master/contributors/design-proposals/instrumentation/metrics-server.md>metrics-server 设计</a></li>
<li><a href=https://github.com/kubernetes-sigs/metrics-server/blob/master/FAQ.md>metrics-server FAQ</a></li>
<li><a href=https://github.com/kubernetes-sigs/metrics-server/blob/master/KNOWN_ISSUES.md>metrics-server known issues</a></li>
<li><a href=https://github.com/kubernetes-sigs/metrics-server/releases>metrics-server releases</a></li>
<li><a href=/zh/docs/tasks/run-application/horizontal-pod-autoscale/>Horizontal Pod Autoscaling</a></li>
</ul>
<h3 id=summary-api-来源>Summary API 来源</h3>
<p><a href=/zh/docs/reference/command-line-tools-reference/kubelet/>Kubelet</a> 在节点、卷、Pod 和容器级别收集统计信息，
并在<a href=https://github.com/kubernetes/kubernetes/blob/7d309e0104fedb57280b261e5677d919cb2a0e2d/staging/src/k8s.io/kubelet/pkg/apis/stats/v1alpha1/types.go>Summary API</a>
中提供它们的统计信息供消费者阅读。</p>
<p>下面是一个 <code>minikube</code> 节点的 Summary API 请求示例：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get --raw <span style=color:#b44>&#34;/api/v1/nodes/minikube/proxy/stats/summary&#34;</span>
</code></pre></div>
<p>这是使用 <code>curl</code> 来执行的相同 API 调用：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>curl http://localhost:8080/api/v1/nodes/minikube/proxy/stats/summary
</code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>Note:</strong>
<p>从 metrics-server 0.6.x 开始，Summary API <code>/stats/summary</code> 端点被 <code>/metrics/resource</code> 端点替换。
</div>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-34a810f1516ad9d99b2697e36e9b0d0f>3 - 管理集群</h1>
<div class=lead>了解管理集群的常见任务。</div>
</div>
<div class=td-content>
<h1 id=pg-adb6c52e773f4d890595e14a9251f59b>3.1 - 从 dockershim 迁移</h1>
<p>本节提供从 dockershim 迁移到其他容器运行时的必备知识。</p>
<p>自从 Kubernetes 1.20 宣布
<a href=/zh/blog/2020/12/08/kubernetes-1-20-release-announcement/#dockershim-deprecation>弃用 dockershim</a>，
各类疑问随之而来：这对各类工作负载和 Kubernetes 部署会产生什么影响。
我们的<a href=/blog/2022/02/17/dockershim-faq/>弃用 Dockershim 常见问题</a>可以帮助你更好地理解这个问题。</p>
<p>建议从 dockershim 迁移到其他替代的容器运行时。
请参阅<a href=/zh/docs/setup/production-environment/container-runtimes/>容器运行时</a>
一节以了解可用的备选项。
当在迁移过程中遇到麻烦，请<a href=https://github.com/kubernetes/kubernetes/issues>上报问题</a>。
那么问题就可以及时修复，你的集群也可以进入移除 dockershim 前的就绪状态。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-b8acce0768c2f92cdb8eaa31e8072353>3.1.1 - 将节点上的容器运行时从 Docker Engine 改为 containerd</h1>
<p>本任务给出将容器运行时从 Docker 改为 containerd 所需的步骤。
此任务适用于运行 1.23 或更早版本 Kubernetes 的集群操作人员。
同时，此任务也涉及从 dockershim 迁移到 containerd 的示例场景，
以及可以从<a href=/zh/docs/setup/production-environment/container-runtimes/>此页面</a>
获得的其他容器运行时列表。</p>
<h2 id=before-you-begin>Before you begin</h2>
<div class="alert alert-secondary callout third-party-content" role=alert><strong>Note:</strong>
This section links to third party projects that provide functionality required by Kubernetes. The Kubernetes project authors aren't responsible for these projects, which are listed alphabetically. To add a project to this list, read the <a href=/docs/contribute/style/content-guide/#third-party-content>content guide</a> before submitting a change. <a href=#third-party-content-disclaimer>More information.</a></div>
<p>安装 containerd。进一步的信息可参见
<a href=https://containerd.io/docs/getting-started/>containerd 的安装文档</a>。
关于一些特定的环境准备工作，请遵循 <a href=/zh/docs/setup/production-environment/container-runtimes/#containerd>containerd 指南</a>。</p>
<h2 id=drain-the-node>腾空节点 </h2>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl drain &lt;node-to-drain&gt; --ignore-daemonsets
</code></pre></div><p>将 <code>&lt;node-to-drain></code> 替换为你所要腾空的节点的名称</p>
<h2 id=stop-the-docker-daemon>停止 Docker 守护进程 </h2>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>systemctl stop kubelet
systemctl disable docker.service --now
</code></pre></div>
<h2 id=install-containerd>安装 Containerd </h2>
<p>遵循此<a href=/zh/docs/setup/production-environment/container-runtimes/#containerd>指南</a>
了解安装 containerd 的详细步骤。</p>
<ul class="nav nav-tabs" id=tab-cri-containerd-installation role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tab-cri-containerd-installation-0 role=tab aria-controls=tab-cri-containerd-installation-0 aria-selected=true>Linux</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tab-cri-containerd-installation-1 role=tab aria-controls=tab-cri-containerd-installation-1>Windows (PowerShell)</a></li></ul>
<div class=tab-content id=tab-cri-containerd-installation><div id=tab-cri-containerd-installation-0 class="tab-pane show active" role=tabpanel aria-labelledby=tab-cri-containerd-installation-0>
<p>
<ol>
<li>从官方的 Docker 仓库安装 <code>containerd.io</code> 包。关于为你所使用的 Linux 发行版来设置
Docker 仓库，以及安装 <code>containerd.io</code> 包的详细说明，可参见
<a href=https://docs.docker.com/engine/install/#server>Install Docker Engine</a>。</li>
</ol>
<ol start=2>
<li>
<p>配置 containerd：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>sudo mkdir -p /etc/containerd
containerd config default | sudo tee /etc/containerd/config.toml
</code></pre></div></li>
</ol>
<ol start=3>
<li>
<p>重启 containerd：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>sudo systemctl restart containerd
</code></pre></div></li>
</ol>
</div>
<div id=tab-cri-containerd-installation-1 class=tab-pane role=tabpanel aria-labelledby=tab-cri-containerd-installation-1>
<p>
<p>启动一个 Powershell 会话，将 <code>$Version</code> 设置为期望的版本（例如：<code>$Version="1.4.3"</code>），
之后运行下面的命令：</p>
<ol>
<li>
<p>下载 containerd：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell>curl.exe -L https<span>:</span>//github.com/containerd/containerd/releases/download/v<span style=color:#b8860b>$Version</span>/containerd-<span style=color:#b8860b>$Version</span>-windows-amd64.tar.gz -o <span style=color:#a2f>containerd-windows</span>-amd64.tar.gz
tar.exe xvf .\<span style=color:#a2f>containerd-windows</span>-amd64.tar.gz
</code></pre></div></li>
</ol>
<ol start=2>
<li>
<p>解压缩并执行配置：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=color:#a2f>Copy-Item</span> -Path <span style=color:#b44>&#34;.\bin\&#34;</span> -Destination <span style=color:#b44>&#34;$Env:ProgramFiles\containerd&#34;</span> -Recurse -Force
<span style=color:#a2f>cd </span><span style=color:#b8860b>$Env:ProgramFiles</span>\containerd\
.\containerd.exe config <span style=color:#a2f;font-weight:700>default</span> | <span style=color:#a2f>Out-File</span> config.toml -Encoding ascii

<span style=color:#080;font-style:italic># 请审查配置信息。取决于你的安装环境，你可能需要调整：</span>
<span style=color:#080;font-style:italic># - the sandbox_image （Kubernetes pause 镜像）</span>
<span style=color:#080;font-style:italic># - cni bin_dir 和 conf_dir 的位置</span>
<span style=color:#a2f>Get-Content</span> config.toml

<span style=color:#080;font-style:italic># （可选步骤，但强烈建议执行）将 containerd 排除在 Windows Defender 扫描之外</span>
<span style=color:#a2f>Add-MpPreference</span> -ExclusionProcess <span style=color:#b44>&#34;$Env:ProgramFiles\containerd\containerd.exe&#34;</span>
</code></pre></div></li>
</ol>
<ol start=3>
<li>
<p>启动 containerd：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell>.\containerd.exe --register-service
<span style=color:#a2f>Start-Service</span> containerd
</code></pre></div></li>
</ol>
</div></div>
<h2 id=配置-kubelet-使用-containerd-作为其容器运行时>配置 kubelet 使用 containerd 作为其容器运行时</h2>
<p>编辑文件 <code>/var/lib/kubelet/kubeadm-flags.env</code>，将 containerd 运行时添加到标志中：
<code>--container-runtime=remote</code> 和 <code>--container-runtime-endpoint=unix:///run/containerd/containerd.sock"</code>。</p>
<p>对于使用 kubeadm 的用户，可以考虑下面的问题：</p>
<p><code>kubeadm</code> 工具将每个主机的 CRI 套接字保存在该主机对应的 Node 对象的注解中。
使用 <code>kubeadm</code> 的用户应该知道，<code>kubeadm</code> 工具将每个主机的 CRI 套接字保存在该主机对应的 Node 对象的注解中。
要更改这一注解信息，你可以在一台包含 kubeadm <code>/etc/kubernetes/admin.conf</code> 文件的机器上执行以下命令：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl edit no &lt;node-name&gt;
</code></pre></div>
<p>这一命令会打开一个文本编辑器，供你在其中编辑 Node 对象。
要选择不同的文本编辑器，你可以设置 <code>KUBE_EDITOR</code> 环境变量。</p>
<ul>
<li>
<p>更改 <code>kubeadm.alpha.kubernetes.io/cri-socket</code> 值，将其从
<code>/var/run/dockershim.sock</code> 改为你所选择的 CRI 套接字路径
（例如：<code>unix:///run/containerd/containerd.sock</code>）。</p>
<p>注意新的 CRI 套接字路径必须带有 <code>unix://</code> 前缀。</p>
</li>
<li>
<p>保存文本编辑器中所作的修改，这会更新 Node 对象。</p>
</li>
</ul>
<h2 id=restart-the-kubelet>重启 kubelet </h2>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>systemctl start kubelet
</code></pre></div>
<h2 id=verify-that-the-node-is-healthy>验证节点处于健康状态 </h2>
<p>运行 <code>kubectl get nodes -o wide</code>，containerd 会显示为我们所更改的节点上的运行时。</p>
<div class="alert alert-secondary callout third-party-content" role=alert><strong>Note:</strong>
This section links to third party projects that provide functionality required by Kubernetes. The Kubernetes project authors aren't responsible for these projects, which are listed alphabetically. To add a project to this list, read the <a href=/docs/contribute/style/content-guide/#third-party-content>content guide</a> before submitting a change. <a href=#third-party-content-disclaimer>More information.</a></div>
<p>最后，在一切顺利时删除 Docker。</p>
<ul class="nav nav-tabs" id=tab-remove-docker-enigine role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tab-remove-docker-enigine-0 role=tab aria-controls=tab-remove-docker-enigine-0 aria-selected=true>CentOS</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tab-remove-docker-enigine-1 role=tab aria-controls=tab-remove-docker-enigine-1>Debian</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tab-remove-docker-enigine-2 role=tab aria-controls=tab-remove-docker-enigine-2>Fedora</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tab-remove-docker-enigine-3 role=tab aria-controls=tab-remove-docker-enigine-3>Ubuntu</a></li></ul>
<div class=tab-content id=tab-remove-docker-enigine><div id=tab-remove-docker-enigine-0 class="tab-pane show active" role=tabpanel aria-labelledby=tab-remove-docker-enigine-0>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>sudo yum remove docker-ce docker-ce-cli
</code></pre></div></div>
<div id=tab-remove-docker-enigine-1 class=tab-pane role=tabpanel aria-labelledby=tab-remove-docker-enigine-1>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>sudo apt-get purge docker-ce docker-ce-cli
</code></pre></div></div>
<div id=tab-remove-docker-enigine-2 class=tab-pane role=tabpanel aria-labelledby=tab-remove-docker-enigine-2>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>sudo dnf remove docker-ce docker-ce-cli
</code></pre></div></div>
<div id=tab-remove-docker-enigine-3 class=tab-pane role=tabpanel aria-labelledby=tab-remove-docker-enigine-3>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>sudo apt-get purge docker-ce docker-ce-cli
</code></pre></div></div></div>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-d79db9ed1698f75ec5f2228987290e49>3.1.2 - 查明节点上所使用的容器运行时</h1>
<p>本页面描述查明集群中节点所使用的<a href=/zh/docs/setup/production-environment/container-runtimes/>容器运行时</a>
的步骤。</p>
<p>取决于你运行集群的方式，节点所使用的容器运行时可能是事先配置好的，
也可能需要你来配置。如果你在使用托管的 Kubernetes 服务，
可能存在特定于厂商的方法来检查节点上配置的容器运行时。
本页描述的方法应该在能够执行 <code>kubectl</code> 的场合下都可以工作。</p>
<h2 id=before-you-begin>Before you begin</h2>
<p>安装并配置 <code>kubectl</code>。参见<a href=/zh/docs/tasks/tools/#kubectl>安装工具</a> 节了解详情。</p>
<h2 id=查明节点所使用的容器运行时>查明节点所使用的容器运行时</h2>
<p>使用 <code>kubectl</code> 来读取并显示节点信息：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get nodes -o wide
</code></pre></div>
<p>输出如下面所示。<code>CONTAINER-RUNTIME</code> 列给出容器运行时及其版本。</p>
<pre><code class=language-none data-lang=none># For dockershim
NAME         STATUS   VERSION    CONTAINER-RUNTIME
node-1       Ready    v1.16.15   docker://19.3.1
node-2       Ready    v1.16.15   docker://19.3.1
node-3       Ready    v1.16.15   docker://19.3.1
</code></pre><pre><code class=language-none data-lang=none># For containerd
NAME         STATUS   VERSION   CONTAINER-RUNTIME
node-1       Ready    v1.19.6   containerd://1.4.1
node-2       Ready    v1.19.6   containerd://1.4.1
node-3       Ready    v1.19.6   containerd://1.4.1
</code></pre>
<p>你可以在<a href=/zh/docs/setup/production-environment/container-runtimes/>容器运行时</a>
页面找到与容器运行时相关的更多信息。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-58702e4818c09c9b3d574349c1a71cb3>3.1.3 - 检查弃用 Dockershim 对你的影响</h1>
<p>Kubernetes 的 <code>dockershim</code> 组件使得你可以把 Docker 用作 Kubernetes 的
<a class=glossary-tooltip title=容器运行时是负责运行容器的软件。 data-toggle=tooltip data-placement=top href=/zh/docs/setup/production-environment/container-runtimes target=_blank aria-label=容器运行时>容器运行时</a>。
在 Kubernetes v1.20 版本中，内建组件 <code>dockershim</code> 被<a href=/zh/blog/2020/12/08/kubernetes-1-20-release-announcement/#dockershim-deprecation>弃用</a>。</p>
<p>本页讲解你的集群把 Docker 用作容器运行时的运作机制，
并提供使用 <code>dockershim</code> 时，它所扮演角色的详细信息，
继而展示了一组操作，可用来检查弃用 <code>dockershim</code> 对你的工作负载是否有影响。</p>
<h2 id=find-docker-dependencies>检查你的应用是否依赖于 Docker</h2>
<p>即使你是通过 Docker 创建的应用容器，也不妨碍你在其他任何容器运行时上运行这些容器。
这种使用 Docker 的方式并不构成对 Docker 作为一个容器运行时的依赖。</p>
<p>当用了别的容器运行时之后，Docker 命令可能不工作，或者产生意外的输出。
下面是判定你是否依赖于 Docker 的方法。</p>
<ol>
<li>确认没有特权 Pod 执行 Docker 命令（如 <code>docker ps</code>）、重新启动 Docker
服务（如 <code>systemctl restart docker.service</code>）或修改 Docker 配置文件
<code>/etc/docker/daemon.json</code>。</li>
<li>检查 Docker 配置文件（如 <code>/etc/docker/daemon.json</code>）中容器镜像仓库的镜像（mirror）站点设置。
这些配置通常需要针对不同容器运行时来重新设置。</li>
<li>检查确保在 Kubernetes 基础设施之外的节点上运行的脚本和应用程序没有执行 Docker 命令。
可能的情况如：
<ul>
<li>SSH 到节点排查故障；</li>
<li>节点启动脚本；</li>
<li>直接安装在节点上的监控和安全代理。</li>
</ul>
</li>
<li>检查执行上述特权操作的第三方工具。详细操作请参考
<a href=/zh/docs/tasks/administer-cluster/migrating-from-dockershim/migrating-telemetry-and-security-agents>从 dockershim 迁移遥测和安全代理</a>。</li>
<li>确认没有对 dockershim 行为的间接依赖。这是一种极端情况，不太可能影响你的应用。
一些工具很可能被配置为使用了 Docker 特性，比如，基于特定指标发警报，
或者在故障排查指令的一个环节中搜索特定的日志信息。
如果你有此类配置的工具，需要在迁移之前，在测试集群上测试这类行为。</li>
</ol>
<h2 id=role-of-dockershim>Docker 依赖详解</h2>
<p><a href=/zh/docs/concepts/containers/#container-runtimes>容器运行时</a>是一个软件，用来运行组成 Kubernetes Pod 的容器。
Kubernetes 负责编排和调度 Pod；在每一个节点上，<a class=glossary-tooltip title="一个在集群中每个节点上运行的代理。它保证容器都运行在 Pod 中。" data-toggle=tooltip data-placement=top href=/docs/reference/generated/kubelet target=_blank aria-label=kubelet>kubelet</a>
使用抽象的容器运行时接口，所以你可以任意选用兼容的容器运行时。</p>
<p>在早期版本中，Kubernetes 提供的兼容性支持一个容器运行时：Docker。
在 Kubernetes 发展历史中，集群运营人员希望采用更多的容器运行时。
于是 CRI 被设计出来满足这类灵活性需要 - 而 kubelet 亦开始支持 CRI。
然而，因为 Docker 在 CRI 规范创建之前就已经存在，Kubernetes 就创建了一个适配器组件 <code>dockershim</code>。
dockershim 适配器允许 kubelet 与 Docker 交互，就好像 Docker 是一个 CRI 兼容的运行时一样。</p>
<p>你可以阅读博文
<a href=/zh/blog/2018/05/24/kubernetes-containerd-integration-goes-ga/>Kubernetes 正式支持集成 Containerd</a>。</p>
<p><img src=/images/blog/2018-05-24-kubernetes-containerd-integration-goes-ga/cri-containerd.png alt="Dockershim 和 Containerd CRI 的实现对比图"></p>
<p>切换到容器运行时 Containerd 可以消除掉中间环节。
所有相同的容器都可由 Containerd 这类容器运行时来运行。
但是现在，由于直接用容器运行时调度容器，它们对 Docker 是不可见的。
因此，你以前用来检查这些容器的 Docker 工具或漂亮的 UI 都不再可用。</p>
<p>你不能再使用 <code>docker ps</code> 或 <code>docker inspect</code> 命令来获取容器信息。
由于你不能列出容器，因此你不能获取日志、停止容器，甚至不能通过 <code>docker exec</code> 在容器中执行命令。</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 如果你在用 Kubernetes 运行工作负载，最好通过 Kubernetes API 停止容器，
而不是通过容器运行时来停止它们
（此建议适用于所有容器运行时，不仅仅是针对 Docker）。
</div>
<p>你仍然可以下载镜像，或者用 <code>docker build</code> 命令创建它们。
但用 Docker 创建、下载的镜像，对于容器运行时和 Kubernetes，均不可见。
为了在 Kubernetes 中使用，需要把镜像推送（push）到某镜像仓库。</p>
<h2 id=what-s-next>What's next</h2>
<ul>
<li>阅读<a href=/zh/docs/tasks/administer-cluster/migrating-from-dockershim/>从 dockershim 迁移</a>以了解你的下一步工作</li>
<li>阅读<a href=/zh/blog/2020/12/02/dockershim-faq/>dockershim 弃用常见问题解答</a>文章了解更多信息。</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-eb3e279a6c5e1224e744080a52ee3f28>3.1.4 - 从 dockershim 迁移遥测和安全代理</h1>
<p>在 Kubernetes 1.20 版本中，dockershim 被弃用。
在博文<a href=/zh/blog/2020/12/02/dockershim-faq/>弃用 Dockershim 常见问题</a>中，
你大概已经了解到，大多数应用并没有直接通过运行时来托管容器。
但是，仍然有大量的遥测和安全代理依赖 docker 来收集容器元数据、日志和指标。
本文汇总了一些信息和链接：信息用于阐述如何探查这些依赖，链接用于解释如何迁移这些代理去使用通用的工具或其他容器运行。</p>
<h2 id=telemetry-and-security-agents>遥测和安全代理</h2>
<p>为了让代理运行在 Kubernetes 集群中，我们有几种办法。
代理既可以直接在节点上运行，也可以作为守护进程运行。</p>
<h3 id=why-do-telemetry-agents-relyon-docker>为什么遥测代理依赖于 Docker？</h3>
<p>因为历史原因，Kubernetes 建立在 Docker 之上。
Kubernetes 管理网络和调度，Docker 则在具体的节点上定位并操作容器。
所以，你可以从 Kubernetes 取得调度相关的元数据，比如 Pod 名称；从 Docker 取得容器状态信息。
后来，人们开发了更多的运行时来管理容器。
同时一些项目和 Kubernetes 特性也不断涌现，支持跨多个运行时收集容器状态信息。</p>
<p>一些代理和 Docker 工具紧密绑定。此类代理可以这样运行命令，比如用
<a href=https://docs.docker.com/engine/reference/commandline/ps/><code>docker ps</code></a>
或 <a href=https://docs.docker.com/engine/reference/commandline/top/><code>docker top</code></a>
这类命令来列出容器和进程，用
<a href=https://docs.docker.com/engine/reference/commandline/logs/>docker logs</a>
订阅 Docker 的日志。
但随着 Docker 作为容器运行时被弃用，这些命令将不再工作。</p>
<h3 id=identify-docker-dependency>识别依赖于 Docker 的 DaemonSet</h3>
<p>如果某 Pod 想调用运行在节点上的 <code>dockerd</code>，该 Pod 必须满足以下两个条件之一：</p>
<ul>
<li>将包含 Docker 守护进程特权套接字的文件系统挂载为一个<a class=glossary-tooltip title="包含可被 Pod 中容器访问的数据的目录。" data-toggle=tooltip data-placement=top href=/zh/docs/concepts/storage/volumes/ target=_blank aria-label=卷>卷</a>；或</li>
<li>直接以卷的形式挂载 Docker 守护进程特权套接字的特定路径。</li>
</ul>
<p>举例来说：在 COS 镜像中，Docker 通过 <code>/var/run/docker.sock</code> 开放其 Unix 域套接字。
这意味着 Pod 的规约中需要包含 <code>hostPath</code> 卷以挂载 <code>/var/run/docker.sock</code>。</p>
<p>下面是一个 shell 示例脚本，用于查找包含直接映射 Docker 套接字的挂载点的 Pod。
你也可以删掉 grep <code>/var/run/docker.sock</code> 这一代码片段以查看其它挂载信息。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl get pods --all-namespaces <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>-o<span style=color:#666>=</span><span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{range .items[*]}{&#34;\n&#34;}{.metadata.namespace}{&#34;:\t&#34;}{.metadata.name}{&#34;:\t&#34;}{range .spec.volumes[*]}{.hostPath.path}{&#34;, &#34;}{end}{end}&#39;</span> <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>| sort <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>| grep <span style=color:#b44>&#39;/var/run/docker.sock&#39;</span>
</code></pre></div>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 对于 Pod 来说，访问宿主机上的 Docker 还有其他方式。
例如，可以挂载 <code>/var/run</code> 的父目录而非其完整路径
（就像<a href=https://gist.github.com/itaysk/7bc3e56d69c4d72a549286d98fd557dd>这个例子</a>）。
上述脚本只检测最常见的使用方式。
</div>
<h3 id=detecting-docker-dependency-from-node-agents>检测节点代理对 Docker 的依赖性</h3>
<p>在你的集群节点被定制、且在各个节点上均安装了额外的安全和遥测代理的场景下，
一定要和代理的供应商确认：该代理是否依赖于 Docker。</p>
<h3 id=telemetry-and-security-agent-vendors>遥测和安全代理的供应商</h3>
<p>我们通过
<a href=https://docs.google.com/document/d/1ZFi4uKit63ga5sxEiZblfb-c23lFhvy6RXVPikS8wf0/edit#>谷歌文档</a>
提供了为各类遥测和安全代理供应商准备的持续更新的迁移指导。
请与供应商联系，获取从 dockershim 迁移的最新说明。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-8e16d69617b175d61e2e7a6e1642c9d6>3.2 - 用 kubeadm 进行管理</h1>
</div>
<div class=td-content>
<h1 id=pg-f62fba1de4084f3be070785757c8079c>3.2.1 - 使用 kubeadm 进行证书管理</h1>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.15 [stable]</code>
</div>
<p>由 <a href=/zh/docs/reference/setup-tools/kubeadm/>kubeadm</a> 生成的客户端证书在 1 年后到期。
本页说明如何使用 kubeadm 管理证书续订。</p>
<h2 id=before-you-begin>Before you begin</h2>
<p>你应该熟悉 <a href=/zh/docs/setup/best-practices/certificates/>Kubernetes 中的 PKI 证书和要求</a>。</p>
<h2 id=custom-certificates>使用自定义的证书</h2>
<p>默认情况下, kubeadm 会生成运行一个集群所需的全部证书。
你可以通过提供你自己的证书来改变这个行为策略。</p>
<p>如果要这样做, 你必须将证书文件放置在通过 <code>--cert-dir</code> 命令行参数或者 kubeadm 配置中的
<code>CertificatesDir</code> 配置项指明的目录中。默认的值是 <code>/etc/kubernetes/pki</code>。</p>
<p>如果在运行 <code>kubeadm init</code> 之前存在给定的证书和私钥对，kubeadm 将不会重写它们。
例如，这意味着您可以将现有的 CA 复制到 <code>/etc/kubernetes/pki/ca.crt</code> 和
<code>/etc/kubernetes/pki/ca.key</code> 中，而 kubeadm 将使用此 CA 对其余证书进行签名。</p>
<h2 id=external-ca-mode>外部 CA 模式</h2>
<p>只提供了 <code>ca.crt</code> 文件但是不提供 <code>ca.key</code> 文件也是可以的
（这只对 CA 根证书可用，其它证书不可用）。
如果所有的其它证书和 kubeconfig 文件已就绪，kubeadm 检测到满足以上条件就会激活
"外部 CA" 模式。kubeadm 将会在没有 CA 密钥文件的情况下继续执行。</p>
<p>否则, kubeadm 将独立运行 controller-manager，附加一个
<code>--controllers=csrsigner</code> 的参数，并且指明 CA 证书和密钥。</p>
<p><a href=/zh/docs/setup/best-practices/certificates/>PKI 证书和要求</a>包括集群使用外部 CA 的设置指南。</p>
<h2 id=检查证书是否过期>检查证书是否过期</h2>
<p>你可以使用 <code>check-expiration</code> 子命令来检查证书何时过期</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubeadm certs check-expiration
</code></pre></div>
<p>输出类似于以下内容：</p>
<pre><code>CERTIFICATE                EXPIRES                  RESIDUAL TIME   CERTIFICATE AUTHORITY   EXTERNALLY MANAGED
admin.conf                 Dec 30, 2020 23:36 UTC   364d                                    no
apiserver                  Dec 30, 2020 23:36 UTC   364d            ca                      no
apiserver-etcd-client      Dec 30, 2020 23:36 UTC   364d            etcd-ca                 no
apiserver-kubelet-client   Dec 30, 2020 23:36 UTC   364d            ca                      no
controller-manager.conf    Dec 30, 2020 23:36 UTC   364d                                    no
etcd-healthcheck-client    Dec 30, 2020 23:36 UTC   364d            etcd-ca                 no
etcd-peer                  Dec 30, 2020 23:36 UTC   364d            etcd-ca                 no
etcd-server                Dec 30, 2020 23:36 UTC   364d            etcd-ca                 no
front-proxy-client         Dec 30, 2020 23:36 UTC   364d            front-proxy-ca          no
scheduler.conf             Dec 30, 2020 23:36 UTC   364d                                    no

CERTIFICATE AUTHORITY   EXPIRES                  RESIDUAL TIME   EXTERNALLY MANAGED
ca                      Dec 28, 2029 23:36 UTC   9y              no
etcd-ca                 Dec 28, 2029 23:36 UTC   9y              no
front-proxy-ca          Dec 28, 2029 23:36 UTC   9y              no
</code></pre>
<p>该命令显示 <code>/etc/kubernetes/pki</code> 文件夹中的客户端证书以及
kubeadm（<code>admin.conf</code>, <code>controller-manager.conf</code> 和 <code>scheduler.conf</code>）
使用的 KUBECONFIG 文件中嵌入的客户端证书的到期时间/剩余时间。</p>
<p>另外， kubeadm 会通知用户证书是否由外部管理；
在这种情况下，用户应该小心的手动/使用其他工具来管理证书更新。</p>
<div class="alert alert-danger warning callout" role=alert>
<strong>Warning:</strong> <code>kubeadm</code> 不能管理由外部 CA 签名的证书
</div>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 上面的列表中没有包含 <code>kubelet.conf</code>，因为 kubeadm 将 kubelet 配置为
<a href=/docs/tasks/tls/certificate-rotation/>自动更新证书</a>。
轮换的证书位于目录 <code>/var/lib/kubelet/pki</code>。
要修复过期的 kubelet 客户端证书，请参阅
<a href=/zh/docs/setup/production-environment/tools/kubeadm/troubleshooting-kubeadm/#kubelet-client-cert>kubelet 客户端证书轮换失败</a>。
</div>
<div class="alert alert-danger warning callout" role=alert>
<strong>Warning:</strong> <p>在通过 <code>kubeadm init</code> 创建的节点上，在 kubeadm 1.17 版本之前有一个
<a href=https://github.com/kubernetes/kubeadm/issues/1753>缺陷</a>，该缺陷
使得你必须手动修改 <code>kubelet.conf</code> 文件的内容。
<code>kubeadm init</code> 操作结束之后，你必须更新 <code>kubelet.conf</code> 文件
将 <code>client-certificate-data</code> 和 <code>client-key-data</code> 改为如下所示的内容
以便使用轮换后的 kubelet 客户端证书：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>client-certificate</span>:<span style=color:#bbb> </span>/var/lib/kubelet/pki/kubelet-client-current.pem<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>client-key</span>:<span style=color:#bbb> </span>/var/lib/kubelet/pki/kubelet-client-current.pem<span style=color:#bbb>
</span></code></pre></div>
</div>
<h2 id=自动更新证书>自动更新证书</h2>
<p><code>kubeadm</code> 会在控制面
<a href=/zh/docs/tasks/administer-cluster/kubeadm/kubeadm-upgrade/>升级</a>
的时候更新所有证书。</p>
<p>这个功能旨在解决最简单的用例；如果你对此类证书的更新没有特殊要求，
并且定期执行 Kubernetes 版本升级（每次升级之间的间隔时间少于 1 年），
则 kubeadm 将确保你的集群保持最新状态并保持合理的安全性。</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 最佳的做法是经常升级集群以确保安全。
</div>
<p>如果你对证书更新有更复杂的需求，则可通过将 <code>--certificate-renewal=false</code> 传递给
<code>kubeadm upgrade apply</code> 或者 <code>kubeadm upgrade node</code>，从而选择不采用默认行为。</p>
<div class="alert alert-danger warning callout" role=alert>
<strong>Warning:</strong> kubeadm 在 1.17 版本之前有一个<a href=https://github.com/kubernetes/kubeadm/issues/1818>缺陷</a>，
该缺陷导致 <code>kubeadm update node</code> 执行时 <code>--certificate-renewal</code> 的默认值被设置为 <code>false</code>。
在这种情况下，你需要显式地设置 <code>--certificate-renewal=true</code>。
</div>
<h2 id=手动更新证书>手动更新证书</h2>
<p>你能随时通过 <code>kubeadm certs renew</code> 命令手动更新你的证书。</p>
<p>此命令用 CA （或者 front-proxy-CA ）证书和存储在 <code>/etc/kubernetes/pki</code> 中的密钥执行更新。</p>
<p>执行完此命令之后你需要重启控制面 Pods。因为动态证书重载目前还不被所有组件和证书支持，所有这项操作是必须的。
<a href=/zh/docs/tasks/configure-pod-container/static-pod/>静态 Pods</a> 是被本地 kubelet 而不是 API Server 管理，
所以 kubectl 不能用来删除或重启他们。
要重启静态 Pod 你可以临时将清单文件从 <code>/etc/kubernetes/manifests/</code> 移除并等待 20 秒
（参考 <a href=/docs/reference/config-api/kubelet-config.v1beta1/>KubeletConfiguration 结构</a> 中的<code>fileCheckFrequency</code> 值）。
如果 Pod 不在清单目录里，kubelet将会终止它。
在另一个 <code>fileCheckFrequency</code> 周期之后你可以将文件移回去，为了组件可以完成 kubelet 将重新创建 Pod 和证书更新。</p>
<div class="alert alert-danger warning callout" role=alert>
<strong>Warning:</strong> 如果你运行了一个 HA 集群，这个命令需要在所有控制面板节点上执行。
</div>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> <code>certs renew</code> 使用现有的证书作为属性 (Common Name、Organization、SAN 等) 的权威来源，
而不是 kubeadm-config ConfigMap 。强烈建议使它们保持同步。
</div>
<p><code>kubeadm certs renew</code>提供以下选项：</p>
<p>Kubernetes 证书通常在一年后到期。</p>
<ul>
<li><code>--csr-only</code> 可用于经过一个外部 CA 生成的证书签名请求来更新证书（无需实际替换更新证书）；
更多信息请参见下节。</li>
<li>可以更新单个证书而不是全部证书。</li>
</ul>
<h2 id=用-kubernetes-证书-api-更新证书>用 Kubernetes 证书 API 更新证书</h2>
<p>本节提供有关如何使用 Kubernetes 证书 API 执行手动证书更新的更多详细信息。</p>
<div class="alert alert-warning caution callout" role=alert>
<strong>Caution:</strong> 这些是针对需要将其组织的证书基础结构集成到 kubeadm 构建的集群中的用户的高级主题。
如果默认的 kubeadm 配置满足了你的需求，则应让 kubeadm 管理证书。
</div>
<h3 id=设置一个签名者-signer>设置一个签名者（Signer）</h3>
<p>Kubernetes 证书颁发机构不是开箱即用。
你可以配置外部签名者，例如
<a href=https://cert-manager.io/docs/configuration/ca/>cert-manager</a>，
也可以使用内置签名者。
内置签名者是
<a href=/zh/docs/reference/command-line-tools-reference/kube-controller-manager/><code>kube-controller-manager</code></a>
的一部分。
要激活内置签名者，请传递 <code>--cluster-signing-cert-file</code> 和 <code>--cluster-signing-key-file</code> 参数。</p>
<p>如果你正在创建一个新的集群，你可以使用 kubeadm 的
<a href=/docs/reference/config-api/kubeadm-config.v1beta3/>配置文件</a>。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>kubeadm.k8s.io/v1beta3<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>controllerManager</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>extraArgs</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>cluster-signing-cert-file</span>:<span style=color:#bbb> </span>/etc/kubernetes/pki/ca.crt<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>cluster-signing-key-file</span>:<span style=color:#bbb> </span>/etc/kubernetes/pki/ca.key<span style=color:#bbb>
</span></code></pre></div>
<h3 id=创建证书签名请求-csr>创建证书签名请求 (CSR)</h3>
<p>有关使用 Kubernetes API 创建 CSR 的信息，
请参见<a href=/zh/docs/reference/access-authn-authz/certificate-signing-requests/#create-certificatesigningrequest>创建 CertificateSigningRequest</a>。</p>
<h2 id=通过外部-ca-更新证书>通过外部 CA 更新证书</h2>
<p>本节提供有关如何使用外部 CA 执行手动更新证书的更多详细信息。</p>
<p>为了更好的与外部 CA 集成，kubeadm 还可以生成证书签名请求（CSR）。
CSR 表示向 CA 请求客户的签名证书。
在 kubeadm 术语中，通常由磁盘 CA 签名的任何证书都可以作为 CSR 生成。但是，CA 不能作为 CSR 生成。</p>
<h3 id=创建证书签名请求-csr-1>创建证书签名请求 (CSR)</h3>
<p>你可以通过 <code>kubeadm certs renew --csr-only</code> 命令创建证书签名请求。</p>
<p>CSR 和随附的私钥都在输出中给出。
你可以传入一个带有 <code>--csr-dir</code> 的目录，将 CRS 输出到指定位置。
如果未指定 <code>--csr-dir</code> ，则使用默认证书目录（<code>/etc/kubernetes/pki</code>）。</p>
<p>证书可以通过 <code>kubeadm certs renew --csr-only</code> 来续订。
和 <code>kubeadm init</code> 一样，可以使用 <code>--csr-dir</code> 标志指定一个输出目录。</p>
<p>CSR 签署证书后，必须将证书和私钥复制到 PKI 目录（默认情况下为 <code>/etc/kubernetes/pki</code>）。</p>
<p>CSR 中包含一个证书的名字，域和 IP，但是未指定用法。
颁发证书时，CA 有责任指定<a href=/zh/docs/setup/best-practices/certificates/#all-certificates>正确的证书用法</a></p>
<ul>
<li>在 <code>openssl</code> 中，这是通过
<a href=https://superuser.com/questions/738612/openssl-ca-keyusage-extension><code>openssl ca</code> 命令</a>
来完成的。</li>
<li>在 <code>cfssl</code> 中，这是通过
<a href=https://github.com/cloudflare/cfssl/blob/master/doc/cmd/cfssl.txt#L170>在配置文件中指定用法</a>
来完成的。</li>
</ul>
<p>使用首选方法对证书签名后，必须将证书和私钥复制到 PKI 目录（默认为 <code>/etc/kubernetes/pki</code> ）。</p>
<h2 id=certificate-authority-rotation>证书机构（CA）轮换 </h2>
<p>kubeadm 并不直接支持对 CA 证书的轮换或者替换。</p>
<p>关于手动轮换或者置换 CA 的更多信息，可参阅
<a href=/zh/docs/tasks/tls/manual-rotation-of-ca-certificates/>手动轮换 CA 证书</a>。</p>
<h2 id=kubelet-serving-certs>启用已签名的 kubelet 服务证书 </h2>
<p>默认情况下，kubeadm 所部署的 kubelet 服务证书是自签名（Self-Signed））。
这意味着从 <a href=https://github.com/kubernetes-sigs/metrics-server>metrics-server</a>
这类外部服务发起向 kubelet 的链接时无法使用 TLS 来完成保护。</p>
<p>要在新的 kubeadm 集群中配置 kubelet 以使用被正确签名的服务证书，
你必须向 <code>kubeadm init</code> 传递如下最小配置数据：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>kubeadm.k8s.io/v1beta3<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>kubelet.config.k8s.io/v1beta1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>KubeletConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>serverTLSBootstrap</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></code></pre></div>
<p>如果你已经创建了集群，你必须通过执行下面的操作来完成适配：</p>
<ul>
<li>找到 <code>kube-system</code> 名字空间中名为 <code>kubelet-config-1.27</code>
的 ConfigMap 并编辑之。
在该 ConfigMap 中，<code>kubelet</code> 键下面有一个
<a href=/zh/docs/reference/config-api/kubelet-config.v1beta1/#kubelet-config-k8s-io-v1beta1-KubeletConfiguration>KubeletConfiguration</a>
文档作为其取值。编辑该 KubeletConfiguration 文档以设置
<code>serverTLSBootstrap: true</code>。</li>
<li>在每个节点上，在 <code>/var/lib/kubelet/config.yaml</code> 文件中添加
<code>serverTLSBootstrap: true</code> 字段，并使用 <code>systemctl restart kubelet</code>
来重启 kubelet。</li>
</ul>
<p>字段 <code>serverTLSBootstrap</code> 将允许启动引导 kubelet 的服务证书，方式
是从 <code>certificates.k8s.io</code> API 处读取。这种方式的一种局限在于这些
证书的 CSR（证书签名请求）不能被 kube-controller-manager 中默认的
签名组件
<a href=/zh/docs/reference/access-authn-authz/certificate-signing-requests/#kubernetes-signers><code>kubernetes.io/kubelet-serving</code></a>
批准。需要用户或者第三方控制器来执行此操作。</p>
<p>可以使用下面的命令来查看 CSR：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get csr
</code></pre></div><pre><code class=language-none data-lang=none>NAME        AGE     SIGNERNAME                        REQUESTOR                      CONDITION
csr-9wvgt   112s    kubernetes.io/kubelet-serving     system:node:worker-1           Pending
csr-lz97v   1m58s   kubernetes.io/kubelet-serving     system:node:control-plane-1    Pending
</code></pre>
<p>你可以执行下面的操作来批准这些请求：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl certificate approve &lt;CSR-名称&gt;
</code></pre></div>
<p>默认情况下，这些服务证书上会在一年后过期。
kubeadm 将 <code>KubeletConfiguration</code> 的 <code>rotateCertificates</code> 字段设置为
<code>true</code>；这意味着证书快要过期时，会生成一组针对服务证书的新的 CSR，而
这些 CSR 也要被批准才能完成证书轮换。
要进一步了解这里的细节，可参阅
<a href=/zh/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/#certificate-rotation>证书轮换</a>
文档。</p>
<p>如果你在寻找一种能够自动批准这些 CSR 的解决方案，建议你与你的云提供商
联系，询问他们是否有 CSR 签名组件，用来以带外（out-of-band）的方式检查
节点的标识符。</p>
<div class="alert alert-secondary callout third-party-content" role=alert><strong>Note:</strong>
This section links to third party projects that provide functionality required by Kubernetes. The Kubernetes project authors aren't responsible for these projects, which are listed alphabetically. To add a project to this list, read the <a href=/docs/contribute/style/content-guide/#third-party-content>content guide</a> before submitting a change. <a href=#third-party-content-disclaimer>More information.</a></div>
<p>也可以使用第三方定制的控制器：</p>
<ul>
<li><a href=https://github.com/kontena/kubelet-rubber-stamp>kubelet-rubber-stamp</a></li>
</ul>
<p>除非既能够验证 CSR 中的 CommonName，也能检查请求的 IP 和域名，
这类控制器还算不得安全的机制。
只有完成彻底的检查，才有可能避免有恶意的、能够访问 kubelet 客户端证书的第三方
为任何 IP 或域名请求服务证书。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-6134c5061298affa145ddb801b5c29da>3.2.2 - 配置 cgroup 驱动</h1>
<p>本页阐述如何配置 kubelet 的 cgroup 驱动以匹配 kubeadm 集群中的容器运行时的 cgroup 驱动。</p>
<h2 id=before-you-begin>Before you begin</h2>
<p>你应该熟悉 Kubernetes 的<a href=/zh/docs/setup/production-environment/container-runtimes>容器运行时需求</a>。</p>
<h2 id=configuring-the-container-runtime-cgroup-driver>配置容器运行时 cgroup 驱动</h2>
<p><a href=/zh/docs/setup/production-environment/container-runtimes>容器运行时</a>页面提到：
由于 kubeadm 把 kubelet 视为一个系统服务来管理，所以对基于 kubeadm 的安装，
我们推荐使用 <code>systemd</code> 驱动，不推荐 <code>cgroupfs</code> 驱动。</p>
<p>此页还详述了如何安装若干不同的容器运行时，并将 <code>systemd</code> 设为其默认驱动。</p>
<h2 id=配置-kubelet-的-cgroup-驱动>配置 kubelet 的 cgroup 驱动</h2>
<p>kubeadm 支持在执行 <code>kubeadm init</code> 时，传递一个 <code>KubeletConfiguration</code> 结构体。
<code>KubeletConfiguration</code> 包含 <code>cgroupDriver</code> 字段，可用于控制 kubelet 的 cgroup 驱动。</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 在版本 1.22 中，如果用户没有在 <code>KubeletConfiguration</code> 中设置 <code>cgroupDriver</code> 字段，
<code>kubeadm init</code> 会将它设置为默认值 <code>systemd</code>。
</div>
<p>这是一个最小化的示例，其中显式的配置了此字段：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#080;font-style:italic># kubeadm-config.yaml</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>kubeadm.k8s.io/v1beta3<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kubernetesVersion</span>:<span style=color:#bbb> </span>v1.21.0<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>KubeletConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>kubelet.config.k8s.io/v1beta1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>cgroupDriver</span>:<span style=color:#bbb> </span>systemd<span style=color:#bbb>
</span></code></pre></div>
<p>这样一个配置文件就可以传递给 kubeadm 命令了：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubeadm init --config kubeadm-config.yaml
</code></pre></div>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> <p>Kubeadm 对集群所有的节点，使用相同的 <code>KubeletConfiguration</code>。
<code>KubeletConfiguration</code> 存放于 <code>kube-system</code> 命名空间下的某个
<a href=/zh/docs/concepts/configuration/configmap>ConfigMap</a> 对象中。</p>
<p>执行 <code>init</code>、<code>join</code> 和 <code>upgrade</code> 等子命令会促使 kubeadm
将 <code>KubeletConfiguration</code> 写入到文件 <code>/var/lib/kubelet/config.yaml</code> 中，
继而把它传递给本地节点的 kubelet。</p>
</div>
<h1 id=使用-cgroupfs-驱动>使用 <code>cgroupfs</code> 驱动</h1>
<p>正如本指南阐述的：不推荐与 kubeadm 一起使用 <code>cgroupfs</code> 驱动。</p>
<p>如仍需使用 <code>cgroupfs</code>，
且要防止 <code>kubeadm upgrade</code> 修改现有系统中 <code>KubeletConfiguration</code> 的 cgroup 驱动，
你必须显式声明它的值。
此方法应对的场景为：在将来某个版本的 kubeadm 中，你不想使用默认的 <code>systemd</code> 驱动。</p>
<p>参阅以下章节“修改 kubelet 的 ConfigMap”，了解显式设置该值的方法。</p>
<p>如果你希望配置容器运行时来使用 <code>cgroupfs</code> 驱动，
则必须参考所选容器运行时的文档。</p>
<h2 id=迁移到-systemd-驱动>迁移到 <code>systemd</code> 驱动</h2>
<p>要将现有 kubeadm 集群的 cgroup 驱动就地升级为 <code>systemd</code>，
需要执行一个与 kubelet 升级类似的过程。
该过程必须包含下面两个步骤：</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 还有一种方法，可以用已配置了 <code>systemd</code> 的新节点替换掉集群中的老节点。
按这种方法，在加入新节点、确保工作负载可以安全迁移到新节点、及至删除旧节点这一系列操作之前，
只需执行以下第一个步骤。
</div>
<h3 id=修改-kubelet-的-configmap>修改 kubelet 的 ConfigMap</h3>
<ul>
<li>
<p>用命令 <code>kubectl get cm -n kube-system | grep kubelet-config</code> 找到 kubelet 的 ConfigMap 名称。</p>
</li>
<li>
<p>运行 <code>kubectl edit cm kubelet-config-x.yy -n kube-system</code> （把 <code>x.yy</code> 替换为 Kubernetes 版本）。</p>
</li>
<li>
<p>修改现有 <code>cgroupDriver</code> 的值，或者新增如下式样的字段：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>cgroupDriver</span>:<span style=color:#bbb> </span>systemd<span style=color:#bbb>
</span></code></pre></div>
<p>该字段必须出现在 ConfigMap 的 <code>kubelet:</code> 小节下。</p>
</li>
</ul>
<h3 id=更新所有节点的-cgroup-驱动>更新所有节点的 cgroup 驱动</h3>
<p>对于集群中的每一个节点：</p>
<ul>
<li>执行命令 <code>kubectl drain &lt;node-name> --ignore-daemonsets</code>，以
<a href=/zh/docs/tasks/administer-cluster/safely-drain-node>腾空节点</a></li>
<li>执行命令 <code>systemctl stop kubelet</code>，以停止 kubelet</li>
<li>停止容器运行时</li>
<li>修改容器运行时 cgroup 驱动为 <code>systemd</code></li>
<li>在文件 <code>/var/lib/kubelet/config.yaml</code> 中添加设置 <code>cgroupDriver: systemd</code></li>
<li>启动容器运行时</li>
<li>执行命令 <code>systemctl start kubelet</code>，以启动 kubelet</li>
<li>执行命令 <code>kubectl uncordon &lt;node-name></code>，以
<a href=/zh/docs/tasks/administer-cluster/safely-drain-node>取消节点隔离</a></li>
</ul>
<p>在节点上依次执行上述步骤，确保工作负载有充足的时间被调度到其他节点。</p>
<p>流程完成后，确认所有节点和工作负载均健康如常。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-98530eb3653d28fef34bff4543364aa7>3.2.3 - 重新配置 kubeadm 集群</h1>
<p>kubeadm 不支持自动重新配置部署在托管节点上的组件的方式。
一种自动化的方法是使用自定义的
<a href=/zh/docs/concepts/extend-kubernetes/operator/>operator</a>。</p>
<p>要修改组件配置，你必须手动编辑磁盘上关联的集群对象和文件。
本指南展示了实现 kubeadm 集群重新配置所需执行的正确步骤顺序。</p>
<h2 id=before-you-begin>Before you begin</h2>
<ul>
<li>你需要一个使用 kubeadm 部署的集群</li>
<li>拥有管理员凭据（<code>/etc/kubernetes/admin.conf</code>）
和从安装了 kubectl 的主机到集群中正在运行的 kube-apiserver 的网络连接</li>
<li>在所有主机上安装文本编辑器</li>
</ul>
<h2 id=重新配置集群>重新配置集群</h2>
<p>kubeadm 在 ConfigMap 和其他对象中写入了一组集群范围的组件配置选项。
这些对象必须手动编辑，可以使用命令 <code>kubectl edit</code>。</p>
<p><code>kubectl edit</code> 命令将打开一个文本编辑器，你可以在其中直接编辑和保存对象。
你可以使用环境变量 <code>KUBECONFIG</code> 和 <code>KUBE_EDITOR</code> 来指定 kubectl
使用的 kubeconfig 文件和首选文本编辑器的位置。</p>
<p>例如：</p>
<pre><code>KUBECONFIG=/etc/kubernetes/admin.conf KUBE_EDITOR=nano kubectl edit &lt;parameters&gt;
</code></pre><div class="alert alert-info note callout" role=alert>
<strong>Note:</strong>
<p>保存对这些集群对象的任何更改后，节点上运行的组件可能不会自动更新。
以下步骤将指导你如何手动执行该操作。
</div>
<div class="alert alert-danger warning callout" role=alert>
<strong>Warning:</strong>
<p>ConfigMaps 中的组件配置存储为非结构化数据（YAML 字符串）。 这意味着在更新
ConfigMap 的内容时不会执行验证。 你必须小心遵循特定组件配置的文档化 API 格式，
并避免引入拼写错误和 YAML 缩进错误。
</div>
<h3 id=应用集群配置更改>应用集群配置更改</h3>
<h4 id=更新-clusterconfiguration>更新 <code>ClusterConfiguration</code></h4>
<p>在集群创建和升级期间，kubeadm 将其
<a href=/zh/docs/reference/config-api/kubeadm-config.v1beta3/><code>ClusterConfiguration</code></a>
写入 <code>kube-system</code> 命名空间中名为 <code>kubeadm-config</code> 的 ConfigMap。</p>
<p>要更改 <code>ClusterConfiguration</code> 中的特定选项，你可以使用以下命令编辑 ConfigMap：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl edit cm -n kube-system kubeadm-config
</code></pre></div><p>配置位于 <code>data.ClusterConfiguration</code> 键下。</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong>
<p><code>ClusterConfiguration</code> 包括各种影响单个组件配置的选项， 例如
kube-apiserver、kube-scheduler、kube-controller-manager、
CoreDNS、etcd 和 kube-proxy。 对配置的更改必须手动反映在节点组件上。
</div>
<h4 id=在控制平面节点上反映-clusterconfiguration-更改>在控制平面节点上反映 <code>ClusterConfiguration</code> 更改</h4>
<p>kubeadm 将控制平面组件作为位于 <code>/etc/kubernetes/manifests</code>
目录中的静态 Pod 清单进行管理。
对 <code>apiServer</code>、<code>controllerManager</code>、<code>scheduler</code> 或 <code>etcd</code>键下的
<code>ClusterConfiguration</code> 的任何更改都必须反映在控制平面节点上清单目录中的关联文件中。</p>
<p>此类更改可能包括:</p>
<ul>
<li><code>extraArgs</code> - 需要更新传递给组件容器的标志列表</li>
<li><code>extraMounts</code> - 需要更新组件容器的卷挂载</li>
<li><code>*SANs</code> - 需要使用更新的主题备用名称编写新证书</li>
</ul>
<p>在继续进行这些更改之前，请确保你已备份目录 <code>/etc/kubernetes/</code>。</p>
<p>要编写新证书，你可以使用：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubeadm init phase certs &lt;component-name&gt; --config &lt;config-file&gt;
</code></pre></div><p>要在 <code>/etc/kubernetes/manifests</code> 中编写新的清单文件，你可以使用：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubeadm init phase control-plane &lt;component-name&gt; --config &lt;config-file&gt;
</code></pre></div>
<p><code>&lt;config-file></code> 内容必须与更新后的 <code>ClusterConfiguration</code> 匹配。
<code>&lt;component-name></code> 值必须是组件的名称。</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong>
<p>更新 <code>/etc/kubernetes/manifests</code> 中的文件将告诉 kubelet 重新启动相应组件的静态 Pod。
尝试一次对一个节点进行这些更改，以在不停机的情况下离开集群。
</div>
<h3 id=应用-kubelet-配置更改>应用 kubelet 配置更改</h3>
<h4 id=更新-kubeletconfiguration>更新 <code>KubeletConfiguration</code></h4>
<p>在集群创建和升级期间，kubeadm 将其
<a href=/zh/docs/reference/config-api/kubelet-config.v1beta1/><code>KubeletConfiguration</code></a>
写入 <code>kube-system</code> 命名空间中名为 <code>kubelet-config</code> 的 ConfigMap。
你可以使用以下命令编辑 ConfigMap：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl edit cm -n kube-system kubelet-config
</code></pre></div><p>配置位于 <code>data.kubelet</code> 键下。</p>
<h4 id=反映-kubelet-的更改>反映 kubelet 的更改</h4>
<p>要反映 kubeadm 节点上的更改，你必须执行以下操作：</p>
<ul>
<li>登录到 kubeadm 节点</li>
<li>运行 <code>kubeadm upgrade node phase kubelet-config</code> 下载最新的
<code>kubelet-config</code> ConfigMap 内容到本地文件 <code>/var/lib/kubelet/config.conf</code></li>
<li>编辑文件 <code>/var/lib/kubelet/kubeadm-flags.env</code> 以使用标志来应用额外的配置</li>
<li>使用 <code>systemctl restart kubelet</code> 重启 kubelet 服务</li>
</ul>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong>
<p>一次执行一个节点的这些更改，以允许正确地重新安排工作负载。
</div>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong>
<p>在 <code>kubeadm upgrade</code> 期间，kubeadm 从 <code>kubelet-config</code> ConfigMap
下载 <code>KubeletConfiguration</code> 并覆盖 <code>/var/lib/kubelet/config.conf</code> 的内容。
这意味着节点本地配置必须通过<code>/var/lib/kubelet/kubeadm-flags.env</code>中的标志或在
kubeadm upgrade<code> 后手动更新</code>/var/lib/kubelet/config.conf`的内容来应用，然后重新启动 kubelet。
</div>
<h3 id=应用-kube-proxy-配置更改>应用 kube-proxy 配置更改</h3>
<h4 id=更新-kubeproxyconfiguration>更新 <code>KubeProxyConfiguration</code></h4>
<p>在集群创建和升级期间，kubeadm 将其写入
<a href=/zh/docs/reference/config-api/kube-proxy-config.v1alpha1/><code>KubeProxyConfiguration</code></a>
在名为 <code>kube-proxy</code> 的 <code>kube-system</code> 命名空间中的 ConfigMap 中。</p>
<p>此 ConfigMap 由 <code>kube-system</code> 命名空间中的 <code>kube-proxy</code> DaemonSet 使用。</p>
<p>要更改 <code>KubeProxyConfiguration</code> 中的特定选项，你可以使用以下命令编辑 ConfigMap：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl edit cm -n kube-system kube-proxy
</code></pre></div><p>配置位于 <code>data.config.conf</code> 键下。</p>
<h4 id=反映-kube-proxy-的更改>反映 kube-proxy 的更改</h4>
<p>更新 <code>kube-proxy</code> ConfigMap 后，你可以重新启动所有 kube-proxy Pod：</p>
<p>获取 Pod 名称：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get po -n kube-system | grep kube-proxy
</code></pre></div><p>使用以下命令删除 Pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete po -n kube-system &lt;pod-name&gt;
</code></pre></div><p>将创建使用更新的 ConfigMap 的新 Pod。</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong>
<p>由于 kubeadm 将 kube-proxy 部署为 DaemonSet，因此不支持特定于节点的配置。
</div>
<h3 id=应用-coredns-配置更改>应用 CoreDNS 配置更改</h3>
<h4 id=更新-coredns-的-deployment-和-service>更新 CoreDNS 的 Deployment 和 Service</h4>
<p>kubeadm 将 CoreDNS 部署为名为 <code>coredns</code> 的 Deployment，并使用 Service <code>kube-dns</code>，
两者都在 <code>kube-system</code> 命名空间中。</p>
<p>要更新任何 CoreDNS 设置，你可以编辑 Deployment 和 Service：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl edit deployment -n kube-system coredns
kubectl edit service -n kube-system kube-dns
</code></pre></div>
<h4 id=反映-coredns-的更改>反映 CoreDNS 的更改</h4>
<p>应用 CoreDNS 更改后，你可以删除 CoreDNS Pod。</p>
<p>获取 Pod 名称：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get po -n kube-system | grep coredns
</code></pre></div><p>使用以下命令删除 Pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete po -n kube-system &lt;pod-name&gt;
</code></pre></div>
<p>将创建具有更新的 CoreDNS 配置的新 Pod。</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong>
<p>kubeadm 不允许在集群创建和升级期间配置 CoreDNS。
这意味着如果执行了 <code>kubeadm upgrade apply</code>，你对
CoreDNS 对象的更改将丢失并且必须重新应用。
</div>
<h2 id=持久化重新配置>持久化重新配置</h2>
<p>在受管节点上执行 <code>kubeadm upgrade</code> 期间，kubeadm
可能会覆盖在创建集群（重新配置）后应用的配置。</p>
<h3 id=持久化-node-对象重新配置>持久化 Node 对象重新配置</h3>
<p>kubeadm 在特定 Kubernetes 节点的 Node 对象上写入标签、污点、CRI
套接字和其他信息。要更改此 Node 对象的任何内容，你可以使用：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl edit no &lt;node-name&gt;
</code></pre></div>
<p>在 <code>kubeadm upgrade</code> 期间，此类节点的内容可能会被覆盖。
如果你想在升级后保留对 Node 对象的修改，你可以准备一个
<a href=/zh/docs/tasks/manage-kubernetes-objects/update-api-object-kubectl-patch/>kubectl patch</a>
并将其应用到 Node 对象：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl patch no &lt;node-name&gt; --patch-file &lt;patch-file&gt;
</code></pre></div>
<h4 id=持久化控制平面组件重新配置>持久化控制平面组件重新配置</h4>
<p>控制平面配置的主要来源是存储在集群中的 <code>ClusterConfiguration</code> 对象。
要扩展静态 Pod 清单配置，可以使用
<a href=/zh/docs/setup/production-environment/tools/kubeadm/control-plane-flags/#patches>patches</a>。</p>
<p>这些补丁文件必须作为文件保留在控制平面节点上，以确保它们可以被
<code>kubeadm upgrade ... --patches &lt;directory></code> 使用。</p>
<p>如果对 <code>ClusterConfiguration</code> 和磁盘上的静态 Pod 清单进行了重新配置，则必须相应地更新节点特定补丁集。</p>
<h4 id=持久化-kubelet-重新配置>持久化 kubelet 重新配置</h4>
<p>对存储在 <code>/var/lib/kubelet/config.conf</code> 中的 <code>KubeletConfiguration</code>
所做的任何更改都将在 <code>kubeadm upgrade</code> 时因为下载集群范围内的 <code>kubelet-config</code>
ConfigMap 的内容而被覆盖。
要持久保存 kubelet 节点特定的配置，文件<code>/var/lib/kubelet/config.conf</code>
必须在升级后手动更新，或者文件<code>/var/lib/kubelet/kubeadm-flags.env</code> 可以包含标志。
kubelet 标志会覆盖相关的 <code>KubeletConfiguration</code> 选项，但请注意，有些标志已被弃用。</p>
<p>更改 <code>/var/lib/kubelet/config.conf</code> 或 <code>/var/lib/kubelet/kubeadm-flags.env</code>
后需要重启 kubelet。</p>
<p>What's next</p>
<ul>
<li><a href=/zh/docs/tasks/administer-cluster/kubeadm/kubeadm-upgrade>升级 kubeadm 集群</a></li>
<li><a href=/zh/docs/setup/production-environment/tools/kubeadm/control-plane-flags>使用 kubeadm API 自定义组件</a></li>
<li><a href=/zh/docs/tasks/administer-cluster/kubeadm/kubeadm-certs>使用 kubeadm 管理证书</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-2e173356df5179cab9eec90a606f0aa4>3.2.4 - 升级 kubeadm 集群</h1>
<p>本页介绍如何将 <code>kubeadm</code> 创建的 Kubernetes 集群从 1.22.x 版本
升级到 1.23.x 版本以及从 1.23.x
升级到 1.23.y（其中 <code>y > x</code>）。略过次版本号的升级是
不被支持的。更多详情请访问<a href=https://kubernetes.io/releases/version-skew-policy/>版本倾斜政策</a>。</p>
<p>要查看 kubeadm 创建的有关旧版本集群升级的信息，请参考以下页面：</p>
<ul>
<li><a href=https://v1-22.docs.kubernetes.io/docs/tasks/administer-cluster/kubeadm/kubeadm-upgrade/>将 kubeadm 集群从 1.21 升级到 1.22</a></li>
<li><a href=https://v1-21.docs.kubernetes.io/docs/tasks/administer-cluster/kubeadm/kubeadm-upgrade/>将 kubeadm 集群从 1.20 升级到 1.21</a></li>
<li><a href=https://v1-20.docs.kubernetes.io/docs/tasks/administer-cluster/kubeadm/kubeadm-upgrade/>将 kubeadm 集群从 1.19 升级到 1.20</a></li>
<li><a href=https://v1-19.docs.kubernetes.io/docs/tasks/administer-cluster/kubeadm/kubeadm-upgrade/>将 kubeadm 集群从 1.18 升级到 1.19</a></li>
</ul>
<p>升级工作的基本流程如下：</p>
<ol>
<li>升级主控制平面节点</li>
<li>升级其他控制平面节点</li>
<li>升级工作节点</li>
</ol>
<h2 id=before-you-begin>Before you begin</h2>
<ul>
<li>务必仔细认真阅读<a href=https://git.k8s.io/kubernetes/CHANGELOG/CHANGELOG-1.27.md>发行说明</a>。</li>
<li>集群应使用静态的控制平面和 etcd Pod 或者外部 etcd。</li>
<li>务必备份所有重要组件，例如存储在数据库中应用层面的状态。
<code>kubeadm upgrade</code> 不会影响你的工作负载，只会涉及 Kubernetes 内部的组件，但备份终究是好的。</li>
<li><a href=https://serverfault.com/questions/684771/best-way-to-disable-swap-in-linux>必须禁用交换分区</a>。</li>
</ul>
<h3 id=附加信息>附加信息</h3>
<ul>
<li>下述说明了在升级过程中何时腾空每个节点。如果你正在对任何 kubelet 进行小版本升级，
你需要先腾空待升级的节点（或多个节点）。对于控制面节点，其上可能运行着 CoreDNS Pods
或者其它非常重要的负载。更多信息见<a href=/zh/docs/tasks/administer-cluster/safely-drain-node/>腾空节点</a>。</li>
<li>升级后，因为容器规约的哈希值已更改，所有容器都会被重新启动。</li>
</ul>
<ul>
<li>要验证 kubelet 服务在升级后是否成功重启，可以执行 <code>systemctl status kubelet</code>
或 <code>journalctl -xeu kubelet</code> 查看服务日志。</li>
<li>不建议使用 <code>kubeadm upgrade</code> 的 `--config 参数和 <a href=/zh/docs/reference/config-api/kubeadm-config.v1beta3>kubeadm 配置 API 类型</a>
来重新配置集群，这样会产生意想不到的结果。请按照<a href=/zh/docs/tasks/administer-cluster/kubeadm/kubeadm-reconfigure>重新配置 kubeadm 集群</a>
中的步骤来进行。</li>
</ul>
<h2 id=确定要升级到哪个版本>确定要升级到哪个版本</h2>
<p>使用操作系统的包管理器找到最新的补丁版本 Kubernetes 1.23：</p>
<ul class="nav nav-tabs" id=k8s-install-versions role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#k8s-install-versions-0 role=tab aria-controls=k8s-install-versions-0 aria-selected=true>Ubuntu、Debian 或 HypriotOS</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#k8s-install-versions-1 role=tab aria-controls=k8s-install-versions-1>CentOS、RHEL 或 Fedora</a></li></ul>
<div class=tab-content id=k8s-install-versions><div id=k8s-install-versions-0 class="tab-pane show active" role=tabpanel aria-labelledby=k8s-install-versions-0>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>apt update
apt-cache madison kubeadm
<span style=color:#080;font-style:italic># 在列表中查找最新的 1.23 版本</span>
<span style=color:#080;font-style:italic># 它看起来应该是 1.23.x-00，其中 x 是最新的补丁版本</span>
</code></pre></div></div>
<div id=k8s-install-versions-1 class=tab-pane role=tabpanel aria-labelledby=k8s-install-versions-1>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>yum list --showduplicates kubeadm --disableexcludes<span style=color:#666>=</span>kubernetes
<span style=color:#080;font-style:italic># 在列表中查找最新的 1.23 版本</span>
<span style=color:#080;font-style:italic># 它看起来应该是 1.23.x-0，其中 x 是最新的补丁版本</span>
</code></pre></div></div></div>
<h2 id=升级控制平面节点>升级控制平面节点</h2>
<p>控制面节点上的升级过程应该每次处理一个节点。
首先选择一个要先行升级的控制面节点。该节点上必须拥有
<code>/etc/kubernetes/admin.conf</code> 文件。</p>
<h3 id=执行-kubeadm-upgrade>执行 "kubeadm upgrade"</h3>
<p><strong>升级第一个控制面节点</strong></p>
<ul>
<li>升级 kubeadm：</li>
</ul>
<p><ul class="nav nav-tabs" id=k8s-install-kubeadm-first-cp role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#k8s-install-kubeadm-first-cp-0 role=tab aria-controls=k8s-install-kubeadm-first-cp-0 aria-selected=true>Ubuntu、Debian 或 HypriotOS</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#k8s-install-kubeadm-first-cp-1 role=tab aria-controls=k8s-install-kubeadm-first-cp-1>CentOS、RHEL 或 Fedora</a></li></ul>
<div class=tab-content id=k8s-install-kubeadm-first-cp><div id=k8s-install-kubeadm-first-cp-0 class="tab-pane show active" role=tabpanel aria-labelledby=k8s-install-kubeadm-first-cp-0>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># 用最新的补丁版本号替换 1.23.x-00 中的 x</span>
apt-mark unhold kubeadm <span style=color:#666>&amp;&amp;</span> <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>apt-get update <span style=color:#666>&amp;&amp;</span> apt-get install -y <span style=color:#b8860b>kubeadm</span><span style=color:#666>=</span>1.23.x-00 <span style=color:#666>&amp;&amp;</span> <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>apt-mark hold kubeadm
-

</code></pre></div></div>
<div id=k8s-install-kubeadm-first-cp-1 class=tab-pane role=tabpanel aria-labelledby=k8s-install-kubeadm-first-cp-1>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># 用最新的补丁版本号替换 1.23.x-0 中的 x</span>
yum install -y kubeadm-1.23.x-0 --disableexcludes<span style=color:#666>=</span>kubernetes
</code></pre></div></div></div>
<br></p>
<ul>
<li>
<p>验证下载操作正常，并且 kubeadm 版本正确：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubeadm version
</code></pre></div></li>
</ul>
<ul>
<li>
<p>验证升级计划：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubeadm upgrade plan
</code></pre></div>
<p>此命令检查你的集群是否可被升级，并取回你要升级的目标版本。
命令也会显示一个包含组件配置版本状态的表格。</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong>
<p><code>kubeadm upgrade</code> 也会自动对 kubeadm 在节点上所管理的证书执行续约操作。
如果需要略过证书续约操作，可以使用标志 <code>--certificate-renewal=false</code>。
更多的信息，可参阅<a href=/zh/docs/tasks/administer-cluster/kubeadm/kubeadm-certs>证书管理指南</a>。
</div>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong>
<p>如果 <code>kubeadm upgrade plan</code> 给出任何需要手动升级的组件配置，用户必须
通过 <code>--config</code> 命令行标志向 <code>kubeadm upgrade apply</code> 命令提供替代的配置文件。
如果不这样做，<code>kubeadm upgrade apply</code> 会出错并退出，不再执行升级操作。
</div>
</li>
</ul>
<p>选择要升级到的目标版本，运行合适的命令。例如：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># 将 x 替换为你为此次升级所选择的补丁版本号</span>
sudo kubeadm upgrade apply v1.23.x
</code></pre></div>
<p>一旦该命令结束，你应该会看到：</p>
<pre><code class=language-console data-lang=console>[upgrade/successful] SUCCESS! Your cluster was upgraded to &quot;v1.23.x&quot;. Enjoy!

[upgrade/kubelet] Now that your control plane is upgraded, please proceed with upgrading your kubelets if you haven't already done so.
</code></pre>
<ul>
<li>
<p>手动升级你的 CNI 驱动插件。</p>
<p>你的容器网络接口（CNI）驱动应该提供了程序自身的升级说明。
参阅<a href=/zh/docs/concepts/cluster-administration/addons/>插件</a>页面查找你的 CNI 驱动，
并查看是否需要其他升级步骤。</p>
<p>如果 CNI 驱动作为 DaemonSet 运行，则在其他控制平面节点上不需要此步骤。</p>
</li>
</ul>
<p><strong>对于其它控制面节点</strong></p>
<p>与第一个控制面节点相同，但是使用：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>sudo kubeadm upgrade node
</code></pre></div>
<p>而不是：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>sudo kubeadm upgrade apply
</code></pre></div>
<p>此外，不需要执行 <code>kubeadm upgrade plan</code> 和更新 CNI 驱动插件的操作。</p>
<h3 id=腾空节点>腾空节点</h3>
<ul>
<li>
<p>通过将节点标记为不可调度并腾空节点为节点作升级准备：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># 将 &lt;node-to-drain&gt; 替换为你要腾空的控制面节点名称</span>
kubectl drain &lt;node-to-drain&gt; --ignore-daemonsets
</code></pre></div></li>
</ul>
<h3 id=升级-kubelet-和-kubectl>升级 kubelet 和 kubectl</h3>
<ul>
<li>
<p>升级 kubelet 和 kubectl：</p>
<p><ul class="nav nav-tabs" id=k8s-install-kubelet role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#k8s-install-kubelet-0 role=tab aria-controls=k8s-install-kubelet-0 aria-selected=true>Ubuntu、Debian 或 HypriotOS</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#k8s-install-kubelet-1 role=tab aria-controls=k8s-install-kubelet-1>CentOS、RHEL 或 Fedora</a></li></ul>
<div class=tab-content id=k8s-install-kubelet><div id=k8s-install-kubelet-0 class="tab-pane show active" role=tabpanel aria-labelledby=k8s-install-kubelet-0>
<p><pre><code>```shell
# 用最新的补丁版本替换 1.23.x-00 中的 x
apt-mark unhold kubelet kubectl &amp;&amp; \
apt-get update &amp;&amp; apt-get install -y kubelet=1.23.x-00 kubectl=1.23.x-00 &amp;&amp; \
apt-mark hold kubelet kubectl
```
</code></pre>
</div>
<div id=k8s-install-kubelet-1 class=tab-pane role=tabpanel aria-labelledby=k8s-install-kubelet-1>
<p><pre><code>```shell
# 用最新的补丁版本号替换 1.23.x-00 中的 x
yum install -y kubelet-1.23.x-0 kubectl-1.23.x-0 --disableexcludes=kubernetes
```
</code></pre>
</div></div>
<br></p>
</li>
</ul>
<ul>
<li>
<p>重启 kubelet</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>sudo systemctl daemon-reload
sudo systemctl restart kubelet
</code></pre></div></li>
</ul>
<h3 id=解除节点的保护>解除节点的保护</h3>
<ul>
<li>
<p>通过将节点标记为可调度，让其重新上线：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># 将 &lt;node-to-drain&gt; 替换为你的节点名称</span>
kubectl uncordon &lt;node-to-drain&gt;
</code></pre></div></li>
</ul>
<h2 id=升级工作节点>升级工作节点</h2>
<p>工作节点上的升级过程应该一次执行一个节点，或者一次执行几个节点，
以不影响运行工作负载所需的最小容量。</p>
<h3 id=升级-kubeadm>升级 kubeadm</h3>
<ul>
<li>
<p>升级 kubeadm：</p>
<ul class="nav nav-tabs" id=k8s-install-kubeadm-worker-nodes role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#k8s-install-kubeadm-worker-nodes-0 role=tab aria-controls=k8s-install-kubeadm-worker-nodes-0 aria-selected=true>Ubuntu、Debian 或 HypriotOS</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#k8s-install-kubeadm-worker-nodes-1 role=tab aria-controls=k8s-install-kubeadm-worker-nodes-1>CentOS、RHEL 或 Fedora</a></li></ul>
<div class=tab-content id=k8s-install-kubeadm-worker-nodes><div id=k8s-install-kubeadm-worker-nodes-0 class="tab-pane show active" role=tabpanel aria-labelledby=k8s-install-kubeadm-worker-nodes-0>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># 将 1.23.x-00 中的 x 替换为最新的补丁版本号</span>
apt-mark unhold kubeadm <span style=color:#666>&amp;&amp;</span> <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>apt-get update <span style=color:#666>&amp;&amp;</span> apt-get install -y <span style=color:#b8860b>kubeadm</span><span style=color:#666>=</span>1.23.x-00 <span style=color:#666>&amp;&amp;</span> <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>apt-mark hold kubeadm
</code></pre></div></div>
<div id=k8s-install-kubeadm-worker-nodes-1 class=tab-pane role=tabpanel aria-labelledby=k8s-install-kubeadm-worker-nodes-1>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># 用最新的补丁版本替换 1.23.x-00 中的 x</span>
yum install -y kubeadm-1.23.x-0 --disableexcludes<span style=color:#666>=</span>kubernetes
</code></pre></div></div></div>
</li>
</ul>
<h3 id=执行-kubeadm-upgrade-1>执行 "kubeadm upgrade"</h3>
<ul>
<li>
<p>对于工作节点，下面的命令会升级本地的 kubelet 配置：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>sudo kubeadm upgrade node
</code></pre></div></li>
</ul>
<h3 id=腾空节点-1>腾空节点</h3>
<ul>
<li>
<p>将节点标记为不可调度并驱逐所有负载，准备节点的维护：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># 将 &lt;node-to-drain&gt; 替换为你正在腾空的节点的名称</span>
kubectl drain &lt;node-to-drain&gt; --ignore-daemonsets
</code></pre></div></li>
</ul>
<h3 id=升级-kubelet-和-kubectl-1>升级 kubelet 和 kubectl</h3>
<ul>
<li>
<p>升级 kubelet 和 kubectl：</p>
<ul class="nav nav-tabs" id=k8s-kubelet-and-kubectl role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#k8s-kubelet-and-kubectl-0 role=tab aria-controls=k8s-kubelet-and-kubectl-0 aria-selected=true>Ubuntu、Debian 或 HypriotOS</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#k8s-kubelet-and-kubectl-1 role=tab aria-controls=k8s-kubelet-and-kubectl-1>CentOS, RHEL or Fedora</a></li></ul>
<div class=tab-content id=k8s-kubelet-and-kubectl><div id=k8s-kubelet-and-kubectl-0 class="tab-pane show active" role=tabpanel aria-labelledby=k8s-kubelet-and-kubectl-0>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># 将 1.23.x-00 中的 x 替换为最新的补丁版本</span>
apt-mark unhold kubelet kubectl <span style=color:#666>&amp;&amp;</span> <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>apt-get update <span style=color:#666>&amp;&amp;</span> apt-get install -y <span style=color:#b8860b>kubelet</span><span style=color:#666>=</span>1.23.x-00 <span style=color:#b8860b>kubectl</span><span style=color:#666>=</span>1.23.x-00 <span style=color:#666>&amp;&amp;</span> <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>apt-mark hold kubelet kubectl
</code></pre></div></div>
<div id=k8s-kubelet-and-kubectl-1 class=tab-pane role=tabpanel aria-labelledby=k8s-kubelet-and-kubectl-1>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># 将 1.23.x-0 x 替换为最新的补丁版本</span>
yum install -y kubelet-1.23.x-0 kubectl-1.23.x-0 --disableexcludes<span style=color:#666>=</span>kubernetes
</code></pre></div></div></div>
</li>
</ul>
<ul>
<li>
<p>重启 kubelet</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>sudo systemctl daemon-reload
sudo systemctl restart kubelet
</code></pre></div></li>
</ul>
<h3 id=取消对节点的保护>取消对节点的保护</h3>
<ul>
<li>
<p>通过将节点标记为可调度，让节点重新上线:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># 将 &lt;node-to-drain&gt; 替换为当前节点的名称</span>
kubectl uncordon &lt;node-to-drain&gt;
</code></pre></div></li>
</ul>
<h2 id=验证集群的状态>验证集群的状态</h2>
<p>在所有节点上升级 kubelet 后，通过从 kubectl 可以访问集群的任何位置运行以下命令，
验证所有节点是否再次可用：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get nodes
</code></pre></div>
<p><code>STATUS</code> 应显示所有节点为 <code>Ready</code> 状态，并且版本号已经被更新。</p>
<h2 id=从故障状态恢复>从故障状态恢复</h2>
<p>如果 <code>kubeadm upgrade</code> 失败并且没有回滚，例如由于执行期间节点意外关闭，
你可以再次运行 <code>kubeadm upgrade</code>。
此命令是幂等的，并最终确保实际状态是你声明的期望状态。
要从故障状态恢复，你还可以运行 <code>kubeadm upgrade --force</code> 而无需更改集群正在运行的版本。</p>
<p>在升级期间，kubeadm 向 <code>/etc/kubernetes/tmp</code> 目录下的如下备份文件夹写入数据：</p>
<ul>
<li><code>kubeadm-backup-etcd-&lt;date>-&lt;time></code></li>
<li><code>kubeadm-backup-manifests-&lt;date>-&lt;time></code></li>
</ul>
<p><code>kubeadm-backup-etcd</code> 包含当前控制面节点本地 etcd 成员数据的备份。
如果 etcd 升级失败并且自动回滚也无法修复，则可以将此文件夹中的内容复制到
<code>/var/lib/etcd</code> 进行手工修复。如果使用的是外部的 etcd，则此备份文件夹为空。</p>
<p><code>kubeadm-backup-manifests</code> 包含当前控制面节点的静态 Pod 清单文件的备份版本。
如果升级失败并且无法自动回滚，则此文件夹中的内容可以复制到
<code>/etc/kubernetes/manifests</code> 目录实现手工恢复。
如果由于某些原因，在升级前后某个组件的清单未发生变化，则 kubeadm 也不会为之
生成备份版本。</p>
<h2 id=how-it-works>工作原理 </h2>
<p><code>kubeadm upgrade apply</code> 做了以下工作：</p>
<ul>
<li>检查你的集群是否处于可升级状态:
<ul>
<li>API 服务器是可访问的</li>
<li>所有节点处于 <code>Ready</code> 状态</li>
<li>控制面是健康的</li>
</ul>
</li>
<li>强制执行版本偏差策略。</li>
<li>确保控制面的镜像是可用的或可拉取到服务器上。</li>
<li>如果组件配置要求版本升级，则生成替代配置与/或使用用户提供的覆盖版本配置。</li>
<li>升级控制面组件或回滚（如果其中任何一个组件无法启动）。</li>
<li>应用新的 <code>CoreDNS</code> 和 <code>kube-proxy</code> 清单，并强制创建所有必需的 RBAC 规则。</li>
<li>如果旧文件在 180 天后过期，将创建 API 服务器的新证书和密钥文件并备份旧文件。</li>
</ul>
<p><code>kubeadm upgrade node</code> 在其他控制平节点上执行以下操作：</p>
<ul>
<li>从集群中获取 kubeadm <code>ClusterConfiguration</code>。</li>
<li>（可选操作）备份 kube-apiserver 证书。</li>
<li>升级控制平面组件的静态 Pod 清单。</li>
<li>为本节点升级 kubelet 配置</li>
</ul>
<p><code>kubeadm upgrade node</code> 在工作节点上完成以下工作：</p>
<ul>
<li>从集群取回 kubeadm <code>ClusterConfiguration</code>。</li>
<li>为本节点升级 kubelet 配置。</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-9133578f1e75663bb031e5a377ca896d>3.2.5 - 添加 Windows 节点</h1>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.18 [beta]</code>
</div>
<p>你可以使用 Kubernetes 来混合运行 Linux 和 Windows 节点，这样你就可以
混合使用运行于 Linux 上的 Pod 和运行于 Windows 上的 Pod。
本页面展示如何将 Windows 节点注册到你的集群。</p>
<h2 id=before-you-begin>Before you begin</h2>
Your Kubernetes server must be at or later than version 1.17.
To check the version, enter <code>kubectl version</code>.
<ul>
<li>
<p>获取 <a href=https://www.microsoft.com/en-us/cloud-platform/windows-server-pricing>Windows Server 2019 或更高版本的授权</a>
以便配置托管 Windows 容器的 Windows 节点。
如果你在使用 VXLAN/覆盖（Overlay）联网设施，则你还必须安装 <a href=https://support.microsoft.com/help/4489899>KB4489899</a>。</p>
</li>
<li>
<p>一个利用 kubeadm 创建的基于 Linux 的 Kubernetes 集群；你能访问该集群的控制面
（参见<a href=/zh/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/>使用 kubeadm 创建一个单控制面的集群</a>)。</p>
</li>
</ul>
<h2 id=objectives>Objectives</h2>
<ul>
<li>将一个 Windows 节点注册到集群上</li>
<li>配置网络，以便 Linux 和 Windows 上的 Pod 和 Service 之间能够相互通信。</li>
</ul>
<h2 id=开始行动-向你的集群添加一个-windows-节点>开始行动：向你的集群添加一个 Windows 节点</h2>
<h3 id=networking-configuration>联网配置 </h3>
<p>一旦你有了一个基于 Linux 的 Kubernetes 控制面节点，你就可以为其选择联网方案。
出于简单考虑，本指南展示如何使用 VXLAN 模式的 Flannel。</p>
<h4 id=configuring-flannel>配置 Flannel </h4>
<ol>
<li>
<p>为 Flannel 准备 Kubernetes 的控制面</p>
<p>在我们的集群中，建议对 Kubernetes 的控制面进行少许准备处理。
建议在使用 Flannel 时为 iptables 链启用桥接方式的 IPv4 流处理，
必须在所有 Linux 节点上执行如下命令：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>sudo sysctl net.bridge.bridge-nf-call-iptables<span style=color:#666>=</span><span style=color:#666>1</span>
</code></pre></div></li>
</ol>
<ol start=2>
<li>
<p>下载并配置 Linux 版本的 Flannel</p>
<p>下载最新的 Flannel 清单文件：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>wget https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml
</code></pre></div><p>修改 Flannel 清单中的 <code>net-conf.json</code> 部分，将 VNI 设置为 4096，并将 Port 设置为 4789。
结果看起来像下面这样：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span>net-conf.json:</span> <span>|</span>
    {
      <span style=color:green;font-weight:700>&#34;Network&#34;</span>: <span style=color:#b44>&#34;10.244.0.0/16&#34;</span>,
      <span style=color:green;font-weight:700>&#34;Backend&#34;</span>: {
         <span style=color:green;font-weight:700>&#34;Type&#34;</span>: <span style=color:#b44>&#34;vxlan&#34;</span>,
         <span style=color:green;font-weight:700>&#34;VNI&#34;</span>: <span style=color:#666>4096</span>,
         <span style=color:green;font-weight:700>&#34;Port&#34;</span>: <span style=color:#666>4789</span>
    }
}
</code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 在 Linux 节点上 VNI 必须设置为 4096，端口必须设置为 4789，这样才能令其与 Windows 上的
Flannel 互操作。关于这些字段的详细说明，请参见
<a href=https://github.com/coreos/flannel/blob/master/Documentation/backends.md#vxlan>VXLAN 文档</a>。
</div>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 如要使用 L2Bridge/Host-gateway 模式，则可将 <code>Type</code> 值设置为
<code>"host-gw"</code>，并忽略 <code>VNI</code> 和 <code>Port</code> 的设置。
</div>
</li>
</ol>
<ol start=3>
<li>
<p>应用 Flannel 清单并验证</p>
<p>首先应用 Flannel 配置：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl apply -f kube-flannel.yml
</code></pre></div><p>几分钟之后，如果 Flannel Pod 网络被正确部署，你应该会看到所有 Pods 都处于运行中状态。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl get pods -n kube-system
</code></pre></div><p>输出中应该包含处于运行中状态的 Linux Flannel DaemonSet：</p>
<pre><code>NAMESPACE     NAME                                      READY        STATUS    RESTARTS   AGE
...
kube-system   kube-flannel-ds-54954                     1/1          Running   0          1m
</code></pre></li>
</ol>
<ol start=4>
<li>
<p>添加 Windows Flannel 和 kube-proxy DaemonSet</p>
<p>现在你可以添加 Windows 兼容版本的 Flannel 和 kube-proxy。为了确保你能获得兼容
版本的 kube-proxy，你需要替换镜像中的标签。
下面的例子中展示的是针对 Kubernetes v1.23.17 版本的用法，
不过你应该根据你自己的集群部署调整其中的版本号。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>curl -L https://github.com/kubernetes-sigs/sig-windows-tools/releases/latest/download/kube-proxy.yml | sed <span style=color:#b44>&#39;s/VERSION/v1.23.17/g&#39;</span> | kubectl apply -f -
kubectl apply -f https://github.com/kubernetes-sigs/sig-windows-tools/releases/latest/download/flannel-overlay.yml
</code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 如果你在使用 host-gateway 模式，则应该使用
<a href=https://github.com/kubernetes-sigs/sig-windows-tools/releases/latest/download/flannel-host-gw.yml>https://github.com/kubernetes-sigs/sig-windows-tools/releases/latest/download/flannel-host-gw.yml</a>
这一清单。
</div>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> <p>如果你在 Windows 节点上使用的不是以太网（即，"Ethernet0 2"）接口，你需要
修改 <code>flannel-host-gw.yml</code> 或 <code>flannel-overlay.yml</code> 文件中的下面这行：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell>wins <span style=color:#a2f>cli </span><span style=color:#a2f;font-weight:700>process</span> run --path /k/flannel/setup.exe --args <span style=color:#b44>&#34;--mode=overlay --interface=Ethernet&#34;</span>
</code></pre></div><p>在其中根据情况设置要使用的网络接口。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#080;font-style:italic># Example</span>
curl -L https://github.com/kubernetes-sigs/sig-windows-tools/releases/latest/download/flannel-overlay.yml | sed <span style=color:#b44>&#39;s/Ethernet/Ethernet0 2/g&#39;</span> | kubectl apply -f -
</code></pre></div>
</div>
</li>
</ol>
<h3 id=joining-a-windows-worker-node>加入 Windows 工作节点 </h3>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong>
<p>Windows 节的所有代码片段都需要在 PowerShell 环境中执行，并且要求在
Windows 工作节点上具有提升的权限（Administrator）。
</div>
<ul class="nav nav-tabs" id=tab-windows-kubeadm-runtime-installation role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tab-windows-kubeadm-runtime-installation-0 role=tab aria-controls=tab-windows-kubeadm-runtime-installation-0 aria-selected=true>Docker EE</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tab-windows-kubeadm-runtime-installation-1 role=tab aria-controls=tab-windows-kubeadm-runtime-installation-1>CRI-containerD</a></li></ul>
<div class=tab-content id=tab-windows-kubeadm-runtime-installation><div id=tab-windows-kubeadm-runtime-installation-0 class="tab-pane show active" role=tabpanel aria-labelledby=tab-windows-kubeadm-runtime-installation-0>
<p>
<h4 id=安装-docker-ee>安装 Docker EE</h4>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=color:#a2f>Install-WindowsFeature</span> -Name containers
</code></pre></div>
<p>安装 Docker
操作指南在 <a href="https://docs.microsoft.com/en-us/virtualization/windowscontainers/quick-start/set-up-environment?tabs=Windows-Server#install-docker">Install Docker Engine - Enterprise on Windows Servers</a>。</p>
<h4 id=安装-wins-kubelet-和-kubeadm>安装 wins、kubelet 和 kubeadm</h4>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-PowerShell data-lang=PowerShell>curl.exe -LO https<span>:</span>//raw.githubusercontent.com/<span style=color:#a2f>kubernetes-sigs</span>/<span style=color:#a2f>sig-windows</span>-tools/master/kubeadm/scripts/PrepareNode.ps1
.\PrepareNode.ps1 -KubernetesVersion v1.23.17
</code></pre></div>
<h4 id=运行-kubeadm-添加节点>运行 <code>kubeadm</code> 添加节点</h4>
<p>当你在控制面主机上运行 <code>kubeadm init</code> 时，输出了一个命令。现在运行这个命令。
如果你找不到这个命令，或者命令中对应的令牌已经过期，你可以（在一个控制面主机上）运行
<code>kubeadm token create --print-join-command</code> 来生成新的令牌和 join 命令。</p>
</div>
<div id=tab-windows-kubeadm-runtime-installation-1 class=tab-pane role=tabpanel aria-labelledby=tab-windows-kubeadm-runtime-installation-1>
<p>
<h4 id=安装-containerd>安装 containerD</h4>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell>curl.exe -LO https<span>:</span>//github.com/<span style=color:#a2f>kubernetes-sigs</span>/<span style=color:#a2f>sig-windows</span>-tools/releases/latest/download/<span style=color:#a2f>Install-Containerd</span>.ps1
.\<span style=color:#a2f>Install-Containerd</span>.ps1
</code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>Note:</strong>
<p>要安装特定版本的 containerD，使用参数 -ContainerDVersion指定版本。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=color:#080;font-style:italic># Example</span>
.\<span style=color:#a2f>Install-Containerd</span>.ps1 -ContainerDVersion 1.4.1
</code></pre></div>
</div>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong>
<p>如果你在 Windows 节点上使用了与 Ethernet 不同的接口（例如 "Ethernet0 2"），使用参数 <code>-netAdapterName</code> 指定名称。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=color:#080;font-style:italic># Example</span>
.\<span style=color:#a2f>Install-Containerd</span>.ps1 -netAdapterName <span style=color:#b44>&#34;Ethernet0 2&#34;</span>
</code></pre></div>
</div>
<h4 id=安装-wins-kubelet-和-kubeadm>安装 wins，kubelet 和 kubeadm</h4>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-PowerShell data-lang=PowerShell>curl.exe -LO https<span>:</span>//raw.githubusercontent.com/<span style=color:#a2f>kubernetes-sigs</span>/<span style=color:#a2f>sig-windows</span>-tools/master/kubeadm/scripts/PrepareNode.ps1
.\PrepareNode.ps1 -KubernetesVersion v1.23.17 -ContainerRuntime containerD
</code></pre></div>
<h4 id=运行-kubeadm-添加节点>运行 <code>kubeadm</code> 添加节点</h4>
<p>使用当你在控制面主机上运行 <code>kubeadm init</code> 时得到的命令。
如果你找不到这个命令，或者命令中对应的令牌已经过期，你可以（在一个控制面主机上）运行
<code>kubeadm token create --print-join-command</code> 来生成新的令牌和 join 命令。</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> If using <strong>CRI-containerD</strong> add <code>--cri-socket "npipe:////./pipe/containerd-containerd"</code> to the kubeadm call
</div>
</div></div>
<h4 id=verifying-your-installation>检查你的安装 </h4>
<p>你现在应该能够通过运行下面的命令来查看集群中的 Windows 节点了：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl get nodes -o wide
</code></pre></div>
<p>如果你的新节点处于 <code>NotReady</code> 状态，很可能的原因是系统仍在下载 Flannel 镜像。
你可以像之前一样，通过检查 <code>kube-system</code> 名字空间中的 Flannel Pods 来了解
安装进度。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl -n kube-system get pods -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>flannel
</code></pre></div>
<p>一旦 Flannel Pod 运行起来，你的节点就应该能进入 <code>Ready</code> 状态并可
用来处理负载。</p>
<h2 id=what-s-next>What's next</h2>
<ul>
<li><a href=/zh/docs/tasks/administer-cluster/kubeadm/upgrading-windows-nodes>升级 kubeadm 安装的 Windows 节点</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-e805c7d8d4ad6195cb82dbbc843bfc29>3.2.6 - 升级 Windows 节点</h1>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.18 [beta]</code>
</div>
<p>本页解释如何升级<a href=/zh/docs/tasks/administer-cluster/kubeadm/adding-windows-nodes>用 kubeadm 创建的</a>
Windows 节点。</p>
<h2 id=before-you-begin>Before you begin</h2>
<p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li>
</ul>
Your Kubernetes server must be at or later than version 1.17.
To check the version, enter <code>kubectl version</code>.
</p>
<ul>
<li>熟悉<a href=/zh/docs/tasks/administer-cluster/kubeadm/kubeadm-upgrade>更新 kubeadm 集群中的其余组件</a>。
在升级你的 Windows 节点之前你会想要升级控制面节点。</li>
</ul>
<h2 id=upgrading-worker-nodes>升级工作节点 </h2>
<h3 id=upgrade-kubeadm>升级 kubeadm </h3>
<ol>
<li>
<p>在 Windows 节点上升级 kubeadm：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=color:#080;font-style:italic># 将 v1.23.17 替换为你希望的版本</span>
curl.exe -Lo C:\k\kubeadm.exe https<span>:</span>//dl.k8s.io/<span style=color:#a2f>/bin/windows/amd64/kubeadm.exe
</code></pre></div></li>
</ol>
<h3 id=drain-the-node>腾空节点 </h3>
<ol>
<li>
<p>在一个能访问到 Kubernetes API 的机器上，将 Windows 节点标记为不可调度并
驱逐其上的所有负载，以便准备节点维护操作：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># 将 &lt;要腾空的节点&gt; 替换为你要腾空的节点的名称</span>
kubectl drain &lt;要腾空的节点&gt; -ignore-daemonsets
</code></pre></div><p>你应该会看到类似下面的输出：</p>
<pre><code>node/ip-172-31-85-18 cordoned
node/ip-172-31-85-18 drained
</code></pre></li>
</ol>
<h3 id=upgrade-the-kubelet-configuration>升级 kubelet 配置 </h3>
<ol>
<li>
<p>在 Windows 节点上，执行下面的命令来同步新的 kubelet 配置：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell>kubeadm upgrade node
</code></pre></div></li>
</ol>
<h3 id=upgrade-kubelet>升级 kubelet </h3>
<ol>
<li>
<p>在 Windows 节点上升级并重启 kubelet：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=color:#a2f>stop-service</span> kubelet
curl.exe -Lo C:\k\kubelet.exe https<span>:</span>//dl.k8s.io/<span style=color:#a2f>/bin/windows/amd64/kubelet.exe
<span style=color:#a2f>restart-service</span> kubelet
</code></pre></div></li>
</ol>
<h3 id=uncordon-the-node>对节点执行 uncordon 操作 </h3>
<ol>
<li>
<p>从一台能够访问到 Kubernetes API 的机器上，通过将节点标记为可调度，使之
重新上线：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># 将 &lt;要腾空的节点&gt; 替换为你的节点名称</span>
kubectl uncordon &lt;要腾空的节点&gt;
</code></pre></div></li>
</ol>
<h3 id=upgrade-kube-proxy>升级 kube-proxy </h3>
<ol>
<li>
<p>在一台可访问 Kubernetes API 的机器上和，将 v1.23.17 替换成你
期望的版本后再次执行下面的命令：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>curl -L https://github.com/kubernetes-sigs/sig-windows-tools/releases/latest/download/kube-proxy.yml | sed <span style=color:#b44>&#39;s/VERSION/v1.23.17/g&#39;</span> | kubectl apply -f -
</code></pre></div></li>
</ol>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-47be5dd51f686017f1766e6ec7aa6f41>3.3 - 管理内存，CPU 和 API 资源</h1>
</div>
<div class=td-content>
<h1 id=pg-337620c76587e4aeb32009cb23be46de>3.3.1 - 为命名空间配置默认的内存请求和限制</h1>
<p>本文介绍怎样给命名空间配置默认的内存请求和限制。
如果在一个有默认内存限制的命名空间创建容器，该容器没有声明自己的内存限制时，
将会被指定默认内存限制。
Kubernetes 还为某些情况指定了默认的内存请求，本章后面会进行介绍。</p>
<h2 id=before-you-begin>Before you begin</h2>
<p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li>
</ul>
To check the version, enter <code>kubectl version</code>.
</p>
<p>你的集群中的每个节点必须至少有 2 GiB 的内存。</p>
<h2 id=创建命名空间>创建命名空间</h2>
<p>创建一个命名空间，以便本练习中所建的资源与集群的其余资源相隔离。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create namespace default-mem-example
</code></pre></div>
<h2 id=创建-limitrange-和-pod>创建 LimitRange 和 Pod</h2>
<p>这里给出了一个限制范围对象的配置文件。该配置声明了一个默认的内存请求和一个默认的内存限制。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/admin/resource/memory-defaults.yaml download=admin/resource/memory-defaults.yaml><code>admin/resource/memory-defaults.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('admin-resource-memory-defaults-yaml')" title="Copy admin/resource/memory-defaults.yaml to clipboard">
</img>
</div>
<div class=includecode id=admin-resource-memory-defaults-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>LimitRange<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mem-limit-range<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>default</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>512Mi<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>defaultRequest</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>256Mi<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Container<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>在 default-mem-example 命名空间创建限制范围：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/admin/resource/memory-defaults.yaml --namespace<span style=color:#666>=</span>default-mem-example
</code></pre></div>
<p>现在，如果在 default-mem-example 命名空间创建容器，并且该容器没有声明自己的内存请求和限制值，
它将被指定默认的内存请求 256 MiB 和默认的内存限制 512 MiB。</p>
<p>下面是具有一个容器的 Pod 的配置文件。
容器未指定内存请求和限制。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/admin/resource/memory-defaults-pod.yaml download=admin/resource/memory-defaults-pod.yaml><code>admin/resource/memory-defaults-pod.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('admin-resource-memory-defaults-pod-yaml')" title="Copy admin/resource/memory-defaults-pod.yaml to clipboard">
</img>
</div>
<div class=includecode id=admin-resource-memory-defaults-pod-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>default-mem-demo<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>default-mem-demo-ctr<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>创建 Pod</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/admin/resource/memory-defaults-pod.yaml --namespace<span style=color:#666>=</span>default-mem-example
</code></pre></div>
<p>查看 Pod 的详情：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod default-mem-demo --output<span style=color:#666>=</span>yaml --namespace<span style=color:#666>=</span>default-mem-example
</code></pre></div>
<p>输出内容显示该 Pod 的容器有 256 MiB 的内存请求和 512 MiB 的内存限制。
这些都是 LimitRange 设置的默认值。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>containers:
- image: nginx
  imagePullPolicy: Always
  name: default-mem-demo-ctr
  resources:
    limits:
      memory: 512Mi
    requests:
      memory: 256Mi
</code></pre></div>
<p>删除你的 Pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete pod default-mem-demo --namespace<span style=color:#666>=</span>default-mem-example
</code></pre></div>
<h2 id=声明容器的限制而不声明它的请求会怎么样>声明容器的限制而不声明它的请求会怎么样？</h2>
<p>这里给出了包含一个容器的 Pod 的配置文件。该容器声明了内存限制，而没有声明内存请求：</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/admin/resource/memory-defaults-pod-2.yaml download=admin/resource/memory-defaults-pod-2.yaml><code>admin/resource/memory-defaults-pod-2.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('admin-resource-memory-defaults-pod-2-yaml')" title="Copy admin/resource/memory-defaults-pod-2.yaml to clipboard">
</img>
</div>
<div class=includecode id=admin-resource-memory-defaults-pod-2-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>default-mem-demo-2<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>default-mem-demo-2-ctr<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;1Gi&#34;</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>创建 Pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/admin/resource/memory-defaults-pod-2.yaml --namespace<span style=color:#666>=</span>default-mem-example
</code></pre></div>
<p>查看 Pod 的详情：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod default-mem-demo-2 --output<span style=color:#666>=</span>yaml --namespace<span style=color:#666>=</span>default-mem-example
</code></pre></div>
<p>输出结果显示容器的内存请求被设置为它的内存限制相同的值。注意该容器没有被指定默认的内存请求值 256MiB。</p>
<pre><code>resources:
  limits:
    memory: 1Gi
  requests:
    memory: 1Gi
</code></pre>
<h2 id=声明容器的内存请求而不声明内存限制会怎么样>声明容器的内存请求而不声明内存限制会怎么样？</h2>
<p>这里给出了一个包含一个容器的 Pod 的配置文件。该容器声明了内存请求，但没有内存限制：</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/admin/resource/memory-defaults-pod-3.yaml download=admin/resource/memory-defaults-pod-3.yaml><code>admin/resource/memory-defaults-pod-3.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('admin-resource-memory-defaults-pod-3-yaml')" title="Copy admin/resource/memory-defaults-pod-3.yaml to clipboard">
</img>
</div>
<div class=includecode id=admin-resource-memory-defaults-pod-3-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>default-mem-demo-3<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>default-mem-demo-3-ctr<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;128Mi&#34;</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>创建 Pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/admin/resource/memory-defaults-pod-3.yaml --namespace<span style=color:#666>=</span>default-mem-example
</code></pre></div>
<p>查看 Pod 声明：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod default-mem-demo-3 --output<span style=color:#666>=</span>yaml --namespace<span style=color:#666>=</span>default-mem-example
</code></pre></div>
<p>输出结果显示该容器的内存请求被设置为了容器配置文件中声明的数值。
容器的内存限制被设置为 512MiB，即命名空间的默认内存限制。</p>
<pre><code>resources:
  limits:
    memory: 512Mi
  requests:
    memory: 128Mi
</code></pre>
<h2 id=设置默认内存限制和请求的动机>设置默认内存限制和请求的动机</h2>
<p>如果你的命名空间有资源配额，那么默认内存限制是很有帮助的。
下面是一个例子，通过资源配额为命名空间设置两项约束：</p>
<ul>
<li>运行在命名空间中的每个容器必须有自己的内存限制。</li>
<li>命名空间中所有容器的内存使用量之和不能超过声明的限制值。</li>
</ul>
<p>如果一个容器没有声明自己的内存限制，会被指定默认限制，然后它才会被允许在限定了配额的命名空间中运行。</p>
<h2 id=清理>清理</h2>
<p>删除你的命名空间：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete namespace default-mem-example
</code></pre></div><h2 id=what-s-next>What's next</h2>
<h3 id=集群管理员参考>集群管理员参考</h3>
<ul>
<li><a href=/zh/docs/tasks/administer-cluster/manage-resources/cpu-default-namespace/>为命名空间配置默认的 CPU 请求和限制</a></li>
<li><a href=/zh/docs/tasks/administer-cluster/manage-resources/memory-constraint-namespace/>为命名空间配置最小和最大内存限制</a></li>
<li><a href=/zh/docs/tasks/administer-cluster/manage-resources/cpu-constraint-namespace/>为命名空间配置最小和最大 CPU 限制</a></li>
<li><a href=/zh/docs/tasks/administer-cluster/manage-resources/quota-memory-cpu-namespace/>为命名空间配置内存和 CPU 配额</a></li>
<li><a href=/zh/docs/tasks/administer-cluster/manage-resources/quota-pod-namespace/>为命名空间配置 Pod 配额</a></li>
<li><a href=/zh/docs/tasks/administer-cluster/quota-api-object/>为 API 对象配置配额</a></li>
</ul>
<h3 id=应用开发者参考>应用开发者参考</h3>
<ul>
<li><a href=/zh/docs/tasks/configure-pod-container/assign-memory-resource/>为容器和 Pod 分配内存资源</a></li>
<li><a href=/zh/docs/tasks/configure-pod-container/assign-cpu-resource/>为容器和 Pod 分配 CPU 资源</a></li>
<li><a href=/zh/docs/tasks/configure-pod-container/quality-service-pod/>为 Pod 配置服务质量</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-320af95e480962c538ebef7ae205845c>3.3.2 - 为命名空间配置默认的 CPU 请求和限制</h1>
<p>本章介绍怎样为命名空间配置默认的 CPU 请求和限制。
一个 Kubernetes 集群可被划分为多个命名空间。如果在配置了 CPU 限制的命名空间创建容器，
并且该容器没有声明自己的 CPU 限制，那么这个容器会被指定默认的 CPU 限制。
Kubernetes 在一些特定情况还会指定 CPU 请求，本文后续章节将会对其进行解释。</p>
<h2 id=before-you-begin>Before you begin</h2>
<p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li>
</ul>
To check the version, enter <code>kubectl version</code>.
</p>
<h2 id=创建命名空间>创建命名空间</h2>
<p>创建一个命名空间，以便本练习中创建的资源和集群的其余部分相隔离。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create namespace default-cpu-example
</code></pre></div>
<h2 id=创建-limitrange-和-pod>创建 LimitRange 和 Pod</h2>
<p>这里给出了 LimitRange 对象的配置文件。该配置声明了一个默认的 CPU 请求和一个默认的 CPU 限制。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/admin/resource/cpu-defaults.yaml download=admin/resource/cpu-defaults.yaml><code>admin/resource/cpu-defaults.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('admin-resource-cpu-defaults-yaml')" title="Copy admin/resource/cpu-defaults.yaml to clipboard">
</img>
</div>
<div class=includecode id=admin-resource-cpu-defaults-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>LimitRange<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cpu-limit-range<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>default</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>defaultRequest</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#666>0.5</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Container<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>在命名空间 default-cpu-example 中创建 LimitRange 对象：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/admin/resource/cpu-defaults.yaml --namespace<span style=color:#666>=</span>default-cpu-example
</code></pre></div>
<p>现在如果在 default-cpu-example 命名空间创建一个容器，该容器没有声明自己的 CPU 请求和限制时，
将会给它指定默认的 CPU 请求0.5和默认的 CPU 限制值1.</p>
<p>这里给出了包含一个容器的 Pod 的配置文件。该容器没有声明 CPU 请求和限制。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/admin/resource/cpu-defaults-pod.yaml download=admin/resource/cpu-defaults-pod.yaml><code>admin/resource/cpu-defaults-pod.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('admin-resource-cpu-defaults-pod-yaml')" title="Copy admin/resource/cpu-defaults-pod.yaml to clipboard">
</img>
</div>
<div class=includecode id=admin-resource-cpu-defaults-pod-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>default-cpu-demo<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>default-cpu-demo-ctr<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>创建 Pod。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/admin/resource/cpu-defaults-pod.yaml --namespace<span style=color:#666>=</span>default-cpu-example
</code></pre></div>
<p>查看该 Pod 的声明：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod default-cpu-demo --output<span style=color:#666>=</span>yaml --namespace<span style=color:#666>=</span>default-cpu-example
</code></pre></div>
<p>输出显示该 Pod 的容器有一个500 millicpus的 CPU 请求和一个1 cpu的 CPU 限制。这些是 LimitRange 声明的默认值。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>containers:
- image: nginx
  imagePullPolicy: Always
  name: default-cpu-demo-ctr
  resources:
    limits:
      cpu: <span style=color:#b44>&#34;1&#34;</span>
    requests:
      cpu: 500m
</code></pre></div>
<h2 id=你只声明容器的限制-而不声明请求会怎么样>你只声明容器的限制，而不声明请求会怎么样？</h2>
<p>这是包含一个容器的 Pod 的配置文件。该容器声明了 CPU 限制，而没有声明 CPU 请求。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/admin/resource/cpu-defaults-pod-2.yaml download=admin/resource/cpu-defaults-pod-2.yaml><code>admin/resource/cpu-defaults-pod-2.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('admin-resource-cpu-defaults-pod-2-yaml')" title="Copy admin/resource/cpu-defaults-pod-2.yaml to clipboard">
</img>
</div>
<div class=includecode id=admin-resource-cpu-defaults-pod-2-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>default-cpu-demo-2<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>default-cpu-demo-2-ctr<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;1&#34;</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>创建 Pod</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/admin/resource/cpu-defaults-pod-2.yaml --namespace<span style=color:#666>=</span>default-cpu-example
</code></pre></div>
<p>查看 Pod 的声明：</p>
<pre><code>kubectl get pod default-cpu-demo-2 --output=yaml --namespace=default-cpu-example
</code></pre>
<p>输出显示该容器的 CPU 请求和 CPU 限制设置相同。注意该容器没有被指定默认的 CPU 请求值0.5 cpu。</p>
<pre><code>resources:
  limits:
    cpu: &quot;1&quot;
  requests:
    cpu: &quot;1&quot;
</code></pre>
<h2 id=你只声明容器的请求-而不声明它的限制会怎么样>你只声明容器的请求，而不声明它的限制会怎么样？</h2>
<p>这里给出了包含一个容器的 Pod 的配置文件。该容器声明了 CPU 请求，而没有声明 CPU 限制。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/admin/resource/cpu-defaults-pod-3.yaml download=admin/resource/cpu-defaults-pod-3.yaml><code>admin/resource/cpu-defaults-pod-3.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('admin-resource-cpu-defaults-pod-3-yaml')" title="Copy admin/resource/cpu-defaults-pod-3.yaml to clipboard">
</img>
</div>
<div class=includecode id=admin-resource-cpu-defaults-pod-3-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>default-cpu-demo-3<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>default-cpu-demo-3-ctr<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;0.75&#34;</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>创建 Pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/admin/resource/cpu-defaults-pod-3.yaml --namespace<span style=color:#666>=</span>default-cpu-example
</code></pre></div>
<p>查看 Pod 的规约：</p>
<pre><code>kubectl get pod default-cpu-demo-3 --output=yaml --namespace=default-cpu-example
</code></pre>
<p>结果显示该容器的 CPU 请求被设置为容器配置文件中声明的数值。
容器的CPU限制被设置为 1 CPU，即该命名空间的默认 CPU 限制值。</p>
<pre><code>resources:
  limits:
    cpu: &quot;1&quot;
  requests:
    cpu: 750m
</code></pre>
<h2 id=默认-cpu-限制和请求的动机>默认 CPU 限制和请求的动机</h2>
<p>如果你的命名空间有一个
<a href=/zh/docs/tasks/administer-cluster/manage-resources/quota-memory-cpu-namespace/>资源配额</a>，
那么有一个默认的 CPU 限制是有帮助的。这里有资源配额强加给命名空间的两条限制：</p>
<ul>
<li>命名空间中运行的每个容器必须有自己的 CPU 限制。</li>
<li>命名空间中所有容器使用的 CPU 总和不能超过一个声明值。</li>
</ul>
<p>如果容器没有声明自己的 CPU 限制，将会给它一个默认限制，这样它就能被允许运行在一个有配额限制的命名空间中。</p>
<h2 id=清理>清理</h2>
<p>删除你的命名空间：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete namespace constraints-cpu-example
</code></pre></div><h2 id=what-s-next>What's next</h2>
<h3 id=集群管理员参考>集群管理员参考</h3>
<ul>
<li><a href=/zh/docs/tasks/administer-cluster/manage-resources/memory-default-namespace/>为命名空间配置默认内存请求和限制</a></li>
<li><a href=/zh/docs/tasks/administer-cluster/manage-resources/memory-constraint-namespace/>为命名空间配置内存限制的最小值和最大值</a></li>
<li><a href=/zh/docs/tasks/administer-cluster/manage-resources/cpu-constraint-namespace/>为命名空间配置 CPU 限制的最小值和最大值</a></li>
<li><a href=/zh/docs/tasks/administer-cluster/manage-resources/quota-memory-cpu-namespace/>为命名空间配置内存和 CPU 配额</a></li>
<li><a href=/zh/docs/tasks/administer-cluster/manage-resources/quota-pod-namespace/>为命名空间配置 Pod 配额</a></li>
<li><a href=/zh/docs/tasks/administer-cluster/quota-api-object/>为 API 对象配置配额</a></li>
</ul>
<h3 id=应用开发者参考>应用开发者参考</h3>
<ul>
<li><a href=/zh/docs/tasks/configure-pod-container/assign-memory-resource/>为容器和 Pod 分配内存资源</a></li>
<li><a href=/zh/docs/tasks/configure-pod-container/assign-cpu-resource/>为容器和 Pod 分配 CPU 资源</a></li>
<li><a href=/zh/docs/tasks/configure-pod-container/quality-service-pod/>为 Pod 配置服务质量</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-adb489b1ab985c9215657b0d4c6ae92b>3.3.3 - 配置命名空间的最小和最大内存约束</h1>
<p>本页介绍如何设置在命名空间中运行的容器使用的内存的最小值和最大值。 你可以在
<a href=/docs/reference/generated/kubernetes-api/v1.23/#limitrange-v1-core>LimitRange</a>
对象中指定最小和最大内存值。如果 Pod 不满足 LimitRange 施加的约束，则无法在命名空间中创建它。</p>
<h2 id=before-you-begin>Before you begin</h2>
<p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li>
</ul>
To check the version, enter <code>kubectl version</code>.
</p>
<p>集群中每个节点必须至少要有 1 GiB 的内存。</p>
<h2 id=创建命名空间>创建命名空间</h2>
<p>创建一个命名空间，以便在此练习中创建的资源与群集的其余资源隔离。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create namespace constraints-mem-example
</code></pre></div>
<h2 id=创建-limitrange-和-pod>创建 LimitRange 和 Pod</h2>
<p>下面是 LimitRange 的配置文件：</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/admin/resource/memory-constraints.yaml download=admin/resource/memory-constraints.yaml><code>admin/resource/memory-constraints.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('admin-resource-memory-constraints-yaml')" title="Copy admin/resource/memory-constraints.yaml to clipboard">
</img>
</div>
<div class=includecode id=admin-resource-memory-constraints-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>LimitRange<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mem-min-max-demo-lr<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>max</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>1Gi<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>min</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>500Mi<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Container<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>创建 LimitRange:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/admin/resource/memory-constraints.yaml --namespace<span style=color:#666>=</span>constraints-mem-example
</code></pre></div>
<p>查看 LimitRange 的详情：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get limitrange mem-min-max-demo-lr --namespace<span style=color:#666>=</span>constraints-mem-example --output<span style=color:#666>=</span>yaml
</code></pre></div>
<p>输出显示预期的最小和最大内存约束。 但请注意，即使你没有在 LimitRange 的配置文件中指定默认值，也会自动创建它们。</p>
<pre><code>  limits:
  - default:
      memory: 1Gi
    defaultRequest:
      memory: 1Gi
    max:
      memory: 1Gi
    min:
      memory: 500Mi
    type: Container
</code></pre>
<p>现在，只要在 constraints-mem-example 命名空间中创建容器，Kubernetes 就会执行下面的步骤：</p>
<ul>
<li>
<p>如果 Container 未指定自己的内存请求和限制，将为它指定默认的内存请求和限制。</p>
</li>
<li>
<p>验证 Container 的内存请求是否大于或等于500 MiB。</p>
</li>
<li>
<p>验证 Container 的内存限制是否小于或等于1 GiB。</p>
</li>
</ul>
<p>这里给出了包含一个 Container 的 Pod 配置文件。Container 声明了 600 MiB 的内存请求和
800 MiB 的内存限制， 这些满足了 LimitRange 施加的最小和最大内存约束。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/admin/resource/memory-constraints-pod.yaml download=admin/resource/memory-constraints-pod.yaml><code>admin/resource/memory-constraints-pod.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('admin-resource-memory-constraints-pod-yaml')" title="Copy admin/resource/memory-constraints-pod.yaml to clipboard">
</img>
</div>
<div class=includecode id=admin-resource-memory-constraints-pod-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>constraints-mem-demo<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>constraints-mem-demo-ctr<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;800Mi&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;600Mi&#34;</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>创建 Pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/admin/resource/memory-constraints-pod.yaml --namespace<span style=color:#666>=</span>constraints-mem-example
</code></pre></div>
<p>确认下 Pod 中的容器在运行：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod constraints-mem-demo --namespace<span style=color:#666>=</span>constraints-mem-example
</code></pre></div>
<p>查看 Pod 详情：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod constraints-mem-demo --output<span style=color:#666>=</span>yaml --namespace<span style=color:#666>=</span>constraints-mem-example
</code></pre></div>
<p>输出结果显示容器的内存请求为600 MiB，内存限制为800 MiB。这些满足了 LimitRange 设定的限制范围。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>800Mi<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>600Mi<span style=color:#bbb>
</span></code></pre></div>
<p>删除你创建的 Pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete pod constraints-mem-demo --namespace<span style=color:#666>=</span>constraints-mem-example
</code></pre></div>
<h2 id=尝试创建一个超过最大内存限制的-pod>尝试创建一个超过最大内存限制的 Pod</h2>
<p>这里给出了包含一个容器的 Pod 的配置文件。容器声明了800 MiB 的内存请求和1.5 GiB 的内存限制。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/admin/resource/memory-constraints-pod-2.yaml download=admin/resource/memory-constraints-pod-2.yaml><code>admin/resource/memory-constraints-pod-2.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('admin-resource-memory-constraints-pod-2-yaml')" title="Copy admin/resource/memory-constraints-pod-2.yaml to clipboard">
</img>
</div>
<div class=includecode id=admin-resource-memory-constraints-pod-2-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>constraints-mem-demo-2<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>constraints-mem-demo-2-ctr<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;1.5Gi&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;800Mi&#34;</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>尝试创建 Pod:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/admin/resource/memory-constraints-pod-2.yaml --namespace<span style=color:#666>=</span>constraints-mem-example
</code></pre></div>
<p>输出结果显示 Pod 没有创建成功，因为容器声明的内存限制太大了：</p>
<pre><code>Error from server (Forbidden): error when creating &quot;examples/admin/resource/memory-constraints-pod-2.yaml&quot;:
pods &quot;constraints-mem-demo-2&quot; is forbidden: maximum memory usage per Container is 1Gi, but limit is 1536Mi.
</code></pre>
<h2 id=尝试创建一个不满足最小内存请求的-pod>尝试创建一个不满足最小内存请求的 Pod</h2>
<p>这里给出了包含一个容器的 Pod 的配置文件。容器声明了100 MiB 的内存请求和800 MiB 的内存限制。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/admin/resource/memory-constraints-pod-3.yaml download=admin/resource/memory-constraints-pod-3.yaml><code>admin/resource/memory-constraints-pod-3.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('admin-resource-memory-constraints-pod-3-yaml')" title="Copy admin/resource/memory-constraints-pod-3.yaml to clipboard">
</img>
</div>
<div class=includecode id=admin-resource-memory-constraints-pod-3-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>constraints-mem-demo-3<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>constraints-mem-demo-3-ctr<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;800Mi&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;100Mi&#34;</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>尝试创建 Pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/admin/resource/memory-constraints-pod-3.yaml --namespace<span style=color:#666>=</span>constraints-mem-example
</code></pre></div>
<p>输出结果显示 Pod 没有创建成功，因为容器声明的内存请求太小了：</p>
<pre><code>Error from server (Forbidden): error when creating &quot;examples/admin/resource/memory-constraints-pod-3.yaml&quot;:
pods &quot;constraints-mem-demo-3&quot; is forbidden: minimum memory usage per Container is 500Mi, but request is 100Mi.
</code></pre>
<h2 id=创建一个没有声明内存请求和限制的-pod>创建一个没有声明内存请求和限制的 Pod</h2>
<p>这里给出了包含一个容器的 Pod 的配置文件。容器没有声明内存请求，也没有声明内存限制。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/admin/resource/memory-constraints-pod-4.yaml download=admin/resource/memory-constraints-pod-4.yaml><code>admin/resource/memory-constraints-pod-4.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('admin-resource-memory-constraints-pod-4-yaml')" title="Copy admin/resource/memory-constraints-pod-4.yaml to clipboard">
</img>
</div>
<div class=includecode id=admin-resource-memory-constraints-pod-4-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>constraints-mem-demo-4<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>constraints-mem-demo-4-ctr<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>创建 Pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/admin/resource/memory-constraints-pod-4.yaml --namespace<span style=color:#666>=</span>constraints-mem-example
</code></pre></div>
<p>查看 Pod 详情：</p>
<pre><code>kubectl get pod constraints-mem-demo-4 --namespace=constraints-mem-example --output=yaml
</code></pre>
<p>输出结果显示 Pod 的内存请求为1 GiB，内存限制为1 GiB。容器怎样获得哪些数值呢？</p>
<pre><code>resources:
  limits:
    memory: 1Gi
  requests:
    memory: 1Gi
</code></pre>
<p>因为你的容器没有声明自己的内存请求和限制，它从 LimitRange 那里获得了
<a href=/zh/docs/tasks/administer-cluster/manage-resources/memory-default-namespace/>默认的内存请求和限制</a>。</p>
<p>此时，你的容器可能运行起来也可能没有运行起来。
回想一下我们本次任务的先决条件是你的每个节点都至少有1 GiB 的内存。
如果你的每个节点都只有1 GiB 的内存，那将没有一个节点拥有足够的可分配内存来满足1 GiB 的内存请求。</p>
<p>删除你的 Pod：</p>
<pre><code>kubectl delete pod constraints-mem-demo-4 --namespace=constraints-mem-example
</code></pre>
<h2 id=强制执行内存最小和最大限制>强制执行内存最小和最大限制</h2>
<p>LimitRange 为命名空间设定的最小和最大内存限制只有在 Pod 创建和更新时才会强制执行。
如果你更新 LimitRange，它不会影响此前创建的 Pod。</p>
<h2 id=设置内存最小和最大限制的动因>设置内存最小和最大限制的动因</h2>
<p>作为集群管理员，你可能想规定 Pod 可以使用的内存总量限制。例如：</p>
<ul>
<li>集群的每个节点有 2 GB 内存。你不想接受任何请求超过 2 GB 的 Pod，因为集群中没有节点可以满足。</li>
<li>集群由生产部门和开发部门共享。你希望允许产品部门的负载最多耗用 8 GB 内存，
但是开发部门的负载最多可使用 512 MiB。
这时，你可以为产品部门和开发部门分别创建名字空间，并为各个名字空间设置内存约束。</li>
</ul>
<h2 id=清理>清理</h2>
<p>删除你的命名空间：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete namespace constraints-mem-example
</code></pre></div><h2 id=what-s-next>What's next</h2>
<h3 id=集群管理员参考>集群管理员参考</h3>
<ul>
<li><a href=/zh/docs/tasks/administer-cluster/manage-resources/memory-default-namespace/>为命名空间配置默认内存请求和限制</a></li>
<li><a href=/zh/docs/tasks/administer-cluster/manage-resources/memory-constraint-namespace/>为命名空间配置内存限制的最小值和最大值</a></li>
<li><a href=/zh/docs/tasks/administer-cluster/manage-resources/cpu-constraint-namespace/>为命名空间配置 CPU 限制的最小值和最大值</a></li>
<li><a href=/zh/docs/tasks/administer-cluster/manage-resources/quota-memory-cpu-namespace/>为命名空间配置内存和 CPU 配额</a></li>
<li><a href=/zh/docs/tasks/administer-cluster/manage-resources/quota-pod-namespace/>为命名空间配置 Pod 配额</a></li>
<li><a href=/zh/docs/tasks/administer-cluster/quota-api-object/>为 API 对象配置配额</a></li>
</ul>
<h3 id=应用开发者参考>应用开发者参考</h3>
<ul>
<li><a href=/zh/docs/tasks/configure-pod-container/assign-memory-resource/>为容器和 Pod 分配内存资源</a></li>
<li><a href=/zh/docs/tasks/configure-pod-container/assign-cpu-resource/>为容器和 Pod 分配 CPU 资源</a></li>
<li><a href=/zh/docs/tasks/configure-pod-container/quality-service-pod/>为 Pod 配置服务质量</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-a87cbd1f9379dac7a48ae320da68a9ad>3.3.4 - 为命名空间配置 CPU 最小和最大约束</h1>
<p>本页介绍如何为命名空间中容器和 Pod 使用的 CPU 资源设置最小和最大值。
你可以通过
<a href=/docs/reference/generated/kubernetes-api/v1.23/#limitrange-v1-core>LimitRange</a>
对象声明 CPU 的最小和最大值. 如果 Pod 不能满足 LimitRange 的限制，它就不能在命名空间中创建。</p>
<h2 id=before-you-begin>Before you begin</h2>
<p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li>
</ul>
To check the version, enter <code>kubectl version</code>.
</p>
<p>你的集群中每个节点至少要有 1 个 CPU 可用才能运行本任务示例。</p>
<h2 id=创建命名空间>创建命名空间</h2>
<p>创建一个命名空间，以便本练习中创建的资源和集群的其余资源相隔离。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create namespace constraints-cpu-example
</code></pre></div>
<h2 id=创建-limitrange-和-pod>创建 LimitRange 和 Pod</h2>
<p>这里给出了 LimitRange 的配置文件：</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/admin/resource/cpu-constraints.yaml download=admin/resource/cpu-constraints.yaml><code>admin/resource/cpu-constraints.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('admin-resource-cpu-constraints-yaml')" title="Copy admin/resource/cpu-constraints.yaml to clipboard">
</img>
</div>
<div class=includecode id=admin-resource-cpu-constraints-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>LimitRange<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cpu-min-max-demo-lr<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>max</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;800m&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>min</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;200m&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Container<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>创建 LimitRange:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/admin/resource/cpu-constraints.yaml --namespace<span style=color:#666>=</span>constraints-cpu-example
</code></pre></div>
<p>查看 LimitRange 详情：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get limitrange cpu-min-max-demo-lr --output<span style=color:#666>=</span>yaml --namespace<span style=color:#666>=</span>constraints-cpu-example
</code></pre></div>
<p>输出结果显示 CPU 的最小和最大限制符合预期。但需要注意的是，尽管你在 LimitRange
的配置文件中你没有声明默认值，默认值也会被自动创建。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>default</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span>800m<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>defaultRequest</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span>800m<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>max</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span>800m<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>min</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span>200m<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Container<span style=color:#bbb>
</span></code></pre></div>
<p>现在不管什么时候在 constraints-cpu-example 命名空间中创建容器，Kubernetes 都会执行下面这些步骤：</p>
<ul>
<li>
<p>如果容器没有声明自己的 CPU 请求和限制，将为容器指定默认 CPU 请求和限制。</p>
</li>
<li>
<p>核查容器声明的 CPU 请求确保其大于或者等于 200 millicpu。</p>
</li>
<li>
<p>核查容器声明的 CPU 限制确保其小于或者等于 800 millicpu。</p>
</li>
</ul>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 当创建 LimitRange 对象时，你也可以声明大页面和 GPU 的限制。
当这些资源同时声明了 'default' 和 'defaultRequest' 参数时，两个参数值必须相同。
</div>
<p>这里给出了包含一个容器的 Pod 的配置文件。
该容器声明了 500 millicpu 的 CPU 请求和 800 millicpu 的 CPU 限制。
这些参数满足了 LimitRange 对象规定的 CPU 最小和最大限制。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/admin/resource/cpu-constraints-pod.yaml download=admin/resource/cpu-constraints-pod.yaml><code>admin/resource/cpu-constraints-pod.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('admin-resource-cpu-constraints-pod-yaml')" title="Copy admin/resource/cpu-constraints-pod.yaml to clipboard">
</img>
</div>
<div class=includecode id=admin-resource-cpu-constraints-pod-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>constraints-cpu-demo<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>constraints-cpu-demo-ctr<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;800m&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;500m&#34;</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>创建Pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/admin/resource/cpu-constraints-pod.yaml --namespace<span style=color:#666>=</span>constraints-cpu-example
</code></pre></div>
<p>确认一下 Pod 中的容器在运行：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod constraints-cpu-demo --namespace<span style=color:#666>=</span>constraints-cpu-example
</code></pre></div>
<p>查看 Pod 的详情：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod constraints-cpu-demo --output<span style=color:#666>=</span>yaml --namespace<span style=color:#666>=</span>constraints-cpu-example
</code></pre></div>
<p>输出结果表明容器的 CPU 请求为 500 millicpu，CPU 限制为 800 millicpu。
这些参数满足 LimitRange 规定的限制范围。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span>800m<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span>500m<span style=color:#bbb>
</span></code></pre></div>
<h2 id=删除-pod>删除 Pod</h2>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete pod constraints-cpu-demo --namespace<span style=color:#666>=</span>constraints-cpu-example
</code></pre></div>
<h2 id=尝试创建一个超过最大-cpu-限制的-pod>尝试创建一个超过最大 CPU 限制的 Pod</h2>
<p>这里给出了包含一个容器的 Pod 的配置文件。容器声明了 500 millicpu 的 CPU
请求和 1.5 CPU 的 CPU 限制。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/admin/resource/cpu-constraints-pod-2.yaml download=admin/resource/cpu-constraints-pod-2.yaml><code>admin/resource/cpu-constraints-pod-2.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('admin-resource-cpu-constraints-pod-2-yaml')" title="Copy admin/resource/cpu-constraints-pod-2.yaml to clipboard">
</img>
</div>
<div class=includecode id=admin-resource-cpu-constraints-pod-2-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>constraints-cpu-demo-2<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>constraints-cpu-demo-2-ctr<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;1.5&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;500m&#34;</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>尝试创建 Pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/admin/resource/cpu-constraints-pod-2.yaml --namespace<span style=color:#666>=</span>constraints-cpu-example
</code></pre></div>
<p>输出结果表明 Pod 没有创建成功，因为容器声明的 CPU 限制太大了：</p>
<pre><code>Error from server (Forbidden): error when creating &quot;examples/admin/resource/cpu-constraints-pod-2.yaml&quot;:
pods &quot;constraints-cpu-demo-2&quot; is forbidden: maximum cpu usage per Container is 800m, but limit is 1500m.
</code></pre>
<h2 id=尝试创建一个不满足最小-cpu-请求的-pod>尝试创建一个不满足最小 CPU 请求的 Pod</h2>
<p>这里给出了包含一个容器的 Pod 的配置文件。该容器声明了100 millicpu的 CPU 请求和800 millicpu的 CPU 限制。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/admin/resource/cpu-constraints-pod-3.yaml download=admin/resource/cpu-constraints-pod-3.yaml><code>admin/resource/cpu-constraints-pod-3.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('admin-resource-cpu-constraints-pod-3-yaml')" title="Copy admin/resource/cpu-constraints-pod-3.yaml to clipboard">
</img>
</div>
<div class=includecode id=admin-resource-cpu-constraints-pod-3-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>constraints-cpu-demo-3<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>constraints-cpu-demo-3-ctr<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;800m&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;100m&#34;</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>尝试创建 Pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/admin/resource/cpu-constraints-pod-3.yaml --namespace<span style=color:#666>=</span>constraints-cpu-example
</code></pre></div>
<p>输出结果显示 Pod 没有创建成功，因为容器声明的 CPU 请求太小了：</p>
<pre><code>Error from server (Forbidden): error when creating &quot;examples/admin/resource/cpu-constraints-pod-3.yaml&quot;:
pods &quot;constraints-cpu-demo-4&quot; is forbidden: minimum cpu usage per Container is 200m, but request is 100m.
</code></pre>
<h2 id=创建一个没有声明-cpu-请求和-cpu-限制的-pod>创建一个没有声明 CPU 请求和 CPU 限制的 Pod</h2>
<p>这里给出了包含一个容器的 Pod 的配置文件。该容器没有设定 CPU 请求和 CPU 限制。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/admin/resource/cpu-constraints-pod-4.yaml download=admin/resource/cpu-constraints-pod-4.yaml><code>admin/resource/cpu-constraints-pod-4.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('admin-resource-cpu-constraints-pod-4-yaml')" title="Copy admin/resource/cpu-constraints-pod-4.yaml to clipboard">
</img>
</div>
<div class=includecode id=admin-resource-cpu-constraints-pod-4-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>constraints-cpu-demo-4<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>constraints-cpu-demo-4-ctr<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>vish/stress<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>创建 Pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/admin/resource/cpu-constraints-pod-4.yaml --namespace<span style=color:#666>=</span>constraints-cpu-example
</code></pre></div>
<p>查看 Pod 的详情：</p>
<pre><code>kubectl get pod constraints-cpu-demo-4 --namespace=constraints-cpu-example --output=yaml
</code></pre>
<p>输出结果显示 Pod 的容器有个 800 millicpu 的 CPU 请求和 800 millicpu 的 CPU 限制。
容器是怎样得到那些值的呢？</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span>800m<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span>800m<span style=color:#bbb>
</span></code></pre></div>
<p>因为你的 Container 没有声明自己的 CPU 请求和限制，LimitRange 给它指定了
<a href=/zh/docs/tasks/administer-cluster/manage-resources/cpu-default-namespace/>默认的 CPU 请求和限制</a></p>
<p>此时，你的容器可能运行也可能没有运行。
回想一下，本任务的先决条件是你的节点要有 1 个 CPU。
如果你的每个节点仅有 1 个 CPU，那么可能没有任何一个节点可以满足 800 millicpu 的 CPU 请求。
如果你在用的节点恰好有两个 CPU，那么你才可能有足够的 CPU 来满足 800 millicpu 的请求。</p>
<pre><code>kubectl delete pod constraints-cpu-demo-4 --namespace=constraints-cpu-example
</code></pre>
<h2 id=cpu-最小和最大限制的强制执行>CPU 最小和最大限制的强制执行</h2>
<p>只有当 Pod 创建或者更新时，LimitRange 为命名空间规定的 CPU 最小和最大限制才会被强制执行。
如果你对 LimitRange 进行修改，那不会影响此前创建的 Pod。</p>
<h2 id=最小和最大-cpu-限制范围的动机>最小和最大 CPU 限制范围的动机</h2>
<p>作为集群管理员，你可能想设定 Pod 可以使用的 CPU 资源限制。例如：</p>
<ul>
<li>集群中的每个节点有两个 CPU。你不想接受任何请求超过 2 个 CPU 的 Pod，因为集群中没有节点可以支持这种请求。</li>
<li>你的生产和开发部门共享一个集群。你想允许生产工作负载消耗 3 个 CPU，
而开发部门工作负载的消耗限制为 1 个 CPU。
你可以为生产和开发创建不同的命名空间，并且为每个命名空间都应用 CPU 限制。</li>
</ul>
<h2 id=清理>清理</h2>
<p>删除你的命名空间：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete namespace constraints-cpu-example
</code></pre></div><h2 id=what-s-next>What's next</h2>
<h3 id=集群管理员参考>集群管理员参考：</h3>
<ul>
<li><a href=/zh/docs/tasks/administer-cluster/manage-resources/memory-default-namespace/>为命名空间配置默认内存请求和限制</a></li>
<li><a href=/zh/docs/tasks/administer-cluster/manage-resources/memory-constraint-namespace/>为命名空间配置内存限制的最小值和最大值</a></li>
<li><a href=/zh/docs/tasks/administer-cluster/manage-resources/cpu-constraint-namespace/>为命名空间配置 CPU 限制的最小值和最大值</a></li>
<li><a href=/zh/docs/tasks/administer-cluster/manage-resources/quota-memory-cpu-namespace/>为命名空间配置内存和 CPU 配额</a></li>
<li><a href=/zh/docs/tasks/administer-cluster/manage-resources/quota-pod-namespace/>为命名空间配置 Pod 配额</a></li>
<li><a href=/zh/docs/tasks/administer-cluster/quota-api-object/>为 API 对象配置配额</a></li>
</ul>
<h3 id=应用开发者参考>应用开发者参考：</h3>
<ul>
<li><a href=/zh/docs/tasks/configure-pod-container/assign-memory-resource/>为容器和 Pod 分配内存资源</a></li>
<li><a href=/zh/docs/tasks/configure-pod-container/assign-cpu-resource/>为容器和 Pod 分配 CPU 资源</a></li>
<li><a href=/zh/docs/tasks/configure-pod-container/quality-service-pod/>为 Pod 配置服务质量</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-fe3283559a3df299aae3ee00ecea2fad>3.3.5 - 为命名空间配置内存和 CPU 配额</h1>
<p>本文介绍怎样为命名空间设置容器可用的内存和 CPU 总量。你可以通过
<a href=/docs/reference/generated/kubernetes-api/v1.23/#resourcequota-v1-core>ResourceQuota</a>
对象设置配额.</p>
<h2 id=before-you-begin>Before you begin</h2>
<p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li>
</ul>
To check the version, enter <code>kubectl version</code>.
</p>
<p>集群中每个节点至少有 1 GiB 的内存。</p>
<h2 id=创建命名空间>创建命名空间</h2>
<p>创建一个命名空间，以便本练习中创建的资源和集群的其余部分相隔离。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create namespace quota-mem-cpu-example
</code></pre></div>
<h2 id=创建-resourcequota>创建 ResourceQuota</h2>
<p>这里给出一个 ResourceQuota 对象的配置文件：</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/admin/resource/quota-mem-cpu.yaml download=admin/resource/quota-mem-cpu.yaml><code>admin/resource/quota-mem-cpu.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('admin-resource-quota-mem-cpu-yaml')" title="Copy admin/resource/quota-mem-cpu.yaml to clipboard">
</img>
</div>
<div class=includecode id=admin-resource-quota-mem-cpu-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ResourceQuota<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mem-cpu-demo<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>hard</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>requests.cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;1&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>requests.memory</span>:<span style=color:#bbb> </span>1Gi<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>limits.cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>limits.memory</span>:<span style=color:#bbb> </span>2Gi<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>创建 ResourceQuota</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/admin/resource/quota-mem-cpu.yaml --namespace<span style=color:#666>=</span>quota-mem-cpu-example
</code></pre></div>
<p>查看 ResourceQuota 详情：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get resourcequota mem-cpu-demo --namespace<span style=color:#666>=</span>quota-mem-cpu-example --output<span style=color:#666>=</span>yaml
</code></pre></div>
<p>ResourceQuota 在 quota-mem-cpu-example 命名空间中设置了如下要求：</p>
<ul>
<li>每个容器必须有内存请求和限制，以及 CPU 请求和限制。</li>
<li>所有容器的内存请求总和不能超过1 GiB。</li>
<li>所有容器的内存限制总和不能超过2 GiB。</li>
<li>所有容器的 CPU 请求总和不能超过1 cpu。</li>
<li>所有容器的 CPU 限制总和不能超过2 cpu。</li>
</ul>
<h2 id=创建-pod>创建 Pod</h2>
<p>这里给出 Pod 的配置文件：</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/admin/resource/quota-mem-cpu-pod.yaml download=admin/resource/quota-mem-cpu-pod.yaml><code>admin/resource/quota-mem-cpu-pod.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('admin-resource-quota-mem-cpu-pod-yaml')" title="Copy admin/resource/quota-mem-cpu-pod.yaml to clipboard">
</img>
</div>
<div class=includecode id=admin-resource-quota-mem-cpu-pod-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>quota-mem-cpu-demo<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>quota-mem-cpu-demo-ctr<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;800Mi&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;800m&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;600Mi&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;400m&#34;</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>创建 Pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/admin/resource/quota-mem-cpu-pod.yaml --namespace<span style=color:#666>=</span>quota-mem-cpu-example
</code></pre></div>
<p>检查下 Pod 中的容器在运行：</p>
<pre><code>kubectl get pod quota-mem-cpu-demo --namespace=quota-mem-cpu-example
</code></pre>
<p>再查看 ResourceQuota 的详情：</p>
<pre><code>kubectl get resourcequota mem-cpu-demo --namespace=quota-mem-cpu-example --output=yaml
</code></pre>
<p>输出结果显示了配额以及有多少配额已经被使用。你可以看到 Pod 的内存和 CPU 请求值及限制值没有超过配额。</p>
<pre><code>status:
  hard:
    limits.cpu: &quot;2&quot;
    limits.memory: 2Gi
    requests.cpu: &quot;1&quot;
    requests.memory: 1Gi
  used:
    limits.cpu: 800m
    limits.memory: 800Mi
    requests.cpu: 400m
    requests.memory: 600Mi
</code></pre>
<h2 id=尝试创建第二个-pod>尝试创建第二个 Pod</h2>
<p>这里给出了第二个 Pod 的配置文件：</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/admin/resource/quota-mem-cpu-pod-2.yaml download=admin/resource/quota-mem-cpu-pod-2.yaml><code>admin/resource/quota-mem-cpu-pod-2.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('admin-resource-quota-mem-cpu-pod-2-yaml')" title="Copy admin/resource/quota-mem-cpu-pod-2.yaml to clipboard">
</img>
</div>
<div class=includecode id=admin-resource-quota-mem-cpu-pod-2-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>quota-mem-cpu-demo-2<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>quota-mem-cpu-demo-2-ctr<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;1Gi&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;800m&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;700Mi&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;400m&#34;</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>配置文件中，你可以看到 Pod 的内存请求为 700 MiB。
请注意新的内存请求与已经使用的内存请求只和超过了内存请求的配额。
600 MiB + 700 MiB > 1 GiB。</p>
<p>尝试创建 Pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/admin/resource/quota-mem-cpu-pod-2.yaml --namespace<span style=color:#666>=</span>quota-mem-cpu-example
</code></pre></div>
<p>第二个 Pod 不能被创建成功。输出结果显示创建第二个 Pod 会导致内存请求总量超过内存请求配额。</p>
<pre><code>Error from server (Forbidden): error when creating &quot;examples/admin/resource/quota-mem-cpu-pod-2.yaml&quot;:
pods &quot;quota-mem-cpu-demo-2&quot; is forbidden: exceeded quota: mem-cpu-demo,
requested: requests.memory=700Mi,used: requests.memory=600Mi, limited: requests.memory=1Gi
</code></pre>
<h2 id=讨论>讨论</h2>
<p>如你在本练习中所见，你可以用 ResourceQuota 限制命名空间中所有容器的内存请求总量。
同样你也可以限制内存限制总量、CPU 请求总量、CPU 限制总量。</p>
<p>如果你想对单个容器而不是所有容器进行限制，就请使用
<a href=/zh/docs/tasks/administer-cluster/manage-resources/memory-constraint-namespace/>LimitRange</a>。</p>
<h2 id=清理>清理</h2>
<p>删除你的命名空间：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete namespace quota-mem-cpu-example
</code></pre></div><h2 id=what-s-next>What's next</h2>
<h3 id=集群管理员参考>集群管理员参考</h3>
<ul>
<li><a href=/zh/docs/tasks/administer-cluster/manage-resources/memory-default-namespace/>为命名空间配置默认内存请求和限制</a></li>
<li><a href=/zh/docs/tasks/administer-cluster/manage-resources/memory-constraint-namespace/>为命名空间配置内存限制的最小值和最大值</a></li>
<li><a href=/zh/docs/tasks/administer-cluster/manage-resources/cpu-constraint-namespace/>为命名空间配置 CPU 限制的最小值和最大值</a></li>
<li><a href=/zh/docs/tasks/administer-cluster/manage-resources/quota-memory-cpu-namespace/>为命名空间配置内存和 CPU 配额</a></li>
<li><a href=/zh/docs/tasks/administer-cluster/manage-resources/quota-pod-namespace/>为命名空间配置 Pod 配额</a></li>
<li><a href=/zh/docs/tasks/administer-cluster/quota-api-object/>为 API 对象配置配额</a></li>
</ul>
<h3 id=应用开发者参考>应用开发者参考</h3>
<ul>
<li><a href=/zh/docs/tasks/configure-pod-container/assign-memory-resource/>为容器和 Pod 分配内存资源</a></li>
<li><a href=/zh/docs/tasks/configure-pod-container/assign-cpu-resource/>为容器和 Pod 分配CPU资源</a></li>
<li><a href=/zh/docs/tasks/configure-pod-container/quality-service-pod/>为 Pod 配置服务质量</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-40e30a9209e0c9f4153707e43243e9d7>3.3.6 - 配置命名空间下 Pod 配额</h1>
<p>本文主要描述如何配置一个命名空间下可运行的 Pod 个数配额。
你可以使用
<a href=/docs/reference/generated/kubernetes-api/v1.23/#resourcequota-v1-core>ResourceQuota</a>
对象来配置配额。</p>
<h2 id=before-you-begin>Before you begin</h2>
<p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li>
</ul>
To check the version, enter <code>kubectl version</code>.
</p>
<h2 id=创建一个命名空间>创建一个命名空间</h2>
<p>首先创建一个命名空间，这样可以将本次操作中创建的资源与集群其他资源隔离开来。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create namespace quota-pod-example
</code></pre></div>
<h2 id=创建-resourcequota>创建 ResourceQuota</h2>
<p>下面是一个 ResourceQuota 的配置文件：</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/admin/resource/quota-pod.yaml download=admin/resource/quota-pod.yaml><code>admin/resource/quota-pod.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('admin-resource-quota-pod-yaml')" title="Copy admin/resource/quota-pod.yaml to clipboard">
</img>
</div>
<div class=includecode id=admin-resource-quota-pod-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ResourceQuota<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pod-demo<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>hard</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>pods</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2&#34;</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>创建这个 ResourceQuota：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/admin/resource/quota-pod.yaml --namespace<span style=color:#666>=</span>quota-pod-example
</code></pre></div>
<p>查看资源配额的详细信息：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get resourcequota pod-demo --namespace<span style=color:#666>=</span>quota-pod-example --output<span style=color:#666>=</span>yaml
</code></pre></div>
<p>从输出的信息我们可以看到，该命名空间下 Pod 的配额是 2 个，目前创建的 Pod 数为 0，
配额使用率为 0。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>hard</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>pods</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>hard</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>pods</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>used</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>pods</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;0&#34;</span><span style=color:#bbb>
</span></code></pre></div>
<p>下面是一个 Deployment 的配置文件：</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/admin/resource/quota-pod-deployment.yaml download=admin/resource/quota-pod-deployment.yaml><code>admin/resource/quota-pod-deployment.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('admin-resource-quota-pod-deployment-yaml')" title="Copy admin/resource/quota-pod-deployment.yaml to clipboard">
</img>
</div>
<div class=includecode id=admin-resource-quota-pod-deployment-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pod-quota-demo<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>purpose</span>:<span style=color:#bbb> </span>quota-demo<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>purpose</span>:<span style=color:#bbb> </span>quota-demo<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pod-quota-demo<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>在配置文件中，<code>replicas: 3</code> 告诉 Kubernetes 尝试创建三个 Pods，且运行相同的应用。</p>
<p>创建这个 Deployment：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/admin/resource/quota-pod-deployment.yaml --namespace<span style=color:#666>=</span>quota-pod-example
</code></pre></div>
<p>查看 Deployment 的详细信息：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get deployment pod-quota-demo --namespace<span style=color:#666>=</span>quota-pod-example --output<span style=color:#666>=</span>yaml
</code></pre></div>
<p>从输出的信息我们可以看到，尽管尝试创建三个 Pod，但是由于配额的限制，只有两个 Pod 能被成功创建。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>availableReplicas</span>:<span style=color:#bbb> </span><span style=color:#666>2</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>lastUpdateTime</span>:<span style=color:#bbb> </span>2017-07-07T20:57:05Z<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>message: &#39;unable to create pods</span>:<span style=color:#bbb> </span>pods &#34;pod-quota-demo-1650323038-&#34; is forbidden:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>exceeded quota: pod-demo, requested: pods=1, used: pods=2, limited</span>:<span style=color:#bbb> </span>pods=2&#39;<span style=color:#bbb>
</span></code></pre></div>
<h2 id=清理>清理</h2>
<p>删除命名空间：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete namespace quota-pod-example
</code></pre></div><h2 id=what-s-next>What's next</h2>
<h3 id=集群管理人员参考>集群管理人员参考</h3>
<ul>
<li><a href=/zh/docs/tasks/administer-cluster/manage-resources/memory-default-namespace/>为命名空间配置默认的内存请求和限制</a></li>
<li><a href=/zh/docs/tasks/administer-cluster/manage-resources/cpu-default-namespace/>为命名空间配置默认的的 CPU 请求和限制</a></li>
<li><a href=/zh/docs/tasks/administer-cluster/manage-resources/memory-constraint-namespace/>为命名空间配置内存的最小值和最大值约束</a></li>
<li><a href=/zh/docs/tasks/administer-cluster/manage-resources/cpu-constraint-namespace/>为命名空间配置 CPU 的最小值和最大值约束</a></li>
<li><a href=/zh/docs/tasks/administer-cluster/manage-resources/quota-memory-cpu-namespace/>为命名空间配置内存和 CPU 配额</a></li>
<li><a href=/zh/docs/tasks/administer-cluster/quota-api-object/>为 API 对象的设置配额</a></li>
</ul>
<h3 id=应用开发人员参考>应用开发人员参考</h3>
<ul>
<li><a href=/zh/docs/tasks/configure-pod-container/assign-memory-resource/>为容器和 Pod 分配内存资源</a></li>
<li><a href=/zh/docs/tasks/configure-pod-container/assign-cpu-resource/>给容器和 Pod 分配 CPU 资源</a></li>
<li><a href=/zh/docs/tasks/configure-pod-container/quality-service-pod/>配置 Pod 的服务质量</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-7743f043c43f7b12e8654e2227dbc658>3.4 - 证书</h1>
<p>在使用客户端证书认证的场景下，你可以通过 <code>easyrsa</code>、<code>openssl</code> 或 <code>cfssl</code> 等工具以手工方式生成证书。</p>
<h3 id=easyrsa>easyrsa</h3>
<p><strong>easyrsa</strong> 支持以手工方式为你的集群生成证书。</p>
<ol>
<li>
<p>下载、解压、初始化打过补丁的 easyrsa3。</p>
<pre><code>curl -LO https://storage.googleapis.com/kubernetes-release/easy-rsa/easy-rsa.tar.gz
tar xzf easy-rsa.tar.gz
cd easy-rsa-master/easyrsa3
./easyrsa init-pki
</code></pre>
</li>
<li>
<p>生成新的证书颁发机构（CA）。参数 <code>--batch</code> 用于设置自动模式；
参数 <code>--req-cn</code> 用于设置新的根证书的通用名称（CN）。</p>
<pre><code>./easyrsa --batch &quot;--req-cn=${MASTER_IP}@`date +%s`&quot; build-ca nopass
</code></pre>
</li>
<li>
<p>生成服务器证书和秘钥。
参数 <code>--subject-alt-name</code> 设置 API 服务器的 IP 和 DNS 名称。
<code>MASTER_CLUSTER_IP</code> 用于 API 服务器和控制管理器，通常取 CIDR 的第一个 IP，由 <code>--service-cluster-ip-range</code> 的参数提供。
参数 <code>--days</code> 用于设置证书的过期时间。
下面的示例假定你的默认 DNS 域名为 <code>cluster.local</code>。</p>
<pre><code>./easyrsa --subject-alt-name=&quot;IP:${MASTER_IP},&quot;\
&quot;IP:${MASTER_CLUSTER_IP},&quot;\
&quot;DNS:kubernetes,&quot;\
&quot;DNS:kubernetes.default,&quot;\
&quot;DNS:kubernetes.default.svc,&quot;\
&quot;DNS:kubernetes.default.svc.cluster,&quot;\
&quot;DNS:kubernetes.default.svc.cluster.local&quot; \
--days=10000 \
build-server-full server nopass
</code></pre>
</li>
<li>
<p>拷贝文件 <code>pki/ca.crt</code>、<code>pki/issued/server.crt</code> 和 <code>pki/private/server.key</code> 到你的目录中。</p>
</li>
<li>
<p>在 API 服务器的启动参数中添加以下参数：</p>
<pre><code>--client-ca-file=/yourdirectory/ca.crt
--tls-cert-file=/yourdirectory/server.crt
--tls-private-key-file=/yourdirectory/server.key
</code></pre>
</li>
</ol>
<h3 id=openssl>openssl</h3>
<p><strong>openssl</strong> 支持以手工方式为你的集群生成证书。</p>
<ol>
<li>
<p>生成一个 2048 位的 ca.key 文件</p>
<pre><code>openssl genrsa -out ca.key 2048
</code></pre>
</li>
<li>
<p>在 ca.key 文件的基础上，生成 ca.crt 文件（用参数 -days 设置证书有效期）</p>
<pre><code>openssl req -x509 -new -nodes -key ca.key -subj &quot;/CN=${MASTER_IP}&quot; -days 10000 -out ca.crt
</code></pre>
</li>
<li>
<p>生成一个 2048 位的 server.key 文件：</p>
<pre><code>openssl genrsa -out server.key 2048
</code></pre>
</li>
<li>
<p>创建一个用于生成证书签名请求（CSR）的配置文件。
保存文件（例如：<code>csr.conf</code>）前，记得用真实值替换掉尖括号中的值（例如：<code>&lt;MASTER_IP></code>）。
注意：<code>MASTER_CLUSTER_IP</code> 就像前一小节所述，它的值是 API 服务器的服务集群 IP。
下面的例子假定你的默认 DNS 域名为 <code>cluster.local</code>。</p>
<pre><code>[ req ]
default_bits = 2048
prompt = no
default_md = sha256
req_extensions = req_ext
distinguished_name = dn

[ dn ]
C = &lt;country&gt;
ST = &lt;state&gt;
L = &lt;city&gt;
O = &lt;organization&gt;
OU = &lt;organization unit&gt;
CN = &lt;MASTER_IP&gt;

[ req_ext ]
subjectAltName = @alt_names

[ alt_names ]
DNS.1 = kubernetes
DNS.2 = kubernetes.default
DNS.3 = kubernetes.default.svc
DNS.4 = kubernetes.default.svc.cluster
DNS.5 = kubernetes.default.svc.cluster.local
IP.1 = &lt;MASTER_IP&gt;
IP.2 = &lt;MASTER_CLUSTER_IP&gt;

[ v3_ext ]
authorityKeyIdentifier=keyid,issuer:always
basicConstraints=CA:FALSE
keyUsage=keyEncipherment,dataEncipherment
extendedKeyUsage=serverAuth,clientAuth
subjectAltName=@alt_names
</code></pre>
</li>
<li>
<p>基于上面的配置文件生成证书签名请求：</p>
<pre><code>openssl req -new -key server.key -out server.csr -config csr.conf
</code></pre>
</li>
<li>
<p>基于 ca.key、ca.crt 和 server.csr 等三个文件生成服务端证书：</p>
<pre><code>openssl x509 -req -in server.csr -CA ca.crt -CAkey ca.key \
-CAcreateserial -out server.crt -days 10000 \
-extensions v3_ext -extfile csr.conf
</code></pre>
</li>
<li>
<p>查看证书签名请求：</p>
<pre><code>openssl req  -noout -text -in ./server.csr
</code></pre>
</li>
<li>
<p>查看证书：</p>
<pre><code>openssl x509  -noout -text -in ./server.crt
</code></pre>
</li>
</ol>
<p>最后，为 API 服务器添加相同的启动参数。</p>
<h3 id=cfssl>cfssl</h3>
<p><strong>cfssl</strong> 是另一个用于生成证书的工具。</p>
<ol>
<li>
<p>下载、解压并准备如下所示的命令行工具。
注意：你可能需要根据所用的硬件体系架构和 cfssl 版本调整示例命令。</p>
<pre><code>curl -L https://github.com/cloudflare/cfssl/releases/download/v1.5.0/cfssl_1.5.0_linux_amd64 -o cfssl
chmod +x cfssl
curl -L https://github.com/cloudflare/cfssl/releases/download/v1.5.0/cfssljson_1.5.0_linux_amd64 -o cfssljson
chmod +x cfssljson
curl -L https://github.com/cloudflare/cfssl/releases/download/v1.5.0/cfssl-certinfo_1.5.0_linux_amd64 -o cfssl-certinfo
chmod +x cfssl-certinfo
</code></pre>
</li>
<li>
<p>创建一个目录，用它保存所生成的构件和初始化 cfssl：</p>
<pre><code>mkdir cert
cd cert
../cfssl print-defaults config &gt; config.json
../cfssl print-defaults csr &gt; csr.json
</code></pre>
</li>
<li>
<p>创建一个 JSON 配置文件来生成 CA 文件，例如：<code>ca-config.json</code>：</p>
<pre><code>{
  &quot;signing&quot;: {
    &quot;default&quot;: {
      &quot;expiry&quot;: &quot;8760h&quot;
    },
    &quot;profiles&quot;: {
      &quot;kubernetes&quot;: {
        &quot;usages&quot;: [
          &quot;signing&quot;,
          &quot;key encipherment&quot;,
          &quot;server auth&quot;,
          &quot;client auth&quot;
        ],
        &quot;expiry&quot;: &quot;8760h&quot;
      }
    }
  }
}
</code></pre>
</li>
<li>
<p>创建一个 JSON 配置文件，用于 CA 证书签名请求（CSR），例如：<code>ca-csr.json</code>。
确认用你需要的值替换掉尖括号中的值。</p>
<pre><code>{
  &quot;CN&quot;: &quot;kubernetes&quot;,
  &quot;key&quot;: {
    &quot;algo&quot;: &quot;rsa&quot;,
    &quot;size&quot;: 2048
  },
  &quot;names&quot;:[{
    &quot;C&quot;: &quot;&lt;country&gt;&quot;,
    &quot;ST&quot;: &quot;&lt;state&gt;&quot;,
    &quot;L&quot;: &quot;&lt;city&gt;&quot;,
    &quot;O&quot;: &quot;&lt;organization&gt;&quot;,
    &quot;OU&quot;: &quot;&lt;organization unit&gt;&quot;
  }]
}
</code></pre>
</li>
<li>
<p>生成 CA 秘钥文件（<code>ca-key.pem</code>）和证书文件（<code>ca.pem</code>）：</p>
<pre><code>../cfssl gencert -initca ca-csr.json | ../cfssljson -bare ca
</code></pre>
</li>
<li>
<p>创建一个 JSON 配置文件，用来为 API 服务器生成秘钥和证书，例如：<code>server-csr.json</code>。
确认用你需要的值替换掉尖括号中的值。<code>MASTER_CLUSTER_IP</code> 是为 API 服务器 指定的服务集群 IP，就像前面小节描述的那样。
以下示例假定你的默认 DSN 域名为<code>cluster.local</code>。</p>
<pre><code>{
  &quot;CN&quot;: &quot;kubernetes&quot;,
  &quot;hosts&quot;: [
    &quot;127.0.0.1&quot;,
    &quot;&lt;MASTER_IP&gt;&quot;,
    &quot;&lt;MASTER_CLUSTER_IP&gt;&quot;,
    &quot;kubernetes&quot;,
    &quot;kubernetes.default&quot;,
    &quot;kubernetes.default.svc&quot;,
    &quot;kubernetes.default.svc.cluster&quot;,
    &quot;kubernetes.default.svc.cluster.local&quot;
  ],
  &quot;key&quot;: {
    &quot;algo&quot;: &quot;rsa&quot;,
    &quot;size&quot;: 2048
  },
  &quot;names&quot;: [{
    &quot;C&quot;: &quot;&lt;country&gt;&quot;,
    &quot;ST&quot;: &quot;&lt;state&gt;&quot;,
    &quot;L&quot;: &quot;&lt;city&gt;&quot;,
    &quot;O&quot;: &quot;&lt;organization&gt;&quot;,
    &quot;OU&quot;: &quot;&lt;organization unit&gt;&quot;
  }]
}
</code></pre>
</li>
<li>
<p>为 API 服务器生成秘钥和证书，默认会分别存储为<code>server-key.pem</code> 和 <code>server.pem</code> 两个文件。</p>
<pre><code>../cfssl gencert -ca=ca.pem -ca-key=ca-key.pem \
--config=ca-config.json -profile=kubernetes \
server-csr.json | ../cfssljson -bare server
</code></pre>
</li>
</ol>
<h2 id=分发自签名的-ca-证书>分发自签名的 CA 证书</h2>
<p>客户端节点可能不认可自签名 CA 证书的有效性。
对于非生产环境，或者运行在公司防火墙后的环境，你可以分发自签名的 CA 证书到所有客户节点，并刷新本地列表以使证书生效。</p>
<p>在每一个客户节点，执行以下操作：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>sudo cp ca.crt /usr/local/share/ca-certificates/kubernetes.crt
sudo update-ca-certificates
</code></pre></div><pre><code>Updating certificates in /etc/ssl/certs...
1 added, 0 removed; done.
Running hooks in /etc/ca-certificates/update.d....
done.
</code></pre>
<h2 id=certificates-api>证书 API</h2>
<p>你可以通过 <code>certificates.k8s.io</code> API 提供 x509 证书，用来做身份验证，
如<a href=/zh/docs/tasks/tls/managing-tls-in-a-cluster>本</a>文档所述。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-8c31aafd38fad5b0de0bd191758d6f93>3.5 - 安装网络策略驱动</h1>
</div>
<div class=td-content>
<h1 id=pg-b4418905b0c14630e4e9cb1368241534>3.5.1 - 使用 Antrea 提供 NetworkPolicy</h1>
<p>本页展示了如何在 kubernetes 中安装和使用 Antrea CNI 插件。
要了解 Antrea 项目的背景，请阅读 <a href=https://antrea.io/docs/>Antrea 介绍</a>。</p>
<h2 id=before-you-begin>Before you begin</h2>
<p>你需要拥有一个 kuernetes 集群。
遵循 <a href=/zh/docs/reference/setup-tools/kubeadm/>kubeadm 入门指南</a>自行创建一个。</p>
<h2 id=使用-kubeadm-部署-antrea>使用 kubeadm 部署 Antrea</h2>
<p>遵循<a href=https://github.com/vmware-tanzu/antrea/blob/main/docs/getting-started.md>入门</a>指南
为 kubeadm 部署 Antrea 。</p>
<h2 id=what-s-next>What's next</h2>
<p>一旦你的集群已经运行，你可以遵循
<a href=/zh/docs/tasks/administer-cluster/declare-network-policy/>声明网络策略</a>
来尝试 Kubernetes NetworkPolicy。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-1239a77618c6278373832a142cd85519>3.5.2 - 使用 Calico 提供 NetworkPolicy</h1>
<p>本页展示了几种在 Kubernetes 上快速创建 Calico 集群的方法。</p>
<h2 id=before-you-begin>Before you begin</h2>
<p>确定你想部署一个<a href=#gke-cluster>云版本</a>还是<a href=#local-cluster>本地版本</a>的集群。</p>
<h2 id=gke-cluster>在 Google Kubernetes Engine (GKE) 上创建一个 Calico 集群</h2>
<p><strong>先决条件</strong>: <a href=https://cloud.google.com/sdk/docs/quickstarts>gcloud</a></p>
<ol>
<li>
<p>启动一个带有 Calico 的 GKE 集群，需要加上参数 <code>--enable-network-policy</code>。</p>
<p><strong>语法</strong></p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>gcloud container clusters create <span style=color:#666>[</span>CLUSTER_NAME<span style=color:#666>]</span> --enable-network-policy
</code></pre></div><p><strong>示例</strong></p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>gcloud container clusters create my-calico-cluster --enable-network-policy
</code></pre></div></li>
</ol>
<ol start=2>
<li>
<p>使用如下命令验证部署是否正确。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods --namespace<span style=color:#666>=</span>kube-system
</code></pre></div>
<p>Calico 的 pods 名以 <code>calico</code> 打头，检查确认每个 pods 状态为 <code>Running</code>。</p>
</li>
</ol>
<h2 id=local-cluster>使用 kubeadm 创建一个本地 Calico 集群 </h2>
<p>使用 kubeadm 在 15 分钟内得到一个本地单主机 Calico 集群，请参考
<a href=https://docs.projectcalico.org/latest/getting-started/kubernetes/>Calico 快速入门</a>。</p>
<h2 id=what-s-next>What's next</h2>
<p>集群运行后，您可以按照<a href=/zh/docs/tasks/administer-cluster/declare-network-policy/>声明网络策略</a>
去尝试使用 Kubernetes NetworkPolicy。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-95039241255a31df196beaa405b68eba>3.5.3 - 使用 Cilium 提供 NetworkPolicy</h1>
<p>本页展示如何使用 Cilium 提供 NetworkPolicy。</p>
<p>关于 Cilium 的背景知识，请阅读 <a href=https://docs.cilium.io/en/stable/intro>Cilium 介绍</a>。</p>
<h2 id=before-you-begin>Before you begin</h2>
<p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li>
</ul>
To check the version, enter <code>kubectl version</code>.
</p>
<h2 id=在-minikube-上部署-cilium-用于基本测试>在 Minikube 上部署 Cilium 用于基本测试</h2>
<p>为了轻松熟悉 Cilium 你可以根据
<a href=https://docs.cilium.io/en/stable/gettingstarted/k8s-install-default/s>Cilium Kubernetes 入门指南</a>
在 minikube 中执行一个 cilium 的基本 DaemonSet 安装。</p>
<p>要启动 minikube，需要的最低版本为 1.5.2，使用下面的参数运行：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>minikube version
</code></pre></div><pre><code>minikube version: v1.5.2
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>minikube start --network-plugin<span style=color:#666>=</span>cni --memory<span style=color:#666>=</span><span style=color:#666>4096</span>
</code></pre></div>
<p>对于 minikube 你可以使用 Cilium 的 CLI 工具安装它。
Cilium 将自动检测集群配置并为成功的集群部署选择合适的组件。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>curl -LO https://github.com/cilium/cilium-cli/releases/latest/download/cilium-linux-amd64.tar.gz
sudo tar xzvfC cilium-linux-amd64.tar.gz /usr/local/bin
rm cilium-linux-amd64.tar.gz
cilium install
</code></pre></div><pre><code>🔮 Auto-detected Kubernetes kind: minikube
✨ Running &quot;minikube&quot; validation checks
✅ Detected minikube version &quot;1.20.0&quot;
ℹ️  Cilium version not set, using default version &quot;v1.10.0&quot;
🔮 Auto-detected cluster name: minikube
🔮 Auto-detected IPAM mode: cluster-pool
🔮 Auto-detected datapath mode: tunnel
🔑 Generating CA...
2021/05/27 02:54:44 [INFO] generate received request
2021/05/27 02:54:44 [INFO] received CSR
2021/05/27 02:54:44 [INFO] generating key: ecdsa-256
2021/05/27 02:54:44 [INFO] encoded CSR
2021/05/27 02:54:44 [INFO] signed certificate with serial number 48713764918856674401136471229482703021230538642
🔑 Generating certificates for Hubble...
2021/05/27 02:54:44 [INFO] generate received request
2021/05/27 02:54:44 [INFO] received CSR
2021/05/27 02:54:44 [INFO] generating key: ecdsa-256
2021/05/27 02:54:44 [INFO] encoded CSR
2021/05/27 02:54:44 [INFO] signed certificate with serial number 3514109734025784310086389188421560613333279574
🚀 Creating Service accounts...
🚀 Creating Cluster roles...
🚀 Creating ConfigMap...
🚀 Creating Agent DaemonSet...
🚀 Creating Operator Deployment...
⌛ Waiting for Cilium to be installed...
</code></pre>
<p>入门指南其余的部分用一个示例应用说明了如何强制执行 L3/L4（即 IP 地址+端口）的安全策略
以及L7 （如 HTTP）的安全策略。</p>
<h2 id=部署-cilium-用于生产用途>部署 Cilium 用于生产用途</h2>
<p>关于部署 Cilium 用于生产的详细说明，请见
<a href=https://docs.cilium.io/en/stable/concepts/kubernetes/intro/>Cilium Kubernetes 安装指南</a>
此文档包括详细的需求、说明和生产用途 DaemonSet 文件示例。</p>
<h2 id=了解-cilium-组件>了解 Cilium 组件</h2>
<p>部署使用 Cilium 的集群会添加 Pods 到 <code>kube-system</code> 命名空间。要查看 Pod 列表，运行：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods --namespace<span style=color:#666>=</span>kube-system -l k8s-app<span style=color:#666>=</span>cilium
</code></pre></div>
<p>你将看到像这样的 Pods 列表：</p>
<pre><code class=language-console data-lang=console>NAME           READY   STATUS    RESTARTS   AGE
cilium-kkdhz   1/1     Running   0          3m23s
...
</code></pre>
<p>你的集群中的每个节点上都会运行一个 <code>cilium</code> Pod，通过使用 Linux BPF
针对该节点上的 Pod 的入站、出站流量实施网络策略控制。</p>
<h2 id=what-s-next>What's next</h2>
<p>集群运行后，你可以按照
<a href=/zh/docs/tasks/administer-cluster/declare-network-policy/>声明网络策略</a>
试用基于 Cilium 的 Kubernetes NetworkPolicy。
玩得开心，如果你有任何疑问，请到 <a href=https://cilium.herokuapp.com/>Cilium Slack 频道</a>
联系我们。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-505a0a6a7e6eff361bbb3be81c84b2e0>3.5.4 - 使用 kube-router 提供 NetworkPolicy</h1>
<p>本页展示如何使用 <a href=https://github.com/cloudnativelabs/kube-router>Kube-router</a> 提供 NetworkPolicy。</p>
<h2 id=before-you-begin>Before you begin</h2>
<p>你需要拥有一个运行中的 Kubernetes 集群。如果你还没有集群，可以使用任意的集群
安装程序如 Kops、Bootkube、Kubeadm 等创建一个。</p>
<h2 id=安装-kube-router-插件>安装 kube-router 插件</h2>
<p>kube-router 插件自带一个网络策略控制器，监视来自于 Kubernetes API 服务器的
NetworkPolicy 和 Pod 的变化，根据策略指示配置 iptables 规则和 ipsets 来允许或阻止流量。
请根据 <a href=https://www.kube-router.io/docs/user-guide/#try-kube-router-with-cluster-installers>通过集群安装程序尝试 kube-router</a> 指南安装 kube-router 插件。</p>
<h2 id=what-s-next>What's next</h2>
<p>在你安装了 kube-router 插件后，可以参考
<a href=/zh/docs/tasks/administer-cluster/declare-network-policy/>声明网络策略</a>
去尝试使用 Kubernetes NetworkPolicy。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-2842eac98aa0e229a5c6755c4c83d2a7>3.5.5 - 使用 Romana 提供 NetworkPolicy</h1>
<p>本页展示如何使用 Romana 作为 NetworkPolicy。</p>
<h2 id=before-you-begin>Before you begin</h2>
<p>完成 <a href=/zh/docs/reference/setup-tools/kubeadm/>kubeadm 入门指南</a>中的 1、2、3 步。</p>
<h2 id=使用-kubeadm-安装-romana>使用 kubeadm 安装 Romana</h2>
<p>按照<a href=https://github.com/romana/romana/tree/master/containerize>容器化安装指南</a>，
使用 kubeadm 安装。</p>
<h2 id=应用网络策略>应用网络策略</h2>
<p>使用以下的一种方式应用网络策略：</p>
<ul>
<li><a href=https://github.com/romana/romana/wiki/Romana-policies>Romana 网络策略</a>
<ul>
<li><a href=https://github.com/romana/core/blob/master/doc/policy.md>Romana 网络策略例子</a></li>
</ul>
</li>
<li>NetworkPolicy API</li>
</ul>
<h2 id=what-s-next>What's next</h2>
<p>Romana 安装完成后，你可以按照
<a href=/zh/docs/tasks/administer-cluster/declare-network-policy/>声明网络策略</a>
去尝试使用 Kubernetes NetworkPolicy。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-ac075c3fdfd0d41aa753cc70e42be064>3.5.6 - 使用 Weave Net 提供 NetworkPolicy</h1>
<p>本页展示如何使用使用 Weave Net 提供 NetworkPolicy。</p>
<h2 id=before-you-begin>Before you begin</h2>
<p>你需要拥有一个 Kubernetes 集群。按照
<a href=/zh/docs/reference/setup-tools/kubeadm/>kubeadm 入门指南</a>
来启动一个。</p>
<h2 id=安装-weave-net-插件>安装 Weave Net 插件</h2>
<p>按照<a href=https://www.weave.works/docs/net/latest/kubernetes/kube-addon/>通过插件集成 Kubernetes</a>
指南执行安装。</p>
<p>Kubernetes 的 Weave Net 插件带有
<a href=https://www.weave.works/docs/net/latest/kubernetes/kube-addon/#npc>网络策略控制器</a>，
可自动监控 Kubernetes 所有名字空间的 NetworkPolicy 注释，
配置 <code>iptables</code> 规则以允许或阻止策略指示的流量。</p>
<h2 id=测试安装>测试安装</h2>
<p>验证 weave 是否有效。</p>
<p>输入以下命令：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get po -n kube-system -o wide
</code></pre></div>
<p>输出类似这样：</p>
<pre><code>NAME                                    READY     STATUS    RESTARTS   AGE       IP              NODE
weave-net-1t1qg                         2/2       Running   0          9d        192.168.2.10    worknode3
weave-net-231d7                         2/2       Running   1          7d        10.2.0.17       worknodegpu
weave-net-7nmwt                         2/2       Running   3          9d        192.168.2.131   masternode
weave-net-pmw8w                         2/2       Running   0          9d        192.168.2.216   worknode2
</code></pre>
<p>每个 Node 都有一个 weave Pod，所有 Pod 都是<code>Running</code> 和 <code>2/2 READY</code>。
（<code>2/2</code> 表示每个 Pod 都有 <code>weave</code> 和 <code>weave-npc</code>）</p>
<h2 id=what-s-next>What's next</h2>
<p>安装 Weave Net 插件后，你可以参考
<a href=/zh/docs/tasks/administer-cluster/declare-network-policy/>声明网络策略</a>
来试用 Kubernetes NetworkPolicy。
如果你有任何疑问，请通过
<a href=https://github.com/weaveworks/weave#getting-help>Slack 上的 #weave-community 频道或者 Weave 用户组</a>
联系我们。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-b45f024608e1b367cdacb1fd9d77278a>3.6 - IP Masquerade Agent 用户指南</h1>
<p>此页面展示如何配置和启用 ip-masq-agent。</p>
<h2 id=before-you-begin>Before you begin</h2>
<p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li>
</ul>
To check the version, enter <code>kubectl version</code>.
</p>
<h2 id=ip-masquerade-agent-用户指南>IP Masquerade Agent 用户指南</h2>
<p>ip-masq-agent 配置 iptables 规则以隐藏位于集群节点 IP 地址后面的 Pod 的 IP 地址。
这通常在将流量发送到集群的 Pod
<a href=https://zh.wikipedia.org/wiki/%E6%97%A0%E7%B1%BB%E5%88%AB%E5%9F%9F%E9%97%B4%E8%B7%AF%E7%94%B1>CIDR</a>
范围之外的目的地时使用。</p>
<h3 id=关键术语><strong>关键术语</strong></h3>
<ul>
<li><strong>NAT (网络地址转译)</strong>
是一种通过修改 IP 地址头中的源和/或目标地址信息将一个 IP 地址重新映射
到另一个 IP 地址的方法。通常由执行 IP 路由的设备执行。</li>
</ul>
<ul>
<li><strong>伪装</strong>
NAT 的一种形式，通常用于执行多对一地址转换，其中多个源 IP 地址被隐藏在
单个地址后面，该地址通常是执行 IP 路由的设备。在 Kubernetes 中，
这是节点的 IP 地址。</li>
</ul>
<ul>
<li><strong>CIDR (无类别域间路由)</strong>
基于可变长度子网掩码，允许指定任意长度的前缀。
CIDR 引入了一种新的 IP 地址表示方法，现在通常称为<strong>CIDR表示法</strong>，
其中地址或路由前缀后添加一个后缀，用来表示前缀的位数，例如 192.168.2.0/24。</li>
</ul>
<ul>
<li><strong>本地链路</strong>
本地链路是仅对网段或主机所连接的广播域内的通信有效的网络地址。
IPv4 的本地链路地址在 CIDR 表示法的地址块 169.254.0.0/16 中定义。</li>
</ul>
<p>ip-masq-agent 配置 iptables 规则，以便在将流量发送到集群节点的 IP 和集群 IP 范围之外的目标时
处理伪装节点或 Pod 的 IP 地址。这本质上隐藏了集群节点 IP 地址后面的 Pod IP 地址。
在某些环境中，去往“外部”地址的流量必须从已知的机器地址发出。
例如，在 Google Cloud 中，任何到互联网的流量都必须来自 VM 的 IP。
使用容器时，如 Google Kubernetes Engine，从 Pod IP 发出的流量将被拒绝出站。
为了避免这种情况，我们必须将 Pod IP 隐藏在 VM 自己的 IP 地址后面 - 通常称为“伪装”。
默认情况下，代理配置为将
<a href=https://tools.ietf.org/html/rfc1918>RFC 1918</a>
指定的三个私有 IP 范围视为非伪装
<a href=https://zh.wikipedia.org/wiki/%E6%97%A0%E7%B1%BB%E5%88%AB%E5%9F%9F%E9%97%B4%E8%B7%AF%E7%94%B1>CIDR</a>。
这些范围是 10.0.0.0/8,172.16.0.0/12 和 192.168.0.0/16。
默认情况下，代理还将链路本地地址（169.254.0.0/16）视为非伪装 CIDR。
代理程序配置为每隔 60 秒从 <em>/etc/config/ip-masq-agent</em> 重新加载其配置，
这也是可修改的。</p>
<p><img src=/images/docs/ip-masq.png alt="masq/non-masq example"></p>
<p>代理配置文件必须使用 YAML 或 JSON 语法编写，并且可能包含三个可选值：</p>
<ul>
<li><strong>nonMasqueradeCIDRs:</strong>
<a href=https://zh.wikipedia.org/wiki/%E6%97%A0%E7%B1%BB%E5%88%AB%E5%9F%9F%E9%97%B4%E8%B7%AF%E7%94%B1>CIDR</a>
表示法中的字符串列表，用于指定不需伪装的地址范围。</li>
</ul>
<ul>
<li><strong>masqLinkLocal:</strong> 布尔值 (true / false)，表示是否将流量伪装到
本地链路前缀 169.254.0.0/16。默认为 false。</li>
</ul>
<ul>
<li><strong>resyncInterval:</strong> 代理尝试从磁盘重新加载配置的时间间隔。
例如 '30s'，其中 's' 是秒，'ms' 是毫秒等...</li>
</ul>
<p>10.0.0.0/8、172.16.0.0/12 和 192.168.0.0/16 范围内的流量不会被伪装。
任何其他流量（假设是互联网）将被伪装。
Pod 访问本地目的地的例子，可以是其节点的 IP 地址、另一节点的地址或集群的 IP 地址范围内的一个 IP 地址。
默认情况下，任何其他流量都将伪装。以下条目展示了 ip-masq-agent 的默认使用的规则：</p>
<pre><code>iptables -t nat -L IP-MASQ-AGENT
RETURN     all  --  anywhere             169.254.0.0/16       /* ip-masq-agent: cluster-local traffic should not be subject to MASQUERADE */ ADDRTYPE match dst-type !LOCAL
RETURN     all  --  anywhere             10.0.0.0/8           /* ip-masq-agent: cluster-local traffic should not be subject to MASQUERADE */ ADDRTYPE match dst-type !LOCAL
RETURN     all  --  anywhere             172.16.0.0/12        /* ip-masq-agent: cluster-local traffic should not be subject to MASQUERADE */ ADDRTYPE match dst-type !LOCAL
RETURN     all  --  anywhere             192.168.0.0/16       /* ip-masq-agent: cluster-local traffic should not be subject to MASQUERADE */ ADDRTYPE match dst-type !LOCAL
MASQUERADE  all  --  anywhere             anywhere             /* ip-masq-agent: outbound traffic should be subject to MASQUERADE (this match must come after cluster-local CIDR matches) */ ADDRTYPE match dst-type !LOCAL

</code></pre>
<p>默认情况下，从 Kubernetes 1.7.0 版本开始的 GCE/Google Kubernetes Engine 中，
如果启用了网络策略，或者你使用的集群 CIDR 不在 10.0.0.0/8 范围内，
则 ip-masq-agent 将在你的集群中运行。
如果你在其他环境中运行，则可以将 ip-masq-agent
<a href=/zh/docs/concepts/workloads/controllers/daemonset/>DaemonSet</a> 添加到你的集群：</p>
<h2 id=创建-ip-masq-agent>创建 ip-masq-agent</h2>
<p>通过运行以下 kubectl 指令创建 ip-masq-agent:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://raw.githubusercontent.com/kubernetes-sigs/ip-masq-agent/master/ip-masq-agent.yaml
</code></pre></div>
<p>你必须同时将适当的节点标签应用于集群中希望代理运行的任何节点。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl label nodes my-node beta.kubernetes.io/masq-agent-ds-ready<span style=color:#666>=</span><span style=color:#a2f>true</span>
</code></pre></div>
<p>更多信息可以通过 ip-masq-agent 文档 <a href=https://github.com/kubernetes-sigs/ip-masq-agent>这里</a> 找到。</p>
<p>在大多数情况下，默认的规则集应该足够；但是，如果你的群集不是这种情况，则可以创建并应用
<a href=/zh/docs/tasks/configure-pod-container/configure-pod-configmap/>ConfigMap</a>
来自定义受影响的 IP 范围。
例如，要允许 ip-masq-agent 仅作用于 10.0.0.0/8，你可以在一个名为 “config” 的文件中创建以下
<a href=/zh/docs/tasks/configure-pod-container/configure-pod-configmap/>ConfigMap</a> 。</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong>
<p>重要的是，该文件之所以被称为 config，因为默认情况下，该文件将被用作
ip-masq-agent 查找的主键：</p>
<pre><code>nonMasqueradeCIDRs:
  - 10.0.0.0/8
resyncInterval: 60s
</code></pre>
</div>
<p>运行以下命令将配置映射添加到你的集群：</p>
<pre><code>kubectl create configmap ip-masq-agent --from-file=config --namespace=kube-system
</code></pre>
<p>这将更新位于 <em>/etc/config/ip-masq-agent</em> 的一个文件，该文件以 <em>resyncInterval</em>
为周期定期检查并应用于集群节点。
重新同步间隔到期后，你应该看到你的更改在 iptables 规则中体现：</p>
<pre><code>iptables -t nat -L IP-MASQ-AGENT
Chain IP-MASQ-AGENT (1 references)
target     prot opt source               destination
RETURN     all  --  anywhere             169.254.0.0/16       /* ip-masq-agent: cluster-local traffic should not be subject to MASQUERADE */ ADDRTYPE match dst-type !LOCAL
RETURN     all  --  anywhere             10.0.0.0/8           /* ip-masq-agent: cluster-local
MASQUERADE  all  --  anywhere             anywhere             /* ip-masq-agent: outbound traffic should be subject to MASQUERADE (this match must come after cluster-local CIDR matches) */ ADDRTYPE match dst-type !LOCAL
</code></pre>
<p>默认情况下，本地链路范围 (169.254.0.0/16) 也由 ip-masq agent 处理，
该代理设置适当的 iptables 规则。 要使 ip-masq-agent 忽略本地链路，
可以在配置映射中将 <em>masqLinkLocal</em> 设置为 true。</p>
<pre><code>nonMasqueradeCIDRs:
  - 10.0.0.0/8
resyncInterval: 60s
masqLinkLocal: true
</code></pre>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-ce4cd28c8feb9faa783e79b48af37961>3.7 - Kubernetes 云管理控制器</h1>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.11 [beta]</code>
</div>
<p>由于云驱动的开发和发布的步调与 Kubernetes 项目不同，将服务提供商专用代码抽象到
<code><a class=glossary-tooltip title="将 Kubernetes 与第三方云提供商进行集成的控制面组件。" data-toggle=tooltip data-placement=top href=/zh/docs/concepts/architecture/cloud-controller/ target=_blank aria-label=cloud-controller-manager>cloud-controller-manager</a></code>
二进制中有助于云服务厂商在 Kubernetes 核心代码之外独立进行开发。</p>
<p><code>cloud-controller-manager</code> 可以被链接到任何满足
<a href=https://github.com/kubernetes/cloud-provider/blob/master/cloud.go>cloudprovider.Interface</a>
约束的云服务提供商。为了兼容旧版本，Kubernetes 核心项目中提供的
<a href=https://github.com/kubernetes/kubernetes/tree/master/cmd/cloud-controller-manager>cloud-controller-manager</a>
使用和 <code>kube-controller-manager</code> 相同的云服务类库。
已经在 Kubernetes 核心项目中支持的云服务提供商预计将通过使用 in-tree 的 cloud-controller-manager
过渡为非 Kubernetes 核心代码。</p>
<h2 id=管理>管理</h2>
<h3 id=需求>需求</h3>
<p>每个云服务都有一套各自的需求用于系统平台的集成，这不应与运行
<code>kube-controller-manager</code> 的需求有太大差异。作为经验法则，你需要：</p>
<ul>
<li>云服务认证/授权：你的云服务可能需要使用令牌或者 IAM 规则以允许对其 API 的访问</li>
<li>kubernetes 认证/授权：cloud-controller-manager 可能需要 RBAC 规则以访问 kubernetes apiserver</li>
<li>高可用：类似于 kube-controller-manager，你可能希望通过主节点选举（默认开启）配置一个高可用的云管理控制器。</li>
</ul>
<h3 id=运行云管理控制器>运行云管理控制器</h3>
<p>你需要对集群配置做适当的修改以成功地运行云管理控制器：</p>
<ul>
<li>一定不要为 <code>kube-apiserver</code> 和 <code>kube-controller-manager</code> 指定 <code>--cloud-provider</code> 标志。
这将保证它们不会运行任何云服务专用循环逻辑，这将会由云管理控制器运行。未来这个标记将被废弃并去除。</li>
<li><code>kubelet</code> 必须使用 <code>--cloud-provider=external</code> 运行。
这是为了保证让 kubelet 知道在执行任何任务前，它必须被云管理控制器初始化。</li>
</ul>
<p>请记住，设置群集使用云管理控制器将用多种方式更改群集行为：</p>
<ul>
<li>指定了 <code>--cloud-provider=external</code> 的 kubelet 将被添加一个 <code>node.cloudprovider.kubernetes.io/uninitialized</code>
的污点，导致其在初始化过程中不可调度（<code>NoSchedule</code>）。
这将标记该节点在能够正常调度前，需要外部的控制器进行二次初始化。
请注意，如果云管理控制器不可用，集群中的新节点会一直处于不可调度的状态。
这个污点很重要，因为调度器可能需要关于节点的云服务特定的信息，比如他们的区域或类型
（高端 CPU、GPU 支持、内存较大、临时实例等）。</li>
</ul>
<ul>
<li>集群中节点的云服务信息将不再能够从本地元数据中获取，取而代之的是所有获取节点信息的
API 调用都将通过云管理控制器。这意味着你可以通过限制到 kubelet 云服务 API 的访问来提升安全性。
在更大的集群中你可能需要考虑云管理控制器是否会遇到速率限制，
因为它现在负责集群中几乎所有到云服务的 API 调用。</li>
</ul>
<p>云管理控制器可以实现：</p>
<ul>
<li>节点控制器 - 负责使用云服务 API 更新 kubernetes 节点并删除在云服务上已经删除的 kubernetes 节点。</li>
<li>服务控制器 - 负责在云服务上为类型为 LoadBalancer 的 service 提供负载均衡器。</li>
<li>路由控制器 - 负责在云服务上配置网络路由。</li>
<li>如果你使用的是 out-of-tree 提供商，请按需实现其余任意特性。</li>
</ul>
<h2 id=示例>示例</h2>
<p>如果当前 Kubernetes 内核支持你使用的云服务，并且想要采用云管理控制器，请参见
<a href=https://github.com/kubernetes/kubernetes/tree/master/cmd/cloud-controller-manager>kubernetes 内核中的云管理控制器</a>。</p>
<p>对于不在 Kubernetes 核心代码库中的云管理控制器，你可以在云服务厂商或 SIG 领导者的源中找到对应的项目。</p>
<ul>
<li><a href=https://github.com/digitalocean/digitalocean-cloud-controller-manager>DigitalOcean</a></li>
<li><a href=https://github.com/munnerz/keepalived-cloud-provider>keepalived</a></li>
<li><a href=https://github.com/oracle/oci-cloud-controller-manager>Oracle Cloud Infrastructure</a></li>
<li><a href=https://github.com/rancher/rancher-cloud-controller-manager>Rancher</a></li>
</ul>
<p>对于已经存在于 Kubernetes 内核中的提供商，你可以在集群中将 in-tree 云管理控制器作为守护进程运行。请使用如下指南：</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/admin/cloud/ccm-example.yaml download=admin/cloud/ccm-example.yaml><code>admin/cloud/ccm-example.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('admin-cloud-ccm-example-yaml')" title="Copy admin/cloud/ccm-example.yaml to clipboard">
</img>
</div>
<div class=includecode id=admin-cloud-ccm-example-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#080;font-style:italic># This is an example of how to setup cloud-controller-manager as a Daemonset in your cluster.</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># It assumes that your masters can run pods and has the role node-role.kubernetes.io/master</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># Note that this Daemonset will not work straight out of the box for your cloud, this is</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># meant to be a guideline.</span><span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ServiceAccount<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cloud-controller-manager<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>kube-system<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRoleBinding<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>system:cloud-controller-manager<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>roleRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cluster-admin<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>subjects</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ServiceAccount<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cloud-controller-manager<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>kube-system<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>DaemonSet<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>k8s-app</span>:<span style=color:#bbb> </span>cloud-controller-manager<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cloud-controller-manager<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>kube-system<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>k8s-app</span>:<span style=color:#bbb> </span>cloud-controller-manager<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>k8s-app</span>:<span style=color:#bbb> </span>cloud-controller-manager<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>serviceAccountName</span>:<span style=color:#bbb> </span>cloud-controller-manager<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cloud-controller-manager<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># for in-tree providers we use k8s.gcr.io/cloud-controller-manager</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># this can be replaced with any other image for out-of-tree providers</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/cloud-controller-manager:v1.8.0<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- /usr/local/bin/cloud-controller-manager<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- --cloud-provider=[YOUR_CLOUD_PROVIDER] <span style=color:#bbb> </span><span style=color:#080;font-style:italic># Add your own cloud provider here!</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span>- --leader-elect=true<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- --use-service-account-credentials<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># these flags will vary for every cloud provider</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span>- --allocate-node-cidrs=true<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- --configure-cloud-routes=true<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- --cluster-cidr=172.17.0.0/16<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>tolerations</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># this is required so CCM can bootstrap itself</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>node.cloudprovider.kubernetes.io/uninitialized<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>effect</span>:<span style=color:#bbb> </span>NoSchedule<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># this is to have the daemonset runnable on master nodes</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># the taint may vary depending on your cluster setup</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>node-role.kubernetes.io/master<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>effect</span>:<span style=color:#bbb> </span>NoSchedule<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># this is to restrict CCM to only run on master nodes</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># the node selector may vary depending on your cluster setup</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>nodeSelector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>node-role.kubernetes.io/master</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<h2 id=限制>限制</h2>
<p>运行云管理控制器会有一些可能的限制。虽然以后的版本将处理这些限制，但是知道这些生产负载的限制很重要。</p>
<h3 id=对-volume-的支持>对 Volume 的支持</h3>
<p>云管理控制器未实现 <code>kube-controller-manager</code> 中的任何 volume 控制器，因为和 volume 的集成还需要与 kubelet 协作。由于我们引入了 CSI (容器存储接口，container storage interface) 并对弹性 volume 插件添加了更强大的支持，云管理控制器将添加必要的支持，以使云服务同 volume 更好的集成。请在 <a href=https://github.com/kubernetes/features/issues/178>这里</a> 了解更多关于 out-of-tree CSI volume 插件的信息。</p>
<h3 id=可扩展性>可扩展性</h3>
<p>在以前为云服务提供商提供的架构中，我们依赖 kubelet 的本地元数据服务来获取关于它本身的节点信息。通过这个新的架构，现在我们完全依赖云管理控制器来获取所有节点的信息。对于非常大的集群，你需要考虑可能的瓶颈，例如资源需求和 API 速率限制。</p>
<h3 id=鸡和蛋的问题>鸡和蛋的问题</h3>
<p>云管理控制器的目标是将云服务特性的开发从 Kubernetes 核心项目中解耦。
不幸的是，Kubernetes 项目的许多方面都假设云服务提供商的特性同项目紧密结合。
因此，这种新架构的采用可能导致某些场景下，当一个请求需要从云服务提供商获取信息时，
在该请求没有完成的情况下云管理控制器不能返回那些信息。</p>
<p>Kubelet 中的 TLS 引导特性是一个很好的例子。
目前，TLS 引导认为 kubelet 有能力从云提供商（或本地元数据服务）获取所有的地址类型（私有、公用等），
但在被初始化之前，云管理控制器不能设置节点地址类型，而这需要 kubelet 拥有
TLS 证书以和 API 服务器通信。</p>
<p>随着整个动议的演进，将来的发行版中将作出改变来解决这些问题。</p>
<h2 id=what-s-next>What's next</h2>
<p>要构建和开发你自己的云管理控制器，请阅读
<a href=/zh/docs/tasks/administer-cluster/developing-cloud-controller-manager/>开发云管理控制器</a>
文档。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-c4d0832845adc92b7ccd54aed63fc932>3.8 - 为 Kubernetes 运行 etcd 集群</h1>
<p>etcd 是兼具一致性和高可用性的键值数据库，可以作为保存 Kubernetes 所有集群数据的后台数据库。</p>
<p>您的 Kubernetes 集群的 etcd 数据库通常需要有个备份计划。</p>
<p>要了解 etcd 更深层次的信息，请参考 <a href=https://etcd.io/docs/>etcd 文档</a>。</p>
<h2 id=before-you-begin>Before you begin</h2>
<p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li>
</ul>
To check the version, enter <code>kubectl version</code>.
</p>
<h2 id=先决条件>先决条件</h2>
<ul>
<li>
<p>运行的 etcd 集群个数成员为奇数。</p>
</li>
<li>
<p>etcd 是一个 leader-based 分布式系统。确保主节点定期向所有从节点发送心跳，以保持集群稳定。</p>
</li>
<li>
<p>确保不发生资源不足。</p>
<p>集群的性能和稳定性对网络和磁盘 I/O 非常敏感。任何资源匮乏都会导致心跳超时，
从而导致集群的不稳定。不稳定的情况表明没有选出任何主节点。
在这种情况下，集群不能对其当前状态进行任何更改，这意味着不能调度新的 pod。</p>
</li>
<li>
<p>保持 etcd 集群的稳定对 Kubernetes 集群的稳定性至关重要。
因此，请在专用机器或隔离环境上运行 etcd 集群，以满足
<a href=https://etcd.io/docs/current/op-guide/hardware/>所需资源需求</a>。</p>
</li>
<li>
<p>在生产中运行的 etcd 的最低推荐版本是 <code>3.2.10+</code>。</p>
</li>
</ul>
<h2 id=资源要求>资源要求</h2>
<p>使用有限的资源运行 etcd 只适合测试目的。为了在生产中部署，需要先进的硬件配置。
在生产中部署 etcd 之前，请查看
<a href=https://etcd.io/docs/current/op-guide/hardware/#example-hardware-configurations>所需资源参考文档</a>。</p>
<h2 id=启动-etcd-集群>启动 etcd 集群</h2>
<p>本节介绍如何启动单节点和多节点 etcd 集群。</p>
<h3 id=单节点-etcd-集群>单节点 etcd 集群</h3>
<p>只为测试目的使用单节点 etcd 集群。</p>
<ol>
<li>
<p>运行以下命令：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>etcd --listen-client-urls<span style=color:#666>=</span>http://<span style=color:#b8860b>$PRIVATE_IP</span>:2379 <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>   --advertise-client-urls<span style=color:#666>=</span>http://<span style=color:#b8860b>$PRIVATE_IP</span>:2379
</code></pre></div></li>
<li>
<p>使用参数 <code>--etcd-servers=$PRIVATE_IP:2379</code> 启动 Kubernetes API 服务器。</p>
<p>确保将 <code>PRIVATE_IP</code> 设置为etcd客户端 IP。</p>
</li>
</ol>
<h3 id=多节点-etcd-集群>多节点 etcd 集群</h3>
<p>为了耐用性和高可用性，在生产中将以多节点集群的方式运行 etcd，并且定期备份。
建议在生产中使用五个成员的集群。
有关该内容的更多信息，请参阅
<a href=https://etcd.io/docs/current/faq/#what-is-failure-tolerance>常见问题文档</a>。</p>
<p>可以通过静态成员信息或动态发现的方式配置 etcd 集群。
有关集群的详细信息，请参阅
<a href=https://etcd.io/docs/current/op-guide/clustering/>etcd 集群文档</a>。</p>
<p>例如，考虑运行以下客户端 URL 的五个成员的 etcd 集群：<code>http://$IP1:2379</code>，
<code>http://$IP2:2379</code>，<code>http://$IP3:2379</code>，<code>http://$IP4:2379</code> 和 <code>http://$IP5:2379</code>。
要启动 Kubernetes API 服务器：</p>
<ol>
<li>
<p>运行以下命令：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>etcd --listen-client-urls<span style=color:#666>=</span>http://<span style=color:#b8860b>$IP1</span>:2379,http://<span style=color:#b8860b>$IP2</span>:2379,http://<span style=color:#b8860b>$IP3</span>:2379,http://<span style=color:#b8860b>$IP4</span>:2379,http://<span style=color:#b8860b>$IP5</span>:2379 --advertise-client-urls<span style=color:#666>=</span>http://<span style=color:#b8860b>$IP1</span>:2379,http://<span style=color:#b8860b>$IP2</span>:2379,http://<span style=color:#b8860b>$IP3</span>:2379,http://<span style=color:#b8860b>$IP4</span>:2379,http://<span style=color:#b8860b>$IP5</span>:2379
</code></pre></div></li>
<li>
<p>使用参数 <code>--etcd-servers=$IP1:2379,$IP2:2379,$IP3:2379,$IP4:2379,$IP5:2379</code>
启动 Kubernetes API 服务器。</p>
<p>确保将 <code>IP&lt;n></code> 变量设置为客户端 IP 地址。</p>
</li>
</ol>
<h3 id=使用负载均衡的多节点-etcd-集群>使用负载均衡的多节点 etcd 集群</h3>
<p>要运行负载均衡的 etcd 集群：</p>
<ol>
<li>建立一个 etcd 集群。</li>
<li>在 etcd 集群前面配置负载均衡器。例如，让负载均衡器的地址为 <code>$LB</code>。</li>
<li>使用参数 <code>--etcd-servers=$LB:2379</code> 启动 Kubernetes API 服务器。</li>
</ol>
<h2 id=安全的-etcd-集群>安全的 etcd 集群</h2>
<p>对 etcd 的访问相当于集群中的 root 权限，因此理想情况下只有 API 服务器才能访问它。
考虑到数据的敏感性，建议只向需要访问 etcd 集群的节点授予权限。</p>
<p>想要确保 etcd 的安全，可以设置防火墙规则或使用 etcd 提供的安全特性，这些安全特性依赖于 x509 公钥基础设施（PKI）。
首先，通过生成密钥和证书对来建立安全的通信通道。
例如，使用密钥对 <code>peer.key</code> 和 <code>peer.cert</code> 来保护 etcd 成员之间的通信，
而 <code>client.key</code> 和 <code>client.cert</code> 用于保护 etcd 与其客户端之间的通信。
请参阅 etcd 项目提供的<a href=https://github.com/coreos/etcd/tree/master/hack/tls-setup>示例脚本</a>，
以生成用于客户端身份验证的密钥对和 CA 文件。</p>
<h3 id=安全通信>安全通信</h3>
<p>若要使用安全对等通信对 etcd 进行配置，请指定参数 <code>--peer-key-file=peer.key</code>
和 <code>--peer-cert-file=peer.cert</code>，并使用 HTTPS 作为 URL 模式。</p>
<p>类似地，要使用安全客户端通信对 etcd 进行配置，请指定参数 <code>--key-file=k8sclient.key</code>
和 <code>--cert-file=k8sclient.cert</code>，并使用 HTTPS 作为 URL 模式。
使用安全通信的客户端命令的示例：</p>
<pre><code>ETCDCTL_API=3 etcdctl --endpoints 10.2.0.9:2379 \
  --cert=/etc/kubernetes/pki/etcd/client.crt \
  --key=/etc/kubernetes/pki/etcd/client.key \
  --cacert=/etc/kubernetes/pki/etcd/ca.crt \
  member list
</code></pre>
<h3 id=限制-etcd-集群的访问>限制 etcd 集群的访问</h3>
<p>配置安全通信后，将 etcd 集群的访问限制在 Kubernetes API 服务器上。使用 TLS 身份验证来完成此任务。</p>
<p>例如，考虑由 CA <code>etcd.ca</code> 信任的密钥对 <code>k8sclient.key</code> 和 <code>k8sclient.cert</code>。
当 etcd 配置为 <code>--client-cert-auth</code> 和 TLS 时，它使用系统 CA 或由 <code>--trusted-ca-file</code> 参数传入的 CA 验证来自客户端的证书。
指定参数 <code>--client-cert-auth=true</code> 和 <code>--trusted-ca-file=etcd.ca</code> 将限制对具有证书 <code>k8sclient.cert</code> 的客户端的访问。</p>
<p>一旦正确配置了 etcd，只有具有有效证书的客户端才能访问它。要让 Kubernetes API 服务器访问，
可以使用参数 <code>--etcd-certfile=k8sclient.cert</code>,<code>--etcd-keyfile=k8sclient.key</code> 和 <code>--etcd-cafile=ca.cert</code> 配置。</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> Kubernetes 目前不支持 etcd 身份验证。
想要了解更多信息，请参阅相关的问题
<a href=https://github.com/kubernetes/kubernetes/issues/23398>支持 etcd v2 的基本认证</a>。
</div>
<h2 id=替换失败的-etcd-成员>替换失败的 etcd 成员</h2>
<p>etcd 集群通过容忍少数成员故障实现高可用性。
但是，要改善集群的整体健康状况，请立即替换失败的成员。当多个成员失败时，逐个替换它们。
替换失败成员需要两个步骤：删除失败成员和添加新成员。</p>
<p>虽然 etcd 在内部保留唯一的成员 ID，但建议为每个成员使用唯一的名称，以避免人为错误。
例如，考虑一个三成员的 etcd 集群。让 URL 为：<code>member1=http://10.0.0.1</code>， <code>member2=http://10.0.0.2</code>
和 <code>member3=http://10.0.0.3</code>。当 <code>member1</code> 失败时，将其替换为 <code>member4=http://10.0.0.4</code>。</p>
<ol>
<li>
<p>获取失败的 <code>member1</code> 的成员 ID：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>etcdctl --endpoints<span style=color:#666>=</span>http://10.0.0.2,http://10.0.0.3 member list
</code></pre></div><p>显示以下信息：</p>
<pre><code class=language-console data-lang=console>8211f1d0f64f3269, started, member1, http://10.0.0.1:2380, http://10.0.0.1:2379
91bc3c398fb3c146, started, member2, http://10.0.0.2:2380, http://10.0.0.2:2379
fd422379fda50e48, started, member3, http://10.0.0.3:2380, http://10.0.0.3:2379
</code></pre></li>
<li>
<p>移除失败的成员</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>etcdctl member remove 8211f1d0f64f3269
</code></pre></div><p>显示以下信息：</p>
<pre><code class=language-console data-lang=console>Removed member 8211f1d0f64f3269 from cluster
</code></pre></li>
<li>
<p>增加新成员：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>etcdctl member add member4 --peer-urls<span style=color:#666>=</span>http://10.0.0.4:2380
</code></pre></div><p>显示以下信息：</p>
<pre><code class=language-console data-lang=console>Member 2be1eb8f84b7f63e added to cluster ef37ad9dc622a7c4
</code></pre></li>
<li>
<p>在 IP 为 <code>10.0.0.4</code> 的机器上启动新增加的成员：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#a2f>export</span> <span style=color:#b8860b>ETCD_NAME</span><span style=color:#666>=</span><span style=color:#b44>&#34;member4&#34;</span>
<span style=color:#a2f>export</span> <span style=color:#b8860b>ETCD_INITIAL_CLUSTER</span><span style=color:#666>=</span><span style=color:#b44>&#34;member2=http://10.0.0.2:2380,member3=http://10.0.0.3:2380,member4=http://10.0.0.4:2380&#34;</span>
<span style=color:#a2f>export</span> <span style=color:#b8860b>ETCD_INITIAL_CLUSTER_STATE</span><span style=color:#666>=</span>existing
etcd <span style=color:#666>[</span>flags<span style=color:#666>]</span>
</code></pre></div></li>
<li>
<p>做以下事情之一：</p>
<ol>
<li>更新 Kubernetes API 服务器的 <code>--etcd-servers</code> 参数，使 Kubernetes 知道配置进行了更改，然后重新启动 Kubernetes API 服务器。</li>
<li>如果在 deployment 中使用了负载均衡，更新负载均衡配置。</li>
</ol>
</li>
</ol>
<p>有关集群重新配置的详细信息，请参阅 <a href=https://etcd.io/docs/current/op-guide/runtime-configuration/#remove-a-member>etcd 重构文档</a>。</p>
<h2 id=备份-etcd-集群>备份 etcd 集群</h2>
<p>所有 Kubernetes 对象都存储在 etcd 上。定期备份 etcd 集群数据对于在灾难场景（例如丢失所有控制平面节点）下恢复 Kubernetes 集群非常重要。
快照文件包含所有 Kubernetes 状态和关键信息。为了保证敏感的 Kubernetes 数据的安全，可以对快照文件进行加密。</p>
<p>备份 etcd 集群可以通过两种方式完成：etcd 内置快照和卷快照。</p>
<h3 id=内置快照>内置快照</h3>
<p>etcd 支持内置快照。快照可以从使用 <code>etcdctl snapshot save</code> 命令的活动成员中获取，
也可以通过从 etcd <a href=https://etcd.io/docs/current/op-guide/configuration/#--data-dir>数据目录</a>
复制 <code>member/snap/db</code> 文件，该 etcd 数据目录目前没有被 etcd 进程使用。获取快照不会影响成员的性能。</p>
<p>下面是一个示例，用于获取 <code>$ENDPOINT</code> 所提供的键空间的快照到文件 <code>snapshotdb</code>：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#b8860b>ETCDCTL_API</span><span style=color:#666>=</span><span style=color:#666>3</span> etcdctl --endpoints <span style=color:#b8860b>$ENDPOINT</span> snapshot save snapshotdb
</code></pre></div><p>验证快照:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#b8860b>ETCDCTL_API</span><span style=color:#666>=</span><span style=color:#666>3</span> etcdctl --write-out<span style=color:#666>=</span>table snapshot status snapshotdb
</code></pre></div><pre><code class=language-console data-lang=console>+----------+----------+------------+------------+
|   HASH   | REVISION | TOTAL KEYS | TOTAL SIZE |
+----------+----------+------------+------------+
| fe01cf57 |       10 |          7 | 2.1 MB     |
+----------+----------+------------+------------+
</code></pre>
<h3 id=卷快照>卷快照</h3>
<p>如果 etcd 运行在支持备份的存储卷（如 Amazon Elastic Block 存储）上，则可以通过获取存储卷的快照来备份 etcd 数据。</p>
<h3 id=使用-etcdctl-选项的快照>使用 etcdctl 选项的快照</h3>
<p>我们还可以使用 etcdctl 提供的各种选项来拍摄快照。例如：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#b8860b>ETCDCTL_API</span><span style=color:#666>=</span><span style=color:#666>3</span> etcdctl -h 
</code></pre></div><p>列出 etcdctl 可用的各种选项。例如，你可以通过指定端点，证书等来拍摄快照，如下所示：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#b8860b>ETCDCTL_API</span><span style=color:#666>=</span><span style=color:#666>3</span> etcdctl --endpoints<span style=color:#666>=</span>https://127.0.0.1:2379 <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --cacert<span style=color:#666>=</span>&lt;trusted-ca-file&gt; --cert<span style=color:#666>=</span>&lt;cert-file&gt; --key<span style=color:#666>=</span>&lt;key-file&gt; <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  snapshot save &lt;backup-file-location&gt;
</code></pre></div><p>可以从 etcd Pod 的描述中获得 <code>trusted-ca-file</code>, <code>cert-file</code> 和 <code>key-file</code> 。</p>
<h2 id=扩展-etcd-集群>扩展 etcd 集群</h2>
<p>通过交换性能，扩展 etcd 集群可以提高可用性。缩放不会提高集群性能和能力。
一般情况下不要扩大或缩小 etcd 集群的集合。不要为 etcd 集群配置任何自动缩放组。
强烈建议始终在任何官方支持的规模上运行生产 Kubernetes 集群时使用静态的五成员 etcd 集群。</p>
<p>合理的扩展是在需要更高可靠性的情况下，将三成员集群升级为五成员集群。
请参阅 <a href=https://etcd.io/docs/current/op-guide/runtime-configuration/#remove-a-member>etcd 重新配置文档</a>
以了解如何将成员添加到现有集群中的信息。</p>
<h2 id=恢复-etcd-集群>恢复 etcd 集群</h2>
<p>etcd 支持从 <a href=http://semver.org/>major.minor</a> 或其他不同 patch 版本的 etcd 进程中获取的快照进行恢复。
还原操作用于恢复失败的集群的数据。</p>
<p>在启动还原操作之前，必须有一个快照文件。它可以是来自以前备份操作的快照文件，
也可以是来自剩余<a href=https://etcd.io/docs/current/op-guide/configuration/#--data-dir>数据目录</a>的快照文件。
例如：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#b8860b>ETCDCTL_API</span><span style=color:#666>=</span><span style=color:#666>3</span> etcdctl --endpoints 10.2.0.9:2379 snapshot restore snapshotdb
</code></pre></div><p>恢复时也可以指定操作选项，例如：</p>
<pre><code>ETCDCTL_API=3 etcdctl --data-dir &lt;data-dir-location&gt; snapshot restore snapshotdb
</code></pre><p>有关从快照文件还原集群的详细信息和示例，请参阅
<a href=https://etcd.io/docs/current/op-guide/recovery/#restoring-a-cluster>etcd 灾难恢复文档</a>。</p>
<p>如果还原的集群的访问 URL 与前一个集群不同，则必须相应地重新配置 Kubernetes API 服务器。
在本例中，使用参数 <code>--etcd-servers=$NEW_ETCD_CLUSTER</code> 而不是参数 <code>--etcd-servers=$OLD_ETCD_CLUSTER</code> 重新启动 Kubernetes API 服务器。
用相应的 IP 地址替换 <code>$NEW_ETCD_CLUSTER</code> 和 <code>$OLD_ETCD_CLUSTER</code>。如果在 etcd 集群前面使用负载平衡，则可能需要更新负载均衡器。</p>
<p>如果大多数 etcd 成员永久失败，则认为 etcd 集群失败。在这种情况下，Kubernetes 不能对其当前状态进行任何更改。
虽然已调度的 pod 可能继续运行，但新的 pod 无法调度。在这种情况下，恢复 etcd 集群并可能需要重新配置 Kubernetes API 服务器以修复问题。</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> <p>如果集群中正在运行任何 API 服务器，则不应尝试还原 etcd 的实例。相反，请按照以下步骤还原 etcd：</p>
<ul>
<li>停止 <em>所有</em> API 服务实例</li>
<li>在所有 etcd 实例中恢复状态</li>
<li>重启所有 API 服务实例</li>
</ul>
<p>我们还建议重启所有组件（例如 <code>kube-scheduler</code>、<code>kube-controller-manager</code>、<code>kubelet</code>），以确保它们不会
依赖一些过时的数据。请注意，实际中还原会花费一些时间。
在还原过程中，关键组件将丢失领导锁并自行重启。</p>
</div>
<h2 id=升级-etcd-集群>升级 etcd 集群</h2>
<p>有关 etcd 升级的更多详细信息，请参阅 <a href=https://etcd.io/docs/latest/upgrades/>etcd 升级</a>文档。
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 在开始升级之前，请先备份你的 etcd 集群。
</div></p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-b64a1d2bb3f4ed9f7021134e09a75c36>3.9 - 为系统守护进程预留计算资源</h1>
<p>Kubernetes 的节点可以按照 <code>Capacity</code> 调度。默认情况下 pod 能够使用节点全部可用容量。
这是个问题，因为节点自己通常运行了不少驱动 OS 和 Kubernetes 的系统守护进程。
除非为这些系统守护进程留出资源，否则它们将与 pod 争夺资源并导致节点资源短缺问题。</p>
<p><code>kubelet</code> 公开了一个名为 'Node Allocatable' 的特性，有助于为系统守护进程预留计算资源。
Kubernetes 推荐集群管理员按照每个节点上的工作负载密度配置 <code>Node Allocatable</code>。</p>
<h2 id=before-you-begin>Before you begin</h2>
<p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li>
</ul>
Your Kubernetes server must be at or later than version 1.8.
To check the version, enter <code>kubectl version</code>.
</p>
<p>您的 kubernetes 服务器版本必须至少是 1.17 版本，才能使用 kubelet
命令行选项 <code>--reserved-cpus</code> 设置
<a href=#explicitly-reserved-cpu-list>显式预留 CPU 列表</a>。</p>
<h2 id=node-allocatable>节点可分配 </h2>
<p><img src=/images/docs/node-capacity.svg alt=节点容量></p>
<p>Kubernetes 节点上的 'Allocatable' 被定义为 pod 可用计算资源量。
调度器不会超额申请 'Allocatable'。
目前支持 'CPU', 'memory' 和 'ephemeral-storage' 这几个参数。</p>
<p>可分配的节点暴露为 API 中 <code>v1.Node</code> 对象的一部分，也是 CLI 中
<code>kubectl describe node</code> 的一部分。</p>
<p>在 <code>kubelet</code> 中，可以为两类系统守护进程预留资源。</p>
<h3 id=启用-qos-和-pod-级别的-cgroups>启用 QoS 和 Pod 级别的 cgroups</h3>
<p>为了恰当的在节点范围实施节点可分配约束，你必须通过 <code>--cgroups-per-qos</code>
标志启用新的 cgroup 层次结构。这个标志是默认启用的。
启用后，<code>kubelet</code> 将在其管理的 cgroup 层次结构中创建所有终端用户的 Pod。</p>
<h3 id=配置-cgroup-驱动>配置 cgroup 驱动</h3>
<p><code>kubelet</code> 支持在主机上使用 cgroup 驱动操作 cgroup 层次结构。
驱动通过 <code>--cgroup-driver</code> 标志配置。</p>
<p>支持的参数值如下：</p>
<ul>
<li><code>cgroupfs</code> 是默认的驱动，在主机上直接操作 cgroup 文件系统以对 cgroup
沙箱进行管理。</li>
<li><code>systemd</code> 是可选的驱动，使用 init 系统支持的资源的瞬时切片管理
cgroup 沙箱。</li>
</ul>
<p>取决于相关容器运行时的配置，操作员可能需要选择一个特定的 cgroup 驱动
来保证系统正常运行。
例如，如果操作员使用 <code>docker</code> 运行时提供的 <code>systemd</code> cgroup 驱动时，
必须配置 <code>kubelet</code> 使用 <code>systemd</code> cgroup 驱动。</p>
<h3 id=kube-reserved>Kube 预留值 </h3>
<ul>
<li><strong>Kubelet 标志</strong>: <code>--kube-reserved=[cpu=100m][,][memory=100Mi][,][ephemeral-storage=1Gi][,][pid=1000]</code></li>
<li><strong>Kubelet 标志</strong>: <code>--kube-reserved-cgroup=</code></li>
</ul>
<p><code>kube-reserved</code> 用来给诸如 <code>kubelet</code>、容器运行时、节点问题监测器等
kubernetes 系统守护进程记述其资源预留值。
该配置并非用来给以 Pod 形式运行的系统守护进程保留资源。<code>kube-reserved</code>
通常是节点上 <code>pod 密度</code> 的函数。</p>
<p>除了 <code>cpu</code>，<code>内存</code> 和 <code>ephemeral-storage</code> 之外，<code>pid</code> 可用来指定为
kubernetes 系统守护进程预留指定数量的进程 ID。</p>
<p>要选择性地对 kubernetes 系统守护进程上执行 <code>kube-reserved</code> 保护，需要把 kubelet 的
<code>--kube-reserved-cgroup</code> 标志的值设置为 kube 守护进程的父控制组。</p>
<p>推荐将 kubernetes 系统守护进程放置于顶级控制组之下（例如 systemd 机器上的
<code>runtime.slice</code>）。
理想情况下每个系统守护进程都应该在其自己的子控制组中运行。
请参考
<a href=https://git.k8s.io/design-proposals-archive/node/node-allocatable.md#recommended-cgroups-setup>这个设计方案</a>，
进一步了解关于推荐控制组层次结构的细节。</p>
<p>请注意，如果 <code>--kube-reserved-cgroup</code> 不存在，Kubelet 将 <strong>不会</strong> 创建它。
如果指定了一个无效的 cgroup，Kubelet 将会失败。</p>
<h3 id=system-reserved>系统预留值 </h3>
<ul>
<li><strong>Kubelet 标志</strong>: <code>--system-reserved=[cpu=100m][,][memory=100Mi][,][ephemeral-storage=1Gi][,][pid=1000]</code></li>
<li><strong>Kubelet 标志</strong>: <code>--system-reserved-cgroup=</code></li>
</ul>
<p><code>system-reserved</code> 用于为诸如 <code>sshd</code>、<code>udev</code> 等系统守护进程记述其资源预留值。
<code>system-reserved</code> 也应该为 <code>kernel</code> 预留 <code>内存</code>，因为目前 <code>kernel</code>
使用的内存并不记在 Kubernetes 的 Pod 上。
同时还推荐为用户登录会话预留资源（systemd 体系中的 <code>user.slice</code>）。</p>
<p>除了 <code>cpu</code>，<code>内存</code> 和 <code>ephemeral-storage</code> 之外，<code>pid</code> 可用来指定为
kubernetes 系统守护进程预留指定数量的进程 ID。</p>
<p>要想为系统守护进程上可选地实施 <code>system-reserved</code> 约束，请指定 kubelet 的
<code>--system-reserved-cgroup</code> 标志值为 OS 系统守护进程的父级控制组。</p>
<p>推荐将 OS 系统守护进程放在一个顶级控制组之下（例如 systemd 机器上的
<code>system.slice</code>）。</p>
<p>请注意，如果 <code>--system-reserved-cgroup</code> 不存在，<code>kubelet</code> <strong>不会</strong> 创建它。
如果指定了无效的 cgroup，<code>kubelet</code> 将会失败。</p>
<h3 id=explicitly-reserved-cpu-list>显式保留的 CPU 列表</h3>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.17 [stable]</code>
</div>
<p>-<strong>Kubelet 标志</strong>: <code>--reserved-cpus=0-3</code></p>
<p><code>reserved-cpus</code> 旨在为操作系统守护程序和 kubernetes 系统守护程序保留一组明确指定编号的
CPU。<code>reserved-cpus</code> 适用于不打算针对 cpuset 资源为操作系统守护程序和 kubernetes
系统守护程序定义独立的顶级 cgroups 的系统。
如果 Kubelet <strong>没有</strong> 指定参数 <code>--system-reserved-cgroup</code> 和 <code>--kube-reserved-cgroup</code>，
则 <code>reserved-cpus</code> 的设置将优先于 <code>--kube-reserved</code> 和 <code>--system-reserved</code> 选项。</p>
<p>此选项是专门为电信/NFV 用例设计的，在这些用例中不受控制的中断或计时器可能会
影响其工作负载性能。
你可以使用此选项为系统或 kubernetes 守护程序以及中断或计时器显式定义 cpuset，
这样系统上的其余 CPU 可以专门用于工作负载，因不受控制的中断或计时器的影响得以
降低。
要将系统守护程序、kubernetes 守护程序和中断或计时器移动到此选项定义的显式
cpuset 上，应使用 Kubernetes 之外的其他机制。
例如：在 Centos 系统中，可以使用 tuned 工具集来执行此操作。</p>
<h3 id=eviction-Thresholds>驱逐阈值 </h3>
<ul>
<li><strong>Kubelet 标志</strong>: <code>--eviction-hard=[memory.available&lt;500Mi]</code></li>
</ul>
<p>节点级别的内存压力将导致系统内存不足，这将影响到整个节点及其上运行的所有 Pod。
节点可以暂时离线直到内存已经回收为止。
为了防止（或减少可能性）系统内存不足，kubelet 提供了
<a href=/zh/docs/concepts/scheduling-eviction/node-pressure-eviction/>资源不足</a>管理。
驱逐操作只支持 <code>memory</code> 和 <code>ephemeral-storage</code>。
通过 <code>--eviction-hard</code> 标志预留一些内存后，当节点上的可用内存降至保留值以下时，
<code>kubelet</code> 将尝试驱逐 Pod。
如果节点上不存在系统守护进程，Pod 将不能使用超过 <code>capacity-eviction-hard</code> 所
指定的资源量。因此，为驱逐而预留的资源对 Pod 是不可用的。</p>
<h3 id=enforcing-node-allocatable>实施节点可分配约束 </h3>
<p>-<strong>Kubelet 标志</strong>: <code>--enforce-node-allocatable=pods[,][system-reserved][,][kube-reserved]</code></p>
<p>调度器将 'Allocatable' 视为 Pod 可用的 <code>capacity</code>（资源容量）。</p>
<p><code>kubelet</code> 默认对 Pod 执行 'Allocatable' 约束。
无论何时，如果所有 Pod 的总用量超过了 'Allocatable'，驱逐 Pod 的措施将被执行。
有关驱逐策略的更多细节可以在
<a href=/zh/docs/concepts/scheduling-eviction/pod-priority-preemption/>节点压力驱逐</a>页找到。
可通过设置 kubelet <code>--enforce-node-allocatable</code> 标志值为 <code>pods</code> 控制这个措施。</p>
<p>可选地，通过在同一标志中同时指定 <code>kube-reserved</code> 和 <code>system-reserved</code> 值，
可以使 <code>kubelet</code> 强制实施 <code>kube-reserved</code> 和 <code>system-reserved</code>约束。
请注意，要想执行 <code>kube-reserved</code> 或者 <code>system-reserved</code> 约束，
需要对应设置 <code>--kube-reserved-cgroup</code> 或者 <code>--system-reserved-cgroup</code>。</p>
<h2 id=general-guidelines>一般原则 </h2>
<p>系统守护进程一般会被按照类似
<a href=/zh/docs/tasks/configure-pod-container/quality-service-pod/#create-a-pod-that-gets-assigned-a-qos-class-of-guaranteed>Guaranteed pods</a>
一样对待。
系统守护进程可以在与其对应的控制组中出现突发资源用量，这一行为要作为
kubernetes 部署的一部分进行管理。
例如，<code>kubelet</code> 应该有它自己的控制组并和容器运行时共享 <code>Kube-reserved</code> 资源。
不过，如果执行了 <code>kube-reserved</code> 约束，则 kubelet 不可出现突发负载并用光
节点的所有可用资源。</p>
<p>在执行 <code>system-reserved</code> 预留策略时请加倍小心，因为它可能导致节点上的
关键系统服务出现 CPU 资源短缺、因为内存不足而被终止或者无法在节点上创建进程。
建议只有当用户详尽地描述了他们的节点以得出精确的估计值，
并且对该组中进程因内存不足而被杀死时，有足够的信心将其恢复时，
才可以强制执行 <code>system-reserved</code> 策略。</p>
<ul>
<li>作为起步，可以先针对 <code>pods</code> 上执行 'Allocatable' 约束。</li>
<li>一旦用于追踪系统守护进程的监控和告警的机制到位，可尝试基于用量估计的
方式执行 <code>kube-reserved</code>策略。</li>
<li>随着时间推进，在绝对必要的时候可以执行 <code>system-reserved</code> 策略。</li>
</ul>
<p>随着时间推进和越来越多特性被加入，kube 系统守护进程对资源的需求可能也会增加。
以后 kubernetes 项目将尝试减少对节点系统守护进程的利用，但目前这件事的优先级
并不是最高。
所以，将来的发布版本中 <code>Allocatable</code> 容量是有可能降低的。</p>
<h2 id=example-scenario>示例场景 </h2>
<p>这是一个用于说明节点可分配（Node Allocatable）计算方式的示例：</p>
<ul>
<li>节点拥有 <code>32Gi</code> <code>memeory</code>，<code>16 CPU</code> 和 <code>100Gi</code> <code>Storage</code> 资源</li>
<li><code>--kube-reserved</code> 被设置为 <code>cpu=1,memory=2Gi,ephemeral-storage=1Gi</code></li>
<li><code>--system-reserved</code> 被设置为 <code>cpu=500m,memory=1Gi,ephemeral-storage=1Gi</code></li>
<li><code>--eviction-hard</code> 被设置为 <code>memory.available&lt;500Mi,nodefs.available&lt;10%</code></li>
</ul>
<p>在这个场景下，'Allocatable' 将会是 14.5 CPUs、28.5Gi 内存以及 <code>88Gi</code> 本地存储。
调度器保证这个节点上的所有 Pod 的内存 <code>requests</code> 总量不超过 28.5Gi，
存储不超过 '88Gi'。
当 Pod 的内存使用总量超过 28.5Gi 或者磁盘使用总量超过 88Gi 时，
kubelet 将会驱逐它们。
如果节点上的所有进程都尽可能多地使用 CPU，则 Pod 加起来不能使用超过
14.5 CPUs 的资源。</p>
<p>当没有执行 <code>kube-reserved</code> 和/或 <code>system-reserved</code> 策略且系统守护进程
使用量超过其预留时，如果节点内存用量高于 31.5Gi 或<code>存储</code>大于 90Gi，
kubelet 将会驱逐 Pod。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-a8f6511197efcd7d0db80ade49620f9d>3.10 - 为节点发布扩展资源</h1>
<p>本文展示了如何为节点指定扩展资源（Extended Resource）。
扩展资源允许集群管理员发布节点级别的资源，这些资源在不进行发布的情况下无法被 Kubernetes 感知。</p>
<h2 id=before-you-begin>Before you begin</h2>
<p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li>
</ul>
To check the version, enter <code>kubectl version</code>.
</p>
<h2 id=获取你的节点名称>获取你的节点名称</h2>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get nodes
</code></pre></div><p>选择一个节点用于此练习。</p>
<h2 id=在你的一个节点上发布一种新的扩展资源>在你的一个节点上发布一种新的扩展资源</h2>
<p>为在一个节点上发布一种新的扩展资源，需要发送一个 HTTP PATCH 请求到 Kubernetes API server。
例如：假设你的一个节点上带有四个 dongle 资源。
下面是一个 PATCH 请求的示例，该请求为你的节点发布四个 dongle 资源。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>PATCH /api/v1/nodes/&lt;your-node-name&gt;/status HTTP/1.1
Accept: application/json
Content-Type: application/json-patch+json
Host: k8s-master:8080

<span style=color:#666>[</span>
  <span style=color:#666>{</span>
    <span style=color:#b44>&#34;op&#34;</span>: <span style=color:#b44>&#34;add&#34;</span>,
    <span style=color:#b44>&#34;path&#34;</span>: <span style=color:#b44>&#34;/status/capacity/example.com~1dongle&#34;</span>,
    <span style=color:#b44>&#34;value&#34;</span>: <span style=color:#b44>&#34;4&#34;</span>
  <span style=color:#666>}</span>
<span style=color:#666>]</span>
</code></pre></div>
<p>注意：Kubernetes 不需要了解 dongle 资源的含义和用途。
前面的 PATCH 请求告诉 Kubernetes 你的节点拥有四个你称之为 dongle 的东西。</p>
<p>启动一个代理（proxy），以便你可以很容易地向 Kubernetes API server 发送请求：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl proxy
</code></pre></div>
<p>在另一个命令窗口中，发送 HTTP PATCH 请求。 用你的节点名称替换 <code>&lt;your-node-name></code>：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>curl --header <span style=color:#b44>&#34;Content-Type: application/json-patch+json&#34;</span> <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --request PATCH <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --data <span style=color:#b44>&#39;[{&#34;op&#34;: &#34;add&#34;, &#34;path&#34;: &#34;/status/capacity/example.com~1dongle&#34;, &#34;value&#34;: &#34;4&#34;}]&#39;</span> <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  http://localhost:8001/api/v1/nodes/&lt;your-node-name&gt;/status
</code></pre></div>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 在前面的请求中，<code>~1</code> 为 patch 路径中 “/” 符号的编码。
JSON-Patch 中的操作路径值被解析为 JSON 指针。
更多细节，请查看 <a href=https://tools.ietf.org/html/rfc6901>IETF RFC 6901</a> 的第 3 节。
</div>
<p>输出显示该节点的 dongle 资源容量（capacity）为 4：</p>
<pre><code>&quot;capacity&quot;: {
  &quot;cpu&quot;: &quot;2&quot;,
  &quot;memory&quot;: &quot;2049008Ki&quot;,
  &quot;example.com/dongle&quot;: &quot;4&quot;,
</code></pre>
<p>描述你的节点：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe node &lt;your-node-name&gt;
</code></pre></div>
<p>输出再次展示了 dongle 资源：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>Capacity</span>:<span style=color:#bbb>
</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb>  </span><span style=color:#666>2</span><span style=color:#bbb>
</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb>  </span>2049008Ki<span style=color:#bbb>
</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>example.com/dongle</span>:<span style=color:#bbb>  </span><span style=color:#666>4</span><span style=color:#bbb>
</span></code></pre></div>
<p>现在，应用开发者可以创建请求一定数量 dongle 资源的 Pod 了。
参见<a href=/zh/docs/tasks/configure-pod-container/extended-resource/>将扩展资源分配给容器</a>。</p>
<h2 id=讨论>讨论</h2>
<p>扩展资源类似于内存和 CPU 资源。例如，正如一个节点拥有一定数量的内存和 CPU 资源，
它们被节点上运行的所有组件共享，该节点也可以拥有一定数量的 dongle 资源，
这些资源同样被节点上运行的所有组件共享。
此外，正如应用开发者可以创建请求一定数量的内存和 CPU 资源的 Pod，
他们也可以创建请求一定数量 dongle 资源的 Pod。</p>
<p>扩展资源对 Kubernetes 是不透明的。Kubernetes 不知道扩展资源含义相关的任何信息。
Kubernetes 只了解一个节点拥有一定数量的扩展资源。
扩展资源必须以整形数量进行发布。
例如，一个节点可以发布 4 个 dongle 资源，但是不能发布 4.5 个。</p>
<h3 id=存储示例>存储示例</h3>
<p>假设一个节点拥有一种特殊类型的磁盘存储，其容量为 800 GiB。
你可以为该特殊存储创建一个名称，如 <code>example.com/special-storage</code>。
然后你就可以按照一定规格的块（如 100 GiB）对其进行发布。
在这种情况下，你的节点将会通知它拥有八个 <code>example.com/special-storage</code> 类型的资源。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>Capacity</span>:<span style=color:#bbb>
</span><span style=color:#bbb> </span>...<span style=color:#bbb>
</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>example.com/special-storage</span>:<span style=color:#bbb> </span><span style=color:#666>8</span><span style=color:#bbb>
</span></code></pre></div>
<p>如果你想要允许针对特殊存储任意（数量）的请求，你可以按照 1 字节大小的块来发布特殊存储。
在这种情况下，你将会发布 800Gi 数量的 example.com/special-storage 类型的资源。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>Capacity</span>:<span style=color:#bbb>
</span><span style=color:#bbb> </span>...<span style=color:#bbb>
</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>example.com/special-storage</span>:<span style=color:#bbb>  </span>800Gi<span style=color:#bbb>
</span></code></pre></div>
<p>然后，容器就能够请求任意数量（多达 800Gi）字节的特殊存储。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>Capacity</span>:<span style=color:#bbb>
</span><span style=color:#bbb> </span>...<span style=color:#bbb>
</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>example.com/special-storage</span>:<span style=color:#bbb>  </span>800Gi<span style=color:#bbb>
</span></code></pre></div>
<h2 id=清理>清理</h2>
<p>这里是一个从节点移除 dongle 资源发布的 PATCH 请求。</p>
<pre><code>PATCH /api/v1/nodes/&lt;your-node-name&gt;/status HTTP/1.1
Accept: application/json
Content-Type: application/json-patch+json
Host: k8s-master:8080

[
  {
    &quot;op&quot;: &quot;remove&quot;,
    &quot;path&quot;: &quot;/status/capacity/example.com~1dongle&quot;,
  }
]
</code></pre>
<p>启动一个代理，以便你可以很容易地向 Kubernetes API 服务器发送请求：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl proxy
</code></pre></div>
<p>在另一个命令窗口中，发送 HTTP PATCH 请求。用你的节点名称替换 <code>&lt;your-node-name></code>：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>curl --header <span style=color:#b44>&#34;Content-Type: application/json-patch+json&#34;</span> <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>--request PATCH <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>--data <span style=color:#b44>&#39;[{&#34;op&#34;: &#34;remove&#34;, &#34;path&#34;: &#34;/status/capacity/example.com~1dongle&#34;}]&#39;</span> <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>http://localhost:8001/api/v1/nodes/&lt;your-node-name&gt;/status
</code></pre></div>
<p>验证 dongle 资源的发布已经被移除：</p>
<pre><code>kubectl describe node &lt;your-node-name&gt; | grep dongle
</code></pre>
<p>(你应该看不到任何输出)</p>
<h2 id=what-s-next>What's next</h2>
<h3 id=针对应用开发人员>针对应用开发人员</h3>
<ul>
<li><a href=/zh/docs/tasks/configure-pod-container/extended-resource/>将扩展资源分配给容器</a></li>
</ul>
<h3 id=针对集群管理员>针对集群管理员</h3>
<ul>
<li><a href=/zh/docs/tasks/administer-cluster/manage-resources/memory-constraint-namespace/>为名字空间配置最小和最大内存约束</a></li>
<li><a href=/zh/docs/tasks/administer-cluster/manage-resources/cpu-constraint-namespace/>为名字空间配置最小和最大 CPU 约束</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-f6f3b8f9789fda4286bf410b8e108f69>3.11 - 以非root用户身份运行 Kubernetes 节点组件</h1>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.22 [alpha]</code>
</div>
<p>这个文档描述了怎样不使用 root 特权，而是通过使用 <a class=glossary-tooltip title="一种为非特权用户模拟超级用户特权的 Linux 内核功能特性。" data-toggle=tooltip data-placement=top href=https://man7.org/linux/man-pages/man7/user_namespaces.7.html target=_blank aria-label=用户命名空间>用户命名空间</a>
去运行 Kubernetes 节点组件（例如 kubelet、CRI、OCI、CNI）。</p>
<p>这种技术也叫做 <em>rootless 模式（Rootless mode）</em>。</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 这个文档描述了怎么以非 root 用户身份运行 Kubernetes 节点组件以及 Pod。
如果你只是想了解如何以非 root 身份运行 Pod，请参阅 <a href=/zh/docs/tasks/configure-pod-container/security-context/>SecurityContext</a>。
</div>
<h2 id=before-you-begin>Before you begin</h2>
<p>Your Kubernetes server must be at or later than version 1.22.
To check the version, enter <code>kubectl version</code>.</p>
<ul>
<li><a href=https://rootlesscontaine.rs/getting-started/common/cgroup2/>启用 Cgroup v2</a></li>
<li><a href=https://rootlesscontaine.rs/getting-started/common/login/>在 systemd 中启用 user session</a></li>
<li><a href=https://rootlesscontaine.rs/getting-started/common/sysctl/>根据不同的 Linux 发行版，配置 sysctl 的值</a></li>
<li><a href=https://rootlesscontaine.rs/getting-started/common/subuid/>确保你的非特权用户被列在 <code>/etc/subuid</code> 和 <code>/etc/subgid</code> 文件中</a></li>
<li>启用 <code>KubeletInUserNamespace</code> <a href=/zh/docs/reference/command-line-tools-reference/feature-gates/>特性门控</a></li>
</ul>
<h2 id=使用-rootless-模式的-docker-podman-运行-kubernetes>使用 Rootless 模式的 Docker/Podman 运行 Kubernetes</h2>
<h3 id=kind>kind</h3>
<p><a href=https://kind.sigs.k8s.io/>kind</a> 支持使用 Rootless 模式的 Docker 或者 Podman 运行 Kubernetes。</p>
<p>请参阅<a href=https://kind.sigs.k8s.io/docs/user/rootless/>使用 Rootless 模式的 Docker 运行 kind</a>。</p>
<h3 id=minikube>minikube</h3>
<p><a href=https://minikube.sigs.k8s.io/>minikube</a> 也支持使用 Rootless 模式的 Docker 运行 Kubernetes。</p>
<p>请参阅 Minikube 文档中的 <a href=https://minikube.sigs.k8s.io/docs/drivers/docker/>docker</a> 驱动页面。</p>
<p>它不支持 Rootless 模式的 Podman。</p>
<h2 id=在非特权容器内运行-kubernetes>在非特权容器内运行 Kubernetes</h2>
<div class="alert alert-secondary callout third-party-content" role=alert><strong>Note:</strong>
This section links to third party projects that provide functionality required by Kubernetes. The Kubernetes project authors aren't responsible for these projects, which are listed alphabetically. To add a project to this list, read the <a href=/docs/contribute/style/content-guide/#third-party-content>content guide</a> before submitting a change. <a href=#third-party-content-disclaimer>More information.</a></div>
<h3 id=sysbox>sysbox</h3>
<p><a href=https://github.com/nestybox/sysbox>Sysbox</a> 是一个开源容器运行时
(类似于 “runc”），支持在 Linux 用户命名空间隔离的非特权容器内运行系统级工作负载，
比如 Docker 和 Kubernetes。</p>
<p>查看 <a href=https://github.com/nestybox/sysbox/blob/master/docs/quickstart/kind.md>Sysbox 快速入门指南: Kubernetes-in-Docker</a>
了解更多细节。</p>
<p>Sysbox 支持在非特权容器内运行 Kubernetes，
而不需要 Cgroup v2 和 “KubeletInUserNamespace” 特性门控。
Sysbox 通过在容器内暴露特定的 <code>/proc</code> 和 <code>/sys</code> 文件系统，
以及其它一些先进的操作系统虚拟化技术来实现。</p>
<h2 id=直接在主机上运行-rootless-模式的-kubernetes>直接在主机上运行 Rootless 模式的 Kubernetes</h2>
<div class="alert alert-secondary callout third-party-content" role=alert><strong>Note:</strong>
This section links to third party projects that provide functionality required by Kubernetes. The Kubernetes project authors aren't responsible for these projects, which are listed alphabetically. To add a project to this list, read the <a href=/docs/contribute/style/content-guide/#third-party-content>content guide</a> before submitting a change. <a href=#third-party-content-disclaimer>More information.</a></div>
<h3 id=k3s>K3s</h3>
<p><a href=https://k3s.io/>K3s</a> 实验性支持了 Rootless 模式。</p>
<p>请参阅<a href=https://rancher.com/docs/k3s/latest/en/advanced/#running-k3s-with-rootless-mode-experimental>使用 Rootless 模式运行 K3s</a>
页面中的用法.</p>
<h3 id=usernetes>Usernetes</h3>
<p><a href=https://github.com/rootless-containers/usernetes>Usernetes</a> 是 Kubernetes 的一个参考发行版，
它可以在不使用 root 特权的情况下安装在 <code>$HOME</code> 目录下。</p>
<p>Usernetes 支持使用 containerd 和 CRI-O 作为 CRI 运行时。
Usernetes 支持配置了 Flannel (VXLAN)的多节点集群。</p>
<p>关于用法，请参阅 <a href=https://github.com/rootless-containers/usernetes>Usernetes 仓库</a>。</p>
<h2 id=userns-the-hard-way>手动部署一个在用户命名空间运行 kubelet 的节点</h2>
<p>本节提供在用户命名空间手动运行 Kubernetes 的注意事项。</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 本节是面向 Kubernetes 发行版的开发者，而不是最终用户。
</div>
<h3 id=创建用户命名空间>创建用户命名空间</h3>
<p>第一步是创建一个 <a class=glossary-tooltip title="一种为非特权用户模拟超级用户特权的 Linux 内核功能特性。" data-toggle=tooltip data-placement=top href=https://man7.org/linux/man-pages/man7/user_namespaces.7.html target=_blank aria-label=用户命名空间>用户命名空间</a>。</p>
<p>如果你正在尝试使用用户命名空间的容器（例如 Rootless 模式的 Docker/Podman 或 LXC/LXD）
运行 Kubernetes，那么你已经准备就绪，可以直接跳到下一小节。</p>
<p>否则你需要通过传递参数 <code>CLONE_NEWUSER</code> 调用 <code>unshare(2)</code>，自己创建一个命名空间。</p>
<p>用户命名空间也可以通过如下所示的命令行工具取消共享：</p>
<ul>
<li><a href=https://man7.org/linux/man-pages/man1/unshare.1.html><code>unshare(1)</code></a></li>
<li><a href=https://github.com/rootless-containers/rootlesskit>RootlessKit</a></li>
<li><a href=https://github.com/giuseppe/become-root>become-root</a></li>
</ul>
<p>在取消命名空间的共享之后，你也必须对其它的命名空间例如 mount 命名空间取消共享。</p>
<p>在取消 mount 命名空间的共享之后，你<em>不</em>需要调用 <code>chroot()</code> 或者 <code>pivot_root()</code>，
但是你必须<em>在这个命名空间内</em>挂载可写的文件系统到几个目录上。</p>
<p>请确保<em>这个命名空间内</em>(不是这个命名空间外部)至少以下几个目录是可写的：</p>
<ul>
<li><code>/etc</code></li>
<li><code>/run</code></li>
<li><code>/var/logs</code></li>
<li><code>/var/lib/kubelet</code></li>
<li><code>/var/lib/cni</code></li>
<li><code>/var/lib/containerd</code> (参照 containerd )</li>
<li><code>/var/lib/containers</code> (参照 CRI-O )</li>
</ul>
<h3 id=创建委派-cgroup-树>创建委派 cgroup 树</h3>
<p>除了用户命名空间，你也需要有一个版本为 cgroup v2 的可写 cgroup 树。</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> Kubernetes 需要 cgroup v2 才支持在用户命名空间运行节点组件。
cgroup v1 是不支持的。
</div>
<p>如果你在一个采用 systemd 机制的主机上使用用户命名空间的容器（例如 Rootless 模式的 Docker/Podman
或 LXC/LXD）来运行 Kubernetes，那么你已经准备就绪。</p>
<p>否则你必须创建一个具有 <code>Delegate=yes</code> 属性的 systemd 单元，来委派一个具有可写权限的 cgroup 树。</p>
<p>在你的节点上，systemd 必须已经配置为允许委派。更多细节请参阅 Rootless 容器文档的
<a href=https://rootlesscontaine.rs/getting-started/common/cgroup2/>cgroup v2</a> 部分。</p>
<h3 id=配置网络>配置网络</h3>
<div class="alert alert-secondary callout third-party-content" role=alert><strong>Note:</strong>
This section links to third party projects that provide functionality required by Kubernetes. The Kubernetes project authors aren't responsible for these projects, which are listed alphabetically. To add a project to this list, read the <a href=/docs/contribute/style/content-guide/#third-party-content>content guide</a> before submitting a change. <a href=#third-party-content-disclaimer>More information.</a></div>
<p>节点组件的网络命名空间必须有一个非本地回路的网卡。它可以使用
<a href=https://github.com/rootless-containers/slirp4netns>slirp4netns</a>、
<a href=https://github.com/moby/vpnkit>VPNKit</a>、
<a href=https://www.man7.org/linux/man-pages/man1/lxc-user-nic.1.html>lxc-user-nic(1)</a>
等工具进行配置。</p>
<p>Pod 的网络命名空间可以使用常规的 CNI 插件配置。对于多节点的网络，已知 Flannel (VXLAN、8472/UDP) 可以正常工作。</p>
<p>诸如 kubelet 端口（10250/TCP）和 <code>NodePort</code> 服务端口之类的端口必须通过外部端口转发器
（例如 RootlessKit、 slirp4netns 或
<a href=https://linux.die.net/man/1/socat>socat(1)</a>) 从节点网络命名空间暴露给主机。</p>
<p>你可以使用 K3s 的端口转发器。更多细节请参阅
<a href=https://rancher.com/docs/k3s/latest/en/advanced/#known-issues-with-rootless-mode>在 Rootless 模式下运行 K3s</a>。</p>
<h3 id=配置-cri>配置 CRI</h3>
<p>kubelet 依赖于容器运行时。你需要部署一个容器运行时（例如 containerd 或 CRI-O），
并确保它在 kubelet 启动之前已经在用户命名空间内运行。</p>
<ul class="nav nav-tabs" id=cri role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#cri-0 role=tab aria-controls=cri-0 aria-selected=true>containerd</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#cri-1 role=tab aria-controls=cri-1>CRI-O</a></li></ul>
<div class=tab-content id=cri><div id=cri-0 class="tab-pane show active" role=tabpanel aria-labelledby=cri-0>
<p><p>containerd 1.4 开始支持在用户命名空间运行 containerd 的 CRI 插件。</p>
<p>在用户命名空间运行 containerd 需要在 <code>/etc/containerd/containerd-config.toml</code> 文件包含以下配置：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-toml data-lang=toml>version = <span style=color:#666>2</span>

[plugins.<span style=color:#b44>&#34;io.containerd.grpc.v1.cri&#34;</span>]
<span style=color:#080;font-style:italic># 禁用 AppArmor</span>
  disable_apparmor = <span style=color:#a2f;font-weight:700>true</span>
<span style=color:#080;font-style:italic># 忽略配置 oom_score_adj 时的错误</span>
  restrict_oom_score_adj = <span style=color:#a2f;font-weight:700>true</span>
<span style=color:#080;font-style:italic># 禁用 hugetlb cgroup v2 控制器（因为 systemd 不支持委派 hugetlb controller）</span>
  disable_hugetlb_controller = <span style=color:#a2f;font-weight:700>true</span>

[plugins.<span style=color:#b44>&#34;io.containerd.grpc.v1.cri&#34;</span>.containerd]
<span style=color:#080;font-style:italic># 如果内核 &gt;= 5.11 , 也可以使用 non-fuse overlayfs， 但需要禁用 SELinux</span>
  snapshotter = <span style=color:#b44>&#34;fuse-overlayfs&#34;</span>

[plugins.<span style=color:#b44>&#34;io.containerd.grpc.v1.cri&#34;</span>.containerd.runtimes.runc.options]
<span style=color:#080;font-style:italic># 我们使用的 cgroupfs 已经被 systemd 委派，所以我们不使用 SystemdCgroup 驱动</span>
<span style=color:#080;font-style:italic># (除非你在命名空间内运行了另一个 systemd)</span>
  SystemdCgroup = <span style=color:#a2f;font-weight:700>false</span>
</code></pre></div></div>
<div id=cri-1 class=tab-pane role=tabpanel aria-labelledby=cri-1>
<p><p>CRI-O 1.22 开始支持在用户命名空间运行 CRI-O。</p>
<p>CRI-O 必须配置一个环境变量 <code>_CRIO_ROOTLESS=1</code>。</p>
<p>也推荐使用 <code>/etc/crio/crio.conf</code> 文件内的以下配置：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-toml data-lang=toml>[crio]
  storage_driver = <span style=color:#b44>&#34;overlay&#34;</span>
<span style=color:#080;font-style:italic># 如果内核 &gt;= 5.11 , 也可以使用 non-fuse overlayfs， 但需要禁用 SELinux</span>
  storage_option = [<span style=color:#b44>&#34;overlay.mount_program=/usr/local/bin/fuse-overlayfs&#34;</span>]

[crio.runtime]
<span style=color:#080;font-style:italic># 我们使用的 cgroupfs 已经被 systemd 委派，所以我们不使用 &#34;systemd&#34; 驱动</span>
<span style=color:#080;font-style:italic># (除非你在命名空间内运行了另一个 systemd)</span>
  cgroup_manager = <span style=color:#b44>&#34;cgroupfs&#34;</span>
</code></pre></div></div></div>
<h3 id=配置-kubelet>配置 kubelet</h3>
<p>在用户命名空间运行 kubelet 必须进行如下配置：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>kubelet.config.k8s.io/v1beta1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>KubeletConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>featureGates</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>KubeletInUserNamespace</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># 我们使用的 cgroupfs 已经被 systemd 委派，所以我们不使用 &#34;systemd&#34; 驱动</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># (除非你在命名空间内运行了另一个 systemd)</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>cgroupDriver</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;cgroupfs&#34;</span><span style=color:#bbb>
</span></code></pre></div><p>当 <code>KubeletInUserNamespace</code> 特性门控被启用时， kubelet 会忽略节点内由于配置如下几个 sysctl
参数值而可能产生的错误。</p>
<ul>
<li><code>vm.overcommit_memory</code></li>
<li><code>vm.panic_on_oom</code></li>
<li><code>kernel.panic</code></li>
<li><code>kernel.panic_on_oops</code></li>
<li><code>kernel.keys.root_maxkeys</code></li>
<li><code>kernel.keys.root_maxbytes</code>.</li>
</ul>
<p>在用户命名空间内， kubelet 也会忽略任何由于打开 <code>/dev/kmsg</code> 而产生的错误。
这个特性门控也允许 kube-proxy 忽略由于配置 <code>RLIMIT_NOFILE</code> 而产生的一个错误。</p>
<p><code>KubeletInUserNamespace</code> 特性门控从 Kubernetes v1.22 被引入， 标记为 "alpha" 状态。</p>
<p>通过挂载特制的 proc 文件系统 （比如 <a href=https://github.com/nestybox/sysbox>Sysbox</a>），
也可以在不使用这个特性门控的情况下在用户命名空间运行 kubelet，但这不受官方支持。</p>
<h3 id=配置-kube-proxy>配置 kube-proxy</h3>
<p>在用户命名空间运行 kube-proxy 需要进行以下配置：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>kubeproxy.config.k8s.io/v1alpha1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>KubeProxyConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>mode</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;iptables&#34;</span><span style=color:#bbb> </span><span style=color:#080;font-style:italic># or &#34;userspace&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>conntrack</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># 跳过配置 sysctl 的值 &#34;net.netfilter.nf_conntrack_max&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>maxPerCore</span>:<span style=color:#bbb> </span><span style=color:#666>0</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># 跳过配置 &#34;net.netfilter.nf_conntrack_tcp_timeout_established&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>tcpEstablishedTimeout</span>:<span style=color:#bbb> </span>0s<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># 跳过配置 &#34;net.netfilter.nf_conntrack_tcp_timeout_close&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>tcpCloseWaitTimeout</span>:<span style=color:#bbb> </span>0s<span style=color:#bbb>
</span></code></pre></div>
<h2 id=caveats>注意事项 </h2>
<ul>
<li>
<p>大部分“非本地”的卷驱动（例如 <code>nfs</code> 和 <code>iscsi</code>）不能正常工作。
已知诸如 <code>local</code>、<code>hostPath</code>、<code>emptyDir</code>、<code>configMap</code>、<code>secret</code> 和 <code>downwardAPI</code>
这些本地卷是能正常工作的。</p>
</li>
<li>
<p>一些 CNI 插件可能不正常工作。已知 Flannel (VXLAN) 是能正常工作的。</p>
</li>
</ul>
<p>更多细节请参阅 rootlesscontaine.rs 站点的 <a href=https://rootlesscontaine.rs/caveats/>Caveats and Future work</a> 页面。</p>
<h2 id=see-also>See Also</h2>
<ul>
<li><a href=https://rootlesscontaine.rs/>rootlesscontaine.rs</a></li>
<li><a href=https://www.slideshare.net/AkihiroSuda/kubecon-na-2020-containerd-rootless-containers-2020>Rootless Containers 2020 (KubeCon NA 2020)</a></li>
<li><a href=https://kind.sigs.k8s.io/docs/user/rootless/>使用 Rootless 模式的 Docker 运行 kind</a></li>
<li><a href=https://github.com/rootless-containers/usernetes>Usernetes</a></li>
<li><a href=https://rancher.com/docs/k3s/latest/en/advanced/#running-k3s-with-rootless-mode-experimental>使用 Rootless 模式运行 K3s</a></li>
<li><a href=https://github.com/kubernetes/enhancements/tree/master/keps/sig-node/2033-kubelet-in-userns-aka-rootless>KEP-2033: Kubelet-in-UserNS (aka Rootless mode)</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-e1afcdac8d5e8458274b3c481c5ebcda>3.12 - 使用 CoreDNS 进行服务发现</h1>
<p>此页面介绍了 CoreDNS 升级过程以及如何安装 CoreDNS 而不是 kube-dns。</p>
<h2 id=before-you-begin>Before you begin</h2>
<p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li>
</ul>
Your Kubernetes server must be at or later than version v1.9.
To check the version, enter <code>kubectl version</code>.
</p>
<h2 id=关于-coredns>关于 CoreDNS</h2>
<p><a href=https://coredns.io>CoreDNS</a> 是一个灵活可扩展的 DNS 服务器，可以作为 Kubernetes 集群 DNS。
与 Kubernetes 一样，CoreDNS 项目由 <a class=glossary-tooltip title=云原生计算基金会 data-toggle=tooltip data-placement=top href=https://cncf.io/ target=_blank aria-label=CNCF>CNCF</a> 托管。</p>
<p>通过替换现有集群部署中的 kube-dns，或者使用 kubeadm 等工具来为你部署和升级集群，
可以在你的集群中使用 CoreDNS 而非 kube-dns，</p>
<h2 id=安装-coredns>安装 CoreDNS</h2>
<p>有关手动部署或替换 kube-dns，请参阅
<a href=https://github.com/coredns/deployment/tree/master/kubernetes>CoreDNS GitHub 项目</a>。</p>
<h2 id=迁移到-coredns>迁移到 CoreDNS</h2>
<h3 id=使用-kubeadm-升级现有集群>使用 kubeadm 升级现有集群</h3>
<p>在 Kubernetes 1.21 版本中，kubeadm 移除了对将 <code>kube-dns</code> 作为 DNS 应用的支持。
对于 <code>kubeadm</code> v1.23，所支持的唯一的集群 DNS 应用是 CoreDNS。</p>
<p>当你使用 <code>kubeadm</code> 升级使用 <code>kube-dns</code> 的集群时，你还可以执行到 CoreDNS 的迁移。
在这种场景中，<code>kubeadm</code> 将基于 <code>kube-dns</code> ConfigMap 生成 CoreDNS 配置（"Corefile"），
保存存根域和上游名称服务器的配置。</p>
<h2 id=升级-coredns>升级 CoreDNS</h2>
<p>你可以在 <a href=https://github.com/coredns/deployment/blob/master/kubernetes/CoreDNS-k8s_version.md>CoreDNS version in Kubernetes</a>
页面查看 kubeadm 为不同版本 Kubernetes 所安装的 CoreDNS 版本。</p>
<p>如果你只想升级 CoreDNS 或使用自己的定制镜像，也可以手动升级 CoreDNS。
参看<a href=https://github.com/coredns/deployment/blob/master/kubernetes/Upgrading_CoreDNS.md>指南和演练</a>
文档了解如何平滑升级。
在升级你的集群过程中，请确保现有 CoreDNS 的配置（"Corefile"）被保留下来。</p>
<p>如果使用 <code>kubeadm</code> 工具来升级集群，则 <code>kubeadm</code> 可以自动处理保留现有 CoreDNS
配置这一事项。</p>
<h2 id=coredns-调优>CoreDNS 调优</h2>
<p>当资源利用方面有问题时，优化 CoreDNS 的配置可能是有用的。
有关详细信息，请参阅有关<a href=https://github.com/coredns/deployment/blob/master/kubernetes/Scaling_CoreDNS.md>扩缩 CoreDNS 的文档</a>。</p>
<h2 id=what-s-next>What's next</h2>
<p>你可以通过修改 CoreDNS 的配置（"Corefile"）来配置 <a href=https://coredns.io>CoreDNS</a>，
以支持比 kube-dns 更多的用例。
请参考 <code>kubernetes</code> CoreDNS 插件的<a href=https://coredns.io/plugins/kubernetes/>文档</a>
或者 CoreDNS 博客上的博文
<a href=https://coredns.io/2017/05/08/custom-dns-entries-for-kubernetes/>Custom DNS Entries for Kubernetes</a>，
以了解更多信息。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-669c88964b4a9eb2b040057266e4b60d>3.13 - 使用 KMS 驱动进行数据加密</h1>
<p>本页展示了如何配置秘钥管理服务—— Key Management Service (KMS) 驱动和插件以启用
Secret 数据加密。</p>
<h2 id=before-you-begin>Before you begin</h2>
<ul>
<li><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li>
</ul>
To check the version, enter <code>kubectl version</code>.
</li>
</ul>
<ul>
<li>需要 Kubernetes 1.10.0 或更新版本</li>
<li>需要 etcd v3 或更新版本</li>
</ul>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.12 [beta]</code>
</div>
<p>KMS 加密驱动使用封套加密模型来加密 etcd 中的数据。
数据使用数据加密秘钥（DEK）加密；每次加密都生成一个新的 DEK。
这些 DEK 经一个秘钥加密秘钥（KEK）加密后在一个远端的 KMS 中存储和管理。
KMS 驱动使用 gRPC 与一个特定的 KMS 插件通信。这个 KMS 插件作为一个 gRPC
服务器被部署在 Kubernetes 主服务器的同一个主机上，负责与远端 KMS 的通信。</p>
<h2 id=配置-kms-驱动>配置 KMS 驱动</h2>
<p>为了在 API 服务器上配置 KMS 驱动，在加密配置文件中的驱动数组中加入一个类型为 <code>kms</code>
的驱动，并设置下列属性：</p>
<ul>
<li><code>name</code>: KMS 插件的显示名称。</li>
<li><code>endpoint</code>: gRPC 服务器（KMS 插件）的监听地址。该端点是一个 UNIX 域套接字。</li>
<li><code>cachesize</code>: 以明文缓存的数据加密秘钥（DEKs）的数量。一旦被缓存，
就可以直接使用 DEKs 而无需另外调用 KMS；而未被缓存的 DEKs 需要调用一次 KMS 才能解包。</li>
<li><code>timeout</code>: 在返回一个错误之前，kube-apiserver 等待 kms-plugin 响应的时间（默认是 3 秒）。</li>
</ul>
<p>参见<a href=/zh/docs/tasks/administer-cluster/encrypt-data>理解静态数据加密配置</a></p>
<h2 id=实现-kms-插件>实现 KMS 插件</h2>
<p>为实现一个 KMS 插件，你可以开发一个新的插件 gRPC 服务器或启用一个由你的云服务驱动提供的 KMS 插件。
你可以将这个插件与远程 KMS 集成，并把它部署到 Kubernetes 的主服务器上。</p>
<h3 id=启用由云服务驱动支持的-kms>启用由云服务驱动支持的 KMS</h3>
<p>有关启用云服务驱动特定的 KMS 插件的说明，请咨询你的云服务驱动商。</p>
<h3 id=开发-kms-插件-grpc-服务器>开发 KMS 插件 gRPC 服务器</h3>
<p>你可以使用 Go 语言的存根文件开发 KMS 插件 gRPC 服务器。
对于其他语言，你可以用 proto 文件创建可以用于开发 gRPC 服务器代码的存根文件。</p>
<ul>
<li>使用 Go：使用存根文件 <a href=https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/apiserver/pkg/storage/value/encrypt/envelope/v1beta1/service.pb.go>service.pb.go</a>
中的函数和数据结构开发 gRPC 服务器代码。</li>
</ul>
<ul>
<li>使用 Go 以外的其他语言：用 protoc 编译器编译 proto 文件：
<a href=https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/apiserver/pkg/storage/value/encrypt/envelope/v1beta1/service.proto>service.proto</a>
为指定语言生成存根文件。</li>
</ul>
<p>然后使用存根文件中的函数和数据结构开发服务器代码。</p>
<p><strong>注意：</strong></p>
<ul>
<li>
<p>kms 插件版本：<code>v1beta1</code></p>
<p>作为对过程调用 Version 的响应，兼容的 KMS 插件应把 v1beta1 作为 VersionResponse.version 返回</p>
</li>
<li>
<p>消息版本：<code>v1beta1</code></p>
<p>所有来自 KMS 驱动的消息都把 version 字段设置为当前版本 v1beta1</p>
</li>
<li>
<p>协议：UNIX 域套接字 (<code>unix</code>)</p>
<p>gRPC 服务器应监听 UNIX 域套接字</p>
</li>
</ul>
<h3 id=将-kms-插件与远程-kms-整合>将 KMS 插件与远程 KMS 整合</h3>
<p>KMS 插件可以用任何受 KMS 支持的协议与远程 KMS 通信。
所有的配置数据，包括 KMS 插件用于与远程 KMS 通信的认证凭据，都由 KMS 插件独立地存储和管理。
KMS 插件可以用额外的元数据对密文进行编码，这些元数据是在把它发往 KMS 进行解密之前可能要用到的。</p>
<h3 id=部署-kms-插件>部署 KMS 插件</h3>
<p>确保 KMS 插件与 Kubernetes 主服务器运行在同一主机上。</p>
<h2 id=使用-kms-驱动加密数据>使用 KMS 驱动加密数据</h2>
<p>为了加密数据：</p>
<ol>
<li>
<p>使用 <code>kms</code> 驱动的相应的属性创建一个新的加密配置文件：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>EncryptionConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apiserver.config.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- secrets<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>providers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>kms</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>myKmsPlugin<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>endpoint</span>:<span style=color:#bbb> </span>unix:///tmp/socketfile.sock<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cachesize</span>:<span style=color:#bbb> </span><span style=color:#666>100</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>timeout</span>:<span style=color:#bbb> </span>3s<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>identity</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span></code></pre></div></li>
</ol>
<ol start=2>
<li>设置 kube-apiserver 的 <code>--encryption-provider-config</code> 参数指向配置文件的位置。</li>
<li>重启 API 服务器。</li>
</ol>
<h2 id=验证数据已经加密>验证数据已经加密</h2>
<p>写入 etcd 时数据被加密。重启 kube-apiserver 后，任何新建或更新的 Secret 在存储时应该已被加密。
要验证这点，你可以用 etcdctl 命令行程序获取 Secret 内容。</p>
<ol>
<li>
<p>在默认的命名空间里创建一个名为 secret1 的 Secret：</p>
<pre><code>kubectl create secret generic secret1 -n default --from-literal=mykey=mydata
</code></pre></li>
</ol>
<ol start=2>
<li>
<p>用 etcdctl 命令行，从 etcd 读取出 Secret：</p>
<pre><code>ETCDCTL_API=3 etcdctl get /kubernetes.io/secrets/default/secret1 [...] | hexdump -C
</code></pre>
<p>其中 <code>[...]</code> 是用于连接 etcd 服务器的额外参数。</p>
</li>
</ol>
<ol start=3>
<li>验证保存的 Secret 是否是以 <code>k8s:enc:kms:v1:</code> 开头的，这表明 <code>kms</code> 驱动已经对结果数据加密。</li>
</ol>
<ol start=4>
<li>
<p>验证 Secret 在被 API 获取时已被正确解密：</p>
<pre><code>kubectl describe secret secret1 -n default
</code></pre><p>结果应该是 <code>mykey: mydata</code>。</p>
</li>
</ol>
<h2 id=确保所有-secret-都已被加密>确保所有 Secret 都已被加密</h2>
<p>因为 Secret 是在写入时被加密的，所以在更新 Secret 时也会加密该内容。</p>
<p>下列命令读取所有 Secret 并更新它们以便应用服务器端加密。如果因为写入冲突导致错误发生，
请重试此命令。对较大的集群，你可能希望根据命名空间或脚本更新去细分 Secret 内容。</p>
<pre><code>kubectl get secrets --all-namespaces -o json | kubectl replace -f -
</code></pre>
<h2 id=从本地加密驱动切换到-kms-驱动>从本地加密驱动切换到 KMS 驱动</h2>
<p>为了从本地加密驱动切换到 <code>kms</code> 驱动并重新加密所有 Secret 内容：</p>
<ol>
<li>
<p>在配置文件中加入 <code>kms</code> 驱动作为第一个条目，如下列样例所示</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>EncryptionConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apiserver.config.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- secrets<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>providers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>kms</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name </span>:<span style=color:#bbb> </span>myKmsPlugin<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>endpoint</span>:<span style=color:#bbb> </span>unix:///tmp/socketfile.sock<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cachesize</span>:<span style=color:#bbb> </span><span style=color:#666>100</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>aescbc</span>:<span style=color:#bbb>
</span><span style=color:#bbb>         </span><span style=color:green;font-weight:700>keys</span>:<span style=color:#bbb>
</span><span style=color:#bbb>         </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>key1<span style=color:#bbb>
</span><span style=color:#bbb>           </span><span style=color:green;font-weight:700>secret</span>:<span style=color:#bbb> </span>&lt;BASE 64 ENCODED SECRET&gt;<span style=color:#bbb>
</span></code></pre></div></li>
</ol>
<ol start=2>
<li>
<p>重启所有 kube-apiserver 进程。</p>
</li>
<li>
<p>运行下列命令使用 <code>kms</code> 驱动强制重新加密所有 Secret。</p>
<pre><code>kubectl get secrets --all-namespaces -o json| kubectl replace -f -
</code></pre></li>
</ol>
<h2 id=禁用静态数据加密>禁用静态数据加密</h2>
<p>要禁用静态数据加密：</p>
<ol>
<li>
<p>将 <code>identity</code> 驱动作为配置文件中的第一个条目：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>EncryptionConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apiserver.config.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- secrets<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>providers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>identity</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>kms</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name </span>:<span style=color:#bbb> </span>myKmsPlugin<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>endpoint</span>:<span style=color:#bbb> </span>unix:///tmp/socketfile.sock<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cachesize</span>:<span style=color:#bbb> </span><span style=color:#666>100</span><span style=color:#bbb>
</span></code></pre></div></li>
</ol>
<ol start=2>
<li>
<p>重启所有 kube-apiserver 进程。</p>
</li>
<li>
<p>运行下列命令强制重新加密所有 Secret。</p>
<pre><code>kubectl get secrets --all-namespaces -o json | kubectl replace -f -
</code></pre></li>
</ol>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-e77685d5b88d2db5c7631a27b9472eea>3.14 - 使用 Kubernetes API 访问集群</h1>
<p>本页展示了如何使用 Kubernetes API 访问集群</p>
<h2 id=before-you-begin>Before you begin</h2>
<p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li>
</ul>
To check the version, enter <code>kubectl version</code>.
</p>
<h2 id=访问集群-api>访问集群 API</h2>
<h3 id=使用-kubectl-进行首次访问>使用 kubectl 进行首次访问</h3>
<p>首次访问 Kubernetes API 时，请使用 Kubernetes 命令行工具 <code>kubectl</code> 。</p>
<p>要访问集群，你需要知道集群位置并拥有访问它的凭证。
通常，当你完成<a href=/zh/docs/setup/>入门指南</a>时，这会自动设置完成，或者由其他人设置好集群并将凭证和位置提供给你。</p>
<p>使用此命令检查 kubectl 已知的位置和凭证：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl config view
</code></pre></div>
<p>许多<a href=https://github.com/kubernetes/examples/tree/master/>样例</a>
提供了使用 kubectl 的介绍。完整文档请见 <a href=/zh/docs/reference/kubectl/>kubectl 手册</a>。</p>
<h3 id=直接访问-rest-api>直接访问 REST API</h3>
<p>kubectl 处理对 API 服务器的定位和身份验证。如果你想通过 http 客户端（如 <code>curl</code> 或 <code>wget</code>，或浏览器）直接访问 REST API，你可以通过多种方式对 API 服务器进行定位和身份验证：</p>
<ol>
<li>以代理模式运行 kubectl（推荐）。
推荐使用此方法，因为它用存储的 apiserver 位置并使用自签名证书验证 API 服务器的标识。
使用这种方法无法进行中间人（MITM）攻击。</li>
<li>另外，你可以直接为 HTTP 客户端提供位置和身份认证。
这适用于被代理混淆的客户端代码。
为防止中间人攻击，你需要将根证书导入浏览器。</li>
</ol>
<p>使用 Go 或 Python 客户端库可以在代理模式下访问 kubectl。</p>
<h4 id=使用-kubectl-代理>使用 kubectl 代理</h4>
<p>下列命令使 kubectl 运行在反向代理模式下。它处理 API 服务器的定位和身份认证。</p>
<p>像这样运行它：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl proxy --port<span style=color:#666>=</span><span style=color:#666>8080</span> &amp;
</code></pre></div>
<p>参见 <a href=/docs/reference/generated/kubectl/kubectl-commands/#proxy>kubectl 代理</a> 获取更多细节。</p>
<p>然后你可以通过 curl，wget，或浏览器浏览 API，像这样：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>curl http://localhost:8080/api/
</code></pre></div>
<p>输出类似如下：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
  <span style=color:green;font-weight:700>&#34;versions&#34;</span>: [
    <span style=color:#b44>&#34;v1&#34;</span>
  ],
  <span style=color:green;font-weight:700>&#34;serverAddressByClientCIDRs&#34;</span>: [
    {
      <span style=color:green;font-weight:700>&#34;clientCIDR&#34;</span>: <span style=color:#b44>&#34;0.0.0.0/0&#34;</span>,
      <span style=color:green;font-weight:700>&#34;serverAddress&#34;</span>: <span style=color:#b44>&#34;10.0.1.149:443&#34;</span>
    }
  ]
}
</code></pre></div>
<h4 id=不使用-kubectl-代理>不使用 kubectl 代理</h4>
<p>通过将身份认证令牌直接传给 API 服务器，可以避免使用 kubectl 代理，像这样：</p>
<p>使用 <code>grep/cut</code> 方式：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># 查看所有的集群，因为你的 .kubeconfig 文件中可能包含多个上下文</span>
kubectl config view -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{&#34;Cluster name\tServer\n&#34;}{range .clusters[*]}{.name}{&#34;\t&#34;}{.cluster.server}{&#34;\n&#34;}{end}&#39;</span>

<span style=color:#080;font-style:italic># 从上述命令输出中选择你要与之交互的集群的名称</span>
<span style=color:#a2f>export</span> <span style=color:#b8860b>CLUSTER_NAME</span><span style=color:#666>=</span><span style=color:#b44>&#34;some_server_name&#34;</span>

<span style=color:#080;font-style:italic># 指向引用该集群名称的 API 服务器</span>
<span style=color:#b8860b>APISERVER</span><span style=color:#666>=</span><span style=color:#a2f;font-weight:700>$(</span>kubectl config view -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#34;{.clusters[?(@.name==\&#34;</span><span style=color:#b8860b>$CLUSTER_NAME</span><span style=color:#b44>\&#34;)].cluster.server}&#34;</span><span style=color:#a2f;font-weight:700>)</span>

<span style=color:#080;font-style:italic># 创建一个 secret 来保存默认服务账户的令牌</span>
kubectl apply -f - <span style=color:#b44>&lt;&lt;EOF
</span><span style=color:#b44>apiVersion: v1
</span><span style=color:#b44>kind: Secret
</span><span style=color:#b44>metadata:
</span><span style=color:#b44>  name: default-token
</span><span style=color:#b44>  annotations:
</span><span style=color:#b44>    kubernetes.io/service-account.name: default
</span><span style=color:#b44>type: kubernetes.io/service-account-token
</span><span style=color:#b44>EOF</span>

<span style=color:#080;font-style:italic># 等待令牌控制器使用令牌填充 secret:</span>
<span style=color:#a2f;font-weight:700>while</span> ! kubectl describe secret default-token | grep -E <span style=color:#b44>&#39;^token&#39;</span> &gt;/dev/null; <span style=color:#a2f;font-weight:700>do</span>
  <span style=color:#a2f>echo</span> <span style=color:#b44>&#34;waiting for token...&#34;</span> &gt;&amp;<span style=color:#666>2</span>
  sleep <span style=color:#666>1</span>
<span style=color:#a2f;font-weight:700>done</span>

<span style=color:#080;font-style:italic># 获取令牌</span>
<span style=color:#b8860b>TOKEN</span><span style=color:#666>=</span><span style=color:#a2f;font-weight:700>$(</span>kubectl get secret default-token -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.data.token}&#39;</span> | base64 --decode<span style=color:#a2f;font-weight:700>)</span>

<span style=color:#080;font-style:italic># 使用令牌玩转 API</span>
curl -X GET <span style=color:#b8860b>$APISERVER</span>/api --header <span style=color:#b44>&#34;Authorization: Bearer </span><span style=color:#b8860b>$TOKEN</span><span style=color:#b44>&#34;</span> --insecure
</code></pre></div>
<p>输出类似如下：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;APIVersions&#34;</span>,
  <span style=color:green;font-weight:700>&#34;versions&#34;</span>: [
    <span style=color:#b44>&#34;v1&#34;</span>
  ],
  <span style=color:green;font-weight:700>&#34;serverAddressByClientCIDRs&#34;</span>: [
    {
      <span style=color:green;font-weight:700>&#34;clientCIDR&#34;</span>: <span style=color:#b44>&#34;0.0.0.0/0&#34;</span>,
      <span style=color:green;font-weight:700>&#34;serverAddress&#34;</span>: <span style=color:#b44>&#34;10.0.1.149:443&#34;</span>
    }
  ]
}
</code></pre></div>
<p>上面例子使用了 <code>--insecure</code> 标志位。这使它易受到 MITM 攻击。
当 kubectl 访问集群时，它使用存储的根证书和客户端证书访问服务器。
（已安装在 <code>~/.kube</code> 目录下）。
由于集群认证通常是自签名的，因此可能需要特殊设置才能让你的 http 客户端使用根证书。</p>
<p>在一些集群中，API 服务器不需要身份认证；它运行在本地，或由防火墙保护着。
对此并没有一个标准。
<a href=/zh/docs/concepts/security/controlling-access/>配置对 API 的访问</a>
讲解了作为集群管理员可如何对此进行配置。</p>
<h3 id=编程方式访问-api>编程方式访问 API</h3>
<p>Kubernetes 官方支持 <a href=#go-client>Go</a>、<a href=#python-client>Python</a>、<a href=#java-client>Java</a>、
<a href=#dotnet-client>dotnet</a>、<a href=#javascript-client>JavaScript</a> 和 <a href=#haskell-client>Haskell</a>
语言的客户端库。还有一些其他客户端库由对应作者而非 Kubernetes 团队提供并维护。
参考<a href=/zh/docs/reference/using-api/client-libraries/>客户端库</a>了解如何使用其他语言
来访问 API 以及如何执行身份认证。</p>
<h4 id=go-client>Go 客户端 </h4>
<ul>
<li>要获取库，运行下列命令：<code>go get k8s.io/client-go/kubernetes-&lt;kubernetes 版本号></code>，
参见 <a href=https://github.com/kubernetes/client-go/releases>https://github.com/kubernetes/client-go/releases</a> 查看受支持的版本。</li>
<li>基于 client-go 客户端编写应用程序。</li>
</ul>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 注意 client-go 定义了自己的 API 对象，因此如果需要，请从 client-go 而不是主仓库导入
API 定义，例如 <code>import "k8s.io/client-go/kubernetes"</code> 是正确做法。
</div>
<p>Go 客户端可以使用与 kubectl 命令行工具相同的
<a href=/zh/docs/concepts/configuration/organize-cluster-access-kubeconfig/>kubeconfig 文件</a>
定位和验证 API 服务器。参见这个
<a href=https://git.k8s.io/client-go/examples/out-of-cluster-client-configuration/main.go>例子</a>：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=color:#a2f;font-weight:700>package</span> main

<span style=color:#a2f;font-weight:700>import</span> (
   <span style=color:#b44>&#34;context&#34;</span>
   <span style=color:#b44>&#34;fmt&#34;</span>
   <span style=color:#b44>&#34;k8s.io/apimachinery/pkg/apis/meta/v1&#34;</span>
   <span style=color:#b44>&#34;k8s.io/client-go/kubernetes&#34;</span>
   <span style=color:#b44>&#34;k8s.io/client-go/tools/clientcmd&#34;</span>
)

<span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>main</span>() {
  <span style=color:#080;font-style:italic>// uses the current context in kubeconfig
</span><span style=color:#080;font-style:italic></span>  <span style=color:#080;font-style:italic>// path-to-kubeconfig -- for example, /root/.kube/config
</span><span style=color:#080;font-style:italic></span>  config, _ <span style=color:#666>:=</span> clientcmd.<span style=color:#00a000>BuildConfigFromFlags</span>(<span style=color:#b44>&#34;&#34;</span>, <span style=color:#b44>&#34;&lt;path-to-kubeconfig&gt;&#34;</span>)
  <span style=color:#080;font-style:italic>// creates the clientset
</span><span style=color:#080;font-style:italic></span>  clientset, _ <span style=color:#666>:=</span> kubernetes.<span style=color:#00a000>NewForConfig</span>(config)
  <span style=color:#080;font-style:italic>// access the API to list pods
</span><span style=color:#080;font-style:italic></span>  pods, _ <span style=color:#666>:=</span> clientset.<span style=color:#00a000>CoreV1</span>().<span style=color:#00a000>Pods</span>(<span style=color:#b44>&#34;&#34;</span>).<span style=color:#00a000>List</span>(context.<span style=color:#00a000>TODO</span>(), v1.ListOptions{})
  fmt.<span style=color:#00a000>Printf</span>(<span style=color:#b44>&#34;There are %d pods in the cluster\n&#34;</span>, <span style=color:#a2f>len</span>(pods.Items))
}
</code></pre></div>
<p>如果该应用程序部署为集群中的一个
Pod，请参阅<a href=/zh/docs/tasks/access-application-cluster/access-cluster/#accessing-the-api-from-a-pod>从 Pod 内访问 API</a>。</p>
<h4 id=python-client>Python 客户端</h4>
<p>要使用 <a href=https://github.com/kubernetes-client/python>Python 客户端</a>，运行下列命令：
<code>pip install kubernetes</code>。
参见 <a href=https://github.com/kubernetes-client/python>Python 客户端库主页</a> 了解更多安装选项。</p>
<p>Python 客户端可以使用与 kubectl 命令行工具相同的
<a href=/zh/docs/concepts/configuration/organize-cluster-access-kubeconfig/>kubeconfig 文件</a>
定位和验证 API 服务器。参见这个
<a href=https://github.com/kubernetes-client/python/blob/master/examples/out_of_cluster_config.py>例子</a>：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#a2f;font-weight:700>from</span> <span style=color:#00f;font-weight:700>kubernetes</span> <span style=color:#a2f;font-weight:700>import</span> client, config

config<span style=color:#666>.</span>load_kube_config()

v1<span style=color:#666>=</span>client<span style=color:#666>.</span>CoreV1Api()
<span style=color:#a2f>print</span>(<span style=color:#b44>&#34;Listing pods with their IPs:&#34;</span>)
ret <span style=color:#666>=</span> v1<span style=color:#666>.</span>list_pod_for_all_namespaces(watch<span style=color:#666>=</span><span style=color:#a2f;font-weight:700>False</span>)
<span style=color:#a2f;font-weight:700>for</span> i <span style=color:#a2f;font-weight:700>in</span> ret<span style=color:#666>.</span>items:
    <span style=color:#a2f>print</span>(<span style=color:#b44>&#34;</span><span style=color:#b68;font-weight:700>%s</span><span style=color:#b62;font-weight:700>\t</span><span style=color:#b68;font-weight:700>%s</span><span style=color:#b62;font-weight:700>\t</span><span style=color:#b68;font-weight:700>%s</span><span style=color:#b44>&#34;</span> <span style=color:#666>%</span> (i<span style=color:#666>.</span>status<span style=color:#666>.</span>pod_ip, i<span style=color:#666>.</span>metadata<span style=color:#666>.</span>namespace, i<span style=color:#666>.</span>metadata<span style=color:#666>.</span>name))
</code></pre></div>
<h4 id=java-client>Java 客户端 </h4>
<p>要安装 <a href=https://github.com/kubernetes-client/java>Java 客户端</a>，运行：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># 克隆 Java 库</span>
git clone --recursive https://github.com/kubernetes-client/java

<span style=color:#080;font-style:italic># 安装项目文件、POM 等</span>
<span style=color:#a2f>cd</span> java
mvn install
</code></pre></div>
<p>参阅<a href=https://github.com/kubernetes-client/java/releases>https://github.com/kubernetes-client/java/releases</a>
了解当前支持的版本。</p>
<p>Java 客户端可以使用 kubectl 命令行所使用的
<a href=/zh/docs/concepts/configuration/organize-cluster-access-kubeconfig/>kubeconfig 文件</a>
以定位 API 服务器并向其认证身份。
参看此<a href=https://github.com/kubernetes-client/java/blob/master/examples/src/main/java/io/kubernetes/client/examples/KubeConfigFileClientExample.java>示例</a>：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#a2f;font-weight:700>package</span> <span style=color:#00f;font-weight:700>io.kubernetes.client.examples</span><span style=color:#666>;</span>

<span style=color:#a2f;font-weight:700>import</span> <span style=color:#00f;font-weight:700>io.kubernetes.client.ApiClient</span><span style=color:#666>;</span>
<span style=color:#a2f;font-weight:700>import</span> <span style=color:#00f;font-weight:700>io.kubernetes.client.ApiException</span><span style=color:#666>;</span>
<span style=color:#a2f;font-weight:700>import</span> <span style=color:#00f;font-weight:700>io.kubernetes.client.Configuration</span><span style=color:#666>;</span>
<span style=color:#a2f;font-weight:700>import</span> <span style=color:#00f;font-weight:700>io.kubernetes.client.apis.CoreV1Api</span><span style=color:#666>;</span>
<span style=color:#a2f;font-weight:700>import</span> <span style=color:#00f;font-weight:700>io.kubernetes.client.models.V1Pod</span><span style=color:#666>;</span>
<span style=color:#a2f;font-weight:700>import</span> <span style=color:#00f;font-weight:700>io.kubernetes.client.models.V1PodList</span><span style=color:#666>;</span>
<span style=color:#a2f;font-weight:700>import</span> <span style=color:#00f;font-weight:700>io.kubernetes.client.util.ClientBuilder</span><span style=color:#666>;</span>
<span style=color:#a2f;font-weight:700>import</span> <span style=color:#00f;font-weight:700>io.kubernetes.client.util.KubeConfig</span><span style=color:#666>;</span>
<span style=color:#a2f;font-weight:700>import</span> <span style=color:#00f;font-weight:700>java.io.FileReader</span><span style=color:#666>;</span>
<span style=color:#a2f;font-weight:700>import</span> <span style=color:#00f;font-weight:700>java.io.IOException</span><span style=color:#666>;</span>

<span style=color:#080;font-style:italic>/**
</span><span style=color:#080;font-style:italic> * A simple example of how to use the Java API from an application outside a kubernetes cluster
</span><span style=color:#080;font-style:italic> *
</span><span style=color:#080;font-style:italic> * &lt;p&gt;Easiest way to run this: mvn exec:java
</span><span style=color:#080;font-style:italic> * -Dexec.mainClass=&#34;io.kubernetes.client.examples.KubeConfigFileClientExample&#34;
</span><span style=color:#080;font-style:italic> *
</span><span style=color:#080;font-style:italic> */</span>
<span style=color:#a2f;font-weight:700>public</span> <span style=color:#a2f;font-weight:700>class</span> <span style=color:#00f>KubeConfigFileClientExample</span> <span style=color:#666>{</span>
  <span style=color:#a2f;font-weight:700>public</span> <span style=color:#a2f;font-weight:700>static</span> <span style=color:#0b0;font-weight:700>void</span> <span style=color:#00a000>main</span><span style=color:#666>(</span>String<span style=color:#666>[]</span> args<span style=color:#666>)</span> <span style=color:#a2f;font-weight:700>throws</span> IOException<span style=color:#666>,</span> ApiException <span style=color:#666>{</span>

    <span style=color:#080;font-style:italic>// file path to your KubeConfig
</span><span style=color:#080;font-style:italic></span>    String kubeConfigPath <span style=color:#666>=</span> <span style=color:#b44>&#34;~/.kube/config&#34;</span><span style=color:#666>;</span>

    <span style=color:#080;font-style:italic>// loading the out-of-cluster config, a kubeconfig from file-system
</span><span style=color:#080;font-style:italic></span>    ApiClient client <span style=color:#666>=</span>
        ClientBuilder<span style=color:#666>.</span><span style=color:#b44>kubeconfig</span><span style=color:#666>(</span>KubeConfig<span style=color:#666>.</span><span style=color:#b44>loadKubeConfig</span><span style=color:#666>(</span><span style=color:#a2f;font-weight:700>new</span> FileReader<span style=color:#666>(</span>kubeConfigPath<span style=color:#666>))).</span><span style=color:#b44>build</span><span style=color:#666>();</span>

    <span style=color:#080;font-style:italic>// set the global default api-client to the in-cluster one from above
</span><span style=color:#080;font-style:italic></span>    Configuration<span style=color:#666>.</span><span style=color:#b44>setDefaultApiClient</span><span style=color:#666>(</span>client<span style=color:#666>);</span>

    <span style=color:#080;font-style:italic>// the CoreV1Api loads default api-client from global configuration.
</span><span style=color:#080;font-style:italic></span>    CoreV1Api api <span style=color:#666>=</span> <span style=color:#a2f;font-weight:700>new</span> CoreV1Api<span style=color:#666>();</span>

    <span style=color:#080;font-style:italic>// invokes the CoreV1Api client
</span><span style=color:#080;font-style:italic></span>    V1PodList list <span style=color:#666>=</span> api<span style=color:#666>.</span><span style=color:#b44>listPodForAllNamespaces</span><span style=color:#666>(</span><span style=color:#a2f;font-weight:700>null</span><span style=color:#666>,</span> <span style=color:#a2f;font-weight:700>null</span><span style=color:#666>,</span> <span style=color:#a2f;font-weight:700>null</span><span style=color:#666>,</span> <span style=color:#a2f;font-weight:700>null</span><span style=color:#666>,</span> <span style=color:#a2f;font-weight:700>null</span><span style=color:#666>,</span> <span style=color:#a2f;font-weight:700>null</span><span style=color:#666>,</span> <span style=color:#a2f;font-weight:700>null</span><span style=color:#666>,</span> <span style=color:#a2f;font-weight:700>null</span><span style=color:#666>,</span> <span style=color:#a2f;font-weight:700>null</span><span style=color:#666>);</span>
    System<span style=color:#666>.</span><span style=color:#b44>out</span><span style=color:#666>.</span><span style=color:#b44>println</span><span style=color:#666>(</span><span style=color:#b44>&#34;Listing all pods: &#34;</span><span style=color:#666>);</span>
    <span style=color:#a2f;font-weight:700>for</span> <span style=color:#666>(</span>V1Pod item <span style=color:#666>:</span> list<span style=color:#666>.</span><span style=color:#b44>getItems</span><span style=color:#666>())</span> <span style=color:#666>{</span>
      System<span style=color:#666>.</span><span style=color:#b44>out</span><span style=color:#666>.</span><span style=color:#b44>println</span><span style=color:#666>(</span>item<span style=color:#666>.</span><span style=color:#b44>getMetadata</span><span style=color:#666>().</span><span style=color:#b44>getName</span><span style=color:#666>());</span>
    <span style=color:#666>}</span>
  <span style=color:#666>}</span>
<span style=color:#666>}</span>
</code></pre></div>
<h4 id=dotnet-client>.Net 客户端 </h4>
<p>要使用<a href=https://github.com/kubernetes-client/csharp>.Net 客户端</a>，运行下面的命令：
<code>dotnet add package KubernetesClient --version 1.6.1</code>。
参见<a href=https://github.com/kubernetes-client/csharp>.Net 客户端库页面</a>了解更多安装选项。
关于可支持的版本，参见<a href=https://github.com/kubernetes-client/csharp/releases>https://github.com/kubernetes-client/csharp/releases</a>。</p>
<p>.Net 客户端可以使用与 kubectl CLI 相同的 <a href=/zh/docs/concepts/configuration/organize-cluster-access-kubeconfig/>kubeconfig 文件</a>
来定位并验证 API 服务器。
参见<a href=https://github.com/kubernetes-client/csharp/blob/master/examples/simple/PodList.cs>样例</a>:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=color:#a2f;font-weight:700>using</span> <span style=color:#00f;font-weight:700>System</span>;
<span style=color:#a2f;font-weight:700>using</span> <span style=color:#00f;font-weight:700>k8s</span>;

<span style=color:#a2f;font-weight:700>namespace</span> <span style=color:#00f;font-weight:700>simple</span>
{
    <span style=color:#a2f;font-weight:700>internal</span> <span style=color:#a2f;font-weight:700>class</span> <span style=color:#00f>PodList</span>
    {
        <span style=color:#a2f;font-weight:700>private</span> <span style=color:#a2f;font-weight:700>static</span> <span style=color:#a2f;font-weight:700>void</span> Main(<span style=color:#0b0;font-weight:700>string</span>[] args)
        {
            <span style=color:#0b0;font-weight:700>var</span> config = KubernetesClientConfiguration.BuildDefaultConfig();
            IKubernetes client = <span style=color:#a2f;font-weight:700>new</span> Kubernetes(config);
            Console.WriteLine(<span style=color:#b44>&#34;Starting Request!&#34;</span>);

            <span style=color:#0b0;font-weight:700>var</span> list = client.ListNamespacedPod(<span style=color:#b44>&#34;default&#34;</span>);
            <span style=color:#a2f;font-weight:700>foreach</span> (<span style=color:#0b0;font-weight:700>var</span> item <span style=color:#a2f;font-weight:700>in</span> list.Items)
            {
                Console.WriteLine(item.Metadata.Name);
            }
            <span style=color:#a2f;font-weight:700>if</span> (list.Items.Count == <span style=color:#666>0</span>)
            {
                Console.WriteLine(<span style=color:#b44>&#34;Empty!&#34;</span>);
            }
        }
    }
}
</code></pre></div>
<h4 id=javascript-client>JavaScript 客户端 </h4>
<p>要安装 <a href=https://github.com/kubernetes-client/javascript>JavaScript 客户端</a>，运行下面的命令：
<code>npm install @kubernetes/client-node</code>。
参考<a href=https://github.com/kubernetes-client/javascript/releases>https://github.com/kubernetes-client/javascript/releases</a>了解可支持的版本。</p>
<p>JavaScript 客户端可以使用 kubectl 命令行所使用的
<a href=/zh/docs/concepts/configuration/organize-cluster-access-kubeconfig/>kubeconfig 文件</a>
以定位 API 服务器并向其认证身份。
参见<a href=https://github.com/kubernetes-client/javascript/blob/master/examples/example.js>此例</a>：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#a2f;font-weight:700>const</span> k8s <span style=color:#666>=</span> require(<span style=color:#b44>&#39;@kubernetes/client-node&#39;</span>);

<span style=color:#a2f;font-weight:700>const</span> kc <span style=color:#666>=</span> <span style=color:#a2f;font-weight:700>new</span> k8s.KubeConfig();
kc.loadFromDefault();

<span style=color:#a2f;font-weight:700>const</span> k8sApi <span style=color:#666>=</span> kc.makeApiClient(k8s.CoreV1Api);

k8sApi.listNamespacedPod(<span style=color:#b44>&#39;default&#39;</span>).then((res) =&gt; {
    console.log(res.body);
});
</code></pre></div>
<h4 id=haskell-client>Haskell 客户端 </h4>
<p>参考 <a href=https://github.com/kubernetes-client/haskell/releases>https://github.com/kubernetes-client/haskell/releases</a> 了解支持的版本。</p>
<p><a href=https://github.com/kubernetes-client/haskell>Haskell 客户端</a>
可以使用 kubectl 命令行所使用的
<a href=/zh/docs/concepts/configuration/organize-cluster-access-kubeconfig/>kubeconfig 文件</a>
以定位 API 服务器并向其认证身份。
参见<a href=https://github.com/kubernetes-client/haskell/blob/master/kubernetes-client/example/App.hs>此例</a>：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#00a000>exampleWithKubeConfig</span> <span style=color:#a2f;font-weight:700>::</span> <span style=color:#0b0;font-weight:700>IO</span> <span style=color:#a2f>()</span>
<span style=color:#00a000>exampleWithKubeConfig</span> <span style=color:#a2f;font-weight:700>=</span> <span style=color:#a2f;font-weight:700>do</span>
    oidcCache <span style=color:#a2f;font-weight:700>&lt;-</span> atomically <span style=color:#666>$</span> newTVar <span style=color:#666>$</span> <span style=color:#0b0;font-weight:700>Map</span><span style=color:#666>.</span>fromList <span style=color:#0b0;font-weight:700>[]</span>
    (mgr, kcfg) <span style=color:#a2f;font-weight:700>&lt;-</span> mkKubeClientConfig oidcCache <span style=color:#666>$</span> <span style=color:#0b0;font-weight:700>KubeConfigFile</span> <span style=color:#b44>&#34;/path/to/kubeconfig&#34;</span>
    dispatchMime
            mgr
            kcfg
            (<span style=color:#0b0;font-weight:700>CoreV1</span><span style=color:#666>.</span>listPodForAllNamespaces (<span style=color:#0b0;font-weight:700>Accept</span> <span style=color:#0b0;font-weight:700>MimeJSON</span>))
        <span style=color:#666>&gt;&gt;=</span> print
</code></pre></div><h2 id=what-s-next>What's next</h2>
<ul>
<li><a href=/zh/docs/tasks/run-application/access-api-from-pod/>从 Pod 中访问 API</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-778055e4a4415ca195169b42cd42ddf9>3.15 - 使用 NUMA 感知的内存管理器</h1>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.22 [beta]</code>
</div>
<p>Kubernetes 内存管理器（Memory Manager）为 <code>Guaranteed</code>
<a class=glossary-tooltip title="QoS 类（Quality of Service Class）为 Kubernetes 提供了一种将集群中的 Pod 分为几个类并做出有关调度和驱逐决策的方法。" data-toggle=tooltip data-placement=top href="/zh/docs/reference/glossary/?all=true#term-qos-class" target=_blank aria-label="QoS 类">QoS 类</a>
的 Pods 提供可保证的内存（及大页面）分配能力。</p>
<p>内存管理器使用提示生成协议来为 Pod 生成最合适的 NUMA 亲和性配置。
内存管理器将这类亲和性提示输入给中央管理器（即 Topology Manager）。
基于所给的提示和 Topology Manager（拓扑管理器）的策略设置，Pod
或者会被某节点接受，或者被该节点拒绝。</p>
<p>此外，内存管理器还确保 Pod 所请求的内存是从尽量少的 NUMA 节点分配而来。</p>
<p>内存管理器仅能用于 Linux 主机。</p>
<h2 id=before-you-begin>Before you begin</h2>
<p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li>
</ul>
Your Kubernetes server must be at or later than version v1.21.
To check the version, enter <code>kubectl version</code>.
</p>
<p>为了使得内存资源与 Pod 规约中所请求的其他资源对齐：</p>
<ul>
<li>CPU 管理器应该被启用，并且在节点（Node）上要配置合适的 CPU 管理器策略，
参见<a href=/zh/docs/tasks/administer-cluster/cpu-management-policies/>控制 CPU 管理策略</a>；</li>
<li>拓扑管理器要被启用，并且要在节点上配置合适的拓扑管理器策略，参见
<a href=/zh/docs/tasks/administer-cluster/topology-manager/>控制拓扑管理器策略</a>。</li>
</ul>
<p>从 v1.22 开始，内存管理器通过
<a href=/zh/docs/reference/command-line-tools-reference/feature-gates/>特性门控</a>
<code>MemoryManager</code> 默认启用。</p>
<p>在 v1.22 之前，<code>kubelet</code> 必须在启动时设置如下标志：</p>
<p><code>--feature-gates=MemoryManager=true</code></p>
<p>这样内存管理器特性才会被启用。</p>
<h2 id=内存管理器如何运作>内存管理器如何运作？</h2>
<p>内存管理器目前为 Guaranteed QoS 类中的 Pod 提供可保证的内存（和大页面）分配能力。
若要立即将内存管理器启用，可参照<a href=#memory-manager-configuration>内存管理器配置</a>节中的指南，
之后按<a href=#placing-a-pod-in-the-guaranteed-qos-class>将 Pod 放入 Guaranteed QoS 类</a>
节中所展示的，准备并部署一个 <code>Guaranteed</code> Pod。</p>
<p>内存管理器是一个提示驱动组件（Hint Provider），负责为拓扑管理器提供拓扑提示，
后者根据这些拓扑提示对所请求的资源执行对齐操作。
内存管理器也会为 Pods 应用 <code>cgroups</code> 设置（即 <code>cpuset.mems</code>）。
与 Pod 准入和部署流程相关的完整流程图在<a href=https://github.com/kubernetes/enhancements/tree/master/keps/sig-node/1769-memory-manager#design-overview>Memory Manager KEP: Design Overview</a>
和下面。</p>
<p><img src=/images/docs/memory-manager-diagram.svg alt="Pod 准入与部署流程中的内存管理器"></p>
<p>在这个过程中，内存管理器会更新其内部存储于<a href=https://github.com/kubernetes/enhancements/tree/master/keps/sig-node/1769-memory-manager#the-concept-of-node-map-and-memory-maps>节点映射和内存映射</a>中的计数器，
从而管理有保障的内存分配。</p>
<p>内存管理器在启动和运行期间按下述逻辑更新节点映射（Node Map）。</p>
<h3 id=startup>启动 </h3>
<p>当节点管理员应用 <code>--reserved-memory</code> <a href=#reserved-memory-flag>预留内存标志</a>时执行此逻辑。
这时，节点映射会被更新以反映内存的预留，如
<a href=https://github.com/kubernetes/enhancements/tree/master/keps/sig-node/1769-memory-manager#memory-maps-at-start-up-with-examples>Memory Manager KEP: Memory Maps at start-up (with examples)</a>
所说明。</p>
<p>当配置了 <code>Static</code> 策略时，管理员必须提供 <code>--reserved-memory</code> 标志设置。</p>
<h3 id=runtime>运行时 </h3>
<p>参考文献 <a href=https://github.com/kubernetes/enhancements/tree/master/keps/sig-node/1769-memory-manager#memory-maps-at-runtime-with-examples>Memory Manager KEP: Memory Maps at runtime (with examples)</a>
中说明了成功的 Pod 部署是如何影响节点映射的，该文档也解释了可能发生的内存不足
（Out-of-memory，OOM）情况是如何进一步被 Kubernetes 或操作系统处理的。</p>
<p>在内存管理器运作的语境中，一个重要的话题是对 NUMA 分组的管理。
每当 Pod 的内存请求超出单个 NUMA 节点容量时，内存管理器会尝试创建一个包含多个
NUMA 节点的分组，从而扩展内存容量。解决这个问题的详细描述在文档
<a href=https://github.com/kubernetes/enhancements/tree/master/keps/sig-node/1769-memory-manager#how-to-enable-the-guaranteed-memory-allocation-over-many-numa-nodes>Memory Manager KEP: How to enable the guaranteed memory allocation over many NUMA nodes?</a>
中。同时，关于 NUMA 分组是如何管理的，你还可以参考文档
<a href=https://github.com/kubernetes/enhancements/tree/master/keps/sig-node/1769-memory-manager#simulation---how-the-memory-manager-works-by-examples>Memory Manager KEP: Simulation - how the Memory Manager works? (by examples)</a>。</p>
<h2 id=memory-manager-configuration>内存管理器配置 </h2>
<p>其他管理器也要预先配置。接下来，内存管理器特性需要被启用，
并且采用 <code>Static</code> 策略（<a href=#policy-static>静态策略</a>）运行。
作为可选操作，可以预留一定数量的内存给系统或者 kubelet 进程以增强节点的
稳定性（<a href=#reserved-memory-flag>预留内存标志</a>）。</p>
<h3 id=policies>策略 </h3>
<p>内存管理器支持两种策略。你可以通过 <code>kubelet</code> 标志 <code>--memory-manager-policy</code> 来
选择一种策略：</p>
<ul>
<li><code>None</code> （默认）</li>
<li><code>Static</code></li>
</ul>
<h4 id=policy-none>None 策略 </h4>
<p>这是默认的策略，并且不会以任何方式影响内存分配。该策略的行为好像内存管理器不存在一样。</p>
<p><code>None</code> 策略返回默认的拓扑提示信息。这种特殊的提示会表明拓扑驱动组件（Hint Provider）
（在这里是内存管理器）对任何资源都没有与 NUMA 亲和性关联的偏好。</p>
<h4 id=policy-static>Static 策略 </h4>
<p>对 <code>Guaranteed</code> Pod 而言，<code>Static</code> 内存管理器策略会返回拓扑提示信息，该信息
与内存分配有保障的 NUMA 节点集合有关，并且内存管理器还通过更新内部的
<a href=https://github.com/kubernetes/enhancements/tree/master/keps/sig-node/1769-memory-manager#the-concept-of-node-map-and-memory-maps>节点映射</a> 对象来完成内存预留。</p>
<p>对 <code>BestEffort</code> 或 <code>Burstable</code> Pod 而言，因为不存在对有保障的内存资源的请求，
<code>Static</code> 内存管理器策略会返回默认的拓扑提示，并且不会通过内部的<a href=https://github.com/kubernetes/enhancements/tree/master/keps/sig-node/1769-memory-manager#the-concept-of-node-map-and-memory-maps>节点映射</a>对象
来预留内存。</p>
<h3 id=reserved-memory-flag>预留内存标志 </h3>
<p><a href=/zh/docs/tasks/administer-cluster/reserve-compute-resources/>节点可分配</a>机制通常
被节点管理员用来为 kubelet 或操作系统进程预留 K8S 节点上的系统资源，目的是提高节点稳定性。
有一组专用的标志可用于这个目的，为节点设置总的预留内存量。
此预配置的值接下来会被用来计算节点上对 Pods “可分配的”内存。</p>
<p>Kubernetes 调度器在优化 Pod 调度过程时，会考虑“可分配的”内存。
前面提到的标志包括 <code>--kube-reserved</code>、<code>--system-reserved</code> 和 <code>--eviction-threshold</code>。
这些标志值的综合计作预留内存的总量。</p>
<p>为内存管理器而新增加的 <code>--reserved-memory</code> 标志可以（让节点管理员）将总的预留内存进行划分，
并完成跨 NUMA 节点的预留操作。</p>
<p>标志设置的值是一个按 NUMA 节点的不同内存类型所给的内存预留的值的列表，用逗号分开。
可以使用分号作为分隔符来指定跨多个 NUMA 节点的内存预留。
只有在内存管理器特性被启用的语境下，这个参数才有意义。
内存管理器不会使用这些预留的内存来为容器负载分配内存。</p>
<p>例如，如果你有一个可用内存为 <code>10Gi</code> 的 NUMA 节点 "NUMA0"，而参数 <code>--reserved-memory</code>
被设置成要在 "NUMA0" 上预留 <code>1Gi</code> 的内存，那么内存管理器会假定节点上只有 <code>9Gi</code>
内存可用于容器负载。</p>
<p>你也可以忽略此参数，不过这样做时，你要清楚，所有 NUMA 节点上预留内存的数量要等于
<a href=/zh/docs/tasks/administer-cluster/reserve-compute-resources/>节点可分配特性</a>
所设定的内存量。如果至少有一个节点可分配参数值为非零，你就需要至少为一个 NUMA
节点设置 <code>--reserved-memory</code>。实际上，<code>eviction-hard</code> 阈值默认为 <code>100Mi</code>，
所以当使用 <code>Static</code> 策略时，<code>--reserved-memory</code> 是必须设置的。</p>
<p>此外，应尽量避免如下配置：</p>
<ol>
<li>重复的配置，即同一 NUMA 节点或内存类型被设置不同的取值；</li>
<li>为某种内存类型设置约束值为零；</li>
<li>使用物理硬件上不存在的 NUMA 节点 ID；</li>
<li>使用名字不是 <code>memory</code> 或 <code>hugepages-&lt;size></code> 的内存类型名称
（特定的 <code>&lt;size></code> 的大页面也必须存在）。</li>
</ol>
<p>语法：</p>
<p><code>--reserved-memory N:memory-type1=value1,memory-type2=value2,...</code></p>
<ul>
<li><code>N</code>（整数）- NUMA 节点索引，例如，<code>0</code></li>
<li><code>memory-type</code>（字符串）- 代表内存类型：
<ul>
<li><code>memory</code> - 常规内存；</li>
<li><code>hugepages-2Mi</code> 或 <code>hugepages-1Gi</code> - 大页面</li>
</ul>
</li>
<li><code>value</code>（字符串） - 预留内存的量，例如 <code>1Gi</code></li>
</ul>
<p>用法示例：</p>
<p><code>--reserved-memory 0:memory=1Gi,hugepages-1Gi=2Gi</code></p>
<p>或者</p>
<p><code>--reserved-memory 0:memory=1Gi --reserved-memory 1:memory=2Gi</code></p>
<p>当你为 <code>--reserved-memory</code> 标志指定取值时，必须要遵从之前通过节点可分配特性标志所设置的值。
换言之，对每种内存类型而言都要遵从下面的规则：</p>
<p><code>sum(reserved-memory(i)) = kube-reserved + system-reserved + eviction-threshold</code></p>
<p>其中，<code>i</code> 是 NUMA 节点的索引。</p>
<p>如果你不遵守上面的公示，内存管理器会在启动时输出错误信息。</p>
<p>换言之，上面的例子我们一共要预留 <code>3Gi</code> 的常规内存（<code>type=memory</code>），即：</p>
<p><code>sum(reserved-memory(i)) = reserved-memory(0) + reserved-memory(1) = 1Gi + 2Gi = 3Gi</code></p>
<p>下面的例子中给出与节点可分配配置相关的 kubelet 命令行参数：</p>
<ul>
<li><code>--kube-reserved=cpu=500m,memory=50Mi</code></li>
<li><code>--system-reserved=cpu=123m,memory=333Mi</code></li>
<li><code>--eviction-hard=memory.available&lt;500Mi</code></li>
</ul>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong>
<p>默认的硬性驱逐阈值是 100MiB，<strong>不是</strong>零。
请记得在使用 <code>--reserved-memory</code> 设置要预留的内存量时，加上这个硬性驱逐阈值。
否则 kubelet 不会启动内存管理器，而会输出一个错误信息。
</div>
<p>下面是一个正确配置的示例：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>--feature-gates<span style=color:#666>=</span><span style=color:#b8860b>MemoryManager</span><span style=color:#666>=</span><span style=color:#a2f>true</span> 
--kube-reserved<span style=color:#666>=</span><span style=color:#b8860b>cpu</span><span style=color:#666>=</span>4,memory<span style=color:#666>=</span>4Gi 
--system-reserved<span style=color:#666>=</span><span style=color:#b8860b>cpu</span><span style=color:#666>=</span>1,memory<span style=color:#666>=</span>1Gi 
--memory-manager-policy<span style=color:#666>=</span>Static 
--reserved-memory <span style=color:#b44>&#39;0:memory=3Gi;1:memory=2148Mi&#39;</span>
</code></pre></div>
<p>我们对上面的配置做一个检查：</p>
<ol>
<li><code>kube-reserved + system-reserved + eviction-hard(default) = reserved-memory(0) + reserved-memory(1)</code></li>
<li><code>4GiB + 1GiB + 100MiB = 3GiB + 2148MiB</code></li>
<li><code>5120MiB + 100MiB = 3072MiB + 2148MiB</code></li>
<li><code>5220MiB = 5220MiB</code> （这是对的）</li>
</ol>
<h2 id=placing-a-pod-in-the-guaranteed-qos-class>将 Pod 放入 Guaranteed QoS 类 </h2>
<p>若所选择的策略不是 <code>None</code>，则内存管理器会辨识处于 <code>Guaranteed</code> QoS 类中的 Pod。
内存管理器为每个 <code>Guaranteed</code> Pod 向拓扑管理器提供拓扑提示信息。
对于不在 <code>Guaranteed</code> QoS 类中的其他 Pod，内存管理器向拓扑管理器提供默认的
拓扑提示信息。</p>
<p>下面的来自 Pod 清单的片段将 Pod 加入到 <code>Guaranteed</code> QoS 类中。</p>
<p>当 Pod 的 CPU <code>requests</code> 等于 <code>limits</code> 且为整数值时，Pod 将运行在 <code>Guaranteed</code>
QoS 类中。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;200Mi&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>example.com/device</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;1&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;200Mi&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>example.com/device</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;1&#34;</span><span style=color:#bbb>
</span></code></pre></div>
<p>此外，共享 CPU 的 Pods 在 <code>requests</code> 等于 <code>limits</code> 值时也运行在 <code>Guaranteed</code>
QoS 类中。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;200Mi&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;300m&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>example.com/device</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;1&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;200Mi&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;300m&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>example.com/device</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;1&#34;</span><span style=color:#bbb>
</span></code></pre></div>
<p>要注意的是，只有 CPU 和内存请求都被设置时，Pod 才会进入 Guaranteed QoS 类。</p>
<h2 id=troubleshooting>故障排查 </h2>
<p>下面的方法可用来排查为什么 Pod 无法被调度或者被节点拒绝：</p>
<ul>
<li>Pod 状态 - 可表明拓扑亲和性错误</li>
<li>系统日志 - 包含用来调试的有价值的信息，例如，关于所生成的提示信息</li>
<li>状态文件 - 其中包含内存管理器内部状态的转储（包含<a href=https://github.com/kubernetes/enhancements/tree/master/keps/sig-node/1769-memory-manager#the-concept-of-node-map-and-memory-maps>节点映射和内存映射</a>）</li>
<li>从 v1.22 开始，<a href=#device-plugin-resource-api>设备插件资源 API</a> 可以用来
检索关于为容器预留的内存的信息</li>
</ul>
<h3 id=TopologyAffinityError>Pod 状态 （TopologyAffinityError） </h3>
<p>这类错误通常在以下情形出现：</p>
<ul>
<li>节点缺少足够的资源来满足 Pod 请求</li>
<li>Pod 的请求因为特定的拓扑管理器策略限制而被拒绝</li>
</ul>
<p>错误信息会出现在 Pod 的状态中：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods
</code></pre></div><pre><code class=language-none data-lang=none>NAME         READY   STATUS                  RESTARTS   AGE
guaranteed   0/1     TopologyAffinityError   0          113s
</code></pre>
<p>使用 <code>kubectl describe pod &lt;id></code> 或 <code>kubectl get events</code> 可以获得详细的错误信息。</p>
<pre><code class=language-none data-lang=none>Warning  TopologyAffinityError  10m   kubelet, dell8  Resources cannot be allocated with Topology locality
</code></pre>
<h3 id=system-logs>系统日志 </h3>
<p>针对特定的 Pod 搜索系统日志。</p>
<p>内存管理器为 Pod 所生成的提示信息可以在日志中找到。
此外，日志中应该也存在 CPU 管理器所生成的提示信息。</p>
<p>拓扑管理器将这些提示信息进行合并，计算得到唯一的最合适的提示数据。
此最佳提示数据也应该出现在日志中。</p>
<p>最佳提示表明要在哪里分配所有的资源。拓扑管理器会用当前的策略来测试此数据，
并基于得出的结论或者接纳 Pod 到节点，或者将其拒绝。</p>
<p>此外，你可以搜索日志查找与内存管理器相关的其他条目，例如 <code>cgroups</code> 和
<code>cpuset.mems</code> 的更新信息等。</p>
<h3 id=检查节点上内存管理器状态>检查节点上内存管理器状态</h3>
<p>我们首先部署一个 <code>Guaranteed</code> Pod 示例，其规约如下所示：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>guaranteed<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>guaranteed<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>consumer<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>imagePullPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>150Gi<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>150Gi<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;sleep&#34;</span>,<span style=color:#b44>&#34;infinity&#34;</span>]<span style=color:#bbb>
</span></code></pre></div>
<p>接下来，我们登录到 Pod 运行所在的节点，检查位于
<code>/var/lib/kubelet/memory_manager_state</code> 的状态文件：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
   <span style=color:green;font-weight:700>&#34;policyName&#34;</span>:<span style=color:#b44>&#34;Static&#34;</span>,
   <span style=color:green;font-weight:700>&#34;machineState&#34;</span>:{
      <span style=color:green;font-weight:700>&#34;0&#34;</span>:{
         <span style=color:green;font-weight:700>&#34;numberOfAssignments&#34;</span>:<span style=color:#666>1</span>,
         <span style=color:green;font-weight:700>&#34;memoryMap&#34;</span>:{
            <span style=color:green;font-weight:700>&#34;hugepages-1Gi&#34;</span>:{
               <span style=color:green;font-weight:700>&#34;total&#34;</span>:<span style=color:#666>0</span>,
               <span style=color:green;font-weight:700>&#34;systemReserved&#34;</span>:<span style=color:#666>0</span>,
               <span style=color:green;font-weight:700>&#34;allocatable&#34;</span>:<span style=color:#666>0</span>,
               <span style=color:green;font-weight:700>&#34;reserved&#34;</span>:<span style=color:#666>0</span>,
               <span style=color:green;font-weight:700>&#34;free&#34;</span>:<span style=color:#666>0</span>
            },
            <span style=color:green;font-weight:700>&#34;memory&#34;</span>:{
               <span style=color:green;font-weight:700>&#34;total&#34;</span>:<span style=color:#666>134987354112</span>,
               <span style=color:green;font-weight:700>&#34;systemReserved&#34;</span>:<span style=color:#666>3221225472</span>,
               <span style=color:green;font-weight:700>&#34;allocatable&#34;</span>:<span style=color:#666>131766128640</span>,
               <span style=color:green;font-weight:700>&#34;reserved&#34;</span>:<span style=color:#666>131766128640</span>,
               <span style=color:green;font-weight:700>&#34;free&#34;</span>:<span style=color:#666>0</span>
            }
         },
         <span style=color:green;font-weight:700>&#34;nodes&#34;</span>:[
            <span style=color:#666>0</span>,
            <span style=color:#666>1</span>
         ]
      },
      <span style=color:green;font-weight:700>&#34;1&#34;</span>:{
         <span style=color:green;font-weight:700>&#34;numberOfAssignments&#34;</span>:<span style=color:#666>1</span>,
         <span style=color:green;font-weight:700>&#34;memoryMap&#34;</span>:{
            <span style=color:green;font-weight:700>&#34;hugepages-1Gi&#34;</span>:{
               <span style=color:green;font-weight:700>&#34;total&#34;</span>:<span style=color:#666>0</span>,
               <span style=color:green;font-weight:700>&#34;systemReserved&#34;</span>:<span style=color:#666>0</span>,
               <span style=color:green;font-weight:700>&#34;allocatable&#34;</span>:<span style=color:#666>0</span>,
               <span style=color:green;font-weight:700>&#34;reserved&#34;</span>:<span style=color:#666>0</span>,
               <span style=color:green;font-weight:700>&#34;free&#34;</span>:<span style=color:#666>0</span>
            },
            <span style=color:green;font-weight:700>&#34;memory&#34;</span>:{
               <span style=color:green;font-weight:700>&#34;total&#34;</span>:<span style=color:#666>135286722560</span>,
               <span style=color:green;font-weight:700>&#34;systemReserved&#34;</span>:<span style=color:#666>2252341248</span>,
               <span style=color:green;font-weight:700>&#34;allocatable&#34;</span>:<span style=color:#666>133034381312</span>,
               <span style=color:green;font-weight:700>&#34;reserved&#34;</span>:<span style=color:#666>29295144960</span>,
               <span style=color:green;font-weight:700>&#34;free&#34;</span>:<span style=color:#666>103739236352</span>
            }
         },
         <span style=color:green;font-weight:700>&#34;nodes&#34;</span>:[
            <span style=color:#666>0</span>,
            <span style=color:#666>1</span>
         ]
      }
   },
   <span style=color:green;font-weight:700>&#34;entries&#34;</span>:{
      <span style=color:green;font-weight:700>&#34;fa9bdd38-6df9-4cf9-aa67-8c4814da37a8&#34;</span>:{
         <span style=color:green;font-weight:700>&#34;guaranteed&#34;</span>:[
            {
               <span style=color:green;font-weight:700>&#34;numaAffinity&#34;</span>:[
                  <span style=color:#666>0</span>,
                  <span style=color:#666>1</span>
               ],
               <span style=color:green;font-weight:700>&#34;type&#34;</span>:<span style=color:#b44>&#34;memory&#34;</span>,
               <span style=color:green;font-weight:700>&#34;size&#34;</span>:<span style=color:#666>161061273600</span>
            }
         ]
      }
   },
   <span style=color:green;font-weight:700>&#34;checksum&#34;</span>:<span style=color:#666>4142013182</span>
}
</code></pre></div>
<p>从这个状态文件，可以推断 Pod 被同时绑定到两个 NUMA 节点，即：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=color:#b44>&#34;numaAffinity&#34;</span><span>:</span>[
   <span style=color:#666>0</span>,
   <span style=color:#666>1</span>
]<span>,</span>
</code></pre></div>
<p>术语绑定（pinned）意味着 Pod 的内存使用被（通过 <code>cgroups</code> 配置）限制到
这些 NUMA 节点。</p>
<p>这也直接意味着内存管理器已经创建了一个 NUMA 分组，由这两个 NUMA 节点组成，
即索引值分别为 <code>0</code> 和 <code>1</code> 的 NUMA 节点。</p>
<p>注意 NUMA 分组的管理是有一个相对复杂的管理器处理的，相关逻辑的进一步细节可在内存管理器的
KEP 中<a href=https://github.com/kubernetes/enhancements/tree/master/keps/sig-node/1769-memory-manager#simulation---how-the-memory-manager-works-by-examples>示例1</a>和<a href=https://github.com/kubernetes/enhancements/tree/master/keps/sig-node/1769-memory-manager#how-to-enable-the-guaranteed-memory-allocation-over-many-numa-nodes>跨 NUMA 节点</a>节找到。</p>
<p>为了分析 NUMA 组中可用的内存资源，必须对分组内 NUMA 节点对应的条目进行汇总。</p>
<p>例如，NUMA 分组中空闲的“常规”内存的总量可以通过将分组内所有 NUMA
节点上空闲内存加和来计算，即将 NUMA 节点 <code>0</code> 和 NUMA 节点 <code>1</code> 的 <code>"memory"</code> 节
（分别是 <code>"free":0</code> 和 <code>"free": 103739236352</code>）相加，得到此分组中空闲的“常规”
内存总量为 <code>0 + 103739236352</code> 字节。</p>
<p><code>"systemReserved": 3221225472</code> 这一行表明节点的管理员使用 <code>--reserved-memory</code> 为 NUMA
节点 <code>0</code> 上运行的 kubelet 和系统进程预留了 <code>3221225472</code> 字节 （即 <code>3Gi</code>）。</p>
<h3 id=device-plugin-resource-api>设备插件资源 API </h3>
<p>通过使用此 <a href=/zh/docs/concepts/extend-kubernetes/compute-storage-net/device-plugins/>API</a>，
可以获得每个容器的预留内存信息，该信息位于 protobuf 协议的 <code>ContainerMemory</code> 消息中。
只能针对 Guaranteed QoS 类中的 Pod 来检索此信息。</p>
<h2 id=what-s-next>What's next</h2>
<ul>
<li><a href=https://github.com/kubernetes/enhancements/tree/master/keps/sig-node/1769-memory-manager#design-overview>Memory Manager KEP: Design Overview</a></li>
<li><a href=https://github.com/kubernetes/enhancements/tree/master/keps/sig-node/1769-memory-manager#memory-maps-at-start-up-with-examples>Memory Manager KEP: Memory Maps at start-up (with examples)</a></li>
<li><a href=https://github.com/kubernetes/enhancements/tree/master/keps/sig-node/1769-memory-manager#memory-maps-at-runtime-with-examples>Memory Manager KEP: Memory Maps at runtime (with examples)</a></li>
<li><a href=https://github.com/kubernetes/enhancements/tree/master/keps/sig-node/1769-memory-manager#simulation---how-the-memory-manager-works-by-examples>Memory Manager KEP: Simulation - how the Memory Manager works? (by examples)</a></li>
<li><a href=https://github.com/kubernetes/enhancements/tree/master/keps/sig-node/1769-memory-manager#the-concept-of-node-map-and-memory-maps>Memory Manager KEP: The Concept of Node Map and Memory Maps</a></li>
<li><a href=https://github.com/kubernetes/enhancements/tree/master/keps/sig-node/1769-memory-manager#how-to-enable-the-guaranteed-memory-allocation-over-many-numa-nodes>Memory Manager KEP: How to enable the guaranteed memory allocation over many NUMA nodes?</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-12001be83d15fcd7f3242313a55777df>3.16 - 保护集群</h1>
<p>本文档涉及与保护集群免受意外或恶意访问有关的主题，并对总体安全性提出建议。</p>
<h2 id=before-you-begin>Before you begin</h2>
<ul>
<li><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li>
</ul>
To check the version, enter <code>kubectl version</code>.
</li>
</ul>
<h2 id=控制对-kubernetes-api-的访问>控制对 Kubernetes API 的访问</h2>
<p>因为 Kubernetes 是完全通过 API 驱动的，所以，控制和限制谁可以通过 API 访问集群，
以及允许这些访问者执行什么样的 API 动作，就成为了安全控制的第一道防线。</p>
<h3 id=为所有-api-交互使用传输层安全-tls>为所有 API 交互使用传输层安全 （TLS）</h3>
<p>Kubernetes 期望集群中所有的 API 通信在默认情况下都使用 TLS 加密，
大多数安装方法也允许创建所需的证书并且分发到集群组件中。
请注意，某些组件和安装方法可能使用 HTTP 来访问本地端口，
管理员应该熟悉每个组件的设置，以识别可能不安全的流量。</p>
<h3 id=api-认证>API 认证</h3>
<p>安装集群时，选择一个 API 服务器的身份验证机制，去使用与之匹配的公共访问模式。
例如，小型的单用户集群可能希望使用简单的证书或静态承载令牌方法。
更大的集群则可能希望整合现有的、OIDC、LDAP 等允许用户分组的服务器。</p>
<p>所有 API 客户端都必须经过身份验证，即使它是基础设施的一部分，比如节点、代理、调度程序和卷插件。
这些客户端通常使用 <a href=/zh/docs/reference/access-authn-authz/service-accounts-admin/>服务帐户</a>
或 X509 客户端证书，并在集群启动时自动创建或是作为集群安装的一部分进行设置。</p>
<p>如果你希望获取更多信息，请参考<a href=/zh/docs/reference/access-authn-authz/authentication/>认证参考文档</a>。</p>
<h3 id=api-授权>API 授权</h3>
<p>一旦通过身份认证，每个 API 的调用都将通过鉴权检查。
Kubernetes 集成<a href=/zh/docs/reference/access-authn-authz/rbac/>基于角色的访问控制（RBAC）</a>组件，
将传入的用户或组与一组绑定到角色的权限匹配。
这些权限将动作（get、create、delete）和资源（Pod、Service、Node）进行组合，并可在名字空间或者集群范围生效。
Kubernetes 提供了一组可直接使用的角色，这些角色根据客户可能希望执行的操作提供合理的责任划分。
建议你同时使用 <a href=/zh/docs/reference/access-authn-authz/node/>Node</a> 和
<a href=/zh/docs/reference/access-authn-authz/rbac/>RBAC</a> 两个鉴权组件，再与
<a href=/zh/docs/reference/access-authn-authz/admission-controllers/#noderestriction>NodeRestriction</a>
准入插件结合使用。</p>
<p>与身份验证一样，简单而广泛的角色可能适合于较小的集群，但是随着更多的用户与集群交互，
可能需要将团队划分到有更多角色限制的、
单独的<a class=glossary-tooltip title="名字空间是 Kubernetes 用来支持隔离单个集群中的资源组的一种抽象。" data-toggle=tooltip data-placement=top href=/zh/docs/concepts/overview/working-with-objects/namespaces/ target=_blank aria-label=名字空间>名字空间</a>中去。</p>
<p>就鉴权而言，很重要的一点是理解对象上的更新操作如何导致在其它地方发生对应行为。
例如，用户可能不能直接创建 Pod，但允许他们通过创建 Deployment 来创建这些 Pod，
这将让他们间接创建这些 Pod。
同样地，从 API 删除一个节点将导致调度到这些节点上的 Pod 被中止，并在其他节点上重新创建。
原生的角色设计代表了灵活性和常见用例之间的平衡，但须限制的角色应该被仔细审查，
以防止意外的权限升级。如果内置的角色无法满足你的需求，则可以根据使用场景需要创建特定的角色。</p>
<p>如果你希望获取更多信息，请参阅<a href=/zh/docs/reference/access-authn-authz/authorization/>鉴权参考</a>。</p>
<h2 id=控制对-kubelet-的访问>控制对 Kubelet 的访问</h2>
<p>Kubelet 公开 HTTPS 端点，这些端点提供了对节点和容器的强大的控制能力。
默认情况下，Kubelet 允许对此 API 进行未经身份验证的访问。</p>
<p>生产级别的集群应启用 Kubelet 身份认证和授权。</p>
<p>进一步的信息，请参考
<a href=/zh/docs/reference/command-line-tools-reference/kubelet-authentication-authorization/>Kubelet 身份验证/授权参考</a>。</p>
<h2 id=控制运行时负载或用户的能力>控制运行时负载或用户的能力</h2>
<p>Kubernetes 中的授权故意设计成较高抽象级别，侧重于对资源的粗粒度行为。
更强大的控制是 <strong>策略</strong> 的形式呈现的，根据使用场景限制这些对象如何作用于集群、自身和其他资源。</p>
<h3 id=限制集群上的资源使用>限制集群上的资源使用</h3>
<p><a href=/zh/docs/concepts/policy/resource-quotas/>资源配额（Resource Quota）</a>限制了赋予命名空间的资源的数量或容量。
资源配额通常用于限制名字空间可以分配的 CPU、内存或持久磁盘的数量，
但也可以控制每个名字空间中存在多少个 Pod、Service 或 Volume。</p>
<p><a href=/zh/docs/tasks/administer-cluster/manage-resources/memory-default-namespace/>限制范围（Limit Range）</a>
限制上述某些资源的最大值或者最小值，以防止用户使用类似内存这样的通用保留资源时请求不合理的过高或过低的值，
或者在没有指定的情况下提供默认限制。</p>
<h3 id=控制容器运行的特权>控制容器运行的特权</h3>
<p>Pod 定义包含了一个<a href=/zh/docs/tasks/configure-pod-container/security-context/>安全上下文</a>，
用于描述一些访问请求，如以某个节点上的特定 Linux 用户（如 root）身份运行，
以特权形式运行，访问主机网络，以及一些在宿主节点上不受约束地运行的其它控制权限等等。</p>
<p>你可以配置 <a href=/zh/docs/concepts/security/pod-security-admission/>Pod 安全准入</a>来在某个
<a class=glossary-tooltip title="名字空间是 Kubernetes 用来支持隔离单个集群中的资源组的一种抽象。" data-toggle=tooltip data-placement=top href=/zh/docs/concepts/overview/working-with-objects/namespaces/ target=_blank aria-label=名字空间>名字空间</a>中
强制实施特定的
<a href=/zh/docs/concepts/security/pod-security-standards/>Pod 安全标准（Pod Security Standard）</a>，
或者检查安全上的缺陷。</p>
<p>一般来说，大多数应用程序需要对主机资源的有限制的访问，
这样它们可以在不访问主机信息的情况下，成功地以 root 账号（UID 0）运行。
但是，考虑到与 root 用户相关的特权，在编写应用程序容器时，你应该使用非 root 用户运行。
类似地，希望阻止客户端应用程序从其容器中逃逸的管理员，应该应用 <strong>Baseline</strong>
或 <strong>Restricted</strong> Pod 安全标准。</p>
<h3 id=限制网络访问>限制网络访问</h3>
<p>基于名字空间的<a href=/zh/docs/tasks/administer-cluster/declare-network-policy/>网络策略</a>
允许应用程序作者限制其它名字空间中的哪些 Pod 可以访问自身名字空间内的 Pod 和端口。
现在已经有许多支持网络策略的
<a href=/zh/docs/concepts/cluster-administration/networking/>Kubernetes 网络驱动</a>。</p>
<p>配额（Quota）和限制范围（Limit Range）也可用于控制用户是否可以请求节点端口或负载均衡服务。
在很多集群上，节点端口和负载均衡服务也可控制用户的应用程序是否在集群之外可见。</p>
<p>此外也可能存在一些基于插件或基于环境的网络规则，能够提供额外的保护能力。
例如各节点上的防火墙、物理隔离群集节点以防止串扰或者高级的网络策略等。</p>
<h3 id=限制云元数据-api-访问>限制云元数据 API 访问</h3>
<p>云平台（AWS, Azure, GCE 等）经常将 metadata 本地服务暴露给实例。
默认情况下，这些 API 可由运行在实例上的 Pod 访问，并且可以包含
该云节点的凭据或配置数据（如 kubelet 凭据）。
这些凭据可以用于在集群内升级或在同一账户下升级到其他云服务。</p>
<p>在云平台上运行 Kubernetes 时，需要限制对实例凭据的权限，使用
<a href=/zh/docs/tasks/administer-cluster/declare-network-policy/>网络策略</a>
限制 Pod 对元数据 API 的访问，并避免使用配置数据来传递机密信息。</p>
<h3 id=控制-pod-可以访问的节点>控制 Pod 可以访问的节点</h3>
<p>默认情况下，对 Pod 可以运行在哪些节点上是没有任何限制的。
Kubernetes 给最终用户提供了
一组丰富的策略用于<a href=/zh/docs/concepts/scheduling-eviction/assign-pod-node/>控制 Pod 所放置的节点位置</a>，
以及<a href=/zh/docs/concepts/scheduling-eviction/taint-and-toleration/>基于污点的 Pod 放置和驱逐</a>。
对于许多集群，使用这些策略来分离工作负载可以作为一种约定，要求作者遵守或者通过工具强制。</p>
<p>对于管理员，Beta 阶段的准入插件 <code>PodNodeSelector</code> 可用于强制某名字空间中的 Pod
使用默认的或特定的节点选择算符。
如果最终用户无法改变名字空间，这一机制可以有效地限制特定工作负载中所有 Pod 的放置位置。</p>
<h2 id=保护集群组件免受破坏>保护集群组件免受破坏</h2>
<p>本节描述保护集群免受破坏的一些常用模式。</p>
<h3 id=限制访问-etcd>限制访问 etcd</h3>
<p>拥有对 API 的 etcd 后端的写访问权限相当于获得了整个集群的 root 权限，
读访问权限也可能被利用，实现相当快速的权限提升。
对于从 API 服务器访问其 etcd 服务器，管理员应该总是使用比较强的凭证，如通过 TLS
客户端证书来实现双向认证。
通常，我们建议将 etcd 服务器隔离到只有 API 服务器可以访问的防火墙后面。</p>
<div class="alert alert-warning caution callout" role=alert>
<strong>Caution:</strong> 允许集群中其它组件对整个主键空间（keyspace）拥有读或写权限去访问 etcd 实例，
相当于授予这些组件群集管理员的访问权限。
对于非主控组件，强烈推荐使用不同的 etcd 实例，或者使用 etcd 的访问控制列表
来限制这些组件只能读或写主键空间的一个子集。
</div>
<h3 id=启用审计日志>启用审计日志</h3>
<p><a href=/zh/docs/tasks/debug-application-cluster/audit/>审计日志</a>是 Beta 特性，
负责记录 API 操作以便在发生破坏时进行事后分析。
建议启用审计日志，并将审计文件归档到安全服务器上。</p>
<h3 id=限制使用-alpha-和-beta-特性>限制使用 alpha 和 beta 特性</h3>
<p>Kubernetes 的 alpha 和 beta 特性还在努力开发中，可能存在导致安全漏洞的缺陷或错误。
要始终评估 alpha 和 beta 特性可能给你的安全态势带来的风险。
当你怀疑存在风险时，可以禁用那些不需要使用的特性。</p>
<h3 id=经常轮换基础设施证书>经常轮换基础设施证书</h3>
<p>一项机密信息或凭据的生命期越短，攻击者就越难使用该凭据。
在证书上设置较短的生命期并实现自动轮换是控制安全的一个好方法。
使用身份验证提供程序时，应该使用那些可以控制所发布令牌的合法时长的提供程序，
并尽可能设置较短的生命期。
如果在外部集成场景中使用服务帐户令牌，则应该经常性地轮换这些令牌。
例如，一旦引导阶段完成，就应该撤销用于配置节点的引导令牌，或者取消它的授权。</p>
<h3 id=在启用第三方集成之前-请先审查它们>在启用第三方集成之前，请先审查它们</h3>
<p>许多集成到 Kubernetes 的第三方软件或服务都可能改变你的集群的安全配置。
启用集成时，在授予访问权限之前，你应该始终检查扩展所请求的权限。
例如，许多安全性集成中可能要求查看集群上的所有 Secret 的访问权限，
本质上该组件便成为了集群的管理员。
当有疑问时，如果可能的话，将要集成的组件限制在某指定名字空间中运行。</p>
<p>如果执行 Pod 创建操作的组件能够在 <code>kube-system</code> 这类名字空间中创建 Pod，
则这类组件也可能获得意外的权限，因为这些 Pod 可以访问服务账户的 Secret，
或者，如果对应服务帐户被授权访问宽松的
<a href=/zh/docs/concepts/policy/pod-security-policy/>PodSecurityPolicy</a>，
它们就能以较高的权限运行。</p>
<p>如果你使用 <a href=/zh/docs/concepts/security/pod-security-admission/>Pod 安全准入</a>，
并且允许任何组件在一个允许执行特权 Pod 的名字空间中创建 Pod，这些 Pod
就可能从所在的容器中逃逸，利用被拓宽的访问权限来实现特权提升。</p>
<p>你不应该允许不可信的组件在任何系统名字空间（名字以 <code>kube-</code> 开头）中创建 Pod，
也不允许它们在访问权限授权可被利用来提升特权的名字空间中创建 Pod。</p>
<h3 id=对-secret-进行静态加密>对 Secret 进行静态加密</h3>
<p>一般情况下，etcd 数据库包含了通过 Kubernetes API 可以访问到的所有信息，
并且可能为攻击者提供对你的集群的状态的较多的可见性。
你要始终使用经过充分审查的备份和加密方案来加密备份数据，
并考虑在可能的情况下使用全盘加密。</p>
<p>Kubernetes 支持<a href=/zh/docs/tasks/administer-cluster/encrypt-data/>静态数据加密</a>。
该功能在 1.7 版本引入，并在 1.13 版本成为 Beta。
它会加密 etcd 里面的 <code>Secret</code> 资源，以防止某一方通过查看 etcd 的备份文件查看到这些
Secret 的内容。虽然目前该功能还只是 Beta 阶段，
在备份未被加密或者攻击者获取到 etcd 的读访问权限时，它仍能提供额外的防御层级。</p>
<h3 id=接收安全更新和报告漏洞的警报>接收安全更新和报告漏洞的警报</h3>
<p>请加入 <a href=https://groups.google.com/forum/#!forum/kubernetes-announce>kubernetes-announce</a>
组，这样你就能够收到有关安全公告的邮件。有关如何报告漏洞的更多信息，
请参见<a href=/zh/docs/reference/issues-security/security/>安全报告</a>页面。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-4a02bcca41439e16655f43fa37c81da4>3.17 - 关键插件 Pod 的调度保证</h1>
<p>Kubernetes 核心组件（如 API 服务器、调度器、控制器管理器）在控制平面节点上运行。
但是插件必须在常规集群节点上运行。
其中一些插件对于功能完备的群集至关重要，例如 Heapster、DNS 和 UI。
如果关键插件被逐出（手动或作为升级等其他操作的副作用）或者变成挂起状态，群集可能会停止正常工作。
关键插件进入挂起状态的例子有：集群利用率过高；被逐出的关键插件 Pod 释放了空间，但该空间被之前悬决的 Pod 占用；由于其它原因导致节点上可用资源的总量发生变化。</p>
<p>注意，把某个 Pod 标记为关键 Pod 并不意味着完全避免该 Pod 被逐出；它只能防止该 Pod 变成永久不可用。
被标记为关键性的静态 Pod 不会被逐出。但是，被标记为关键性的非静态 Pod 总是会被重新调度。</p>
<h3 id=标记关键-pod>标记关键 Pod</h3>
<p>要将 Pod 标记为关键性（critical），设置 Pod 的 priorityClassName 为 <code>system-cluster-critical</code> 或者 <code>system-node-critical</code>。
<code>system-node-critical</code> 是最高级别的可用性优先级，甚至比 <code>system-cluster-critical</code> 更高。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-fe6b50655c29ab0b7c1ee549ff64c138>3.18 - 升级集群</h1>
<p>本页概述升级 Kubernetes 集群的步骤。</p>
<p>升级集群的方式取决于你最初部署它的方式、以及后续更改它的方式。</p>
<p>从高层规划的角度看，要执行的步骤是：</p>
<ul>
<li>升级<a class=glossary-tooltip title="控制平面是指容器编排层，它暴露 API 和接口来定义、部署容器和管理容器的生命周期。" data-toggle=tooltip data-placement=top href="/zh/docs/reference/glossary/?all=true#term-control-plane" target=_blank aria-label=控制平面>控制平面</a></li>
<li>升级集群中的节点</li>
<li>升级 <a class=glossary-tooltip title="kubectl 是用来和 Kubernetes 集群进行通信的命令行工具。" data-toggle=tooltip data-placement=top href=/docs/user-guide/kubectl-overview/ target=_blank aria-label=kubectl>kubectl</a> 之类的客户端</li>
<li>根据新 Kubernetes 版本带来的 API 变化，调整清单文件和其他资源</li>
</ul>
<h2 id=before-you-begin>Before you begin</h2>
<p>你必须有一个集群。
本页内容涉及从 Kubernetes 1.26
升级到 Kubernetes 1.27。
如果你的集群未运行 Kubernetes 1.26，
那请参考目标 Kubernetes 版本的文档。</p>
<h2 id=upgrade-approaches>升级方法</h2>
<h3 id=upgrade-kubeadm>kubeadm</h3>
<p>如果你的集群是使用 <code>kubeadm</code> 安装工具部署而来，
那么升级群集的详细信息，请参阅
<a href=/zh/docs/tasks/administer-cluster/kubeadm/kubeadm-upgrade/>升级 kubeadm 集群</a>。</p>
<p>升级集群之后，要记得
<a href=/zh/docs/tasks/tools/>安装最新版本的 <code>kubectl</code></a>.</p>
<h3 id=manual-deployments>手动部署</h3>
<div class="alert alert-warning caution callout" role=alert>
<strong>Caution:</strong> 这些步骤不考虑第三方扩展，例如网络和存储插件。
</div>
<p>你应该跟随下面操作顺序，手动更新控制平面：</p>
<ul>
<li>etcd (所有实例)</li>
<li>kube-apiserver (所有控制平面的宿主机)</li>
<li>kube-controller-manager</li>
<li>kube-scheduler</li>
<li>cloud controller manager, 在你用到时</li>
</ul>
<p>现在，你应该
<a href=/zh/docs/tasks/tools/>安装最新版本的 <code>kubectl</code></a>.</p>
<p>对于群集中的每个节点，
<a href=/zh/docs/tasks/administer-cluster/safely-drain-node/>排空</a>
节点，然后，或者用一个运行了 1.27 kubelet 的新节点替换它；
或者升级此节点的 kubelet，并使节点恢复服务。</p>
<h3 id=upgrade-other>其他部署方式</h3>
<p>参阅你的集群部署工具对应的文档，了解用于维护的推荐设置步骤。</p>
<h2 id=post-upgrade-tasks>升级后的任务</h2>
<h3 id=switch-your-clusters-storage-api-version>切换群集的存储 API 版本</h3>
<p>对象序列化到 etcd，是为了提供集群中活动 Kubernetes 资源的内部表示法，
这些对象都使用特定版本的 API 编写。</p>
<p>当底层的 API 更改时，这些对象可能需要用新 API 重写。
如果不能做到这一点，会导致再也不能用 Kubernetes API 服务器解码、使用该对象。</p>
<p>对于每个受影响的对象，用最新支持的 API 获取它，然后再用最新支持的 API 写回来。</p>
<h3 id=update-manifests>更新清单</h3>
<p>升级到新版本 Kubernetes 就可以提供新的 API。</p>
<p>你可以使用 <code>kubectl convert</code> 命令在不同 API 版本之间转换清单。
例如：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl convert -f pod.yaml --output-version v1
</code></pre></div>
<p><code>kubectl</code> 替换了 <code>pod.yaml</code> 的内容，
在新的清单文件中，<code>kind</code> 被设置为 Pod（未变），
但 <code>apiVersion</code> 则被修订了。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-56de8c25b1486599777034111645b803>3.19 - 名字空间演练</h1>
<p>Kubernetes <a class=glossary-tooltip title="名字空间是 Kubernetes 用来支持隔离单个集群中的资源组的一种抽象。" data-toggle=tooltip data-placement=top href=/zh/docs/concepts/overview/working-with-objects/namespaces/ target=_blank aria-label=名字空间>名字空间</a>
有助于不同的项目、团队或客户去共享 Kubernetes 集群。</p>
<p>名字空间通过以下方式实现这点：</p>
<ol>
<li>为<a href=/zh/docs/concepts/overview/working-with-objects/names/>名字</a>设置作用域.</li>
<li>为集群中的部分资源关联鉴权和策略的机制。</li>
</ol>
<p>使用多个名字空间是可选的。</p>
<p>此示例演示了如何使用 Kubernetes 名字空间细分群集。</p>
<h2 id=before-you-begin>Before you begin</h2>
<p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li>
</ul>
To check the version, enter <code>kubectl version</code>.
</p>
<h2 id=环境准备>环境准备</h2>
<p>此示例作如下假设：</p>
<ol>
<li>你已拥有一个<a href=/zh/docs/setup/>配置好的 Kubernetes 集群</a>。</li>
<li>你已对 Kubernetes 的 <em><a href=/zh/docs/concepts/workloads/pods/>Pods</a></em>、
<em><a href=/zh/docs/concepts/services-networking/service/>Services</a></em> 和
<em><a href=/zh/docs/concepts/workloads/controllers/deployment/>Deployments</a></em>
有基本理解。</li>
</ol>
<h2 id=理解默认名字空间>理解默认名字空间</h2>
<p>默认情况下，Kubernetes 集群会在配置集群时实例化一个默认名字空间，用以存放集群所使用的默认
Pod、Service 和 Deployment 集合。</p>
<p>假设你有一个新的集群，你可以通过执行以下操作来检查可用的名字空间：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get namespaces
</code></pre></div><pre><code>NAME      STATUS    AGE
default   Active    13m
</code></pre>
<h2 id=创建新的名字空间>创建新的名字空间</h2>
<p>在本练习中，我们将创建两个额外的 Kubernetes 名字空间来保存我们的内容。</p>
<p>我们假设一个场景，某组织正在使用共享的 Kubernetes 集群来支持开发和生产：</p>
<p>开发团队希望在集群中维护一个空间，以便他们可以查看用于构建和运行其应用程序的 Pod、Service
和 Deployment 列表。在这个空间里，Kubernetes 资源被自由地加入或移除，
对谁能够或不能修改资源的限制被放宽，以实现敏捷开发。</p>
<p>运维团队希望在集群中维护一个空间，以便他们可以强制实施一些严格的规程，
对谁可以或谁不可以操作运行生产站点的 Pod、Service 和 Deployment 集合进行控制。</p>
<p>该组织可以遵循的一种模式是将 Kubernetes 集群划分为两个名字空间：<code>development</code> 和 <code>production</code>。</p>
<p>让我们创建两个新的名字空间来保存我们的工作。</p>
<p>文件 <a href=/examples/admin/namespace-dev.json><code>namespace-dev.json</code></a> 描述了 <code>development</code> 名字空间:</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/admin/namespace-dev.json download=admin/namespace-dev.json><code>admin/namespace-dev.json</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('admin-namespace-dev-json')" title="Copy admin/namespace-dev.json to clipboard">
</img>
</div>
<div class=includecode id=admin-namespace-dev-json>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
  <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;v1&#34;</span>,
  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;Namespace&#34;</span>,
  <span style=color:green;font-weight:700>&#34;metadata&#34;</span>: {
    <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;development&#34;</span>,
    <span style=color:green;font-weight:700>&#34;labels&#34;</span>: {
      <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;development&#34;</span>
    }
  }
}
</code></pre></div>
</div>
</div>
<p>使用 kubectl 创建 <code>development</code> 名字空间。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create -f https://k8s.io/examples/admin/namespace-dev.json
</code></pre></div>
<p>将下列的内容保存到文件 <a href=/examples/admin/namespace-prod.json><code>namespace-prod.json</code></a> 中，
这些内容是对 <code>production</code> 名字空间的描述：</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/admin/namespace-prod.json download=admin/namespace-prod.json><code>admin/namespace-prod.json</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('admin-namespace-prod-json')" title="Copy admin/namespace-prod.json to clipboard">
</img>
</div>
<div class=includecode id=admin-namespace-prod-json>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
  <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;v1&#34;</span>,
  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;Namespace&#34;</span>,
  <span style=color:green;font-weight:700>&#34;metadata&#34;</span>: {
    <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;production&#34;</span>,
    <span style=color:green;font-weight:700>&#34;labels&#34;</span>: {
      <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;production&#34;</span>
    }
  }
}
</code></pre></div>
</div>
</div>
<p>让我们使用 kubectl 创建 <code>production</code> 名字空间。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create -f https://k8s.io/examples/admin/namespace-prod.json
</code></pre></div>
<p>为了确保一切正常，我们列出集群中的所有名字空间。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get namespaces --show-labels
</code></pre></div><pre><code>NAME          STATUS    AGE       LABELS
default       Active    32m       &lt;none&gt;
development   Active    29s       name=development
production    Active    23s       name=production
</code></pre>
<h2 id=在每个名字空间中创建-pod>在每个名字空间中创建 pod</h2>
<p>Kubernetes 名字空间为集群中的 Pod、Service 和 Deployment 提供了作用域。</p>
<p>与一个名字空间交互的用户不会看到另一个名字空间中的内容。</p>
<p>为了演示这一点，让我们在 development 名字空间中启动一个简单的 Deployment 和 Pod。</p>
<p>我们首先检查一下当前的上下文：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl config view
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>clusters</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>cluster</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>certificate-authority-data</span>:<span style=color:#bbb> </span>REDACTED<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>server</span>:<span style=color:#bbb> </span>https://130.211.122.180<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>lithe-cocoa-92103_kubernetes<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>contexts</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>context</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>cluster</span>:<span style=color:#bbb> </span>lithe-cocoa-92103_kubernetes<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>user</span>:<span style=color:#bbb> </span>lithe-cocoa-92103_kubernetes<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>lithe-cocoa-92103_kubernetes<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>current-context</span>:<span style=color:#bbb> </span>lithe-cocoa-92103_kubernetes<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Config<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>preferences</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>users</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>lithe-cocoa-92103_kubernetes<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>user</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>client-certificate-data</span>:<span style=color:#bbb> </span>REDACTED<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>client-key-data</span>:<span style=color:#bbb> </span>REDACTED<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>token</span>:<span style=color:#bbb> </span>65rZW78y8HbwXXtSXuUw9DbP4FLjHi4b<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>lithe-cocoa-92103_kubernetes-basic-auth<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>user</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>password</span>:<span style=color:#bbb> </span>h5M0FtUUIflBSdI7<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>username</span>:<span style=color:#bbb> </span>admin<span style=color:#bbb>
</span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl config current-context
</code></pre></div><pre><code>lithe-cocoa-92103_kubernetes
</code></pre>
<p>下一步是为 kubectl 客户端定义一个上下文，以便在每个名字空间中工作。
"cluster" 和 "user" 字段的值将从当前上下文中复制。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl config set-context dev --namespace<span style=color:#666>=</span>development <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --cluster<span style=color:#666>=</span>lithe-cocoa-92103_kubernetes <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --user<span style=color:#666>=</span>lithe-cocoa-92103_kubernetes

kubectl config set-context prod --namespace<span style=color:#666>=</span>production <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --cluster<span style=color:#666>=</span>lithe-cocoa-92103_kubernetes <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --user<span style=color:#666>=</span>lithe-cocoa-92103_kubernetes
</code></pre></div>
<p>默认情况下，上述命令会添加两个上下文到 <code>.kube/config</code> 文件中。
你现在可以查看上下文并根据你希望使用的名字空间并在这两个新的请求上下文之间切换。</p>
<p>查看新的上下文：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl config view
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>clusters</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>cluster</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>certificate-authority-data</span>:<span style=color:#bbb> </span>REDACTED<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>server</span>:<span style=color:#bbb> </span>https://130.211.122.180<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>lithe-cocoa-92103_kubernetes<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>contexts</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>context</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>cluster</span>:<span style=color:#bbb> </span>lithe-cocoa-92103_kubernetes<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>user</span>:<span style=color:#bbb> </span>lithe-cocoa-92103_kubernetes<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>lithe-cocoa-92103_kubernetes<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>context</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>cluster</span>:<span style=color:#bbb> </span>lithe-cocoa-92103_kubernetes<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>development<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>user</span>:<span style=color:#bbb> </span>lithe-cocoa-92103_kubernetes<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>dev<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>context</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>cluster</span>:<span style=color:#bbb> </span>lithe-cocoa-92103_kubernetes<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>production<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>user</span>:<span style=color:#bbb> </span>lithe-cocoa-92103_kubernetes<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>prod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>current-context</span>:<span style=color:#bbb> </span>lithe-cocoa-92103_kubernetes<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Config<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>preferences</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>users</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>lithe-cocoa-92103_kubernetes<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>user</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>client-certificate-data</span>:<span style=color:#bbb> </span>REDACTED<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>client-key-data</span>:<span style=color:#bbb> </span>REDACTED<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>token</span>:<span style=color:#bbb> </span>65rZW78y8HbwXXtSXuUw9DbP4FLjHi4b<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>lithe-cocoa-92103_kubernetes-basic-auth<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>user</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>password</span>:<span style=color:#bbb> </span>h5M0FtUUIflBSdI7<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>username</span>:<span style=color:#bbb> </span>admin<span style=color:#bbb>
</span></code></pre></div>
<p>让我们切换到 <code>development</code> 名字空间进行操作。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl config use-context dev
</code></pre></div>
<p>你可以使用下列命令验证当前上下文：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl config current-context
</code></pre></div><pre><code>dev
</code></pre>
<p>此时，我们从命令行向 Kubernetes 集群发出的所有请求都限定在 <code>development</code> 名字空间中。</p>
<p>让我们创建一些内容。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/admin/snowflake-deployment.yaml download=admin/snowflake-deployment.yaml><code>admin/snowflake-deployment.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('admin-snowflake-deployment-yaml')" title="Copy admin/snowflake-deployment.yaml to clipboard">
</img>
</div>
<div class=includecode id=admin-snowflake-deployment-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>snowflake<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>snowflake<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>2</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>snowflake<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>snowflake<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/serve_hostname<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>imagePullPolicy</span>:<span style=color:#bbb> </span>Always<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>snowflake<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>应用清单文件来创建 Deployment。</p>
<p>我们创建了一个副本大小为 2 的 Deployment，该 Deployment 运行名为 <code>snowflake</code> 的 Pod，
其中包含一个仅提供主机名服务的基本容器。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get deployment
</code></pre></div><pre><code>NAME         READY   UP-TO-DATE   AVAILABLE   AGE
snowflake    2/2     2            2           2m
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>snowflake
</code></pre></div><pre><code>NAME                         READY     STATUS    RESTARTS   AGE
snowflake-3968820950-9dgr8   1/1       Running   0          2m
snowflake-3968820950-vgc4n   1/1       Running   0          2m
</code></pre>
<p>这很棒，开发人员可以做他们想要的事情，而不必担心影响 <code>production</code> 名字空间中的内容。</p>
<p>让我们切换到 <code>production</code> 名字空间，展示一个名字空间中的资源如何对另一个名字空间不可见。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl config use-context prod
</code></pre></div>
<p><code>production</code> 名字空间应该是空的，下列命令应该返回的内容为空。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get deployment
kubectl get pods
</code></pre></div>
<p>生产环境需要以放牛的方式运维，让我们创建一些名为 <code>cattle</code> 的 Pod。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create deployment cattle --image<span style=color:#666>=</span>k8s.gcr.io/serve_hostname --replicas<span style=color:#666>=</span><span style=color:#666>5</span>
kubectl get deployment
</code></pre></div><pre><code>NAME         READY   UP-TO-DATE   AVAILABLE   AGE
cattle       5/5     5            5           10s
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods -l <span style=color:#b8860b>run</span><span style=color:#666>=</span>cattle
</code></pre></div><pre><code>NAME                      READY     STATUS    RESTARTS   AGE
cattle-2263376956-41xy6   1/1       Running   0          34s
cattle-2263376956-kw466   1/1       Running   0          34s
cattle-2263376956-n4v97   1/1       Running   0          34s
cattle-2263376956-p5p3i   1/1       Running   0          34s
cattle-2263376956-sxpth   1/1       Running   0          34s
</code></pre>
<p>此时，应该很清楚的展示了用户在一个名字空间中创建的资源对另一个名字空间是不可见的。</p>
<p>随着 Kubernetes 中的策略支持的发展，我们将扩展此场景，以展示如何为每个名字空间提供不同的授权规则。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-09cc2cf3e0f23a3996e6cb31dc4d867c>3.20 - 启用/禁用 Kubernetes API</h1>
<p>本页展示怎么用集群的
<a class=glossary-tooltip title="控制平面是指容器编排层，它暴露 API 和接口来定义、部署容器和管理容器的生命周期。" data-toggle=tooltip data-placement=top href="/zh/docs/reference/glossary/?all=true#term-control-plane" target=_blank aria-label=控制平面>控制平面</a>.
启用/禁用 API 版本。</p>
<p>通过 API 服务器的命令行参数 <code>--runtime-config=api/&lt;version></code> ，
可以开启/关闭某个指定的 API 版本。
此参数的值是一个逗号分隔的 API 版本列表。
此列表中，后面的值可以覆盖前面的值。</p>
<p>命令行参数 <code>runtime-config</code> 支持两个特殊的值（keys）：</p>
<ul>
<li><code>api/all</code>：指所有已知的 API</li>
<li><code>api/legacy</code>：指过时的 API。过时的 API 就是明确地
<a href=/zh/docs/reference/using-api/deprecation-policy/>弃用</a>
的 API。</li>
</ul>
<p>例如：为了停用除去 v1 版本之外的全部其他 API 版本，
就用参数 <code>--runtime-config=api/all=false,api/v1=true</code> 启动 <code>kube-apiserver</code>。</p>
<h2 id=what-s-next>What's next</h2>
<p>阅读<a href=/zh/docs/reference/command-line-tools-reference/kube-apiserver/>完整的文档</a>,
以了解 <code>kube-apiserver</code> 组件。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-9ceed97f912df7289ed8872e290cfbad>3.21 - 在 Kubernetes 集群中使用 NodeLocal DNSCache</h1>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.18 [stable]</code>
</div>
<p>本页概述了 Kubernetes 中的 NodeLocal DNSCache 功能。</p>
<h2 id=before-you-begin>Before you begin</h2>
<p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li>
</ul>
To check the version, enter <code>kubectl version</code>.
</p>
<h2 id=引言>引言</h2>
<p>NodeLocal DNSCache 通过在集群节点上作为 DaemonSet 运行 DNS 缓存代理来提高集群 DNS 性能。
在当今的体系结构中，运行在 ClusterFirst DNS 模式下的 Pod 可以连接到 kube-dns <code>serviceIP</code> 进行 DNS 查询。
通过 kube-proxy 添加的 iptables 规则将其转换为 kube-dns/CoreDNS 端点。
借助这种新架构，Pods 将可以访问在同一节点上运行的 DNS 缓存代理，从而避免 iptables DNAT 规则和连接跟踪。
本地缓存代理将查询 kube-dns 服务以获取集群主机名的缓存缺失（默认为 "<code>cluster.local</code>" 后缀）。</p>
<h2 id=动机>动机</h2>
<ul>
<li>使用当前的 DNS 体系结构，如果没有本地 kube-dns/CoreDNS 实例，则具有最高 DNS QPS
的 Pod 可能必须延伸到另一个节点。
在这种场景下，拥有本地缓存将有助于改善延迟。</li>
</ul>
<ul>
<li>跳过 iptables DNAT 和连接跟踪将有助于减少
<a href=https://github.com/kubernetes/kubernetes/issues/56903>conntrack 竞争</a>
并避免 UDP DNS 条目填满 conntrack 表。</li>
</ul>
<ul>
<li>从本地缓存代理到 kube-dns 服务的连接可以升级为 TCP 。
TCP conntrack 条目将在连接关闭时被删除，相反 UDP 条目必须超时
（<a href=https://www.kernel.org/doc/Documentation/networking/nf_conntrack-sysctl.txt>默认</a>
<code>nf_conntrack_udp_timeout</code> 是 30 秒）。</li>
</ul>
<ul>
<li>将 DNS 查询从 UDP 升级到 TCP 将减少由于被丢弃的 UDP 包和 DNS 超时而带来的尾部等待时间；
这类延时通常长达 30 秒（3 次重试 + 10 秒超时）。
由于 nodelocal 缓存监听 UDP DNS 查询，应用不需要变更。</li>
</ul>
<ul>
<li>在节点级别对 DNS 请求的度量和可见性。</li>
</ul>
<ul>
<li>可以重新启用负缓存，从而减少对 kube-dns 服务的查询数量。</li>
</ul>
<h2 id=架构图>架构图</h2>
<p>启用 NodeLocal DNSCache 之后，DNS 查询所遵循的路径如下：</p>
<figure class=diagram-medium>
<img src=/images/docs/nodelocaldns.svg alt="NodeLocal DNSCache 流"> <figcaption>
<h4>Nodelocal DNSCache 流</h4><p>此图显示了 NodeLocal DNSCache 如何处理 DNS 查询。</p>
</figcaption>
</figure>
<h2 id=配置>配置</h2>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> NodeLocal DNSCache 的本地侦听 IP 地址可以是任何地址，只要该地址不和你的集群里现有的 IP 地址发生冲突。
推荐使用本地范围内的地址，例如，IPv4 链路本地区段 '169.254.0.0/16' 内的地址，
或者 IPv6 唯一本地地址区段 'fd00::/8' 内的地址。
</div>
<p>可以使用以下步骤启动此功能：</p>
<ul>
<li>根据示例 <a href=https://github.com/kubernetes/kubernetes/blob/master/cluster/addons/dns/nodelocaldns/nodelocaldns.yaml><code>nodelocaldns.yaml</code></a>
准备一个清单，把它保存为 <code>nodelocaldns.yaml</code>。</li>
</ul>
<ul>
<li>如果使用 IPv6，在使用 IP:Port 格式的时候需要把 CoreDNS 配置文件里的所有 IPv6 地址用方括号包起来。
如果你使用上述的示例清单，需要把
<a href=https://github.com/kubernetes/kubernetes/blob/b2ecd1b3a3192fbbe2b9e348e095326f51dc43dd/cluster/addons/dns/nodelocaldns/nodelocaldns.yaml#L70>配置行 L70</a>
修改为 <code>health [__PILLAR__LOCAL__DNS__]:8080</code>。</li>
</ul>
<ul>
<li>
<p>把清单里的变量更改为正确的值：</p>
<pre><code>kubedns=`kubectl get svc kube-dns -n kube-system -o jsonpath={.spec.clusterIP}`
domain=&lt;cluster-domain&gt;
localdns=&lt;node-local-address&gt;
</code></pre><p><code>&lt;cluster-domain></code> 的默认值是 "<code>cluster.local</code>"。<code>&lt;node-local-address></code> 是
NodeLocal DNSCache 选择的本地侦听 IP 地址。</p>
</li>
</ul>
<ul>
<li>
<p>如果 kube-proxy 运行在 IPTABLES 模式：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>sed -i <span style=color:#b44>&#34;s/__PILLAR__LOCAL__DNS__/</span><span style=color:#b8860b>$localdns</span><span style=color:#b44>/g; s/__PILLAR__DNS__DOMAIN__/</span><span style=color:#b8860b>$domain</span><span style=color:#b44>/g; s/__PILLAR__DNS__SERVER__/</span><span style=color:#b8860b>$kubedns</span><span style=color:#b44>/g&#34;</span> nodelocaldns.yaml
</code></pre></div><p>node-local-dns Pods 会设置 <code>__PILLAR__CLUSTER__DNS__</code> 和 <code>__PILLAR__UPSTREAM__SERVERS__</code>。
在此模式下, node-local-dns Pods 会同时侦听 kube-dns 服务的 IP 地址和
<code>&lt;node-local-address></code> 的地址，以便 Pods 可以使用其中任何一个 IP 地址来查询 DNS 记录。</p>
</li>
</ul>
<ul>
<li>
<p>如果 kube-proxy 运行在 IPVS 模式：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>sed -i <span style=color:#b44>&#34;s/__PILLAR__LOCAL__DNS__/</span><span style=color:#b8860b>$localdns</span><span style=color:#b44>/g; s/__PILLAR__DNS__DOMAIN__/</span><span style=color:#b8860b>$domain</span><span style=color:#b44>/g; s/__PILLAR__DNS__SERVER__//g; s/__PILLAR__CLUSTER__DNS__/</span><span style=color:#b8860b>$kubedns</span><span style=color:#b44>/g&#34;</span> nodelocaldns.yaml
</code></pre></div><p>在此模式下，node-local-dns Pods 只会侦听 <code>&lt;node-local-address></code> 的地址。
node-local-dns 接口不能绑定 kube-dns 的集群 IP 地址，因为 IPVS 负载均衡
使用的接口已经占用了该地址。
node-local-dns Pods 会设置 <code>__PILLAR__UPSTREAM__SERVERS__</code>。</p>
</li>
</ul>
<ul>
<li>运行 <code>kubectl create -f nodelocaldns.yaml</code></li>
<li>如果 kube-proxy 运行在 IPVS 模式，需要修改 kubelet 的 <code>--cluster-dns</code> 参数
NodeLocal DNSCache 正在侦听的 <code>&lt;node-local-address></code> 地址。
否则，不需要修改 <code>--cluster-dns</code> 参数，因为 NodeLocal DNSCache 会同时侦听
kube-dns 服务的 IP 地址和 <code>&lt;node-local-address></code> 的地址。</li>
</ul>
<p>启用后，node-local-dns Pods 将在每个集群节点上的 kube-system 名字空间中运行。
此 Pod 在缓存模式下运行 <a href=https://github.com/coredns/coredns>CoreDNS</a> ，
因此每个节点都可以使用不同插件公开的所有 CoreDNS 指标。</p>
<p>如果要禁用该功能，你可以使用 <code>kubectl delete -f &lt;manifest></code> 来删除 DaemonSet。
你还应该回滚你对 kubelet 配置所做的所有改动。</p>
<h2 id=stubdomains-和上游服务器配置>StubDomains 和上游服务器配置</h2>
<p><code>node-local-dns</code> Pod 能够自动读取 <code>kube-system</code> 名字空间中 <code>kube-dns</code> ConfigMap
中保存的 StubDomains 和上游服务器信息。ConfigMap 中的内容需要遵从
<a href=/zh/docs/tasks/administer-cluster/dns-custom-nameservers/#example-1>此示例</a>
中所给的格式。
<code>node-local-dns</code> ConfigMap 也可被直接修改，使用 Corefile 格式设置 stubDomain 配置。
某些云厂商可能不允许直接修改 <code>node-local-dns</code> ConfigMap 的内容。
在这种情况下，可以更新 <code>kube-dns</code> ConfigMap。</p>
<h2 id=设置内存限制>设置内存限制</h2>
<p><code>node-local-dns</code> Pod 使用内存来保存缓存项并处理查询。
由于它们并不监视 Kubernetes 对象变化，集群规模或者 Service/Endpoints
的数量都不会直接影响内存用量。内存用量会受到 DNS 查询模式的影响。
根据 <a href=https://github.com/coredns/deployment/blob/master/kubernetes/Scaling_CoreDNS.md>CoreDNS 文档</a>,</p>
<blockquote>
<p>The default cache size is 10000 entries, which uses about 30 MB when completely filled.
（默认的缓存大小是 10000 个表项，当完全填充时会使用约 30 MB 内存）</p>
</blockquote>
<p>这一数值是（缓存完全被填充时）每个服务器块的内存用量。
通过设置小一点的缓存大小可以降低内存用量。</p>
<p>并发查询的数量会影响内存需求，因为用来处理查询请求而创建的 Go 协程都需要一定量的内存。
你可以在 forward 插件中使用 <code>max_concurrent</code> 选项设置并发查询数量上限。</p>
<p>如果一个 <code>node-local-dns</code> Pod 尝试使用的内存超出可提供的内存量
（因为系统资源总量的，或者所配置的<a href=/zh/docs/concepts/configuration/manage-resources-containers/>资源约束</a>）的原因，
操作系统可能会关闭这一 Pod 的容器。
发生这种情况时，被终止的（"OOMKilled"）容器不会清理其启动期间所添加的定制包过滤规则。
该 <code>node-local-dns</code> 容器应该会被重启（因其作为 DaemonSet 的一部分被管理），
但因上述原因可能每次容器失败时都会导致 DNS 有一小段时间不可用：
the packet filtering rules direct DNS queries to a local Pod that is unhealthy
（包过滤器规则将 DNS 查询转发到本地某个不健康的 Pod）。</p>
<p>通过不带限制地运行 <code>node-local-dns</code> Pod 并度量其内存用量峰值，你可以为其确定一个合适的内存限制值。
你也可以安装并使用一个运行在 “Recommender Mode（建议者模式）” 的
<a href=https://github.com/kubernetes/autoscaler/tree/master/vertical-pod-autoscaler>VerticalPodAutoscaler</a>，
并查看该组件输出的建议信息。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-fe5ad73163d38596340536ec03a205f0>3.22 - 在 Kubernetes 集群中使用 sysctl</h1>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.21 [stable]</code>
</div>
<p>本文档介绍如何通过 <a class=glossary-tooltip title="用于获取和设置 Unix 内核参数的接口" data-toggle=tooltip data-placement=top href=/zh/docs/tasks/administer-cluster/sysctl-cluster/ target=_blank aria-label=sysctl>sysctl</a>
接口在 Kubernetes 集群中配置和使用内核参数。</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 从 Kubernetes 1.23 版本开始，kubelet 支持使用 <code>/</code> 或 <code>.</code> 作为 sysctl 参数的分隔符。
例如，你可以使用点或者斜线作为分隔符表示相同的 sysctl 参数，以点作为分隔符表示为： <code>kernel.shm_rmid_forced</code>，
或者以斜线作为分隔符表示为：<code>kernel/shm_rmid_forced</code>。
更多 sysctl 参数转换方法详情请参考 Linux man-pages
<a href=https://man7.org/linux/man-pages/man5/sysctl.d.5.html>sysctl.d(5)</a> 。
设置 Pod 的 Sysctl 参数 和 PodSecurityPolicy 功能尚不支持设置包含斜线的 Sysctl 参数。
</div>
<h2 id=before-you-begin>Before you begin</h2>
<p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li>
</ul>
<p>对一些步骤，你需要能够重新配置在你的集群里运行的 kubelet 命令行的选项。</p>
<h2 id=获取-sysctl-的参数列表>获取 Sysctl 的参数列表</h2>
<p>在 Linux 中，管理员可以通过 sysctl 接口修改内核运行时的参数。在 <code>/proc/sys/</code>
虚拟文件系统下存放许多内核参数。这些参数涉及了多个内核子系统，如：</p>
<ul>
<li>内核子系统（通常前缀为: <code>kernel.</code>）</li>
<li>网络子系统（通常前缀为: <code>net.</code>）</li>
<li>虚拟内存子系统（通常前缀为: <code>vm.</code>）</li>
<li>MDADM 子系统（通常前缀为: <code>dev.</code>）</li>
<li>更多子系统请参见<a href=https://www.kernel.org/doc/Documentation/sysctl/README>内核文档</a>。</li>
</ul>
<p>若要获取完整的参数列表，请执行以下命令</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>sudo sysctl -a
</code></pre></div>
<h2 id=启用非安全的-sysctl-参数>启用非安全的 Sysctl 参数</h2>
<p>sysctl 参数分为 <em>安全</em> 和 <em>非安全的</em>。
<em>安全</em> sysctl 参数除了需要设置恰当的命名空间外，在同一 node 上的不同 Pod
之间也必须是 <em>相互隔离的</em>。这意味着在 Pod 上设置 <em>安全</em> sysctl 参数</p>
<ul>
<li>必须不能影响到节点上的其他 Pod</li>
<li>必须不能损害节点的健康</li>
<li>必须不允许使用超出 Pod 的资源限制的 CPU 或内存资源。</li>
</ul>
<p>至今为止，大多数 <em>有命名空间的</em> sysctl 参数不一定被认为是 <em>安全</em> 的。
以下几种 sysctl 参数是 <em>安全的</em>：</p>
<ul>
<li><code>kernel.shm_rmid_forced</code></li>
<li><code>net.ipv4.ip_local_port_range</code></li>
<li><code>net.ipv4.tcp_syncookies</code></li>
<li><code>net.ipv4.ping_group_range</code> （从 Kubernetes 1.18 开始）</li>
<li><code>net.ipv4.ip_unprivileged_port_start</code> （从 Kubernetes 1.22 开始）。</li>
</ul>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 示例中的 <code>net.ipv4.tcp_syncookies</code> 在Linux 内核 4.4 或更低的版本中是无命名空间的。
</div>
<p>在未来的 Kubernetes 版本中，若 kubelet 支持更好的隔离机制，则上述列表中将会
列出更多 <em>安全的</em> sysctl 参数。</p>
<p>所有 <em>安全的</em> sysctl 参数都默认启用。</p>
<p>所有 <em>非安全的</em> sysctl 参数都默认禁用，且必须由集群管理员在每个节点上手动开启。
那些设置了不安全 sysctl 参数的 Pod 仍会被调度，但无法正常启动。</p>
<p>参考上述警告，集群管理员只有在一些非常特殊的情况下（如：高可用或实时应用调整），
才可以启用特定的 <em>非安全的</em> sysctl 参数。
如需启用 <em>非安全的</em> sysctl 参数，请你在每个节点上分别设置 kubelet 命令行参数，例如：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubelet --allowed-unsafe-sysctls <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  <span style=color:#b44>&#39;kernel.msg*,net.core.somaxconn&#39;</span> ...
</code></pre></div>
<p>如果你使用 <a class=glossary-tooltip title="Minikube 是用来在本地运行 Kubernetes 的一种工具。" data-toggle=tooltip data-placement=top href=/docs/getting-started-guides/minikube/ target=_blank aria-label=Minikube>Minikube</a>，可以通过 <code>extra-config</code> 参数来配置：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>minikube start --extra-config<span style=color:#666>=</span><span style=color:#b44>&#34;kubelet.allowed-unsafe-sysctls=kernel.msg*,net.core.somaxconn&#34;</span>...
</code></pre></div>
<p>只有 <em>有命名空间的</em> sysctl 参数可以通过该方式启用。</p>
<h2 id=设置-pod-的-sysctl-参数>设置 Pod 的 Sysctl 参数</h2>
<p>目前，在 Linux 内核中，有许多的 sysctl 参数都是 <em>有命名空间的</em> 。
这就意味着可以为节点上的每个 Pod 分别去设置它们的 sysctl 参数。
在 Kubernetes 中，只有那些有命名空间的 sysctl 参数可以通过 Pod 的 securityContext 对其进行配置。</p>
<p>以下列出有命名空间的 sysctl 参数，在未来的 Linux 内核版本中，此列表可能会发生变化。</p>
<ul>
<li><code>kernel.shm*</code>,</li>
<li><code>kernel.msg*</code>,</li>
<li><code>kernel.sem</code>,</li>
<li><code>fs.mqueue.*</code>,</li>
<li><code>net.*</code>（内核中可以在容器命名空间里被更改的网络配置项相关参数）。然而也有一些特例
（例如，<code>net.netfilter.nf_conntrack_max</code> 和 <code>net.netfilter.nf_conntrack_expect_max</code>
可以在容器命名空间里被更改，但它们是非命名空间的）。</li>
</ul>
<p>没有命名空间的 sysctl 参数称为 <em>节点级别的</em> sysctl 参数。
如果需要对其进行设置，则必须在每个节点的操作系统上手动地去配置它们，
或者通过在 DaemonSet 中运行特权模式容器来配置。</p>
<p>可使用 Pod 的 securityContext 来配置有命名空间的 sysctl 参数，
securityContext 应用于同一个 Pod 中的所有容器。</p>
<p>此示例中，使用 Pod SecurityContext 来对一个安全的 sysctl 参数
<code>kernel.shm_rmid_forced</code> 以及两个非安全的 sysctl 参数
<code>net.core.somaxconn</code> 和 <code>kernel.msgmax</code> 进行设置。
在 Pod 规约中对 <em>安全的</em> 和 <em>非安全的</em> sysctl 参数不做区分。</p>
<div class="alert alert-danger warning callout" role=alert>
<strong>Warning:</strong> 为了避免破坏操作系统的稳定性，请你在了解变更后果之后再修改 sysctl 参数。
</div>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>sysctl-example<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>securityContext</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>sysctls</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>kernel.shm_rmid_forced<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;0&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>net.core.somaxconn<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;1024&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>kernel.msgmax<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;65536&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></code></pre></div>
<div class="alert alert-danger warning callout" role=alert>
<strong>Warning:</strong> 由于 <em>非安全的</em> sysctl 参数其本身具有不稳定性，在使用 <em>非安全的</em> sysctl 参数
时可能会导致一些严重问题，如容器的错误行为、机器资源不足或节点被完全破坏，
用户需自行承担风险。
</div>
<p>最佳实践方案是将集群中具有特殊 sysctl 设置的节点视为 <em>有污点的</em>，并且只调度
需要使用到特殊 sysctl 设置的 Pod 到这些节点上。
建议使用 Kubernetes 的
<a href=/docs/reference/generated/kubectl/kubectl-commands/#taint>污点和容忍度特性</a> 来实现它。</p>
<p>设置了 <em>非安全的</em> sysctl 参数的 Pod 在禁用了这两种 <em>非安全的</em> sysctl 参数配置
的节点上启动都会失败。与 <em>节点级别的</em> sysctl 一样，建议开启
<a href=/docs/reference/generated/kubectl/kubectl-commands/#taint>污点和容忍度特性</a> 或
<a href=/zh/docs/concepts/scheduling-eviction/taint-and-toleration/>为节点配置污点</a>
以便将 Pod 调度到正确的节点之上。</p>
<h2 id=podsecuritypolicy>PodSecurityPolicy</h2>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.21 [deprecated]</code>
</div>
<p>你可以通过在 PodSecurityPolicy 的 <code>forbiddenSysctls</code> 和/或 <code>allowedUnsafeSysctls</code>
字段中，指定 sysctl 或填写 sysctl 匹配模式来进一步为 Pod 设置 sysctl 参数。
sysctl 参数匹配模式以 <code>*</code> 字符结尾，如 <code>kernel.*</code>。
单独的 <code>*</code> 字符匹配所有 sysctl 参数。</p>
<p>所有 <em>安全的</em> sysctl 参数都默认启用。</p>
<p><code>forbiddenSysctls</code> 和 <code>allowedUnsafeSysctls</code> 的值都是字符串列表类型，
可以添加 sysctl 参数名称，也可以添加 sysctl 参数匹配模式（以<code>*</code>结尾）。
只填写 <code>*</code> 则匹配所有的 sysctl 参数。</p>
<p><code>forbiddenSysctls</code> 字段用于禁用特定的 sysctl 参数。
你可以在列表中禁用安全和非安全的 sysctl 参数的组合。
要禁用所有的 sysctl 参数，请设置为 <code>*</code>。</p>
<p>如果要在 <code>allowedUnsafeSysctls</code> 字段中指定一个非安全的 sysctl 参数，
并且它在 <code>forbiddenSysctls</code> 字段中未被禁用，则可以在 Pod 中通过
PodSecurityPolicy 启用该 sysctl 参数。
若要在 PodSecurityPolicy 中开启所有非安全的 sysctl 参数，
请设 <code>allowedUnsafeSysctls</code> 字段值为 <code>*</code>。</p>
<p><code>allowedUnsafeSysctls</code> 与 <code>forbiddenSysctls</code> 两字段的配置不能重叠，
否则这就意味着存在某个 sysctl 参数既被启用又被禁用。</p>
<div class="alert alert-danger warning callout" role=alert>
<strong>Warning:</strong> 如果你通过 PodSecurityPolicy 中的 <code>allowedUnsafeSysctls</code> 字段将非安全的 sysctl
参数列入白名单，但该 sysctl 参数未通过 kubelet 命令行参数
<code>--allowed-unsafe-sysctls</code> 在节点上将其列入白名单，则设置了这个 sysctl
参数的 Pod 将会启动失败。
</div>
<p>以下示例设置启用了以 <code>kernel.msg</code> 为前缀的非安全的 sysctl 参数，同时禁用了
sysctl 参数 <code>kernel.shm_rmid_forced</code>。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>policy/v1beta1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PodSecurityPolicy<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>sysctl-psp<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>allowedUnsafeSysctls</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- kernel.msg*<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>forbiddenSysctls</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- kernel.shm_rmid_forced<span style=color:#bbb>
</span><span style=color:#bbb> </span>...<span style=color:#bbb>
</span></code></pre></div>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-eec61e72c300dbfbf7302400ca966432>3.23 - 在运行中的集群上重新配置节点的 kubelet</h1>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.22 [deprecated]</code>
</div>
<div class="alert alert-warning caution callout" role=alert>
<strong>Caution:</strong> <a href=https://github.com/kubernetes/enhancements/tree/master/keps/sig-node/281-dynamic-kubelet-configuration>动态 kubelet 配置</a>
已经废弃不建议使用。请选择其他方法将配置分发到集群中的节点。
</div>
<p><a href=https://github.com/kubernetes/enhancements/issues/281>动态 kubelet 配置</a>
允许你通过部署一个所有节点都会使用的 ConfigMap
达到在运行中的 Kubernetes 集群中更改 kubelet 配置的目的。</p>
<div class="alert alert-danger warning callout" role=alert>
<strong>Warning:</strong> 所有 kubelet 配置参数都可以被动态更改，但对某些参数来说这类更改是不安全的。
在决定动态更改参数之前，你需要深刻理解这个改动将会如何影响集群的行为。
在将变更扩散到整个集群之前，你需要先在小规模的节点集合上仔细地测试这些配置变动。
特定字段相关的配置建议可以在文档
<a href=/docs/reference/config-api/kubelet-config.v1beta1/><code>KubeletConfiguration</code></a>中找到。
</div>
<h2 id=before-you-begin>Before you begin</h2>
<p>你需要一个 Kubernetes 集群。
你还需要 <code>kubectl</code>，<a href=/zh/docs/tasks/tools/#kubectl>安装</a>并配置好与集群的通信。
To check the version, enter <code>kubectl version</code>.
确保你使用的 <code>kubectl</code> 版本与集群 <a href=/releases/version-skew-policy/>兼容</a>。</p>
<p>在某些例子中使用了命令行工具 <a href=https://stedolan.github.io/jq/>jq</a>。
你并不一定需要 <code>jq</code> 才能完成这些任务，因为总是有一些手工替代的方式。</p>
<p>针对你重新配置的每个节点，你必须设置 kubelet 的标志
<code>-dynamic-config-dir</code>，使之指向一个可写的目录。</p>
<h2 id=重配置-集群中运行节点上的-kubelet>重配置 集群中运行节点上的 kubelet</h2>
<h3 id=基本工作流程概览>基本工作流程概览</h3>
<p>在运行中的集群中配置 kubelet 的基本工作流程如下：</p>
<ol>
<li>编写一个包含 kubelet 配置的 YAML 或 JSON 文件。</li>
<li>将此文件包装在 ConfigMap 中并将其保存到 Kubernetes 控制平面。</li>
<li>更新 kubelet 所在节点对象以使用此 ConfigMap。</li>
</ol>
<p>每个 kubelet 都会在其各自的节点对象上监测（Watch）配置引用。当引用更改时，kubelet 将下载新的配置文件，
更新本地引用指向该文件，然后退出。
为了使该功能正常地工作，你必须运行操作系统级别的服务管理器（如 systemd），
它将会在 kubelet 退出后将其重启。
kubelet 重新启动时，将开始使用新配置。</p>
<p>新配置将会完全地覆盖 <code>--config</code> 所提供的配置，并被命令行标志覆盖。
新配置中未指定的值将收到适合配置版本的默认值
(e.g. <code>kubelet.config.k8s.io/v1beta1</code>)，除非被命令行标志覆盖。</p>
<p>节点 kubelet 配置状态可通过 <code>node.spec.status.config</code> 获取。
一旦你更新了一个节点去使用新的 ConfigMap，
就可以通过观察此状态来确认该节点是否正在使用预期配置。</p>
<p>本文中使用命令 <code>kubectl edit</code> 来编辑节点，还有其他的方式可以修改节点的规约，
比如更利于脚本化工作流程的 <code>kubectl patch</code>。</p>
<p>本文仅仅讲述在单节点上使用每个 ConfigMap。请注意对于多个节点使用相同的 ConfigMap
也是合法的。</p>
<div class="alert alert-danger warning callout" role=alert>
<strong>Warning:</strong> 尽管通过就地更新 ConfigMap 来更改配置是 <em>可能的</em>。
但是这样做会导致所有使用该 ConfigMap 配置的 kubelet 同时更新。
更安全的做法是按惯例将 ConfigMap 视为不可变更的，借助于
<code>kubectl</code> 的 <code>--append-hash</code> 选项逐步把更新推广到 <code>node.spec.configSource</code>。
</div>
<h3 id=节点鉴权器的自动-rbac-规则>节点鉴权器的自动 RBAC 规则</h3>
<p>以前，你需要手动创建 RBAC 规则以允许节点访问其分配的 ConfigMap。节点鉴权器现在
能够自动配置这些规则。</p>
<h3 id=生成包含当前配置的文件>生成包含当前配置的文件</h3>
<p>动态 kubelet 配置特性允许你为整个配置对象提供一个重载配置，而不是靠单个字段的叠加。
这是一个更简单的模型，可以更轻松地跟踪配置值的来源，更便于调试问题。
然而，相应的代价是你必须首先了解现有配置，以确保你只更改你打算修改的字段。</p>
<p>组件 kubelet 从其配置文件中加载配置数据，不过你可以通过设置命令行标志
来重载文件中的一些配置。这意味着，如果你仅知道配置文件的内容，而你不知道
命令行重载了哪些配置，你就无法知道 kubelet 的运行时配置是什么。</p>
<p>因为你需要知道运行时所使用的配置才能重载之，你可以从 kubelet 取回其运行时配置。
你可以通过访问 kubelet 的 <code>configz</code> 末端来生成包含节点当前配置的配置文件；
这一操作可以通过 <code>kubectl proxy</code> 来完成。
下一节解释如何完成这一操作。</p>
<div class="alert alert-warning caution callout" role=alert>
<strong>Caution:</strong> 组件 <code>kubelet</code> 上的 <code>configz</code> 末端是用来协助调试的，并非 kubelet 稳定行为的一部分。
请不要在产品环境下依赖此末端的行为，也不要在自动化工具中使用此末端。
</div>
<p>关于如何使用配置文件来配置 kubelet 行为的更多信息可参见
<a href=/zh/docs/tasks/administer-cluster/kubelet-config-file>通过配置文件设置 kubelet 参数</a>
文档。</p>
<h4 id=生成配置文件>生成配置文件</h4>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 下面的任务步骤中使用了 <code>jq</code> 命令以方便处理 JSON 数据。为了完成这里讲述的任务，
你需要安装 <code>jq</code>。如果你更希望手动提取 <code>kubeletconfig</code> 子对象，也可以对这里
的对应步骤做一些调整。
</div>
<ol>
<li>
<p>选择要重新配置的节点。在本例中，此节点的名称为 <code>NODE_NAME</code>。</p>
</li>
<li>
<p>使用以下命令在后台启动 kubectl 代理：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl proxy --port<span style=color:#666>=</span><span style=color:#666>8001</span> &amp;
</code></pre></div></li>
</ol>
<ol start=3>
<li>
<p>运行以下命令从 <code>configz</code> 端点中下载并解压配置。这个命令很长，因此在复制粘贴时要小心。
<strong>如果你使用 zsh</strong>，请注意常见的 zsh 配置要添加反斜杠转义 URL 中变量名称周围的大括号。
例如：在粘贴时，<code>${NODE_NAME}</code> 将被重写为 <code>$\{NODE_NAME\}</code>。
你必须在运行命令之前删除反斜杠，否则命令将失败。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#b8860b>NODE_NAME</span><span style=color:#666>=</span><span style=color:#b44>&#34;the-name-of-the-node-you-are-reconfiguring&#34;</span>; curl -sSL <span style=color:#b44>&#34;http://localhost:8001/api/v1/nodes/</span><span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>NODE_NAME</span><span style=color:#b68;font-weight:700>}</span><span style=color:#b44>/proxy/configz&#34;</span> | jq <span style=color:#b44>&#39;.kubeletconfig|.kind=&#34;KubeletConfiguration&#34;|.apiVersion=&#34;kubelet.config.k8s.io/v1beta1&#34;&#39;</span> &gt; kubelet_configz_<span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>NODE_NAME</span><span style=color:#b68;font-weight:700>}</span>
</code></pre></div></li>
</ol>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 你需要手动将 <code>kind</code> 和 <code>apiVersion</code> 添加到下载对象中，因为它们不是由 <code>configz</code> 末端
返回的。
</div>
<h4 id=修改配置文件>修改配置文件</h4>
<p>使用文本编辑器，改变上述操作生成的文件中一个参数。
例如，你或许会修改 QPS 参数 <code>eventRecordQPS</code>。</p>
<h4 id=把配置文件推送到控制平面>把配置文件推送到控制平面</h4>
<p>用以下命令把编辑后的配置文件推送到控制平面：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl -n kube-system create configmap my-node-config <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --from-file<span style=color:#666>=</span><span style=color:#b8860b>kubelet</span><span style=color:#666>=</span>kubelet_configz_<span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>NODE_NAME</span><span style=color:#b68;font-weight:700>}</span> <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --append-hash -o yaml
</code></pre></div>
<p>下面是合法响应的一个例子：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>creationTimestamp</span>:<span style=color:#bbb> </span>2017-09-14T20:23:33Z<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-node-config-gkt4c2m4b2<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>kube-system<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resourceVersion</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;119980&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selfLink</span>:<span style=color:#bbb> </span>/api/v1/namespaces/kube-system/configmaps/my-node-config-gkt4c2m4b2<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>uid</span>:<span style=color:#bbb> </span>946d785e-998a-11e7-a8dd-42010a800006<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>kubelet</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span><span style=color:#b44;font-style:italic>    </span><span style=color:#bbb>    </span>{...}<span style=color:#bbb>
</span></code></pre></div>
<p>你会在 <code>kube-system</code> 命名空间中创建 ConfigMap，因为 kubelet 是 Kubernetes 的系统组件。</p>
<p><code>--append-hash</code> 选项给 ConfigMap 内容附加了一个简短校验和。
这对于先编辑后推送的工作流程很方便，
因为它自动并确定地为新 ConfigMap 生成新的名称。
在以下示例中，包含生成的哈希字符串的对象名被称为 <code>CONFIG_MAP_NAME</code>。</p>
<h4 id=配置节点使用新的配置>配置节点使用新的配置</h4>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl edit node <span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>NODE_NAME</span><span style=color:#b68;font-weight:700>}</span>
</code></pre></div>
<p>在你的文本编辑器中，在 <code>spec</code> 下增添以下 YAML：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>configSource</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>configMap</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>CONFIG_MAP_NAME<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>kube-system<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>kubeletConfigKey</span>:<span style=color:#bbb> </span>kubelet<span style=color:#bbb>
</span></code></pre></div>
<p>你必须同时指定 <code>name</code>、<code>namespace</code> 和 <code>kubeletConfigKey</code> 这三个属性。
<code>kubeletConfigKey</code> 这个参数通知 kubelet ConfigMap 中的哪个键下面包含所要的配置。</p>
<h4 id=观察节点开始使用新配置>观察节点开始使用新配置</h4>
<p>用 <code>kubectl get node ${NODE_NAME} -o yaml</code> 命令读取节点并检查 <code>node.status.config</code> 内容。
状态部分报告了对应 <code>active</code>（使用中的）配置、<code>assigned</code>（被赋予的）配置和
<code>lastKnownGood</code>（最近已知可用的）配置的配置源。</p>
<ul>
<li><code>active</code> 是 kubelet 当前运行时所使用的版本。</li>
<li><code>assigned</code> 参数是 kubelet 基于 <code>node.spec.configSource</code> 所解析出来的最新版本。</li>
<li><code>lastKnownGood</code> 参数是 kubelet 的回退版本；如果在 <code>node.spec.configSource</code> 中
包含了无效的配置值，kubelet 可以回退到这个版本。</li>
</ul>
<p>如果用本地配置部署节点，使其设置成默认值，这个 <code>lastKnownGood</code> 配置可能不存在。
在 kubelet 配置好后，将更新 <code>lastKnownGood</code> 为一个有效的 <code>assigned</code> 配置。
决定如何确定某配置成为 <code>lastKnownGood</code> 配置的细节并不在 API 保障范畴，
不过目前实现中采用了 10 分钟的宽限期。</p>
<p>你可以使用以下命令（使用 <code>jq</code>）过滤出配置状态：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl get no <span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>NODE_NAME</span><span style=color:#b68;font-weight:700>}</span> -o json | jq <span style=color:#b44>&#39;.status.config&#39;</span>
</code></pre></div>
<p>以下是一个响应示例：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
  <span style=color:green;font-weight:700>&#34;active&#34;</span>: {
    <span style=color:green;font-weight:700>&#34;configMap&#34;</span>: {
      <span style=color:green;font-weight:700>&#34;kubeletConfigKey&#34;</span>: <span style=color:#b44>&#34;kubelet&#34;</span>,
      <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;my-node-config-9mbkccg2cc&#34;</span>,
      <span style=color:green;font-weight:700>&#34;namespace&#34;</span>: <span style=color:#b44>&#34;kube-system&#34;</span>,
      <span style=color:green;font-weight:700>&#34;resourceVersion&#34;</span>: <span style=color:#b44>&#34;1326&#34;</span>,
      <span style=color:green;font-weight:700>&#34;uid&#34;</span>: <span style=color:#b44>&#34;705ab4f5-6393-11e8-b7cc-42010a800002&#34;</span>
    }
  },
  <span style=color:green;font-weight:700>&#34;assigned&#34;</span>: {
    <span style=color:green;font-weight:700>&#34;configMap&#34;</span>: {
      <span style=color:green;font-weight:700>&#34;kubeletConfigKey&#34;</span>: <span style=color:#b44>&#34;kubelet&#34;</span>,
      <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;my-node-config-9mbkccg2cc&#34;</span>,
      <span style=color:green;font-weight:700>&#34;namespace&#34;</span>: <span style=color:#b44>&#34;kube-system&#34;</span>,
      <span style=color:green;font-weight:700>&#34;resourceVersion&#34;</span>: <span style=color:#b44>&#34;1326&#34;</span>,
      <span style=color:green;font-weight:700>&#34;uid&#34;</span>: <span style=color:#b44>&#34;705ab4f5-6393-11e8-b7cc-42010a800002&#34;</span>
    }
  },
  <span style=color:green;font-weight:700>&#34;lastKnownGood&#34;</span>: {
    <span style=color:green;font-weight:700>&#34;configMap&#34;</span>: {
      <span style=color:green;font-weight:700>&#34;kubeletConfigKey&#34;</span>: <span style=color:#b44>&#34;kubelet&#34;</span>,
      <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;my-node-config-9mbkccg2cc&#34;</span>,
      <span style=color:green;font-weight:700>&#34;namespace&#34;</span>: <span style=color:#b44>&#34;kube-system&#34;</span>,
      <span style=color:green;font-weight:700>&#34;resourceVersion&#34;</span>: <span style=color:#b44>&#34;1326&#34;</span>,
      <span style=color:green;font-weight:700>&#34;uid&#34;</span>: <span style=color:#b44>&#34;705ab4f5-6393-11e8-b7cc-42010a800002&#34;</span>
    }
  }
}
</code></pre></div>
<p>如果你没有安装 <code>jq</code>，你可以查看整个响应对象，查找其中的 <code>node.status.config</code>
部分。</p>
<p>如果发生错误，kubelet 会在 <code>Node.Status.Config.Error</code> 中显示出错误信息的结构体。
错误可能出现在列表<a href=#understanding-node-config-status-errors>理解节点状态配置错误信息</a>中。
你可以在 kubelet 日志中搜索相同的文本以获取更多详细信息和有关错误的上下文。</p>
<h4 id=make-more-changes>做出更多的改变 </h4>
<p>按照下面的工作流程做出更多的改变并再次推送它们。
你每次推送一个 ConfigMap 的新内容时，kubectl 的 <code>--append-hash</code> 选项都会给
ConfigMap 创建一个新的名称。
最安全的上线策略是首先创建一个新的 ConfigMap，然后更新节点以使用新的 ConfigMap。</p>
<h4 id=重置节点以使用其本地默认配置>重置节点以使用其本地默认配置</h4>
<p>要重置节点，使其使用节点创建时使用的配置，可以用
<code>kubectl edit node $ {NODE_NAME}</code> 命令编辑节点，并删除 <code>node.spec.configSource</code>
字段。</p>
<h4 id=观察节点正在使用本地默认配置>观察节点正在使用本地默认配置</h4>
<p>在删除此字段后，<code>node.status.config</code> 最终变成空，所有配置源都已重置为 <code>nil</code>。
这表示本地默认配置成为了 <code>assigned</code>、<code>active</code> 和 <code>lastKnownGood</code> 配置，
并且没有报告错误。</p>
<h2 id=kubectl-patch-示例><code>kubectl patch</code> 示例</h2>
<p>你可以使用几种不同的机制来更改节点的 configSource。</p>
<p>本例使用<code>kubectl patch</code>：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl patch node <span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>NODE_NAME</span><span style=color:#b68;font-weight:700>}</span> -p <span style=color:#b44>&#34;{\&#34;spec\&#34;:{\&#34;configSource\&#34;:{\&#34;configMap\&#34;:{\&#34;name\&#34;:\&#34;</span><span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>CONFIG_MAP_NAME</span><span style=color:#b68;font-weight:700>}</span><span style=color:#b44>\&#34;,\&#34;namespace\&#34;:\&#34;kube-system\&#34;,\&#34;kubeletConfigKey\&#34;:\&#34;kubelet\&#34;}}}}&#34;</span>
</code></pre></div>
<h2 id=了解-kubelet-如何为配置生成检查点>了解 Kubelet 如何为配置生成检查点</h2>
<p>当为节点赋予新配置时，kubelet 会下载并解压配置负载为本地磁盘上的一组文件。
kubelet 还记录一些元数据，用以在本地跟踪已赋予的和最近已知良好的配置源，以便
kubelet 在重新启动时知道使用哪个配置，即使 API 服务器变为不可用。
在为配置信息和相关元数据生成检查点之后，如果检测到已赋予的配置发生改变，则 kubelet 退出。
当 kubelet 被 OS 级服务管理器（例如 <code>systemd</code>）重新启动时，它会读取新的元数据并使用新配置。</p>
<p>当记录的元数据已被完全解析时，意味着它包含选择一个指定的配置版本所需的所有信息
-- 通常是 <code>UID</code> 和 <code>ResourceVersion</code>。
这与 <code>node.spec.configSource</code> 形成对比，后者通过幂等的 <code>namespace/name</code> 声明来标识
目标 ConfigMap；kubelet 尝试使用此 ConfigMap 的最新版本。</p>
<p>当你在调试节点上问题时，可以检查 kubelet 的配置元数据和检查点。kubelet 的检查点目录结构是：</p>
<pre><code class=language-none data-lang=none>- --dynamic-config-dir （用于管理动态配置的根目录）
|-- meta
  | - assigned （编码后的 kubeletconfig/v1beta1.SerializedNodeConfigSource 对象，对应赋予的配置）
  | - last-known-good （编码后的 kubeletconfig/v1beta1.SerializedNodeConfigSource 对象，对应最近已知可用配置）
| - checkpoints
  | - uid1 （用 uid1 来标识的对象版本目录)
    | - resourceVersion1 （uid1 对象 resourceVersion1 版本下所有解压文件的目录）
    | - ...
  | - ...
</code></pre>
<h2 id=understanding-node-config-status-errors>理解 <code>Node.Status.Config.Error</code> 消息</h2>
<p>下表描述了使用动态 kubelet 配置时可能发生的错误消息。
你可以在 kubelet 日志中搜索相同的文本来获取有关错误的其他详细信息和上下文。</p>
<table><caption style=display:none>理解 node.status.config.error 消息</caption>
<thead>
<tr>
<th style=text-align:left>错误信息</th>
<th style=text-align:left>可能的原因</th>
</tr>
</thead>
<tbody>
<tr>
<td style=text-align:left>failed to load config, see Kubelet log for details</td>
<td style=text-align:left>kubelet 可能无法解析下载配置的有效负载，或者当尝试从磁盘中加载有效负载时，遇到文件系统错误。</td>
</tr>
<tr>
<td style=text-align:left>failed to validate config, see Kubelet log for details</td>
<td style=text-align:left>有效负载中的配置，与命令行标志所产生的覆盖配置以及特行门控的组合、配置文件本身、远程负载被 kubelet 判定为无效。</td>
</tr>
<tr>
<td style=text-align:left>invalid NodeConfigSource, exactly one subfield must be non-nil, but all were nil</td>
<td style=text-align:left>由于 API 服务器负责对 node.spec.configSource 执行验证，检查其中是否包含至少一个非空子字段，这个消息可能意味着 kubelet 比 API 服务器版本低，因而无法识别更新的源类型。</td>
</tr>
<tr>
<td style=text-align:left>failed to sync: failed to download config, see Kubelet log for details</td>
<td style=text-align:left>kubelet 无法下载配置数据。可能是 node.spec.configSource 无法解析为具体的 API 对象，或者网络错误破坏了下载。处于此错误状态时，kubelet 将重新尝试下载。</td>
</tr>
<tr>
<td style=text-align:left>failed to sync: internal failure, see Kubelet log for details</td>
<td style=text-align:left>kubelet 遇到了一些内部问题，因此无法更新其配置。 例如：发生文件系统错误或无法从内部缓存中读取对象。</td>
</tr>
<tr>
<td style=text-align:left>internal failure, see Kubelet log for details</td>
<td style=text-align:left>在对配置进行同步的循环之外操作配置时，kubelet 遇到了一些内部问题。</td>
</tr>
</tbody>
</table>
<h2 id=what-s-next>What's next</h2>
<ul>
<li><a href=/zh/docs/tasks/administer-cluster/kubelet-config-file>使用配置文件设置 kubelet 参数</a>说明了配置 kubelet 的方法。</li>
<li>阅读 Node 的参考文档，包括 <a href=/docs/reference/kubernetes-api/cluster-resources/node-v1/#NodeSpec>.spec</a> 里的 <code>configSource</code> 字段</li>
<li>查阅<a href=/docs/reference/config-api/kubelet-config.v1beta1/><code>KubeletConfiguration</code></a>文献进一步了解 kubelet
配置信息。</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-4e9de5bc3973e5d2bb8f09ff940c3319>3.24 - 在集群中使用级联删除</h1>
<p>本页面向你展示如何设置在你的集群执行<a class=glossary-tooltip title="Kubernetes 用于清理集群资源的各种机制的统称。" data-toggle=tooltip data-placement=top href=/zh/docs/concepts/workloads/controllers/garbage-collection/ target=_blank aria-label=垃圾收集>垃圾收集</a>
时要使用的<a href=/zh/docs/concepts/architecture/garbage-collection/#cascading-deletion>级联删除</a>
类型。</p>
<h2 id=before-you-begin>Before you begin</h2>
<p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li>
</ul>
<p>你还需要<a href=/zh/docs/tasks/run-application/run-stateless-application-deployment/#creating-and-exploring-an-nginx-deployment>创建一个 Deployment 示例</a>
以试验不同类型的级联删除。你需要为每种级联删除类型来重建 Deployment。</p>
<h2 id=check-owner-references-on-your-pods>检查 Pod 上的属主引用 </h2>
<p>检查确认你的 Pods 上存在 <code>ownerReferences</code> 字段：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>nginx --output<span style=color:#666>=</span>yaml
</code></pre></div>
<p>输出中包含 <code>ownerReferences</code> 字段，类似这样：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb>    </span>...<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>ownerReferences</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>blockOwnerDeletion</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>controller</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ReplicaSet<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-deployment-6b474476c4<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>uid</span>:<span style=color:#bbb> </span>4fdcd81c-bd5d-41f7-97af-3a3b759af9a7<span style=color:#bbb>
</span><span style=color:#bbb>    </span>...<span style=color:#bbb>
</span></code></pre></div>
<h2 id=use-foreground-cascading-deletion>使用前台级联删除 </h2>
<p>默认情况下，Kubernetes 使用<a href=/zh/docs/concepts/architecture/garbage-collection/#background-deletion>后台级联删除</a>
以删除依赖某对象的其他对象。取决于你的集群所运行的 Kubernetes 版本，
你可以使用 <code>kubectl</code> 或者 Kubernetes API 来切换到前台级联删除。
To check the version, enter <code>kubectl version</code>.
</p>
<ul class="nav nav-tabs" id=foreground-deletion role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#foreground-deletion-0 role=tab aria-controls=foreground-deletion-0 aria-selected=true>Kubernetes 1.20.x 及更新版本</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#foreground-deletion-1 role=tab aria-controls=foreground-deletion-1>Kubernetes 1.20.x 之前的版本</a></li></ul>
<div class=tab-content id=foreground-deletion><div id=foreground-deletion-0 class="tab-pane show active" role=tabpanel aria-labelledby=foreground-deletion-0>
<p>
<p>你可以使用 <code>kubectl</code> 或者 Kubernetes API 来基于前台级联删除来删除对象。</p>
<p><strong>使用 kubectl</strong></p>
<p>运行下面的命令：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete deployment nginx-deployment --cascade<span style=color:#666>=</span>foreground
</code></pre></div>
<p><strong>使用 Kubernetes API</strong></p>
<ol>
<li>
<p>启动一个本地代理会话：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl proxy --port<span style=color:#666>=</span><span style=color:#666>8080</span>
</code></pre></div></li>
</ol>
<ol start=2>
<li>
<p>使用 <code>curl</code> 来触发删除操作：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>curl -X DELETE localhost:8080/apis/apps/v1/namespaces/default/deployments/nginx-deployment <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>    -d <span style=color:#b44>&#39;{&#34;kind&#34;:&#34;DeleteOptions&#34;,&#34;apiVersion&#34;:&#34;v1&#34;,&#34;propagationPolicy&#34;:&#34;Foreground&#34;}&#39;</span> <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>    -H <span style=color:#b44>&#34;Content-Type: application/json&#34;</span>
</code></pre></div>
<p>输出中包含 <code>foregroundDeletion</code> <a class=glossary-tooltip title="一个带有命名空间的键，告诉 Kubernetes 等到特定的条件被满足后， 再完全删除被标记为删除的资源。" data-toggle=tooltip data-placement=top href=/zh/docs/concepts/overview/working-with-objects/finalizers/ target=_blank aria-label=finalizer>finalizer</a>，
类似这样：</p>
<pre><code>&quot;kind&quot;: &quot;Deployment&quot;,
&quot;apiVersion&quot;: &quot;apps/v1&quot;,
&quot;metadata&quot;: {
    &quot;name&quot;: &quot;nginx-deployment&quot;,
    &quot;namespace&quot;: &quot;default&quot;,
    &quot;uid&quot;: &quot;d1ce1b02-cae8-4288-8a53-30e84d8fa505&quot;,
    &quot;resourceVersion&quot;: &quot;1363097&quot;,
    &quot;creationTimestamp&quot;: &quot;2021-07-08T20:24:37Z&quot;,
    &quot;deletionTimestamp&quot;: &quot;2021-07-08T20:27:39Z&quot;,
    &quot;finalizers&quot;: [
      &quot;foregroundDeletion&quot;
    ]
    ...
</code></pre></li>
</ol>
</div>
<div id=foreground-deletion-1 class=tab-pane role=tabpanel aria-labelledby=foreground-deletion-1>
<p>
<p>你可以通过调用 Kubernetes API 来基于前台级联删除模式删除对象。</p>
<p>进一步的细节，可阅读<a href=/zh/docs/home/supported-doc-versions>特定于你的 Kubernetes 版本的文档</a>。</p>
<ol>
<li>
<p>启动一个本地代理会话：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl proxy --port<span style=color:#666>=</span><span style=color:#666>8080</span>
</code></pre></div></li>
</ol>
<ol start=2>
<li>
<p>使用 <code>curl</code> 来触发删除操作：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>curl -X DELETE localhost:8080/apis/apps/v1/namespaces/default/deployments/nginx-deployment <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>    -d <span style=color:#b44>&#39;{&#34;kind&#34;:&#34;DeleteOptions&#34;,&#34;apiVersion&#34;:&#34;v1&#34;,&#34;propagationPolicy&#34;:&#34;Foreground&#34;}&#39;</span> <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>    -H <span style=color:#b44>&#34;Content-Type: application/json&#34;</span>
</code></pre></div>
<p>输出中包含 <code>foregroundDeletion</code> <a class=glossary-tooltip title="一个带有命名空间的键，告诉 Kubernetes 等到特定的条件被满足后， 再完全删除被标记为删除的资源。" data-toggle=tooltip data-placement=top href=/zh/docs/concepts/overview/working-with-objects/finalizers/ target=_blank aria-label=finalizer>finalizer</a>，
类似这样：</p>
<pre><code>&quot;kind&quot;: &quot;Deployment&quot;,
&quot;apiVersion&quot;: &quot;apps/v1&quot;,
&quot;metadata&quot;: {
    &quot;name&quot;: &quot;nginx-deployment&quot;,
    &quot;namespace&quot;: &quot;default&quot;,
    &quot;uid&quot;: &quot;d1ce1b02-cae8-4288-8a53-30e84d8fa505&quot;,
    &quot;resourceVersion&quot;: &quot;1363097&quot;,
    &quot;creationTimestamp&quot;: &quot;2021-07-08T20:24:37Z&quot;,
    &quot;deletionTimestamp&quot;: &quot;2021-07-08T20:27:39Z&quot;,
    &quot;finalizers&quot;: [
      &quot;foregroundDeletion&quot;
    ]
    ...
</code></pre></li>
</ol>
</div></div>
<h2 id=use-background-cascading-deletion>使用后台级联删除</h2>
<ol>
<li><a href=/zh/docs/tasks/run-application/run-stateless-application-deployment/#creating-and-exploring-an-nginx-deployment>创建一个 Deployment 示例</a>。</li>
<li>基于你的集群所运行的 Kubernetes 版本，使用 <code>kubectl</code> 或者 Kubernetes API 来删除 Deployment。
To check the version, enter <code>kubectl version</code>.
</li>
</ol>
<ul class="nav nav-tabs" id=background-deletion role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#background-deletion-0 role=tab aria-controls=background-deletion-0 aria-selected=true>Kubernetes 1.20.x 及更新版本</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#background-deletion-1 role=tab aria-controls=background-deletion-1>Kubernetes 1.20.x 之前的版本</a></li></ul>
<div class=tab-content id=background-deletion><div id=background-deletion-0 class="tab-pane show active" role=tabpanel aria-labelledby=background-deletion-0>
<p>
<p>你可以使用 <code>kubectl</code> 或者 Kubernetes API 来执行后台级联删除方式的对象删除操作。</p>
<p>Kubernetes 默认采用后台级联删除方式，如果你在运行下面的命令时不指定
<code>--cascade</code> 标志或者 <code>propagationPolicy</code> 参数时，用这种方式来删除对象。</p>
<p><strong>使用 kubectl</strong></p>
<p>运行下面的命令：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete deployment nginx-deployment --cascade<span style=color:#666>=</span>background
</code></pre></div>
<p><strong>使用 Kubernetes API</strong></p>
<ol>
<li>
<p>启动一个本地代理会话：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl proxy --port<span style=color:#666>=</span><span style=color:#666>8080</span>
</code></pre></div></li>
</ol>
<ol start=2>
<li>
<p>使用 <code>curl</code> 来触发删除操作：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>curl -X DELETE localhost:8080/apis/apps/v1/namespaces/default/deployments/nginx-deployment <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>    -d <span style=color:#b44>&#39;{&#34;kind&#34;:&#34;DeleteOptions&#34;,&#34;apiVersion&#34;:&#34;v1&#34;,&#34;propagationPolicy&#34;:&#34;Background&#34;}&#39;</span> <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>    -H <span style=color:#b44>&#34;Content-Type: application/json&#34;</span>
</code></pre></div>
<p>输出类似于：</p>
<pre><code>&quot;kind&quot;: &quot;Status&quot;,
&quot;apiVersion&quot;: &quot;v1&quot;,
...
&quot;status&quot;: &quot;Success&quot;,
&quot;details&quot;: {
    &quot;name&quot;: &quot;nginx-deployment&quot;,
    &quot;group&quot;: &quot;apps&quot;,
    &quot;kind&quot;: &quot;deployments&quot;,
    &quot;uid&quot;: &quot;cc9eefb9-2d49-4445-b1c1-d261c9396456&quot;
}
</code></pre></li>
</ol>
</div>
<div id=background-deletion-1 class=tab-pane role=tabpanel aria-labelledby=background-deletion-1>
<p>
<p>Kubernetes 默认采用后台级联删除方式，如果你在运行下面的命令时不指定
<code>--cascade</code> 标志或者 <code>propagationPolicy</code> 参数时，用这种方式来删除对象。</p>
<p>进一步的细节，可阅读<a href=/zh/docs/home/supported-doc-versions>特定于你的 Kubernetes 版本的文档</a>。</p>
<p><strong>使用 kubectl</strong></p>
<p>运行下面的命令：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete deployment nginx-deployment --cascade<span style=color:#666>=</span><span style=color:#a2f>true</span>
</code></pre></div>
<p><strong>使用 Kubernetes API</strong></p>
<ol>
<li>
<p>启动一个本地代理会话：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl proxy --port<span style=color:#666>=</span><span style=color:#666>8080</span>
</code></pre></div></li>
</ol>
<ol start=2>
<li>
<p>使用 <code>curl</code> 来触发删除操作：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>curl -X DELETE localhost:8080/apis/apps/v1/namespaces/default/deployments/nginx-deployment <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>    -d <span style=color:#b44>&#39;{&#34;kind&#34;:&#34;DeleteOptions&#34;,&#34;apiVersion&#34;:&#34;v1&#34;,&#34;propagationPolicy&#34;:&#34;Background&#34;}&#39;</span> <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>    -H <span style=color:#b44>&#34;Content-Type: application/json&#34;</span>
</code></pre></div>
<p>输出类似于：</p>
<pre><code>&quot;kind&quot;: &quot;Status&quot;,
&quot;apiVersion&quot;: &quot;v1&quot;,
...
&quot;status&quot;: &quot;Success&quot;,
&quot;details&quot;: {
    &quot;name&quot;: &quot;nginx-deployment&quot;,
    &quot;group&quot;: &quot;apps&quot;,
    &quot;kind&quot;: &quot;deployments&quot;,
    &quot;uid&quot;: &quot;cc9eefb9-2d49-4445-b1c1-d261c9396456&quot;
}
</code></pre></li>
</ol>
</div></div>
<h2 id=set-orphan-deletion-policy>删除属主对象和孤立的依赖对象 </h2>
<p>默认情况下，当你告诉 Kubernetes 删除某个对象时，
<a class=glossary-tooltip title="控制器通过 apiserver 监控集群的公共状态，并致力于将当前状态转变为期望的状态。" data-toggle=tooltip data-placement=top href=/zh/docs/concepts/architecture/controller/ target=_blank aria-label=控制器>控制器</a> 也会删除依赖该对象
的其他对象。
取决于你的集群所运行的 Kubernetes 版本，你也可以使用 <code>kubectl</code> 或者 Kubernetes
API 来让 Kubernetes <em>孤立</em> 这些依赖对象。
To check the version, enter <code>kubectl version</code>.
</p>
<ul class="nav nav-tabs" id=orphan-objects role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#orphan-objects-0 role=tab aria-controls=orphan-objects-0 aria-selected=true>Kubernetes 1.20.x 及更新版本</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#orphan-objects-1 role=tab aria-controls=orphan-objects-1>Kubernetes 1.20.x 之前的版本</a></li></ul>
<div class=tab-content id=orphan-objects><div id=orphan-objects-0 class="tab-pane show active" role=tabpanel aria-labelledby=orphan-objects-0>
<p>
<p><strong>使用 kubectl</strong></p>
<p>运行下面的命令：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete deployment nginx-deployment --cascade<span style=color:#666>=</span>orphan
</code></pre></div>
<p><strong>使用 Kubernetes API</strong></p>
<ol>
<li>
<p>启动一个本地代理会话：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl proxy --port<span style=color:#666>=</span><span style=color:#666>8080</span>
</code></pre></div></li>
</ol>
<ol start=2>
<li>
<p>使用 <code>curl</code> 来触发删除操作：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>curl -X DELETE localhost:8080/apis/apps/v1/namespaces/default/deployments/nginx-deployment <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>    -d <span style=color:#b44>&#39;{&#34;kind&#34;:&#34;DeleteOptions&#34;,&#34;apiVersion&#34;:&#34;v1&#34;,&#34;propagationPolicy&#34;:&#34;Orphan&#34;}&#39;</span> <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>    -H <span style=color:#b44>&#34;Content-Type: application/json&#34;</span>
</code></pre></div>
<p>输出中在 <code>finalizers</code> 字段中包含 <code>orphan</code>，如下所示：</p>
<pre><code>&quot;kind&quot;: &quot;Deployment&quot;,
&quot;apiVersion&quot;: &quot;apps/v1&quot;,
&quot;namespace&quot;: &quot;default&quot;,
&quot;uid&quot;: &quot;6f577034-42a0-479d-be21-78018c466f1f&quot;,
&quot;creationTimestamp&quot;: &quot;2021-07-09T16:46:37Z&quot;,
&quot;deletionTimestamp&quot;: &quot;2021-07-09T16:47:08Z&quot;,
&quot;deletionGracePeriodSeconds&quot;: 0,
&quot;finalizers&quot;: [
  &quot;orphan&quot;
],
...
</code></pre></li>
</ol>
</div>
<div id=orphan-objects-1 class=tab-pane role=tabpanel aria-labelledby=orphan-objects-1>
<p>
<p>进一步的细节，可阅读<a href=/zh/docs/home/supported-doc-versions>特定于你的 Kubernetes 版本的文档</a>。</p>
<p><strong>使用 kubectl</strong></p>
<p>运行下面的命令：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete deployment nginx-deployment --cascade<span style=color:#666>=</span>orphan
</code></pre></div>
<p><strong>使用 Kubernetes API</strong></p>
<ol>
<li>
<p>启动一个本地代理会话：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl proxy --port<span style=color:#666>=</span><span style=color:#666>8080</span>
</code></pre></div></li>
</ol>
<ol start=2>
<li>
<p>使用 <code>curl</code> 来触发删除操作：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>curl -X DELETE localhost:8080/apis/apps/v1/namespaces/default/deployments/nginx-deployment <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>    -d <span style=color:#b44>&#39;{&#34;kind&#34;:&#34;DeleteOptions&#34;,&#34;apiVersion&#34;:&#34;v1&#34;,&#34;propagationPolicy&#34;:&#34;Orphan&#34;}&#39;</span> <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>    -H <span style=color:#b44>&#34;Content-Type: application/json&#34;</span>
</code></pre></div>
<p>输出中在 <code>finalizers</code> 字段中包含 <code>orphan</code>，如下所示：</p>
<pre><code>&quot;kind&quot;: &quot;Deployment&quot;,
&quot;apiVersion&quot;: &quot;apps/v1&quot;,
&quot;namespace&quot;: &quot;default&quot;,
&quot;uid&quot;: &quot;6f577034-42a0-479d-be21-78018c466f1f&quot;,
&quot;creationTimestamp&quot;: &quot;2021-07-09T16:46:37Z&quot;,
&quot;deletionTimestamp&quot;: &quot;2021-07-09T16:47:08Z&quot;,
&quot;deletionGracePeriodSeconds&quot;: 0,
&quot;finalizers&quot;: [
  &quot;orphan&quot;
],
...
</code></pre></li>
</ol>
</div></div>
<p>你可以检查 Deployment 所管理的 Pods 仍然处于运行状态：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>nginx
</code></pre></div><h2 id=what-s-next>What's next</h2>
<ul>
<li>了解 Kubernetes 中的<a href=/zh/docs/concepts/overview/working-with-objects/owners-dependents/>属主与依赖</a></li>
<li>了解 Kubernetes <a href=/zh/docs/concepts/overview/working-with-objects/finalizers/>finalizers</a></li>
<li>了解<a href=/zh/docs/concepts/architecture/garbage-collection/>垃圾收集</a>.</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-a3790dfb57271d13517e549dffa805b9>3.25 - 声明网络策略</h1>
<p>本文可以帮助你开始使用 Kubernetes 的
<a href=/zh/docs/concepts/services-networking/network-policies/>NetworkPolicy API</a>
声明网络策略去管理 Pod 之间的通信</p>
<div class="alert alert-secondary callout third-party-content" role=alert><strong>Note:</strong>
This section links to third party projects that provide functionality required by Kubernetes. The Kubernetes project authors aren't responsible for these projects, which are listed alphabetically. To add a project to this list, read the <a href=/docs/contribute/style/content-guide/#third-party-content>content guide</a> before submitting a change. <a href=#third-party-content-disclaimer>More information.</a></div>
<h2 id=before-you-begin>Before you begin</h2>
<p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li>
</ul>
Your Kubernetes server must be at or later than version v1.8.
To check the version, enter <code>kubectl version</code>.
</p>
<p>你首先需要有一个支持网络策略的 Kubernetes 集群。已经有许多支持 NetworkPolicy 的网络提供商，包括：</p>
<ul>
<li><a href=/zh/docs/tasks/administer-cluster/network-policy-provider/antrea-network-policy/>Antrea</a></li>
<li><a href=/zh/docs/tasks/administer-cluster/network-policy-provider/calico-network-policy/>Calico</a></li>
<li><a href=/zh/docs/tasks/administer-cluster/network-policy-provider/cilium-network-policy/>Cilium</a></li>
<li><a href=/zh/docs/tasks/administer-cluster/network-policy-provider/kube-router-network-policy/>Kube-router</a></li>
<li><a href=/zh/docs/tasks/administer-cluster/network-policy-provider/romana-network-policy/>Romana</a></li>
<li><a href=/zh/docs/tasks/administer-cluster/network-policy-provider/weave-network-policy/>Weave 网络</a></li>
</ul>
<h2 id=创建一个-nginx-deployment-并且通过服务将其暴露>创建一个<code>nginx</code> Deployment 并且通过服务将其暴露</h2>
<p>为了查看 Kubernetes 网络策略是怎样工作的，可以从创建一个<code>nginx</code> Deployment 并且通过服务将其暴露开始</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create deployment nginx --image<span style=color:#666>=</span>nginx
</code></pre></div><pre><code class=language-none data-lang=none>deployment.apps/nginx created
</code></pre>
<p>将此 Deployment 以名为 <code>nginx</code> 的 Service 暴露出来：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl expose deployment nginx --port<span style=color:#666>=</span><span style=color:#666>80</span>
</code></pre></div><pre><code class=language-none data-lang=none>service/nginx exposed
</code></pre>
<p>上述命令创建了一个带有一个 nginx 的 Deployment，并将之通过名为 <code>nginx</code> 的
Service 暴露出来。名为 <code>nginx</code> 的 Pod 和 Deployment 都位于 <code>default</code>
名字空间内。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get svc,pod
</code></pre></div><pre><code class=language-none data-lang=none>NAME                        CLUSTER-IP    EXTERNAL-IP   PORT(S)    AGE
svc/kubernetes              10.100.0.1    &lt;none&gt;        443/TCP    46m
svc/nginx                   10.100.0.16   &lt;none&gt;        80/TCP     33s

NAME                        READY         STATUS        RESTARTS   AGE
po/nginx-701339712-e0qfq    1/1           Running       0          35s
</code></pre>
<h2 id=通过从-pod-访问服务对其进行测试>通过从 Pod 访问服务对其进行测试</h2>
<p>你应该可以从其它的 Pod 访问这个新的 <code>nginx</code> 服务。
要从 default 命名空间中的其它s Pod 来访问该服务。可以启动一个 busybox 容器：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl run busybox --rm -ti --image<span style=color:#666>=</span>busybox:1.28 /bin/sh
</code></pre></div>
<p>在你的 Shell 中，运行下面的命令：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>wget --spider --timeout<span style=color:#666>=</span><span style=color:#666>1</span> nginx
</code></pre></div><pre><code class=language-none data-lang=none>Connecting to nginx (10.100.0.16:80)
remote file exists
</code></pre>
<h2 id=限制-nginx-服务的访问>限制 <code>nginx</code> 服务的访问</h2>
<p>如果想限制对 <code>nginx</code> 服务的访问，只让那些拥有标签 <code>access: true</code> 的 Pod 访问它，
那么可以创建一个如下所示的 NetworkPolicy 对象：</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/service/networking/nginx-policy.yaml download=service/networking/nginx-policy.yaml><code>service/networking/nginx-policy.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('service-networking-nginx-policy-yaml')" title="Copy service/networking/nginx-policy.yaml to clipboard">
</img>
</div>
<div class=includecode id=service-networking-nginx-policy-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>networking.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>NetworkPolicy<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>access-nginx<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>podSelector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ingress</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>from</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>podSelector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>access</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>NetworkPolicy 对象的名称必须是一个合法的
<a href=/zh/docs/concepts/overview/working-with-objects/names#dns-subdomain-names>DNS 子域名</a>.</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> NetworkPolicy 中包含选择策略所适用的 Pods 集合的 <code>podSelector</code>。
你可以看到上面的策略选择的是带有标签 <code>app=nginx</code> 的 Pods。
此标签是被自动添加到 <code>nginx</code> Deployment 中的 Pod 上的。
如果 <code>podSelector</code> 为空，则意味着选择的是名字空间中的所有 Pods。
</div>
<h2 id=为服务指定策略>为服务指定策略</h2>
<p>使用 kubectl 根据上面的 <code>nginx-policy.yaml</code> 文件创建一个 NetworkPolicy：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/service/networking/nginx-policy.yaml
</code></pre></div><pre><code class=language-none data-lang=none>networkpolicy.networking.k8s.io/access-nginx created
</code></pre>
<h2 id=测试没有定义访问标签时访问服务>测试没有定义访问标签时访问服务</h2>
<p>如果你尝试从没有设定正确标签的 Pod 中去访问 <code>nginx</code> 服务，请求将会超时：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl run busybox --rm -ti --image<span style=color:#666>=</span>busybox:1.28 -- /bin/sh
</code></pre></div>
<p>在 Shell 中运行命令：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>wget --spider --timeout<span style=color:#666>=</span><span style=color:#666>1</span> nginx
</code></pre></div><pre><code class=language-none data-lang=none>Connecting to nginx (10.100.0.16:80)
wget: download timed out
</code></pre>
<h2 id=定义访问标签后再次测试>定义访问标签后再次测试</h2>
<p>创建一个拥有正确标签的 Pod，你将看到请求是被允许的：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl run busybox --rm -ti --labels<span style=color:#666>=</span><span style=color:#b44>&#34;access=true&#34;</span> --image<span style=color:#666>=</span>busybox:1.28 -- /bin/sh
</code></pre></div>
<p>在 Shell 中运行命令：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>wget --spider --timeout<span style=color:#666>=</span><span style=color:#666>1</span> nginx
</code></pre></div><pre><code class=language-none data-lang=none>Connecting to nginx (10.100.0.16:80)
remote file exists
</code></pre>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-b35b8ddb9bbc15620ce9636f4346c05c>3.26 - 安全地清空一个节点</h1>
<p>本页展示了如何在确保 PodDisruptionBudget 的前提下，安全地清空一个<a class=glossary-tooltip title="Kubernetes 中的工作机器称作节点。" data-toggle=tooltip data-placement=top href=/zh/docs/concepts/architecture/nodes/ target=_blank aria-label=节点>节点</a>。</p>
<h2 id=before-you-begin>Before you begin</h2>
<p>Your Kubernetes server must be at or later than version 1.5.
To check the version, enter <code>kubectl version</code>.</p>
<p>此任务假定你已经满足了以下先决条件：</p>
<ul>
<li>使用的 Kubernetes 版本 >= 1.5。</li>
<li>以下两项，具备其一：
<ol>
<li>在节点清空期间，不要求应用程序具有高可用性</li>
<li>你已经了解了 <a href=/zh/docs/concepts/workloads/pods/disruptions/>PodDisruptionBudget 的概念</a>，
并为需要它的应用程序<a href=/zh/docs/tasks/run-application/configure-pdb/>配置了 PodDisruptionBudget</a>。</li>
</ol>
</li>
</ul>
<h2 id=configure-poddisruptionbudget>（可选） 配置干扰预算</h2>
<p>为了确保你的负载在维护期间仍然可用，你可以配置一个 <a href=/zh/docs/concepts/workloads/pods/disruptions/>PodDisruptionBudget</a>。
如果可用性对于正在清空的该节点上运行或可能在该节点上运行的任何应用程序很重要，
首先 <a href=/zh/docs/tasks/run-application/configure-pdb/>配置一个 PodDisruptionBudgets</a> 并继续遵循本指南。</p>
<h2 id=use-kubectl-drain-to-remove-a-node-from-service>使用 <code>kubectl drain</code> 从服务中删除一个节点</h2>
<p>在对节点执行维护（例如内核升级、硬件维护等）之前，
可以使用 <code>kubectl drain</code> 从节点安全地逐出所有 Pods。
安全的驱逐过程允许 Pod 的容器
<a href=/zh/docs/concepts/workloads/pods/pod-lifecycle/#pod-termination>体面地终止</a>，
并确保满足指定的 PodDisruptionBudgets。</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 默认情况下， <code>kubectl drain</code> 将忽略节点上不能杀死的特定系统 Pod；
有关更多细节，请参阅
<a href=/docs/reference/generated/kubectl/kubectl-commands/#drain>kubectl drain</a> 文档。
</div>
<p><code>kubectl drain</code> 的成功返回，表明所有的 Pods（除了上一段中描述的被排除的那些），
已经被安全地逐出（考虑到期望的终止宽限期和你定义的 PodDisruptionBudget）。
然后就可以安全地关闭节点，
比如关闭物理机器的电源，如果它运行在云平台上，则删除它的虚拟机。</p>
<p>首先，确定想要清空的节点的名称。可以用以下命令列出集群中的所有节点:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get nodes
</code></pre></div>
<p>接下来，告诉 Kubernetes 清空节点：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl drain &lt;node name&gt;
</code></pre></div>
<p>一旦它返回（没有报错），
你就可以下线此节点（或者等价地，如果在云平台上，删除支持该节点的虚拟机）。
如果要在维护操作期间将节点留在集群中，则需要运行：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl uncordon &lt;node name&gt;
</code></pre></div>
<p>然后告诉 Kubernetes，它可以继续在此节点上调度新的 Pods。</p>
<h2 id=draining-multiple-nodes-in-parallel>并行清空多个节点 </h2>
<p><code>kubectl drain</code> 命令一次只能发送给一个节点。
但是，你可以在不同的终端或后台为不同的节点并行地运行多个 <code>kubectl drain</code> 命令。
同时运行的多个 drain 命令仍然遵循你指定的 PodDisruptionBudget 。</p>
<p>例如，如果你有一个三副本的 StatefulSet，
并设置了一个 <code>PodDisruptionBudget</code>，指定 <code>minAvailable: 2</code>。
如果所有的三个 Pod 均就绪，并且你并行地发出多个 drain 命令，
那么 <code>kubectl drain</code> 只会从 StatefulSet 中逐出一个 Pod，
因为 Kubernetes 会遵守 PodDisruptionBudget 并确保在任何时候只有一个 Pod 不可用
（最多不可用 Pod 个数的计算方法：<code>replicas - minAvailable</code>）。
任何会导致就绪副本数量低于指定预算的清空操作都将被阻止。</p>
<h2 id=the-eviction-api>驱逐 API</h2>
<p>如果你不喜欢使用
<a href=/docs/reference/generated/kubectl/kubectl-commands/#drain>kubectl drain</a>
（比如避免调用外部命令，或者更细化地控制 pod 驱逐过程），
你也可以用驱逐 API 通过编程的方式达到驱逐的效果。
更多信息，请参阅 <a href=/zh/docs/concepts/scheduling-eviction/api-eviction/>API 发起的驱逐</a>。</p>
<h2 id=what-s-next>What's next</h2>
<ul>
<li>执行<a href=/zh/docs/tasks/run-application/configure-pdb/>配置 PDB</a>中的各个步骤，
保护你的应用</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-9585dc0efb0450fd68728e7511754717>3.27 - 开发云控制器管理器</h1>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.11 [beta]</code>
</div>
<p>云控制器管理器是指嵌入特定云的控制逻辑的
<a class=glossary-tooltip title="控制平面是指容器编排层，它暴露 API 和接口来定义、部署容器和管理容器的生命周期。" data-toggle=tooltip data-placement=top href="/zh/docs/reference/glossary/?all=true#term-control-plane" target=_blank aria-label=控制平面>控制平面</a>组件。
云控制器管理器使得你可以将你的集群连接到云提供商的 API 之上，
并将与该云平台交互的组件同与你的集群交互的组件分离开来。</p>
<p>通过分离 Kubernetes 和底层云基础设置之间的互操作性逻辑，
云控制器管理器组件使云提供商能够以不同于 Kubernetes 主项目的
步调发布新特征。</p>
<h2 id=背景>背景</h2>
<p>由于云驱动的开发和发布与 Kubernetes 项目本身步调不同，将特定于云环境的代码抽象到
<code>cloud-controller-manager</code> 二进制组件有助于云厂商独立于 Kubernetes
核心代码推进其驱动开发。</p>
<p>Kubernetes 项目提供 cloud-controller-manager 的框架代码，其中包含 Go 语言的接口，
便于你（或者你的云驱动提供者）接驳你自己的实现。这意味着每个云驱动可以通过从
Kubernetes 核心代码导入软件包来实现一个 cloud-controller-manager；
每个云驱动会通过调用 <code>cloudprovider.RegisterCloudProvider</code> 接口来注册其自身实现代码，
从而更新一个用来记录可用云驱动的全局变量。</p>
<h2 id=开发>开发</h2>
<h3 id=树外-out-of-tree>树外（Out of Tree）</h3>
<p>要为你的云环境构建一个树外（Out-of-Tree）云控制器管理器：</p>
<ol>
<li>使用满足 <a href=https://github.com/kubernetes/cloud-provider/blob/master/cloud.go><code>cloudprovider.Interface</code></a>
接口的实现来创建一个 Go 语言包。</li>
<li>使用来自 Kubernetes 核心代码库的
<a href=https://github.com/kubernetes/kubernetes/blob/master/cmd/cloud-controller-manager/main.go>cloud-controller-manager 中的 main.go</a>
作为 <code>main.go</code> 的模板。如上所述，唯一的区别应该是将导入的云包不同。</li>
<li>在 <code>main.go</code> 中导入你的云包，确保你的包有一个 <code>init</code> 块来运行
<a href=https://github.com/kubernetes/cloud-provider/blob/master/plugins.go><code>cloudprovider.RegisterCloudProvider</code></a>。</li>
</ol>
<p>很多云驱动都将其控制器管理器代码以开源代码的形式公开。
如果你在开发一个新的 cloud-controller-manager，你可以选择某个树外（Out-of-Tree）
云控制器管理器作为出发点。</p>
<h3 id=树内-in-tree>树内（In Tree）</h3>
<p>对于树内（In-Tree）驱动，你可以将树内云控制器管理器作为集群中的
<a class=glossary-tooltip title="确保 Pod 的副本在集群中的一组节点上运行。" data-toggle=tooltip data-placement=top href=/zh/docs/concepts/workloads/controllers/daemonset/ target=_blank aria-label=DaemonSet>DaemonSet</a> 来运行。
有关详细信息，请参阅<a href=/zh/docs/tasks/administer-cluster/running-cloud-controller/>云控制器管理器管理</a>。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-00733cc3747eb3f5fe1c9e0439262967>3.28 - 开启服务拓扑</h1>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.21 [deprecated]</code>
</div>
<p>这项功能，特别是 Alpha 状态的 <code>topologyKeys</code> 字段，在 kubernetes v1.21 中已经弃用。
在 kubernetes v1.21 加入的<a href=/zh/docs/concepts/services-networking/topology-aware-hints/>拓扑感知提示</a>
提供了类似的功能。</p>
<h2 id=before-you-begin>Before you begin</h2>
<p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li>
</ul>
Your Kubernetes server must be at or later than version 1.17.
To check the version, enter <code>kubectl version</code>.
</p>
<p><em>服务拓扑（Service Topology）</em> 使 <a class=glossary-tooltip title="将运行在一组 Pods 上的应用程序公开为网络服务的抽象方法。" data-toggle=tooltip data-placement=top href=/zh/docs/concepts/services-networking/service/ target=_blank aria-label=服务>服务</a>
能够根据集群中的 Node 拓扑来路由流量。
比如，服务可以指定将流量优先路由到与客户端位于同一节点或者同一可用区域的端点上。</p>
<h2 id=before-you-begin-1>Before you begin</h2>
<p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li>
</ul>
Your Kubernetes server must be at or later than version 1.17.
To check the version, enter <code>kubectl version</code>.
</p>
<p>需要下面列的先决条件，才能启用拓扑感知的服务路由：</p>
<ul>
<li>Kubernetes 1.17 或更新版本</li>
<li>配置 <a class=glossary-tooltip title="kube-proxy 是集群中每个节点上运行的网络代理。" data-toggle=tooltip data-placement=top href=/zh/docs/reference/command-line-tools-reference/kube-proxy/ target=_blank aria-label=kube-proxy>kube-proxy</a> 以 iptables 或者 IPVS 模式运行</li>
</ul>
<h2 id=启用服务拓扑>启用服务拓扑</h2>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.21 [deprecated]</code>
</div>
<p>要启用服务拓扑功能，需要为所有 Kubernetes 组件启用 <code>ServiceTopology</code>
<a href=/zh/docs/reference/command-line-tools-reference/feature-gates/>特性门控</a>：</p>
<pre><code>--feature-gates=&quot;ServiceTopology=true`
</code></pre><h2 id=what-s-next>What's next</h2>
<ul>
<li>阅读<a href=/zh/docs/concepts/services-networking/topology-aware-hints/>拓扑感知提示</a>，该技术是用来替换 <code>topologyKeys</code> 字段的。</li>
<li>阅读<a href=/zh/docs/concepts/services-networking/endpoint-slices>端点切片</a></li>
<li>阅读<a href=/zh/docs/concepts/services-networking/service-topology>服务拓扑</a>概念</li>
<li>阅读<a href=/zh/docs/concepts/services-networking/connect-applications-service/>通过服务来连接应用</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-7127e6b7344b315b30b1ce8c4d8bfc55>3.29 - 控制节点上的 CPU 管理策略</h1>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.12 [beta]</code>
</div>
<p>按照设计，Kubernetes 对 pod 执行相关的很多方面进行了抽象，使得用户不必关心。
然而，为了正常运行，有些工作负载要求在延迟和/或性能方面有更强的保证。
为此，kubelet 提供方法来实现更复杂的负载放置策略，同时保持抽象，避免显式的放置指令。</p>
<h2 id=before-you-begin>Before you begin</h2>
<p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li>
</ul>
To check the version, enter <code>kubectl version</code>.
</p>
<h2 id=cpu-管理策略>CPU 管理策略</h2>
<p>默认情况下，kubelet 使用 <a href=https://en.wikipedia.org/wiki/Completely_Fair_Scheduler>CFS 配额</a>
来执行 Pod 的 CPU 约束。
当节点上运行了很多 CPU 密集的 Pod 时，工作负载可能会迁移到不同的 CPU 核，
这取决于调度时 Pod 是否被扼制，以及哪些 CPU 核是可用的。
许多工作负载对这种迁移不敏感，因此无需任何干预即可正常工作。</p>
<p>然而，有些工作负载的性能明显地受到 CPU 缓存亲和性以及调度延迟的影响。
对此，kubelet 提供了可选的 CPU 管理策略，来确定节点上的一些分配偏好。</p>
<h3 id=配置>配置</h3>
<p>CPU 管理策略通过 kubelet 参数 <code>--cpu-manager-policy</code> 来指定。支持两种策略：</p>
<ul>
<li><code>none</code>: 默认策略，表示现有的调度行为。</li>
<li><code>static</code>: 允许为节点上具有某些资源特征的 pod 赋予增强的 CPU 亲和性和独占性。</li>
</ul>
<p>CPU 管理器定期通过 CRI 写入资源更新，以保证内存中 CPU 分配与 cgroupfs 一致。
同步频率通过新增的 Kubelet 配置参数 <code>--cpu-manager-reconcile-period</code> 来设置。
如果不指定，默认与 <code>--node-status-update-frequency</code> 的周期相同。</p>
<p>Static 策略的行为可以使用 <code>--cpu-manager-policy-options</code> 参数来微调。
该参数采用一个逗号分隔的 <code>key=value</code> 策略选项列表。</p>
<h3 id=none-策略>none 策略</h3>
<p><code>none</code> 策略显式地启用现有的默认 CPU 亲和方案，不提供操作系统调度器默认行为之外的亲和性策略。
通过 CFS 配额来实现 <a href=/zh/docs/tasks/configure-pod-container/quality-service-pod/>Guaranteed pods</a>
和 <a href=/zh/docs/tasks/configure-pod-container/quality-service-pod/>Burstable pods</a>
的 CPU 使用限制。</p>
<h3 id=static-策略>static 策略</h3>
<p><code>static</code> 策略针对具有整数型 CPU <code>requests</code> 的 <code>Guaranteed</code> Pod ，它允许该类 Pod
中的容器访问节点上的独占 CPU 资源。这种独占性是使用
<a href=https://www.kernel.org/doc/Documentation/cgroup-v1/cpusets.txt>cpuset cgroup 控制器</a> 来实现的。</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 诸如容器运行时和 kubelet 本身的系统服务可以继续在这些独占 CPU 上运行。独占性仅针对其他 Pod。
</div>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> CPU 管理器不支持运行时下线和上线 CPUs。此外，如果节点上的在线 CPUs 集合发生变化，
则必须驱逐节点上的 Pod，并通过删除 kubelet 根目录中的状态文件 <code>cpu_manager_state</code>
来手动重置 CPU 管理器。
</div>
<p>该策略管理一个共享 CPU 资源池，最初，该资源池包含节点上所有的 CPU 资源。可用
的独占性 CPU 资源数量等于节点的 CPU 总量减去通过 <code>--kube-reserved</code> 或 <code>--system-reserved</code> 参数保留的 CPU 。从1.17版本开始，CPU保留列表可以通过 kublet 的 '--reserved-cpus' 参数显式地设置。
通过 '--reserved-cpus' 指定的显式CPU列表优先于使用 '--kube-reserved' 和 '--system-reserved' 参数指定的保留CPU。 通过这些参数预留的 CPU 是以整数方式，按物理内
核 ID 升序从初始共享池获取的。 共享池是 <code>BestEffort</code> 和 <code>Burstable</code> pod 运行
的 CPU 集合。<code>Guaranteed</code> pod 中的容器，如果声明了非整数值的 CPU <code>requests</code> ，也将运行在共享池的 CPU 上。只有 <code>Guaranteed</code> pod 中，指定了整数型 CPU <code>requests</code> 的容器，才会被分配独占 CPU 资源。</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 当启用 static 策略时，要求使用 <code>--kube-reserved</code> 和/或 <code>--system-reserved</code> 或
<code>--reserved-cpus</code> 来保证预留的 CPU 值大于零。
这是因为零预留 CPU 值可能使得共享池变空。
</div>
<p>当 <code>Guaranteed</code> Pod 调度到节点上时，如果其容器符合静态分配要求，
相应的 CPU 会被从共享池中移除，并放置到容器的 cpuset 中。
因为这些容器所使用的 CPU 受到调度域本身的限制，所以不需要使用 CFS 配额来进行 CPU 的绑定。
换言之，容器 cpuset 中的 CPU 数量与 Pod 规约中指定的整数型 CPU <code>limit</code> 相等。
这种静态分配增强了 CPU 亲和性，减少了 CPU 密集的工作负载在节流时引起的上下文切换。</p>
<p>考虑以下 Pod 规格的容器：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></code></pre></div>
<p>该 Pod 属于 <code>BestEffort</code> QoS 类型，因为其未指定 <code>requests</code> 或 <code>limits</code> 值。
所以该容器运行在共享 CPU 池中。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;200Mi&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;100Mi&#34;</span><span style=color:#bbb>
</span></code></pre></div>
<p>该 Pod 属于 <code>Burstable</code> QoS 类型，因为其资源 <code>requests</code> 不等于 <code>limits</code>，且未指定 <code>cpu</code> 数量。
所以该容器运行在共享 CPU 池中。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;200Mi&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;100Mi&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;1&#34;</span><span style=color:#bbb>
</span></code></pre></div>
<p>该 pod 属于 <code>Burstable</code> QoS 类型，因为其资源 <code>requests</code> 不等于 <code>limits</code>。
所以该容器运行在共享 CPU 池中。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;200Mi&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;200Mi&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2&#34;</span><span style=color:#bbb>
</span></code></pre></div>
<p>该 Pod 属于 <code>Guaranteed</code> QoS 类型，因为其 <code>requests</code> 值与 <code>limits</code>相等。
同时，容器对 CPU 资源的限制值是一个大于或等于 1 的整数值。
所以，该 <code>nginx</code> 容器被赋予 2 个独占 CPU。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;200Mi&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;1.5&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;200Mi&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;1.5&#34;</span><span style=color:#bbb>
</span></code></pre></div>
<p>该 Pod 属于 <code>Guaranteed</code> QoS 类型，因为其 <code>requests</code> 值与 <code>limits</code>相等。
但是容器对 CPU 资源的限制值是一个小数。所以该容器运行在共享 CPU 池中。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;200Mi&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2&#34;</span><span style=color:#bbb>
</span></code></pre></div>
<p>该 Pod 属于 <code>Guaranteed</code> QoS 类型，因其指定了 <code>limits</code> 值，同时当未显式指定时，
<code>requests</code> 值被设置为与 <code>limits</code> 值相等。
同时，容器对 CPU 资源的限制值是一个大于或等于 1 的整数值。
所以，该 <code>nginx</code> 容器被赋予 2 个独占 CPU。</p>
<h4 id=static-策略选项>Static 策略选项</h4>
<p>如果使用 <code>full-pcpus-only</code> 策略选项，static 策略总是会分配完整的物理核心。
你可以通过在 CPUManager 策略选项里加上 <code>full-pcups-only=true</code> 来启用该选项。</p>
<p>默认情况下，如果不使用该选项，static 策略会使用拓扑感知最适合的分配方法来分配 CPU。
在启用了 SMT 的系统上，此策略所分配是与硬件线程对应的、独立的虚拟核。
这会导致不同的容器共享相同的物理核心，该行为进而会导致
<a href=https://en.wikipedia.org/wiki/Cloud_computing_issues#Performance_interference_and_noisy_neighbors>吵闹的邻居问题</a>。</p>
<p>启用该选项之后，只有当一个 Pod 里所有容器的 CPU 请求都能够分配到完整的物理核心时，kubelet 才会接受该 Pod。
如果 Pod 没有被准入，它会被置于 Failed 状态，错误消息是 <code>SMTAlignmentError</code>。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-8060aed5bf1172fa62199a4c306a4cd1>3.30 - 控制节点上的拓扑管理策略</h1>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.18 [beta]</code>
</div>
<p>越来越多的系统利用 CPU 和硬件加速器的组合来支持对延迟要求较高的任务和高吞吐量的并行计算。
这类负载包括电信、科学计算、机器学习、金融服务和数据分析等。
此类混合系统即用于构造这些高性能环境。</p>
<p>为了获得最佳性能，需要进行与 CPU 隔离、内存和设备局部性有关的优化。
但是，在 Kubernetes 中，这些优化由各自独立的组件集合来处理。</p>
<p><em>拓扑管理器（Topology Manager）</em> 是一个 kubelet 的一部分，旨在协调负责这些优化的一组组件。</p>
<h2 id=before-you-begin>Before you begin</h2>
<p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li>
</ul>
Your Kubernetes server must be at or later than version v1.18.
To check the version, enter <code>kubectl version</code>.
</p>
<h2 id=拓扑管理器如何工作>拓扑管理器如何工作</h2>
<p>在引入拓扑管理器之前， Kubernetes 中的 CPU 和设备管理器相互独立地做出资源分配决策。
这可能会导致在多处理系统上出现并非期望的资源分配；由于这些与期望相左的分配，对性能或延迟敏感的应用将受到影响。
这里的不符合期望意指，例如， CPU 和设备是从不同的 NUMA 节点分配的，因此会导致额外的延迟。</p>
<p>拓扑管理器是一个 Kubelet 组件，扮演信息源的角色，以便其他 Kubelet 组件可以做出与拓扑结构相对应的资源分配决定。</p>
<p>拓扑管理器为组件提供了一个称为 <em>建议供应者（Hint Providers）</em> 的接口，以发送和接收拓扑信息。
拓扑管理器具有一组节点级策略，具体说明如下。</p>
<p>拓扑管理器从 <em>建议提供者</em> 接收拓扑信息，作为表示可用的 NUMA 节点和首选分配指示的位掩码。
拓扑管理器策略对所提供的建议执行一组操作，并根据策略对提示进行约减以得到最优解；如果存储了与预期不符的建议，则该建议的优选字段将被设置为 false。
在当前策略中，首选的是最窄的优选掩码。
所选建议将被存储为拓扑管理器的一部分。
取决于所配置的策略，所选建议可用来决定节点接受或拒绝 Pod 。
之后，建议会被存储在拓扑管理器中，供 <em>建议提供者</em> 进行资源分配决策时使用。</p>
<h3 id=启用拓扑管理器功能特性>启用拓扑管理器功能特性</h3>
<p>对拓扑管理器的支持要求启用 <code>TopologyManager</code>
<a href=/zh/docs/reference/command-line-tools-reference/feature-gates/>特性门控</a>。
从 Kubernetes 1.18 版本开始，这一特性默认是启用的。</p>
<h3 id=拓扑管理器作用域和策略>拓扑管理器作用域和策略</h3>
<p>拓扑管理器目前：</p>
<ul>
<li>对所有 QoS 类的 Pod 执行对齐操作</li>
<li>针对建议提供者所提供的拓扑建议，对请求的资源进行对齐</li>
</ul>
<p>如果满足这些条件，则拓扑管理器将对齐请求的资源。</p>
<p>为了定制如何进行对齐，拓扑管理器提供了两种不同的方式：<code>scope</code> 和 <code>policy</code>。</p>
<p><code>scope</code> 定义了资源对齐时你所希望使用的粒度（例如，是在 <code>pod</code> 还是 <code>container</code> 级别）。
<code>policy</code> 定义了对齐时实际使用的策略（例如，<code>best-effort</code>、<code>restricted</code>、<code>single-numa-node</code> 等等）。</p>
<p>可以在下文找到现今可用的各种 <code>scopes</code> 和 <code>policies</code> 的具体信息。</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 为了将 Pod 规约中的 CPU 资源与其他请求资源对齐，CPU 管理器需要被启用并且
节点上应配置了适当的 CPU 管理器策略。
参看<a href=/zh/docs/tasks/administer-cluster/cpu-management-policies/>控制 CPU 管理策略</a>.
</div>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 为了将 Pod 规约中的 memory（和 hugepages）资源与所请求的其他资源对齐，需要启用内存管理器，
并且在节点配置适当的内存管理器策略。查看<a href=/zh/docs/tasks/administer-cluster/memory-manager/>内存管理器</a>
文档。
</div>
<h3 id=拓扑管理器作用域>拓扑管理器作用域</h3>
<p>拓扑管理器可以在以下不同的作用域内进行资源对齐：</p>
<ul>
<li><code>container</code> （默认）</li>
<li><code>pod</code></li>
</ul>
<p>在 kubelet 启动时，可以使用 <code>--topology-manager-scope</code> 标志来选择其中任一选项。</p>
<h3 id=容器作用域>容器作用域</h3>
<p>默认使用的是 <code>container</code> 作用域。</p>
<p>在该作用域内，拓扑管理器依次进行一系列的资源对齐，
也就是，对每一个容器（包含在一个 Pod 里）计算单独的对齐。
换句话说，在该特定的作用域内，没有根据特定的 NUMA 节点集来把容器分组的概念。
实际上，拓扑管理器会把单个容器任意地对齐到 NUMA 节点上。</p>
<p>容器分组的概念是在以下的作用域内特别实现的，也就是 <code>pod</code> 作用域。</p>
<h3 id=pod-作用域>Pod 作用域</h3>
<p>使用命令行选项 <code>--topology-manager-scope=pod</code> 来启动 kubelet，就可以选择 <code>pod</code> 作用域。</p>
<p>该作用域允许把一个 Pod 里的所有容器作为一个分组，分配到一个共同的 NUMA 节点集。
也就是，拓扑管理器会把一个 Pod 当成一个整体，
并且试图把整个 Pod（所有容器）分配到一个单个的 NUMA 节点或者一个共同的 NUMA 节点集。
以下的例子说明了拓扑管理器在不同的场景下使用的对齐方式：</p>
<ul>
<li>所有容器可以被分配到一个单一的 NUMA 节点；</li>
<li>所有容器可以被分配到一个共享的 NUMA 节点集。</li>
</ul>
<p>整个 Pod 所请求的某种资源总量是根据
<a href=/zh/docs/concepts/workloads/pods/init-containers/#resources>有效 request/limit</a>
公式来计算的，
因此，对某一种资源而言，该总量等于以下数值中的最大值：</p>
<ul>
<li>所有应用容器请求之和；</li>
<li>初始容器请求的最大值。</li>
</ul>
<p><code>pod</code> 作用域与 <code>single-numa-node</code> 拓扑管理器策略一起使用，
对于延时敏感的工作负载，或者对于进行 IPC 的高吞吐量应用程序，都是特别有价值的。
把这两个选项组合起来，你可以把一个 Pod 里的所有容器都放到一个单个的 NUMA 节点，
使得该 Pod 消除了 NUMA 之间的通信开销。</p>
<p>在 <code>single-numa-node</code> 策略下，只有当可能的分配方案中存在合适的 NUMA 节点集时，Pod 才会被接受。
重新考虑上述的例子：</p>
<ul>
<li>节点集只包含单个 NUMA 节点时，Pod 就会被接受，</li>
<li>然而，节点集包含多个 NUMA 节点时，Pod 就会被拒绝
（因为满足该分配方案需要两个或以上的 NUMA 节点，而不是单个 NUMA 节点）。</li>
</ul>
<p>简要地说，拓扑管理器首先计算出 NUMA 节点集，然后使用拓扑管理器策略来测试该集合，
从而决定拒绝或者接受 Pod。</p>
<h3 id=拓扑管理器策略>拓扑管理器策略</h3>
<p>拓扑管理器支持四种分配策略。
你可以通过 Kubelet 标志 <code>--topology-manager-policy</code> 设置策略。
所支持的策略有四种：</p>
<ul>
<li><code>none</code> (默认)</li>
<li><code>best-effort</code></li>
<li><code>restricted</code></li>
<li><code>single-numa-node</code></li>
</ul>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 如果拓扑管理器配置使用 <strong>Pod</strong> 作用域，
那么在策略考量一个容器时，该容器反映的是整个 Pod 的要求，
于是该 Pod 里的每个容器都会得到 <strong>相同的</strong> 拓扑对齐决定。
</div>
<h3 id=policy-none>none 策略</h3>
<p>这是默认策略，不执行任何拓扑对齐。</p>
<h3 id=policy-best-effort>best-effort 策略</h3>
<p>对于 Guaranteed 类的 Pod 中的每个容器，具有 <code>best-effort</code> 拓扑管理策略的
kubelet 将调用每个建议提供者以确定资源可用性。
使用此信息，拓扑管理器存储该容器的首选 NUMA 节点亲和性。
如果亲和性不是首选，则拓扑管理器将存储该亲和性，并且无论如何都将 pod 接纳到该节点。</p>
<p>之后 <em>建议提供者</em> 可以在进行资源分配决策时使用这个信息。</p>
<h3 id=policy-restricted>restricted 策略</h3>
<p>对于 Guaranteed 类 Pod 中的每个容器， 配置了 <code>restricted</code> 拓扑管理策略的 kubelet
调用每个建议提供者以确定其资源可用性。。
使用此信息，拓扑管理器存储该容器的首选 NUMA 节点亲和性。
如果亲和性不是首选，则拓扑管理器将从节点中拒绝此 Pod 。
这将导致 Pod 处于 <code>Terminated</code> 状态，且 Pod 无法被节点接纳。</p>
<p>一旦 Pod 处于 <code>Terminated</code> 状态，Kubernetes 调度器将不会尝试重新调度该 Pod。
建议使用 ReplicaSet 或者 Deployment 来重新部署 Pod。
还可以通过实现外部控制环，以启动对具有 <code>Topology Affinity</code> 错误的 Pod 的重新部署。</p>
<p>如果 Pod 被允许运行在某节点，则 <em>建议提供者</em> 可以在做出资源分配决定时使用此信息。</p>
<h3 id=policy-single-numa-node>single-numa-node 策略</h3>
<p>对于 Guaranteed 类 Pod 中的每个容器， 配置了 <code>single-numa-nodde</code> 拓扑管理策略的
kubelet 调用每个建议提供者以确定其资源可用性。
使用此信息，拓扑管理器确定单 NUMA 节点亲和性是否可能。
如果是这样，则拓扑管理器将存储此信息，然后 <em>建议提供者</em> 可以在做出资源分配决定时使用此信息。
如果不可能，则拓扑管理器将拒绝 Pod 运行于该节点。
这将导致 Pod 处于 <code>Terminated</code> 状态，且 Pod 无法被节点接受。</p>
<p>一旦 Pod 处于 <code>Terminated</code> 状态，Kubernetes 调度器将不会尝试重新调度该 Pod。
建议使用 ReplicaSet 或者 Deployment 来重新部署 Pod。
还可以通过实现外部控制环，以触发具有 <code>Topology Affinity</code> 错误的 Pod 的重新部署。</p>
<h3 id=pod-与拓扑管理器策略的交互>Pod 与拓扑管理器策略的交互</h3>
<p>考虑以下 pod 规范中的容器：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></code></pre></div>
<p>该 Pod 以 <code>BestEffort</code> QoS 类运行，因为没有指定资源 <code>requests</code> 或 <code>limits</code>。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;200Mi&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;100Mi&#34;</span><span style=color:#bbb>
</span></code></pre></div>
<p>由于 requests 数少于 limits，因此该 Pod 以 <code>Burstable</code> QoS 类运行。</p>
<p>如果选择的策略是 <code>none</code> 以外的任何其他策略，拓扑管理器都会评估这些 Pod 的规范。
拓扑管理器会咨询建议提供者，获得拓扑建议。
若策略为 <code>static</code>，则 CPU 管理器策略会返回默认的拓扑建议，因为这些 Pod
并没有显式地请求 CPU 资源。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;200Mi&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>example.com/device</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;1&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;200Mi&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>example.com/device</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;1&#34;</span><span style=color:#bbb>
</span></code></pre></div>
<p>此 Pod 以 <code>Guaranteed</code> QoS 类运行，因为其 <code>requests</code> 值等于 <code>limits</code> 值。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>example.com/deviceA</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;1&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>example.com/deviceB</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;1&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>example.com/deviceA</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;1&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>example.com/deviceB</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;1&#34;</span><span style=color:#bbb>
</span></code></pre></div>
<p>因为未指定 CPU 和内存请求，所以 Pod 以 <code>BestEffort</code> QoS 类运行。</p>
<p>拓扑管理器将考虑以上两个 Pod。拓扑管理器将咨询建议提供者即 CPU 和设备管理器，以获取 Pod 的拓扑提示。
对于 <code>Guaranteed</code> 类的 CPU 请求数为整数的 Pod，<code>static</code> CPU 管理器策略将返回与 CPU 请求有关的提示，
而设备管理器将返回有关所请求设备的提示。</p>
<p>对于 <code>Guaranteed</code> 类的 CPU 请求可共享的 Pod，<code>static</code> CPU
管理器策略将返回默认的拓扑提示，因为没有排他性的 CPU 请求；而设备管理器
则针对所请求的设备返回有关提示。</p>
<p>在上述两种 <code>Guaranteed</code> Pod 的情况中，<code>none</code> CPU 管理器策略会返回默认的拓扑提示。</p>
<p>对于 <code>BestEffort</code> Pod，由于没有 CPU 请求，<code>static</code> CPU 管理器策略将发送默认提示，
而设备管理器将为每个请求的设备发送提示。</p>
<p>基于此信息，拓扑管理器将为 Pod 计算最佳提示并存储该信息，并且供
提示提供程序在进行资源分配时使用。</p>
<h3 id=已知的局限性>已知的局限性</h3>
<ol>
<li>拓扑管理器所能处理的最大 NUMA 节点个数是 8。若 NUMA 节点数超过 8，
枚举可能的 NUMA 亲和性并为之生成提示时会发生状态爆炸。</li>
<li>调度器不是拓扑感知的，所以有可能一个 Pod 被调度到一个节点之后，会因为拓扑管理器的缘故在该节点上启动失败。</li>
</ol>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-2bffd7f3571cdd609bd97fb2e1bdb2fe>3.31 - 改变默认 StorageClass</h1>
<p>本文展示了如何改变默认的 Storage Class，它用于为没有特殊需求的 PersistentVolumeClaims 配置 volumes。</p>
<h2 id=before-you-begin>Before you begin</h2>
<p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li>
</ul>
To check the version, enter <code>kubectl version</code>.
</p>
<h2 id=为什么要改变默认存储类>为什么要改变默认存储类？</h2>
<p>取决于安装模式，你的 Kubernetes 集群可能和一个被标记为默认的已有 StorageClass 一起部署。
这个默认的 StorageClass 以后将被用于动态的为没有特定存储类需求的 PersistentVolumeClaims
配置存储。更多细节请查看
<a href=/zh/docs/concepts/storage/persistent-volumes/#perspersistentvolumeclaims>PersistentVolumeClaim 文档</a>。</p>
<p>预先安装的默认 StorageClass 可能不能很好的适应你期望的工作负载；例如，它配置的存储可能太过昂贵。
如果是这样的话，你可以改变默认 StorageClass，或者完全禁用它以防止动态配置存储。</p>
<p>删除默认 StorageClass 可能行不通，因为它可能会被你集群中的扩展管理器自动重建。
请查阅你的安装文档中关于扩展管理器的细节，以及如何禁用单个扩展。</p>
<h2 id=改变默认-storageclass>改变默认 StorageClass</h2>
<ol>
<li>
<p>列出你的集群中的 StorageClasses：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get storageclass
</code></pre></div><p>输出类似这样：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>NAME                 PROVISIONER               AGE
standard <span style=color:#666>(</span>default<span style=color:#666>)</span>   kubernetes.io/gce-pd      1d
gold                 kubernetes.io/gce-pd      1d
</code></pre></div><p>默认 StorageClass 以 <code>(default)</code> 标记。</p>
</li>
</ol>
<ol start=2>
<li>
<p>标记默认 StorageClass 非默认：</p>
<p>默认 StorageClass 的注解 <code>storageclass.kubernetes.io/is-default-class</code> 设置为 <code>true</code>。
注解的其它任意值或者缺省值将被解释为 <code>false</code>。</p>
<p>要标记一个 StorageClass 为非默认的，你需要改变它的值为 <code>false</code>：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl patch storageclass standard -p <span style=color:#b44>&#39;{&#34;metadata&#34;: {&#34;annotations&#34;:{&#34;storageclass.kubernetes.io/is-default-class&#34;:&#34;false&#34;}}}&#39;</span>
</code></pre></div>
<p>这里的 <code>standard</code> 是你选择的 StorageClass 的名字。</p>
</li>
</ol>
<ol start=3>
<li>
<p>标记一个 StorageClass 为默认的：</p>
<p>和前面的步骤类似，你需要添加/设置注解 <code>storageclass.kubernetes.io/is-default-class=true</code>。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl patch storageclass &lt;your-class-name&gt; -p <span style=color:#b44>&#39;{&#34;metadata&#34;: {&#34;annotations&#34;:{&#34;storageclass.kubernetes.io/is-default-class&#34;:&#34;true&#34;}}}&#39;</span>
</code></pre></div>
<p>请注意，最多只能有一个 StorageClass 能够被标记为默认。
如果它们中有两个或多个被标记为默认，Kubernetes 将忽略这个注解，
也就是它将表现为没有默认 StorageClass。</p>
</li>
</ol>
<ol start=4>
<li>
<p>验证你选用的 StorageClass 为默认的：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl get storageclass
</code></pre></div>
<p>输出类似这样：</p>
<pre><code>NAME             PROVISIONER               AGE
standard         kubernetes.io/gce-pd      1d
gold (default)   kubernetes.io/gce-pd      1d
</code></pre></li>
</ol>
<h2 id=what-s-next>What's next</h2>
<ul>
<li>进一步了解 <a href=/zh/docs/concepts/storage/persistent-volumes/>PersistentVolumes</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-fbc9136f53eccd6eb8c80f4bbea3b8f4>3.32 - 更改 PersistentVolume 的回收策略</h1>
<p>本文展示了如何更改 Kubernetes PersistentVolume 的回收策略。</p>
<h2 id=before-you-begin>Before you begin</h2>
<p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li>
</ul>
To check the version, enter <code>kubectl version</code>.
</p>
<h2 id=为什么要更改-persistentvolume-的回收策略>为什么要更改 PersistentVolume 的回收策略</h2>
<p>PersistentVolumes 可以有多种回收策略，包括 "Retain"、"Recycle" 和 "Delete"。
对于动态配置的 PersistentVolumes 来说，默认回收策略为 "Delete"。
这表示当用户删除对应的 PersistentVolumeClaim 时，动态配置的 volume 将被自动删除。
如果 volume 包含重要数据时，这种自动行为可能是不合适的。
那种情况下，更适合使用 "Retain" 策略。
使用 "Retain" 时，如果用户删除 PersistentVolumeClaim，对应的 PersistentVolume 不会被删除。
相反，它将变为 Released 状态，表示所有的数据可以被手动恢复。</p>
<h2 id=更改-persistentvolume-的回收策略>更改 PersistentVolume 的回收策略</h2>
<ol>
<li>
<p>列出你集群中的 PersistentVolumes</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pv
</code></pre></div><p>输出类似于这样：</p>
<pre><code>NAME                                       CAPACITY   ACCESSMODES   RECLAIMPOLICY   STATUS    CLAIM                  REASON    AGE
pvc-b6efd8da-b7b5-11e6-9d58-0ed433a7dd94   4Gi        RWO           Delete          Bound     default/claim1                   10s
pvc-b95650f8-b7b5-11e6-9d58-0ed433a7dd94   4Gi        RWO           Delete          Bound     default/claim2                   6s
pvc-bb3ca71d-b7b5-11e6-9d58-0ed433a7dd94   4Gi        RWO           Delete          Bound     default/claim3                   3s
</code></pre>
<p>这个列表同样包含了绑定到每个卷的 claims 名称，以便更容易的识别动态配置的卷。</p>
</li>
</ol>
<ol start=2>
<li>
<p>选择你的 PersistentVolumes 中的一个并更改它的回收策略：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl patch pv &lt;your-pv-name&gt; -p <span style=color:#b44>&#39;{&#34;spec&#34;:{&#34;persistentVolumeReclaimPolicy&#34;:&#34;Retain&#34;}}&#39;</span>
</code></pre></div>
<p>这里的 <code>&lt;your-pv-name></code> 是你选择的 PersistentVolume 的名字。</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> <p>在 Windows 系统上，你必须对包含空格的 JSONPath 模板加双引号（而不是像上面
一样为 Bash 环境使用的单引号）。这也意味着你必须使用单引号或者转义的双引号
来处理模板中的字面值。例如：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cmd data-lang=cmd>kubectl patch pv &lt;your-pv-name&gt; -p <span style=color:#b44>&#34;{\&#34;</span>spec\<span style=color:#b44>&#34;:{\&#34;</span>persistentVolumeReclaimPolicy\<span style=color:#b44>&#34;:\&#34;</span>Retain\<span style=color:#b44>&#34;}}&#34;</span>
</code></pre></div>
</div>
</li>
</ol>
<ol start=3>
<li>
<p>验证你选择的 PersistentVolume 拥有正确的策略：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pv
</code></pre></div>
<p>输出类似于这样：</p>
<pre><code>NAME                                       CAPACITY   ACCESSMODES   RECLAIMPOLICY   STATUS    CLAIM                  REASON    AGE
pvc-b6efd8da-b7b5-11e6-9d58-0ed433a7dd94   4Gi        RWO           Delete          Bound     default/claim1                   40s
pvc-b95650f8-b7b5-11e6-9d58-0ed433a7dd94   4Gi        RWO           Delete          Bound     default/claim2                   36s
pvc-bb3ca71d-b7b5-11e6-9d58-0ed433a7dd94   4Gi        RWO           Retain          Bound     default/claim3                   33s
</code></pre>
<p>在前面的输出中，你可以看到绑定到申领 <code>default/claim3</code> 的卷的回收策略为 <code>Retain</code>。
当用户删除申领 <code>default/claim3</code> 时，它不会被自动删除。</p>
</li>
</ol>
<h2 id=what-s-next>What's next</h2>
<ul>
<li>进一步了解 <a href=/zh/docs/concepts/storage/persistent-volumes/>PersistentVolumes</a></li>
<li>进一步了解 <a href=/zh/docs/concepts/storage/persistent-volumes/#persistentvolumeclaims>PersistentVolumeClaims</a></li>
</ul>
<h3 id=参考>参考</h3>
<ul>
<li><a href=/docs/api-reference/v1.23/#persistentvolume-v1-core>PersistentVolume</a></li>
<li><a href=/docs/api-reference/v1.23/#persistentvolumeclaim-v1-core>PersistentVolumeClaim</a></li>
<li>参阅 <a href=/docs/api-reference/v1.23/#persistentvolumeclaim-v1-core>PersistentVolumeSpec</a> 的 <code>persistentVolumeReclaimPolicy</code> 字段</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-966cd1cc69c69410d8698b3ac74abce2>3.33 - 自动扩缩集群 DNS 服务</h1>
<p>本页展示了如何在集群中启用和配置 DNS 服务的自动扩缩功能。</p>
<h2 id=before-you-begin>Before you begin</h2>
<ul>
<li><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li>
</ul>
To check the version, enter <code>kubectl version</code>.
</li>
</ul>
<ul>
<li>
<p>本指南假设你的节点使用 AMD64 或 Intel 64 CPU 架构</p>
</li>
<li>
<p>确保已启用 <a href=/zh/docs/concepts/services-networking/dns-pod-service/>DNS 功能</a>本身。</p>
</li>
<li>
<p>建议使用 Kubernetes 1.4.0 或更高版本。</p>
</li>
</ul>
<h2 id=determining-whether-dns-horizontal-autoscaling-is-already-enabled>确定是否 DNS 水平 水平自动扩缩特性已经启用</h2>
<p>在 kube-system 命名空间中列出集群中的 <a class=glossary-tooltip title="Deployment 是管理应用副本的 API 对象。" data-toggle=tooltip data-placement=top href=/zh/docs/concepts/workloads/controllers/deployment/ target=_blank aria-label=Deployments>Deployments</a> ：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get deployment --namespace<span style=color:#666>=</span>kube-system
</code></pre></div><p>输出类似如下这样：</p>
<pre><code>NAME                  DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
...
dns-autoscaler        1         1         1            1           ...
...
</code></pre><p>如果在输出中看到 “dns-autoscaler”，说明 DNS 水平自动扩缩已经启用，可以跳到
<a href=#tuning-autoscaling-parameters>调优自动扩缩参数</a>。</p>
<h2 id=find-scaling-target>获取 DNS Deployment 的名称</h2>
<p>列出集群内 kube-system 名字空间中的 DNS Deployment：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get deployment -l k8s-app<span style=color:#666>=</span>kube-dns --namespace<span style=color:#666>=</span>kube-system
</code></pre></div><p>输出类似如下这样：</p>
<pre><code>NAME      READY   UP-TO-DATE   AVAILABLE   AGE
...
coredns   2/2     2            2           ...
...
</code></pre>
<p>如果看不到 DNS 服务的 Deployment，你也可以通过名字来查找：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get deployment --namespace<span style=color:#666>=</span>kube-system
</code></pre></div>
<p>并在输出中寻找名称为 <code>coredns</code> 或 <code>kube-dns</code> 的 Deployment。</p>
<p>你的扩缩目标为：</p>
<pre><code>Deployment/&lt;your-deployment-name&gt;
</code></pre>
<p>其中 <code>&lt;your-deployment-name></code> 是 DNS Deployment 的名称。
例如，如果你的 DNS Deployment 名称是 <code>coredns</code>，则你的扩展目标是 Deployment/coredns。</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> CoreDNS 是 Kubernetes 的默认 DNS 服务。CoreDNS 设置标签 <code>k8s-app=kube-dns</code>，
以便能够在原来使用 <code>kube-dns</code> 的集群中工作。
</div>
<h2 id=enablng-dns-horizontal-autoscaling>启用 DNS 水平自动扩缩 </h2>
<p>在本节，我们创建一个 Deployment。Deployment 中的 Pod 运行一个基于
<code>cluster-proportional-autoscaler-amd64</code> 镜像的容器。</p>
<p>创建文件 <code>dns-horizontal-autoscaler.yaml</code>，内容如下所示：</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/admin/dns/dns-horizontal-autoscaler.yaml download=admin/dns/dns-horizontal-autoscaler.yaml><code>admin/dns/dns-horizontal-autoscaler.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('admin-dns-dns-horizontal-autoscaler-yaml')" title="Copy admin/dns/dns-horizontal-autoscaler.yaml to clipboard">
</img>
</div>
<div class=includecode id=admin-dns-dns-horizontal-autoscaler-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ServiceAccount<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>kube-dns-autoscaler<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>kube-system<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>system:kube-dns-autoscaler<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;nodes&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;list&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;watch&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;replicationcontrollers/scale&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;get&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;update&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;apps&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;deployments/scale&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;replicasets/scale&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;get&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;update&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># 待以下 issue 修复后，请删除 Configmaps</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># kubernetes-incubator/cluster-proportional-autoscaler#16</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;configmaps&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;get&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;create&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRoleBinding<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>system:kube-dns-autoscaler<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>subjects</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ServiceAccount<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>kube-dns-autoscaler<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>kube-system<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>roleRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>system:kube-dns-autoscaler<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>kube-dns-autoscaler<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>kube-system<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>k8s-app</span>:<span style=color:#bbb> </span>kube-dns-autoscaler<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubernetes.io/cluster-service</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>k8s-app</span>:<span style=color:#bbb> </span>kube-dns-autoscaler<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>k8s-app</span>:<span style=color:#bbb> </span>kube-dns-autoscaler<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>priorityClassName</span>:<span style=color:#bbb> </span>system-cluster-critical<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>securityContext</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>seccompProfile</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>RuntimeDefault<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>supplementalGroups</span>:<span style=color:#bbb> </span>[<span style=color:#bbb> </span><span style=color:#666>65534</span><span style=color:#bbb> </span>]<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>fsGroup</span>:<span style=color:#bbb> </span><span style=color:#666>65534</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>nodeSelector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>kubernetes.io/os</span>:<span style=color:#bbb> </span>linux<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>autoscaler<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/cpa/cluster-proportional-autoscaler:1.8.4<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>                </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;20m&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>                </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;10Mi&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span>- /cluster-proportional-autoscaler<span style=color:#bbb>
</span><span style=color:#bbb>          </span>- --namespace=kube-system<span style=color:#bbb>
</span><span style=color:#bbb>          </span>- --configmap=kube-dns-autoscaler<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:#080;font-style:italic># 应该保持目标与 cluster/addons/dns/kube-dns.yaml.base 同步</span><span style=color:#bbb>
</span><span style=color:#bbb>          </span>- --target=&lt;SCALE_TARGET&gt;<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:#080;font-style:italic>#当集群使用大节点（有更多核）时，“coresPerReplica”应该占主导地位。</span><span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:#080;font-style:italic>#如果使用小节点，“nodesPerReplica“ 应该占主导地位。</span><span style=color:#bbb>
</span><span style=color:#bbb>          </span>- --default-params={&#34;linear&#34;:{&#34;coresPerReplica&#34;:256,&#34;nodesPerReplica&#34;:16,&#34;preventSinglePointFailure&#34;:true,&#34;includeUnschedulableNodes&#34;:true}}<span style=color:#bbb>
</span><span style=color:#bbb>          </span>- --logtostderr=true<span style=color:#bbb>
</span><span style=color:#bbb>          </span>- --v=2<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>tolerations</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;CriticalAddonsOnly&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;Exists&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>serviceAccountName</span>:<span style=color:#bbb> </span>kube-dns-autoscaler<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>在文件中，将 <code>&lt;SCALE_TARGET></code> 替换成扩缩目标。</p>
<p>进入到包含配置文件的目录中，输入如下命令创建 Deployment：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f dns-horizontal-autoscaler.yaml
</code></pre></div>
<p>一个成功的命令输出是：</p>
<pre><code>deployment.apps/dns-autoscaler created
</code></pre>
<p>DNS 水平自动扩缩在已经启用了。</p>
<h2 id=tuning-autoscaling-parameters>调优自动扩缩参数 </h2>
<p>验证 dns-autoscaler <a class=glossary-tooltip title="ConfigMap 是一种 API 对象，用来将非机密性的数据保存到键值对中。使用时可以用作环境变量、命令行参数或者存储卷中的配置文件。" data-toggle=tooltip data-placement=top href=/zh/docs/tasks/configure-pod-container/configure-pod-configmap/ target=_blank aria-label=ConfigMap>ConfigMap</a> 是否存在：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get configmap --namespace<span style=color:#666>=</span>kube-system
</code></pre></div>
<p>输出类似于：</p>
<pre><code>NAME                  DATA      AGE
...
dns-autoscaler        1         ...
...
</code></pre>
<p>修改该 ConfigMap 中的数据：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl edit configmap dns-autoscaler --namespace<span style=color:#666>=</span>kube-system
</code></pre></div>
<p>找到如下这行内容：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>linear</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;{&#34;coresPerReplica&#34;:256,&#34;min&#34;:1,&#34;nodesPerReplica&#34;:16}&#39;</span><span style=color:#bbb>
</span></code></pre></div>
<p>根据需要修改对应的字段。“min” 字段表明 DNS 后端的最小数量。
实际后端的数量通过使用如下公式来计算：</p>
<pre><code>replicas = max( ceil( cores * 1/coresPerReplica ) , ceil( nodes * 1/nodesPerReplica ) )
</code></pre>
<p>注意 <code>coresPerReplica</code> 和 <code>nodesPerReplica</code> 的值都是整数。</p>
<p>背后的思想是，当一个集群使用具有很多核心的节点时，由 <code>coresPerReplica</code> 来控制。
当一个集群使用具有较少核心的节点时，由 <code>nodesPerReplica</code> 来控制。</p>
<p>其它的扩缩模式也是支持的，详情查看
<a href=https://github.com/kubernetes-sigs/cluster-proportional-autoscaler>cluster-proportional-autoscaler</a>。</p>
<h2 id=禁用-dns-水平自动扩缩>禁用 DNS 水平自动扩缩</h2>
<p>有几个可供调优的 DNS 水平自动扩缩选项。具体使用哪个选项因环境而异。</p>
<h3 id=选项-1-缩容-dns-autoscaler-deployment-至-0-个副本>选项 1：缩容 dns-autoscaler Deployment 至 0 个副本</h3>
<p>该选项适用于所有场景。运行如下命令：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl scale deployment --replicas<span style=color:#666>=</span><span style=color:#666>0</span> dns-autoscaler --namespace<span style=color:#666>=</span>kube-system
</code></pre></div>
<p>输出如下所示：</p>
<pre><code>deployment.apps/dns-autoscaler scaled
</code></pre>
<p>验证当前副本数为 0：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get rs --namespace<span style=color:#666>=</span>kube-system
</code></pre></div>
<p>输出内容中，在 DESIRED 和 CURRENT 列显示为 0：</p>
<pre><code>NAME                                 DESIRED   CURRENT   READY   AGE
...
dns-autoscaler-6b59789fc8            0         0         0       ...
...
</code></pre>
<h3 id=选项-2-删除-dns-autoscaler-deployment>选项 2：删除 dns-autoscaler Deployment</h3>
<p>如果 dns-autoscaler 为你所控制，也就说没有人会去重新创建它，可以选择此选项：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete deployment dns-autoscaler --namespace<span style=color:#666>=</span>kube-system
</code></pre></div>
<p>输出内容如下所示：</p>
<pre><code>deployment.apps &quot;dns-autoscaler&quot; deleted
</code></pre>
<h3 id=选项-3-从主控节点删除-dns-autoscaler-清单文件>选项 3：从主控节点删除 dns-autoscaler 清单文件</h3>
<p>如果 dns-autoscaler 在<a href=https://git.k8s.io/kubernetes/cluster/addons/README.md>插件管理器</a>
的控制之下，并且具有操作 master 节点的写权限，可以使用此选项。</p>
<p>登录到主控节点，删除对应的清单文件。
dns-autoscaler 对应的路径一般为：</p>
<pre><code>/etc/kubernetes/addons/dns-horizontal-autoscaler/dns-horizontal-autoscaler.yaml
</code></pre>
<p>当清单文件被删除后，插件管理器将删除 dns-autoscaler Deployment。</p>
<h2 id=理解-dns-水平自动扩缩工作原理>理解 DNS 水平自动扩缩工作原理</h2>
<ul>
<li>
<p>cluster-proportional-autoscaler 应用独立于 DNS 服务部署。</p>
</li>
<li>
<p>autoscaler Pod 运行一个客户端，它通过轮询 Kubernetes API 服务器获取集群中节点和核心的数量。</p>
</li>
</ul>
<ul>
<li>
<p>系统会基于当前可调度的节点个数、核心数以及所给的扩缩参数，计算期望的副本数并应用到 DNS 后端。</p>
</li>
<li>
<p>扩缩参数和数据点会基于一个 ConfigMap 来提供给 autoscaler，它会在每次轮询时刷新它的参数表，
以与最近期望的扩缩参数保持一致。</p>
</li>
</ul>
<ul>
<li>
<p>扩缩参数是可以被修改的，而且不需要重建或重启 autoscaler Pod。</p>
</li>
<li>
<p>autoscaler 提供了一个控制器接口来支持两种控制模式：<em>linear</em> 和 <em>ladder</em>。</p>
</li>
</ul>
<h2 id=what-s-next>What's next</h2>
<ul>
<li>阅读<a href=/zh/docs/tasks/administer-cluster/guaranteed-scheduling-critical-addon-pods/>为关键插件 Pod 提供的调度保障</a></li>
<li>进一步了解 <a href=https://github.com/kubernetes-sigs/cluster-proportional-autoscaler>cluster-proportional-autoscaler 实现</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-3d0cd7d2f13d4759094f281504cf57b8>3.34 - 自定义 DNS 服务</h1>
<p>本页说明如何配置 DNS <a class=glossary-tooltip title="Pod 表示您的集群上一组正在运行的容器。" data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod(s)>Pod(s)</a>，以及定制集群中 DNS 解析过程。</p>
<h2 id=before-you-begin>Before you begin</h2>
<p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li>
</ul>
Your Kubernetes server must be at or later than version v1.12.
To check the version, enter <code>kubectl version</code>.
</p>
<p>你的集群必须运行 CoreDNS 插件。
文档<a href=/zh/docs/tasks/administer-cluster/coredns/#migrating-to-coredns>迁移到 CoreDNS</a>
解释了如何使用 <code>kubeadm</code> 从 <code>kube-dns</code> 迁移到 CoreDNS。</p>
<h2 id=介绍>介绍</h2>
<p>DNS 是使用<a href=http://releases.k8s.io/master/cluster/addons/README.md>集群插件</a>
管理器自动启动的内置的 Kubernetes 服务。</p>
<p>从 Kubernetes v1.12 开始，CoreDNS 是推荐的 DNS 服务器，取代了 kube-dns。 如果
你的集群原来使用 kube-dns，你可能部署的仍然是 <code>kube-dns</code> 而不是 CoreDNS。</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> CoreDNS 服务在其 <code>metadata.name</code> 字段被命名为 <code>kube-dns</code>。
这是为了能够与依靠传统 <code>kube-dns</code> 服务名称来解析集群内部地址的工作负载具有更好的互操作性。
使用 <code>kube-dns</code> 作为服务名称可以抽离共有名称之后运行的是哪个 DNS 提供程序这一实现细节。
</div>
<p>如果你在使用 Deployment 运行 CoreDNS，则该 Deployment 通常会向外暴露为一个具有
静态 IP 地址 Kubernetes 服务。
kubelet 使用 <code>--cluster-dns=&lt;DNS 服务 IP></code> 标志将 DNS 解析器的信息传递给每个容器。</p>
<p>DNS 名称也需要域名。 你可在 kubelet 中使用 <code>--cluster-domain=&lt;默认本地域名></code>
标志配置本地域名。</p>
<p>DNS 服务器支持正向查找（A 和 AAAA 记录）、端口发现（SRV 记录）、反向 IP 地址发现（PTR 记录）等。
更多信息，请参见<a href=/zh/docs/concepts/services-networking/dns-pod-service/>Pod 和 服务的 DNS</a>。</p>
<p>如果 Pod 的 <code>dnsPolicy</code> 设置为 "<code>default</code>"，则它将从 Pod 运行所在节点继承名称解析配置。
Pod 的 DNS 解析行为应该与节点相同。
但请参阅<a href=/zh/docs/tasks/administer-cluster/dns-debugging-resolution/#known-issues>已知问题</a>。</p>
<p>如果你不想这样做，或者想要为 Pod 使用其他 DNS 配置，则可以
使用 kubelet 的 <code>--resolv-conf</code> 标志。 将此标志设置为 "" 可以避免 Pod 继承 DNS。
将其设置为有别于 <code>/etc/resolv.conf</code> 的有效文件路径可以设定 DNS 继承不同的配置。</p>
<h2 id=coredns>CoreDNS</h2>
<p>CoreDNS 是通用的权威 DNS 服务器，可以用作集群 DNS，符合
<a href=https://github.com/kubernetes/dns/blob/master/docs/specification.md>DNS 规范</a>。</p>
<h3 id=coredns-configmap-options>CoreDNS ConfigMap 选项 </h3>
<p>CoreDNS 是模块化且可插拔的 DNS 服务器，每个插件都为 CoreDNS 添加了新功能。
可以通过维护 <a href=https://coredns.io/2017/07/23/corefile-explained/>Corefile</a>，即 CoreDNS 配置文件，
来定制其行为。 集群管理员可以修改 CoreDNS Corefile 的 ConfigMap，以更改服务发现的工作方式。</p>
<p>在 Kubernetes 中，CoreDNS 安装时使用如下默认 Corefile 配置。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>coredns<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>kube-system<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>Corefile</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span><span style=color:#b44;font-style:italic>    .:53 {
</span><span style=color:#b44;font-style:italic>        errors
</span><span style=color:#b44;font-style:italic>        health {
</span><span style=color:#b44;font-style:italic>            lameduck 5s
</span><span style=color:#b44;font-style:italic>        }
</span><span style=color:#b44;font-style:italic>        ready
</span><span style=color:#b44;font-style:italic>        kubernetes cluster.local in-addr.arpa ip6.arpa {
</span><span style=color:#b44;font-style:italic>           pods insecure
</span><span style=color:#b44;font-style:italic>           fallthrough in-addr.arpa ip6.arpa
</span><span style=color:#b44;font-style:italic>           ttl 30
</span><span style=color:#b44;font-style:italic>        }
</span><span style=color:#b44;font-style:italic>        prometheus :9153
</span><span style=color:#b44;font-style:italic>        forward . /etc/resolv.conf
</span><span style=color:#b44;font-style:italic>        cache 30
</span><span style=color:#b44;font-style:italic>        loop
</span><span style=color:#b44;font-style:italic>        reload
</span><span style=color:#b44;font-style:italic>        loadbalance
</span><span style=color:#b44;font-style:italic>    }</span><span style=color:#bbb>    
</span></code></pre></div>
<p>Corefile 配置包括以下 CoreDNS <a href=https://coredns.io/plugins/>插件</a>：</p>
<ul>
<li>
<p><a href=https://coredns.io/plugins/errors/>errors</a>：错误记录到标准输出。</p>
</li>
<li>
<p><a href=https://coredns.io/plugins/health/>health</a>：在 http://localhost:8080/health 处提供 CoreDNS 的健康报告。</p>
</li>
<li>
<p><a href=https://coredns.io/plugins/ready/>ready</a>：在端口 8181 上提供的一个 HTTP 末端，当所有能够
表达自身就绪的插件都已就绪时，在此末端返回 200 OK。</p>
</li>
<li>
<p><a href=https://coredns.io/plugins/kubernetes/>kubernetes</a>：CoreDNS 将基于 Kubernetes 的服务和 Pod 的
IP 答复 DNS 查询。你可以在 CoreDNS 网站阅读<a href=https://coredns.io/plugins/kubernetes/>更多细节</a>。
你可以使用 <code>ttl</code> 来定制响应的 TTL。默认值是 5 秒钟。TTL 的最小值可以是 0 秒钟，
最大值为 3600 秒。将 TTL 设置为 0 可以禁止对 DNS 记录进行缓存。</p>
<p><code>pods insecure</code> 选项是为了与 kube-dns 向后兼容。你可以使用 <code>pods verified</code> 选项，该选项使得
仅在相同名称空间中存在具有匹配 IP 的 Pod 时才返回 A 记录。如果你不使用 Pod 记录，则可以使用
<code>pods disabled</code> 选项。</p>
</li>
</ul>
<ul>
<li><a href=https://coredns.io/plugins/prometheus/>prometheus</a>：CoreDNS 的度量指标值以
<a href=https://prometheus.io/>Prometheus</a> 格式在 http://localhost:9153/metrics 上提供。</li>
<li><a href=https://coredns.io/plugins/forward/>forward</a>: 不在 Kubernetes 集群域内的任何查询都将转发到
预定义的解析器 (/etc/resolv.conf).</li>
<li><a href=https://coredns.io/plugins/cache/>cache</a>：启用前端缓存。</li>
<li><a href=https://coredns.io/plugins/loop/>loop</a>：检测到简单的转发环，如果发现死循环，则中止 CoreDNS 进程。</li>
<li><a href=https://coredns.io/plugins/reload>reload</a>：允许自动重新加载已更改的 Corefile。
编辑 ConfigMap 配置后，请等待两分钟，以使更改生效。</li>
<li><a href=https://coredns.io/plugins/loadbalance>loadbalance</a>：这是一个轮转式 DNS 负载均衡器，
它在应答中随机分配 A、AAAA 和 MX 记录的顺序。</li>
</ul>
<p>你可以通过修改 ConfigMap 来更改默认的 CoreDNS 行为。</p>
<h3 id=使用-coredns-配置存根域和上游域名服务器>使用 CoreDNS 配置存根域和上游域名服务器</h3>
<p>CoreDNS 能够使用 <a href=https://coredns.io/plugins/forward/>forward 插件</a>配置存根域和上游域名服务器。</p>
<h4 id=示例>示例</h4>
<p>如果集群操作员在 10.150.0.1 处运行了 <a href=https://www.consul.io/>Consul</a> 域服务器，
且所有 Consul 名称都带有后缀 <code>.consul.local</code>。要在 CoreDNS 中对其进行配置，
集群管理员可以在 CoreDNS 的 ConfigMap 中创建加入以下字段。</p>
<pre><code>consul.local:53 {
        errors
        cache 30
        forward . 10.150.0.1
    }
</code></pre>
<p>要显式强制所有非集群 DNS 查找通过特定的域名服务器（位于 172.16.0.1），可将 <code>forward</code>
指向该域名服务器，而不是 <code>/etc/resolv.conf</code>。</p>
<pre><code>forward .  172.16.0.1
</code></pre>
<p>最终的包含默认的 <code>Corefile</code> 配置的 ConfigMap 如下所示：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>coredns<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>kube-system<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>Corefile</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span><span style=color:#b44;font-style:italic>    .:53 {
</span><span style=color:#b44;font-style:italic>        errors
</span><span style=color:#b44;font-style:italic>        health
</span><span style=color:#b44;font-style:italic>        kubernetes cluster.local in-addr.arpa ip6.arpa {
</span><span style=color:#b44;font-style:italic>           pods insecure
</span><span style=color:#b44;font-style:italic>           fallthrough in-addr.arpa ip6.arpa
</span><span style=color:#b44;font-style:italic>        }
</span><span style=color:#b44;font-style:italic>        prometheus :9153
</span><span style=color:#b44;font-style:italic>        forward . 172.16.0.1
</span><span style=color:#b44;font-style:italic>        cache 30
</span><span style=color:#b44;font-style:italic>        loop
</span><span style=color:#b44;font-style:italic>        reload
</span><span style=color:#b44;font-style:italic>        loadbalance
</span><span style=color:#b44;font-style:italic>    }
</span><span style=color:#b44;font-style:italic>    consul.local:53 {
</span><span style=color:#b44;font-style:italic>        errors
</span><span style=color:#b44;font-style:italic>        cache 30
</span><span style=color:#b44;font-style:italic>        forward . 10.150.0.1
</span><span style=color:#b44;font-style:italic>    }</span><span style=color:#bbb>    
</span></code></pre></div>
<p>工具 <code>kubeadm</code> 支持将 kube-dns ConfigMap 自动转换为 CoreDNS ConfigMap。</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 尽管 kube-dns 接受 FQDN（例如：ns.foo.com）作为存根域和名字服务器，CoreDNS 不支持此功能。
转换期间，CoreDNS 配置中将忽略所有的 FQDN 域名服务器。
</div>
<h2 id=coredns-配置等同于-kube-dns>CoreDNS 配置等同于 kube-dns</h2>
<p>CoreDNS 不仅仅提供 kube-dns 的功能。
为 kube-dns 创建的 ConfigMap 支持 <code>StubDomains</code> 和 <code>upstreamNameservers</code> 转换为 CoreDNS 中的 <code>forward</code> 插件。</p>
<h3 id=示例-1>示例</h3>
<p>用于 kubedns 的此示例 ConfigMap 描述了 stubdomains 和 upstreamnameservers：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>stubDomains</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span><span style=color:#b44;font-style:italic>    </span><span style=color:#bbb>    </span>{<span style=color:#b44>&#34;abc.com&#34;</span><span style=color:#bbb> </span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;1.2.3.4&#34;</span>],<span style=color:#bbb> </span><span style=color:#b44>&#34;my.cluster.local&#34;</span><span style=color:#bbb> </span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;2.3.4.5&#34;</span>]}<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>upstreamNameservers</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span><span style=color:#b44;font-style:italic>    </span><span style=color:#bbb>    </span>[<span style=color:#b44>&#34;8.8.8.8&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;8.8.4.4&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span></code></pre></div>
<p>CoreDNS 中的等效配置将创建一个 Corefile：</p>
<ul>
<li>
<p>针对 stubDomains:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>abc.com:53 {<span style=color:#bbb>
</span><span style=color:#bbb>     </span>errors<span style=color:#bbb>
</span><span style=color:#bbb>     </span>cache 30<span style=color:#bbb>
</span><span style=color:#bbb>     </span>proxy . 1.2.3.4<span style=color:#bbb>
</span><span style=color:#bbb> </span>}<span style=color:#bbb>
</span><span style=color:#bbb> </span>my.cluster.local:53 {<span style=color:#bbb>
</span><span style=color:#bbb>     </span>errors<span style=color:#bbb>
</span><span style=color:#bbb>     </span>cache 30<span style=color:#bbb>
</span><span style=color:#bbb>     </span>proxy . 2.3.4.5<span style=color:#bbb>
</span><span style=color:#bbb> </span>}<span style=color:#bbb>
</span></code></pre></div></li>
</ul>
<p>带有默认插件的完整 Corefile：</p>
<pre><code>.:53 {
    errors
    health
    kubernetes cluster.local in-addr.arpa ip6.arpa {
       pods insecure
       fallthrough in-addr.arpa ip6.arpa
    }
    federation cluster.local {
       foo foo.feddomain.com
    }
    prometheus :9153
    forward .  8.8.8.8 8.8.4.4
    cache 30
}
abc.com:53 {
    errors
    cache 30
    forward . 1.2.3.4
}
my.cluster.local:53 {
    errors
    cache 30
    forward . 2.3.4.5
}
</code></pre>
<h2 id=迁移到-coredns>迁移到 CoreDNS</h2>
<p>要从 kube-dns 迁移到 CoreDNS，<a href=https://coredns.io/2018/05/21/migration-from-kube-dns-to-coredns/>此博客</a>
提供了帮助用户将 kube-dns 替换为 CoreDNS。
集群管理员还可以使用<a href=https://github.com/coredns/deployment/blob/master/kubernetes/deploy.sh>部署脚本</a>
进行迁移。</p>
<h2 id=what-s-next>What's next</h2>
<ul>
<li>阅读<a href=/zh/docs/tasks/administer-cluster/dns-debugging-resolution/>调试 DNS 解析</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-8bcf4aeb5bbb6d6969a146e5ab97557b>3.35 - 调试 DNS 问题</h1>
<p>这篇文章提供了一些关于 DNS 问题诊断的方法。</p>
<h2 id=before-you-begin>Before you begin</h2>
<p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li>
</ul>
<p>你的集群必须使用了 CoreDNS <a class=glossary-tooltip title="扩展 Kubernetes 功能的资源。" data-toggle=tooltip data-placement=top href=/zh/docs/concepts/cluster-administration/addons/ target=_blank aria-label=插件>插件</a>
或者其前身，<code>kube-dns</code>。</p>
Your Kubernetes server must be at or later than version v1.6.
To check the version, enter <code>kubectl version</code>.
<h3 id=创建一个简单的-pod-作为测试环境>创建一个简单的 Pod 作为测试环境</h3>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/admin/dns/dnsutils.yaml download=admin/dns/dnsutils.yaml><code>admin/dns/dnsutils.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('admin-dns-dnsutils-yaml')" title="Copy admin/dns/dnsutils.yaml to clipboard">
</img>
</div>
<div class=includecode id=admin-dns-dnsutils-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>dnsutils<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>dnsutils<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/e2e-test-images/jessie-dnsutils:1.3<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- sleep<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:#b44>&#34;3600&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>imagePullPolicy</span>:<span style=color:#bbb> </span>IfNotPresent<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Always<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 此示例在 <code>default</code> 命名空间创建 pod。 服务的 DNS 名字解析取决于 pod 的命名空间。 详细信息请查阅
<a href=/zh/docs/concepts/services-networking/dns-pod-service/#what-things-get-dns-names>服务和 Pod 的 DNS</a>。
</div>
<p>使用上面的清单来创建一个 Pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/admin/dns/dnsutils.yaml
</code></pre></div><pre><code>pod/dnsutils created
</code></pre>
<p>验证其状态：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods dnsutils
</code></pre></div><pre><code>NAME      READY     STATUS    RESTARTS   AGE
dnsutils   1/1       Running   0          &lt;some-time&gt;
</code></pre>
<p>一旦 Pod 处于运行状态，你就可以在该环境里执行 <code>nslookup</code>。
如果你看到类似下列的内容，则表示 DNS 是正常运行的。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#a2f>exec</span> -i -t dnsutils -- nslookup kubernetes.default
</code></pre></div><pre><code>Server:    10.0.0.10
Address 1: 10.0.0.10

Name:      kubernetes.default
Address 1: 10.0.0.1
</code></pre>
<p>如果 <code>nslookup</code> 命令执行失败，请检查下列内容：</p>
<h3 id=先检查本地的-dns-配置>先检查本地的 DNS 配置</h3>
<p>查看 resolv.conf 文件的内容
（阅读<a href=/zh/docs/tasks/administer-cluster/dns-custom-nameservers/>定制 DNS 服务</a> 和
后文的<a href=#known-issues>已知问题</a> ，获取更多信息)</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#a2f>exec</span> -ti dnsutils -- cat /etc/resolv.conf
</code></pre></div>
<p>验证 search 和 nameserver 的配置是否与下面的内容类似
（注意 search 根据不同的云提供商可能会有所不同)：</p>
<pre><code>search default.svc.cluster.local svc.cluster.local cluster.local google.internal c.gce_project_id.internal
nameserver 10.0.0.10
options ndots:5
</code></pre>
<p>下列错误表示 CoreDNS （或 kube-dns）插件或者相关服务出现了问题：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#a2f>exec</span> -i -t dnsutils -- nslookup kubernetes.default
</code></pre></div><p>输出为：</p>
<pre><code>Server:    10.0.0.10
Address 1: 10.0.0.10

nslookup: can't resolve 'kubernetes.default'
</code></pre><p>或者</p>
<pre><code>Server:    10.0.0.10
Address 1: 10.0.0.10 kube-dns.kube-system.svc.cluster.local

nslookup: can't resolve 'kubernetes.default'
</code></pre>
<h3 id=check-if-the-dns-pod-is-running>检查 DNS Pod 是否运行 </h3>
<p>使用 <code>kubectl get pods</code> 命令来验证 DNS Pod 是否运行。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods --namespace<span style=color:#666>=</span>kube-system -l k8s-app<span style=color:#666>=</span>kube-dns
</code></pre></div><pre><code>NAME                       READY     STATUS    RESTARTS   AGE
...
coredns-7b96bf9f76-5hsxb   1/1       Running   0           1h
coredns-7b96bf9f76-mvmmt   1/1       Running   0           1h
...
</code></pre>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 对于 CoreDNS 和 kube-dns 部署而言，标签 <code>k8s-app</code> 的值都应该是 <code>kube-dns</code>。
</div>
<p>如果你发现没有 CoreDNS Pod 在运行，或者该 Pod 的状态是 failed 或者 completed，
那可能这个 DNS 插件在您当前的环境里并没有成功部署，你将需要手动去部署它。</p>
<h3 id=check-for-errors-in-the-dns-pod>检查 DNS Pod 里的错误 </h3>
<p>使用 <code>kubectl logs</code> 命令来查看 DNS 容器的日志信息。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl logs --namespace<span style=color:#666>=</span>kube-system -l k8s-app<span style=color:#666>=</span>kube-dns
</code></pre></div>
<p>下列是一个正常运行的 CoreDNS 日志信息：</p>
<pre><code>.:53
2018/08/15 14:37:17 [INFO] CoreDNS-1.2.2
2018/08/15 14:37:17 [INFO] linux/amd64, go1.10.3, 2e322f6
CoreDNS-1.2.2
linux/amd64, go1.10.3, 2e322f6
2018/08/15 14:37:17 [INFO] plugin/reload: Running configuration MD5 = 24e6c59e83ce706f07bcc82c31b1ea1c
</code></pre>
<p>查看是否日志中有一些可疑的或者意外的消息。</p>
<h3 id=is-dns-service-up>检查是否启用了 DNS 服务 </h3>
<p>使用 <code>kubectl get service</code> 命令来检查 DNS 服务是否已经启用。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get svc --namespace<span style=color:#666>=</span>kube-system
</code></pre></div><pre><code>NAME         TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)             AGE
...
kube-dns     ClusterIP   10.0.0.10      &lt;none&gt;        53/UDP,53/TCP        1h
...
</code></pre>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 不管是 CoreDNS 还是 kube-dns，这个服务的名字都会是 <code>kube-dns</code> 。
</div>
<p>如果你已经创建了 DNS 服务，或者该服务应该是默认自动创建的但是它并没有出现，
请阅读<a href=/zh/docs/tasks/debug-application-cluster/debug-service/>调试服务</a>
来获取更多信息。</p>
<h3 id=are-dns-endpoints-exposed>DNS 的端点公开了吗？ </h3>
<p>你可以使用 <code>kubectl get endpoints</code> 命令来验证 DNS 的端点是否公开了。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get ep kube-dns --namespace<span style=color:#666>=</span>kube-system
</code></pre></div><pre><code>NAME       ENDPOINTS                       AGE
kube-dns   10.180.3.17:53,10.180.3.17:53    1h
</code></pre>
<p>如果你没看到对应的端点，请阅读
<a href=/zh/docs/tasks/debug-application-cluster/debug-service/>调试服务</a>的端点部分。</p>
<p>若需要了解更多的 Kubernetes DNS 例子，请在 Kubernetes GitHub 仓库里查看
<a href=https://github.com/kubernetes/examples/tree/master/staging/cluster-dns>cluster-dns 示例</a>。</p>
<h3 id=are-dns-queries-bing-received-processed>DNS 查询有被接收或者执行吗？ </h3>
<p>你可以通过给 CoreDNS 的配置文件（也叫 Corefile）添加 <code>log</code> 插件来检查查询是否被正确接收。
CoreDNS 的 Corefile 被保存在一个叫 <code>coredns</code> 的 ConfigMap 里，使用下列命令来编辑它：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl -n kube-system edit configmap coredns
</code></pre></div>
<p>然后按下面的例子给 Corefile 添加 <code>log</code>。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>coredns<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>kube-system<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>Corefile</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span><span style=color:#b44;font-style:italic>    .:53 {
</span><span style=color:#b44;font-style:italic>        log
</span><span style=color:#b44;font-style:italic>        errors
</span><span style=color:#b44;font-style:italic>        health
</span><span style=color:#b44;font-style:italic>        kubernetes cluster.local in-addr.arpa ip6.arpa {
</span><span style=color:#b44;font-style:italic>          pods insecure
</span><span style=color:#b44;font-style:italic>          upstream
</span><span style=color:#b44;font-style:italic>          fallthrough in-addr.arpa ip6.arpa
</span><span style=color:#b44;font-style:italic>        }
</span><span style=color:#b44;font-style:italic>        prometheus :9153
</span><span style=color:#b44;font-style:italic>        forward . /etc/resolv.conf
</span><span style=color:#b44;font-style:italic>        cache 30
</span><span style=color:#b44;font-style:italic>        loop
</span><span style=color:#b44;font-style:italic>        reload
</span><span style=color:#b44;font-style:italic>        loadbalance
</span><span style=color:#b44;font-style:italic>    }</span><span style=color:#bbb>    
</span></code></pre></div>
<p>保存这些更改后，你可能会需要等待一到两分钟让 Kubernetes 把这些更改应用到
CoreDNS 的 Pod 里。</p>
<p>接下来，发起一些查询并依照前文所述查看日志信息，如果 CoreDNS 的 Pod 接收到这些查询，
你将可以在日志信息里看到它们。</p>
<p>下面是日志信息里的查询例子：</p>
<pre><code>.:53
2018/08/15 14:37:15 [INFO] CoreDNS-1.2.0
2018/08/15 14:37:15 [INFO] linux/amd64, go1.10.3, 2e322f6
CoreDNS-1.2.0
linux/amd64, go1.10.3, 2e322f6
2018/09/07 15:29:04 [INFO] plugin/reload: Running configuration MD5 = 162475cdf272d8aa601e6fe67a6ad42f
2018/09/07 15:29:04 [INFO] Reloading complete
172.17.0.18:41675 - [07/Sep/2018:15:29:11 +0000] 59925 &quot;A IN kubernetes.default.svc.cluster.local. udp 54 false 512&quot; NOERROR qr,aa,rd,ra 106 0.000066649s

</code></pre>
<h3 id=你的服务在正确的命名空间中吗>你的服务在正确的命名空间中吗？</h3>
<p>未指定命名空间的 DNS 查询仅作用于 pod 所在的命名空间。</p>
<p>如果 pod 和服务的命名空间不相同，则 DNS 查询必须指定服务所在的命名空间。</p>
<p>该查询仅限于 pod 所在的名称空间：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#a2f>exec</span> -i -t dnsutils -- nslookup &lt;service-name&gt;
</code></pre></div>
<p>指定命名空间的查询：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#a2f>exec</span> -i -t dnsutils -- nslookup &lt;service-name&gt;.&lt;namespace&gt;
</code></pre></div>
<p>要进一步了解名字解析，请查看
<a href=/zh/docs/concepts/services-networking/dns-pod-service/#what-things-get-dns-names>服务和 Pod 的 DNS</a>。</p>
<h2 id=known-issues>已知问题</h2>
<p>有些 Linux 发行版本（比如 Ubuntu）默认使用一个本地的 DNS 解析器（systemd-resolved）。
<code>systemd-resolved</code> 会用一个存根文件（Stub File）来覆盖 <code>/etc/resolv.conf</code> 内容，
从而可能在上游服务器中解析域名产生转发环（forwarding loop）。 这个问题可以通过手动指定
kubelet 的 <code>--resolv-conf</code> 标志为正确的 <code>resolv.conf</code>（如果是 <code>systemd-resolved</code>，
则这个文件路径为 <code>/run/systemd/resolve/resolv.conf</code>）来解决。
kubeadm 会自动检测 <code>systemd-resolved</code> 并对应的更改 kubelet 的命令行标志。</p>
<p>Kubernetes 的安装并不会默认配置节点的 <code>resolv.conf</code> 文件来使用集群的 DNS 服务，因为这个配置对于不同的发行版本是不一样的。这个问题应该迟早会被解决的。</p>
<p>Linux 的 libc 限制 <code>nameserver</code> 只能有三个记录。不仅如此，对于 glibc-2.17-222
之前的版本（<a href=https://access.redhat.com/solutions/58028>参见此 Issue 了解新版本的更新</a>），<code>search</code> 的记录不能超过 6 个
（ <a href="https://bugzilla.redhat.com/show_bug.cgi?id=168253">详情请查阅这个 2005 年的 bug</a>）。
Kubernetes 需要占用一个 <code>nameserver</code> 记录和三个<code>search</code>记录。
这意味着如果一个本地的安装已经使用了三个 <code>nameserver</code> 或者使用了超过三个
<code>search</code> 记录，而你的 glibc 版本也在有问题的版本列表中，那么有些配置很可能会丢失。
为了绕过 DNS <code>nameserver</code> 个数限制，节点可以运行 <code>dnsmasq</code>，以提供更多的
<code>nameserver</code> 记录。你也可以使用kubelet 的 <code>--resolv-conf</code> 标志来解决这个问题。
要想修复 DNS <code>search</code> 记录个数限制问题，可以考虑升级你的 Linux 发行版本，或者
升级 glibc 到一个不再受此困扰的版本。</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong>
<p>使用<a href=/zh/docs/concepts/services-networking/dns-pod-service/#expanded-dns-configuration>扩展 DNS 设置</a>，
Kubernetes 允许更多的 <code>search</code> 记录。
</div>
<p>如果你使用 Alpine 3.3 或更早版本作为你的基础镜像，DNS 可能会由于 Alpine 中
一个已知的问题导致无法正常工作。
请查看<a href=https://github.com/kubernetes/kubernetes/issues/30215>这里</a>获取更多信息。</p>
<h2 id=what-s-next>What's next</h2>
<ul>
<li>参阅<a href=/zh/docs/tasks/administer-cluster/dns-horizontal-autoscaling/>自动扩缩集群中的 DNS 服务</a>.</li>
<li>阅读<a href=/zh/docs/concepts/services-networking/dns-pod-service/>服务和 Pod 的 DNS</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-a24171610b6ea75a142cb9c8c7882390>3.36 - 迁移多副本的控制面以使用云控制器管理器</h1>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.22 [beta]</code>
</div>
<p>云控制器管理器是指嵌入特定云的控制逻辑的
<a class=glossary-tooltip title="控制平面是指容器编排层，它暴露 API 和接口来定义、部署容器和管理容器的生命周期。" data-toggle=tooltip data-placement=top href="/zh/docs/reference/glossary/?all=true#term-control-plane" target=_blank aria-label=控制平面>控制平面</a>组件。
云控制器管理器使得你可以将你的集群连接到云提供商的 API 之上，
并将与该云平台交互的组件同与你的集群交互的组件分离开来。</p>
<p>通过分离 Kubernetes 和底层云基础设置之间的互操作性逻辑，
云控制器管理器组件使云提供商能够以不同于 Kubernetes 主项目的
步调发布新特征。</p>
<h2 id=背景>背景</h2>
<p>作为<a href=https://kubernetes.io/blog/2019/04/17/the-future-of-cloud-providers-in-kubernetes/>云驱动提取工作</a>
的一部分，所有特定于云的控制器都必须移出 <code>kube-controller-manager</code>。
所有在 <code>kube-controller-manager</code> 中运行云控制器的现有集群必须迁移到特定于云厂商的
<code>cloud-controller-manager</code> 中运行这些控制器。</p>
<p>领导者迁移（Leader Migration）提供了一种机制，使得 HA 集群可以通过这两个组件之间共享资源锁，
在升级多副本的控制平面时，安全地将“特定于云”的控制器从 <code>kube-controller-manager</code> 迁移到
<code>cloud-controller-manager</code>。
对于单节点控制平面，或者在升级过程中可以容忍控制器管理器不可用的情况，则不需要领导者迁移，
亦可以忽略本指南。</p>
<p>领导者迁移可以通过在 <code>kube-controller-manager</code> 或 <code>cloud-controller-manager</code> 上设置
<code>--enable-leader-migration</code> 来启用。
领导者迁移仅在升级期间适用，并且在升级完成后可以安全地禁用或保持启用状态。</p>
<p>本指南将引导你手动将控制平面从内置的云驱动的 <code>kube-controller-manager</code> 升级为
同时运行 <code>kube-controller-manager</code> 和 <code>cloud-controller-manager</code>。
如果使用某种工具来管理群集，请参阅对应工具和云驱动的文档以获取更多详细信息。</p>
<h2 id=before-you-begin>Before you begin</h2>
<p>假定控制平面正在运行 Kubernetes 版本 N，要升级到版本 N+1。
尽管可以在同一版本内进行迁移，但理想情况下，迁移应作为升级的一部分执行，
以便可以配置的变更可以与发布版本变化对应起来。
N 和 N+1 的确切版本值取决于各个云厂商。例如，如果云厂商构建了一个可与 Kubernetes 1.22
配合使用的 <code>cloud-controller-manager</code>，则 N 可以为 1.21，N+1 可以为 1.22。</p>
<p>控制平面节点应运行 <code>kube-controller-manager</code>，并通过 <code>--leader-elect=true</code> 启用领导者选举。
在版本 N 中，树内云驱动必须设置 <code>--cloud-provider</code> 标志，而且 <code>cloud-controller-manager</code>
应该尚未部署。</p>
<p>树外云驱动必须已经构建了一个实现了领导者迁移的 <code>cloud-controller-manager</code>。
如果云驱动导入了 v0.21.0 或更高版本的 <code>k8s.io/cloud-provider</code> 和 <code>k8s.io/controller-manager</code>，
则可以进行领导者迁移。
但是，对 v0.22.0 以下的版本，领导者迁移是一项 Alpha 阶段功能，需要启用特性门控
<code>ControllerManagerLeaderMigration</code>。</p>
<p>本指南假定每个控制平面节点的 kubelet 以静态 Pod 的形式启动 <code>kube-controller-manager</code>
和 <code>cloud-controller-manager</code>，静态 Pod 的定义在清单文件中。
如果组件以其他设置运行，请相应地调整这里的步骤。</p>
<p>关于鉴权，本指南假定集群使用 RBAC。如果其他鉴权模式授予 <code>kube-controller-manager</code>
和 <code>cloud-controller-manager</code> 组件权限，请以与该模式匹配的方式授予所需的访问权限。</p>
<h3 id=授予访问迁移租约的权限>授予访问迁移租约的权限</h3>
<p>控制器管理器的默认权限仅允许访问其主租约（Lease）对象。为了使迁移正常进行，
需要授权它访问其他 Lease 对象。</p>
<p>你可以通过修改 <code>system::leader-locking-kube-controller-manager</code> 角色来授予
<code>kube-controller-manager</code> 对 Lease API 的完全访问权限。
本任务指南假定迁移 Lease 的名称为 <code>cloud-provider-extraction-migration</code>。</p>
<p><code>kubectl patch -n kube-system role 'system::leader-locking-kube-controller-manager' -p '{"rules": [ {"apiGroups":[ "coordination.k8s.io"], "resources": ["leases"], "resourceNames": ["cloud-provider-extraction-migration"], "verbs": ["create", "list", "get", "update"] } ]}' --type=merge</code></p>
<p>对 <code>system::leader-locking-cloud-controller-manager</code> 角色执行相同的操作。</p>
<p><code>kubectl patch -n kube-system role 'system::leader-locking-cloud-controller-manager' -p '{"rules": [ {"apiGroups":[ "coordination.k8s.io"], "resources": ["leases"], "resourceNames": ["cloud-provider-extraction-migration"], "verbs": ["create", "list", "get", "update"] } ]}' --type=merge</code></p>
<h3 id=初始领导者迁移配置>初始领导者迁移配置</h3>
<p>领导者迁移可以选择使用一个表示如何将控制器分配给不同管理器的配置文件。
目前，对于树内云驱动，<code>kube-controller-manager</code> 运行 <code>route</code>、<code>service</code> 和
<code>cloud-node-lifecycle</code>。以下示例配置显示的是这种分配。</p>
<p>领导者迁移可以不指定配置的情况下启用。请参阅<a href=#default-configuration>默认配置</a>
以获取更多详细信息。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>LeaderMigrationConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>controllermanager.config.k8s.io/v1beta1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>leaderName</span>:<span style=color:#bbb> </span>cloud-provider-extraction-migration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>resourceLock</span>:<span style=color:#bbb> </span>leases<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>controllerLeaders</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>route<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>component</span>:<span style=color:#bbb> </span>kube-controller-manager<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>service<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>component</span>:<span style=color:#bbb> </span>kube-controller-manager<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cloud-node-lifecycle<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>component</span>:<span style=color:#bbb> </span>kube-controller-manager<span style=color:#bbb>
</span></code></pre></div>
<p>在每个控制平面节点上，请将如上内容保存到 <code>/etc/leadermigration.conf</code> 中，
并更新 <code>kube-controller-manager</code> 清单，以便将文件挂载到容器内的同一位置。
另外，请更新同一清单，添加以下参数：</p>
<ul>
<li><code>--enable-leader-migration</code> 在控制器管理器上启用领导者迁移</li>
<li><code>--leader-migration-config=/etc/leadermigration.conf</code> 设置配置文件</li>
</ul>
<p>在每个节点上重新启动 <code>kube-controller-manager</code>。这时，<code>kube-controller-manager</code>
已启用领导者迁移，为迁移准备就绪。</p>
<h3 id=部署云控制器管理器>部署云控制器管理器</h3>
<p>在版本 N+1 中，如何将控制器分配给不同管理器的预期分配状态可以由新的配置文件表示，
如下所示。请注意，各个 <code>controllerLeaders</code> 的 <code>component</code> 字段从 <code>kube-controller-manager</code>
更改为 <code>cloud-controller-manager</code>。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>LeaderMigrationConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>controllermanager.config.k8s.io/v1beta1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>leaderName</span>:<span style=color:#bbb> </span>cloud-provider-extraction-migration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>resourceLock</span>:<span style=color:#bbb> </span>leases<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>controllerLeaders</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>route<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>component</span>:<span style=color:#bbb> </span>cloud-controller-manager<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>service<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>component</span>:<span style=color:#bbb> </span>cloud-controller-manager<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cloud-node-lifecycle<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>component</span>:<span style=color:#bbb> </span>cloud-controller-manager<span style=color:#bbb>
</span></code></pre></div>
<p>当创建版本 N+1 的控制平面节点时，应将如上内容写入到 <code>/etc/leadermigration.conf</code>。
你需要更新 <code>cloud-controller-manager</code> 的清单，以与版本 N 的 <code>kube-controller-manager</code>
相同的方式挂载配置文件。
类似地，添加 <code>--feature-gates=ControllerManagerLeaderMigration=true</code>、<code>--enable-leader-migration</code>
和 <code>--leader-migration-config=/etc/leadermigration.conf</code> 到 <code>cloud-controller-manager</code>
的参数中。</p>
<p>使用已更新的 <code>cloud-controller-manager</code> 清单创建一个新的 N+1 版本的控制平面节点，
同时确保没有设置 <code>kube-controller-manager</code> 的 <code>--cloud-provider</code> 标志。
版本为 N+1 的 <code>kube-controller-manager</code> 不能启用领导者迁移，
因为在使用外部云驱动的情况下，它不再运行已迁移的控制器，因此不参与迁移。</p>
<p>请参阅<a href=/zh/docs/tasks/administer-cluster/running-cloud-controller/>云控制器管理器管理</a>
了解有关如何部署 <code>cloud-controller-manager</code> 的更多细节。</p>
<h3 id=升级控制平面>升级控制平面</h3>
<p>现在，控制平面同时包含 N 和 N+1 版本的节点。
版本 N 的节点仅运行 <code>kube-controller-manager</code>，而版本 N+1 的节点同时运行
<code>kube-controller-manager</code> 和 <code>cloud-controller-manager</code>。
根据配置所指定，已迁移的控制器在版本 N 的 <code>kube-controller-manager</code> 或版本
N+1 的 <code>cloud-controller-manager</code> 下运行，具体取决于哪个控制器管理器拥有迁移租约对象。
任何时候都不会有同一个控制器在两个控制器管理器下运行。</p>
<p>以滚动的方式创建一个新的版本为 N+1 的控制平面节点，并将版本 N 中的一个关闭，
直到控制平面仅包含版本为 N+1 的节点。
如果需要从 N+1 版本回滚到 N 版本，则将 <code>kube-controller-manager</code> 启用了领导者迁移的、
且版本为 N 的节点添加回控制平面，每次替换 N+1 版本中的一个，直到只有版本 N 的节点为止。</p>
<h3 id=disable-leader-migration>（可选）禁用领导者迁移</h3>
<p>现在，控制平面已经完成升级，同时运行版本 N+1 的 <code>kube-controller-manager</code>
和 <code>cloud-controller-manager</code>。领导者迁移的任务已经结束，可以被安全地禁用以节省一个
Lease 资源。在将来可以安全地重新启用领导者迁移，以完成回滚。</p>
<p>在滚动管理器中，更新 <code>cloud-controller-manager</code> 的清单以同时取消设置
<code>--enable-leader-migration</code> 和 <code>--leader-migration-config=</code> 标志，并删除
<code>/etc/leadermigration.conf</code> 的挂载，最后删除 <code>/etc/leadermigration.conf</code>。
要重新启用领导者迁移，请重新创建配置文件，并将其挂载和启用领导者迁移的标志添加回到
<code>cloud-controller-manager</code>。</p>
<h3 id=default-configuration>默认配置</h3>
<p>从 Kubernetes 1.22 开始，领导者迁移提供了一个默认配置，它适用于控制器与管理器间默认的分配关系。
可以通过设置 <code>--enable-leader-migration</code>，但不设置 <code>--leader-migration-config=</code>
来启用默认配置。</p>
<p>对于 <code>kube-controller-manager</code> 和 <code>cloud-controller-manager</code>，如果没有用参数来启用树内云驱动或者改变控制器属主，
则可以使用默认配置来避免手动创建配置文件。</p>
<h2 id=what-s-next>What's next</h2>
<ul>
<li>阅读<a href=https://github.com/kubernetes/enhancements/tree/master/keps/sig-cloud-provider/2436-controller-manager-leader-migration>领导者迁移控制器管理器</a>
改进建议提案。</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-1e966f5d0540bbee0876f9d0d08d54dc>3.37 - 通过名字空间共享集群</h1>
<p>本页展示如何查看、使用和删除<a class=glossary-tooltip title="名字空间是 Kubernetes 用来支持隔离单个集群中的资源组的一种抽象。" data-toggle=tooltip data-placement=top href=/zh/docs/concepts/overview/working-with-objects/namespaces/ target=_blank aria-label=名字空间>名字空间</a>。
本页同时展示如何使用 Kubernetes 名字空间来划分集群。</p>
<h2 id=before-you-begin>Before you begin</h2>
<ul>
<li>你已拥有一个<a href=/zh/docs/setup/>配置好的 Kubernetes 集群</a>。</li>
<li>你已对 Kubernetes 的 <a class=glossary-tooltip title="Pod 表示您的集群上一组正在运行的容器。" data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pods>Pods</a> ,
<a class=glossary-tooltip title="将运行在一组 Pods 上的应用程序公开为网络服务的抽象方法。" data-toggle=tooltip data-placement=top href=/zh/docs/concepts/services-networking/service/ target=_blank aria-label=Services>Services</a> , 和
<a class=glossary-tooltip title="Deployment 是管理应用副本的 API 对象。" data-toggle=tooltip data-placement=top href=/zh/docs/concepts/workloads/controllers/deployment/ target=_blank aria-label=Deployments>Deployments</a> 有基本理解。</li>
</ul>
<h2 id=查看名字空间>查看名字空间</h2>
<ol>
<li>列出集群中现有的名字空间：</li>
</ol>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get namespaces
</code></pre></div><pre><code>NAME          STATUS    AGE
default       Active    11d
kube-system   Active    11d
kube-public   Active    11d
</code></pre>
<p>初始状态下，Kubernetes 具有三个名字空间：</p>
<ul>
<li><code>default</code> 无名字空间对象的默认名字空间</li>
<li><code>kube-system</code> 由 Kubernetes 系统创建的对象的名字空间</li>
<li><code>kube-public</code> 自动创建且被所有用户可读的名字空间（包括未经身份认证的）。此名字空间通常在某些资源在整个集群中可见且可公开读取时被集群使用。此名字空间的公共方面只是一个约定，而不是一个必要条件。</li>
</ul>
<p>你还可以通过下列命令获取特定名字空间的摘要：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get namespaces &lt;name&gt;
</code></pre></div>
<p>或用下面的命令获取详细信息：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe namespaces &lt;name&gt;
</code></pre></div><pre><code>Name:           default
Labels:         &lt;none&gt;
Annotations:    &lt;none&gt;
Status:         Active

No resource quota.

Resource Limits
 Type       Resource    Min Max Default
 ----               --------    --- --- ---
 Container          cpu         -   -   100m
</code></pre>
<p>请注意，这些详情同时显示了资源配额（如果存在）以及资源限制区间。</p>
<p>资源配额跟踪并聚合 <em>Namespace</em> 中资源的使用情况，并允许集群运营者定义 <em>Namespace</em> 可能消耗的 <em>Hard</em> 资源使用限制。</p>
<p>限制区间定义了单个实体在一个 <em>Namespace</em> 中可使用的最小/最大资源量约束。</p>
<p>参阅 <a href=https://git.k8s.io/community/contributors/design-proposals/resource-management/admission_control_limit_range.md>准入控制: 限制区间</a></p>
<p>名字空间可以处于下列两个阶段中的一个:</p>
<ul>
<li><code>Active</code> 名字空间正在被使用中</li>
<li><code>Terminating</code> 名字空间正在被删除，且不能被用于新对象。</li>
</ul>
<p>更多细节，参阅 API 参考中的<a href=/docs/reference/kubernetes-api/cluster-resources/namespace-v1/>命名空间</a>。</p>
<h2 id=创建名字空间>创建名字空间</h2>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 避免使用前缀 <code>kube-</code> 创建名字空间，因为它是为 Kubernetes 系统名字空间保留的。
</div>
<ol>
<li>
<p>新建一个名为 <code>my-namespace.yaml</code> 的 YAML 文件，并写入下列内容：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Namespace<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>&lt;insert-namespace-name-here&gt;<span style=color:#bbb>
</span></code></pre></div>
<p>然后运行：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create -f ./my-namespace.yaml
</code></pre></div></li>
</ol>
<ol start=2>
<li>
<p>或者，你可以使用下面的命令创建名字空间：</p>
<pre><code>kubectl create namespace &lt;insert-namespace-name-here&gt;
</code></pre></li>
</ol>
<p>请注意，名字空间的名称必须是一个合法的
<a href=/zh/docs/concepts/overview/working-with-objects/names#dns-label-names>DNS 标签</a>。</p>
<p>可选字段 <code>finalizers</code> 允许观察者们在名字空间被删除时清除资源。记住如果指定了一个不存在的终结器，名字空间仍会被创建，但如果用户试图删除它，它将陷入 <code>Terminating</code> 状态。</p>
<p>更多有关 <code>finalizers</code> 的信息请查阅 <a href=https://git.k8s.io/community/contributors/design-proposals/architecture/namespaces.md#finalizers>设计文档</a> 中名字空间部分。</p>
<h2 id=删除名字空间>删除名字空间</h2>
<p>删除名字空间使用命令：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete namespaces &lt;insert-some-namespace-name&gt;
</code></pre></div>
<div class="alert alert-danger warning callout" role=alert>
<strong>Warning:</strong> 这会删除名字空间下的 <em>所有内容</em> ！
</div>
<p>删除是异步的，所以有一段时间你会看到名字空间处于 <code>Terminating</code> 状态。</p>
<h2 id=使用-kubernetes-名字空间细分你的集群>使用 Kubernetes 名字空间细分你的集群</h2>
<ol>
<li>
<p>理解 default 名字空间</p>
<p>默认情况下，Kubernetes 集群会在配置集群时实例化一个 default 名字空间，用以存放集群所使用的默认
Pods、Services 和 Deployments 集合。</p>
<p>假设你有一个新的集群，你可以通过执行以下操作来内省可用的名字空间</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get namespaces
</code></pre></div><pre><code>NAME      STATUS    AGE
default   Active    13m
</code></pre></li>
</ol>
<ol start=2>
<li>
<p>创建新的名字空间</p>
<p>在本练习中，我们将创建两个额外的 Kubernetes 名字空间来保存我们的内容。</p>
<p>在某组织使用共享的 Kubernetes 集群进行开发和生产的场景中：</p>
<p>开发团队希望在集群中维护一个空间，以便他们可以查看用于构建和运行其应用程序的 Pods、Services
和 Deployments 列表。在这个空间里，Kubernetes 资源被自由地加入或移除，
对谁能够或不能修改资源的限制被放宽，以实现敏捷开发。</p>
<p>运维团队希望在集群中维护一个空间，以便他们可以强制实施一些严格的规程，
对谁可以或不可以操作运行生产站点的 Pods、Services 和 Deployments 集合进行控制。</p>
<p>该组织可以遵循的一种模式是将 Kubernetes 集群划分为两个名字空间：development 和 production。</p>
<p>让我们创建两个新的名字空间来保存我们的工作。</p>
<p>使用 kubectl 创建 <code>development</code> 名字空间。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create -f https://k8s.io/examples/admin/namespace-dev.json
</code></pre></div>
<p>让我们使用 kubectl 创建 <code>production</code> 名字空间。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create -f https://k8s.io/examples/admin/namespace-prod.json
</code></pre></div>
<p>为了确保一切正常，列出集群中的所有名字空间。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get namespaces --show-labels
</code></pre></div><pre><code>NAME          STATUS    AGE       LABELS
default       Active    32m       &lt;none&gt;
development   Active    29s       name=development
production    Active    23s       name=production
</code></pre></li>
</ol>
<ol start=3>
<li>
<p>在每个名字空间中创建 pod</p>
<p>Kubernetes 名字空间为集群中的 Pods、Services 和 Deployments 提供了作用域。</p>
<p>与一个名字空间交互的用户不会看到另一个名字空间中的内容。</p>
<p>为了演示这一点，让我们在 <code>development</code> 名字空间中启动一个简单的 Deployment 和 Pod。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create deployment snowflake --image<span style=color:#666>=</span>k8s.gcr.io/serve_hostname -n<span style=color:#666>=</span>development
kubectl scale deployment snowflake --replicas<span style=color:#666>=</span><span style=color:#666>2</span> -n<span style=color:#666>=</span>development
</code></pre></div>
<p>我们创建了一个副本个数为 2 的 Deployment，运行名为 <code>snowflake</code> 的
Pod，其中包含一个负责提供主机名的基本容器。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get deployment -n<span style=color:#666>=</span>development
</code></pre></div><pre><code>NAME         READY   UP-TO-DATE   AVAILABLE   AGE
snowflake    2/2     2            2           2m
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>snowflake -n<span style=color:#666>=</span>development
</code></pre></div><pre><code>NAME                         READY     STATUS    RESTARTS   AGE
snowflake-3968820950-9dgr8   1/1       Running   0          2m
snowflake-3968820950-vgc4n   1/1       Running   0          2m
</code></pre>
<p>看起来还不错，开发人员能够做他们想做的事，而且他们不必担心会影响到
<code>production</code> 名字空间下面的内容。</p>
<p>让我们切换到 <code>production</code> 名字空间，展示一下一个名字空间中的资源是如何对
另一个名字空间隐藏的。</p>
<p>名字空间 <code>production</code> 应该是空的，下面的命令应该不会返回任何东西。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get deployment -n<span style=color:#666>=</span>production
kubectl get pods -n<span style=color:#666>=</span>production
</code></pre></div>
<p>生产环境下一般以养牛的方式运行负载，所以让我们创建一些 Cattle（牛）Pod。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create deployment cattle --image<span style=color:#666>=</span>k8s.gcr.io/serve_hostname -n<span style=color:#666>=</span>production
kubectl scale deployment cattle --replicas<span style=color:#666>=</span><span style=color:#666>5</span> -n<span style=color:#666>=</span>production

kubectl get deployment -n<span style=color:#666>=</span>production
</code></pre></div><pre><code>NAME         READY   UP-TO-DATE   AVAILABLE   AGE
cattle       5/5     5            5           10s
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>cattle -n<span style=color:#666>=</span>production
</code></pre></div><pre><code>NAME                      READY     STATUS    RESTARTS   AGE
cattle-2263376956-41xy6   1/1       Running   0          34s
cattle-2263376956-kw466   1/1       Running   0          34s
cattle-2263376956-n4v97   1/1       Running   0          34s
cattle-2263376956-p5p3i   1/1       Running   0          34s
cattle-2263376956-sxpth   1/1       Running   0          34s
</code></pre></li>
</ol>
<p>此时，应该很清楚的展示了用户在一个名字空间中创建的资源对另一个名字空间是隐藏的。</p>
<p>随着 Kubernetes 中的策略支持的发展，我们将扩展此场景，以展示如何为每个名字空间提供不同的授权规则。</p>
<h2 id=理解使用名字空间的动机>理解使用名字空间的动机</h2>
<p>单个集群应该能满足多个用户及用户组的需求（以下称为 “用户社区”）。</p>
<p>Kubernetes <em>名字空间</em> 帮助不同的项目、团队或客户去共享 Kubernetes 集群。</p>
<p>名字空间通过以下方式实现这点：</p>
<ol>
<li>为<a href=/zh/docs/concepts/overview/working-with-objects/names/>名字</a>设置作用域.</li>
<li>为集群中的部分资源关联鉴权和策略的机制。</li>
</ol>
<p>使用多个名字空间是可选的。</p>
<p>每个用户社区都希望能够与其他社区隔离开展工作。</p>
<p>每个用户社区都有自己的：</p>
<ol>
<li>资源（pods、服务、 副本控制器等等）</li>
<li>策略（谁能或不能在他们的社区里执行操作）</li>
<li>约束（该社区允许多少配额，等等）</li>
</ol>
<p>集群运营者可以为每个唯一用户社区创建名字空间。</p>
<p>名字空间为下列内容提供唯一的作用域：</p>
<ol>
<li>命名资源（避免基本的命名冲突）</li>
<li>将管理权限委派给可信用户</li>
<li>限制社区资源消耗的能力</li>
</ol>
<p>用例包括:</p>
<ol>
<li>作为集群运营者, 我希望能在单个集群上支持多个用户社区。</li>
<li>作为集群运营者，我希望将集群分区的权限委派给这些社区中的受信任用户。</li>
<li>作为集群运营者，我希望能限定每个用户社区可使用的资源量，以限制对使用同一集群的其他用户社区的影响。</li>
<li>作为群集用户，我希望与我的用户社区相关的资源进行交互，而与其他用户社区在该集群上执行的操作无关。</li>
</ol>
<h2 id=理解名字空间和-dns>理解名字空间和 DNS</h2>
<p>当你创建<a href=/zh/docs/concepts/services-networking/service/>服务</a>时，Kubernetes
会创建相应的 <a href=/zh/docs/concepts/services-networking/dns-pod-service/>DNS 条目</a>。
此条目的格式为 <code>&lt;服务名称>.&lt;名字空间名称>.svc.cluster.local</code>。
这意味着如果容器使用 <code>&lt;服务名称></code>，它将解析为名字空间本地的服务。
这对于在多个名字空间（如开发、暂存和生产）中使用相同的配置非常有用。
如果要跨名字空间访问，则需要使用完全限定的域名（FQDN）。</p>
<h2 id=what-s-next>What's next</h2>
<ul>
<li>进一步了解<a href=/zh/docs/concepts/overview/working-with-objects/namespaces/#setting-the-namespace-preference>设置名字空间偏好</a></li>
<li>进一步了解<a href=/zh/docs/concepts/overview/working-with-objects/namespaces/#setting-the-namespace-for-a-request>设置请求的名字空间</a></li>
<li>参阅<a href=https://github.com/kubernetes/community/blob/master/contributors/design-proposals/architecture/namespaces.md>名字空间的设计文档</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-f58763cc9447491b6c40f939a02d441d>3.38 - 通过配置文件设置 Kubelet 参数</h1>
<p>通过保存在硬盘的配置文件设置 kubelet 的部分配置参数，这可以作为命令行参数的替代。</p>
<p>建议通过配置文件的方式提供参数，因为这样可以简化节点部署和配置管理。</p>
<h2 id=创建配置文件>创建配置文件</h2>
<p><a href=/zh/docs/reference/config-api/kubelet-config.v1beta1/><code>KubeletConfiguration</code></a> 结构体定义了可以通过文件配置的 Kubelet 配置子集，</p>
<p>配置文件必须是这个结构体中参数的 JSON 或 YAML 表现形式。
确保 kubelet 可以读取该文件。</p>
<p>下面是一个 Kubelet 配置文件示例：</p>
<pre><code>apiVersion: kubelet.config.k8s.io/v1beta1
kind: KubeletConfiguration
address: &quot;192.168.0.8&quot;,
port: 20250,
serializeImagePulls: false,
evictionHard:
    memory.available:  &quot;200Mi&quot;
</code></pre>
<p>在这个示例中, Kubelet 被设置为在地址 192.168.0.8 端口 20250 上提供服务，以并行方式拖拽镜像，
当可用内存低于 200Mi 时, kubelet 将会开始驱逐 Pods。
没有声明的其余配置项都将使用默认值，除非使用命令行参数来重载。
命令行中的参数将会覆盖配置文件中的对应值。</p>
<h2 id=启动通过配置文件配置的-kubelet-进程>启动通过配置文件配置的 Kubelet 进程</h2>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 如果你使用 kubeadm 初始化你的集群，在使用 <code>kubeadmin init</code> 创建你的集群的时候请使用 kubelet-config。
更多细节请阅读<a href=/zh/docs/setup/production-environment/tools/kubeadm/kubelet-integration/>使用 kubeadm 配置 kubelet</a>
</div>
<p>启动 Kubelet 需要将 <code>--config</code> 参数设置为 Kubelet 配置文件的路径。Kubelet 将从此文件加载其配置。</p>
<p>请注意，命令行参数与配置文件有相同的值时，就会覆盖配置文件中的该值。
这有助于确保命令行 API 的向后兼容性。</p>
<p>请注意，kubelet 配置文件中的相对文件路径是相对于 kubelet 配置文件的位置解析的，
而命令行参数中的相对路径是相对于 kubelet 的当前工作目录解析的。</p>
<p>请注意，命令行参数和 Kubelet 配置文件的某些默认值不同。
如果设置了 <code>--config</code>，并且没有通过命令行指定值，则 <code>KubeletConfiguration</code>
版本的默认值生效。在上面的例子中，version 是 <code>kubelet.config.k8s.io/v1beta1</code>。</p>
<h2 id=what-s-next>What's next</h2>
<ul>
<li>参阅 <a href=/zh/docs/reference/config-api/kubelet-config.v1beta1/><code>KubeletConfiguration</code></a>
进一步学习 kubelet 的配置。</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-5e59f5575dce11fdaed640afdbeedfc1>3.39 - 配置 API 对象配额</h1>
<p>本文讨论如何为 API 对象配置配额，包括 PersistentVolumeClaim 和 Service。
配额限制了可以在命名空间中创建的特定类型对象的数量。
你可以在 <a href=/docs/reference/generated/kubernetes-api/v1.23/#resourcequota-v1-core>ResourceQuota</a> 对象中指定配额。</p>
<h2 id=before-you-begin>Before you begin</h2>
<p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li>
</ul>
To check the version, enter <code>kubectl version</code>.
</p>
<h2 id=创建命名空间>创建命名空间</h2>
<p>创建一个命名空间以便本例中创建的资源和集群中的其余部分相隔离。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create namespace quota-object-example
</code></pre></div>
<h2 id=创建-resourcequota>创建 ResourceQuota</h2>
<p>下面是一个 ResourceQuota 对象的配置文件：</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/admin/resource/quota-objects.yaml download=admin/resource/quota-objects.yaml><code>admin/resource/quota-objects.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('admin-resource-quota-objects-yaml')" title="Copy admin/resource/quota-objects.yaml to clipboard">
</img>
</div>
<div class=includecode id=admin-resource-quota-objects-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ResourceQuota<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>object-quota-demo<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>hard</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>persistentvolumeclaims</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;1&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>services.loadbalancers</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>services.nodeports</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;0&#34;</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>创建 ResourceQuota：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/admin/resource/quota-objects.yaml --namespace<span style=color:#666>=</span>quota-object-example
</code></pre></div>
<p>查看 ResourceQuota 的详细信息：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get resourcequota object-quota-demo --namespace<span style=color:#666>=</span>quota-object-example --output<span style=color:#666>=</span>yaml
</code></pre></div>
<p>输出结果表明在 quota-object-example 命名空间中，至多只能有一个 PersistentVolumeClaim，
最多两个 LoadBalancer 类型的服务，不能有 NodePort 类型的服务。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>hard</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>persistentvolumeclaims</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;1&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>services.loadbalancers</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>services.nodeports</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;0&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>used</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>persistentvolumeclaims</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;0&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>services.loadbalancers</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;0&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>services.nodeports</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;0&#34;</span><span style=color:#bbb>
</span></code></pre></div>
<h2 id=创建-persistentvolumeclaim>创建 PersistentVolumeClaim</h2>
<p>下面是一个 PersistentVolumeClaim 对象的配置文件：</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/admin/resource/quota-objects-pvc.yaml download=admin/resource/quota-objects-pvc.yaml><code>admin/resource/quota-objects-pvc.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('admin-resource-quota-objects-pvc-yaml')" title="Copy admin/resource/quota-objects-pvc.yaml to clipboard">
</img>
</div>
<div class=includecode id=admin-resource-quota-objects-pvc-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolumeClaim<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pvc-quota-demo<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>storageClassName</span>:<span style=color:#bbb> </span>manual<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- ReadWriteOnce<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>3Gi<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>创建 PersistentVolumeClaim：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/admin/resource/quota-objects-pvc.yaml --namespace<span style=color:#666>=</span>quota-object-example
</code></pre></div>
<p>确认已创建完 PersistentVolumeClaim：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get persistentvolumeclaims --namespace<span style=color:#666>=</span>quota-object-example
</code></pre></div>
<p>输出信息表明 PersistentVolumeClaim 存在并且处于 Pending 状态：</p>
<pre><code>NAME             STATUS
pvc-quota-demo   Pending
</code></pre>
<h2 id=尝试创建第二个-persistentvolumeclaim>尝试创建第二个 PersistentVolumeClaim</h2>
<p>下面是第二个 PersistentVolumeClaim 的配置文件：</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/admin/resource/quota-objects-pvc-2.yaml download=admin/resource/quota-objects-pvc-2.yaml><code>admin/resource/quota-objects-pvc-2.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('admin-resource-quota-objects-pvc-2-yaml')" title="Copy admin/resource/quota-objects-pvc-2.yaml to clipboard">
</img>
</div>
<div class=includecode id=admin-resource-quota-objects-pvc-2-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolumeClaim<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pvc-quota-demo-2<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>storageClassName</span>:<span style=color:#bbb> </span>manual<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- ReadWriteOnce<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>4Gi<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>尝试创建第二个 PersistentVolumeClaim：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create -f https://k8s.io/examples/admin/resource/quota-objects-pvc-2.yaml --namespace<span style=color:#666>=</span>quota-object-example
</code></pre></div>
<p>输出信息表明第二个 PersistentVolumeClaim 没有创建成功，因为这会超出命名空间的配额。</p>
<pre><code>persistentvolumeclaims &quot;pvc-quota-demo-2&quot; is forbidden:
exceeded quota: object-quota-demo, requested: persistentvolumeclaims=1,
used: persistentvolumeclaims=1, limited: persistentvolumeclaims=1
</code></pre>
<h2 id=说明>说明</h2>
<p>下面这些字符串可被用来标识那些能被配额限制的 API 资源：</p>
<table>
<tr><th>字符串</th><th>API 对象</th></tr>
<tr><td>"pods"</td><td>Pod</td></tr>
<tr><td>"services"</td><td>Service</td></tr>
<tr><td>"replicationcontrollers"</td><td>ReplicationController</td></tr>
<tr><td>"resourcequotas"</td><td>ResourceQuota</td></tr>
<tr><td>"secrets"</td><td>Secret</td></tr>
<tr><td>"configmaps"</td><td>ConfigMap</td></tr>
<tr><td>"persistentvolumeclaims"</td><td>PersistentVolumeClaim</td></tr>
<tr><td>"services.nodeports"</td><td>NodePort 类型的 Service</td></tr>
<tr><td>"services.loadbalancers"</td><td>LoadBalancer 类型的 Service</td></tr>
</table>
<h2 id=清理>清理</h2>
<p>删除你的命名空间：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete namespace quota-object-example
</code></pre></div><h2 id=what-s-next>What's next</h2>
<h3 id=集群管理员参考>集群管理员参考</h3>
<ul>
<li><a href=/zh/docs/tasks/administer-cluster/manage-resources/memory-default-namespace/>为命名空间配置默认的内存请求和限制</a></li>
<li><a href=/zh/docs/tasks/administer-cluster/manage-resources/cpu-default-namespace/>为命名空间配置默认的 CPU 请求和限制</a></li>
<li><a href=/zh/docs/tasks/administer-cluster/manage-resources/memory-constraint-namespace/>为命名空间配置内存的最小和最大限制</a></li>
<li><a href=/zh/docs/tasks/administer-cluster/manage-resources/cpu-constraint-namespace/>为命名空间配置 CPU 的最小和最大限制</a></li>
<li><a href=/zh/docs/tasks/administer-cluster/manage-resources/quota-memory-cpu-namespace/>为命名空间配置 CPU 和内存配额</a></li>
<li><a href=/zh/docs/tasks/administer-cluster/manage-resources/quota-pod-namespace/>为命名空间配置 Pod 配额</a></li>
</ul>
<h3 id=应用开发者参考>应用开发者参考</h3>
<ul>
<li><a href=/zh/docs/tasks/configure-pod-container/assign-memory-resource/>为容器和 Pod 分配内存资源</a></li>
<li><a href=/zh/docs/tasks/configure-pod-container/assign-cpu-resource/>为容器和 Pod 分配 CPU 资源</a></li>
<li><a href=/zh/docs/tasks/configure-pod-container/quality-service-pod/>为 Pod 配置服务质量</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-a02f35804917d7a269c38d7e2c475005>3.40 - 限制存储消耗</h1>
<p>此示例演示了如何限制一个名字空间中的存储使用量。</p>
<p>演示中用到了以下资源：<a href=/zh/docs/concepts/policy/resource-quotas/>ResourceQuota</a>，
<a href=/zh/docs/tasks/administer-cluster/manage-resources/memory-default-namespace/>LimitRange</a> 和
<a href=/zh/docs/concepts/storage/persistent-volumes/>PersistentVolumeClaim</a>。</p>
<h2 id=before-you-begin>Before you begin</h2>
<ul>
<li><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li>
</ul>
To check the version, enter <code>kubectl version</code>.
</li>
</ul>
<h2 id=场景-限制存储消耗>场景：限制存储消耗</h2>
<p>集群管理员代表用户群操作集群，管理员希望控制单个名称空间可以消耗多少存储空间以控制成本。</p>
<p>管理员想要限制：</p>
<ol>
<li>名字空间中持久卷申领（persistent volume claims）的数量</li>
<li>每个申领（claim）可以请求的存储量</li>
<li>名字空间可以具有的累计存储量</li>
</ol>
<h2 id=使用-limitrange-限制存储请求>使用 LimitRange 限制存储请求</h2>
<p>将 <code>LimitRange</code> 添加到名字空间会为存储请求大小强制设置最小值和最大值。
存储是通过 <code>PersistentVolumeClaim</code> 来发起请求的。
执行限制范围控制的准入控制器会拒绝任何高于或低于管理员所设阈值的 PVC。</p>
<p>在此示例中，请求 10Gi 存储的 PVC 将被拒绝，因为它超过了最大 2Gi。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>LimitRange<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>storagelimits<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>PersistentVolumeClaim<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>max</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>2Gi<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>min</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>1Gi<span style=color:#bbb>
</span></code></pre></div>
<p>当底层存储提供程序需要某些最小值时，将会用到所设置最小存储请求值。
例如，AWS EBS volumes 的最低要求为 1Gi。</p>
<h2 id=使用-storagequota-限制-pvc-数目和累计存储容量>使用 StorageQuota 限制 PVC 数目和累计存储容量</h2>
<p>管理员可以限制某个名字空间中的 PVCs 个数以及这些 PVCs 的累计容量。
新 PVCs 请求如果超过任一上限值将被拒绝。</p>
<p>在此示例中，名字空间中的第 6 个 PVC 将被拒绝，因为它超过了最大计数 5。
或者，当与上面的 2Gi 最大容量限制结合在一起时，意味着 5Gi 的最大配额
不能支持 3 个都是 2Gi 的 PVC。
后者实际上是向名字空间请求 6Gi 容量，而该命令空间已经设置上限为 5Gi。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ResourceQuota<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>storagequota<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>hard</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>persistentvolumeclaims</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;5&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>requests.storage</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;5Gi&#34;</span><span style=color:#bbb>
</span></code></pre></div>
<h2 id=小结>小结</h2>
<p>限制范围对象可以用来设置可请求的存储量上限，而资源配额对象则可以通过申领计数和
累计存储容量有效地限制名字空间耗用的存储量。
这两种机制使得集群管理员能够规划其集群存储预算而不会发生任一项目超量分配的风险。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-6b4e7ca6586f448c8533a120c29bdd25>3.41 - 静态加密 Secret 数据</h1>
<p>本文展示如何启用和配置静态 Secret 数据的加密</p>
<h2 id=before-you-begin>Before you begin</h2>
<ul>
<li><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li>
</ul>
To check the version, enter <code>kubectl version</code>.
</li>
</ul>
<ul>
<li>需要 etcd v3 或者更高版本</li>
</ul>
<h2 id=配置并确定是否已启用静态数据加密>配置并确定是否已启用静态数据加密</h2>
<p><code>kube-apiserver</code> 的参数 <code>--experimental-encryption-provider-config</code> 控制 API 数据在 etcd 中的加密方式。
下面提供一个配置示例。</p>
<h2 id=理解静态数据加密>理解静态数据加密</h2>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apiserver.config.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>EncryptionConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- secrets<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>providers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>identity</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>aesgcm</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>keys</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>key1<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>secret</span>:<span style=color:#bbb> </span>c2VjcmV0IGlzIHNlY3VyZQ==<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>key2<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>secret</span>:<span style=color:#bbb> </span>dGhpcyBpcyBwYXNzd29yZA==<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>aescbc</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>keys</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>key1<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>secret</span>:<span style=color:#bbb> </span>c2VjcmV0IGlzIHNlY3VyZQ==<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>key2<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>secret</span>:<span style=color:#bbb> </span>dGhpcyBpcyBwYXNzd29yZA==<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>secretbox</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>keys</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>key1<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>secret</span>:<span style=color:#bbb> </span>YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY=<span style=color:#bbb>
</span></code></pre></div>
<p>每个 <code>resources</code> 数组项目是一个单独的完整的配置。
<code>resources.resources</code> 字段是要加密的 Kubernetes 资源名称（<code>resource</code> 或 <code>resource.group</code>）的数组。
<code>providers</code> 数组是可能的加密 provider 的有序列表。
每个条目只能指定一个 provider 类型（可以是 <code>identity</code> 或 <code>aescbc</code>，但不能在同一个项目中同时指定）。</p>
<p>列表中的第一个 provider 用于加密进入存储的资源。
当从存储器读取资源时，与存储的数据匹配的所有 provider 将按顺序尝试解密数据。
如果由于格式或密钥不匹配而导致没有 provider 能够读取存储的数据，则会返回一个错误，以防止客户端访问该资源。</p>
<div class="alert alert-warning caution callout" role=alert>
<strong>Caution:</strong> <strong>重要：</strong> 如果通过加密配置无法读取资源（因为密钥已更改），唯一的方法是直接从底层 etcd 中删除该密钥。
任何尝试读取资源的调用将会失败，直到它被删除或提供有效的解密密钥。
</div>
<h3 id=providers>Providers:</h3>
<table><caption style=display:none>Kubernetes 静态数据加密的 Providers</caption>
<thead>
<tr>
<th>名称</th>
<th>加密类型</th>
<th>强度</th>
<th>速度</th>
<th>密钥长度</th>
<th>其它事项</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>identity</code></td>
<td>无</td>
<td>N/A</td>
<td>N/A</td>
<td>N/A</td>
<td>不加密写入的资源。当设置为第一个 provider 时，资源将在新值写入时被解密。</td>
</tr>
<tr>
<td><code>secretbox</code></td>
<td>XSalsa20 和 Poly1305</td>
<td>强</td>
<td>更快</td>
<td>32字节</td>
<td>较新的标准，在需要高度评审的环境中可能不被接受。</td>
</tr>
<tr>
<td><code>aesgcm</code></td>
<td>带有随机数的 AES-GCM</td>
<td>必须每 200k 写入一次</td>
<td>最快</td>
<td>16, 24 或者 32字节</td>
<td>建议不要使用，除非实施了自动密钥循环方案。</td>
</tr>
<tr>
<td><code>aescbc</code></td>
<td>填充 PKCS#7 的 AES-CBC</td>
<td>弱</td>
<td>快</td>
<td>32字节</td>
<td>由于 CBC 容易受到密文填塞攻击（Padding Oracle Attack），不推荐使用。</td>
</tr>
<tr>
<td><code>kms</code></td>
<td>使用信封加密方案：数据使用带有 PKCS#7 填充的 AES-CBC 通过数据加密密钥（DEK）加密，DEK 根据 Key Management Service（KMS）中的配置通过密钥加密密钥（Key Encryption Keys，KEK）加密</td>
<td>最强</td>
<td>快</td>
<td>32字节</td>
<td>建议使用第三方工具进行密钥管理。为每个加密生成新的 DEK，并由用户控制 KEK 轮换来简化密钥轮换。<a href=/zh/docs/tasks/administer-cluster/kms-provider/>配置 KMS 提供程序</a></td>
</tr>
</tbody>
</table>
<p>每个 provider 都支持多个密钥 - 在解密时会按顺序使用密钥，如果是第一个 provider，则第一个密钥用于加密。</p>
<p><strong>在 EncryptionConfig 中保存原始的加密密钥与不加密相比只会略微地提升安全级别。
请使用 <code>kms</code> 驱动以获得更强的安全性。</strong>
默认情况下，<code>identity</code> 驱动被用来对 etcd 中的 Secret 提供保护，
而这个驱动不提供加密能力。
<code>EncryptionConfiguration</code> 的引入是为了能够使用本地管理的密钥来在本地加密 Secret 数据。</p>
<p>使用本地管理的密钥来加密 Secret 能够保护数据免受 etcd 破坏的影响，不过无法针对
主机被侵入提供防护。
这是因为加密的密钥保存在主机上的 EncryptionConfig YAML 文件中，有经验的入侵者
仍能访问该文件并从中提取出加密密钥。</p>
<p>封套加密（Envelope Encryption）引入了对独立密钥的依赖，而这个密钥并不保存在 Kubernetes 中。
在这种情况下下，入侵者需要攻破 etcd、kube-apiserver 和第三方的 KMS
驱动才能获得明文数据，因而这种方案提供了比本地保存加密密钥更高的安全级别。</p>
<h2 id=加密你的数据>加密你的数据</h2>
<p>创建一个新的加密配置文件：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apiserver.config.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>EncryptionConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- secrets<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>providers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>aescbc</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>keys</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>key1<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>secret</span>:<span style=color:#bbb> </span>&lt;BASE 64 ENCODED SECRET&gt;<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>identity</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span></code></pre></div>
<p>遵循如下步骤来创建一个新的 secret：</p>
<ol>
<li>
<p>生成一个 32 字节的随机密钥并进行 base64 编码。如果你在 Linux 或 Mac OS X 上，请运行以下命令：</p>
<pre><code>head -c 32 /dev/urandom | base64
</code></pre></li>
</ol>
<ol start=2>
<li>将这个值放入到 secret 字段中。</li>
<li>设置 <code>kube-apiserver</code> 的 <code>--experimental-encryption-provider-config</code> 参数，将其指向
配置文件所在位置。</li>
<li>重启你的 API server。</li>
</ol>
<div class="alert alert-warning caution callout" role=alert>
<strong>Caution:</strong> 你的配置文件包含可以解密 etcd 内容的密钥，因此你必须正确限制主控节点的访问权限，
以便只有能运行 kube-apiserver 的用户才能读取它。
</div>
<h2 id=验证数据已被加密>验证数据已被加密</h2>
<p>数据在写入 etcd 时会被加密。重新启动你的 <code>kube-apiserver</code> 后，任何新创建或更新的密码在存储时都应该被加密。
如果想要检查，你可以使用 <code>etcdctl</code> 命令行程序来检索你的加密内容。</p>
<ol>
<li>
<p>创建一个新的 secret，名称为 <code>secret1</code>，命名空间为 <code>default</code>：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create secret generic secret1 -n default --from-literal<span style=color:#666>=</span><span style=color:#b8860b>mykey</span><span style=color:#666>=</span>mydata
</code></pre></div></li>
</ol>
<ol start=2>
<li>
<p>使用 etcdctl 命令行，从 etcd 中读取 secret：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#b8860b>ETCDCTL_API</span><span style=color:#666>=</span><span style=color:#666>3</span> etcdctl get /registry/secrets/default/secret1 <span style=color:#666>[</span>...<span style=color:#666>]</span> | hexdump -C
</code></pre></div>
<p>这里的 <code>[...]</code> 是用来连接 etcd 服务的额外参数。</p>
</li>
</ol>
<ol start=3>
<li>
<p>验证存储的密钥前缀是否为 <code>k8s:enc:aescbc:v1:</code>，这表明 <code>aescbc</code> provider 已加密结果数据。</p>
</li>
<li>
<p>通过 API 检索，验证 secret 是否被正确解密：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe secret secret1 -n default
</code></pre></div>
<p>其输出应该是 <code>mykey: bXlkYXRh</code>，<code>mydata</code> 数据是被加密过的，请参阅
<a href=/zh/docs/tasks/configmap-secret/managing-secret-using-kubectl/#decoding-secret>解密 Secret</a>
了解如何完全解码 Secret 内容。</p>
</li>
</ol>
<h2 id=确保所有-secret-都被加密>确保所有 Secret 都被加密</h2>
<p>由于 Secret 是在写入时被加密，因此对 Secret 执行更新也会加密该内容。</p>
<pre><code>kubectl get secrets --all-namespaces -o json | kubectl replace -f -
</code></pre>
<p>上面的命令读取所有 Secret，然后使用服务端加密来更新其内容。</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 如果由于冲突写入而发生错误，请重试该命令。
对于较大的集群，你可能希望通过命名空间或更新脚本来对 Secret 进行划分。
</div>
<h2 id=轮换解密密钥>轮换解密密钥</h2>
<p>在不发生停机的情况下更改 Secret 需要多步操作，特别是在有多个 <code>kube-apiserver</code> 进程正在运行的
高可用环境中。</p>
<ol>
<li>生成一个新密钥并将其添加为所有服务器上当前提供程序的第二个密钥条目</li>
<li>重新启动所有 <code>kube-apiserver</code> 进程以确保每台服务器都可以使用新密钥进行解密</li>
<li>将新密钥设置为 <code>keys</code> 数组中的第一个条目，以便在配置中使用其进行加密</li>
<li>重新启动所有 <code>kube-apiserver</code> 进程以确保每个服务器现在都使用新密钥进行加密</li>
<li>运行 <code>kubectl get secrets --all-namespaces -o json | kubectl replace -f -</code> 以用新密钥加密所有现有的秘密</li>
<li>在使用新密钥备份 etcd 后，从配置中删除旧的解密密钥并更新所有密钥</li>
</ol>
<p>如果只有一个 <code>kube-apiserver</code>，第 2 步可能可以忽略。</p>
<h2 id=解密所有数据>解密所有数据</h2>
<p>要禁用 rest 加密，请将 <code>identity</code> provider 作为配置中的第一个条目：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apiserver.config.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>EncryptionConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- secrets<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>providers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>identity</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>aescbc</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>keys</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>key1<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>secret</span>:<span style=color:#bbb> </span>&lt;BASE 64 ENCODED SECRET&gt;<span style=color:#bbb>
</span></code></pre></div>
<p>并重新启动所有 <code>kube-apiserver</code> 进程。然后运行：</p>
<pre><code>kubectl get secrets -all-namespaces -o json | kubectl replace -f -`
</code></pre>
<p>以强制解密所有 secret。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-20165c8269bed123bfb94fb6e7f85643>4 - 节点健康监测</h1>
<p><em>节点问题检测器（Node Problem Detector）</em> 是一个守护程序，用于监视和报告节点的健康状况。
你可以将节点问题探测器以 <code>DaemonSet</code> 或独立守护程序运行。
节点问题检测器从各种守护进程收集节点问题，并以
<a href=/zh/docs/concepts/architecture/nodes/#condition>NodeCondition</a> 和
<a href=/docs/reference/generated/kubernetes-api/v1.23/#event-v1-core>Event</a>
的形式报告给 API 服务器。</p>
<p>要了解如何安装和使用节点问题检测器，请参阅
<a href=https://github.com/kubernetes/node-problem-detector>节点问题探测器项目文档</a>。</p>
<h2 id=before-you-begin>Before you begin</h2>
<p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li>
</ul>
<h2 id=limitations>局限性 </h2>
<ul>
<li>节点问题检测器只支持基于文件类型的内核日志。
它不支持像 journald 这样的命令行日志工具。</li>
<li>节点问题检测器使用内核日志格式来报告内核问题。
要了解如何扩展内核日志格式，请参阅<a href=#support-other-log-format>添加对另一个日志格式的支持</a>。</li>
</ul>
<h2 id=启用节点问题检测器>启用节点问题检测器</h2>
<p>一些云供应商将节点问题检测器以<a class=glossary-tooltip title="扩展 Kubernetes 功能的资源。" data-toggle=tooltip data-placement=top href=/zh/docs/concepts/cluster-administration/addons/ target=_blank aria-label=插件>插件</a>形式启用。
你还可以使用 <code>kubectl</code> 或创建插件 Pod 来启用节点问题探测器。</p>
<h2 id=using-kubectl>使用 kubectl 启用节点问题检测器</h2>
<p><code>kubectl</code> 提供了节点问题探测器最灵活的管理。
你可以覆盖默认配置使其适合你的环境或检测自定义节点问题。例如：</p>
<ol>
<li>
<p>创建类似于 <code>node-strought-detector.yaml</code> 的节点问题检测器配置：
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/debug/node-problem-detector.yaml download=debug/node-problem-detector.yaml><code>debug/node-problem-detector.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('debug-node-problem-detector-yaml')" title="Copy debug/node-problem-detector.yaml to clipboard">
</img>
</div>
<div class=includecode id=debug-node-problem-detector-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>DaemonSet<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>node-problem-detector-v0.1<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>kube-system<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>k8s-app</span>:<span style=color:#bbb> </span>node-problem-detector<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>version</span>:<span style=color:#bbb> </span>v0.1<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubernetes.io/cluster-service</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>k8s-app</span>:<span style=color:#bbb> </span>node-problem-detector  <span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>version</span>:<span style=color:#bbb> </span>v0.1<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>kubernetes.io/cluster-service</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>k8s-app</span>:<span style=color:#bbb> </span>node-problem-detector<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>version</span>:<span style=color:#bbb> </span>v0.1<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>kubernetes.io/cluster-service</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>hostNetwork</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>node-problem-detector<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/node-problem-detector:v0.1<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>securityContext</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>privileged</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;200m&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;100Mi&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;20m&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;20Mi&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>log<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/log<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>log<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>hostPath</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/var/log/</code></pre></div>
</div>
</div>
</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 你应该检查系统日志目录是否适用于操作系统发行版本。
</div>
</li>
<li>
<p>使用 <code>kubectl</code> 启动节点问题检测器：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/debug/node-problem-detector.yaml
</code></pre></div></li>
</ol>
<h3 id=using-addon-pod>使用插件 pod 启用节点问题检测器</h3>
<p>如果你使用的是自定义集群引导解决方案，不需要覆盖默认配置，
可以利用插件 Pod 进一步自动化部署。</p>
<p>创建 <code>node-strick-detector.yaml</code>，并在控制平面节点上保存配置到插件 Pod 的目录
<code>/etc/kubernetes/addons/node-problem-detector</code>。</p>
<h2 id=覆盖配置文件>覆盖配置文件</h2>
<p>构建节点问题检测器的 docker 镜像时，会嵌入
<a href=https://github.com/kubernetes/node-problem-detector/tree/v0.1/config>默认配置</a>。</p>
<p>不过，你可以像下面这样使用 <a href=/zh/docs/tasks/configure-pod-container/configure-pod-configmap/><code>ConfigMap</code></a>
将其覆盖：</p>
<ol>
<li>
<p>更改 <code>config/</code> 中的配置文件</p>
</li>
<li>
<p>创建 <code>ConfigMap</code> <code>node-strick-detector-config</code>：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create configmap node-problem-detector-config --from-file<span style=color:#666>=</span>config/
</code></pre></div></li>
<li>
<p>更改 <code>node-problem-detector.yaml</code> 以使用 ConfigMap:</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/debug/node-problem-detector-configmap.yaml download=debug/node-problem-detector-configmap.yaml><code>debug/node-problem-detector-configmap.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('debug-node-problem-detector-configmap-yaml')" title="Copy debug/node-problem-detector-configmap.yaml to clipboard">
</img>
</div>
<div class=includecode id=debug-node-problem-detector-configmap-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>DaemonSet<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>node-problem-detector-v0.1<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>kube-system<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>k8s-app</span>:<span style=color:#bbb> </span>node-problem-detector<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>version</span>:<span style=color:#bbb> </span>v0.1<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubernetes.io/cluster-service</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>k8s-app</span>:<span style=color:#bbb> </span>node-problem-detector  <span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>version</span>:<span style=color:#bbb> </span>v0.1<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>kubernetes.io/cluster-service</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>k8s-app</span>:<span style=color:#bbb> </span>node-problem-detector<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>version</span>:<span style=color:#bbb> </span>v0.1<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>kubernetes.io/cluster-service</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>hostNetwork</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>node-problem-detector<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/node-problem-detector:v0.1<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>securityContext</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>privileged</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;200m&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;100Mi&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;20m&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;20Mi&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>log<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/log<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>config<span style=color:#bbb> </span><span style=color:#080;font-style:italic># Overwrite the config/ directory with ConfigMap volume</span><span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/config<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>log<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>hostPath</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/var/log/<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>config<span style=color:#bbb> </span><span style=color:#080;font-style:italic># Define ConfigMap volume</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>configMap</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>node-problem-detector-config</code></pre></div>
</div>
</div>
</li>
<li>
<p>使用新的配置文件重新创建节点问题检测器：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># 如果你正在运行节点问题检测器，请先删除，然后再重新创建</span>
kubectl delete -f https://k8s.io/examples/debug/node-problem-detector.yaml
kubectl apply -f https://k8s.io/examples/debug/node-problem-detector-configmap.yaml
</code></pre></div></li>
</ol>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 此方法仅适用于通过 <code>kubectl</code> 启动的节点问题检测器。
</div>
<p>如果节点问题检测器作为集群插件运行，则不支持覆盖配置。
插件管理器不支持 <code>ConfigMap</code>。</p>
<h2 id=内核监视器>内核监视器</h2>
<p><em>内核监视器（Kernel Monitor）</em> 是节点问题检测器中支持的系统日志监视器守护进程。
内核监视器观察内核日志并根据预定义规则检测已知的内核问题。</p>
<p>内核监视器根据 <a href=https://github.com/kubernetes/node-problem-detector/blob/v0.1/config/kernel-monitor.json><code>config/kernel-monitor.json</code></a>
中的一组预定义规则列表匹配内核问题。
规则列表是可扩展的，你始终可以通过覆盖配置来扩展它。</p>
<h3 id=添加新的-nodecondition>添加新的 NodeCondition</h3>
<p>要支持新的 <code>NodeCondition</code>，请在 <code>config/kernel-monitor.json</code> 中的
<code>conditions</code> 字段中创建一个条件定义：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
  <span style=color:green;font-weight:700>&#34;type&#34;</span>: <span style=color:#b44>&#34;NodeConditionType&#34;</span>,
  <span style=color:green;font-weight:700>&#34;reason&#34;</span>: <span style=color:#b44>&#34;CamelCaseDefaultNodeConditionReason&#34;</span>,
  <span style=color:green;font-weight:700>&#34;message&#34;</span>: <span style=color:#b44>&#34;arbitrary default node condition message&#34;</span>
}
</code></pre></div>
<h3 id=检测新的问题>检测新的问题</h3>
<p>你可以使用新的规则描述来扩展 <code>config/kernel-monitor.json</code> 中的 <code>rules</code> 字段以检测新问题：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
  <span style=color:green;font-weight:700>&#34;type&#34;</span>: <span style=color:#b44>&#34;temporary/permanent&#34;</span>,
  <span style=color:green;font-weight:700>&#34;condition&#34;</span>: <span style=color:#b44>&#34;NodeConditionOfPermanentIssue&#34;</span>,
  <span style=color:green;font-weight:700>&#34;reason&#34;</span>: <span style=color:#b44>&#34;CamelCaseShortReason&#34;</span>,
  <span style=color:green;font-weight:700>&#34;message&#34;</span>: <span style=color:#b44>&#34;regexp matching the issue in the kernel log&#34;</span>
}
</code></pre></div>
<h3 id=kernel-log-device-path>配置内核日志设备的路径</h3>
<p>检查你的操作系统（OS）发行版本中的内核日志路径位置。
Linux 内核<a href=https://www.kernel.org/doc/documentation/abi/testing/dev-kmsg>日志设备</a>
通常呈现为 <code>/dev/kmsg</code>。
但是，日志路径位置因 OS 发行版本而异。
<code>config/kernel-monitor.json</code> 中的 <code>log</code> 字段表示容器内的日志路径。
你可以配置 <code>log</code> 字段以匹配节点问题检测器所示的设备路径。</p>
<h3 id=support-other-log-format>添加对其它日志格式的支持 </h3>
<p>内核监视器使用
<a href=https://github.com/kubernetes/node-problem-detector/blob/v0.1/pkg/kernelmonitor/translator.go><code>Translator</code></a>
插件转换内核日志的内部数据结构。
你可以为新的日志格式实现新的转换器。</p>
<h2 id=建议和限制>建议和限制</h2>
<p>建议在集群中运行节点问题检测器以监控节点运行状况。
运行节点问题检测器时，你可以预期每个节点上的额外资源开销。
通常这是可接受的，因为：</p>
<ul>
<li>内核日志增长相对缓慢。</li>
<li>已经为节点问题检测器设置了资源限制。</li>
<li>即使在高负载下，资源使用也是可接受的。有关更多信息，请参阅节点问题检测器
<a href=https://github.com/kubernetes/node-problem-detector/issues/2.suecomment-220255629>基准结果</a>。</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-f5da33b976758a9183018c421eb83f58>5 - 配置 Pods 和容器</h1>
<div class=lead>对 Pod 和容器执行常见的配置任务。</div>
</div>
<div class=td-content>
<h1 id=pg-e6dd9300cf3a955f7cdfe77fb5d15292>5.1 - 为容器和 Pod 分配内存资源</h1>
<p>此页面展示如何将内存 <em>请求</em> （request）和内存 <em>限制</em> （limit）分配给一个容器。
我们保障容器拥有它请求数量的内存，但不允许使用超过限制数量的内存。</p>
<h2 id=before-you-begin>Before you begin</h2>
<p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li>
</ul>
To check the version, enter <code>kubectl version</code>.
</p>
<p>你集群中的每个节点必须拥有至少 300 MiB 的内存。</p>
<p>该页面上的一些步骤要求你在集群中运行
<a href=https://github.com/kubernetes-sigs/metrics-server>metrics-server</a> 服务。
如果你已经有在运行中的 metrics-server，则可以跳过这些步骤。</p>
<p>如果你运行的是 Minikube，可以运行下面的命令启用 metrics-server：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>minikube addons <span style=color:#a2f>enable</span> metrics-server
</code></pre></div>
<p>要查看 metrics-server 或资源指标 API (<code>metrics.k8s.io</code>) 是否已经运行，请运行以下命令：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get apiservices
</code></pre></div>
<p>如果资源指标 API 可用，则输出结果将包含对 <code>metrics.k8s.io</code> 的引用信息。</p>
<pre><code>NAME
v1beta1.metrics.k8s.io
</code></pre>
<h2 id=创建命名空间>创建命名空间</h2>
<p>创建一个命名空间，以便将本练习中创建的资源与集群的其余部分隔离。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create namespace mem-example
</code></pre></div>
<h2 id=指定内存请求和限制>指定内存请求和限制</h2>
<p>要为容器指定内存请求，请在容器资源清单中包含 <code>resources：requests</code> 字段。
同理，要指定内存限制，请包含 <code>resources：limits</code>。</p>
<p>在本练习中，你将创建一个拥有一个容器的 Pod。
容器将会请求 100 MiB 内存，并且内存会被限制在 200 MiB 以内。
这是 Pod 的配置文件：</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/pods/resource/memory-request-limit.yaml download=pods/resource/memory-request-limit.yaml><code>pods/resource/memory-request-limit.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-resource-memory-request-limit-yaml')" title="Copy pods/resource/memory-request-limit.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-resource-memory-request-limit-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>memory-demo<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>mem-example<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>memory-demo-ctr<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>polinux/stress<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;100Mi&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;200Mi&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;stress&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;--vm&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;1&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;--vm-bytes&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;150M&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;--vm-hang&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;1&#34;</span>]<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>配置文件的 <code>args</code> 部分提供了容器启动时的参数。
<code>"--vm-bytes", "150M"</code> 参数告知容器尝试分配 150 MiB 内存。</p>
<p>开始创建 Pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/pods/resource/memory-request-limit.yaml --namespace<span style=color:#666>=</span>mem-example
</code></pre></div>
<p>验证 Pod 中的容器是否已运行：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod memory-demo --namespace<span style=color:#666>=</span>mem-example
</code></pre></div>
<p>查看 Pod 相关的详细信息：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod memory-demo --output<span style=color:#666>=</span>yaml --namespace<span style=color:#666>=</span>mem-example
</code></pre></div>
<p>输出结果显示：该 Pod 中容器的内存请求为 100 MiB，内存限制为 200 MiB。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>100Mi<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>200Mi<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></code></pre></div>
<p>运行 <code>kubectl top</code> 命令，获取该 Pod 的指标数据：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl top pod memory-demo --namespace<span style=color:#666>=</span>mem-example
</code></pre></div>
<p>输出结果显示：Pod 正在使用的内存大约为 162,900,000 字节，约为 150 MiB。
这大于 Pod 请求的 100 MiB，但在 Pod 限制的 200 MiB之内。</p>
<pre><code>NAME                        CPU(cores)   MEMORY(bytes)
memory-demo                 &lt;something&gt;  162856960
</code></pre>
<p>删除 Pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete pod memory-demo --namespace<span style=color:#666>=</span>mem-example
</code></pre></div>
<h2 id=超过容器限制的内存>超过容器限制的内存</h2>
<p>当节点拥有足够的可用内存时，容器可以使用其请求的内存。
但是，容器不允许使用超过其限制的内存。
如果容器分配的内存超过其限制，该容器会成为被终止的候选容器。
如果容器继续消耗超出其限制的内存，则终止容器。
如果终止的容器可以被重启，则 kubelet 会重新启动它，就像其他任何类型的运行时失败一样。</p>
<p>在本练习中，你将创建一个 Pod，尝试分配超出其限制的内存。
这是一个 Pod 的配置文件，其拥有一个容器，该容器的内存请求为 50 MiB，内存限制为 100 MiB：</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/pods/resource/memory-request-limit-2.yaml download=pods/resource/memory-request-limit-2.yaml><code>pods/resource/memory-request-limit-2.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-resource-memory-request-limit-2-yaml')" title="Copy pods/resource/memory-request-limit-2.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-resource-memory-request-limit-2-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>memory-demo-2<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>mem-example<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>memory-demo-2-ctr<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>polinux/stress<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;50Mi&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;100Mi&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;stress&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;--vm&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;1&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;--vm-bytes&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;250M&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;--vm-hang&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;1&#34;</span>]<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>在配置文件的 <code>args</code> 部分中，你可以看到容器会尝试分配 250 MiB 内存，这远高于 100 MiB 的限制。</p>
<p>创建 Pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/pods/resource/memory-request-limit-2.yaml --namespace<span style=color:#666>=</span>mem-example
</code></pre></div>
<p>查看 Pod 相关的详细信息：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod memory-demo-2 --namespace<span style=color:#666>=</span>mem-example
</code></pre></div>
<p>此时，容器可能正在运行或被杀死。重复前面的命令，直到容器被杀掉：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>NAME            READY     STATUS      RESTARTS   AGE
memory-demo-2   0/1       OOMKilled   <span style=color:#666>1</span>          24s
</code></pre></div>
<p>获取容器更详细的状态信息：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod memory-demo-2 --output<span style=color:#666>=</span>yaml --namespace<span style=color:#666>=</span>mem-example
</code></pre></div>
<p>输出结果显示：由于内存溢出（OOM），容器已被杀掉：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>lastState:
   terminated:
     containerID: 65183c1877aaec2e8427bc95609cc52677a454b56fcb24340dbd22917c23b10f
     exitCode: <span style=color:#666>137</span>
     finishedAt: 2017-06-20T20:52:19Z
     reason: OOMKilled
     startedAt: null
</code></pre></div>
<p>本练习中的容器可以被重启，所以 kubelet 会重启它。
多次运行下面的命令，可以看到容器在反复的被杀死和重启：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod memory-demo-2 --namespace<span style=color:#666>=</span>mem-example
</code></pre></div>
<p>输出结果显示：容器被杀掉、重启、再杀掉、再重启……：</p>
<pre><code>kubectl get pod memory-demo-2 --namespace=mem-example
NAME            READY     STATUS      RESTARTS   AGE
memory-demo-2   0/1       OOMKilled   1          37s
</code></pre><pre><code>
kubectl get pod memory-demo-2 --namespace=mem-example
NAME            READY     STATUS    RESTARTS   AGE
memory-demo-2   1/1       Running   2          40s
</code></pre>
<p>查看关于该 Pod 历史的详细信息：</p>
<pre><code>kubectl describe pod memory-demo-2 --namespace=mem-example
</code></pre>
<p>输出结果显示：该容器反复的在启动和失败：</p>
<pre><code>... Normal  Created   Created container with id 66a3a20aa7980e61be4922780bf9d24d1a1d8b7395c09861225b0eba1b1f8511
... Warning BackOff   Back-off restarting failed container
</code></pre>
<p>查看关于集群节点的详细信息：</p>
<pre><code>kubectl describe nodes
</code></pre>
<p>输出结果包含了一条练习中的容器由于内存溢出而被杀掉的记录：</p>
<pre><code>Warning OOMKilling Memory cgroup out of memory: Kill process 4481 (stress) score 1994 or sacrifice child
</code></pre>
<p>删除 Pod:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete pod memory-demo-2 --namespace<span style=color:#666>=</span>mem-example
</code></pre></div>
<h2 id=超过整个节点容量的内存>超过整个节点容量的内存</h2>
<p>内存请求和限制是与容器关联的，但将 Pod 视为具有内存请求和限制，也是很有用的。
Pod 的内存请求是 Pod 中所有容器的内存请求之和。
同理，Pod 的内存限制是 Pod 中所有容器的内存限制之和。</p>
<p>Pod 的调度基于请求。只有当节点拥有足够满足 Pod 内存请求的内存时，才会将 Pod 调度至节点上运行。</p>
<p>在本练习中，你将创建一个 Pod，其内存请求超过了你集群中的任意一个节点所拥有的内存。
这是该 Pod 的配置文件，其拥有一个请求 1000 GiB 内存的容器，这应该超过了你集群中任何节点的容量。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/pods/resource/memory-request-limit-3.yaml download=pods/resource/memory-request-limit-3.yaml><code>pods/resource/memory-request-limit-3.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-resource-memory-request-limit-3-yaml')" title="Copy pods/resource/memory-request-limit-3.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-resource-memory-request-limit-3-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>memory-demo-3<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>mem-example<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>memory-demo-3-ctr<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>polinux/stress<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;1000Gi&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;1000Gi&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;stress&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;--vm&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;1&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;--vm-bytes&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;150M&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;--vm-hang&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;1&#34;</span>]<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>创建 Pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/pods/resource/memory-request-limit-3.yaml --namespace<span style=color:#666>=</span>mem-example
</code></pre></div>
<p>查看 Pod 状态：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod memory-demo-3 --namespace<span style=color:#666>=</span>mem-example
</code></pre></div>
<p>输出结果显示：Pod 处于 PENDING 状态。
这意味着，该 Pod 没有被调度至任何节点上运行，并且它会无限期的保持该状态：</p>
<pre><code>kubectl get pod memory-demo-3 --namespace=mem-example
NAME            READY     STATUS    RESTARTS   AGE
memory-demo-3   0/1       Pending   0          25s
</code></pre>
<p>查看关于 Pod 的详细信息，包括事件：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe pod memory-demo-3 --namespace<span style=color:#666>=</span>mem-example
</code></pre></div>
<p>输出结果显示：由于节点内存不足，该容器无法被调度：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>Events:
  ...  Reason            Message
       ------            -------
  ...  FailedScheduling  No nodes are available that match all of the following predicates:: Insufficient memory <span style=color:#666>(</span>3<span style=color:#666>)</span>.
</code></pre></div>
<h2 id=内存单位>内存单位</h2>
<p>内存资源的基本单位是字节（byte）。你可以使用这些后缀之一，将内存表示为
纯整数或定点整数：E、P、T、G、M、K、Ei、Pi、Ti、Gi、Mi、Ki。
例如，下面是一些近似相同的值：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>128974848, 129e6, 129M , 123Mi
</code></pre></div>
<p>删除 Pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete pod memory-demo-3 --namespace<span style=color:#666>=</span>mem-example
</code></pre></div>
<h2 id=如果你没有指定内存限制>如果你没有指定内存限制</h2>
<p>如果你没有为一个容器指定内存限制，则自动遵循以下情况之一：</p>
<ul>
<li>
<p>容器可无限制地使用内存。容器可以使用其所在节点所有的可用内存，
进而可能导致该节点调用 OOM Killer。
此外，如果发生 OOM Kill，没有资源限制的容器将被杀掉的可行性更大。</p>
</li>
<li>
<p>运行的容器所在命名空间有默认的内存限制，那么该容器会被自动分配默认限制。
集群管理员可用使用 <a href=/docs/reference/generated/kubernetes-api/v1.23/#limitrange-v1-core>LimitRange</a>
来指定默认的内存限制。</p>
</li>
</ul>
<h2 id=内存请求和限制的目的>内存请求和限制的目的</h2>
<p>通过为集群中运行的容器配置内存请求和限制，你可以有效利用集群节点上可用的内存资源。
通过将 Pod 的内存请求保持在较低水平，你可以更好地安排 Pod 调度。
通过让内存限制大于内存请求，你可以完成两件事：</p>
<ul>
<li>Pod 可以进行一些突发活动，从而更好的利用可用内存。</li>
<li>Pod 在突发活动期间，可使用的内存被限制为合理的数量。</li>
</ul>
<h2 id=清理>清理</h2>
<p>删除命名空间。下面的命令会删除你根据这个任务创建的所有 Pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete namespace mem-example
</code></pre></div><h2 id=what-s-next>What's next</h2>
<h3 id=应用开发者扩展阅读>应用开发者扩展阅读</h3>
<ul>
<li>
<p><a href=/zh/docs/tasks/configure-pod-container/assign-cpu-resource/>为容器和 Pod 分配 CPU 资源</a></p>
</li>
<li>
<p><a href=/zh/docs/tasks/configure-pod-container/quality-service-pod/>配置 Pod 的服务质量</a></p>
</li>
</ul>
<h3 id=集群管理员扩展阅读>集群管理员扩展阅读</h3>
<ul>
<li><a href=/zh/docs/tasks/administer-cluster/manage-resources/memory-default-namespace/>为命名空间配置默认的内存请求和限制</a></li>
<li><a href=/zh/docs/tasks/administer-cluster/manage-resources/cpu-default-namespace/>为命名空间配置默认的 CPU 请求和限制</a></li>
<li><a href=/zh/docs/tasks/administer-cluster/manage-resources/memory-constraint-namespace/>配置命名空间的最小和最大内存约束</a></li>
<li><a href=/zh/docs/tasks/administer-cluster/manage-resources/cpu-constraint-namespace/>配置命名空间的最小和最大 CPU 约束</a></li>
<li><a href=/zh/docs/tasks/administer-cluster/manage-resources/quota-memory-cpu-namespace/>为命名空间配置内存和 CPU 配额</a></li>
<li><a href=/zh/docs/tasks/administer-cluster/manage-resources/quota-pod-namespace/>配置命名空间下 Pod 总数</a></li>
<li><a href=/zh/docs/tasks/administer-cluster/quota-api-object/>配置 API 对象配额</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-aa522472483f900008124a2809f2114b>5.2 - 为 Windows Pod 和容器配置 GMSA</h1>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.18 [stable]</code>
</div>
<p>本页展示如何为将运行在 Windows 节点上的 Pod 和容器配置
<a href=https://docs.microsoft.com/en-us/windows-server/security/group-managed-service-accounts/group-managed-service-accounts-overview>组管理的服务账号（Group Managed Service Accounts，GMSA）</a>。
组管理的服务账号是活动目录（Active Directory）的一种特殊类型，提供自动化的
密码管理、简化的服务主体名称（Service Principal Name，SPN）管理以及跨多个
服务器将管理操作委派给其他管理员等能力。</p>
<p>在 Kubernetes 环境中，GMSA 凭据规约配置为 Kubernetes 集群范围的自定义资源
（Custom Resources）形式。Windows Pod 以及各 Pod 中的每个容器可以配置为
使用 GMSA 来完成基于域（Domain）的操作（例如，Kerberos 身份认证），以便
与其他 Windows 服务相交互。自 Kubernetes 1.16 版本起，Docker 运行时为
Windows 负载支持 GMSA。</p>
<h2 id=before-you-begin>Before you begin</h2>
<p>你需要一个 Kubernetes 集群，以及 <code>kubectl</code> 命令行工具，且工具必须已配置
为能够与你的集群通信。集群预期包含 Windows 工作节点。
本节讨论需要为每个集群执行一次的初始操作。</p>
<h3 id=安装-gmsacredentialspec-crd>安装 GMSACredentialSpec CRD</h3>
<p>你需要在集群上配置一个用于 GMSA 凭据规约资源的
<a href=/zh/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/>CustomResourceDefinition</a>(CRD)，
以便定义类型为 <code>GMSACredentialSpec</code> 的自定义资源。
首先下载 GMSA CRD <a href=https://github.com/kubernetes-sigs/windows-gmsa/blob/master/admission-webhook/deploy/gmsa-crd.yml>YAML</a>
并将其保存为 <code>gmsa-crd.yaml</code>。接下来执行 <code>kubectl apply -f gmsa-crd.yaml</code>
安装 CRD。</p>
<h3 id=安装-webhook-来验证-gmsa-用户>安装 Webhook 来验证 GMSA 用户</h3>
<p>你需要为 Kubernetes 集群配置两个 Webhook，在 Pod 或容器级别填充和检查
GMSA 凭据规约引用。</p>
<ol>
<li>
<p>一个修改模式（Mutating）的 Webhook，将对 GMSA 的引用（在 Pod 规约中体现为名字）
展开为完整凭据规约的 JSON 形式，并保存回 Pod 规约中。</p>
</li>
<li>
<p>一个验证模式（Validating）的 Webhook，确保对 GMSA 的所有引用都是已经授权
给 Pod 的服务账号使用的。</p>
</li>
</ol>
<p>安装以上 Webhook 及其相关联的对象需要执行以下步骤：</p>
<ol>
<li>
<p>创建一个证书密钥对（用于允许 Webhook 容器与集群通信）</p>
</li>
<li>
<p>安装一个包含如上证书的 Secret</p>
</li>
<li>
<p>创建一个包含核心 Webhook 逻辑的 Deployment</p>
</li>
<li>
<p>创建引用该 Deployment 的 Validating Webhook 和 Mutating Webhook 配置</p>
</li>
</ol>
<p>你可以使用<a href=https://github.com/kubernetes-sigs/windows-gmsa/blob/master/admission-webhook/deploy/deploy-gmsa-webhook.sh>这个脚本</a>
来部署和配置上述 GMSA Webhook 及相关联的对象。你还可以在运行脚本时设置 <code>--dry-run=server</code>
选项以便审查脚本将会对集群做出的变更。</p>
<p>脚本所使用的<a href=https://github.com/kubernetes-sigs/windows-gmsa/blob/master/admission-webhook/deploy/gmsa-webhook.yml.tpl>YAML 模板</a>
也可用于手动部署 Webhook 及相关联的对象，不过需要对其中的参数作适当替换。</p>
<h2 id=在活动目录中配置-gmsa-和-windows-节点>在活动目录中配置 GMSA 和 Windows 节点</h2>
<p>在配置 Kubernetes 中的 Pod 以使用 GMSA 之前，需要按
<a href=https://docs.microsoft.com/en-us/windows-server/security/group-managed-service-accounts/getting-started-with-group-managed-service-accounts#BKMK_Step1>Windows GMSA 文档</a>
中描述的那样先在活动目录中准备好期望的 GMSA。
Windows 工作节点（作为 Kubernetes 集群的一部分）需要被配置到活动目录中，以便
访问与期望的 GSMA 相关联的秘密凭据数据。这一操作的描述位于
<a href=https://docs.microsoft.com/en-us/windows-server/security/group-managed-service-accounts/getting-started-with-group-managed-service-accounts#to-add-member-hosts-using-the-set-adserviceaccount-cmdlet>Windows GMSA 文档</a>
中。</p>
<h2 id=创建-gmsa-凭据规约资源>创建 GMSA 凭据规约资源</h2>
<p>当（如前所述）安装了 GMSACredentialSpec CRD 之后，你就可以配置包含 GMSA 凭据
规约的自定义资源了。GMSA 凭据规约中并不包含秘密或敏感数据。
其中包含的信息主要用于容器运行时，便于后者向 Windows 描述容器所期望的 GMSA。
GMSA 凭据规约可以使用
<a href=https://github.com/kubernetes-sigs/windows-gmsa/tree/master/scripts/GenerateCredentialSpecResource.ps1>PowerShell 脚本</a>
以 YAML 格式生成。</p>
<p>下面是手动以 JSON 格式生成 GMSA 凭据规约并对其进行 YAML 转换的步骤：</p>
<ol>
<li>
<p>导入 CredentialSpec <a href=https://github.com/MicrosoftDocs/Virtualization-Documentation/blob/live/windows-server-container-tools/ServiceAccounts/CredentialSpec.psm1>模块</a>: <code>ipmo CredentialSpec.psm1</code></p>
</li>
<li>
<p>使用 <code>New-CredentialSpec</code> 来创建一个 JSON 格式的凭据规约。
要创建名为 <code>WebApp1</code> 的 GMSA 凭据规约，调用
<code>New-CredentialSpec -Name WebApp1 -AccountName WebApp1 -Domain $(Get-ADDomain -Current LocalComputer)</code>。</p>
</li>
<li>
<p>使用 <code>Get-CredentialSpec</code> 来显示 JSON 文件的路径。</p>
</li>
<li>
<p>将凭据规约从 JSON 格式转换为 YAML 格式，并添加必要的头部字段
<code>apiVersion</code>、<code>kind</code>、<code>metadata</code> 和 <code>credspec</code>，使其成为一个可以在
Kubernetes 中配置的 GMSACredentialSpec 自定义资源。</p>
</li>
</ol>
<p>下面的 YAML 配置描述的是一个名为 <code>gmsa-WebApp1</code> 的 GMSA 凭据规约：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>windows.k8s.io/v1alpha1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>GMSACredentialSpec<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>gmsa-WebApp1 <span style=color:#bbb> </span><span style=color:#080;font-style:italic># 这是随意起的一个名字，将用作引用</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>credspec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ActiveDirectoryConfig</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>GroupManagedServiceAccounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>Name</span>:<span style=color:#bbb> </span>WebApp1  <span style=color:#bbb> </span><span style=color:#080;font-style:italic># GMSA 账号的用户名</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>Scope</span>:<span style=color:#bbb> </span>CONTOSO <span style=color:#bbb> </span><span style=color:#080;font-style:italic># NETBIOS 域名</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>Name</span>:<span style=color:#bbb> </span>WebApp1  <span style=color:#bbb> </span><span style=color:#080;font-style:italic># GMSA 账号的用户名</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>Scope</span>:<span style=color:#bbb> </span>contoso.com<span style=color:#bbb> </span><span style=color:#080;font-style:italic># DNS 域名</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>CmsPlugins</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- ActiveDirectory<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>DomainJoinConfig</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>DnsName</span>:<span style=color:#bbb> </span>contoso.com <span style=color:#bbb> </span><span style=color:#080;font-style:italic># DNS 域名</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>DnsTreeName</span>:<span style=color:#bbb> </span>contoso.com<span style=color:#bbb> </span><span style=color:#080;font-style:italic># DNS 域名根</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>Guid</span>:<span style=color:#bbb> </span>244818ae-87ac-4fcd-92ec-e79e5252348a <span style=color:#bbb> </span><span style=color:#080;font-style:italic># GUID</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>MachineAccountName</span>:<span style=color:#bbb> </span>WebApp1<span style=color:#bbb> </span><span style=color:#080;font-style:italic># GMSA 账号的用户名</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>NetBiosName</span>:<span style=color:#bbb> </span>CONTOSO <span style=color:#bbb> </span><span style=color:#080;font-style:italic># NETBIOS 域名</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>Sid</span>:<span style=color:#bbb> </span>S-1-5-21-2126449477-2524075714-3094792973<span style=color:#bbb> </span><span style=color:#080;font-style:italic># GMSA 的 SID</span><span style=color:#bbb>
</span></code></pre></div>
<p>上面的凭据规约资源可以保存为 <code>gmsa-Webapp1-credspec.yaml</code>，之后使用
<code>kubectl apply -f gmsa-Webapp1-credspec.yml</code> 应用到集群上。</p>
<h2 id=配置集群角色以启用对特定-gmsa-凭据规约的-rbac>配置集群角色以启用对特定 GMSA 凭据规约的 RBAC</h2>
<p>你需要为每个 GMSA 凭据规约资源定义集群角色。
该集群角色授权某主体（通常是一个服务账号）对特定的 GMSA 资源执行 <code>use</code> 动作。
下面的示例显示的是一个集群角色，对前文创建的凭据规约 <code>gmsa-WebApp1</code> 执行鉴权。
将此文件保存为 <code>gmsa-webapp1-role.yaml</code> 并执行 <code>kubectl apply -f gmsa-webapp1-role.yaml</code>。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#080;font-style:italic># 创建集群角色读取凭据规约</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>webapp1-role<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;windows.k8s.io&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;gmsacredentialspecs&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;use&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resourceNames</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;gmsa-WebApp1&#34;</span>]<span style=color:#bbb>
</span></code></pre></div>
<h2 id=将角色指派给要使用特定-gmsa-凭据规约的服务账号>将角色指派给要使用特定 GMSA 凭据规约的服务账号</h2>
<p>你需要将某个服务账号（Pod 配置所对应的那个）绑定到前文创建的集群角色上。
这一绑定操作实际上授予该服务账号使用所指定的 GMSA 凭据规约资源的访问权限。
下面显示的是一个绑定到集群角色 <code>webapp1-role</code> 上的 default 服务账号，使之
能够使用前面所创建的 <code>gmsa-WebApp1</code> 凭据规约资源。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>RoleBinding<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>allow-default-svc-account-read-on-gmsa-WebApp1<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>subjects</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ServiceAccount<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>roleRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>webapp1-role<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span></code></pre></div>
<h2 id=在-pod-规约中配置-gmsa-凭据规约引用>在 Pod 规约中配置 GMSA 凭据规约引用</h2>
<p>Pod 规约字段 <code>securityContext.windowsOptions.gmsaCredentialSpecName</code> 可用来
设置对指定 GMSA 凭据规约自定义资源的引用。
设置此引用将会配置 Pod 中的所有容器使用所给的 GMSA。
下面是一个 Pod 规约示例，其中包含了对 <code>gmsa-WebApp1</code> 凭据规约的引用：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>run</span>:<span style=color:#bbb> </span>with-creds<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>with-creds<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>run</span>:<span style=color:#bbb> </span>with-creds<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>run</span>:<span style=color:#bbb> </span>with-creds<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>securityContext</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>windowsOptions</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>gmsaCredentialSpecName</span>:<span style=color:#bbb> </span>gmsa-webapp1<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>mcr.microsoft.com/windows/servercore/iis:windowsservercore-ltsc2019<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>imagePullPolicy</span>:<span style=color:#bbb> </span>Always<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>iis<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>nodeSelector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>kubernetes.io/os</span>:<span style=color:#bbb> </span>windows<span style=color:#bbb>
</span></code></pre></div>
<p>Pod 中的各个容器也可以使用对应容器的 <code>securityContext.windowsOptions.gmsaCredentialSpecName</code>
字段来设置期望使用的 GMSA 凭据规约。
例如：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>run</span>:<span style=color:#bbb> </span>with-creds<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>with-creds<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>run</span>:<span style=color:#bbb> </span>with-creds<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>run</span>:<span style=color:#bbb> </span>with-creds<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>mcr.microsoft.com/windows/servercore/iis:windowsservercore-ltsc2019<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>imagePullPolicy</span>:<span style=color:#bbb> </span>Always<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>iis<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>securityContext</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>windowsOptions</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>gmsaCredentialSpecName</span>:<span style=color:#bbb> </span>gmsa-Webapp1<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>nodeSelector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>kubernetes.io/os</span>:<span style=color:#bbb> </span>windows<span style=color:#bbb>
</span></code></pre></div>
<p>当 Pod 规约中填充了 GMSA 相关字段（如上所述），在集群中应用 Pod 规约时会依次
发生以下事件：</p>
<ol>
<li>
<p>Mutating Webhook 解析对 GMSA 凭据规约资源的引用，并将其全部展开，
得到 GMSA 凭据规约的实际内容。</p>
</li>
<li>
<p>Validating Webhook 确保与 Pod 相关联的服务账号有权在所给的 GMSA 凭据规约
上执行 <code>use</code> 动作。</p>
</li>
<li>
<p>容器运行时为每个 Windows 容器配置所指定的 GMSA 凭据规约，这样容器就可以以
活动目录中该 GMSA 所代表的身份来执行操作，使用该身份来访问域中的服务。</p>
</li>
</ol>
<h2 id=containerd>Containerd</h2>
<p>在 Windows Server 2019 上对 containerd 使用 GMSA，需要使用 Build 17763.1817（或更新的版本），
你可以安装补丁 <a href=https://support.microsoft.com/en-us/topic/march-9-2021-kb5000822-os-build-17763-1817-2eb6197f-e3b1-4f42-ab51-84345e063564>KB5000822</a>。</p>
<p>containerd 场景从 Pod 连接 SMB 共享的时候有一个已知问题：
配置了 GMSA 以后，无法通过主机名或者 FQDN 访问 SMB共享，但是通过 IP 地址访问没有问题。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-PowerShell data-lang=PowerShell>ping adserver.ad.local
</code></pre></div>
<p>主机名可以被解析为 IPv4 地址，输出类似如下所示：</p>
<pre><code>Pinging adserver.ad.local [192.168.111.18] with 32 bytes of data:
Reply from 192.168.111.18: bytes=32 time=6ms TTL=124
Reply from 192.168.111.18: bytes=32 time=5ms TTL=124
Reply from 192.168.111.18: bytes=32 time=5ms TTL=124
Reply from 192.168.111.18: bytes=32 time=5ms TTL=124
</code></pre>
<p>但是，当尝试使用主机名浏览目录时:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-PowerShell data-lang=PowerShell><span style=color:#a2f>cd </span>\\adserver.ad.local\test
</code></pre></div>
<p>你会看到一个错误，提示目标共享不存在:</p>
<pre><code>cd : Cannot find path '\\adserver.ad.local\test' because it does not exist.
At line:1 char:1
+ cd \\adserver.ad.local\test
+ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    + CategoryInfo          : ObjectNotFound: (\\adserver.ad.local\test:String) [Set-Location], ItemNotFoundException
    + FullyQualifiedErrorId : PathNotFound,Microsoft.PowerShell.Commands.SetLocationCommand
</code></pre>
<p>但是你会注意到，如果你改为使用其 IPv4 地址浏览共享，错误就会消失；例如：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-PowerShell data-lang=PowerShell><span style=color:#a2f>cd </span>\\192.168.111.18\test
</code></pre></div>
<p>切换到共享中的目录后，你会看到类似于以下内容的提示：</p>
<pre><code>Microsoft.PowerShell.Core\FileSystem::\\192.168.111.18\test&gt;
</code></pre>
<p>要解决问题，你需要在节点上运行以下命令以添加所需的注册表项
<code>reg add "HKLM\SYSTEM\CurrentControlSet\Services\hns\State" /v EnableCompartmentNamespace /t REG_DWORD /d 1</code>。
此更改只会在新创建的 Pod 中生效，这意味着你必须重新创建任何需要访问 SMB 共享的正在运行的 Pod。</p>
<h2 id=故障排查>故障排查</h2>
<p>如果在你的环境中配置 GMSA 时遇到了困难，你可以采取若干步骤来排查可能的故障。</p>
<p>首先，确保 credspec 已传递给 Pod。为此，你需要先运行 <code>exec</code> 进入到你的一个 Pod 中并检查 <code>nltest.exe /parentdomain</code> 命令的输出。
在下面的例子中，Pod 未能正确地获得凭据规约：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-PowerShell data-lang=PowerShell>kubectl exec -it <span style=color:#a2f>iis-auth</span>-7776966999-n5nzr powershell.exe
</code></pre></div>
<p><code>nltest.exe /parentdomain</code> 导致以下错误：</p>
<pre><code>Getting parent domain failed: Status = 1722 0x6ba RPC_S_SERVER_UNAVAILABLE
</code></pre>
<p>如果 Pod 未能正确获得凭据规约，则下一步就要检查与域之间的通信。
首先，从 Pod 内部快速执行一个 nslookup 操作，找到域根。</p>
<p>这一操作会告诉我们三件事情：</p>
<ol>
<li>Pod 能否访问域控制器（DC）</li>
<li>DC 能否访问 Pod</li>
<li>DNS 是否正常工作</li>
</ol>
<p>如果 DNS 和通信测试通过，接下来你需要检查是否 Pod 已经与域之间建立了
安全通信通道。要执行这一检查，你需要再次通过 <code>exec</code> 进入到你的 Pod 中
并执行 <code>nltest.exe /query</code> 命令。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-PowerShell data-lang=PowerShell>nltest.exe /query
</code></pre></div>
<p>这告诉我们，由于某种原因，Pod 无法使用 credspec 中指定的帐户登录到域。
你可以尝试通过运行以下命令来修复安全通道：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-PowerShell data-lang=PowerShell>nltest /sc_reset<span>:</span>domain.example
</code></pre></div>
<p>如果命令成功，你将看到类似以下内容的输出：</p>
<pre><code>Flags: 30 HAS_IP  HAS_TIMESERV
Trusted DC Name \\dc10.domain.example
Trusted DC Connection Status Status = 0 0x0 NERR_Success
The command completed successfully
</code></pre>
<p>如果以上命令修复了错误，你可以通过将以下生命周期回调添加到你的 Pod 规约中来自动执行该步骤。
如果这些操作没有修复错误，你将需要再次检查你的 credspec 并确认它是正确和完整的。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>registry.domain.example/iis-auth:1809v1<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>lifecycle</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>postStart</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>exec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;powershell.exe&#34;</span>,<span style=color:#b44>&#34;-command&#34;</span>,<span style=color:#b44>&#34;do { Restart-Service -Name netlogon } while ( $($Result = (nltest.exe /query); if ($Result -like &#39;*0x0 NERR_Success*&#39;) {return $true} else {return $false}) -eq $false)&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>imagePullPolicy</span>:<span style=color:#bbb> </span>IfNotPresent<span style=color:#bbb>
</span></code></pre></div>
<p>如果你向你的 Pod 规约中添加如上所示的 <code>lifecycle</code> 节，则 Pod 会自动执行所
列举的命令来重启 <code>netlogon</code> 服务，直到 <code>nltest.exe /query</code>
命令返回时没有错误信息。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-f5da7517bee8a8807431d9fc65263b39>5.3 - 为 Windows 的 Pod 和容器配置 RunAsUserName</h1>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.18 [stable]</code>
</div>
<p>本页展示如何为运行为在 Windows 节点上运行的 Pod 和容器配置 <code>RunAsUserName</code> 。
大致相当于 Linux 上的 <code>runAsUser</code>，允许在容器中以与默认值不同的用户名运行应用。</p>
<h2 id=before-you-begin>Before you begin</h2>
<p>你必须有一个 Kubernetes 集群，并且 kubectl 必须能和集群通信。
集群应该要有 Windows 工作节点，将在其中调度运行 Windows 工作负载的 pod 和容器。</p>
<h2 id=为-pod-设置-username>为 Pod 设置 Username</h2>
<p>要指定运行 Pod 容器时所使用的用户名，请在 Pod 声明中包含 <code>securityContext</code>
(<a href=/docs/reference/generated/kubernetes-api/v1.23/#podsecuritycontext-v1-core>PodSecurityContext</a>) 字段，
并在其内部包含 <code>windowsOptions</code>
(<a href=/docs/reference/generated/kubernetes-api/v1.23/#windowssecuritycontextoptions-v1-core>WindowsSecurityContextOptions</a>)
字段的 <code>runAsUserName</code> 字段。</p>
<p>你为 Pod 指定的 Windows SecurityContext 选项适用于该 Pod 中（包括 init 容器）的所有容器。</p>
<p>这儿有一个已经设置了 <code>runAsUserName</code> 字段的 Windows Pod 的配置文件：</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/windows/run-as-username-pod.yaml download=windows/run-as-username-pod.yaml><code>windows/run-as-username-pod.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('windows-run-as-username-pod-yaml')" title="Copy windows/run-as-username-pod.yaml to clipboard">
</img>
</div>
<div class=includecode id=windows-run-as-username-pod-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>run-as-username-pod-demo<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>securityContext</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>windowsOptions</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>runAsUserName</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;ContainerUser&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>run-as-username-demo<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>mcr.microsoft.com/windows/servercore:ltsc2019<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;ping&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;-t&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;localhost&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>nodeSelector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubernetes.io/os</span>:<span style=color:#bbb> </span>windows<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>创建 Pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/windows/run-as-username-pod.yaml
</code></pre></div>
<p>验证 Pod 容器是否在运行：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod run-as-username-pod-demo
</code></pre></div>
<p>获取该容器的 shell：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#a2f>exec</span> -it run-as-username-pod-demo -- powershell
</code></pre></div>
<p>检查运行 shell 的用户的用户名是否正确：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=color:#a2f>echo </span><span style=color:#b8860b>$env:USERNAME</span>
</code></pre></div>
<p>输出结果应该是这样：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>ContainerUser
</code></pre></div>
<h2 id=为容器设置-username>为容器设置 Username</h2>
<p>要指定运行容器时所使用的用户名，请在容器清单中包含 <code>securityContext</code>
(<a href=/zh/docs/reference/generated/kubernetes-api/v1.23/#securitycontext-v1-core>SecurityContext</a>)
字段，并在其内部包含 <code>windowsOptions</code>
（<a href=/zh/docs/reference/generated/kubernetes-api/v1.23/#windowssecuritycontextoptions-v1-core>WindowsSecurityContextOptions</a>）
字段的 <code>runAsUserName</code> 字段。</p>
<p>你为容器指定的 Windows SecurityContext 选项仅适用于该容器，并且它会覆盖 Pod 级别设置。</p>
<p>这里有一个 Pod 的配置文件，其中只有一个容器，并且在 Pod 级别和容器级别都设置了 <code>runAsUserName</code>：</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/windows/run-as-username-container.yaml download=windows/run-as-username-container.yaml><code>windows/run-as-username-container.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('windows-run-as-username-container-yaml')" title="Copy windows/run-as-username-container.yaml to clipboard">
</img>
</div>
<div class=includecode id=windows-run-as-username-container-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>run-as-username-container-demo<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>securityContext</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>windowsOptions</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>runAsUserName</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;ContainerUser&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>run-as-username-demo<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>mcr.microsoft.com/windows/servercore:ltsc2019<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;ping&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;-t&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;localhost&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>securityContext</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>windowsOptions</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>runAsUserName</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;ContainerAdministrator&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>nodeSelector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubernetes.io/os</span>:<span style=color:#bbb> </span>windows<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>创建 Pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/windows/run-as-username-container.yaml
</code></pre></div>
<p>验证 Pod 容器是否在运行：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod run-as-username-container-demo
</code></pre></div>
<p>获取该容器的 shell：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#a2f>exec</span> -it run-as-username-container-demo -- powershell
</code></pre></div>
<p>检查运行 shell 的用户的用户名是否正确（应该是容器级别设置的那个）：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=color:#a2f>echo </span><span style=color:#b8860b>$env:USERNAME</span>
</code></pre></div>
<p>输出结果应该是这样：</p>
<pre><code>ContainerAdministrator
</code></pre>
<h2 id=windows-username-的局限性>Windows Username 的局限性</h2>
<p>想要使用此功能，在 <code>runAsUserName</code> 字段中设置的值必须是有效的用户名。
它必须是 <code>DOMAIN\USER</code> 这种格式，其中 <code>DOMAIN\</code> 是可选的。
Windows 用户名不区分大小写。此外，关于 <code>DOMAIN</code> 和 <code>USER</code> 还有一些限制：</p>
<ul>
<li><code>runAsUserName</code> 字段不能为空，并且不能包含控制字符（ASCII 值：<code>0x00-0x1F</code>、<code>0x7F</code>）</li>
<li><code>DOMAIN</code> 必须是 NetBios 名称或 DNS 名称，每种名称都有各自的局限性：
<ul>
<li>NetBios 名称：最多 15 个字符，不能以 <code>.</code>（点）开头，并且不能包含以下字符：<code>\ / : * ? " &lt; > |</code></li>
<li>DNS 名称：最多 255 个字符，只能包含字母、数字、点和中划线，并且不能以 <code>.</code>（点）或 <code>-</code>（中划线）开头和结尾。</li>
</ul>
</li>
<li><code>USER</code> 最多不超过 20 个字符，不能 <strong>只</strong> 包含点或空格，并且不能包含以下字符：<code>" / \ [ ] : ; | = , + * ? &lt; > @</code></li>
</ul>
<p><code>runAsUserName</code> 字段接受的值的一些示例：<code>ContainerAdministrator</code>、<code>ContainerUser</code>、
<code>NT AUTHORITY\NETWORK SERVICE</code>、<code>NT AUTHORITY\LOCAL SERVICE</code>。</p>
<p>关于这些限制的更多信息，可以查看<a href=https://support.microsoft.com/en-us/help/909264/naming-conventions-in-active-directory-for-computers-domains-sites-and>这里</a>和<a href="https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.localaccounts/new-localuser?view=powershell-5.1">这里</a>。</p>
<h2 id=what-s-next>What's next</h2>
<ul>
<li><a href=/zh/docs/setup/production-environment/windows/user-guide-windows-containers/>Kubernetes 中调度 Windows 容器的指南</a></li>
<li><a href=/zh/docs/setup/production-environment/windows/user-guide-windows-containers/#managing-workload-identity-with-group-managed-service-accounts>使用组托管服务帐户（GMSA）管理工作负载身份</a></li>
<li><a href=/zh/docs/tasks/configure-pod-container/configure-gmsa/>Windows 下 pod 和容器的 GMSA 配置</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-8555af270ae7122cc0464bab3f5d1609>5.4 - 为容器和 Pods 分配 CPU 资源</h1>
<p>本页面展示如何为容器设置 CPU <em>request（请求）</em> 和 CPU <em>limit（限制）</em>。
容器使用的 CPU 不能超过所配置的限制。
如果系统有空闲的 CPU 时间，则可以保证给容器分配其所请求数量的 CPU 资源。</p>
<h2 id=before-you-begin>Before you begin</h2>
<p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li>
</ul>
To check the version, enter <code>kubectl version</code>.
</p>
<p>集群中的每个节点必须至少有 1 个 CPU 可用才能运行本任务中的示例。</p>
<p>本页的一些步骤要求你在集群中运行
<a href=https://github.com/kubernetes-sigs/metrics-server>metrics-server</a>
服务。如果你的集群中已经有正在运行的 metrics-server 服务，可以跳过这些步骤。</p>
<p>如果你正在运行<a class=glossary-tooltip title="Minikube 是用来在本地运行 Kubernetes 的一种工具。" data-toggle=tooltip data-placement=top href=/docs/getting-started-guides/minikube/ target=_blank aria-label=Minikube>Minikube</a>，请运行以下命令启用 metrics-server：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>minikube addons <span style=color:#a2f>enable</span> metrics-server
</code></pre></div>
<p>查看 metrics-server（或者其他资源度量 API <code>metrics.k8s.io</code> 服务提供者）是否正在运行，
请键入以下命令：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get apiservices
</code></pre></div>
<p>如果资源指标 API 可用，则会输出将包含一个对 <code>metrics.k8s.io</code> 的引用。</p>
<pre><code>NAME
v1beta1.metrics.k8s.io
</code></pre>
<h2 id=创建一个名字空间>创建一个名字空间</h2>
<p>创建一个<a class=glossary-tooltip title="名字空间是 Kubernetes 用来支持隔离单个集群中的资源组的一种抽象。" data-toggle=tooltip data-placement=top href=/zh/docs/concepts/overview/working-with-objects/namespaces/ target=_blank aria-label=名字空间>名字空间</a>，以便将
本练习中创建的资源与集群的其余部分资源隔离。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create namespace cpu-example
</code></pre></div>
<h2 id=指定-cpu-请求和-cpu-限制>指定 CPU 请求和 CPU 限制</h2>
<p>要为容器指定 CPU 请求，请在容器资源清单中包含 <code>resources: requests</code> 字段。
要指定 CPU 限制，请包含 <code>resources:limits</code>。</p>
<p>在本练习中，你将创建一个具有一个容器的 Pod。容器将会请求 0.5 个 CPU，而且最多限制使用 1 个 CPU。
这是 Pod 的配置文件：</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/pods/resource/cpu-request-limit.yaml download=pods/resource/cpu-request-limit.yaml><code>pods/resource/cpu-request-limit.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-resource-cpu-request-limit-yaml')" title="Copy pods/resource/cpu-request-limit.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-resource-cpu-request-limit-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cpu-demo<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>cpu-example<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cpu-demo-ctr<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>vish/stress<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;1&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;0.5&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- -cpus<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;2&#34;</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>配置文件的 <code>args</code> 部分提供了容器启动时的参数。
<code>-cpus "2"</code> 参数告诉容器尝试使用 2 个 CPU。</p>
<p>创建 Pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/pods/resource/cpu-request-limit.yaml --namespace<span style=color:#666>=</span>cpu-example
</code></pre></div>
<p>验证所创建的 Pod 处于 Running 状态</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod cpu-demo --namespace<span style=color:#666>=</span>cpu-example
</code></pre></div>
<p>查看显示关于 Pod 的详细信息：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod cpu-demo --output<span style=color:#666>=</span>yaml --namespace<span style=color:#666>=</span>cpu-example
</code></pre></div>
<p>输出显示 Pod 中的一个容器的 CPU 请求为 500 milli CPU，并且 CPU 限制为 1 个 CPU。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;1&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span>500m<span style=color:#bbb>
</span></code></pre></div>
<p>使用 <code>kubectl top</code> 命令来获取该 Pod 的度量值数据：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl top pod cpu-demo --namespace<span style=color:#666>=</span>cpu-example
</code></pre></div>
<p>此示例输出显示 Pod 使用的是 974 milliCPU，即略低于 Pod 配置中指定的 1 个 CPU 的限制。</p>
<pre><code>NAME                        CPU(cores)   MEMORY(bytes)
cpu-demo                    974m         &lt;something&gt;
</code></pre>
<p>回想一下，通过设置 <code>-cpu "2"</code>，你将容器配置为尝试使用 2 个 CPU，
但是容器只被允许使用大约 1 个 CPU。
容器的 CPU 用量受到限制，因为该容器正尝试使用超出其限制的 CPU 资源。</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> CPU 使用率低于 1.0 的另一种可能的解释是，节点可能没有足够的 CPU 资源可用。
回想一下，此练习的先决条件需要你的节点至少具有 1 个 CPU 可用。
如果你的容器在只有 1 个 CPU 的节点上运行，则容器无论为容器指定的 CPU 限制如何，
都不能使用超过 1 个 CPU。
</div>
<h2 id=cpu-units>CPU 单位 </h2>
<p>CPU 资源以 <em>CPU</em> 单位度量。Kubernetes 中的一个 CPU 等同于：</p>
<ul>
<li>1 个 AWS vCPU</li>
<li>1 个 GCP核心</li>
<li>1 个 Azure vCore</li>
<li>裸机上具有超线程能力的英特尔处理器上的 1 个超线程</li>
</ul>
<p>小数值是可以使用的。一个请求 0.5 CPU 的容器保证会获得请求 1 个 CPU 的容器的 CPU 的一半。
你可以使用后缀 <code>m</code> 表示毫。例如 <code>100m</code> CPU、100 milliCPU 和 0.1 CPU 都相同。
精度不能超过 1m。</p>
<p>CPU 请求只能使用绝对数量，而不是相对数量。0.1 在单核、双核或 48 核计算机上的 CPU 数量值是一样的。</p>
<p>删除 Pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete pod cpu-demo --namespace<span style=color:#666>=</span>cpu-example
</code></pre></div>
<h2 id=设置超过节点能力的-cpu-请求>设置超过节点能力的 CPU 请求</h2>
<p>CPU 请求和限制与都与容器相关，但是我们可以考虑一下 Pod 具有对应的 CPU 请求和限制这样的场景。
Pod 对 CPU 用量的请求等于 Pod 中所有容器的请求数量之和。
同样，Pod 的 CPU 资源限制等于 Pod 中所有容器 CPU 资源限制数之和。</p>
<p>Pod 调度是基于资源请求值来进行的。
仅在某节点具有足够的 CPU 资源来满足 Pod CPU 请求时，Pod 将会在对应节点上运行：</p>
<p>在本练习中，你将创建一个 Pod，该 Pod 的 CPU 请求对于集群中任何节点的容量而言都会过大。
下面是 Pod 的配置文件，其中有一个容器。容器请求 100 个 CPU，这可能会超出集群中任何节点的容量。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/pods/resource/cpu-request-limit-2.yaml download=pods/resource/cpu-request-limit-2.yaml><code>pods/resource/cpu-request-limit-2.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-resource-cpu-request-limit-2-yaml')" title="Copy pods/resource/cpu-request-limit-2.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-resource-cpu-request-limit-2-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cpu-demo-2<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>cpu-example<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cpu-demo-ctr-2<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>vish/stress<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;100&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;100&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- -cpus<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;2&#34;</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>创建 Pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/pods/resource/cpu-request-limit-2.yaml --namespace<span style=color:#666>=</span>cpu-example
</code></pre></div>
<p>查看该 Pod 的状态：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod cpu-demo-2 --namespace<span style=color:#666>=</span>cpu-example
</code></pre></div>
<p>输出显示 Pod 状态为 Pending。也就是说，Pod 未被调度到任何节点上运行，
并且 Pod 将无限期地处于 Pending 状态：</p>
<pre><code>NAME         READY     STATUS    RESTARTS   AGE
cpu-demo-2   0/1       Pending   0          7m
</code></pre>
<p>查看有关 Pod 的详细信息，包含事件：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe pod cpu-demo-2 --namespace<span style=color:#666>=</span>cpu-example
</code></pre></div>
<p>输出显示由于节点上的 CPU 资源不足，无法调度容器：</p>
<pre><code>Events:
  Reason                        Message
  ------                        -------
  FailedScheduling      No nodes are available that match all of the following predicates:: Insufficient cpu (3).
</code></pre>
<p>删除你的 Pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete pod cpu-demo-2 --namespace<span style=color:#666>=</span>cpu-example
</code></pre></div>
<h2 id=如果不指定-cpu-限制>如果不指定 CPU 限制</h2>
<p>如果你没有为容器指定 CPU 限制，则会发生以下情况之一：</p>
<ul>
<li>
<p>容器在可以使用的 CPU 资源上没有上限。因而可以使用所在节点上所有的可用 CPU 资源。</p>
</li>
<li>
<p>容器在具有默认 CPU 限制的名字空间中运行，系统会自动为容器设置默认限制。
集群管理员可以使用
<a href=/docs/reference/generated/kubernetes-api/v1.23/#limitrange-v1-core/>LimitRange</a>
指定 CPU 限制的默认值。</p>
</li>
</ul>
<h2 id=如果你设置了-cpu-限制但未设置-cpu-请求>如果你设置了 CPU 限制但未设置 CPU 请求</h2>
<p>如果你为容器指定了 CPU 限制值但未为其设置 CPU 请求，Kubernetes 会自动为其
设置与 CPU 限制相同的 CPU 请求值。类似的，如果容器设置了内存限制值但未设置
内存请求值，Kubernetes 也会为其设置与内存限制值相同的内存请求。</p>
<h2 id=cpu-请求和限制的初衷>CPU 请求和限制的初衷</h2>
<p>通过配置你的集群中运行的容器的 CPU 请求和限制，你可以有效利用集群上可用的 CPU 资源。
通过将 Pod CPU 请求保持在较低水平，可以使 Pod 更有机会被调度。
通过使 CPU 限制大于 CPU 请求，你可以完成两件事：</p>
<ul>
<li>Pod 可能会有突发性的活动，它可以利用碰巧可用的 CPU 资源。</li>
<li>Pod 在突发负载期间可以使用的 CPU 资源数量仍被限制为合理的数量。</li>
</ul>
<h2 id=清理>清理</h2>
<p>删除名称空间：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete namespace cpu-example
</code></pre></div><h2 id=what-s-next>What's next</h2>
<h3 id=针对应用开发者>针对应用开发者</h3>
<ul>
<li><a href=/zh/docs/tasks/configure-pod-container/assign-memory-resource/>将内存资源分配给容器和 Pod</a></li>
<li><a href=/zh/docs/tasks/configure-pod-container/quality-service-pod/>配置 Pod 服务质量</a></li>
</ul>
<h3 id=针对集群管理员>针对集群管理员</h3>
<ul>
<li><a href=/zh/docs/tasks/administer-cluster/manage-resources/memory-default-namespace/>配置名称空间的默认内存请求和限制</a></li>
<li><a href=/zh/docs/tasks/administer-cluster/manage-resources/cpu-default-namespace/>为名字空间配置默认 CPU 请求和限制</a></li>
<li><a href=/zh/docs/tasks/administer-cluster//manage-resources/memory-constraint-namespace/>为名字空间配置最小和最大内存限制</a></li>
<li><a href=/zh/docs/tasks/administer-cluster/manage-resources/cpu-constraint-namespace/>为名字空间配置最小和最大 CPU 约束</a></li>
<li><a href=/zh/docs/tasks/administer-cluster/manage-resources/quota-memory-cpu-namespace/>为名字空间配置内存和 CPU 配额</a></li>
<li><a href=/zh/docs/tasks/administer-cluster/manage-resources/quota-pod-namespace/>为名字空间配置 Pod 配额</a></li>
<li><a href=/zh/docs/tasks/administer-cluster/quota-api-object/>配置 API 对象的配额</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-3fbf113e9e5f4b46f8ccb91a048509c0>5.5 - 创建 Windows HostProcess Pod</h1>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.23 [beta]</code>
</div>
<p>Windows HostProcess 容器让你能够在 Windows 主机上运行容器化负载。
这类容器以普通的进程形式运行，但能够在具有合适用户特权的情况下，
访问主机网络名字空间、存储和设备。HostProcess 容器可用来在 Windows
节点上部署网络插件、存储配置、设备插件、kube-proxy 以及其他组件，
同时不需要配置专用的代理或者直接安装主机服务。</p>
<p>类似于安装安全补丁、事件日志收集等这类管理性质的任务可以在不需要集群操作员登录到每个
Windows 节点的前提下执行。HostProcess 容器可以以主机上存在的任何用户账户来运行，
也可以以主机所在域中的用户账户运行，这样管理员可以通过用户许可权限来限制资源访问。
尽管文件系统和进程隔离都不支持，在启动容器时会在主机上创建一个新的卷，
为其提供一个干净的、整合的工作空间。HostProcess 容器也可以基于现有的 Windows
基础镜像来制作，并且不再有 Windows 服务器容器所带有的那些
<a href=https://docs.microsoft.com/virtualization/windowscontainers/deploy-containers/version-compatibility>兼容性需求</a>，
这意味着基础镜像的版本不必与主机操作系统的版本匹配。
不过，仍然建议你像使用 Windows 服务器容器负载那样，使用相同的基础镜像版本，
这样你就不会有一些未使用的镜像占用节点上的存储空间。HostProcess 容器也支持
在容器卷内执行<a href=#volume-mounts>卷挂载</a>。</p>
<h3 id=我何时该使用-windows-hostprocess-容器>我何时该使用 Windows HostProcess 容器？</h3>
<ul>
<li>当你准备执行需要访问主机上网络名字空间的任务时，HostProcess
容器能够访问主机上的网络接口和 IP 地址。</li>
<li>当你需要访问主机上的资源，如文件系统、事件日志等等。</li>
<li>需要安装特定的设备驱动或者 Windows 服务时。</li>
<li>需要对管理任务和安全策略进行整合时。使用 HostProcess 容器能够缩小 Windows
节点上所需要的特权范围。</li>
</ul>
<h2 id=before-you-begin>Before you begin</h2>
<p>本任务指南是特定于 Kubernetes v1.23 的。
如果你运行的不是 Kubernetes v1.23，请移步访问正确
版本的 Kubernetes 文档。</p>
<p>在 Kubernetes v1.23 中，HostProcess 容器功能特性默认是启用的。
kubelet 会直接与 containerd 通信，通过 CRI 将主机进程标志传递过去。
你可以使用 containerd 的最新版本（v1.6+）来运行 HostProcess 容器。
参阅<a href=/zh/docs/setup/production-environment/container-runtimes/#containerd>如何安装 containerd</a>。</p>
<p>要 <em>禁用</em> HostProcess 容器特性，你需要为 <strong>kubelet</strong> 和 <strong>kube-apiserver</strong>
设置下面的特性门控标志：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell>--feature-gates=WindowsHostProcessContainers=false
</code></pre></div>
<p>进一步的细节可参阅<a href=/zh/docs/reference/command-line-tools-reference/feature-gates/#overview>特性门控</a>文档。</p>
<h2 id=limitations>限制 </h2>
<p>以下限制是与 Kubernetes v1.23 相关的：</p>
<ul>
<li>HostProcess 容器需要 containerd 1.6 或更高版本的
<a class=glossary-tooltip title=容器运行时是负责运行容器的软件。 data-toggle=tooltip data-placement=top href=/zh/docs/setup/production-environment/container-runtimes target=_blank aria-label=容器运行时>容器运行时</a>。</li>
<li>HostProcess Pods 只能包含 HostProcess 容器。这是在 Windows 操作系统上的约束；
非特权的 Windows 容器不能与主机 IP 名字空间共享虚拟网卡（vNIC）。</li>
<li>HostProcess 在主机上以一个进程的形式运行，除了通过 HostProcess
用户账号所实施的资源约束外，不提供任何形式的隔离。HostProcess 容器不支持文件系统或
Hyper-V 隔离。</li>
</ul>
<ul>
<li>卷挂载是被支持的，并且要花在到容器卷下。参见<a href=#volume-mounts>卷挂载</a>。</li>
<li>默认情况下有一组主机用户账户可供 HostProcess 容器使用。
参见<a href=#choosing-a-user-account>选择用户账号</a>。</li>
<li>对资源约束（磁盘、内存、CPU 个数）的支持与主机上进程相同。</li>
<li><strong>不支持</strong>命名管道或者 UNIX 域套接字形式的挂载，需要使用主机上的路径名来访问
（例如，\\.\pipe\*）。</li>
</ul>
<h2 id=hostprocess-pod-configuration-requirements>HostProcess Pod 配置需求 </h2>
<p>启用 Windows HostProcess Pod 需要在 Pod 安全配置中设置合适的选项。
在 <a href=/zh/docs/concepts/security/pod-security-standards>Pod
安全标准</a>中所定义的策略中，
HostProcess Pod 默认是不被 basline 和 restricted 策略支持的。因此建议
HostProcess 运行在与 privileged 模式相看齐的策略下。</p>
<p>当运行在 privileged 策略下时，下面是要启用 HostProcess Pod 创建所需要设置的选项：</p>
<table>
<caption style=display:none>privileged 策略规约</caption>
<thead>
<tr>
<th>控制</th>
<th>策略</th>
</tr>
</thead>
<tbody>
<tr>
<td style=white-space:nowrap><a href=/zh/docs/concepts/security/pod-security-standards><tt>securityContext.windowsOptions.hostProcess</tt></a></td>
<td>
<p>
Windows Pods 提供运行<a href=/zh/docs/tasks/configure-pod-container/create-hostprocess-pod>
HostProcess 容器</a>的能力，这类容器能够具有对 Windows 节点的特权访问权限。</p>
<p><strong>可选值</strong></p>
<ul>
<li><code>true</code></li>
</ul>
</td>
</tr>
<tr>
<td style=white-space:nowrap><a href=/zh/docs/concepts/security/pod-security-standards><tt>hostNetwork</tt></a></td>
<td>
<p>
初始时将默认位于主机网络中。在未来可能会希望将网络设置到不同的隔离环境中。
</p>
<p><strong>可选值</strong></p>
<ul>
<li><code>true</code></li>
</ul>
</td>
</tr>
<tr>
<td style=white-space:nowrap><a href=/zh/docs/tasks/configure-pod-container/configure-runasusername/><tt>securityContext.windowsOptions.runAsUsername</tt></a></td>
<td>
<p>
关于 HostProcess 容器所要使用的用户的规约，需要设置在 Pod 的规约中。
</p>
<p><strong>可选值</strong></p>
<ul>
<li><code>NT AUTHORITY\SYSTEM</code></li>
<li><code>NT AUTHORITY\Local service</code></li>
<li><code>NT AUTHORITY\NetworkService</code></li>
</ul>
</td>
</tr>
<tr>
<td style=white-space:nowrap><a href=/zh/docs/concepts/security/pod-security-standards><tt>runAsNonRoot</tt></a></td>
<td>
<p>
因为 HostProcess 容器有访问主机的特权，<tt>runAsNonRoot</tt> 字段不可以设置为 true。
</p>
<p><strong>可选值</strong></p>
<ul>
<li>未定义/Nil</li>
<li><code>false</code></li>
</ul>
</td>
</tr>
</tbody>
</table>
<h3 id=manifest-example>配置清单示例（片段） </h3>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>securityContext</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>windowsOptions</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>hostProcess</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>runAsUserName</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;NT AUTHORITY\\Local service&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>hostNetwork</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>image1:latest<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- ping<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- -t<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:#666>127.0.0.1</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>nodeSelector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;kubernetes.io/os&#34;: </span>windows<span style=color:#bbb>
</span></code></pre></div>
<h2 id=volume-mounts>卷挂载 </h2>
<p>HostProcess 容器支持在容器卷空间中挂载卷的能力。
在容器内运行的应用能够通过相对或者绝对路径直接访问卷挂载。
环境变量 <code>$CONTAINER_SANDBOX_MOUNT_POINT</code> 在容器创建时被设置为指向容器卷的绝对主机路径。
相对路径是基于 <code>.spec.containers.volumeMounts.mountPath</code> 配置来推导的。</p>
<h3 id=volume-mount-example>示例 </h3>
<p>容器内支持通过下面的路径结构来访问服务账好令牌：</p>
<p><code>.\var\run\secrets\kubernetes.io\serviceaccount\</code></p>
<p><code>$CONTAINER_SANDBOX_MOUNT_POINT\var\run\secrets\kubernetes.io\serviceaccount\</code></p>
<h2 id=resource-limits>资源约束 </h2>
<p>资源约束（磁盘、内存、CPU 个数）作用到任务之上，并在整个任务上起作用。
例如，如果内存限制设置为 10MB，任何 HostProcess 任务对象所分配的内存不会超过 10MB。
这一行为与其他 Windows 容器类型相同。资源限制的设置方式与编排系统或容器运行时无关。
唯一的区别是用来跟踪资源所进行的磁盘资源用量的计算，出现差异的原因是因为
HostProcess 容器启动引导的方式造成的。</p>
<h2 id=choosing-a-user-account>选择用户账号 </h2>
<p>HostProcess 容器支持以三种被支持的 Windows 服务账号之一来运行：</p>
<ul>
<li><strong><a href=https://docs.microsoft.com/windows/win32/services/localsystem-account>LocalSystem</a></strong></li>
<li><strong><a href=https://docs.microsoft.com/windows/win32/services/localservice-account>LocalService</a></strong></li>
<li><strong><a href=https://docs.microsoft.com/windows/win32/services/networkservice-account>NetworkService</a></strong></li>
</ul>
<p>你应该为每个 HostProcess 容器选择一个合适的 Windows 服务账号，尝试限制特权范围，
避免给主机代理意外的（甚至是恶意的）伤害。LocalSystem 服务账号的特权级
在三者之中最高，只有在绝对需要的时候才应该使用。只要可能，应该使用
LocalService 服务账号，因为该账号在三者中特权最低。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-904cea8c8efd5c0d33adbfe579ec2dd2>5.6 - 配置 Pod 的服务质量</h1>
<p>本页介绍怎样配置 Pod 让其获得特定的服务质量（QoS）类。Kubernetes 使用 QoS 类来决定 Pod 的调度和驱逐策略。</p>
<h2 id=before-you-begin>Before you begin</h2>
<p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li>
</ul>
To check the version, enter <code>kubectl version</code>.
</p>
<h2 id=qos-classes>QoS 类 </h2>
<p>Kubernetes 创建 Pod 时就给它指定了下列一种 QoS 类：</p>
<ul>
<li>Guaranteed</li>
<li>Burstable</li>
<li>BestEffort</li>
</ul>
<h2 id=创建命名空间>创建命名空间</h2>
<p>创建一个命名空间，以便将本练习所创建的资源与集群的其余资源相隔离。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create namespace qos-example
</code></pre></div>
<h2 id=创建一个-qos-类为-guaranteed-的-pod>创建一个 QoS 类为 Guaranteed 的 Pod</h2>
<p>对于 QoS 类为 Guaranteed 的 Pod：</p>
<ul>
<li>Pod 中的每个容器都必须指定内存限制和内存请求。</li>
<li>对于 Pod 中的每个容器，内存限制必须等于内存请求。</li>
<li>Pod 中的每个容器都必须指定 CPU 限制和 CPU 请求。</li>
<li>对于 Pod 中的每个容器，CPU 限制必须等于 CPU 请求。</li>
</ul>
<p>这些限制同样适用于初始化容器和应用程序容器。</p>
<p>下面是包含一个容器的 Pod 配置文件。
容器设置了内存请求和内存限制，值都是 200 MiB。
容器设置了 CPU 请求和 CPU 限制，值都是 700 milliCPU：</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/pods/qos/qos-pod.yaml download=pods/qos/qos-pod.yaml><code>pods/qos/qos-pod.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-qos-qos-pod-yaml')" title="Copy pods/qos/qos-pod.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-qos-qos-pod-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>qos-demo<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>qos-example<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>qos-demo-ctr<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;200Mi&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;700m&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;200Mi&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;700m&#34;</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>创建 Pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create -f https://k8s.io/examples/pods/qos/qos-pod.yaml --namespace<span style=color:#666>=</span>qos-example
</code></pre></div>
<p>查看 Pod 详情：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod qos-demo --namespace<span style=color:#666>=</span>qos-example --output<span style=color:#666>=</span>yaml
</code></pre></div>
<p>结果表明 Kubernetes 为 Pod 配置的 QoS 类为 Guaranteed。
结果也确认了 Pod 容器设置了与内存限制匹配的内存请求，设置了与 CPU 限制匹配的 CPU 请求。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>...<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span>700m<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>200Mi<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span>700m<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>200Mi<span style=color:#bbb>
</span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>qosClass</span>:<span style=color:#bbb> </span>Guaranteed<span style=color:#bbb>
</span></code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>Note:</strong>
<p>如果容器指定了自己的内存限制，但没有指定内存请求，Kubernetes 会自动为它指定与内存限制匹配的内存请求。
同样，如果容器指定了自己的 CPU 限制，但没有指定 CPU 请求，Kubernetes 会自动为它指定与 CPU 限制匹配的 CPU 请求。
</div>
<p>删除 Pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete pod qos-demo --namespace<span style=color:#666>=</span>qos-example
</code></pre></div>
<h2 id=创建一个-qos-类为-burstable-的-pod>创建一个 QoS 类为 Burstable 的 Pod</h2>
<p>如果满足下面条件，将会指定 Pod 的 QoS 类为 Burstable：</p>
<ul>
<li>Pod 不符合 Guaranteed QoS 类的标准。</li>
<li>Pod 中至少一个容器具有内存或 CPU 的请求或限制。</li>
</ul>
<p>下面是包含一个容器的 Pod 配置文件。
容器设置了内存限制 200 MiB 和内存请求 100 MiB。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/pods/qos/qos-pod-2.yaml download=pods/qos/qos-pod-2.yaml><code>pods/qos/qos-pod-2.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-qos-qos-pod-2-yaml')" title="Copy pods/qos/qos-pod-2.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-qos-qos-pod-2-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>qos-demo-2<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>qos-example<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>qos-demo-2-ctr<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;200Mi&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;100Mi&#34;</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>创建 Pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create -f https://k8s.io/examples/pods/qos/qos-pod-2.yaml --namespace<span style=color:#666>=</span>qos-example
</code></pre></div>
<p>查看 Pod 详情：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod qos-demo-2 --namespace<span style=color:#666>=</span>qos-example --output<span style=color:#666>=</span>yaml
</code></pre></div>
<p>结果表明 Kubernetes 为 Pod 配置的 QoS 类为 Burstable。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>imagePullPolicy</span>:<span style=color:#bbb> </span>Always<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>qos-demo-2-ctr<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>200Mi<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>100Mi<span style=color:#bbb>
</span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>qosClass</span>:<span style=color:#bbb> </span>Burstable<span style=color:#bbb>
</span></code></pre></div>
<p>删除 Pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete pod qos-demo-2 --namespace<span style=color:#666>=</span>qos-example
</code></pre></div>
<h2 id=创建一个-qos-类为-besteffort-的-pod>创建一个 QoS 类为 BestEffort 的 Pod</h2>
<p>对于 QoS 类为 BestEffort 的 Pod，Pod 中的容器必须没有设置内存和 CPU 限制或请求。</p>
<p>下面是包含一个容器的 Pod 配置文件。
容器没有设置内存和 CPU 限制或请求。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/pods/qos/qos-pod-3.yaml download=pods/qos/qos-pod-3.yaml><code>pods/qos/qos-pod-3.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-qos-qos-pod-3-yaml')" title="Copy pods/qos/qos-pod-3.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-qos-qos-pod-3-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>qos-demo-3<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>qos-example<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>qos-demo-3-ctr<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>创建 Pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create -f https://k8s.io/examples/pods/qos/qos-pod-3.yaml --namespace<span style=color:#666>=</span>qos-example
</code></pre></div>
<p>查看 Pod 详情：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod qos-demo-3 --namespace<span style=color:#666>=</span>qos-example --output<span style=color:#666>=</span>yaml
</code></pre></div>
<p>结果表明 Kubernetes 为 Pod 配置的 QoS 类为 BestEffort。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>...<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>qosClass</span>:<span style=color:#bbb> </span>BestEffort<span style=color:#bbb>
</span></code></pre></div>
<p>删除 Pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete pod qos-demo-3 --namespace<span style=color:#666>=</span>qos-example
</code></pre></div>
<h2 id=创建包含两个容器的-pod>创建包含两个容器的 Pod</h2>
<p>下面是包含两个容器的 Pod 配置文件。
一个容器指定了内存请求 200 MiB。
另外一个容器没有指定任何请求和限制。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/pods/qos/qos-pod-4.yaml download=pods/qos/qos-pod-4.yaml><code>pods/qos/qos-pod-4.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-qos-qos-pod-4-yaml')" title="Copy pods/qos/qos-pod-4.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-qos-qos-pod-4-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>qos-demo-4<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>qos-example<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>qos-demo-4-ctr-1<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;200Mi&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>qos-demo-4-ctr-2<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>注意此 Pod 满足 Burstable QoS 类的标准。
也就是说它不满足 Guaranteed QoS 类标准，因为它的一个容器设有内存请求。</p>
<p>创建 Pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create -f https://k8s.io/examples/pods/qos/qos-pod-4.yaml --namespace<span style=color:#666>=</span>qos-example
</code></pre></div>
<p>查看 Pod 详情：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod qos-demo-4 --namespace<span style=color:#666>=</span>qos-example --output<span style=color:#666>=</span>yaml
</code></pre></div>
<p>结果表明 Kubernetes 为 Pod 配置的 QoS 类为 Burstable：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>...<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>qos-demo-4-ctr-1<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>200Mi<span style=color:#bbb>
</span><span style=color:#bbb>    </span>...<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>qos-demo-4-ctr-2<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span><span style=color:#bbb>    </span>...<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>qosClass</span>:<span style=color:#bbb> </span>Burstable<span style=color:#bbb>
</span></code></pre></div>
<p>删除 Pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete pod qos-demo-4 --namespace<span style=color:#666>=</span>qos-example
</code></pre></div>
<h2 id=环境清理>环境清理</h2>
<p>删除命名空间：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete namespace qos-example
</code></pre></div><h2 id=what-s-next>What's next</h2>
<h3 id=应用开发者参考>应用开发者参考</h3>
<ul>
<li>
<p><a href=/zh/docs/tasks/configure-pod-container/assign-memory-resource/>为 Pod 和容器分配内存资源</a></p>
</li>
<li>
<p><a href=/zh/docs/tasks/configure-pod-container/assign-cpu-resource/>为 Pod 和容器分配 CPU 资源</a></p>
</li>
</ul>
<h3 id=集群管理员参考>集群管理员参考</h3>
<ul>
<li>
<p><a href=/zh/docs/tasks/administer-cluster/manage-resources/memory-default-namespace/>为命名空间配置默认的内存请求和限制</a></p>
</li>
<li>
<p><a href=/zh/docs/tasks/administer-cluster/manage-resources/cpu-default-namespace>为命名空间配置默认的 CPU 请求和限制</a></p>
</li>
<li>
<p><a href=/zh/docs/tasks/administer-cluster/manage-resources/memory-constraint-namespace/>为命名空间配置最小和最大内存限制</a></p>
</li>
<li>
<p><a href=/zh/docs/tasks/administer-cluster/manage-resources/cpu-constraint-namespace/>为命名空间配置最小和最大 CPU 限制</a></p>
</li>
<li>
<p><a href=/zh/docs/tasks/administer-cluster/manage-resources/quota-memory-cpu-namespace/>为命名空间配置内存和 CPU 配额</a></p>
</li>
<li>
<p><a href=/zh/docs/tasks/administer-cluster/manage-resources/quota-pod-namespace/>为命名空间配置 Pod 配额</a></p>
</li>
<li>
<p><a href=/zh/docs/tasks/administer-cluster/quota-api-object/>为 API 对象配置配额</a></p>
</li>
<li>
<p><a href=/zh/docs/tasks/administer-cluster/topology-manager/>控制节点上的拓扑管理策略</a></p>
</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-4219ac6ab56a3b88d20305083d57d03c>5.7 - 为容器分派扩展资源</h1>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.23 [stable]</code>
</div>
<p>本文介绍如何为容器指定扩展资源。</p>
<h2 id=before-you-begin>Before you begin</h2>
<p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li>
</ul>
To check the version, enter <code>kubectl version</code>.
</p>
<p>在你开始此练习前，请先练习
<a href=/zh/docs/tasks/administer-cluster/extended-resource-node/>为节点广播扩展资源</a>。
在那个练习中将配置你的一个节点来广播 dongle 资源。</p>
<h2 id=给-pod-分派扩展资源>给 Pod 分派扩展资源</h2>
<p>要请求扩展资源，需要在你的容器清单中包括 <code>resources:requests</code> 字段。
扩展资源可以使用任何完全限定名称，只是不能使用 <code>*.kubernetes.io/</code>。
有效的扩展资源名的格式为 <code>example.com/foo</code>，其中 <code>example.com</code> 应被替换为
你的组织的域名，而 <code>foo</code> 则是描述性的资源名称。</p>
<p>下面是包含一个容器的 Pod 配置文件：</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/pods/resource/extended-resource-pod.yaml download=pods/resource/extended-resource-pod.yaml><code>pods/resource/extended-resource-pod.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-resource-extended-resource-pod-yaml')" title="Copy pods/resource/extended-resource-pod.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-resource-extended-resource-pod-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>extended-resource-demo<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>extended-resource-demo-ctr<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>example.com/dongle</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>example.com/dongle</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>在配置文件中，你可以看到容器请求了 3 个 dongles。</p>
<p>创建 Pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/pods/resource/extended-resource-pod.yaml
</code></pre></div>
<p>检查 Pod 是否运行正常：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod extended-resource-demo
</code></pre></div>
<p>描述 Pod:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe pod extended-resource-demo
</code></pre></div>
<p>输出结果显示 dongle 请求如下：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>Limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>example.com/dongle</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>Requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>example.com/dongle</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span></code></pre></div>
<h2 id=尝试创建第二个-pod>尝试创建第二个 Pod</h2>
<p>下面是包含一个容器的 Pod 配置文件，容器请求了 2 个 dongles。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/pods/resource/extended-resource-pod-2.yaml download=pods/resource/extended-resource-pod-2.yaml><code>pods/resource/extended-resource-pod-2.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-resource-extended-resource-pod-2-yaml')" title="Copy pods/resource/extended-resource-pod-2.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-resource-extended-resource-pod-2-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>extended-resource-demo-2<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>extended-resource-demo-2-ctr<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>example.com/dongle</span>:<span style=color:#bbb> </span><span style=color:#666>2</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>example.com/dongle</span>:<span style=color:#bbb> </span><span style=color:#666>2</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>Kubernetes 将不能满足 2 个 dongles 的请求，因为第一个 Pod 已经使用了 4 个可用 dongles 中的 3 个。</p>
<p>尝试创建 Pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/pods/resource/extended-resource-pod-2.yaml
</code></pre></div>
<p>描述 Pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe pod extended-resource-demo-2
</code></pre></div>
<p>输出结果表明 Pod 不能被调度，因为没有一个节点上存在两个可用的 dongles。</p>
<pre><code>Conditions:
  Type    Status
  PodScheduled  False
...
Events:
  ...
  ... Warning   FailedScheduling  pod (extended-resource-demo-2) failed to fit in any node
fit failure summary on nodes : Insufficient example.com/dongle (1)
</code></pre>
<p>查看 Pod 的状态：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod extended-resource-demo-2
</code></pre></div>
<p>输出结果表明 Pod 虽然被创建了，但没有被调度到节点上正常运行。Pod 的状态为 Pending：</p>
<pre><code>NAME                       READY     STATUS    RESTARTS   AGE
extended-resource-demo-2   0/1       Pending   0          6m
</code></pre>
<h2 id=清理>清理</h2>
<p>删除本练习中创建的 Pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete pod extended-resource-demo
kubectl delete pod extended-resource-demo-2
</code></pre></div><h2 id=what-s-next>What's next</h2>
<h2 id=应用开发者参考>应用开发者参考</h2>
<ul>
<li><a href=/zh/docs/tasks/configure-pod-container/assign-memory-resource/>为容器和 Pod 分配内存资源</a></li>
<li><a href=/zh/docs/tasks/configure-pod-container/assign-cpu-resource/>为容器和 Pod 分配 CPU 资源</a></li>
</ul>
<h3 id=集群管理员参考>集群管理员参考</h3>
<ul>
<li><a href=/zh/docs/tasks/administer-cluster/extended-resource-node/>为节点广播扩展资源</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-484833fb880d1e179cc2965d15f84da5>5.8 - 配置 Pod 以使用卷进行存储</h1>
<p>此页面展示了如何配置 Pod 以使用卷进行存储。</p>
<p>只要容器存在，容器的文件系统就会存在，因此当一个容器终止并重新启动，对该容器的文件系统改动将丢失。
对于独立于容器的持久化存储，你可以使用<a href=/zh/docs/concepts/storage/volumes/>卷</a>。
这对于有状态应用程序尤为重要，例如键值存储（如 Redis）和数据库。</p>
<h2 id=before-you-begin>Before you begin</h2>
<p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li>
</ul>
To check the version, enter <code>kubectl version</code>.
</p>
<h2 id=configure-a-volume-for-a-pod>为 Pod 配置卷 </h2>
<p>在本练习中，你将创建一个运行 Pod，该 Pod 仅运行一个容器并拥有一个类型为
<a href=/zh/docs/concepts/storage/volumes/#emptydir>emptyDir</a> 的卷，
在整个 Pod 生命周期中一直存在，即使 Pod 中的容器被终止和重启。以下是 Pod 的配置：</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/pods/storage/redis.yaml download=pods/storage/redis.yaml><code>pods/storage/redis.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-storage-redis-yaml')" title="Copy pods/storage/redis.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-storage-redis-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>redis-storage<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/data/redis<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>redis-storage<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>emptyDir</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<ol>
<li>
<p>创建 Pod:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/pods/storage/redis.yaml
</code></pre></div></li>
</ol>
<ol start=2>
<li>
<p>验证 Pod 中的容器是否正在运行，然后留意 Pod 的更改：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod redis --watch
</code></pre></div><p>输出如下：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>NAME      READY     STATUS    RESTARTS   AGE
redis     1/1       Running   <span style=color:#666>0</span>          13s
</code></pre></div></li>
</ol>
<ol start=3>
<li>
<p>在另一个终端，用 shell 连接正在运行的容器：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#a2f>exec</span> -it redis -- /bin/bash
</code></pre></div></li>
</ol>
<ol start=4>
<li>
<p>在你的 Shell中，切换到 <code>/data/redis</code> 目录下，然后创建一个文件：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>root@redis:/data# <span style=color:#a2f>cd</span> /data/redis/
root@redis:/data/redis# <span style=color:#a2f>echo</span> Hello &gt; test-file
</code></pre></div></li>
</ol>
<ol start=5>
<li>
<p>在你的 Shell 中，列出正在运行的进程：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>root@redis:/data/redis# apt-get update
root@redis:/data/redis# apt-get install procps
root@redis:/data/redis# ps aux
</code></pre></div><p>输出类似于：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
redis        <span style=color:#666>1</span>  0.1  0.1  <span style=color:#666>33308</span>  <span style=color:#666>3828</span> ?        Ssl  00:46   0:00 redis-server *:6379
root        <span style=color:#666>12</span>  0.0  0.0  <span style=color:#666>20228</span>  <span style=color:#666>3020</span> ?        Ss   00:47   0:00 /bin/bash
root        <span style=color:#666>15</span>  0.0  0.0  <span style=color:#666>17500</span>  <span style=color:#666>2072</span> ?        R+   00:48   0:00 ps aux
</code></pre></div></li>
</ol>
<ol start=6>
<li>
<p>在你的 Shell 中，结束 Redis 进程：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>root@redis:/data/redis# <span style=color:#a2f>kill</span> &lt;pid&gt;
</code></pre></div><p>其中 <code>&lt;pid></code> 是 Redis 进程的 ID (PID)。</p>
</li>
</ol>
<ol start=7>
<li>
<p>在你原先终端中，留意 Redis Pod 的更改。最终你将会看到和下面类似的输出：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>NAME      READY     STATUS     RESTARTS   AGE
redis     1/1       Running    <span style=color:#666>0</span>          13s
redis     0/1       Completed  <span style=color:#666>0</span>         6m
redis     1/1       Running    <span style=color:#666>1</span>         6m
</code></pre></div></li>
</ol>
<p>此时，容器已经终止并重新启动。这是因为 Redis Pod 的
<a href=/docs/reference/generated/kubernetes-api/v1.23/#podspec-v1-core>restartPolicy</a>
为 <code>Always</code>。</p>
<ol>
<li>
<p>用 Shell 进入重新启动的容器中：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#a2f>exec</span> -it redis -- /bin/bash
</code></pre></div></li>
</ol>
<ol start=2>
<li>
<p>在你的 Shell 中，进入到 <code>/data/redis</code> 目录下，并确认 <code>test-file</code> 文件是否仍然存在。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>root@redis:/data/redis# <span style=color:#a2f>cd</span> /data/redis/
root@redis:/data/redis# ls
test-file
</code></pre></div></li>
</ol>
<ol start=3>
<li>
<p>删除为此练习所创建的 Pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete pod redis
</code></pre></div></li>
</ol>
<h2 id=what-s-next>What's next</h2>
<ul>
<li>参阅 <a href=/docs/reference/generated/kubernetes-api/v1.23/#volume-v1-core>Volume</a>。</li>
<li>参阅 <a href=/docs/reference/generated/kubernetes-api/v1.23/#pod-v1-core>Pod</a>。</li>
<li>除了 <code>emptyDir</code> 提供的本地磁盘存储外，Kubernetes 还支持许多不同的网络附加存储解决方案，
包括 GCE 上的 PD 和 EC2 上的 EBS，它们是关键数据的首选，并将处理节点上的一些细节，
例如安装和卸载设备。了解更多详情请参阅<a href=/zh/docs/concepts/storage/volumes/>卷</a>。</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-528d2422215cb9632b7b45e886b023b5>5.9 - 配置 Pod 以使用 PersistentVolume 作为存储</h1>
<p>本文介绍如何配置 Pod 使用
<a class=glossary-tooltip title=声明在持久卷中定义的存储资源，以便可以将其挂载为容器中的卷。 data-toggle=tooltip data-placement=top href=/zh/docs/concepts/storage/persistent-volumes/ target=_blank aria-label=PersistentVolumeClaim>PersistentVolumeClaim</a>
作为存储。
以下是该过程的总结：</p>
<ol>
<li>
<p>你作为集群管理员创建由物理存储支持的 PersistentVolume。你不会将卷与任何 Pod 关联。</p>
</li>
<li>
<p>你现在以开发人员或者集群用户的角色创建一个 PersistentVolumeClaim，
它将自动绑定到合适的 PersistentVolume。</p>
</li>
<li>
<p>你创建一个使用 PersistentVolumeClaim 作为存储的 Pod。</p>
</li>
</ol>
<h2 id=before-you-begin>Before you begin</h2>
<ul>
<li>你需要一个包含单个节点的 Kubernetes 集群，并且必须配置 kubectl 命令行工具以便与集群交互。
如果还没有单节点集群，可以使用
<a href=https://minikube.sigs.k8s.io/docs/>Minikube</a> 创建一个。
.</li>
<li>熟悉<a href=/zh/docs/concepts/storage/persistent-volumes/>持久卷</a>中的材料。</li>
</ul>
<h2 id=在你的节点上创建一个-index-html-文件>在你的节点上创建一个 index.html 文件</h2>
<p>打开集群中节点的一个 Shell。
如何打开 Shell 取决于集群的设置。
例如，如果你正在使用 Minikube，那么可以通过输入 <code>minikube ssh</code> 来打开节点的 Shell。</p>
<p>在 Shell 中，创建一个 <code>/mnt/data</code> 目录：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># 这里假定你的节点使用 &#34;sudo&#34; 来以超级用户角色执行命令</span>
sudo mkdir /mnt/data
</code></pre></div>
<p>在 <code>/mnt/data</code> 目录中创建一个 index.html 文件：</p>
<pre><code># 这里再次假定你的节点使用 &quot;sudo&quot; 来以超级用户角色执行命令
sudo sh -c &quot;echo 'Hello from Kubernetes storage' &gt; /mnt/data/index.html&quot;
</code></pre>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 如果你的节点使用某工具而不是 <code>sudo</code> 来完成超级用户访问，你可以将上述命令
中的 <code>sudo</code> 替换为该工具的名称。
</div>
<p>测试 <code>index.html</code> 文件确实存在：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>cat /mnt/data/index.html
</code></pre></div>
<p>输出应该是：</p>
<pre><code>Hello from Kubernetes storage
</code></pre>
<p>现在你可以关闭节点的 Shell 了。</p>
<h2 id=创建-persistentvolume>创建 PersistentVolume</h2>
<p>在本练习中，你将创建一个 <em>hostPath</em> 类型的 PersistentVolume。
Kubernetes 支持用于在单节点集群上开发和测试的 hostPath 类型的 PersistentVolume。
hostPath 类型的 PersistentVolume 使用节点上的文件或目录来模拟网络附加存储。</p>
<p>在生产集群中，你不会使用 hostPath。
集群管理员会提供网络存储资源，比如 Google Compute Engine 持久盘卷、NFS 共享卷或 Amazon Elastic Block Store 卷。
集群管理员还可以使用 <a href=/docs/reference/generated/kubernetes-api/v1.23/#storageclass-v1-storage>StorageClasses</a> 来设置<a href=https://kubernetes.io/blog/2016/10/dynamic-provisioning-and-storage-in-kubernetes>动态提供存储</a>。</p>
<p>下面是 hostPath PersistentVolume 的配置文件：</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/pods/storage/pv-volume.yaml download=pods/storage/pv-volume.yaml><code>pods/storage/pv-volume.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-storage-pv-volume-yaml')" title="Copy pods/storage/pv-volume.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-storage-pv-volume-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolume<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>task-pv-volume<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>local<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>storageClassName</span>:<span style=color:#bbb> </span>manual<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>capacity</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>10Gi<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- ReadWriteOnce<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>hostPath</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/mnt/data&#34;</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>创建 PersistentVolume：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/pods/storage/pv-volume.yaml
</code></pre></div>
<p>查看 PersistentVolume 的信息：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pv task-pv-volume
</code></pre></div>
<p>输出结果显示该 PersistentVolume 的<code>状态（STATUS）</code> 为 <code>Available</code>。
这意味着它还没有被绑定给 PersistentVolumeClaim。</p>
<pre><code>NAME             CAPACITY   ACCESSMODES   RECLAIMPOLICY   STATUS      CLAIM     STORAGECLASS   REASON    AGE
task-pv-volume   10Gi       RWO           Retain          Available             manual                   4s
</code></pre>
<h2 id=创建-persistentvolumeclaim>创建 PersistentVolumeClaim</h2>
<p>下一步是创建一个 PersistentVolumeClaim。
Pod 使用 PersistentVolumeClaim 来请求物理存储。
在本练习中，你将创建一个 PersistentVolumeClaim，它请求至少 3 GB 容量的卷，
该卷至少可以为一个节点提供读写访问。</p>
<p>下面是 PersistentVolumeClaim 的配置文件：</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/pods/storage/pv-claim.yaml download=pods/storage/pv-claim.yaml><code>pods/storage/pv-claim.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-storage-pv-claim-yaml')" title="Copy pods/storage/pv-claim.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-storage-pv-claim-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolumeClaim<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>task-pv-claim<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>storageClassName</span>:<span style=color:#bbb> </span>manual<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- ReadWriteOnce<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>3Gi<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>创建 PersistentVolumeClaim：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create -f https://k8s.io/examples/pods/storage/pv-claim.yaml
</code></pre></div>
<p>创建 PersistentVolumeClaim 之后，Kubernetes 控制平面将查找满足申领要求的 PersistentVolume。
如果控制平面找到具有相同 StorageClass 的适当的 PersistentVolume，
则将 PersistentVolumeClaim 绑定到该 PersistentVolume 上。</p>
<p>再次查看 PersistentVolume 信息：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pv task-pv-volume
</code></pre></div>
<p>现在输出的 <code>STATUS</code> 为 <code>Bound</code>。</p>
<pre><code>NAME             CAPACITY   ACCESSMODES   RECLAIMPOLICY   STATUS    CLAIM                   STORAGECLASS   REASON    AGE
task-pv-volume   10Gi       RWO           Retain          Bound     default/task-pv-claim   manual                   2m
</code></pre>
<p>查看 PersistentVolumeClaim：</p>
<pre><code>kubectl get pvc task-pv-claim
</code></pre>
<p>输出结果表明该 PersistentVolumeClaim 绑定了你的 PersistentVolume <code>task-pv-volume</code>。</p>
<pre><code>NAME            STATUS    VOLUME           CAPACITY   ACCESSMODES   STORAGECLASS   AGE
task-pv-claim   Bound     task-pv-volume   10Gi       RWO           manual         30s
</code></pre>
<h2 id=创建-pod>创建 Pod</h2>
<p>下一步是创建一个 Pod， 该 Pod 使用你的 PersistentVolumeClaim 作为存储卷。</p>
<p>下面是 Pod 的 配置文件：</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/pods/storage/pv-pod.yaml download=pods/storage/pv-pod.yaml><code>pods/storage/pv-pod.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-storage-pv-pod-yaml')" title="Copy pods/storage/pv-pod.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-storage-pv-pod-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>task-pv-pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>task-pv-storage<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>persistentVolumeClaim</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>claimName</span>:<span style=color:#bbb> </span>task-pv-claim<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>task-pv-container<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;http-server&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/usr/share/nginx/html&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>task-pv-storage<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>注意 Pod 的配置文件指定了 PersistentVolumeClaim，但没有指定 PersistentVolume。
对 Pod 而言，PersistentVolumeClaim 就是一个存储卷。</p>
<p>创建 Pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/pods/storage/pv-pod.yaml
</code></pre></div>
<p>检查 Pod 中的容器是否运行正常：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod task-pv-pod
</code></pre></div>
<p>打开一个 Shell 访问 Pod 中的容器：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#a2f>exec</span> -it task-pv-pod -- /bin/bash
</code></pre></div>
<p>在 Shell 中，验证 nginx 是否正在从 hostPath 卷提供 <code>index.html</code> 文件：</p>
<pre><code># 一定要在上一步 &quot;kubectl exec&quot; 所返回的 Shell 中执行下面三个命令
root@task-pv-pod:/# apt-get update
root@task-pv-pod:/# apt-get install curl
root@task-pv-pod:/# curl localhost
</code></pre>
<p>输出结果是你之前写到 hostPath 卷中的 <code>index.html</code> 文件中的内容：</p>
<pre><code>Hello from Kubernetes storage
</code></pre>
<p>如果你看到此消息，则证明你已经成功地配置了 Pod 使用 PersistentVolumeClaim
的存储。</p>
<h2 id=clean-up>清理 </h2>
<p>删除 Pod、PersistentVolumeClaim 和 PersistentVolume 对象：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete pod task-pv-pod
kubectl delete pvc task-pv-claim
kubectl delete pv task-pv-volume
</code></pre></div>
<p>如果你还没有连接到集群中节点的 Shell，可以按之前所做操作，打开一个新的 Shell。</p>
<p>在节点的 Shell 上，删除你所创建的目录和文件：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># 这里假定你使用 &#34;sudo&#34; 来以超级用户的角色执行命令</span>
sudo rm /mnt/data/index.html
sudo rmdir /mnt/data
</code></pre></div>
<p>你现在可以关闭连接到节点的 Shell。</p>
<h2 id=在两个地方挂载相同的-persistentvolume>在两个地方挂载相同的 persistentVolume</h2>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/pods/storage/pv-duplicate.yaml download=pods/storage/pv-duplicate.yaml><code>pods/storage/pv-duplicate.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-storage-pv-duplicate-yaml')" title="Copy pods/storage/pv-duplicate.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-storage-pv-duplicate-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># 网站数据挂载</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>config<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/usr/share/nginx/html<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>subPath</span>:<span style=color:#bbb> </span>html<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># Nginx 配置挂载</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>config<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/etc/nginx/nginx.conf<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>subPath</span>:<span style=color:#bbb> </span>nginx.conf<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>config<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>persistentVolumeClaim</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>claimName</span>:<span style=color:#bbb> </span>test-nfs-claim<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>你可以在 nginx 容器上执行两个卷挂载:</p>
<p><code>/usr/share/nginx/html</code> 用于静态网站
<code>/etc/nginx/nginx.conf</code> 作为默认配置</p>
<h2 id=access-control>访问控制 </h2>
<p>使用组 ID（GID）配置的存储仅允许 Pod 使用相同的 GID 进行写入。
GID 不匹配或缺失将会导致无权访问错误。
为了减少与用户的协调，管理员可以对 PersistentVolume 添加 GID 注解。
这样 GID 就能自动添加到使用 PersistentVolume 的任何 Pod 中。</p>
<p>使用 <code>pv.beta.kubernetes.io/gid</code> 注解的方法如下所示：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolume<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pv1<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>pv.beta.kubernetes.io/gid</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;1234&#34;</span><span style=color:#bbb>
</span></code></pre></div>
<p>当 Pod 使用带有 GID 注解的 PersistentVolume 时，注解的 GID 会被应用于 Pod 中的所有容器，
应用的方法与 Pod 的安全上下文中指定的 GID 相同。
每个 GID，无论是来自 PersistentVolume 注解还是来自 Pod 规约，都会被应用于每个容器中
运行的第一个进程。</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 当 Pod 使用 PersistentVolume 时，与 PersistentVolume 关联的 GID 不会在 Pod
资源本身的对象上出现。
</div>
<h2 id=what-s-next>What's next</h2>
<ul>
<li>进一步了解 <a href=/zh/docs/concepts/storage/persistent-volumes/>PersistentVolumes</a></li>
<li>阅读<a href=https://git.k8s.io/community/contributors/design-proposals/storage/persistent-storage.md>持久存储设计文档</a></li>
</ul>
<h3 id=参考>参考</h3>
<ul>
<li><a href=/docs/reference/generated/kubernetes-api/v1.23/#persistentvolume-v1-core>PersistentVolume</a></li>
<li><a href=/docs/reference/generated/kubernetes-api/v1.23/#persistentvolumespec-v1-core>PersistentVolumeSpec</a></li>
<li><a href=/docs/reference/generated/kubernetes-api/v1.23/#persistentvolumeclaim-v1-core>PersistentVolumeClaim</a></li>
<li><a href=/docs/reference/generated/kubernetes-api/v1.23/#persistentvolumeclaimspec-v1-core>PersistentVolumeClaimSpec</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-4621938ba53c04a77f51b5938a583439>5.10 - 配置 Pod 使用投射卷作存储</h1>
<p>本文介绍怎样通过<a href=/zh/docs/concepts/storage/volumes/#projected><code>projected</code></a> 卷将现有的多个卷资源挂载到相同的目录。
当前，<code>secret</code>、<code>configMap</code>、<code>downwardAPI</code> 和 <code>serviceAccountToken</code> 卷可以被投射。</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> <code>serviceAccountToken</code> 不是一种卷类型
</div>
<h2 id=before-you-begin>Before you begin</h2>
<p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li>
</ul>
To check the version, enter <code>kubectl version</code>.
</p>
<h2 id=为-pod-配置-projected-卷>为 Pod 配置 projected 卷</h2>
<p>本练习中，您将从本地文件来创建包含有用户名和密码的 Secret。然后创建运行一个容器的 Pod，
该 Pod 使用<a href=/zh/docs/concepts/storage/volumes/#projected><code>projected</code></a> 卷将 Secret 挂载到相同的路径下。</p>
<p>下面是 Pod 的配置文件：</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/pods/storage/projected.yaml download=pods/storage/projected.yaml><code>pods/storage/projected.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-storage-projected-yaml')" title="Copy pods/storage/projected.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-storage-projected-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-projected-volume<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-projected-volume<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox:1.28<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- sleep<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;86400&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>all-in-one<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/projected-volume&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>all-in-one<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>projected</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>sources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>secret</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>user<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>secret</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pass<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<ol>
<li>
<p>创建 Secret:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># 创建包含用户名和密码的文件:</span>
<span style=color:#a2f>echo</span> -n <span style=color:#b44>&#34;admin&#34;</span> &gt; ./username.txt
<span style=color:#a2f>echo</span> -n <span style=color:#b44>&#34;1f2d1e2e67df&#34;</span> &gt; ./password.txt

<span style=color:#080;font-style:italic># 将上述文件引用到 Secret：</span>
kubectl create secret generic user --from-file<span style=color:#666>=</span>./username.txt
kubectl create secret generic pass --from-file<span style=color:#666>=</span>./password.txt
</code></pre></div></li>
<li>
<p>创建 Pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create -f https://k8s.io/examples/pods/storage/projected.yaml
</code></pre></div></li>
<li>
<p>确认 Pod 中的容器运行正常，然后监视 Pod 的变化：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get --watch pod test-projected-volume
</code></pre></div>
<p>输出结果和下面类似：</p>
<pre><code>NAME                    READY     STATUS    RESTARTS   AGE
test-projected-volume   1/1       Running   0          14s
</code></pre></li>
<li>
<p>在另外一个终端中，打开容器的 shell：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#a2f>exec</span> -it test-projected-volume -- /bin/sh
</code></pre></div></li>
<li>
<p>在 shell 中，确认 <code>projected-volume</code> 目录包含你的投射源：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>ls /projected-volume/
</code></pre></div></li>
</ol>
<h2 id=清理>清理</h2>
<p>删除 Pod 和 Secret:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete pod test-projected-volume
kubectl delete secret user pass
</code></pre></div><h2 id=what-s-next>What's next</h2>
<ul>
<li>进一步了解<a href=/zh/docs/concepts/storage/volumes/#projected><code>projected</code></a> 卷。</li>
<li>阅读<a href=https://github.com/kubernetes/community/blob/master/contributors/design-proposals/node/all-in-one-volume.md>一体卷</a>设计文档。</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-abd895c0803315e9717e6ff9ec4e3d30>5.11 - 为 Pod 或容器配置安全上下文</h1>
<p>安全上下文（Security Context）定义 Pod 或 Container 的特权与访问控制设置。
安全上下文包括但不限于：</p>
<ul>
<li>自主访问控制（Discretionary Access Control）：
基于<a href=https://wiki.archlinux.org/index.php/users_and_groups>用户 ID（UID）和组 ID（GID）</a>
来判定对对象（例如文件）的访问权限。</li>
<li><a href=https://zh.wikipedia.org/wiki/%E5%AE%89%E5%85%A8%E5%A2%9E%E5%BC%BA%E5%BC%8FLinux>安全性增强的 Linux（SELinux）</a>：
为对象赋予安全性标签。</li>
<li>以特权模式或者非特权模式运行。</li>
<li><a href=https://linux-audit.com/linux-capabilities-hardening-linux-binaries-by-removing-setuid/>Linux 权能</a>:
为进程赋予 root 用户的部分特权而非全部特权。</li>
</ul>
<ul>
<li>
<p><a href=/zh/docs/tutorials/security/apparmor/>AppArmor</a>：使用程序配置来限制个别程序的权能。</p>
</li>
<li>
<p><a href=/zh/docs/tutorials/security/seccomp/>Seccomp</a>：过滤进程的系统调用。</p>
</li>
<li>
<p><code>allowPrivilegeEscalation</code>：控制进程是否可以获得超出其父进程的特权。
此布尔值直接控制是否为容器进程设置
<a href=https://www.kernel.org/doc/Documentation/prctl/no_new_privs.txt><code>no_new_privs</code></a>标志。
当容器满足一下条件之一时，<code>allowPrivilegeEscalation</code> 总是为 true：</p>
<ul>
<li>以特权模式运行，或者</li>
<li>具有 <code>CAP_SYS_ADMIN</code> 权能</li>
</ul>
</li>
<li>
<p>readOnlyRootFilesystem：以只读方式加载容器的根文件系统。</p>
</li>
</ul>
<p>以上条目不是安全上下文设置的完整列表 -- 请参阅
<a href=/docs/reference/generated/kubernetes-api/v1.23/#securitycontext-v1-core>SecurityContext</a>
了解其完整列表。</p>
<h2 id=before-you-begin>Before you begin</h2>
<p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li>
</ul>
To check the version, enter <code>kubectl version</code>.
</p>
<h2 id=set-the-security-context-for-a-pod>为 Pod 设置安全性上下文 </h2>
<p>要为 Pod 设置安全性设置，可在 Pod 规约中包含 <code>securityContext</code> 字段。<code>securityContext</code> 字段值是一个
<a href=/docs/reference/generated/kubernetes-api/v1.23/#podsecuritycontext-v1-core>PodSecurityContext</a>
对象。你为 Pod 所设置的安全性配置会应用到 Pod 中所有 Container 上。
下面是一个 Pod 的配置文件，该 Pod 定义了 <code>securityContext</code> 和一个 <code>emptyDir</code> 卷：</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/pods/security/security-context.yaml download=pods/security/security-context.yaml><code>pods/security/security-context.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-security-security-context-yaml')" title="Copy pods/security/security-context.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-security-security-context-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>security-context-demo<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>securityContext</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>runAsUser</span>:<span style=color:#bbb> </span><span style=color:#666>1000</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>runAsGroup</span>:<span style=color:#bbb> </span><span style=color:#666>3000</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>fsGroup</span>:<span style=color:#bbb> </span><span style=color:#666>2000</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>sec-ctx-vol<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>emptyDir</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>sec-ctx-demo<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox:1.28<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#bbb> </span><span style=color:#b44>&#34;sh&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;-c&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;sleep 1h&#34;</span><span style=color:#bbb> </span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>sec-ctx-vol<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/data/demo<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>securityContext</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>allowPrivilegeEscalation</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>false</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>在配置文件中，<code>runAsUser</code> 字段指定 Pod 中的所有容器内的进程都使用用户 ID 1000
来运行。<code>runAsGroup</code> 字段指定所有容器中的进程都以主组 ID 3000 来运行。
如果忽略此字段，则容器的主组 ID 将是 root（0）。
当 <code>runAsGroup</code> 被设置时，所有创建的文件也会划归用户 1000 和组 3000。
由于 <code>fsGroup</code> 被设置，容器中所有进程也会是附组 ID 2000 的一部分。
卷 <code>/data/demo</code> 及在该卷中创建的任何文件的属主都会是组 ID 2000。</p>
<p>创建该 Pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/pods/security/security-context.yaml
</code></pre></div>
<p>检查 Pod 的容器处于运行状态：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod security-context-demo
</code></pre></div>
<p>开启一个 Shell 进入到运行中的容器：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#a2f>exec</span> -it security-context-demo -- sh
</code></pre></div>
<p>在你的 Shell 中，列举运行中的进程：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>ps
</code></pre></div>
<p>输出显示进程以用户 1000 运行，即 <code>runAsUser</code> 所设置的值：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>PID   USER     TIME  COMMAND
    <span style=color:#666>1</span> <span style=color:#666>1000</span>      0:00 sleep 1h
    <span style=color:#666>6</span> <span style=color:#666>1000</span>      0:00 sh
...
</code></pre></div>
<p>在你的 Shell 中，进入 <code>/data</code> 目录列举其内容：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#a2f>cd</span> /data
ls -l
</code></pre></div>
<p>输出显示 <code>/data/demo</code> 目录的组 ID 为 2000，即 <code>fsGroup</code> 的设置值：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>drwxrwsrwx <span style=color:#666>2</span> root <span style=color:#666>2000</span> <span style=color:#666>4096</span> Jun  <span style=color:#666>6</span> 20:08 demo
</code></pre></div>
<p>在你的 Shell 中，进入到 <code>/data/demo</code> 目录下创建一个文件：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#a2f>cd</span> demo
<span style=color:#a2f>echo</span> hello &gt; testfile
</code></pre></div>
<p>列举 <code>/data/demo</code> 目录下的文件：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>ls -l
</code></pre></div>
<p>输出显示 <code>testfile</code> 的组 ID 为 2000，也就是 <code>fsGroup</code> 所设置的值：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>-rw-r--r-- <span style=color:#666>1</span> <span style=color:#666>1000</span> <span style=color:#666>2000</span> <span style=color:#666>6</span> Jun  <span style=color:#666>6</span> 20:08 testfile
</code></pre></div>
<p>运行下面的命令：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>id
</code></pre></div>
<p>输出类似于：</p>
<pre><code class=language-none data-lang=none>uid=1000 gid=3000 groups=2000
</code></pre>
<p>从输出中你会看到 <code>gid</code> 值为 3000，也就是 <code>runAsGroup</code> 字段的值。
如果 <code>runAsGroup</code> 被忽略，则 <code>gid</code> 会取值 0（root），而进程就能够与 root
用户组所拥有以及要求 root 用户组访问权限的文件交互。</p>
<p>退出你的 Shell：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#a2f>exit</span>
</code></pre></div>
<h2 id=为-pod-配置卷访问权限和属主变更策略>为 Pod 配置卷访问权限和属主变更策略</h2>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.23 [stable]</code>
</div>
<p>默认情况下，Kubernetes 在挂载一个卷时，会递归地更改每个卷中的内容的属主和访问权限，
使之与 Pod 的 <code>securityContext</code> 中指定的 <code>fsGroup</code> 匹配。
对于较大的数据卷，检查和变更属主与访问权限可能会花费很长时间，降低 Pod 启动速度。
你可以在 <code>securityContext</code> 中使用 <code>fsGroupChangePolicy</code> 字段来控制 Kubernetes
检查和管理卷属主和访问权限的方式。</p>
<p><strong>fsGroupChangePolicy</strong> - <code>fsGroupChangePolicy</code> 定义在卷被暴露给 Pod 内部之前对其
内容的属主和访问许可进行变更的行为。此字段仅适用于那些支持使用 <code>fsGroup</code> 来
控制属主与访问权限的卷类型。此字段的取值可以是：</p>
<ul>
<li><code>OnRootMismatch</code>：只有根目录的属主与访问权限与卷所期望的权限不一致时，
才改变其中内容的属主和访问权限。这一设置有助于缩短更改卷的属主与访问
权限所需要的时间。</li>
<li><code>Always</code>：在挂载卷时总是更改卷中内容的属主和访问权限。</li>
</ul>
<p>例如：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>securityContext</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>runAsUser</span>:<span style=color:#bbb> </span><span style=color:#666>1000</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>runAsGroup</span>:<span style=color:#bbb> </span><span style=color:#666>3000</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>fsGroup</span>:<span style=color:#bbb> </span><span style=color:#666>2000</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>fsGroupChangePolicy</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;OnRootMismatch&#34;</span><span style=color:#bbb>
</span></code></pre></div>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 此字段对于 <a href=/zh/docs/concepts/storage/volumes/#secret><code>secret</code></a>、
<a href=/zh/docs/concepts/storage/volumes/#configmap><code>configMap</code></a>
和 <a href=/zh/docs/concepts/storage/volumes/#emptydir><code>emptydir</code></a>
这类临时性存储无效。
</div>
<h2 id=将卷权限和所有权更改委派给-csi-驱动程序>将卷权限和所有权更改委派给 CSI 驱动程序</h2>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.23 [beta]</code>
</div>
<p>如果你部署了一个<a href=https://github.com/container-storage-interface/spec/blob/master/spec.md>容器存储接口 (CSI)</a>
驱动，而该驱动支持 <code>VOLUME_MOUNT_GROUP</code> <code>NodeServiceCapability</code>，
在 <code>securityContext</code> 中指定 <code>fsGroup</code> 来设置文件所有权和权限的过程将由 CSI
驱动而不是 Kubernetes 来执行，前提是 Kubernetes 的 <code>DelegateFSGroupToCSIDriver</code>
特性门控已启用。在这种情况下，由于 Kubernetes 不执行任何所有权和权限更改，
<code>fsGroupChangePolicy</code> 不会生效，并且按照 CSI 的规定，CSI 驱动应该使用所指定的
<code>fsGroup</code> 来挂载卷，从而生成了一个对 <code>fsGroup</code> 可读/可写的卷.</p>
<p>更多的信息请参考 <a href=https://github.com/gnufied/enhancements/blob/master/keps/sig-storage/2317-fsgroup-on-mount/README.md>KEP</a>
和 <a href=https://github.com/container-storage-interface/spec/blob/master/spec.md#createvolume>CSI 规范</a>
中的字段 <code>VolumeCapability.MountVolume.volume_mount_group</code> 的描述。</p>
<h2 id=set-the-security-context-for-a-container>为 Container 设置安全性上下文 </h2>
<p>若要为 Container 设置安全性配置，可以在 Container 清单中包含 <code>securityContext</code>
字段。<code>securityContext</code> 字段的取值是一个
<a href=/docs/reference/generated/kubernetes-api/v1.23/#securitycontext-v1-core>SecurityContext</a>
对象。你为 Container 设置的安全性配置仅适用于该容器本身，并且所指定的设置在与
Pod 层面设置的内容发生重叠时，会重载后者。Container 层面的设置不会影响到 Pod 的卷。</p>
<p>下面是一个 Pod 的配置文件，其中包含一个 Container。Pod 和 Container 都有
<code>securityContext</code> 字段：</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/pods/security/security-context-2.yaml download=pods/security/security-context-2.yaml><code>pods/security/security-context-2.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-security-security-context-2-yaml')" title="Copy pods/security/security-context-2.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-security-security-context-2-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>security-context-demo-2<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>securityContext</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>runAsUser</span>:<span style=color:#bbb> </span><span style=color:#666>1000</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>sec-ctx-demo-2<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>gcr.io/google-samples/node-hello:1.0<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>securityContext</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>runAsUser</span>:<span style=color:#bbb> </span><span style=color:#666>2000</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>allowPrivilegeEscalation</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>false</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>创建该 Pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/pods/security/security-context-2.yaml
</code></pre></div>
<p>验证 Pod 中的容器处于运行状态：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod security-context-demo-2
</code></pre></div>
<p>启动一个 Shell 进入到运行中的容器内：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#a2f>exec</span> -it security-context-demo-2 -- sh
</code></pre></div>
<p>在你的 Shell 中，列举运行中的进程：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>ps aux
</code></pre></div>
<p>输出显示进程以用户 2000 运行。该值是在 Container 的 <code>runAsUser</code> 中设置的。
该设置值重载了 Pod 层面所设置的值 1000。</p>
<pre><code>USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
2000         1  0.0  0.0   4336   764 ?        Ss   20:36   0:00 /bin/sh -c node server.js
2000         8  0.1  0.5 772124 22604 ?        Sl   20:36   0:00 node server.js
...
</code></pre>
<p>退出你的 Shell：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#a2f>exit</span>
</code></pre></div>
<h2 id=set-capabilities-for-a-container>为 Container 设置权能 </h2>
<p>使用 <a href=https://man7.org/linux/man-pages/man7/capabilities.7.html>Linux 权能</a>，
你可以赋予进程 root 用户所拥有的某些特权，但不必赋予其全部特权。
要为 Container 添加或移除 Linux 权能，可以在 Container 清单的 <code>securityContext</code>
节包含 <code>capabilities</code> 字段。</p>
<p>首先，看一下不包含 <code>capabilities</code> 字段时候会发生什么。
下面是一个配置文件，其中没有添加或移除容器的权能：</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/pods/security/security-context-3.yaml download=pods/security/security-context-3.yaml><code>pods/security/security-context-3.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-security-security-context-3-yaml')" title="Copy pods/security/security-context-3.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-security-security-context-3-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>security-context-demo-3<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>sec-ctx-3<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>gcr.io/google-samples/node-hello:1.0<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>创建该 Pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/pods/security/security-context-3.yaml
</code></pre></div>
<p>验证 Pod 的容器处于运行状态：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod security-context-demo-3
</code></pre></div>
<p>启动一个 Shell 进入到运行中的容器：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#a2f>exec</span> -it security-context-demo-3 -- sh
</code></pre></div>
<p>在你的 Shell 中，列举运行中的进程：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>ps aux
</code></pre></div>
<p>输出显示容器中进程 ID（PIDs）：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>USER  PID %CPU %MEM    VSZ   RSS TTY   STAT START   TIME COMMAND
root    <span style=color:#666>1</span>  0.0  0.0   <span style=color:#666>4336</span>   <span style=color:#666>796</span> ?     Ss   18:17   0:00 /bin/sh -c node server.js
root    <span style=color:#666>5</span>  0.1  0.5 <span style=color:#666>772124</span> <span style=color:#666>22700</span> ?     Sl   18:17   0:00 node server.js
</code></pre></div>
<p>在你的 Shell 中，查看进程 1 的状态：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#a2f>cd</span> /proc/1
cat status
</code></pre></div>
<p>输出显示进程的权能位图：</p>
<pre><code>...
CapPrm:	00000000a80425fb
CapEff:	00000000a80425fb
...
</code></pre>
<p>记下进程权能位图，之后退出你的 Shell：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#a2f>exit</span>
</code></pre></div>
<p>接下来运行一个与前例中容器相同的容器，只是这个容器有一些额外的权能设置。</p>
<p>下面是一个 Pod 的配置，其中运行一个容器。配置为容器添加 <code>CAP_NET_ADMIN</code> 和
<code>CAP_SYS_TIME</code> 权能：</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/pods/security/security-context-4.yaml download=pods/security/security-context-4.yaml><code>pods/security/security-context-4.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-security-security-context-4-yaml')" title="Copy pods/security/security-context-4.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-security-security-context-4-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>security-context-demo-4<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>sec-ctx-4<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>gcr.io/google-samples/node-hello:1.0<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>securityContext</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>capabilities</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>add</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;NET_ADMIN&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;SYS_TIME&#34;</span>]<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>创建 Pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/pods/security/security-context-4.yaml
</code></pre></div>
<p>启动一个 Shell，进入到运行中的容器：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#a2f>exec</span> -it security-context-demo-4 -- sh
</code></pre></div>
<p>在你的 Shell 中，查看进程 1 的权能：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#a2f>cd</span> /proc/1
cat status
</code></pre></div>
<p>输出显示的是进程的权能位图：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>...
CapPrm:	00000000aa0435fb
CapEff:	00000000aa0435fb
...
</code></pre></div>
<p>比较两个容器的权能位图：</p>
<pre><code>00000000a80425fb
00000000aa0435fb
</code></pre>
<p>在第一个容器的权能位图中，位 12 和 25 是没有设置的。在第二个容器中，位 12
和 25 是设置了的。位 12 是 <code>CAP_NET_ADMIN</code> 而位 25 则是 <code>CAP_SYS_TIME</code>。
参见 <a href=https://github.com/torvalds/linux/blob/master/include/uapi/linux/capability.h>capability.h</a>
了解权能常数的定义。</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> Linux 权能常数定义的形式为 <code>CAP_XXX</code>。但是你在 Container 清单中列举权能时，
要将权能名称中的 <code>CAP_</code> 部分去掉。例如，要添加 <code>CAP_SYS_TIME</code>，
可在权能列表中添加 <code>SYS_TIME</code>。
</div>
<h2 id=为容器设置-seccomp-配置>为容器设置 Seccomp 配置</h2>
<p>若要为容器设置 Seccomp 配置（Profile），可在你的 Pod 或 Container 清单的
<code>securityContext</code> 节中包含 <code>seccompProfile</code> 字段。该字段是一个
<a href=/docs/reference/generated/kubernetes-api/v1.23/#seccompprofile-v1-core>SeccompProfile</a>
对象，包含 <code>type</code> 和 <code>localhostProfile</code> 属性。
<code>type</code> 的合法选项包括 <code>RuntimeDefault</code>、<code>Unconfined</code> 和 <code>Localhost</code>。
<code>localhostProfile</code> 只能在 <code>type: Localhost</code> 配置下才可以设置。
该字段标明节点上预先设定的配置的路径，路径是相对于 kubelet 所配置的
Seccomp 配置路径（使用 <code>--root-dir</code> 设置）而言的。</p>
<p>下面是一个例子，设置容器使用节点上容器运行时的默认配置作为 Seccomp 配置：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>securityContext</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>seccompProfile</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>RuntimeDefault<span style=color:#bbb>
</span></code></pre></div>
<p>下面是另一个例子，将 Seccomp 的样板设置为位于
<code>&lt;kubelet-根目录>/seccomp/my-profiles/profile-allow.json</code>
的一个预先配置的文件。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>securityContext</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>seccompProfile</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Localhost<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>localhostProfile</span>:<span style=color:#bbb> </span>my-profiles/profile-allow.json<span style=color:#bbb>
</span></code></pre></div>
<h2 id=为-container-赋予-selinux-标签>为 Container 赋予 SELinux 标签</h2>
<p>若要给 Container 设置 SELinux 标签，可以在 Pod 或 Container 清单的
<code>securityContext</code> 节包含 <code>seLinuxOptions</code> 字段。
<code>seLinuxOptions</code> 字段的取值是一个
<a href=/docs/reference/generated/kubernetes-api/v1.23/#selinuxoptions-v1-core>SELinuxOptions</a>
对象。下面是一个应用 SELinux 标签的例子：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>securityContext</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>seLinuxOptions</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>level</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;s0:c123,c456&#34;</span><span style=color:#bbb>
</span></code></pre></div>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 要指定 SELinux，需要在宿主操作系统中装载 SELinux 安全性模块。
</div>
<h2 id=discussion>讨论 </h2>
<p>Pod 的安全上下文适用于 Pod 中的容器，也适用于 Pod 所挂载的卷（如果有的话）。
尤其是，<code>fsGroup</code> 和 <code>seLinuxOptions</code> 按下面的方式应用到挂载卷上：</p>
<ul>
<li>
<p><code>fsGroup</code>：支持属主管理的卷会被修改，将其属主变更为 <code>fsGroup</code> 所指定的 GID，
并且对该 GID 可写。进一步的细节可参阅
<a href=https://git.k8s.io/community/contributors/design-proposals/storage/volume-ownership-management.md>属主变更设计文档</a>。</p>
</li>
<li>
<p><code>seLinuxOptions</code>：支持 SELinux 标签的卷会被重新打标签，以便可被 <code>seLinuxOptions</code>
下所设置的标签访问。通常你只需要设置 <code>level</code> 部分。
该部分设置的是赋予 Pod 中所有容器及卷的
<a href=https://selinuxproject.org/page/NB_MLS>多类别安全性（Multi-Category Security，MCS)</a>标签。</p>
<div class="alert alert-danger warning callout" role=alert>
<strong>Warning:</strong> 在为 Pod 设置 MCS 标签之后，所有带有相同标签的 Pod 可以访问该卷。
如果你需要跨 Pod 的保护，你必须为每个 Pod 赋予独特的 MCS 标签。
</div>
</li>
</ul>
<h2 id=清理>清理</h2>
<p>删除之前创建的所有 Pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete pod security-context-demo
kubectl delete pod security-context-demo-2
kubectl delete pod security-context-demo-3
kubectl delete pod security-context-demo-4
</code></pre></div><h2 id=what-s-next>What's next</h2>
<ul>
<li><a href=/docs/reference/generated/kubernetes-api/v1.23/#podsecuritycontext-v1-core>PodSecurityContext</a> API 定义</li>
<li><a href=/docs/reference/generated/kubernetes-api/v1.23/#securitycontext-v1-core>SecurityContext</a> API 定义</li>
<li><a href=https://github.com/containerd/containerd/blob/main/docs/cri/config.md>使用最新的安全性增强来调优 Docker（英文）</a></li>
<li><a href=https://git.k8s.io/community/contributors/design-proposals/auth/security_context.md>安全上下文的设计文档（英文）</a></li>
<li><a href=https://git.k8s.io/community/contributors/design-proposals/storage/volume-ownership-management.md>属主管理的设计文档（英文）</a></li>
<li><a href=/zh/docs/concepts/security/pod-security-policy/>Pod 安全策略</a></li>
<li><a href=https://git.k8s.io/community/contributors/design-proposals/auth/no-new-privs.md>AllowPrivilegeEscalation 的设计文档（英文）</a></li>
<li>关于在 Linux 系统中的安全机制的更多信息，可参阅
<a href=https://www.linux.com/learn/overview-linux-kernel-security-features>Linux 内核安全性能力概述</a>。</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-2c0d882359718c4c69c67099bed2156c>5.12 - 为 Pod 配置服务账户</h1>
<p>服务账户为 Pod 中运行的进程提供了一个标识。</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 本文是服务账户的用户使用介绍，描述服务账号在集群中如何起作用。
你的集群管理员可能已经对你的集群做了定制，因此导致本文中所讲述的内容并不适用。
</div>
<p>当你（自然人）访问集群时（例如，使用 <code>kubectl</code>），API 服务器将你的身份验证为
特定的用户帐户（当前这通常是 <code>admin</code>，除非你的集群管理员已经定制了你的集群配置）。
Pod 内的容器中的进程也可以与 api 服务器接触。
当它们进行身份验证时，它们被验证为特定的服务帐户（例如，<code>default</code>）。</p>
<h2 id=before-you-begin>Before you begin</h2>
<p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li>
</ul>
To check the version, enter <code>kubectl version</code>.
</p>
<h2 id=使用默认的服务账户访问-api-服务器>使用默认的服务账户访问 API 服务器</h2>
<p>当你创建 Pod 时，如果没有指定服务账户，Pod 会被指定给命名空间中的 <code>default</code> 服务账户。
如果你查看 Pod 的原始 JSON 或 YAML（例如：<code>kubectl get pods/podname -o yaml</code>），
你可以看到 <code>spec.serviceAccountName</code> 字段已经被自动设置了。</p>
<p>你可以使用自动挂载给 Pod 的服务账户凭据访问 API，
<a href=/zh/docs/tasks/access-application-cluster/access-cluster/>访问集群</a>页面中有相关描述。
服务账户的 API 许可取决于你所使用的
<a href=/zh/docs/reference/access-authn-authz/authorization/#authorization-modules>鉴权插件和策略</a>。</p>
<p>在 1.6 以上版本中，你可以通过在服务账户上设置 <code>automountServiceAccountToken: false</code>
来实现不给服务账号自动挂载 API 凭据：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ServiceAccount<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>build-robot<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>automountServiceAccountToken</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>false</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></code></pre></div>
<p>在 1.6 以上版本中，你也可以选择不给特定 Pod 自动挂载 API 凭据：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>serviceAccountName</span>:<span style=color:#bbb> </span>build-robot<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>automountServiceAccountToken</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>false</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></code></pre></div>
<p>如果 Pod 和服务账户都指定了 <code>automountServiceAccountToken</code> 值，则 Pod 的 spec 优先于服务帐户。</p>
<h2 id=use-multiple-service-accounts>使用多个服务账户 </h2>
<p>每个命名空间都有一个名为 <code>default</code> 的服务账户资源。
你可以用下面的命令查询这个服务账户以及命名空间中的其他 ServiceAccount 资源：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get serviceAccounts
</code></pre></div>
<p>输出类似于：</p>
<pre><code>NAME      SECRETS    AGE
default   1          1d
</code></pre>
<p>你可以像这样来创建额外的 ServiceAccount 对象：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create -f - <span style=color:#b44>&lt;&lt;EOF
</span><span style=color:#b44>apiVersion: v1
</span><span style=color:#b44>kind: ServiceAccount
</span><span style=color:#b44>metadata:
</span><span style=color:#b44>  name: build-robot
</span><span style=color:#b44>EOF</span>
</code></pre></div>
<p>ServiceAccount 对象的名字必须是一个有效的
<a href=/zh/docs/concepts/overview/working-with-objects/names#dns-subdomain-names>DNS 子域名</a>.</p>
<p>如果你查询服务帐户对象的完整信息，如下所示：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get serviceaccounts/build-robot -o yaml
</code></pre></div>
<p>输出类似于：</p>
<pre><code class=language-none data-lang=none>apiVersion: v1
kind: ServiceAccount
metadata:
  creationTimestamp: 2015-06-16T00:12:59Z
  name: build-robot
  namespace: default
  resourceVersion: &quot;272500&quot;
  uid: 721ab723-13bc-11e5-aec2-42010af0021e
secrets:
- name: build-robot-token-bvbk5
</code></pre>
<p>那么你就能看到系统已经自动创建了一个令牌并且被服务账户所引用。</p>
<p>你可以使用授权插件来
<a href=/zh/docs/reference/access-authn-authz/rbac/#service-account-permissions>设置服务账户的访问许可</a>。</p>
<p>要使用非默认的服务账户，将 Pod 的 <code>spec.serviceAccountName</code> 字段设置为你想用的服务账户名称。</p>
<p>Pod 被创建时服务账户必须存在，否则会被拒绝。</p>
<p>你不能更新已经创建好的 Pod 的服务账户。</p>
<p>你可以清除服务账户，如下所示：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete serviceaccount/build-robot
</code></pre></div>
<h2 id=手动创建服务账户-api-令牌>手动创建服务账户 API 令牌</h2>
<p>假设我们有一个上面提到的名为 "build-robot" 的服务账户，然后我们手动创建一个新的 Secret。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create -f - <span style=color:#b44>&lt;&lt;EOF
</span><span style=color:#b44>apiVersion: v1
</span><span style=color:#b44>kind: Secret
</span><span style=color:#b44>metadata:
</span><span style=color:#b44>  name: build-robot-secret
</span><span style=color:#b44>  annotations:
</span><span style=color:#b44>    kubernetes.io/service-account.name: build-robot
</span><span style=color:#b44>type: kubernetes.io/service-account-token
</span><span style=color:#b44>EOF</span>
</code></pre></div>
<p>现在，你可以确认新构建的 Secret 中填充了 "build-robot" 服务帐户的 API 令牌。
令牌控制器将清理不存在的服务帐户的所有令牌。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe secrets/build-robot-secret
</code></pre></div>
<p>输出类似于：</p>
<pre><code>Name:           build-robot-secret
Namespace:      default
Labels:         &lt;none&gt;
Annotations:    kubernetes.io/service-account.name: build-robot
                kubernetes.io/service-account.uid: da68f9c6-9d26-11e7-b84e-002dc52800da

Type:   kubernetes.io/service-account-token

Data
====
ca.crt:         1338 bytes
namespace:      7 bytes
token:          ...
</code></pre>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 这里省略了 <code>token</code> 的内容。
</div>
<h2 id=add-imagepullsecrets-to-a-service-account>为服务账户添加 ImagePullSecrets </h2>
<h3 id=创建-imagepullsecret>创建 ImagePullSecret</h3>
<ul>
<li>
<p>创建一个 ImagePullSecret，如同<a href=/zh/docs/concepts/containers/images/#specifying-imagepullsecrets-on-a-pod>为 Pod 设置 ImagePullSecret</a>所述。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create secret docker-registry myregistrykey --docker-server<span style=color:#666>=</span>DUMMY_SERVER <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>          --docker-username<span style=color:#666>=</span>DUMMY_USERNAME --docker-password<span style=color:#666>=</span>DUMMY_DOCKER_PASSWORD <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>          --docker-email<span style=color:#666>=</span>DUMMY_DOCKER_EMAIL
</code></pre></div></li>
</ul>
<ul>
<li>
<p>确认创建成功：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get secrets myregistrykey
</code></pre></div>
<p>输出类似于：</p>
<pre><code>NAME             TYPE                              DATA    AGE
myregistrykey    kubernetes.io/.dockerconfigjson   1       1d
</code></pre></li>
</ul>
<h3 id=将镜像拉取-secret-添加到服务账号>将镜像拉取 Secret 添加到服务账号</h3>
<p>接着修改命名空间的 <code>default</code> 服务帐户，以将该 Secret 用作 <code>imagePullSecret</code>。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl patch serviceaccount default -p <span style=color:#b44>&#39;{&#34;imagePullSecrets&#34;: [{&#34;name&#34;: &#34;myregistrykey&#34;}]}&#39;</span>
</code></pre></div>
<p>你也可以使用 <code>kubectl edit</code>，或者如下所示手动编辑 YAML 清单：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get serviceaccounts default -o yaml &gt; ./sa.yaml
</code></pre></div><p><code>sa.yaml</code> 文件的内容类似于：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ServiceAccount<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>creationTimestamp</span>:<span style=color:#bbb> </span>2015-08-07T22:02:39Z<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resourceVersion</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;243024&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>uid</span>:<span style=color:#bbb> </span>052fb0f4-3d50-11e5-b066-42010af0d7b6<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>secrets</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>default-token-uudge<span style=color:#bbb>
</span></code></pre></div>
<p>使用你常用的编辑器（例如 <code>vi</code>），打开 <code>sa.yaml</code> 文件，删除带有键名
<code>resourceVersion</code> 的行，添加带有 <code>imagePullSecrets:</code> 的行，最后保存文件。</p>
<p>所得到的 <code>sa.yaml</code> 文件类似于：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ServiceAccount<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>creationTimestamp</span>:<span style=color:#bbb> </span>2015-08-07T22:02:39Z<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>uid</span>:<span style=color:#bbb> </span>052fb0f4-3d50-11e5-b066-42010af0d7b6<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>secrets</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>default-token-uudge<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>imagePullSecrets</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>myregistrykey<span style=color:#bbb>
</span></code></pre></div>
<p>最后，用新的更新的 <code>sa.yaml</code> 文件替换服务账号。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl replace serviceaccount default -f ./sa.yaml
</code></pre></div>
<h3 id=验证镜像拉取-secret-已经被添加到-pod-规约>验证镜像拉取 Secret 已经被添加到 Pod 规约</h3>
<p>现在，在当前命名空间中创建使用默认服务账号的新 Pod 时，新 Pod
会自动设置其 <code>.spec.imagePullSecrets</code> 字段：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl run nginx --image<span style=color:#666>=</span>nginx --restart<span style=color:#666>=</span>Never
kubectl get pod nginx -o<span style=color:#666>=</span><span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.spec.imagePullSecrets[0].name}{&#34;\n&#34;}&#39;</span>
</code></pre></div>
<p>输出为：</p>
<pre><code>myregistrykey
</code></pre>
<h2 id=service-account-token-volume-projection>服务帐户令牌卷投射 </h2>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.20 [stable]</code>
</div>
<p>为了启用令牌请求投射，你必须为 <code>kube-apiserver</code> 设置以下命令行参数：</p>
<ul>
<li>
<p><code>--service-account-issuer</code></p>
<p>此参数可作为服务账户令牌发放者的身份标识（Identifier）。你可以多次指定
<code>--service-account-issuer</code> 参数，对于要变更发放者而又不想带来业务中断的场景，
这样做是有用的。如果这个参数被多次指定，则第一个参数值会被用来生成令牌，
而所有参数值都会被用来确定哪些发放者是可接受的。你所运行的 Kubernetes
集群必须是 v1.22 或更高版本，才能多次指定 <code>--service-account-issuer</code>。</p>
</li>
</ul>
<ul>
<li>
<p><code>--service-account-key-file</code></p>
<p>包含 PEM 编码的 x509 RSA 或 ECDSA 私钥或公钥，用来检查 ServiceAccount
的令牌。所指定的文件中可以包含多个秘钥，并且你可以多次使用此参数，
每次参数值为不同的文件。多次使用此参数时，由所给的秘钥之一签名的令牌会被
Kubernetes API 服务器认为是合法令牌。</p>
</li>
</ul>
<ul>
<li>
<p><code>--service-account-signing-key-file</code></p>
<p>指向包含当前服务账户令牌发放者的私钥的文件路径。
此发放者使用此私钥来签署所发放的 ID 令牌。</p>
</li>
</ul>
<ul>
<li>
<p><code>--api-audiences</code> (can be omitted)</p>
<p>服务账号令牌身份检查组件会检查针对 API 访问所使用的令牌，
确认令牌至少是被绑定到这里所给的受众（audiences）之一。
如果此参数被多次指定，则针对所给的多个受众中任何目标的令牌都会被
Kubernetes API 服务器当做合法的令牌。如果 <code>--service-account-issuer</code>
参数被设置，而这个参数未指定，则这个参数的默认值为一个只有一个元素的列表，
且该元素为令牌发放者的 URL。</p>
</li>
</ul>
<p>kubelet 还可以将服务帐户令牌投射到 Pod 中。
你可以指定令牌的期望属性，例如受众和有效期限。
这些属性在 default 服务帐户令牌上无法配置。
当删除 Pod 或 ServiceAccount 时，服务帐户令牌也将对 API 无效。</p>
<p>使用名为 <a href=/zh/docs/concepts/storage/volumes/#projected>ServiceAccountToken</a> 的
ProjectedVolume 类型在 PodSpec 上配置此功能。
要向 Pod 提供具有 "vault" 用户以及两个小时有效期的令牌，可以在 PodSpec 中配置以下内容：</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/pods/pod-projected-svc-token.yaml download=pods/pod-projected-svc-token.yaml><code>pods/pod-projected-svc-token.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-pod-projected-svc-token-yaml')" title="Copy pods/pod-projected-svc-token.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-pod-projected-svc-token-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/var/run/secrets/tokens<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>vault-token<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>serviceAccountName</span>:<span style=color:#bbb> </span>build-robot<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>vault-token<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>projected</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>sources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>serviceAccountToken</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>vault-token<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>expirationSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>7200</span><span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>audience</span>:<span style=color:#bbb> </span>vault<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>创建 Pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create -f https://k8s.io/examples/pods/pod-projected-svc-token.yaml
</code></pre></div>
<p><code>kubelet</code> 组件会替 Pod 请求令牌并将其保存起来，
通过将令牌存储到一个可配置的路径使之在 Pod 内可用，
并在令牌快要到期的时候刷新它。
<code>kubelet</code> 会在令牌存在期达到其 TTL 的 80% 的时候或者令牌生命期超过
24 小时的时候主动轮换它。</p>
<p>应用程序负责在令牌被轮换时重新加载其内容。对于大多数使用场景而言，
周期性地（例如，每隔 5 分钟）重新加载就足够了。</p>
<h2 id=发现服务账号分发者>发现服务账号分发者</h2>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.21 [stable]</code>
</div>
<p>当启用服务账号令牌投射时启用发现服务账号分发者（Service Account Issuer Discovery）
这一功能特性，如<a href=#service-account-token-volume-projection>上文所述</a>。</p>
<p>分发者的 URL 必须遵从
<a href=https://openid.net/specs/openid-connect-discovery-1_0.html>OIDC 发现规范</a>。
这意味着 URL 必须使用 <code>https</code> 模式，并且必须在
<code>{service-account-issuer}/.well-known/openid-configuration</code>
路径给出 OpenID 提供者（Provider）配置。</p>
<p>如果 URL 没有遵从这一规范，<code>ServiceAccountIssuerDiscovery</code> 末端就不会被注册，
即使该特性已经被启用。</p>
<p>发现服务账号分发者这一功能使得用户能够用联邦的方式结合使用 Kubernetes
集群（“Identity Provider”，标识提供者）与外部系统（“Relying Parties”，
依赖方）所分发的服务账号令牌。</p>
<p>当此功能被启用时，Kubernetes API 服务器会在 <code>/.well-known/openid-configuration</code>
提供一个 OpenID 提供者配置文档，并在 <code>/openid/v1/jwks</code> 处提供与之关联的
JSON Web Key Set（JWKS）。
这里的 OpenID 提供者配置有时候也被称作“发现文档（Discovery Document）”。</p>
<p>集群包括一个的默认 RBAC ClusterRole, 名为 <code>system:service-account-issuer-discovery</code>。
默认的 RBAC ClusterRoleBinding 将此角色分配给 <code>system:serviceaccounts</code> 组，
所有服务帐户隐式属于该组。这使得集群上运行的 Pod
能够通过它们所挂载的服务帐户令牌访问服务帐户发现文档。
此外，管理员可以根据其安全性需要以及期望集成的外部系统选择是否将该角色绑定到
<code>system:authenticated</code> 或 <code>system:unauthenticated</code>。</p>
<p>对 <code>/.well-known/openid-configuration</code> 和 <code>/openid/v1/jwks</code> 路径请求的响应
被设计为与 OIDC 兼容，但不是完全与其一致。
返回的文档仅包含对 Kubernetes 服务账号令牌进行验证所必须的参数。</p>
<p>JWKS 响应包含依赖方可以用来验证 Kubernetes 服务账号令牌的公钥数据。
依赖方先会查询 OpenID 提供者配置，之后使用返回响应中的 <code>jwks_uri</code> 来查找 JWKS。</p>
<p>在很多场合，Kubernetes API 服务器都不会暴露在公网上，不过对于缓存并向外提供 API
服务器响应数据的公开末端而言，用户或者服务提供商可以选择将其暴露在公网上。
在这种环境中，可能会重载 OpenID 提供者配置中的
<code>jwks_uri</code>，使之指向公网上可用的末端地址，而不是 API 服务器的地址。
这时需要向 API 服务器传递 <code>--service-account-jwks-uri</code> 参数。
与分发者 URL 类似，此 JWKS URI 也需要使用 <code>https</code> 模式。</p>
<h2 id=what-s-next>What's next</h2>
<p>另请参见：</p>
<ul>
<li><a href=/zh/docs/reference/access-authn-authz/service-accounts-admin/>服务账号的集群管理员指南</a></li>
<li><a href=https://github.com/kubernetes/enhancements/tree/master/keps/sig-auth/1393-oidc-discovery>服务账号签署密钥检索 KEP</a></li>
<li><a href=https://openid.net/specs/openid-connect-discovery-1_0.html>OIDC 发现规范</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-d385b86a7cb496d3b1c3b2a47280ca70>5.13 - 从私有仓库拉取镜像</h1>
<p>本文介绍如何使用 <a class=glossary-tooltip title="Secret 用于存储敏感信息，如密码、 OAuth 令牌和 SSH 密钥。" data-toggle=tooltip data-placement=top href=/zh/docs/concepts/configuration/secret/ target=_blank aria-label=Secret>Secret</a>
从私有的镜像仓库或代码仓库拉取镜像来创建 Pod。
有很多私有镜像仓库正在使用中。这个任务使用的镜像仓库是
<a href=https://www.docker.com/products/docker-hub>Docker Hub</a></p>
<div class="alert alert-secondary callout third-party-content" role=alert>&#128711; This item links to a third party project or product that is not part of Kubernetes itself. <a class=alert-more-info href=#third-party-content-disclaimer>More information</a></div>
<h2 id=before-you-begin>Before you begin</h2>
<ul>
<li><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li>
</ul>
</li>
</ul>
<ul>
<li>要进行此练习，你需要 <code>docker</code> 命令行工具和一个知道密码的
<a href=https://docs.docker.com/docker-id/>Docker ID</a>。</li>
<li>如果你要使用不同的私有的镜像仓库，你需要有对应镜像仓库的命令行工具和登录信息。</li>
</ul>
<h2 id=log-in-to-docker>登录 Docker 镜像仓库 </h2>
<p>在个人电脑上，要想拉取私有镜像必须在镜像仓库上进行身份验证。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>docker login
</code></pre></div>
<p>当出现提示时，输入您的 Docker ID 和登录凭证（访问令牌、
或 Docker ID 的密码）。</p>
<p>登录过程会创建或更新保存有授权令牌的 <code>config.json</code> 文件。
查看 <a href=/zh/docs/concepts/containers/images#config-json>Kubernetes 中如何解析这个文件</a>。</p>
<p>查看 <code>config.json</code> 文件：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>cat ~/.docker/config.json
</code></pre></div>
<p>输出结果包含类似于以下内容的部分：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
    <span style=color:green;font-weight:700>&#34;auths&#34;</span>: {
        <span style=color:green;font-weight:700>&#34;https://index.docker.io/v1/&#34;</span>: {
            <span style=color:green;font-weight:700>&#34;auth&#34;</span>: <span style=color:#b44>&#34;c3R...zE2&#34;</span>
        }
    }
}
</code></pre></div>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 如果使用 Docker 凭证仓库，则不会看到 <code>auth</code> 条目，看到的将是以仓库名称作为值的 <code>credsStore</code> 条目。
</div>
<h2 id=registry-secret-existing-credentials>创建一个基于现有凭证的 Secret </h2>
<p>Kubernetes 集群使用 <code>kubernetes.io/dockerconfigjson</code> 类型的
Secret 来通过镜像仓库的身份验证，进而提取私有镜像。</p>
<p>如果你已经运行了 <code>docker login</code> 命令，你可以复制该镜像仓库的凭证到 Kubernetes:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create secret generic regcred <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>    --from-file<span style=color:#666>=</span>.dockerconfigjson<span style=color:#666>=</span>&lt;path/to/.docker/config.json&gt; <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>    --type<span style=color:#666>=</span>kubernetes.io/dockerconfigjson
</code></pre></div>
<p>如果你需要更多的设置（例如，为新 Secret 设置名字空间或标签），
则可以在存储 Secret 之前对它进行自定义。
请务必：</p>
<ul>
<li>将 data 项中的名称设置为 <code>.dockerconfigjson</code></li>
<li>使用 base64 编码方法对 Docker 配置文件进行编码，然后粘贴该字符串的内容，作为字段
<code>data[".dockerconfigjson"]</code> 的值</li>
<li>将 <code>type</code> 设置为 <code>kubernetes.io/dockerconfigjson</code></li>
</ul>
<p>示例：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>myregistrykey<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>awesomeapps<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>.dockerconfigjson</span>:<span style=color:#bbb> </span>UmVhbGx5IHJlYWxseSByZWVlZWVlZWVlZWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGx5eXl5eXl5eXl5eXl5eXl5eXl5eSBsbGxsbGxsbGxsbGxsbG9vb29vb29vb29vb29vb29vb29vb29vb29vb25ubm5ubm5ubm5ubm5ubm5ubm5ubm5ubmdnZ2dnZ2dnZ2dnZ2dnZ2dnZ2cgYXV0aCBrZXlzCg==<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>kubernetes.io/dockerconfigjson<span style=color:#bbb>
</span></code></pre></div>
<p>如果你收到错误消息：<code>error: no objects passed to create</code>，
这可能意味着 base64 编码的字符串是无效的。 如果你收到类似
<code>Secret "myregistrykey" is invalid: data[.dockerconfigjson]: invalid value ...</code>
的错误消息，则表示数据中的 base64 编码字符串已成功解码，但无法解析为 <code>.docker/config.json</code> 文件。</p>
<h2 id=create-a-secret-by-providing-credentials-on-the-command-line>在命令行上提供凭证来创建 Secret </h2>
<p>创建 Secret，命名为 <code>regcred</code>：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create secret docker-registry regcred <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --docker-server<span style=color:#666>=</span>&lt;你的镜像仓库服务器&gt; <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --docker-username<span style=color:#666>=</span>&lt;你的用户名&gt; <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --docker-password<span style=color:#666>=</span>&lt;你的密码&gt; <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --docker-email<span style=color:#666>=</span>&lt;你的邮箱地址&gt;
</code></pre></div>
<p>在这里：</p>
<ul>
<li><code>&lt;your-registry-server></code> 是你的私有 Docker 仓库全限定域名（FQDN）。
DockerHub 使用 <code>https://index.docker.io/v1/</code>。</li>
<li><code>&lt;your-name></code> 是你的 Docker 用户名。</li>
<li><code>&lt;your-pword></code> 是你的 Docker 密码。</li>
<li><code>&lt;your-email></code> 是你的 Docker 邮箱。</li>
</ul>
<p>这样你就成功地将集群中的 Docker 凭证设置为名为 <code>regcred</code> 的 Secret。</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 在命令行上键入 Secret 可能会将它们存储在你的 shell 历史记录中而不受保护，
并且这些 Secret 信息也可能在 <code>kubectl</code> 运行期间对你 PC 上的其他用户可见。
</div>
<h2 id=inspecting-the-secret-regcred>检查 Secret <code>regcred</code> </h2>
<p>要了解你创建的 <code>regcred</code> Secret 的内容，可以用 YAML 格式进行查看：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get secret regcred --output<span style=color:#666>=</span>yaml
</code></pre></div>
<p>输出和下面类似：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>.dockerconfigjson</span>:<span style=color:#bbb> </span>eyJodHRwczovL2luZGV4L ... J0QUl6RTIifX0=<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>regcred<span style=color:#bbb>
</span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>kubernetes.io/dockerconfigjson<span style=color:#bbb>
</span></code></pre></div>
<p><code>.dockerconfigjson</code> 字段的值是 Docker 凭证的 base64 表示。</p>
<p>要了解 <code>dockerconfigjson</code> 字段中的内容，请将 Secret 数据转换为可读格式：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get secret regcred --output<span style=color:#666>=</span><span style=color:#b44>&#34;jsonpath={.data.\.dockerconfigjson}&#34;</span> | base64 --decode
</code></pre></div>
<p>输出和下面类似：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{<span style=color:green;font-weight:700>&#34;auths&#34;</span>:{<span style=color:green;font-weight:700>&#34;yourprivateregistry.com&#34;</span>:{<span style=color:green;font-weight:700>&#34;username&#34;</span>:<span style=color:#b44>&#34;janedoe&#34;</span>,<span style=color:green;font-weight:700>&#34;password&#34;</span>:<span style=color:#b44>&#34;xxxxxxxxxxx&#34;</span>,<span style=color:green;font-weight:700>&#34;email&#34;</span>:<span style=color:#b44>&#34;jdoe@example.com&#34;</span>,<span style=color:green;font-weight:700>&#34;auth&#34;</span>:<span style=color:#b44>&#34;c3R...zE2&#34;</span>}}}
</code></pre></div>
<p>要了解 <code>auth</code> 字段中的内容，请将 base64 编码过的数据转换为可读格式：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#a2f>echo</span> <span style=color:#b44>&#34;c3R...zE2&#34;</span> | base64 --decode
</code></pre></div>
<p>输出结果中，用户名和密码用 <code>:</code> 链接，类似下面这样：</p>
<pre><code class=language-none data-lang=none>janedoe:xxxxxxxxxxx
</code></pre>
<p>注意，Secret 数据包含与本地 <code>~/.docker/config.json</code> 文件类似的授权令牌。</p>
<p>这样你就已经成功地将 Docker 凭证设置为集群中的名为 <code>regcred</code> 的 Secret。</p>
<h2 id=create-a-pod-that-uses-your-secret>创建一个使用你的 Secret 的 Pod </h2>
<p>下面是一个 Pod 配置清单示例，该示例中 Pod 需要访问你的 Docker 凭证 <code>regcred</code>：</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/pods/private-reg-pod.yaml download=pods/private-reg-pod.yaml><code>pods/private-reg-pod.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-private-reg-pod-yaml')" title="Copy pods/private-reg-pod.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-private-reg-pod-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>private-reg<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>private-reg-container<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>&lt;your-private-image&gt;<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>imagePullSecrets</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>regcred<span style=color:#bbb>
</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>将上述文件下载到你的计算机中：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>curl -L -O my-private-reg-pod.yaml https://k8s.io/examples/pods/private-reg-pod.yaml
</code></pre></div>
<p>在<code>my-private-reg-pod.yaml</code> 文件中，使用私有仓库的镜像路径替换 <code>&lt;your-private-image></code>，例如：</p>
<pre><code class=language-none data-lang=none>janedoe/jdoe-private:v1
</code></pre>
<p>要从私有仓库拉取镜像，Kubernetes 需要凭证。
配置文件中的 <code>imagePullSecrets</code> 字段表明 Kubernetes 应该通过名为 <code>regcred</code> 的 Secret 获取凭证。</p>
<p>创建使用了你的 Secret 的 Pod，并检查它是否正常运行：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f my-private-reg-pod.yaml
kubectl get pod private-reg
</code></pre></div><h2 id=what-s-next>What's next</h2>
<ul>
<li>进一步了解 <a href=/zh/docs/concepts/configuration/secret/>Secrets</a>
<ul>
<li>或阅读
<a href=/docs/reference/kubernetes-api/config-and-storage-resources/secret-v1/>Secret</a> 的 API 参考</li>
</ul>
</li>
<li>进一步了解 <a href=/zh/docs/concepts/containers/images/#using-a-private-registry>使用私有仓库</a></li>
<li>进一步了解 <a href=/zh/docs/tasks/configure-pod-container/configure-service-account/#add-imagepullsecrets-to-a-service-account>为服务账户添加拉取镜像凭证</a></li>
<li>查看 <a href=/docs/reference/generated/kubectl/kubectl-commands/#-em-secret-docker-registry-em->kubectl 创建 docker-registry 凭证</a></li>
<li>查看 Pod <a href=/docs/reference/kubernetes-api/workload-resources/pod-v1/#containers>容器定义</a>中的 <code>imagePullSecrets</code> 字段。</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-eb54daf87df373096b5e830680194dfc>5.14 - 配置存活、就绪和启动探测器</h1>
<p>这篇文章介绍如何给容器配置活跃（Liveness）、就绪（Readiness）和启动（Startup）探测器。</p>
<p><a href=/zh/docs/reference/command-line-tools-reference/kubelet/>kubelet</a>
使用存活探测器来确定什么时候要重启容器。
例如，存活探测器可以探测到应用死锁（应用程序在运行，但是无法继续执行后面的步骤）情况。
重启这种状态下的容器有助于提高应用的可用性，即使其中存在缺陷。</p>
<p>kubelet 使用就绪探测器可以知道容器何时准备好接受请求流量，当一个 Pod
内的所有容器都就绪时，才能认为该 Pod 就绪。
这种信号的一个用途就是控制哪个 Pod 作为 Service 的后端。
若 Pod 尚未就绪，会被从 Service 的负载均衡器中剔除。</p>
<p>kubelet 使用启动探测器来了解应用容器何时启动。
如果配置了这类探测器，你就可以控制容器在启动成功后再进行存活性和就绪态检查，
确保这些存活、就绪探测器不会影响应用的启动。
启动探测器可以用于对慢启动容器进行存活性检测，避免它们在启动运行之前就被杀掉。</p>
<h2 id=before-you-begin>Before you begin</h2>
<p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li>
</ul>
<h2 id=define-a-liveness-command>定义存活命令</h2>
<p>许多长时间运行的应用最终会进入损坏状态，除非重新启动，否则无法被恢复。
Kubernetes 提供了存活探测器来发现并处理这种情况。</p>
<p>在本练习中，你会创建一个 Pod，其中运行一个基于 <code>k8s.gcr.io/busybox</code> 镜像的容器。
下面是这个 Pod 的配置文件。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/pods/probe/exec-liveness.yaml download=pods/probe/exec-liveness.yaml><code>pods/probe/exec-liveness.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-probe-exec-liveness-yaml')" title="Copy pods/probe/exec-liveness.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-probe-exec-liveness-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>test</span>:<span style=color:#bbb> </span>liveness<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>liveness-exec<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>liveness<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/busybox<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- /bin/sh<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- -c<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- touch /tmp/healthy; sleep 30; rm -f /tmp/healthy; sleep 600<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>livenessProbe</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>exec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- cat<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- /tmp/healthy<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>initialDelaySeconds</span>:<span style=color:#bbb> </span><span style=color:#666>5</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>periodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>5</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>在这个配置文件中，可以看到 Pod 中只有一个 <code>Container</code>。
<code>periodSeconds</code> 字段指定了 kubelet 应该每 5 秒执行一次存活探测。
<code>initialDelaySeconds</code> 字段告诉 kubelet 在执行第一次探测前应该等待 5 秒。
kubelet 在容器内执行命令 <code>cat /tmp/healthy</code> 来进行探测。
如果命令执行成功并且返回值为 0，kubelet 就会认为这个容器是健康存活的。
如果这个命令返回非 0 值，kubelet 会杀死这个容器并重新启动它。</p>
<p>当容器启动时，执行如下的命令：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>/bin/sh -c <span style=color:#b44>&#34;touch /tmp/healthy; sleep 30; rm -rf /tmp/healthy; sleep 600&#34;</span>
</code></pre></div>
<p>这个容器生命的前 30 秒，<code>/tmp/healthy</code> 文件是存在的。
所以在这最开始的 30 秒内，执行命令 <code>cat /tmp/healthy</code> 会返回成功代码。
30 秒之后，执行命令 <code>cat /tmp/healthy</code> 就会返回失败代码。</p>
<p>创建 Pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/pods/probe/exec-liveness.yaml
</code></pre></div>
<p>在 30 秒内，查看 Pod 的事件：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe pod liveness-exec
</code></pre></div>
<p>输出结果表明还没有存活探测器失败：</p>
<pre><code>FirstSeen    LastSeen    Count   From            SubobjectPath           Type        Reason      Message
--------- --------    -----   ----            -------------           --------    ------      -------
24s       24s     1   {default-scheduler }                    Normal      Scheduled   Successfully assigned liveness-exec to worker0
23s       23s     1   {kubelet worker0}   spec.containers{liveness}   Normal      Pulling     pulling image &quot;k8s.gcr.io/busybox&quot;
23s       23s     1   {kubelet worker0}   spec.containers{liveness}   Normal      Pulled      Successfully pulled image &quot;k8s.gcr.io/busybox&quot;
23s       23s     1   {kubelet worker0}   spec.containers{liveness}   Normal      Created     Created container with docker id 86849c15382e; Security:[seccomp=unconfined]
23s       23s     1   {kubelet worker0}   spec.containers{liveness}   Normal      Started     Started container with docker id 86849c15382e
</code></pre>
<p>35 秒之后，再来看 Pod 的事件：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe pod liveness-exec
</code></pre></div>
<p>在输出结果的最下面，有信息显示存活探测器失败了，这个容器被杀死并且被重建了。</p>
<pre><code>FirstSeen LastSeen    Count   From            SubobjectPath           Type        Reason      Message
--------- --------    -----   ----            -------------           --------    ------      -------
37s       37s     1   {default-scheduler }                    Normal      Scheduled   Successfully assigned liveness-exec to worker0
36s       36s     1   {kubelet worker0}   spec.containers{liveness}   Normal      Pulling     pulling image &quot;k8s.gcr.io/busybox&quot;
36s       36s     1   {kubelet worker0}   spec.containers{liveness}   Normal      Pulled      Successfully pulled image &quot;k8s.gcr.io/busybox&quot;
36s       36s     1   {kubelet worker0}   spec.containers{liveness}   Normal      Created     Created container with docker id 86849c15382e; Security:[seccomp=unconfined]
36s       36s     1   {kubelet worker0}   spec.containers{liveness}   Normal      Started     Started container with docker id 86849c15382e
2s        2s      1   {kubelet worker0}   spec.containers{liveness}   Warning     Unhealthy   Liveness probe failed: cat: can't open '/tmp/healthy': No such file or directory
</code></pre>
<p>再等 30 秒，确认这个容器被重启了：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod liveness-exec
</code></pre></div>
<p>输出结果显示 <code>RESTARTS</code> 的值增加了 1。</p>
<pre><code>NAME            READY     STATUS    RESTARTS   AGE
liveness-exec   1/1       Running   1          1m
</code></pre>
<h2 id=define-a-liveness-HTTP-request>定义一个存活态 HTTP 请求接口</h2>
<p>另外一种类型的存活探测方式是使用 HTTP GET 请求。
下面是一个 Pod 的配置文件，其中运行一个基于 <code>k8s.gcr.io/liveness</code> 镜像的容器。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/pods/probe/http-liveness.yaml download=pods/probe/http-liveness.yaml><code>pods/probe/http-liveness.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-probe-http-liveness-yaml')" title="Copy pods/probe/http-liveness.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-probe-http-liveness-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>test</span>:<span style=color:#bbb> </span>liveness<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>liveness-http<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>liveness<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/liveness<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- /server<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>livenessProbe</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>httpGet</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/healthz<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>8080</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>httpHeaders</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>Custom-Header<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span>Awesome<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>initialDelaySeconds</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>periodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>在这个配置文件中，你可以看到 Pod 也只有一个容器。
<code>periodSeconds</code> 字段指定了 kubelet 每隔 3 秒执行一次存活探测。
<code>initialDelaySeconds</code> 字段告诉 kubelet 在执行第一次探测前应该等待 3 秒。
kubelet 会向容器内运行的服务（服务在监听 8080 端口）发送一个 HTTP GET 请求来执行探测。
如果服务器上 <code>/healthz</code> 路径下的处理程序返回成功代码，则 kubelet 认为容器是健康存活的。
如果处理程序返回失败代码，则 kubelet 会杀死这个容器并将其重启。</p>
<p>返回大于或等于 200 并且小于 400 的任何代码都标示成功，其它返回代码都标示失败。</p>
<p>你可以访问 <a href=https://github.com/kubernetes/kubernetes/blob/master/test/images/agnhost/liveness/server.go>server.go</a>。
阅读服务的源码。
容器存活期间的最开始 10 秒中，<code>/healthz</code> 处理程序返回 200 的状态码。
之后处理程序返回 500 的状态码。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>http.<span style=color:#00a000>HandleFunc</span>(<span style=color:#b44>&#34;/healthz&#34;</span>, <span style=color:#a2f;font-weight:700>func</span>(w http.ResponseWriter, r <span style=color:#666>*</span>http.Request) {
    duration <span style=color:#666>:=</span> time.<span style=color:#00a000>Now</span>().<span style=color:#00a000>Sub</span>(started)
    <span style=color:#a2f;font-weight:700>if</span> duration.<span style=color:#00a000>Seconds</span>() &gt; <span style=color:#666>10</span> {
        w.<span style=color:#00a000>WriteHeader</span>(<span style=color:#666>500</span>)
        w.<span style=color:#00a000>Write</span>([]<span style=color:#a2f>byte</span>(fmt.<span style=color:#00a000>Sprintf</span>(<span style=color:#b44>&#34;error: %v&#34;</span>, duration.<span style=color:#00a000>Seconds</span>())))
    } <span style=color:#a2f;font-weight:700>else</span> {
        w.<span style=color:#00a000>WriteHeader</span>(<span style=color:#666>200</span>)
        w.<span style=color:#00a000>Write</span>([]<span style=color:#a2f>byte</span>(<span style=color:#b44>&#34;ok&#34;</span>))
    }
})
</code></pre></div>
<p>kubelet 在容器启动之后 3 秒开始执行健康检测。所以前几次健康检查都是成功的。
但是 10 秒之后，健康检查会失败，并且 kubelet 会杀死容器再重新启动容器。</p>
<p>创建一个 Pod 来测试 HTTP 的存活检测：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/pods/probe/http-liveness.yaml
</code></pre></div>
<p>10 秒之后，通过查看 Pod 事件来确认活跃探测器已经失败，并且容器被重新启动了。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe pod liveness-http
</code></pre></div>
<p>在 1.13 之前（包括 1.13）的版本中，如果在 Pod 运行的节点上设置了环境变量
<code>http_proxy</code>（或者 <code>HTTP_PROXY</code>），HTTP 的存活探测会使用这个代理。
在 1.13 之后的版本中，设置本地的 HTTP 代理环境变量不会影响 HTTP 的存活探测。</p>
<h2 id=define-a-TCP-liveness-probe>定义 TCP 的存活探测</h2>
<p>第三种类型的存活探测是使用 TCP 套接字。
使用这种配置时，kubelet 会尝试在指定端口和容器建立套接字链接。
如果能建立连接，这个容器就被看作是健康的，如果不能则这个容器就被看作是有问题的。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/pods/probe/tcp-liveness-readiness.yaml download=pods/probe/tcp-liveness-readiness.yaml><code>pods/probe/tcp-liveness-readiness.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-probe-tcp-liveness-readiness-yaml')" title="Copy pods/probe/tcp-liveness-readiness.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-probe-tcp-liveness-readiness-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>goproxy<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>goproxy<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>goproxy<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/goproxy:0.1<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>8080</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>readinessProbe</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>tcpSocket</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>8080</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>initialDelaySeconds</span>:<span style=color:#bbb> </span><span style=color:#666>5</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>periodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>10</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>livenessProbe</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>tcpSocket</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>8080</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>initialDelaySeconds</span>:<span style=color:#bbb> </span><span style=color:#666>15</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>periodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>20</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>如你所见，TCP 检测的配置和 HTTP 检测非常相似。
下面这个例子同时使用就绪和存活探测器。kubelet 会在容器启动 5 秒后发送第一个就绪探测。
探测器会尝试连接 <code>goproxy</code> 容器的 8080 端口。
如果探测成功，这个 Pod 会被标记为就绪状态，kubelet 将继续每隔 10 秒运行一次检测。</p>
<p>除了就绪探测，这个配置包括了一个存活探测。
kubelet 会在容器启动 15 秒后进行第一次存活探测。
与就绪探测类似，活跃探测器会尝试连接 <code>goproxy</code> 容器的 8080 端口。
如果存活探测失败，容器会被重新启动。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/pods/probe/tcp-liveness-readiness.yaml
</code></pre></div>
<p>15 秒之后，通过看 Pod 事件来检测存活探测器：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe pod goproxy
</code></pre></div>
<h2 id=定义-grpc-活跃探测器>定义 gRPC 活跃探测器</h2>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.23 [alpha]</code>
</div>
<p>如果你的应用实现了 <a href=https://github.com/grpc/grpc/blob/master/doc/health-checking.md>gRPC 健康检查协议</a>，
kubelet 可以配置为使用该协议来执行应用活跃性检查。
你必须启用 <code>GRPCContainerProbe</code>
<a href=/zh/docs/reference/command-line-tools-reference/feature-gates/>特性门控</a>
才能配置依赖于 gRPC 的检查机制。</p>
<p>下面是一个示例清单：</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/pods/probe/grpc-liveness.yaml download=pods/probe/grpc-liveness.yaml><code>pods/probe/grpc-liveness.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-probe-grpc-liveness-yaml')" title="Copy pods/probe/grpc-liveness.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-probe-grpc-liveness-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>etcd-with-grpc<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>etcd<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/etcd:3.5.1-0<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#bbb> </span><span style=color:#b44>&#34;/usr/local/bin/etcd&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;--data-dir&#34;</span>,<span style=color:#bbb>  </span><span style=color:#b44>&#34;/var/lib/etcd&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;--listen-client-urls&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;http://0.0.0.0:2379&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;--advertise-client-urls&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;http://127.0.0.1:2379&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;--log-level&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;debug&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>2379</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>livenessProbe</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>grpc</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>2379</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>initialDelaySeconds</span>:<span style=color:#bbb> </span><span style=color:#666>10</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>要使用 gRPC 探测器，必须配置 <code>port</code> 属性。如果健康状态端点配置在非默认服务之上，
你还必须设置 <code>service</code> 属性。</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong>
<p>与 HTTP 和 TCP 探测器不同，gRPC 探测不能使用命名端口或定制主机。
</div>
<p>配置问题（例如：错误的 <code>port</code> 和 <code>service</code>、未实现健康检查协议）
都被认作是探测失败，这一点与 HTTP 和 TCP 探测器类似。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/pods/probe/grpc-liveness.yaml
</code></pre></div>
<p>15 秒钟之后，查看 Pod 事件确认活跃性检查并未失败：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe pod etcd-with-grpc
</code></pre></div>
<p>在 Kubernetes 1.23 之前，gRPC 健康探测通常使用
<a href=https://github.com/grpc-ecosystem/grpc-health-probe/>grpc-health-probe</a>
来实现，如博客 <a href=/blog/2018/10/01/health-checking-grpc-servers-on-kubernetes/>Health checking gRPC servers on Kubernetes（对 Kubernetes 上的 gRPC 服务器执行健康检查）</a>所描述。
内置的 gRPC 探测器行为与 <code>grpc-health-probe</code> 所实现的行为类似。
从 <code>grpc-health-probe</code> 迁移到内置探测器时，请注意以下差异：</p>
<ul>
<li>内置探测器运行时针对的是 Pod 的 IP 地址，不像 <code>grpc-health-probe</code>
那样通常针对 <code>127.0.0.1</code> 执行探测；
请一定配置你的 gRPC 端点使之监听于 Pod 的 IP 地址之上。</li>
<li>内置探测器不支持任何身份认证参数（例如 <code>tls</code>）。</li>
<li>对于内置的探测器而言，不存在错误代码。所有错误都被视作探测失败。</li>
<li>如果 <code>ExecProbeTimeout</code> 特性门控被设置为 <code>false</code>，则 <code>grpc-health-probe</code>
不会考虑 <code>timeoutSeconds</code> 设置状态（默认值为 1s），
而内置探测器则会在超时时返回失败。</li>
</ul>
<h2 id=use-a-named-port>使用命名端口</h2>
<p>对于 HTTP 或者 TCP 存活检测可以使用命名的
<a href=/docs/reference/generated/kubernetes-api/v1.23/#containerport-v1-core>ContainerPort</a>。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>liveness-port<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>8080</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>hostPort</span>:<span style=color:#bbb> </span><span style=color:#666>8080</span><span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>livenessProbe</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>httpGet</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/healthz<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span>liveness-port<span style=color:#bbb>
</span></code></pre></div>
<h2 id=define-startup-probes>使用启动探测器保护慢启动容器</h2>
<p>有时候，会有一些现有的应用在启动时需要较长的初始化时间。
要这种情况下，若要不影响对死锁作出快速响应的探测，设置存活探测参数是要技巧的。
技巧就是使用相同的命令来设置启动探测，针对 HTTP 或 TCP 检测，可以通过将
<code>failureThreshold * periodSeconds</code> 参数设置为足够长的时间来应对糟糕情况下的启动时间。</p>
<p>这样，前面的例子就变成了：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>liveness-port<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>8080</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>hostPort</span>:<span style=color:#bbb> </span><span style=color:#666>8080</span><span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>livenessProbe</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>httpGet</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/healthz<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span>liveness-port<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>failureThreshold</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>periodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>10</span><span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>startupProbe</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>httpGet</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/healthz<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span>liveness-port<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>failureThreshold</span>:<span style=color:#bbb> </span><span style=color:#666>30</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>periodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>10</span><span style=color:#bbb>
</span></code></pre></div>
<p>幸亏有启动探测，应用程序将会有最多 5 分钟（30 * 10 = 300s）的时间来完成其启动过程。
一旦启动探测成功一次，存活探测任务就会接管对容器的探测，对容器死锁作出快速响应。
如果启动探测一直没有成功，容器会在 300 秒后被杀死，并且根据 <code>restartPolicy</code> 来
执行进一步处置。</p>
<h2 id=define-readiness-probes>定义就绪探测器</h2>
<p>有时候，应用会暂时性地无法为请求提供服务。
例如，应用在启动时可能需要加载大量的数据或配置文件，或是启动后要依赖等待外部服务。
在这种情况下，既不想杀死应用，也不想给它发送请求。
Kubernetes 提供了就绪探测器来发现并缓解这些情况。
容器所在 Pod 上报还未就绪的信息，并且不接受通过 Kubernetes Service 的流量。</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 就绪探测器在容器的整个生命周期中保持运行状态。
</div>
<div class="alert alert-warning caution callout" role=alert>
<strong>Caution:</strong> 活跃探测器 <strong>不等待</strong> 就绪性探测器成功。
如果要在执行活跃探测器之前等待，应该使用 <code>initialDelaySeconds</code> 或 <code>startupProbe</code>。
</div>
<p>就绪探测器的配置和存活探测器的配置相似。
唯一区别就是要使用 <code>readinessProbe</code> 字段，而不是 <code>livenessProbe</code> 字段。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>readinessProbe</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>exec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- cat<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- /tmp/healthy<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>initialDelaySeconds</span>:<span style=color:#bbb> </span><span style=color:#666>5</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>periodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>5</span><span style=color:#bbb>
</span></code></pre></div>
<p>HTTP 和 TCP 的就绪探测器配置也和存活探测器的配置完全相同。</p>
<p>就绪和存活探测可以在同一个容器上并行使用。
两者都可以确保流量不会发给还未就绪的容器，当这些探测失败时容器会被重新启动。</p>
<h2 id=configure-probes>配置探测器</h2>
<p><a href=/docs/reference/generated/kubernetes-api/v1.23/#probe-v1-core>Probe</a>
有很多配置字段，可以使用这些字段精确地控制活跃和就绪检测的行为：</p>
<ul>
<li><code>initialDelaySeconds</code>：容器启动后要等待多少秒后才启动存活和就绪探测器，
默认是 0 秒，最小值是 0。</li>
<li><code>periodSeconds</code>：执行探测的时间间隔（单位是秒）。默认是 10 秒。最小值是 1。</li>
<li><code>timeoutSeconds</code>：探测的超时后等待多少秒。默认值是 1 秒。最小值是 1。</li>
<li><code>successThreshold</code>：探测器在失败后，被视为成功的最小连续成功数。默认值是 1。
存活和启动探测的这个值必须是 1。最小值是 1。</li>
<li><code>failureThreshold</code>：当探测失败时，Kubernetes 的重试次数。
对存活探测而言，放弃就意味着重新启动容器。
对就绪探测而言，放弃意味着 Pod 会被打上未就绪的标签。默认值是 3。最小值是 1。</li>
</ul>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong>
<p>在 Kubernetes 1.20 版本之前，<code>exec</code> 探针会忽略 <code>timeoutSeconds</code>：
探针会无限期地持续运行，甚至可能超过所配置的限期，直到返回结果为止。</p>
<p>这一缺陷在 Kubernetes v1.20 版本中得到修复。你可能一直依赖于之前错误的探测行为，
甚至都没有觉察到这一问题的存在，因为默认的超时值是 1 秒钟。
作为集群管理员，你可以在所有的 kubelet 上禁用 <code>ExecProbeTimeout</code>
<a href=/zh/docs/reference/command-line-tools-reference/feature-gates/>特性门控</a>
（将其设置为 <code>false</code>），从而恢复之前版本中的运行行为。之后当集群中所有的
exec 探针都设置了 <code>timeoutSeconds</code> 参数后，移除此标志重载。
如果你有 Pod 受到此默认 1 秒钟超时值的影响，你应该更新这些 Pod 对应的探针的超时值，
这样才能为最终去除该特性门控做好准备。</p>
<p>当此缺陷被修复之后，在使用 <code>dockershim</code> 容器运行时的 Kubernetes <code>1.20+</code>
版本中，对于 exec 探针而言，容器中的进程可能会因为超时值的设置保持持续运行，
即使探针返回了失败状态。</p>
</div>
<div class="alert alert-warning caution callout" role=alert>
<strong>Caution:</strong>
<p>如果就绪态探针的实现不正确，可能会导致容器中进程的数量不断上升。
如果不对其采取措施，很可能导致资源枯竭的状况。
</div>
<h3 id=http-probes>HTTP 探测 </h3>
<p><a href=/docs/reference/generated/kubernetes-api/v1.23/#httpgetaction-v1-core>HTTP Probes</a>
允许针对 <code>httpGet</code> 配置额外的字段：</p>
<ul>
<li><code>host</code>：连接使用的主机名，默认是 Pod 的 IP。也可以在 HTTP 头中设置 “Host” 来代替。</li>
<li><code>scheme</code> ：用于设置连接主机的方式（HTTP 还是 HTTPS）。默认是 "HTTP"。</li>
<li><code>path</code>：访问 HTTP 服务的路径。默认值为 "/"。</li>
<li><code>httpHeaders</code>：请求中自定义的 HTTP 头。HTTP 头字段允许重复。</li>
<li><code>port</code>：访问容器的端口号或者端口名。如果数字必须在 1～65535 之间。</li>
</ul>
<p>对于 HTTP 探测，kubelet 发送一个 HTTP 请求到指定的路径和端口来执行检测。
除非 <code>httpGet</code> 中的 <code>host</code> 字段设置了，否则 kubelet 默认是给 Pod 的 IP 地址发送探测。
如果 <code>scheme</code> 字段设置为了 <code>HTTPS</code>，kubelet 会跳过证书验证发送 HTTPS 请求。
大多数情况下，不需要设置<code>host</code> 字段。
这里有个需要设置 <code>host</code> 字段的场景，假设容器监听 127.0.0.1，并且 Pod 的 <code>hostNetwork</code>
字段设置为了 <code>true</code>。那么 <code>httpGet</code> 中的 <code>host</code> 字段应该设置为 127.0.0.1。
可能更常见的情况是如果 Pod 依赖虚拟主机，你不应该设置 <code>host</code> 字段，而是应该在
<code>httpHeaders</code> 中设置 <code>Host</code>。</p>
<p>针对 HTTP 探针，kubelet 除了必需的 <code>Host</code> 头部之外还发送两个请求头部字段：
<code>User-Agent</code> 和 <code>Accept</code>。这些头部的默认值分别是 <code>kube-probe/{{ skew latestVersion >}}</code>
（其中 <code>1.27</code> 是 kubelet 的版本号）和 <code>*/*</code>。</p>
<p>你可以通过为探测设置 <code>.httpHeaders</code> 来重载默认的头部字段值；例如：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>livenessProbe</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>httpGet</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>httpHeaders</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>Accept<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span>application/json<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>startupProbe</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>httpGet</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>httpHeaders</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>User-Agent<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span>MyUserAgent<span style=color:#bbb>
</span></code></pre></div>
<p>你也可以通过将这些头部字段定义为空值，从请求中去掉这些头部字段。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>livenessProbe</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>httpGet</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>httpHeaders</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>Accept<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>startupProbe</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>httpGet</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>httpHeaders</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>User-Agent<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></code></pre></div>
<h3 id=tcp-probes>TCP 探测 </h3>
<p>对于 TCP 探测而言，kubelet 在节点上（不是在 Pod 里面）发起探测连接，
这意味着你不能在 <code>host</code> 参数上配置服务名称，因为 kubelet 不能解析服务名称。</p>
<h3 id=探测器层面的-terminationgraceperiodseconds>探测器层面的 <code>terminationGracePeriodSeconds</code></h3>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.22 [beta]</code>
</div>
<p>在 1.21 发行版之前，Pod 层面的 <code>terminationGracePeriodSeconds</code>
被用来终止活跃探测或启动探测失败的容器。
这一行为上的关联不是我们想要的，可能导致 Pod 层面设置了 <code>terminationGracePeriodSeconds</code>
时容器要花非常长的时间才能重新启动。</p>
<p>在 1.21 及更高版本中，当特性门控 <code>ProbeTerminationGracePeriod</code> 被启用时，
用户可以指定一个探测器层面的 <code>terminationGracePeriodSeconds</code> 作为探测器规约的一部分。
当该特性门控被启用，并且 Pod 层面和探测器层面的 <code>terminationGracePeriodSeconds</code>
都已设置，kubelet 将使用探测器层面设置的值。</p>
<p>在 Kubernetes 1.22 中，<code>ProbeTerminationGracePeriod</code> 特性门控只能用在 API 服务器上。
kubelet 始终遵守探针级别 <code>terminationGracePeriodSeconds</code> 字段
（如果它存在于 Pod 上）。</p>
<p>如果你已经为现有 Pod 设置了 <code>terminationGracePeriodSeconds</code>
字段并且不再希望使用针对每个探针的终止宽限期，则必须删除现有的这类 Pod。</p>
<p>当你（或控制平面或某些其他组件）创建替换 Pod，并且特性门控 <code>ProbeTerminationGracePeriod</code>
被禁用时，API 服务器会忽略 Pod 级别的 <code>terminationGracePeriodSeconds</code> 字段设置，
即使 Pod 或 Pod 模板指定了它。</p>
<p>例如:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>terminationGracePeriodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>3600</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># pod-level</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>...<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>liveness-port<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>8080</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>hostPort</span>:<span style=color:#bbb> </span><span style=color:#666>8080</span><span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>livenessProbe</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>httpGet</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/healthz<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span>liveness-port<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>failureThreshold</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>periodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>60</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># Override pod-level terminationGracePeriodSeconds #</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>terminationGracePeriodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>60</span><span style=color:#bbb>
</span></code></pre></div>
<p>探测器层面的 <code>terminationGracePeriodSeconds</code> 不能用于就绪态探针。
这一设置将被 API 服务器拒绝。</p>
<h2 id=what-s-next>What's next</h2>
<ul>
<li>进一步了解<a href=/zh/docs/concepts/workloads/pods/pod-lifecycle/#container-probes>容器探针</a>。</li>
</ul>
<p>你也可以阅读以下的 API 参考资料：</p>
<ul>
<li><a href=/docs/reference/generated/kubernetes-api/v1.23/#pod-v1-core>Pod</a></li>
<li><a href=/docs/reference/generated/kubernetes-api/v1.23/#container-v1-core>Container</a></li>
<li><a href=/docs/reference/generated/kubernetes-api/v1.23/#probe-v1-core>Probe</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-bbc17480da6d051c696489654c64064a>5.15 - 将 Pod 分配给节点</h1>
<p>此页面显示如何将 Kubernetes Pod 分配给 Kubernetes 集群中的特定节点。</p>
<h2 id=before-you-begin>Before you begin</h2>
<p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li>
</ul>
To check the version, enter <code>kubectl version</code>.
</p>
<h2 id=给节点添加标签>给节点添加标签</h2>
<ol>
<li>
<p>列出集群中的节点</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get nodes
</code></pre></div>
<p>输出类似如下：</p>
<pre><code>NAME      STATUS    AGE     VERSION
worker0   Ready     1d      v1.6.0+fff5156
worker1   Ready     1d      v1.6.0+fff5156
worker2   Ready     1d      v1.6.0+fff5156
</code></pre></li>
</ol>
<ol start=2>
<li>
<p>选择其中一个节点，为它添加标签：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl label nodes &lt;your-node-name&gt; <span style=color:#b8860b>disktype</span><span style=color:#666>=</span>ssd
</code></pre></div>
<p><code>&lt;your-node-name></code> 是你选择的节点的名称。</p>
</li>
</ol>
<ol start=3>
<li>
<p>验证你选择的节点是否有 <code>disktype=ssd</code> 标签：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get nodes --show-labels
</code></pre></div>
<p>输出类似如下：</p>
<pre><code>NAME      STATUS    AGE     VERSION            LABELS
worker0   Ready     1d      v1.6.0+fff5156     ...,disktype=ssd,kubernetes.io/hostname=worker0
worker1   Ready     1d      v1.6.0+fff5156     ...,kubernetes.io/hostname=worker1
worker2   Ready     1d      v1.6.0+fff5156     ...,kubernetes.io/hostname=worker2
</code></pre>
<p>在前面的输出中，你可以看到 <code>worker0</code> 节点有 <code>disktype=ssd</code> 标签。</p>
</li>
</ol>
<h2 id=创建一个调度到你选择的节点的-pod>创建一个调度到你选择的节点的 pod</h2>
<p>此 Pod 配置文件描述了一个拥有节点选择器 <code>disktype: ssd</code> 的 Pod。这表明该 Pod 将被调度到
有 <code>disktype=ssd</code> 标签的节点。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/pods/pod-nginx.yaml download=pods/pod-nginx.yaml><code>pods/pod-nginx.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-pod-nginx-yaml')" title="Copy pods/pod-nginx.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-pod-nginx-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb> </span>test<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>imagePullPolicy</span>:<span style=color:#bbb> </span>IfNotPresent<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>nodeSelector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>disktype</span>:<span style=color:#bbb> </span>ssd<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<ol>
<li>
<p>使用该配置文件去创建一个 pod，该 pod 将被调度到你选择的节点上：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create -f https://k8s.io/examples/pods/pod-nginx.yaml
</code></pre></div></li>
</ol>
<ol start=2>
<li>
<p>验证 pod 是不是运行在你选择的节点上：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods --output<span style=color:#666>=</span>wide
</code></pre></div>
<p>输出类似如下：</p>
<pre><code>NAME     READY     STATUS    RESTARTS   AGE    IP           NODE
nginx    1/1       Running   0          13s    10.200.0.4   worker0
</code></pre></li>
</ol>
<h2 id=what-s-next>What's next</h2>
<p>进一步了解<a href=/zh/docs/concepts/overview/working-with-objects/labels/>标签和选择器</a></p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-fc3f4777ae8ea685d2b54e175277ac01>5.16 - 用节点亲和性把 Pods 分配到节点</h1>
<p>本页展示在 Kubernetes 集群中，如何使用节点亲和性把 Kubernetes Pod 分配到特定节点。</p>
<h2 id=before-you-begin>Before you begin</h2>
<p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li>
</ul>
Your Kubernetes server must be at or later than version v1.10.
To check the version, enter <code>kubectl version</code>.
</p>
<h2 id=给节点添加标签>给节点添加标签</h2>
<ol>
<li>
<p>列出集群中的节点及其标签：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get nodes --show-labels
</code></pre></div>
<p>输出类似于此：</p>
<pre><code>NAME      STATUS    ROLES    AGE     VERSION        LABELS
worker0   Ready     &lt;none&gt;   1d      v1.13.0        ...,kubernetes.io/hostname=worker0
worker1   Ready     &lt;none&gt;   1d      v1.13.0        ...,kubernetes.io/hostname=worker1
worker2   Ready     &lt;none&gt;   1d      v1.13.0        ...,kubernetes.io/hostname=worker2
</code></pre>
</li>
<li>
<p>选择一个节点，给它添加一个标签：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl label nodes &lt;your-node-name&gt; <span style=color:#b8860b>disktype</span><span style=color:#666>=</span>ssd
</code></pre></div>
<p>其中 <code>&lt;your-node-name></code> 是你所选节点的名称。</p>
</li>
<li>
<p>验证你所选节点具有 <code>disktype=ssd</code> 标签：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get nodes --show-labels
</code></pre></div>
<p>输出类似于此：</p>
<pre><code>NAME      STATUS    ROLES    AGE     VERSION        LABELS
worker0   Ready     &lt;none&gt;   1d      v1.13.0        ...,disktype=ssd,kubernetes.io/hostname=worker0
worker1   Ready     &lt;none&gt;   1d      v1.13.0        ...,kubernetes.io/hostname=worker1
worker2   Ready     &lt;none&gt;   1d      v1.13.0        ...,kubernetes.io/hostname=worker2
</code></pre>
<p>在前面的输出中，可以看到 <code>worker0</code> 节点有一个 <code>disktype=ssd</code> 标签。</p>
</li>
</ol>
<h2 id=schedule-a-Pod-using-required-node-affinity>依据强制的节点亲和性调度 Pod </h2>
<p>下面清单描述了一个 Pod，它有一个节点亲和性配置 <code>requiredDuringSchedulingIgnoredDuringExecution</code>，<code>disktype=ssd</code>。
这意味着 pod 只会被调度到具有 <code>disktype=ssd</code> 标签的节点上。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/pods/pod-nginx-required-affinity.yaml download=pods/pod-nginx-required-affinity.yaml><code>pods/pod-nginx-required-affinity.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-pod-nginx-required-affinity-yaml')" title="Copy pods/pod-nginx-required-affinity.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-pod-nginx-required-affinity-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>affinity</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>nodeAffinity</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requiredDuringSchedulingIgnoredDuringExecution</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>nodeSelectorTerms</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>disktype<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span>In<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>values</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span>- ssd            <span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>imagePullPolicy</span>:<span style=color:#bbb> </span>IfNotPresent<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<ol>
<li>
<p>执行（Apply）此清单来创建一个调度到所选节点上的 Pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/pods/pod-nginx-required-affinity.yaml
</code></pre></div>
</li>
<li>
<p>验证 pod 已经在所选节点上运行：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods --output<span style=color:#666>=</span>wide
</code></pre></div>
<p>输出类似于此：</p>
<pre><code>NAME     READY     STATUS    RESTARTS   AGE    IP           NODE
nginx    1/1       Running   0          13s    10.200.0.4   worker0
</code></pre></li>
</ol>
<h2 id=schedule-a-Pod-using-preferred-node-affinity>使用首选的节点亲和性调度 Pod</h2>
<p>本清单描述了一个Pod，它有一个节点亲和性设置 <code>preferredDuringSchedulingIgnoredDuringExecution</code>，<code>disktype: ssd</code>。
这意味着 pod 将首选具有 <code>disktype=ssd</code> 标签的节点。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/pods/pod-nginx-preferred-affinity.yaml download=pods/pod-nginx-preferred-affinity.yaml><code>pods/pod-nginx-preferred-affinity.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-pod-nginx-preferred-affinity-yaml')" title="Copy pods/pod-nginx-preferred-affinity.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-pod-nginx-preferred-affinity-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>affinity</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>nodeAffinity</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>preferredDuringSchedulingIgnoredDuringExecution</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>weight</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>preference</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>disktype<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span>In<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>values</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span>- ssd          <span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>imagePullPolicy</span>:<span style=color:#bbb> </span>IfNotPresent<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<ol>
<li>
<p>执行此清单创建一个会调度到所选节点上的 Pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/pods/pod-nginx-preferred-affinity.yaml
</code></pre></div>
</li>
<li>
<p>验证 pod 是否在所选节点上运行：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods --output<span style=color:#666>=</span>wide
</code></pre></div>
<p>输出类似于此：</p>
<pre><code>NAME     READY     STATUS    RESTARTS   AGE    IP           NODE
nginx    1/1       Running   0          13s    10.200.0.4   worker0
</code></pre></li>
</ol>
<h2 id=what-s-next>What's next</h2>
<p>进一步了解
<a href=/zh/docs/concepts/scheduling-eviction/assign-pod-node/#node-affinity>节点亲和性</a>.</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-1e7baac1825631a5af5d2aebcf059249>5.17 - 配置 Pod 初始化</h1>
<p>本文介绍在应用容器运行前，怎样利用 Init 容器初始化 Pod。</p>
<h2 id=before-you-begin>Before you begin</h2>
<p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li>
</ul>
To check the version, enter <code>kubectl version</code>.
</p>
<h2 id=creating-a-pod-that-has-an-init-container>创建一个包含 Init 容器的 Pod </h2>
<p>本例中你将创建一个包含一个应用容器和一个 Init 容器的 Pod。Init 容器在应用容器启动前运行完成。</p>
<p>下面是 Pod 的配置文件：</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/pods/init-containers.yaml download=pods/init-containers.yaml><code>pods/init-containers.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-init-containers-yaml')" title="Copy pods/init-containers.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-init-containers-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>init-demo<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>workdir<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/usr/share/nginx/html<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># These containers are run during pod initialization</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>initContainers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>install<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox:1.28<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- wget<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;-O&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;/work-dir/index.html&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span>- http://info.cern.ch<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>workdir<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/work-dir&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>dnsPolicy</span>:<span style=color:#bbb> </span>Default<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>workdir<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>emptyDir</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>配置文件中，你可以看到应用容器和 Init 容器共享了一个卷。</p>
<p>Init 容器将共享卷挂载到了 <code>/work-dir</code> 目录，应用容器将共享卷挂载到了 <code>/usr/share/nginx/html</code> 目录。
Init 容器执行完下面的命令就终止：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>wget -O /work-dir/index.html http://info.cern.ch
</code></pre></div>
<p>请注意 Init 容器在 nginx 服务器的根目录写入 <code>index.html</code>。</p>
<p>创建 Pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create -f https://k8s.io/examples/pods/init-containers.yaml
</code></pre></div>
<p>检查 nginx 容器运行正常：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod init-demo
</code></pre></div>
<p>结果表明 nginx 容器运行正常：</p>
<pre><code>NAME        READY     STATUS    RESTARTS   AGE
init-demo   1/1       Running   0          1m
</code></pre>
<p>通过 shell 进入 init-demo Pod 中的 nginx 容器：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#a2f>exec</span> -it init-demo -- /bin/bash
</code></pre></div>
<p>在 shell 中，发送个 GET 请求到 nginx 服务器：</p>
<pre><code>root@nginx:~# apt-get update
root@nginx:~# apt-get install curl
root@nginx:~# curl localhost
</code></pre>
<p>结果表明 nginx 正在为 Init 容器编写的 web 页面服务：</p>
<pre><code>&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;header&gt;
&lt;title&gt;http://info.cern.ch&lt;/title&gt;
&lt;/header&gt;

&lt;h1&gt;http://info.cern.ch - home of the first website&lt;/h1&gt;
  ...
&lt;li&gt;&lt;a href=&quot;http://info.cern.ch/hypertext/WWW/TheProject.html&quot;&gt;Browse the first website&lt;/a&gt;&lt;/li&gt;
  ...
</code></pre><h2 id=what-s-next>What's next</h2>
<ul>
<li>进一步了解<a href=/zh/docs/tasks/access-application-cluster/communicate-containers-same-pod-shared-volume/>同一 Pod 中的容器间的通信</a>。</li>
<li>进一步了解 <a href=/zh/docs/concepts/workloads/pods/init-containers/>Init 容器</a>。</li>
<li>进一步了解<a href=/zh/docs/concepts/storage/volumes/>卷</a>。</li>
<li>进一步了解 <a href=/zh/docs/tasks/debug-application-cluster/debug-init-containers/>Init 容器排错</a>。</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-efbc43486296f0439d1a89c12d944d94>5.18 - 为容器的生命周期事件设置处理函数</h1>
<p>这个页面将演示如何为容器的生命周期事件挂接处理函数。Kubernetes 支持 postStart 和 preStop 事件。
当一个容器启动后，Kubernetes 将立即发送 postStart 事件；在容器被终结之前，
Kubernetes 将发送一个 preStop 事件。容器可以为每个事件指定一个处理程序。</p>
<h2 id=before-you-begin>Before you begin</h2>
<p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li>
</ul>
To check the version, enter <code>kubectl version</code>.
</p>
<h2 id=定义-poststart-和-prestop-处理函数>定义 postStart 和 preStop 处理函数</h2>
<p>在本练习中，你将创建一个包含一个容器的 Pod，该容器为 postStart 和 preStop 事件提供对应的处理函数。</p>
<p>下面是对应 Pod 的配置文件：</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/pods/lifecycle-events.yaml download=pods/lifecycle-events.yaml><code>pods/lifecycle-events.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-lifecycle-events-yaml')" title="Copy pods/lifecycle-events.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-lifecycle-events-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>lifecycle-demo<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>lifecycle-demo-container<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>lifecycle</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>postStart</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>exec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;/bin/sh&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;-c&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;echo Hello from the postStart handler &gt; /usr/share/message&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>preStop</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>exec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;/bin/sh&#34;</span>,<span style=color:#b44>&#34;-c&#34;</span>,<span style=color:#b44>&#34;nginx -s quit; while killall -0 nginx; do sleep 1; done&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>在上述配置文件中，你可以看到 postStart 命令在容器的 <code>/usr/share</code> 目录下写入文件 <code>message</code>。
命令 preStop 负责优雅地终止 nginx 服务。当因为失效而导致容器终止时，这一处理方式很有用。</p>
<p>创建 Pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/pods/lifecycle-events.yaml
</code></pre></div>
<p>验证 Pod 中的容器已经运行：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod lifecycle-demo
</code></pre></div>
<p>使用 shell 连接到你的 Pod 里的容器：</p>
<pre><code>kubectl exec -it lifecycle-demo -- /bin/bash
</code></pre>
<p>在 shell 中，验证 <code>postStart</code> 处理函数创建了 <code>message</code> 文件：</p>
<pre><code>root@lifecycle-demo:/# cat /usr/share/message
</code></pre>
<p>命令行输出的是 <code>postStart</code> 处理函数所写入的文本</p>
<pre><code>Hello from the postStart handler
</code></pre>
<h2 id=讨论>讨论</h2>
<p>Kubernetes 在容器创建后立即发送 postStart 事件。
然而，postStart 处理函数的调用不保证早于容器的入口点（entrypoint）
的执行。postStart 处理函数与容器的代码是异步执行的，但 Kubernetes
的容器管理逻辑会一直阻塞等待 postStart 处理函数执行完毕。
只有 postStart 处理函数执行完毕，容器的状态才会变成
RUNNING。</p>
<p>Kubernetes 在容器结束前立即发送 preStop 事件。除非 Pod 宽限期限超时，Kubernetes 的容器管理逻辑
会一直阻塞等待 preStop 处理函数执行完毕。更多的相关细节，可以参阅
<a href=/zh/docs/concepts/workloads/pods/pod-lifecycle/#pod-termination>Pods 的结束</a>。</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> Kubernetes 只有在 Pod <em>结束（Terminated）</em> 的时候才会发送 preStop 事件，
这意味着在 Pod <em>完成（Completed）</em> 时
preStop 的事件处理逻辑不会被触发。这个限制在
<a href=https://github.com/kubernetes/kubernetes/issues/55807>issue #55087</a> 中被追踪。
</div>
<h2 id=what-s-next>What's next</h2>
<ul>
<li>进一步了解<a href=/zh/docs/concepts/containers/container-lifecycle-hooks/>容器生命周期回调</a>。</li>
<li>进一步了解<a href=/zh/docs/concepts/workloads/pods/pod-lifecycle/>Pod 的生命周期</a>。</li>
</ul>
<h3 id=参考>参考</h3>
<ul>
<li><a href=/docs/reference/generated/kubernetes-api/v1.23/#lifecycle-v1-core>Lifecycle</a></li>
<li><a href=/docs/reference/generated/kubernetes-api/v1.23/#container-v1-core>Container</a></li>
<li>参阅 <a href=/docs/reference/generated/kubernetes-api/v1.23/#podspec-v1-core>PodSpec</a> 中关于<code>terminationGracePeriodSeconds</code> 的部分</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-ed34e761c3dbd00fa79577fa78e30020>5.19 - 配置 Pod 使用 ConfigMap</h1>
<p>很多应用在其初始化或运行期间要依赖一些配置信息。大多数时候，
存在要调整配置参数所设置的数值的需求。
ConfigMap 是 Kubernetes 用来向应用 Pod 中注入配置数据的方法。</p>
<p>ConfigMap 允许你将配置文件与镜像文件分离，以使容器化的应用程序具有可移植性。
本页提供了一系列使用示例，这些示例演示了如何创建 ConfigMap 以及配置 Pod
使用存储在 ConfigMap 中的数据。</p>
<h2 id=before-you-begin>Before you begin</h2>
<p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li>
</ul>
To check the version, enter <code>kubectl version</code>.
</p>
<h2 id=创建-configmap>创建 ConfigMap</h2>
<p>你可以使用 <code>kubectl create configmap</code> 或者在 <code>kustomization.yaml</code> 中的 ConfigMap
生成器来创建 ConfigMap。注意，<code>kubectl</code> 从 1.14 版本开始支持 <code>kustomization.yaml</code>。</p>
<h3 id=使用-kubectl-create-configmap-创建-configmap>使用 kubectl create configmap 创建 ConfigMap</h3>
<p>你可以使用 <code>kubectl create configmap</code>
命令基于<a href=#create-configmaps-from-directories>目录</a>、
<a href=#create-configmaps-from-files>文件</a>或者<a href=#create-configmaps-from-literal-values>字面值</a>来创建
ConfigMap：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create configmap &lt;映射名称&gt; &lt;数据源&gt;
</code></pre></div>
<p>其中，<code>&lt;映射名称></code> 是为 ConfigMap 指定的名称，<code>&lt;数据源></code> 是要从中提取数据的目录、
文件或者字面值。
ConfigMap 对象的名称必须是合法的
<a href=/zh/docs/concepts/overview/working-with-objects/names#dns-subdomain-names>DNS 子域名</a>.</p>
<p>在你基于文件来创建 ConfigMap 时，<code>&lt;数据源></code> 中的键名默认取自文件的基本名，
而对应的值则默认为文件的内容。</p>
<p>你可以使用<a href=/docs/reference/generated/kubectl/kubectl-commands/#describe><code>kubectl describe</code></a> 或者
<a href=/docs/reference/generated/kubectl/kubectl-commands/#get><code>kubectl get</code></a> 获取有关 ConfigMap 的信息。</p>
<h4 id=create-configmaps-from-directories>基于目录创建 ConfigMap </h4>
<p>你可以使用 <code>kubectl create configmap</code> 基于同一目录中的多个文件创建 ConfigMap。
当你基于目录来创建 ConfigMap 时，kubectl 识别目录下基本名可以作为合法键名的文件，
并将这些文件打包到新的 ConfigMap 中。普通文件之外的所有目录项都会被忽略
（例如：子目录、符号链接、设备、管道等等）。</p>
<p>例如：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># 创建本地目录</span>
mkdir -p configure-pod-container/configmap/

<span style=color:#080;font-style:italic># 将实例文件下载到 `configure-pod-container/configmap/` 目录</span>
wget https://kubernetes.io/examples/configmap/game.properties -O configure-pod-container/configmap/game.properties
wget https://kubernetes.io/examples/configmap/ui.properties -O configure-pod-container/configmap/ui.properties

<span style=color:#080;font-style:italic># 创建 configmap</span>
kubectl create configmap game-config --from-file<span style=color:#666>=</span>configure-pod-container/configmap/
</code></pre></div>
<p>以上命令将 <code>configure-pod-container/configmap</code> 目录下的所有文件，也就是
<code>game.properties</code> 和 <code>ui.properties</code> 打包到 game-config ConfigMap
中。你可以使用下面的命令显示 ConfigMap 的详细信息：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe configmaps game-config
</code></pre></div>
<p>输出类似以下内容：</p>
<pre><code>Name:         game-config
Namespace:    default
Labels:       &lt;none&gt;
Annotations:  &lt;none&gt;

Data
====
game.properties:
----
enemies=aliens
lives=3
enemies.cheat=true
enemies.cheat.level=noGoodRotten
secret.code.passphrase=UUDDLRLRBABAS
secret.code.allowed=true
secret.code.lives=30
ui.properties:
----
color.good=purple
color.bad=yellow
allow.textmode=true
how.nice.to.look=fairlyNice
</code></pre>
<p><code>configure-pod-container/configmap/</code> 目录中的 <code>game.properties</code> 和 <code>ui.properties</code>
文件出现在 ConfigMap 的 <code>data</code> 部分。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get configmaps game-config -o yaml
</code></pre></div>
<p>输出类似以下内容:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>creationTimestamp</span>:<span style=color:#bbb> </span>2016-02-18T18:52:05Z<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>game-config<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resourceVersion</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;516&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selfLink</span>:<span style=color:#bbb> </span>/api/v1/namespaces/default/configmaps/game-config<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>uid</span>:<span style=color:#bbb> </span>b4952dc3-d670-11e5-8cd0-68f728db1985<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>game.properties</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span><span style=color:#b44;font-style:italic>    enemies=aliens
</span><span style=color:#b44;font-style:italic>    lives=3
</span><span style=color:#b44;font-style:italic>    enemies.cheat=true
</span><span style=color:#b44;font-style:italic>    enemies.cheat.level=noGoodRotten
</span><span style=color:#b44;font-style:italic>    secret.code.passphrase=UUDDLRLRBABAS
</span><span style=color:#b44;font-style:italic>    secret.code.allowed=true
</span><span style=color:#b44;font-style:italic>    secret.code.lives=30</span><span style=color:#bbb>    
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ui.properties</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span><span style=color:#b44;font-style:italic>    color.good=purple
</span><span style=color:#b44;font-style:italic>    color.bad=yellow
</span><span style=color:#b44;font-style:italic>    allow.textmode=true
</span><span style=color:#b44;font-style:italic>    how.nice.to.look=fairlyNice</span><span style=color:#bbb>    
</span></code></pre></div>
<h4 id=create-configmaps-from-files>基于文件创建 ConfigMap </h4>
<p>你可以使用 <code>kubectl create configmap</code> 基于单个文件或多个文件创建 ConfigMap。</p>
<p>例如：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create configmap game-config-2 --from-file<span style=color:#666>=</span>configure-pod-container/configmap/game.properties
</code></pre></div>
<p>将产生以下 ConfigMap:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe configmaps game-config-2
</code></pre></div>
<p>输出类似以下内容:</p>
<pre><code>Name:         game-config-2
Namespace:    default
Labels:       &lt;none&gt;
Annotations:  &lt;none&gt;

Data
====
game.properties:
----
enemies=aliens
lives=3
enemies.cheat=true
enemies.cheat.level=noGoodRotten
secret.code.passphrase=UUDDLRLRBABAS
secret.code.allowed=true
secret.code.lives=30
</code></pre>
<p>你可以多次使用 <code>--from-file</code> 参数，从多个数据源创建 ConfigMap。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create configmap game-config-2 --from-file<span style=color:#666>=</span>configure-pod-container/configmap/game.properties --from-file<span style=color:#666>=</span>configure-pod-container/configmap/ui.properties
</code></pre></div>
<p>描述上面创建的 <code>game-config-2</code> ConfigMap：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe configmaps game-config-2
</code></pre></div>
<p>输出类似以下内容:</p>
<pre><code>Name:         game-config-2
Namespace:    default
Labels:       &lt;none&gt;
Annotations:  &lt;none&gt;

Data
====
game.properties:
----
enemies=aliens
lives=3
enemies.cheat=true
enemies.cheat.level=noGoodRotten
secret.code.passphrase=UUDDLRLRBABAS
secret.code.allowed=true
secret.code.lives=30
ui.properties:
----
color.good=purple
color.bad=yellow
allow.textmode=true
how.nice.to.look=fairlyNice
</code></pre>
<p>当 <code>kubectl</code> 基于非 ASCII 或 UTF-8 的输入创建 ConfigMap 时，
该工具将这些输入放入 ConfigMap 的 <code>binaryData</code> 字段，而不是 <code>data</code> 中。
同一个 ConfigMap 中可同时包含文本数据和二进制数据源。
如果你想查看 ConfigMap 中的 <code>binaryData</code> 键（及其值），
你可以运行 <code>kubectl get configmap -o jsonpath='{.binaryData}' &lt;name></code>。</p>
<p>使用 <code>--from-env-file</code> 选项从环境文件创建 ConfigMap，例如：</p>
<p>Env 文件包含环境变量列表。其中适用以下语法规则:</p>
<ul>
<li>Env 文件中的每一行必须为 VAR=VAL 格式。</li>
<li>以＃开头的行（即注释）将被忽略。</li>
<li>空行将被忽略。</li>
<li>引号不会被特殊处理（即它们将成为 ConfigMap 值的一部分）。</li>
</ul>
<p>将示例文件下载到 <code>configure-pod-container/configmap/</code> 目录：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>wget https://kubernetes.io/examples/configmap/game-env-file.properties -O configure-pod-container/configmap/game-env-file.properties
wget https://kubernetes.io/examples/configmap/ui-env-file.properties -O configure-pod-container/configmap/ui-env-file.properties
</code></pre></div><p>Env 文件 <code>game-env-file.properties</code> 如下所示：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>cat configure-pod-container/configmap/game-env-file.properties
</code></pre></div><pre><code>enemies=aliens
lives=3
allowed=&quot;true&quot;
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create configmap game-config-env-file <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>       --from-env-file<span style=color:#666>=</span>configure-pod-container/configmap/game-env-file.properties
</code></pre></div>
<p>将产生以下 ConfigMap：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get configmap game-config-env-file -o yaml
</code></pre></div>
<p>输出类似以下内容：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>creationTimestamp</span>:<span style=color:#bbb> </span>2017-12-27T18:36:28Z<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>game-config-env-file<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resourceVersion</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;809965&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selfLink</span>:<span style=color:#bbb> </span>/api/v1/namespaces/default/configmaps/game-config-env-file<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>uid</span>:<span style=color:#bbb> </span>d9d1ca5b-eb34-11e7-887b-42010a8002b8<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>allowed</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;&#34;true&#34;&#39;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>enemies</span>:<span style=color:#bbb> </span>aliens<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>lives</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;3&#34;</span><span style=color:#bbb>
</span></code></pre></div>
<p>从 Kubernetes 1.23 版本开始，<code>kubectl</code> 支持多次指定 <code>--from-env-file</code> 参数来从多个数据源创建 ConfigMap。</p>
<p>下面是一个多次使用 <code>--from-env-file</code> 参数的示例：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create configmap config-multi-env-files <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>        --from-env-file<span style=color:#666>=</span>configure-pod-container/configmap/game-env-file.properties <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>        --from-env-file<span style=color:#666>=</span>configure-pod-container/configmap/ui-env-file.properties
</code></pre></div>
<p>将产生以下 ConfigMap:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get configmap config-multi-env-files -o yaml
</code></pre></div>
<p>输出类似以下内容:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>creationTimestamp</span>:<span style=color:#bbb> </span>2017-12-27T18:38:34Z<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>config-multi-env-files<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resourceVersion</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;810136&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selfLink</span>:<span style=color:#bbb> </span>/api/v1/namespaces/default/configmaps/config-multi-env-files<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>uid</span>:<span style=color:#bbb> </span>252c4572-eb35-11e7-887b-42010a8002b8<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>allowed</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;&#34;true&#34;&#39;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>color</span>:<span style=color:#bbb> </span>purple<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>enemies</span>:<span style=color:#bbb> </span>aliens<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>how</span>:<span style=color:#bbb> </span>fairlyNice<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>lives</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;3&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>textmode</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span></code></pre></div>
<h4 id=定义从文件创建-configmap-时要使用的键>定义从文件创建 ConfigMap 时要使用的键</h4>
<p>在使用 <code>--from-file</code> 参数时，你可以定义在 ConfigMap 的 <code>data</code> 部分出现键名，
而不是按默认行为使用文件名：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create configmap game-config-3 --from-file<span style=color:#666>=</span>&lt;我的键名&gt;<span style=color:#666>=</span>&lt;文件路径&gt;
</code></pre></div>
<p><code>&lt;我的键名></code> 是你要在 ConfigMap 中使用的键名，<code>&lt;文件路径></code> 是你想要键所表示的数据源文件的位置。</p>
<p>例如:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create configmap game-config-3 --from-file<span style=color:#666>=</span>game-special-key<span style=color:#666>=</span>configure-pod-container/configmap/game.properties
</code></pre></div>
<p>将产生以下 ConfigMap:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get configmaps game-config-3 -o yaml
</code></pre></div>
<p>输出类似以下内容：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>creationTimestamp</span>:<span style=color:#bbb> </span>2016-02-18T18:54:22Z<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>game-config-3<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resourceVersion</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;530&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selfLink</span>:<span style=color:#bbb> </span>/api/v1/namespaces/default/configmaps/game-config-3<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>uid</span>:<span style=color:#bbb> </span>05f8da22-d671-11e5-8cd0-68f728db1985<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>game-special-key</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span><span style=color:#b44;font-style:italic>    enemies=aliens
</span><span style=color:#b44;font-style:italic>    lives=3
</span><span style=color:#b44;font-style:italic>    enemies.cheat=true
</span><span style=color:#b44;font-style:italic>    enemies.cheat.level=noGoodRotten
</span><span style=color:#b44;font-style:italic>    secret.code.passphrase=UUDDLRLRBABAS
</span><span style=color:#b44;font-style:italic>    secret.code.allowed=true
</span><span style=color:#b44;font-style:italic>    secret.code.lives=30</span><span style=color:#bbb>    
</span></code></pre></div>
<h4 id=create-configmaps-from-literal-values>根据字面值创建 ConfigMap </h4>
<p>你可以将 <code>kubectl create configmap</code> 与 <code>--from-literal</code> 参数一起使用，
通过命令行定义文字值：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create configmap special-config --from-literal<span style=color:#666>=</span>special.how<span style=color:#666>=</span>very --from-literal<span style=color:#666>=</span>special.type<span style=color:#666>=</span>charm
</code></pre></div>
<p>你可以传入多个键值对。命令行中提供的每对键值在 ConfigMap 的 <code>data</code> 部分中均表示为单独的条目。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get configmaps special-config -o yaml
</code></pre></div>
<p>输出类似以下内容:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>creationTimestamp</span>:<span style=color:#bbb> </span>2016-02-18T19:14:38Z<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>special-config<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resourceVersion</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;651&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selfLink</span>:<span style=color:#bbb> </span>/api/v1/namespaces/default/configmaps/special-config<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>uid</span>:<span style=color:#bbb> </span>dadce046-d673-11e5-8cd0-68f728db1985<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>special.how</span>:<span style=color:#bbb> </span>very<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>special.type</span>:<span style=color:#bbb> </span>charm<span style=color:#bbb>
</span></code></pre></div>
<h3 id=基于生成器创建-configmap>基于生成器创建 ConfigMap</h3>
<p>自 1.14 开始，<code>kubectl</code> 开始支持 <code>kustomization.yaml</code>。
你还可以基于生成器（Generators）创建 ConfigMap，然后将其应用于 API 服务器上创建对象。
生成器应在目录内的 <code>kustomization.yaml</code> 中指定。</p>
<h4 id=基于文件生成-configmap>基于文件生成 ConfigMap</h4>
<p>例如，要基于 <code>configure-pod-container/configmap/kubectl/game.properties</code>
文件生成一个 ConfigMap：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># 创建包含 ConfigMapGenerator 的 kustomization.yaml 文件</span>
cat <span style=color:#b44>&lt;&lt;EOF &gt;./kustomization.yaml
</span><span style=color:#b44>configMapGenerator:
</span><span style=color:#b44>- name: game-config-4
</span><span style=color:#b44>  files:
</span><span style=color:#b44>  - configure-pod-container/configmap/kubectl/game.properties
</span><span style=color:#b44>EOF</span>
</code></pre></div>
<p>应用（Apply）kustomization 目录创建 ConfigMap 对象：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -k .
</code></pre></div><pre><code>configmap/game-config-4-m9dm2f92bt created
</code></pre>
<p>你可以检查 ConfigMap 被创建如下：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get configmap
</code></pre></div><pre><code>NAME                       DATA   AGE
game-config-4-m9dm2f92bt   1      37s


kubectl describe configmaps/game-config-4-m9dm2f92bt
Name:         game-config-4-m9dm2f92bt
Namespace:    default
Labels:       &lt;none&gt;
Annotations:  kubectl.kubernetes.io/last-applied-configuration:
                {&quot;apiVersion&quot;:&quot;v1&quot;,&quot;data&quot;:{&quot;game.properties&quot;:&quot;enemies=aliens\nlives=3\nenemies.cheat=true\nenemies.cheat.level=noGoodRotten\nsecret.code.p...

Data
====
game.properties:
----
enemies=aliens
lives=3
enemies.cheat=true
enemies.cheat.level=noGoodRotten
secret.code.passphrase=UUDDLRLRBABAS
secret.code.allowed=true
secret.code.lives=30
Events:  &lt;none&gt;
</code></pre>
<p>请注意，生成的 ConfigMap 名称具有通过对内容进行散列而附加的后缀，
这样可以确保每次修改内容时都会生成新的 ConfigMap。</p>
<h4 id=定义从文件生成-configmap-时要使用的键>定义从文件生成 ConfigMap 时要使用的键</h4>
<p>在 ConfigMap 生成器中，你可以定义一个非文件名的键名。
例如，从 <code>configure-pod-container/configmap/game.properties</code> 文件生成 ConfigMap，
但使用 <code>game-special-key</code> 作为键名：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># 创建包含 ConfigMapGenerator 的 kustomization.yaml 文件</span>
cat <span style=color:#b44>&lt;&lt;EOF &gt;./kustomization.yaml
</span><span style=color:#b44>configMapGenerator:
</span><span style=color:#b44>- name: game-config-5
</span><span style=color:#b44>  files:
</span><span style=color:#b44>  - game-special-key=configure-pod-container/configmap/kubectl/game.properties
</span><span style=color:#b44>EOF</span>
</code></pre></div>
<p>应用 Kustomization 目录创建 ConfigMap 对象。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -k .
</code></pre></div><pre><code>configmap/game-config-5-m67dt67794 created
</code></pre>
<h4 id=基于字面值生成-configmap>基于字面值生成 ConfigMap</h4>
<p>要基于字符串 <code>special.type=charm</code> 和 <code>special.how=very</code> 生成 ConfigMap，
可以在 <code>kusotmization.yaml</code> 中配置 ConfigMap 生成器：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># 创建带有 ConfigMapGenerator 的 kustomization.yaml 文件</span>
cat <span style=color:#b44>&lt;&lt;EOF &gt;./kustomization.yaml
</span><span style=color:#b44>configMapGenerator:
</span><span style=color:#b44>- name: special-config-2
</span><span style=color:#b44>  literals:
</span><span style=color:#b44>  - special.how=very
</span><span style=color:#b44>  - special.type=charm
</span><span style=color:#b44>EOF</span>
</code></pre></div>
<p>应用 Kustomization 目录创建 ConfigMap 对象。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -k .
</code></pre></div><pre><code>configmap/special-config-2-c92b5mmcf2 created
</code></pre>
<h2 id=使用-configmap-数据定义容器环境变量>使用 ConfigMap 数据定义容器环境变量</h2>
<h3 id=使用单个-configmap-中的数据定义容器环境变量>使用单个 ConfigMap 中的数据定义容器环境变量</h3>
<ol>
<li>
<p>在 ConfigMap 中将环境变量定义为键值对:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create configmap special-config --from-literal<span style=color:#666>=</span>special.how<span style=color:#666>=</span>very
</code></pre></div></li>
</ol>
<ol start=2>
<li>
<p>将 ConfigMap 中定义的 <code>special.how</code> 赋值给 Pod 规约中的 <code>SPECIAL_LEVEL_KEY</code> 环境变量。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/pods/pod-single-configmap-env-variable.yaml download=pods/pod-single-configmap-env-variable.yaml><code>pods/pod-single-configmap-env-variable.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-pod-single-configmap-env-variable-yaml')" title="Copy pods/pod-single-configmap-env-variable.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-pod-single-configmap-env-variable-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>dapi-test-pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-container<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/busybox<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#bbb> </span><span style=color:#b44>&#34;/bin/sh&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;-c&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;env&#34;</span><span style=color:#bbb> </span>]<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># 定义环境变量</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>SPECIAL_LEVEL_KEY<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>configMapKeyRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:#080;font-style:italic># ConfigMap 包含你要赋给 SPECIAL_LEVEL_KEY 的值</span><span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>special-config<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:#080;font-style:italic># 指定与取值相关的键名</span><span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>special.how<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>创建 Pod:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create -f https://kubernetes.io/examples/pods/pod-single-configmap-env-variable.yaml
</code></pre></div>
<p>现在，Pod 的输出包含环境变量 <code>SPECIAL_LEVEL_KEY=very</code>。</p>
</li>
</ol>
<h3 id=使用来自多个-configmap-的数据定义容器环境变量>使用来自多个 ConfigMap 的数据定义容器环境变量</h3>
<ul>
<li>
<p>与前面的示例一样，首先创建 ConfigMap。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/configmap/configmaps.yaml download=configmap/configmaps.yaml><code>configmap/configmaps.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('configmap-configmaps-yaml')" title="Copy configmap/configmaps.yaml to clipboard">
</img>
</div>
<div class=includecode id=configmap-configmaps-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>special-config<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>special.how</span>:<span style=color:#bbb> </span>very<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>env-config<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>log_level</span>:<span style=color:#bbb> </span>INFO<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>创建 ConfigMap:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create -f https://kubernetes.io/examples/configmap/configmaps.yaml
</code></pre></div></li>
</ul>
<ul>
<li>
<p>在 Pod 规约中定义环境变量。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/pods/pod-multiple-configmap-env-variable.yaml download=pods/pod-multiple-configmap-env-variable.yaml><code>pods/pod-multiple-configmap-env-variable.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-pod-multiple-configmap-env-variable-yaml')" title="Copy pods/pod-multiple-configmap-env-variable.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-pod-multiple-configmap-env-variable-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>dapi-test-pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-container<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/busybox<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#bbb> </span><span style=color:#b44>&#34;/bin/sh&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;-c&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;env&#34;</span><span style=color:#bbb> </span>]<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>SPECIAL_LEVEL_KEY<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>configMapKeyRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>special-config<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>special.how<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>LOG_LEVEL<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>configMapKeyRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>env-config<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>log_level<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>创建 Pod:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create -f https://kubernetes.io/examples/pods/pod-multiple-configmap-env-variable.yaml
</code></pre></div>
<p>现在，Pod 的输出包含环境变量 <code>SPECIAL_LEVEL_KEY=very</code> 和 <code>LOG_LEVEL=INFO</code>。</p>
</li>
</ul>
<h2 id=将-configmap-中的所有键值对配置为容器环境变量>将 ConfigMap 中的所有键值对配置为容器环境变量</h2>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> Kubernetes v1.6 和更高版本支持此功能。
</div>
<ul>
<li>
<p>创建一个包含多个键值对的 ConfigMap。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/configmap/configmap-multikeys.yaml download=configmap/configmap-multikeys.yaml><code>configmap/configmap-multikeys.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('configmap-configmap-multikeys-yaml')" title="Copy configmap/configmap-multikeys.yaml to clipboard">
</img>
</div>
<div class=includecode id=configmap-configmap-multikeys-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>special-config<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>SPECIAL_LEVEL</span>:<span style=color:#bbb> </span>very<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>SPECIAL_TYPE</span>:<span style=color:#bbb> </span>charm<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>创建 ConfigMap:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create -f https://kubernetes.io/examples/configmap/configmap-multikeys.yaml
</code></pre></div></li>
</ul>
<ul>
<li>
<p>使用 <code>envFrom</code> 将所有 ConfigMap 的数据定义为容器环境变量，ConfigMap
中的键成为 Pod 中的环境变量名称。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/pods/pod-configmap-envFrom.yaml download=pods/pod-configmap-envFrom.yaml><code>pods/pod-configmap-envFrom.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-pod-configmap-envfrom-yaml')" title="Copy pods/pod-configmap-envFrom.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-pod-configmap-envfrom-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>dapi-test-pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-container<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/busybox<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#bbb> </span><span style=color:#b44>&#34;/bin/sh&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;-c&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;env&#34;</span><span style=color:#bbb> </span>]<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>envFrom</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>configMapRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>special-config<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>创建 Pod:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create -f https://kubernetes.io/examples/pods/pod-configmap-envFrom.yaml
</code></pre></div>
<p>现在，Pod 的输出包含环境变量 <code>SPECIAL_LEVEL=very</code> 和 <code>SPECIAL_TYPE=charm</code>。</p>
</li>
</ul>
<h2 id=在-pod-命令中使用-configmap-定义的环境变量>在 Pod 命令中使用 ConfigMap 定义的环境变量</h2>
<p>你可以使用 <code>$(VAR_NAME)</code> Kubernetes 替换语法在容器的 <code>command</code> 和 <code>args</code>
属性中使用 ConfigMap 定义的环境变量。</p>
<p>例如，以下 Pod 规约</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/pods/pod-configmap-env-var-valueFrom.yaml download=pods/pod-configmap-env-var-valueFrom.yaml><code>pods/pod-configmap-env-var-valueFrom.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-pod-configmap-env-var-valuefrom-yaml')" title="Copy pods/pod-configmap-env-var-valueFrom.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-pod-configmap-env-var-valuefrom-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>dapi-test-pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-container<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/busybox<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#bbb> </span><span style=color:#b44>&#34;/bin/echo&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;$(SPECIAL_LEVEL_KEY) $(SPECIAL_TYPE_KEY)&#34;</span><span style=color:#bbb> </span>]<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>SPECIAL_LEVEL_KEY<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>configMapKeyRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>special-config<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>SPECIAL_LEVEL<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>SPECIAL_TYPE_KEY<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>configMapKeyRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>special-config<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>SPECIAL_TYPE<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>通过运行下面命令创建 Pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create -f https://kubernetes.io/examples/pods/pod-configmap-env-var-valueFrom.yaml
</code></pre></div>
<p>在 <code>test-container</code> 容器中产生以下输出:</p>
<pre><code>very charm
</code></pre>
<h2 id=将-configmap-数据添加到一个卷中>将 ConfigMap 数据添加到一个卷中</h2>
<p>如基于文件创建 <a href=#create-configmaps-from-files>ConfigMap</a> 中所述，当你使用
<code>--from-file</code> 创建 ConfigMap 时，文件名成为存储在 ConfigMap 的 <code>data</code> 部分中的键，
文件内容成为键对应的值。</p>
<p>本节中的示例引用了一个名为 'special-config' 的 ConfigMap，如下所示：</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/configmap/configmap-multikeys.yaml download=configmap/configmap-multikeys.yaml><code>configmap/configmap-multikeys.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('configmap-configmap-multikeys-yaml')" title="Copy configmap/configmap-multikeys.yaml to clipboard">
</img>
</div>
<div class=includecode id=configmap-configmap-multikeys-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>special-config<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>SPECIAL_LEVEL</span>:<span style=color:#bbb> </span>very<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>SPECIAL_TYPE</span>:<span style=color:#bbb> </span>charm<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>创建 ConfigMap:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create -f https://kubernetes.io/examples/configmap/configmap-multikeys.yaml
</code></pre></div>
<h3 id=使用存储在-configmap-中的数据填充卷>使用存储在 ConfigMap 中的数据填充卷</h3>
<p>在 Pod 规约的 <code>volumes</code> 部分下添加 ConfigMap 名称。
这会将 ConfigMap 数据添加到 <code>volumeMounts.mountPath</code> 所指定的目录
（在本例中为 <code>/etc/config</code>）。
<code>command</code> 部分引用存储在 ConfigMap 中的 <code>special.level</code>。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/pods/pod-configmap-volume.yaml download=pods/pod-configmap-volume.yaml><code>pods/pod-configmap-volume.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-pod-configmap-volume-yaml')" title="Copy pods/pod-configmap-volume.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-pod-configmap-volume-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>dapi-test-pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-container<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/busybox<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#bbb> </span><span style=color:#b44>&#34;/bin/sh&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;-c&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;ls /etc/config/&#34;</span><span style=color:#bbb> </span>]<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>config-volume<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/etc/config<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>config-volume<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>configMap</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># 提供包含要添加到容器中的文件的 ConfigMap 的名称</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>special-config<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>创建 Pod:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create -f https://kubernetes.io/examples/pods/pod-configmap-volume.yaml
</code></pre></div>
<p>Pod 运行时，命令 <code>ls /etc/config/</code> 产生下面的输出：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>SPECIAL_LEVEL
SPECIAL_TYPE
</code></pre></div>
<div class="alert alert-warning caution callout" role=alert>
<strong>Caution:</strong> 如果在 <code>/etc/config/</code> 目录中有一些文件，这些文件将被删除。
</div>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 文本数据会展现为 UTF-8 字符编码的文件。如果使用其他字符编码，
可以使用 <code>binaryData</code>。
</div>
<h3 id=将-configmap-数据添加到卷中的特定路径>将 ConfigMap 数据添加到卷中的特定路径</h3>
<p>使用 <code>path</code> 字段为特定的 ConfigMap 项目指定预期的文件路径。
在这里，ConfigMap 中键 <code>SPECIAL_LEVEL</code> 的内容将挂载在 <code>config-volume</code>
卷中 <code>/etc/config/keys</code> 文件中。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/pods/pod-configmap-volume-specific-key.yaml download=pods/pod-configmap-volume-specific-key.yaml><code>pods/pod-configmap-volume-specific-key.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-pod-configmap-volume-specific-key-yaml')" title="Copy pods/pod-configmap-volume-specific-key.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-pod-configmap-volume-specific-key-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>dapi-test-pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-container<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/busybox<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#bbb> </span><span style=color:#b44>&#34;/bin/sh&#34;</span>,<span style=color:#b44>&#34;-c&#34;</span>,<span style=color:#b44>&#34;cat /etc/config/keys&#34;</span><span style=color:#bbb> </span>]<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>config-volume<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/etc/config<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>config-volume<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>configMap</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>special-config<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>items</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>SPECIAL_LEVEL<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>keys<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>创建Pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create -f https://kubernetes.io/examples/pods/pod-configmap-volume-specific-key.yaml
</code></pre></div>
<p>当 Pod 运行时，命令 <code>cat /etc/config/keys</code> 产生以下输出：</p>
<pre><code>very
</code></pre>
<div class="alert alert-warning caution callout" role=alert>
<strong>Caution:</strong> 如前，<code>/etc/config/</code> 目录中所有先前的文件都将被删除。
</div>
<h3 id=映射键到指定路径并设置文件访问权限>映射键到指定路径并设置文件访问权限</h3>
<p>你可以将指定键名投射到特定目录，也可以逐个文件地设定访问权限。
<a href=/zh/docs/concepts/configuration/secret/#using-secrets-as-files-from-a-pod>Secret 用户指南</a>
中为这一语法提供了解释。</p>
<h3 id=optional-references>可选的引用 </h3>
<p>ConfigMap 引用可以被标记为 “optional（可选的）”。如果所引用的 ConfigMap 不存在，
则所挂载的卷将会是空的。如果所引用的 ConfigMap 确实存在，但是所引用的主键不存在，
则在挂载点下对应的路径也会不存在。</p>
<h3 id=mounted-configmaps-are-updated-automatically>挂载的 ConfigMap 将自动更新 </h3>
<p>当某个已被挂载的 ConfigMap 被更新，所投射的内容最终也会被更新。
对于 Pod 已经启动之后所引用的、可选的 ConfigMap 才出现的情形，
这一动态更新现象也是适用的。</p>
<p><code>kubelet</code> 在每次周期性同步时都会检查已挂载的 ConfigMap 是否是最新的。
但是，它使用其本地的基于 TTL 的缓存来获取 ConfigMap 的当前值。
因此，从更新 ConfigMap 到将新键映射到 Pod 的总延迟可能与
kubelet 同步周期（默认 1 分钟） + ConfigMap 在 kubelet 中缓存的 TTL
（默认 1 分钟）一样长。
你可以通过更新 Pod 的某个注解来触发立即更新。</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 使用 ConfigMap 作为 <a href=/zh/docs/concepts/storage/volumes/#using-subpath>subPath</a>
的数据卷将不会收到 ConfigMap 更新。
</div>
<h2 id=了解-configmap-和-pod>了解 ConfigMap 和 Pod</h2>
<p>ConfigMap API 资源将配置数据存储为键值对。
数据可以在 Pod 中使用，也可以用来提供系统组件（如控制器）的配置。
ConfigMap 与 <a href=/zh/docs/concepts/configuration/secret/>Secret</a> 类似，
但是提供的是一种处理不含敏感信息的字符串的方法。
用户和系统组件都可以在 ConfigMap 中存储配置数据。</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> ConfigMap 应该引用属性文件，而不是替换它们。可以将 ConfigMap 理解为类似于 Linux
<code>/etc</code> 目录及其内容的东西。例如，如果你基于 ConfigMap 创建
<a href=/zh/docs/concepts/storage/volumes/>Kubernetes 卷</a>，则 ConfigMap
中的每个数据项都由该数据卷中的某个独立的文件表示。
</div>
<p>ConfigMap 的 <code>data</code> 字段包含配置数据。如下例所示，它可以简单
（如用 <code>--from-literal</code> 的单个属性定义）或复杂
（如用 <code>--from-file</code> 的配置文件或 JSON blob定义）。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>creationTimestamp</span>:<span style=color:#bbb> </span>2016-02-18T19:14:38Z<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>example-config<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 使用 --from-literal 定义的简单属性</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>example.property.1</span>:<span style=color:#bbb> </span>hello<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>example.property.2</span>:<span style=color:#bbb> </span>world<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 使用 --from-file 定义复杂属性的例子</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>example.property.file</span>:<span style=color:#bbb> </span>|-<span style=color:#b44;font-style:italic>
</span><span style=color:#b44;font-style:italic>    property.1=value-1
</span><span style=color:#b44;font-style:italic>    property.2=value-2
</span><span style=color:#b44;font-style:italic>    property.3=value-3</span><span style=color:#bbb>    
</span></code></pre></div>
<h3 id=restrictions>限制 </h3>
<ul>
<li>在 Pod 规约中引用某个 ConfigMap 之前，必须先创建它（除非将 ConfigMap 标记为
“optional（可选）”）。如果引用的 ConfigMap 不存在，则 Pod 将不会启动。
同样，引用 ConfigMap 中不存在的主键也会令 Pod 无法启动。</li>
</ul>
<ul>
<li>
<p>如果你使用 <code>envFrom</code> 来基于 ConfigMap 定义环境变量，那么无效的键将被忽略。
Pod 可以被启动，但无效名称将被记录在事件日志中（<code>InvalidVariableNames</code>）。
日志消息列出了每个被跳过的键。例如:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get events
</code></pre></div>
<p>输出与此类似:</p>
<pre><code>LASTSEEN FIRSTSEEN COUNT NAME          KIND  SUBOBJECT  TYPE      REASON                            SOURCE                MESSAGE
0s       0s        1     dapi-test-pod Pod              Warning   InvalidEnvironmentVariableNames   {kubelet, 127.0.0.1}  Keys [1badkey, 2alsobad] from the EnvFrom configMap default/myconfig were skipped since they are considered invalid environment variable names.
</code></pre></li>
</ul>
<ul>
<li>ConfigMap 位于确定的<a class=glossary-tooltip title="名字空间是 Kubernetes 用来支持隔离单个集群中的资源组的一种抽象。" data-toggle=tooltip data-placement=top href=/zh/docs/concepts/overview/working-with-objects/namespaces/ target=_blank aria-label=名字空间>名字空间</a>中。
每个 ConfigMap 只能被同一名字空间中的 Pod 引用.</li>
</ul>
<ul>
<li>你不能将 ConfigMap 用于<a class=glossary-tooltip title="静态Pod（Static Pod）是指由特定节点上的 kubelet 守护进程直接管理的 Pod。" data-toggle=tooltip data-placement=top href=/zh/docs/tasks/configure-pod-container/static-pod/ target=_blank aria-label="静态 Pod">静态 Pod</a>，
因为 Kubernetes 不支持这种用法。</li>
</ul>
<h2 id=what-s-next>What's next</h2>
<ul>
<li>浏览<a href=/zh/docs/tutorials/configuration/configure-redis-using-configmap/>使用 ConfigMap 配置 Redis</a>
真实实例。</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-3d7b9cb24a647c36ba63f7a02ec49010>5.20 - 在 Pod 中的容器之间共享进程命名空间</h1>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.17 [stable]</code>
</div>
<p>此页面展示如何为 pod 配置进程命名空间共享。
当启用进程命名空间共享时，容器中的进程对该 pod 中的所有其他容器都是可见的。</p>
<p>您可以使用此功能来配置协作容器，比如日志处理 sidecar 容器，或者对那些不包含诸如 shell 等调试实用工具的镜像进行故障排查。</p>
<h2 id=before-you-begin>Before you begin</h2>
<p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li>
</ul>
Your Kubernetes server must be at or later than version v1.10.
To check the version, enter <code>kubectl version</code>.
</p>
<h2 id=配置-pod>配置 Pod</h2>
<p>进程命名空间共享使用 <code>v1.PodSpec</code> 中的 <code>ShareProcessNamespace</code> 字段启用。例如：</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/pods/share-process-namespace.yaml download=pods/share-process-namespace.yaml><code>pods/share-process-namespace.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-share-process-namespace-yaml')" title="Copy pods/share-process-namespace.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-share-process-namespace-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>shareProcessNamespace</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>shell<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox:1.28<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>securityContext</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>capabilities</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>add</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- SYS_PTRACE<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>stdin</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>tty</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<ol>
<li>
<p>在集群中创建 <code>nginx</code> pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/pods/share-process-namespace.yaml
</code></pre></div></li>
<li>
<p>获取容器 <code>shell</code>，执行 <code>ps</code>：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl attach -it nginx -c shell
</code></pre></div><p>如果没有看到命令提示符，请按 enter 回车键。</p>
<pre><code>/ # ps ax
PID   USER     TIME  COMMAND
    1 root      0:00 /pause
    8 root      0:00 nginx: master process nginx -g daemon off;
   14 101       0:00 nginx: worker process
   15 root      0:00 sh
   21 root      0:00 ps ax
</code></pre></li>
</ol>
<p>您可以在其他容器中对进程发出信号。例如，发送 <code>SIGHUP</code> 到 nginx 以重启工作进程。这需要 <code>SYS_PTRACE</code> 功能。</p>
<pre><code>/ # kill -HUP 8
/ # ps ax
PID   USER     TIME  COMMAND
    1 root      0:00 /pause
    8 root      0:00 nginx: master process nginx -g daemon off;
   15 root      0:00 sh
   22 101       0:00 nginx: worker process
   23 root      0:00 ps ax
</code></pre>
<p>甚至可以使用 <code>/proc/$pid/root</code> 链接访问另一个容器镜像。</p>
<pre><code>/ # head /proc/8/root/etc/nginx/nginx.conf

user  nginx;
worker_processes  1;

error_log  /var/log/nginx/error.log warn;
pid        /var/run/nginx.pid;


events {
    worker_connections  1024;
</code></pre>
<h2 id=理解进程命名空间共享>理解进程命名空间共享</h2>
<p>Pod 共享许多资源，因此它们共享进程命名空间是很有意义的。
不过，有些容器镜像可能希望与其他容器隔离，因此了解这些差异很重要:</p>
<ol>
<li>
<p><strong>容器进程不再具有 PID 1。</strong> 在没有 PID 1 的情况下，一些容器镜像拒绝启动（例如，使用 <code>systemd</code> 的容器)，或者拒绝执行 <code>kill -HUP 1</code> 之类的命令来通知容器进程。在具有共享进程命名空间的 pod 中，<code>kill -HUP 1</code> 将通知 pod 沙箱（在上面的例子中是 <code>/pause</code>）。</p>
</li>
<li>
<p><strong>进程对 pod 中的其他容器可见。</strong> 这包括 <code>/proc</code> 中可见的所有信息，例如作为参数或环境变量传递的密码。这些仅受常规 Unix 权限的保护。</p>
</li>
<li>
<p><strong>容器文件系统通过 <code>/proc/$pid/root</code> 链接对 pod 中的其他容器可见。</strong> 这使调试更加容易，但也意味着文件系统安全性只受文件系统权限的保护。</p>
</li>
</ol>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-42a59b878d4c58e5c6f4bb87483dda93>5.21 - 创建静态 Pod</h1>
<p><em>静态 Pod</em> 在指定的节点上由 kubelet 守护进程直接管理，不需要
<a class=glossary-tooltip title="提供 Kubernetes API 服务的控制面组件。" data-toggle=tooltip data-placement=top href=/zh/docs/reference/command-line-tools-reference/kube-apiserver/ target=_blank aria-label="API 服务器">API 服务器</a> 监管。
与由控制面管理的 Pod（例如，<a class=glossary-tooltip title="Deployment 是管理应用副本的 API 对象。" data-toggle=tooltip data-placement=top href=/zh/docs/concepts/workloads/controllers/deployment/ target=_blank aria-label=Deployment>Deployment</a>）
不同；kubelet 监视每个静态 Pod（在它崩溃之后重新启动）。</p>
<p>静态 Pod 永远都会绑定到一个指定节点上的 <a class=glossary-tooltip title="一个在集群中每个节点上运行的代理。它保证容器都运行在 Pod 中。" data-toggle=tooltip data-placement=top href=/docs/reference/generated/kubelet target=_blank aria-label=Kubelet>Kubelet</a>。</p>
<p>kubelet 会尝试通过 Kubernetes API 服务器为每个静态 Pod 自动创建一个
<a class=glossary-tooltip title="API 服务器中的一个对象，用于跟踪 kubelet 上的静态 pod。" data-toggle=tooltip data-placement=top href="/zh/docs/reference/glossary/?all=true#term-mirror-pod" target=_blank aria-label="镜像 Pod">镜像 Pod</a>。
这意味着节点上运行的静态 Pod 对 API 服务来说是可见的，但是不能通过 API 服务器来控制。
Pod 名称将把以连字符开头的节点主机名作为后缀。</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 如果你在运行一个 Kubernetes 集群，并且在每个节点上都运行一个静态 Pod，
就可能需要考虑使用 <a class=glossary-tooltip title="确保 Pod 的副本在集群中的一组节点上运行。" data-toggle=tooltip data-placement=top href=/zh/docs/concepts/workloads/controllers/daemonset/ target=_blank aria-label=DaemonSet>DaemonSet</a> 替代这种方式。
</div>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 静态 Pod 的 <code>spec</code> 不能引用其他 API 对象
（如：<a class=glossary-tooltip title="为在 Pod 中运行的进程提供标识。" data-toggle=tooltip data-placement=top href=/zh/docs/tasks/configure-pod-container/configure-service-account/ target=_blank aria-label=ServiceAccount>ServiceAccount</a>、
<a class=glossary-tooltip title="ConfigMap 是一种 API 对象，用来将非机密性的数据保存到键值对中。使用时可以用作环境变量、命令行参数或者存储卷中的配置文件。" data-toggle=tooltip data-placement=top href=/zh/docs/tasks/configure-pod-container/configure-pod-configmap/ target=_blank aria-label=ConfigMap>ConfigMap</a>、
<a class=glossary-tooltip title="Secret 用于存储敏感信息，如密码、 OAuth 令牌和 SSH 密钥。" data-toggle=tooltip data-placement=top href=/zh/docs/concepts/configuration/secret/ target=_blank aria-label=Secret>Secret</a> 等）。
</div>
<h2 id=before-you-begin>Before you begin</h2>
<p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li>
</ul>
To check the version, enter <code>kubectl version</code>.
</p>
<p>本文假定你在使用 <a class=glossary-tooltip title="Docker 是一种可以提供操作系统级别虚拟化（也称作容器）的软件技术。" data-toggle=tooltip data-placement=top href=/zh/docs/reference/kubectl/docker-cli-to-kubectl/ target=_blank aria-label=Docker>Docker</a> 来运行 Pod，
并且你的节点是运行着 Fedora 操作系统。
其它发行版或者 Kubernetes 部署版本上操作方式可能不一样。</p>
<h2 id=static-pod-creation>创建静态 Pod</h2>
<p>可以通过<a href=/zh/docs/tasks/configure-pod-container/static-pod/#configuration-files>文件系统上的配置文件</a>
或者 <a href=/zh/docs/tasks/configure-pod-container/static-pod/#pods-created-via-http>web 网络上的配置文件</a>
来配置静态 Pod。</p>
<h3 id=configuration-files>文件系统上的静态 Pod 声明文件</h3>
<p>声明文件是标准的 Pod 定义文件，以 JSON 或者 YAML 格式存储在指定目录。路径设置在
<a href=/zh/docs/reference/config-api/kubelet-config.v1beta1/>Kubelet 配置文件</a>
的 <code>staticPodPath: &lt;目录></code> 字段，kubelet 会定期的扫描这个文件夹下的 YAML/JSON
文件来创建/删除静态 Pod。
注意 kubelet 扫描目录的时候会忽略以点开头的文件。</p>
<p>例如：下面是如何以静态 Pod 的方式启动一个简单 web 服务：</p>
<ol>
<li>
<p>选择一个要运行静态 Pod 的节点。在这个例子中选择 <code>my-node1</code>。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>ssh my-node1
</code></pre></div></li>
</ol>
<ol start=2>
<li>
<p>选择一个目录，比如在 <code>/etc/kubelet.d</code> 目录来保存 web 服务 Pod 的定义文件，
<code>/etc/kubelet.d/static-web.yaml</code>：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># 在 kubelet 运行的节点上执行以下命令</span>
mkdir /etc/kubelet.d/
cat <span style=color:#b44>&lt;&lt;EOF &gt;/etc/kubelet.d/static-web.yaml
</span><span style=color:#b44>apiVersion: v1
</span><span style=color:#b44>kind: Pod
</span><span style=color:#b44>metadata:
</span><span style=color:#b44>  name: static-web
</span><span style=color:#b44>  labels:
</span><span style=color:#b44>    role: myrole
</span><span style=color:#b44>spec:
</span><span style=color:#b44>  containers:
</span><span style=color:#b44>    - name: web
</span><span style=color:#b44>      image: nginx
</span><span style=color:#b44>      ports:
</span><span style=color:#b44>        - name: web
</span><span style=color:#b44>          containerPort: 80
</span><span style=color:#b44>          protocol: TCP
</span><span style=color:#b44>EOF</span>
</code></pre></div></li>
</ol>
<ol start=3>
<li>
<p>配置这个节点上的 kubelet，使用这个参数执行 <code>--pod-manifest-path=/etc/kubelet.d/</code>。
在 Fedora 上编辑 <code>/etc/kubernetes/kubelet</code> 以包含下行：</p>
<pre><code>KUBELET_ARGS=&quot;--cluster-dns=10.254.0.10 --cluster-domain=kube.local --pod-manifest-path=/etc/kubelet.d/&quot;
</code></pre><p>或者在 <a href=/zh/docs/reference/config-api/kubelet-config.v1beta1/>Kubelet 配置文件</a>
中添加 <code>staticPodPath: &lt;目录></code>字段。</p>
</li>
</ol>
<ol start=4>
<li>
<p>重启 kubelet。Fedora 上使用下面的命令：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># 在 kubelet 运行的节点上执行以下命令</span>
systemctl restart kubelet
</code></pre></div></li>
</ol>
<h3 id=pods-created-via-http>Web 网上的静态 Pod 声明文件</h3>
<p>Kubelet 根据 <code>--manifest-url=&lt;URL></code> 参数的配置定期的下载指定文件，并且转换成
JSON/YAML 格式的 Pod 定义文件。
与<a href=#configuration-files>文件系统上的清单文件</a>使用方式类似，kubelet 调度获取清单文件。
如果静态 Pod 的清单文件有改变，kubelet 会应用这些改变。</p>
<p>按照下面的方式来：</p>
<ol>
<li>
<p>创建一个 YAML 文件，并保存在 web 服务上，为 kubelet 生成一个 URL。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>static-web<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>role</span>:<span style=color:#bbb> </span>myrole<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>web<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>web<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span></code></pre></div></li>
</ol>
<ol start=2>
<li>
<p>通过在选择的节点上使用 <code>--manifest-url=&lt;manifest-url></code> 配置运行 kubelet。
在 Fedora 添加下面这行到 <code>/etc/kubernetes/kubelet</code> ：</p>
<pre><code>KUBELET_ARGS=&quot;--cluster-dns=10.254.0.10 --cluster-domain=kube.local --manifest-url=&lt;manifest-url&gt;&quot;
</code></pre></li>
</ol>
<ol start=3>
<li>
<p>重启 kubelet。在 Fedora 上运行如下命令：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># 在 kubelet 运行的节点上执行以下命令</span>
systemctl restart kubelet
</code></pre></div></li>
</ol>
<h2 id=behavior-of-static-pods>观察静态 pod 的行为</h2>
<p>当 kubelet 启动时，会自动启动所有定义的静态 Pod。
当定义了一个静态 Pod 并重新启动 kubelet 时，新的静态 Pod 就应该已经在运行了。</p>
<p>可以在节点上运行下面的命令来查看正在运行的容器（包括静态 Pod）：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># 在 kubelet 运行的节点上执行以下命令</span>
crictl ps
</code></pre></div>
<p>输出可能会像这样：</p>
<pre><code class=language-console data-lang=console>CONTAINER       IMAGE                                 CREATED           STATE      NAME    ATTEMPT    POD ID
129fd7d382018   docker.io/library/nginx@sha256:...    11 minutes ago    Running    web     0          34533c6729106
</code></pre>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> <code>crictl</code> 会输出镜像 URI 和 SHA-256 校验和。 <code>NAME</code> 看起来像：
<code>docker.io/library/nginx@sha256:0d17b565c37bcbd895e9d92315a05c1c3c9a29f762b011a10c54a66cd53c9b31</code>。
</div>
<p>可以在 API 服务上看到镜像 Pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods
</code></pre></div><pre><code>NAME         READY   STATUS    RESTARTS        AGE
static-web   1/1     Running   0               2m
</code></pre>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 要确保 kubelet 在 API 服务上有创建镜像 Pod 的权限。如果没有，创建请求会被 API 服务拒绝。
可以看 <a href=/zh/docs/concepts/security/pod-security-admission/>Pod 安全性准入</a>和 <a href=/zh/docs/concepts/security/pod-security-policy/>Pod 安全策略</a>。
</div>
<p>静态 Pod 上的<a class=glossary-tooltip title=用来为对象设置可标识的属性标记；这些标记对用户而言是有意义且重要的。 data-toggle=tooltip data-placement=top href=/zh/docs/concepts/overview/working-with-objects/labels/ target=_blank aria-label=标签>标签</a> 被传到镜像 Pod。
你可以通过 <a class=glossary-tooltip title=选择算符允许用户通过标签对一组资源对象进行筛选过滤。 data-toggle=tooltip data-placement=top href=/zh/docs/concepts/overview/working-with-objects/labels/ target=_blank aria-label=选择算符>选择算符</a> 使用这些标签。</p>
<p>如果你用 <code>kubectl</code> 从 API 服务上删除镜像 Pod，kubelet <em>不会</em> 移除静态 Pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete pod static-web
</code></pre></div><pre><code>pod &quot;static-web&quot; deleted
</code></pre>
<p>可以看到 Pod 还在运行：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods
</code></pre></div><pre><code>NAME         READY   STATUS    RESTARTS   AGE
static-web   1/1     Running   0          4s
</code></pre>
<p>回到 kubelet 运行的节点上，你可以手动停止容器。
可以看到过了一段时间后 kubelet 会发现容器停止了并且会自动重启 Pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># 在 kubelet 运行的节点上执行以下命令</span>
<span style=color:#080;font-style:italic># 把 ID 换为你的容器的 ID</span>
crictl stop 129fd7d382018
sleep <span style=color:#666>20</span>
crictl ps
</code></pre></div><pre><code class=language-console data-lang=console>CONTAINER       IMAGE                                 CREATED           STATE      NAME    ATTEMPT    POD ID
89db4553e1eeb   docker.io/library/nginx@sha256:...    19 seconds ago    Running    web     1          34533c6729106
</code></pre>
<h2 id=动态增加和删除静态-pod>动态增加和删除静态 pod</h2>
<p>运行中的 kubelet 会定期扫描配置的目录(比如例子中的 <code>/etc/kubelet.d</code> 目录)中的变化，
并且根据文件中出现/消失的 Pod 来添加/删除 Pod。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># 前提是你在用主机文件系统上的静态 Pod 配置文件</span>
<span style=color:#080;font-style:italic># 在 kubelet 运行的节点上执行以下命令</span>
mv /etc/kubelet.d/static-web.yaml /tmp
sleep <span style=color:#666>20</span>
crictl ps
<span style=color:#080;font-style:italic># 可以看到没有 nginx 容器在运行</span>
mv /tmp/static-web.yaml  /etc/kubelet.d/
sleep <span style=color:#666>20</span>
crictl ps
</code></pre></div><pre><code class=language-console data-lang=console>CONTAINER       IMAGE                                 CREATED           STATE      NAME    ATTEMPT    POD ID
f427638871c35   docker.io/library/nginx@sha256:...    19 seconds ago    Running    web     1          34533c6729106
</code></pre>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-1bb997c61a85de753d9994e7a312a291>5.22 - 将 Docker Compose 文件转换为 Kubernetes 资源</h1>
<p>Kompose 是什么？它是个转换工具，可将 compose（即 Docker Compose）所组装的所有内容
转换成容器编排器（Kubernetes 或 OpenShift）可识别的形式。</p>
<p>更多信息请参考 Kompose 官网 <a href=http://kompose.io>http://kompose.io</a>。</p>
<h2 id=before-you-begin>Before you begin</h2>
<p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li>
</ul>
To check the version, enter <code>kubectl version</code>.
</p>
<h2 id=安装-kompose>安装 Kompose</h2>
<p>我们有很多种方式安装 Kompose。首选方式是从最新的 GitHub 发布页面下载二进制文件。</p>
<ul class="nav nav-tabs" id=install-ways role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#install-ways-0 role=tab aria-controls=install-ways-0 aria-selected=true>GitHub 下载</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#install-ways-1 role=tab aria-controls=install-ways-1>基于源代码构建</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#install-ways-2 role=tab aria-controls=install-ways-2>CentOS 包</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#install-ways-3 role=tab aria-controls=install-ways-3>Fedora package</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#install-ways-4 role=tab aria-controls=install-ways-4>Homebrew (macOS)</a></li></ul>
<div class=tab-content id=install-ways><div id=install-ways-0 class="tab-pane show active" role=tabpanel aria-labelledby=install-ways-0>
<p>
<p>Kompose 通过 GitHub 发布，发布周期为三星期。
你可以在 <a href=https://github.com/kubernetes/kompose/releases>GitHub 发布页面</a>
上看到所有当前版本。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># Linux</span>
curl -L https://github.com/kubernetes/kompose/releases/download/v1.24.0/kompose-linux-amd64 -o kompose

<span style=color:#080;font-style:italic># macOS</span>
curl -L https://github.com/kubernetes/kompose/releases/download/v1.24.0/kompose-darwin-amd64 -o kompose

<span style=color:#080;font-style:italic># Windows</span>
curl -L https://github.com/kubernetes/kompose/releases/download/v1.24.0/kompose-windows-amd64.exe -o kompose.exe

chmod +x kompose
sudo mv ./kompose /usr/local/bin/kompose
</code></pre></div>
<p>或者，你可以下载 <a href=https://github.com/kubernetes/kompose/releases>tar 包</a>。</p>
</div>
<div id=install-ways-1 class=tab-pane role=tabpanel aria-labelledby=install-ways-1>
<p>
<p>用 <code>go get</code> 命令从主分支拉取最新的开发变更的方法安装 Kompose。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>go get -u github.com/kubernetes/kompose
</code></pre></div></div>
<div id=install-ways-2 class=tab-pane role=tabpanel aria-labelledby=install-ways-2>
<p>
<p>Kompose 位于 <a href=https://fedoraproject.org/wiki/EPEL>EPEL</a> CentOS 代码仓库。
如果你还没有安装启用 <a href=https://fedoraproject.org/wiki/EPEL>EPEL</a> 代码仓库，
请运行命令 <code>sudo yum install epel-release</code>。</p>
<p>如果你的系统中已经启用了 <a href=https://fedoraproject.org/wiki/EPEL>EPEL</a>，
你就可以像安装其他软件包一样安装 Kompose。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>sudo yum -y install kompose
</code></pre></div></div>
<div id=install-ways-3 class=tab-pane role=tabpanel aria-labelledby=install-ways-3>
<p>
<p>Kompose 位于 Fedora 24、25 和 26 的代码仓库。你可以像安装其他软件包一样安装 Kompose。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>sudo dnf -y install kompose
</code></pre></div></div>
<div id=install-ways-4 class=tab-pane role=tabpanel aria-labelledby=install-ways-4>
<p>
<p>在 macOS 上你可以通过 <a href=https://brew.sh>Homebrew</a> 安装 Kompose 的最新版本：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>brew install kompose
</code></pre></div></div></div>
<h2 id=使用-kompose>使用 Kompose</h2>
<p>再需几步，我们就把你从 Docker Compose 带到 Kubernetes。
你只需要一个现有的 <code>docker-compose.yml</code> 文件。</p>
<ol>
<li>
<p>进入 <code>docker-compose.yml</code> 文件所在的目录。如果没有，请使用下面这个进行测试。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>version</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>services</span>:<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>redis-master</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/redis:e2e<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:#b44>&#34;6379&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>redis-slave</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>gcr.io/google_samples/gb-redisslave:v3<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:#b44>&#34;6379&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>environment</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- GET_HOSTS_FROM=dns<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>frontend</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>gcr.io/google-samples/gb-frontend:v4<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:#b44>&#34;80:80&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>environment</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- GET_HOSTS_FROM=dns<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>kompose.service.type</span>:<span style=color:#bbb> </span>LoadBalancer<span style=color:#bbb>
</span></code></pre></div></li>
</ol>
<ol start=2>
<li>
<p>要将 <code>docker-compose.yml</code> 转换为 <code>kubectl</code> 可用的文件，请运行 <code>kompose convert</code>
命令进行转换，然后运行 <code>kubectl create -f &lt;output file></code> 进行创建。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kompose convert                           
</code></pre></div><pre><code class=language-none data-lang=none>INFO Kubernetes file &quot;frontend-service.yaml&quot; created
   INFO Kubernetes file &quot;frontend-service.yaml&quot; created
INFO Kubernetes file &quot;frontend-service.yaml&quot; created
INFO Kubernetes file &quot;redis-master-service.yaml&quot; created
   INFO Kubernetes file &quot;redis-master-service.yaml&quot; created
INFO Kubernetes file &quot;redis-master-service.yaml&quot; created
INFO Kubernetes file &quot;redis-slave-service.yaml&quot; created
   INFO Kubernetes file &quot;redis-slave-service.yaml&quot; created
INFO Kubernetes file &quot;redis-slave-service.yaml&quot; created
INFO Kubernetes file &quot;frontend-deployment.yaml&quot; created
   INFO Kubernetes file &quot;frontend-deployment.yaml&quot; created
INFO Kubernetes file &quot;frontend-deployment.yaml&quot; created
INFO Kubernetes file &quot;redis-master-deployment.yaml&quot; created
   INFO Kubernetes file &quot;redis-master-deployment.yaml&quot; created
INFO Kubernetes file &quot;redis-master-deployment.yaml&quot; created
INFO Kubernetes file &quot;redis-slave-deployment.yaml&quot; created
   INFO Kubernetes file &quot;redis-slave-deployment.yaml&quot; created
INFO Kubernetes file &quot;redis-slave-deployment.yaml&quot; created
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl apply -f frontend-service.yaml,redis-master-service.yaml,redis-slave-service.yaml,frontend-deployment.yaml,
</code></pre></div>
<p>输出类似于：</p>
<pre><code class=language-none data-lang=none>service/frontend created
service/redis-master created
service/redis-slave created
deployment.apps/frontend created
deployment.apps/redis-master created
deployment.apps/redis-slave created
</code></pre>
<p>你部署的应用在 Kubernetes 中运行起来了。</p>
</li>
</ol>
<ol start=3>
<li>
<p>访问你的应用</p>
<p>如果你在开发过程中使用 <code>minikube</code>，请执行：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>minikube service frontend
</code></pre></div>
<p>否则，我们要查看一下你的服务使用了什么 IP！</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe svc frontend
</code></pre></div><pre><code class=language-none data-lang=none>Name:                   frontend
Namespace:              default
Labels:                 service=frontend
Selector:               service=frontend
Type:                   LoadBalancer
IP:                     10.0.0.183
LoadBalancer Ingress:   192.0.2.89
Port:                   80      80/TCP
NodePort:               80      31144/TCP
Endpoints:              172.17.0.4:80
Session Affinity:       None
No events.
</code></pre>
<p>如果你使用的是云提供商，你的 IP 将在 <code>LoadBalancer Ingress</code> 字段给出。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>curl http://192.0.2.89
</code></pre></div></li>
</ol>
<h2 id=user-guide>用户指南 </h2>
<ul>
<li>
<p>CLI</p>
<ul>
<li><a href=#kompose-convert><code>kompose convert</code></a></li>
</ul>
</li>
<li>
<p>文档</p>
<ul>
<li><a href=#%E5%85%B6%E4%BB%96%E8%BD%AC%E6%8D%A2%E6%96%B9%E5%BC%8F>其他转换方式</a></li>
<li><a href=#labels>标签</a></li>
<li><a href=#restart>重启</a></li>
<li><a href=#docker-compose-versions>Docker Compose 版本</a></li>
</ul>
</li>
</ul>
<p>Kompose 支持两种驱动：OpenShift 和 Kubernetes。
你可以通过全局选项 <code>--provider</code> 选择驱动。如果没有指定，
会将 Kubernetes 作为默认驱动。</p>
<h2 id=kompose-convert><code>kompose convert</code></h2>
<p>Kompose 支持将 V1、V2 和 V3 版本的 Docker Compose 文件转换为 Kubernetes 和 OpenShift 资源对象。</p>
<h3 id=kubernetes-kompose-convert-示例>Kubernetes <code>kompose convert</code> 示例</h3>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kompose --file docker-voting.yml convert
</code></pre></div><pre><code class=language-none data-lang=none>WARN Unsupported key networks - ignoring
WARN Unsupported key build - ignoring
INFO Kubernetes file &quot;worker-svc.yaml&quot; created
INFO Kubernetes file &quot;db-svc.yaml&quot; created
INFO Kubernetes file &quot;redis-svc.yaml&quot; created
INFO Kubernetes file &quot;result-svc.yaml&quot; created
INFO Kubernetes file &quot;vote-svc.yaml&quot; created
INFO Kubernetes file &quot;redis-deployment.yaml&quot; created
INFO Kubernetes file &quot;result-deployment.yaml&quot; created
INFO Kubernetes file &quot;vote-deployment.yaml&quot; created
INFO Kubernetes file &quot;worker-deployment.yaml&quot; created
INFO Kubernetes file &quot;db-deployment.yaml&quot; created
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>ls
</code></pre></div><pre><code class=language-none data-lang=none>db-deployment.yaml  docker-compose.yml         docker-gitlab.yml  redis-deployment.yaml  result-deployment.yaml  vote-deployment.yaml  worker-deployment.yaml
db-svc.yaml         docker-voting.yml          redis-svc.yaml     result-svc.yaml        vote-svc.yaml           worker-svc.yaml
</code></pre>
<p>你也可以同时提供多个 docker-compose 文件进行转换：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kompose -f docker-compose.yml -f docker-guestbook.yml convert
</code></pre></div><pre><code class=language-none data-lang=none>INFO Kubernetes file &quot;frontend-service.yaml&quot; created         
INFO Kubernetes file &quot;mlbparks-service.yaml&quot; created         
INFO Kubernetes file &quot;mongodb-service.yaml&quot; created          
INFO Kubernetes file &quot;redis-master-service.yaml&quot; created     
INFO Kubernetes file &quot;redis-slave-service.yaml&quot; created      
INFO Kubernetes file &quot;frontend-deployment.yaml&quot; created      
INFO Kubernetes file &quot;mlbparks-deployment.yaml&quot; created      
INFO Kubernetes file &quot;mongodb-deployment.yaml&quot; created       
INFO Kubernetes file &quot;mongodb-claim0-persistentvolumeclaim.yaml&quot; created
INFO Kubernetes file &quot;redis-master-deployment.yaml&quot; created  
INFO Kubernetes file &quot;redis-slave-deployment.yaml&quot; created   
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>ls
</code></pre></div><pre><code>mlbparks-deployment.yaml  mongodb-service.yaml                       redis-slave-service.jsonmlbparks-service.yaml  
frontend-deployment.yaml  mongodb-claim0-persistentvolumeclaim.yaml  redis-master-service.yaml
frontend-service.yaml     mongodb-deployment.yaml                    redis-slave-deployment.yaml
redis-master-deployment.yaml
</code></pre>
<p>当提供多个 docker-compose 文件时，配置将会合并。任何通用的配置都将被后续文件覆盖。</p>
<h3 id=openshift-kompose-convert-示例>OpenShift <code>kompose convert</code> 示例</h3>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kompose --provider openshift --file docker-voting.yml convert
</code></pre></div><pre><code>WARN [worker] Service cannot be created because of missing port.
INFO OpenShift file &quot;vote-service.yaml&quot; created             
INFO OpenShift file &quot;db-service.yaml&quot; created               
INFO OpenShift file &quot;redis-service.yaml&quot; created            
INFO OpenShift file &quot;result-service.yaml&quot; created           
INFO OpenShift file &quot;vote-deploymentconfig.yaml&quot; created    
INFO OpenShift file &quot;vote-imagestream.yaml&quot; created         
INFO OpenShift file &quot;worker-deploymentconfig.yaml&quot; created  
INFO OpenShift file &quot;worker-imagestream.yaml&quot; created       
INFO OpenShift file &quot;db-deploymentconfig.yaml&quot; created      
INFO OpenShift file &quot;db-imagestream.yaml&quot; created           
INFO OpenShift file &quot;redis-deploymentconfig.yaml&quot; created   
INFO OpenShift file &quot;redis-imagestream.yaml&quot; created        
INFO OpenShift file &quot;result-deploymentconfig.yaml&quot; created  
INFO OpenShift file &quot;result-imagestream.yaml&quot; created  
</code></pre>
<p>kompose 还支持为服务中的构建指令创建 buildconfig。
默认情况下，它使用当前 git 分支的 remote 仓库作为源仓库，使用当前分支作为构建的源分支。
你可以分别使用 <code>--build-repo</code> 和 <code>--build-branch</code> 选项指定不同的源仓库和分支。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kompose --provider openshift --file buildconfig/docker-compose.yml convert
</code></pre></div><pre><code class=language-none data-lang=none>WARN [foo] Service cannot be created because of missing port.
INFO OpenShift Buildconfig using git@github.com:rtnpro/kompose.git::master as source.
INFO OpenShift file &quot;foo-deploymentconfig.yaml&quot; created     
INFO OpenShift file &quot;foo-imagestream.yaml&quot; created          
INFO OpenShift file &quot;foo-buildconfig.yaml&quot; created
</code></pre>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 如果使用 <code>oc create -f</code> 手动推送 Openshift 工件，则需要确保在构建配置工件之前推送
imagestream 工件，以解决 Openshift 的这个问题：https://github.com/openshift/origin/issues/4518 。
</div>
<h2 id=alternative-conversions>其他转换方式 </h2>
<p>默认的 <code>kompose</code> 转换会生成 yaml 格式的 Kubernetes
<a href=/zh/docs/concepts/workloads/controllers/deployment/>Deployment</a> 和
<a href=/zh/docs/concepts/services-networking/service/>Service</a> 对象。
你可以选择通过 <code>-j</code> 参数生成 json 格式的对象。
你也可以替换生成 <a href=/zh/docs/concepts/workloads/controllers/replicationcontroller/>Replication Controllers</a> 对象、
<a href=/zh/docs/concepts/workloads/controllers/daemonset/>Daemon Sets</a> 或
<a href=https://github.com/helm/helm>Helm</a> charts。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kompose convert -j
</code></pre></div><pre><code class=language-none data-lang=none>INFO Kubernetes file &quot;redis-svc.json&quot; created
INFO Kubernetes file &quot;web-svc.json&quot; created
INFO Kubernetes file &quot;redis-deployment.json&quot; created
INFO Kubernetes file &quot;web-deployment.json&quot; created
</code></pre>
<p><code>*-deployment.json</code> 文件中包含 Deployment 对象。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kompose convert --replication-controller
</code></pre></div><pre><code class=language-none data-lang=none>INFO Kubernetes file &quot;redis-svc.yaml&quot; created
INFO Kubernetes file &quot;web-svc.yaml&quot; created
INFO Kubernetes file &quot;redis-replicationcontroller.yaml&quot; created
INFO Kubernetes file &quot;web-replicationcontroller.yaml&quot; created
</code></pre>
<p><code>*-replicationcontroller.yaml</code> 文件包含 Replication Controller 对象。
如果你想指定副本数（默认为 1），可以使用 <code>--replicas</code> 参数：
<code>kompose convert --replication-controller --replicas 3</code></p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kompose convert --daemon-set
</code></pre></div><pre><code class=language-none data-lang=none>INFO Kubernetes file &quot;redis-svc.yaml&quot; created
INFO Kubernetes file &quot;web-svc.yaml&quot; created
INFO Kubernetes file &quot;redis-daemonset.yaml&quot; created
INFO Kubernetes file &quot;web-daemonset.yaml&quot; created
</code></pre>
<p><code>*-daemonset.yaml</code> 文件包含 DaemonSet 对象。</p>
<p>如果你想生成 <a href=https://github.com/kubernetes/helm>Helm</a> 可用的 Chart，
只需简单的执行下面的命令：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kompose convert -c
</code></pre></div><pre><code class=language-none data-lang=none>INFO Kubernetes file &quot;web-svc.yaml&quot; created
INFO Kubernetes file &quot;redis-svc.yaml&quot; created
INFO Kubernetes file &quot;web-deployment.yaml&quot; created
INFO Kubernetes file &quot;redis-deployment.yaml&quot; created
chart created in &quot;./docker-compose/&quot;
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>tree docker-compose/
</code></pre></div><pre><code>docker-compose
├── Chart.yaml
├── README.md
└── templates
    ├── redis-deployment.yaml
    ├── redis-svc.yaml
    ├── web-deployment.yaml
    └── web-svc.yaml
</code></pre>
<p>这个 Chart 结构旨在为构建 Helm Chart 提供框架。</p>
<h2 id=labels>标签 </h2>
<p><code>kompose</code> 支持 <code>docker-compose.yml</code> 文件中用于 Kompose 的标签，以便
在转换时明确定义 Service 的行为。</p>
<ul>
<li>
<p><code>kompose.service.type</code> 定义要创建的 Service 类型。例如：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>version</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>services</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>nginx</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>dockerfile</span>:<span style=color:#bbb> </span>foobar<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>build</span>:<span style=color:#bbb> </span>./foobar<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>cap_add</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- ALL<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>container_name</span>:<span style=color:#bbb> </span>foobar<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>kompose.service.type</span>:<span style=color:#bbb> </span>nodeport<span style=color:#bbb>
</span></code></pre></div></li>
</ul>
<ul>
<li>
<p><code>kompose.service.expose</code> 定义是否允许从集群外部访问 Service。
如果该值被设置为 "true"，提供程序将自动设置端点，
对于任何其他值，该值将被设置为主机名。
如果在 Service 中定义了多个端口，则选择第一个端口作为公开端口。</p>
<ul>
<li>如果使用 Kubernetes 驱动，会有一个 Ingress 资源被创建，并且假定
已经配置了相应的 Ingress 控制器。</li>
<li>如果使用 OpenShift 驱动, 则会有一个 route 被创建。</li>
</ul>
<p>例如：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>version</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>services</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>web</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>tuna/docker-counter23<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>     </span>- <span style=color:#b44>&#34;5000:5000&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>links</span>:<span style=color:#bbb>
</span><span style=color:#bbb>     </span>- redis<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>kompose.service.expose</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;counter.example.com&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>redis</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>redis:3.0<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>     </span>- <span style=color:#b44>&#34;6379&#34;</span><span style=color:#bbb>
</span></code></pre></div></li>
</ul>
<p>当前支持的选项有:</p>
<table>
<thead>
<tr>
<th>键</th>
<th>值</th>
</tr>
</thead>
<tbody>
<tr>
<td>kompose.service.type</td>
<td>nodeport / clusterip / loadbalancer</td>
</tr>
<tr>
<td>kompose.service.expose</td>
<td>true / hostname</td>
</tr>
</tbody>
</table>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong>
<p><code>kompose.service.type</code> 标签应该只用 <code>ports</code> 来定义，否则 <code>kompose</code> 会失败。
</div>
<h2 id=restart>重启 </h2>
<p>如果你想创建没有控制器的普通 Pod，可以使用 docker-compose 的 <code>restart</code>
结构来指定这一行为。请参考下表了解 <code>restart</code> 的不同参数。</p>
<table>
<thead>
<tr>
<th><code>docker-compose</code> <code>restart</code></th>
<th>创建的对象</th>
<th>Pod <code>restartPolicy</code></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>""</code></td>
<td>控制器对象</td>
<td><code>Always</code></td>
</tr>
<tr>
<td><code>always</code></td>
<td>控制器对象</td>
<td><code>Always</code></td>
</tr>
<tr>
<td><code>on-failure</code></td>
<td>Pod</td>
<td><code>OnFailure</code></td>
</tr>
<tr>
<td><code>no</code></td>
<td>Pod</td>
<td><code>Never</code></td>
</tr>
</tbody>
</table>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 控制器对象可以是 <code>deployment</code> 或 <code>replicationcontroller</code> 等。
</div>
<p>例如，<code>pival</code> Service 将在这里变成 Pod。这个容器计算 <code>pi</code> 的取值。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>version</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;2&#39;</span><span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>services</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>pival</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>perl<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;perl&#34;</span>,<span style=color:#bbb>  </span><span style=color:#b44>&#34;-Mbignum=bpi&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;-wle&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;print bpi(2000)&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>restart</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;on-failure&#34;</span><span style=color:#bbb>
</span></code></pre></div>
<h3 id=关于-deployment-config-的提醒>关于 Deployment Config 的提醒</h3>
<p>如果 Docker Compose 文件中为服务声明了卷，Deployment (Kubernetes) 或
DeploymentConfig (OpenShift) 策略会从 "RollingUpdate" (默认) 变为 "Recreate"。
这样做的目的是为了避免服务的多个实例同时访问卷。</p>
<p>如果 Docker Compose 文件中的服务名包含 <code>_</code>（例如 <code>web_service</code>），
那么将会被替换为 <code>-</code>，服务也相应的会重命名（例如 <code>web-service</code>）。
Kompose 这样做的原因是 "Kubernetes" 不允许对象名称中包含 <code>_</code>。</p>
<p>请注意，更改服务名称可能会破坏一些 <code>docker-compose</code> 文件。</p>
<h2 id=docker-compose-versions>Docker Compose 版本 </h2>
<p>Kompose 支持的 Docker Compose 版本包括：1、2 和 3。
对 2.1 和 3.2 版本的支持还有限，因为它们还在实验阶段。</p>
<p>所有三个版本的兼容性列表请查看我们的
<a href=https://github.com/kubernetes/kompose/blob/master/docs/conversion.md>转换文档</a>，
文档中列出了所有不兼容的 Docker Compose 关键字。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-0a91fdc1445a8c7f3563c41a9b9b3370>5.23 - 从 PodSecurityPolicy 迁移到内置的 PodSecurity 准入控制器</h1>
<p>本页面描述从 PodSecurityPolicy 迁移到内置的 PodSecurity 准入控制器的过程。
这一迁移过程可以通过综合使用试运行、<code>audit</code> 和 <code>warn</code> 模式等来实现，
尽管在使用了变更式 PSP 时会变得有些困难。</p>
<h2 id=before-you-begin>Before you begin</h2>
<p>Your Kubernetes server must be at or later than version v1.22.
To check the version, enter <code>kubectl version</code>.</p>
<ul>
<li>确保 <code>PodSecurity</code> <a href=/docs/reference/command-line-tools-reference/feature-gates/>特性门控</a>被启用。</li>
</ul>
<p>本页面假定你已经熟悉 <a href=/zh/docs/concepts/security/pod-security-admission/>Pod 安全性准入</a>的基本概念。</p>
<h2 id=overall-approach>方法概览 </h2>
<p>你可以采取多种策略来完成从 PodSecurityPolicy 到 Pod 安全性准入
（Pod Security Admission）的迁移。
下面是一种可能的迁移路径，其目标是尽可能降低生产环境不可用的风险，
以及安全性仍然不足的风险。</p>
<ol start=0>
<li>确定 Pod 安全性准入是否对于你的使用场景而言比较合适。</li>
<li>审查名字空间访问权限。</li>
<li>简化、标准化 PodSecurityPolicy。</li>
<li>更新名字空间：
<ol>
<li>确定合适的 Pod 安全性级别；</li>
<li>验证该 Pod 安全性级别可工作；</li>
<li>实施该 Pod 安全性级别；</li>
<li>绕过 PodSecurityPolicy。</li>
</ol>
</li>
<li>审阅名字空间创建过程。</li>
<li>禁用 PodSecurityPolicy。</li>
</ol>
<h2 id=is-psa-right-for-you>0. 确定是否 Pod 安全性准入适合你 </h2>
<p>Pod 安全性准入被设计用来直接满足最常见的安全性需求，并提供一组可用于多个集群的安全性级别。
不过，这一机制比 PodSecurityPolicy 的灵活度要低。
值得注意的是，PodSecurityPolicy 所支持的以下特性是 Pod 安全性准入所不支持的：</p>
<ul>
<li><strong>设置默认的安全性约束</strong> - Pod 安全性准入是一个非变更性质的准入控制器，
这就意味着它不会在对 Pod 进行合法性检查之前更改其配置。如果你之前依赖于 PSP 的这方面能力，
你或者需要更改你的负载以满足 Pod 安全性约束，或者需要使用一个
<a href=/zh/docs/reference/access-authn-authz/extensible-admission-controllers/>变更性质的准入 Webhook</a>
来执行相应的变更。进一步的细节可参见后文的<a href=#simplify-psps>简化和标准化 PodSecurityPolicy</a>。</li>
</ul>
<ul>
<li><strong>对策略定义的细粒度控制</strong> - Pod 安全性准入仅支持
<a href=/zh/docs/concepts/security/pod-security-standards/>三种标准级别</a>。
如果你需要对特定的约束施加更多的控制，你就需要使用一个
<a href=/zh/docs/reference/access-authn-authz/extensible-admission-controllers/>验证性质的准入 Webhook</a>
以实施这列策略。</li>
</ul>
<ul>
<li><strong>粒度小于名字空间的策略</strong> - PodSecurityPolicy 允许你为不同的服务账户或用户绑定不同策略，
即使这些服务账户或用户隶属于同一个名字空间。这一方法有很多缺陷，不建议使用。
不过如果你的确需要这种功能，你就需要使用第三方的 Webhook。
唯一的例外是当你只需要完全针对某用户或者
<a href=/zh/docs/concepts/containers/runtime-class/>RuntimeClasses</a> 赋予豁免规则时，
Pod 安全性准入的确也为豁免规则暴露一些
<a href=/zh/docs/concepts/security/pod-security-admission/#exemptions>静态配置</a>。</li>
</ul>
<p>即便 Pod 安全性准入无法满足你的所有需求，该机制也是设计用作其他策略实施机制的
<em>补充</em>，因此可以和其他准入 Webhook 一起运行，进而提供一种有用的兜底机制。</p>
<h2 id=review-namespace-permissions>1. 审查名字空间访问权限 </h2>
<p>Pod 安全性准入是通过<a href=/zh/docs/concepts/security/pod-security-admission/#pod-security-admission-labels-for-namespaces>名字空间上的标签</a>
来控制的。这也就是说，任何能够更新（或通过 patch 部分更新或创建）
名字空间的人都可以更改该名字空间的 Pod 安全性级别，而这可能会被利用来绕过约束性更强的策略。
在继续执行迁移操作之前，请确保只有被信任的、有特权的用户具有这类名字空间访问权限。
不建议将这类强大的访问权限授予不应获得权限提升的用户，不过如果你必须这样做，
你需要使用一个
<a href=/zh/docs/reference/access-authn-authz/extensible-admission-controllers/>准入 Webhook</a>
来针对为 Namespace 对象设置 Pod 安全性级别设置额外的约束。</p>
<h2 id=simplify-psps>2. 简化、标准化 PodSecurityPolicy </h2>
<p>在本节中，你会削减变更性质的 PodSecurityPolicy，去掉 Pod 安全性标准范畴之外的选项。
针对要修改的、已存在的 PodSecurityPolicy，你应该将这里所建议的更改写入到其离线副本中。
所克隆的 PSP 应该与原来的副本名字不同，并且按字母序要排到原副本之前
（例如，可以向 PSP 名字前加一个 <code>0</code>）。
先不要在 Kubernetes 中创建新的策略 - 这类操作会在后文的<a href=#psp-update-rollout>推出更新的策略</a>
部分讨论。</p>
<h3 id=eliminating-mutaging-fields>2.a. 去掉纯粹变更性质的字段 </h3>
<p>如果某个 PodSecurityPolicy 能够变更字段，你可能会在关掉 PodSecurityPolicy
时发现有些 Pod 无法满足 Pod 安全性级别。为避免这类状况，
你应该在执行切换操作之前去掉所有 PSP 的变更操作。
不幸的是，PSP 没有对变更性和验证性字段做清晰的区分，所以这一迁移操作也不够简单直接。</p>
<p>你可以先去掉那些纯粹变更性质的字段，留下验证策略中的其他内容。
这些字段（也列举于<a href=/zh/docs/reference/access-authn-authz/psp-to-pod-security-standards/>将 PodSecurityPolicy 映射到 Pod 安全性标准</a>参考中）
包括：</p>
<ul>
<li><code>.spec.defaultAllowPrivilegeEscalation</code></li>
<li><code>.spec.runtimeClass.defaultRuntimeClassName</code></li>
<li><code>.metadata.annotations['seccomp.security.alpha.kubernetes.io/defaultProfileName']</code></li>
<li><code>.metadata.annotations['apparmor.security.beta.kubernetes.io/defaultProfileName']</code></li>
<li><code>.spec.defaultAddCapabilities</code> - 尽管理论上是一个混合了变更性与验证性功能的字段，
这里的设置应该被合并到 <code>.spec.allowedCapabilities</code> 中，后者会执行相同的验证操作，
但不会执行任何变更动作。</li>
</ul>
<div class="alert alert-warning caution callout" role=alert>
<strong>Caution:</strong>
<p>删除这些字段可能导致负载缺少所需的配置信息，进而导致一些问题。
参见后文<a href=#psp-update-rollout>退出更新的策略</a>以获得如何安全地将这些变更上线的建议。
</div>
<h3 id=eliminate-non-standard-options>2.b. 去掉 Pod 安全性标准未涉及的选项</h3>
<p>PodSecurityPolicy 中有一些字段未被 Pod 安全性准入机制覆盖。如果你必须使用这些选项，
你需要在 Pod 安全性准入之外部署
<a href=/zh/docs/reference/access-authn-authz/extensible-admission-controllers/>准入 Webhook</a>
以补充这一能力，而这类操作不在本指南范围。</p>
<p>首先，你可以去掉 Pod 安全性标准所未覆盖的那些验证性字段。这些字段（也列举于
<a href=/zh/docs/reference/access-authn-authz/psp-to-pod-security-standards/>将 PodSecurityPolicy 映射到 Pod 安全性标准</a>参考中，标记为“无意见”）有：</p>
<ul>
<li><code>.spec.allowedHostPaths</code></li>
<li><code>.spec.allowedFlexVolumes</code></li>
<li><code>.spec.allowedCSIDrivers</code></li>
<li><code>.spec.forbiddenSysctls</code></li>
<li><code>.spec.runtimeClass</code></li>
</ul>
<p>你也可以去掉以下字段，这些字段与 POSIX/UNIX 用户组控制有关。</p>
<div class="alert alert-warning caution callout" role=alert>
<strong>Caution:</strong>
<p>如果这些字段中存在使用 <code>MustRunAs</code> 策略的情况，则意味着对应字段是变更性质的。
去掉相应的字段可能导致负载无法设置所需的用户组，进而带来一些问题。
关于如何安全地将这类变更上线的相关建议，请参阅后文的<a href=#psp-update-rollout>推出更新的策略</a>部分。
</div>
<ul>
<li><code>.spec.runAsGroup</code></li>
<li><code>.spec.supplementalGroups</code></li>
<li><code>.spec.fsGroup</code></li>
</ul>
<p>剩下的变更性字段是为了适当支持 Pod 安全性标准所需要的，因而需要逐个处理：</p>
<ul>
<li><code>.spec.requiredDropCapabilities</code> - 需要此字段来为 Restricted 配置去掉 <code>ALL</code> 设置。</li>
<li><code>.spec.seLinux</code> - （仅针对带有 <code>MustRunAs</code> 规则的变更性设置）需要此字段来满足
Baseline 和 Restricted 配置所需要的 SELinux 需求。</li>
<li><code>.spec.runAsUser</code> - （仅针对带有 <code>RunAsAny</code> 规则的非变更性设置）需要此字段来为
Restricted 配置保证 <code>RunAsNonRoot</code>。</li>
<li><code>.spec.allowPrivilegeEscalation</code> - （如果设置为 <code>false</code> 则为变更性设置）
需要此字段来支持 Restricted 配置。</li>
</ul>
<h3 id=psp-update-rollout>2.c. 推出更新的 PSP </h3>
<p>接下来，你可以将更新后的策略推出到你的集群上。在继续操作时，你要非常小心，
因为去掉变更性质的选项可能导致有些工作负载缺少必需的配置。</p>
<p>针对更新后的每个 PodSecurityPolicy：</p>
<ol>
<li>
<p>识别运行于原 PSP 之下的 Pod。可以通过 <code>kubernetes.io/psp</code> 注解来完成。
例如，使用 kubectl：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#b8860b>PSP_NAME</span><span style=color:#666>=</span><span style=color:#b44>&#34;original&#34;</span> <span style=color:#080;font-style:italic># 设置你要检查的 PSP 的名称</span>
kubectl get pods --all-namespaces -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#34;{range .items[?(@.metadata.annotations.kubernetes\.io\/psp==&#39;</span><span style=color:#b8860b>$PSP_NAME</span><span style=color:#b44>&#39;)]}{.metadata.namespace} {.metadata.name}{&#39;\n&#39;}{end}&#34;</span>
</code></pre></div></li>
</ol>
<ol start=2>
<li>
<p>比较运行中的 Pod 与原来的 Pod 规约，确定 PodSecurityPolicy 是否更改过这些 Pod。
对于通过<a href=/zh/docs/concepts/workloads/controllers/>工作负载资源</a>所创建的 Pod，
你可以比较 Pod 和控制器资源中的 PodTemplate。如果发现任何变更，则原来的 Pod
或者 PodTemplate 需要被更新以加上所希望的配置。要审查的字段包括：</p>
<ul>
<li><code>.metadata.annotations['container.apparmor.security.beta.kubernetes.io/*']</code>
（将 <code>*</code> 替换为每个容器的名称）</li>
<li><code>.spec.runtimeClassName</code></li>
<li><code>.spec.securityContext.fsGroup</code></li>
<li><code>.spec.securityContext.seccompProfile</code></li>
<li><code>.spec.securityContext.seLinuxOptions</code></li>
<li><code>.spec.securityContext.supplementalGroups</code></li>
</ul>
<ul>
<li>对于容器，在 <code>.spec.containers[*]</code> 和 <code>.spec.initContainers[*]</code> 之下，检查下面字段：
<ul>
<li><code>.securityContext.allowPrivilegeEscalation</code></li>
<li><code>.securityContext.capabilities.add</code></li>
<li><code>.securityContext.capabilities.drop</code></li>
<li><code>.securityContext.readOnlyRootFilesystem</code></li>
<li><code>.securityContext.runAsGroup</code></li>
<li><code>.securityContext.runAsNonRoot</code></li>
<li><code>.securityContext.runAsUser</code></li>
<li><code>.securityContext.seccompProfile</code></li>
<li><code>.securityContext.seLinuxOptions</code></li>
</ul>
</li>
</ul>
</li>
</ol>
<ol start=3>
<li>创建新的 PodSecurityPolicy。如果存在 Role 或 ClusterRole 对象为用户授权了在所有 PSP
上使用 <code>use</code> 动词的权限，则所使用的的会是新创建的 PSP 而不是其变更性的副本。</li>
<li>更新你的鉴权配置，为访问新的 PSP 授权。在 RBAC 机制下，这意味着需要更新所有为原 PSP
授予 <code>use</code> 访问权限的 Role 或 ClusterRole 对象，使之也对更新后的 PSP 授权。</li>
</ol>
<ol start=5>
<li>验证：经过一段时间后，重新执行步骤 1 中所给的命令，查看是否有 Pod 仍在使用原来的 PSP。
注意，在新的策略被推出到集群之后，Pod 需要被重新创建才可以执行全面验证。</li>
<li>（可选）一旦你已经验证原来的 PSP 不再被使用，你就可以删除这些 PSP。</li>
</ol>
<h2 id=update-namespace>3. 更新名字空间 </h2>
<p>下面的步骤需要在集群中的所有名字空间上执行。所列步骤中的命令使用变量
<code>$NAMESPACE</code> 来引用所更新的名字空间。</p>
<h3 id=identify-appropriate-level>3.a. 识别合适的 Pod 安全级别 </h3>
<p>首先请回顾 <a href=/zh/docs/concepts/security/pod-security-standards/>Pod 安全性标准</a>内容，
并了解三个安全级别。</p>
<p>为你的名字空间选择 Pod 安全性级别有几种方法：</p>
<ol>
<li><strong>根据名字空间的安全性需求来确定</strong> - 如果你熟悉某名字空间的预期访问级别，
你可以根据这类需求来选择合适的安全级别，就像大家在为新集群确定安全级别一样。</li>
</ol>
<ol start=2>
<li>
<p><strong>根据现有的 PodSecurityPolicy 来确定</strong> - 基于
<a href=/zh/docs/reference/access-authn-authz/psp-to-pod-security-standards/>将 PodSecurityPolicy 映射到 Pod 安全性标准</a>
参考资料，你可以将各个 PSP 映射到某个 Pod 安全性标准级别。如果你的 PSP 不是基于
Pod 安全性标准的，你可能或者需要选择一个至少与该 PSP 一样宽松的级别，
或者选择一个至少与其一样严格的级别。使用下面的命令你可以查看被 Pod 使用的 PSP 有哪些：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>kubectl get pods -n <span style=color:#b8860b>$NAMESPACE</span> -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#34;{.items[*].metadata.annotations.kubernetes\.io\/psp}&#34;</span> | tr <span style=color:#b44>&#34; &#34;</span> <span style=color:#b44>&#34;\n&#34;</span> | sort -u
</code></pre></div></li>
</ol>
<ol start=3>
<li><strong>根据现有 Pod 来确定</strong> - 使用<a href=#verify-pss-level>检查 Pod 安全性级别</a>小节所述策略，
你可以测试 Baseline 和 Restricted 级别，检查它们是否对于现有负载而言足够宽松，
并选择二者之间特权级较低的合法级别。</li>
</ol>
<div class="alert alert-warning caution callout" role=alert>
<strong>Caution:</strong>
<p>上面的第二和第三种方案是基于 <em>现有</em> Pod 的，因此可能错失那些当前未处于运行状态的
Pod，例如 CronJobs、缩容到零的负载，或者其他尚未全面铺开的负载。
</div>
<h3 id=verify-pss-level>3.b. 检查 Pod 安全性级别 </h3>
<p>一旦你已经为名字空间选择了 Pod 安全性级别（或者你正在尝试多个不同级别），
先进行测试是个不错的主意（如果使用 Privileged 级别，则可略过此步骤）。
Pod 安全性包含若干工具可用来测试和安全地推出安全性配置。</p>
<p>首先，你可以试运行新策略，这个过程可以针对所应用的策略评估当前在名字空间中运行的
Pod，但不会令新策略马上生效：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=color:#080;font-style:italic># $LEVEL 是要试运行的级别，可以是 &#34;baseline&#34; 或 &#34;restricted&#34;</span>
kubectl label --dry-run<span style=color:#666>=</span>server --overwrite ns <span style=color:#b8860b>$NAMESPACE</span> pod-security.kubernetes.io/enforce<span style=color:#666>=</span><span style=color:#b8860b>$LEVEL</span>
</code></pre></div>
<p>此命令会针对在所提议的级别下不再合法的所有 <em>现存</em> Pod 返回警告信息。</p>
<p>第二种办法在抓取当前未运行的负载方面表现的更好：audit 模式。
运行于 audit 模式（而非 enforcing 模式）下时，违反策略级别的 Pod 会被记录到审计日志中，
经过一段时间后可以在日志中查看到，但这些 Pod 不会被拒绝。
warning 模式的工作方式与此类似，不过会立即向用户返回告警信息。
你可以使用下面的命令为名字空间设置 audit 模式的级别：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>kubectl label --overwrite ns <span style=color:#b8860b>$NAMESPACE</span> pod-security.kubernetes.io/audit<span style=color:#666>=</span><span style=color:#b8860b>$LEVEL</span>
</code></pre></div>
<p>当以上两种方法输出意料之外的违例状况时，你就需要或者更新发生违例的负载以满足策略需求，
或者放宽名字空间上的 Pod 安全性级别。</p>
<h3 id=enforce-pod-security-level>3.c. 实施 Pod 安全性级别 </h3>
<p>当你对可以安全地在名字空间上实施的级别比较满意时，你可以更新名字空间来实施所期望的级别：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>kubectl label --overwrite ns <span style=color:#b8860b>$NAMESPACE</span> pod-security.kubernetes.io/enforce<span style=color:#666>=</span><span style=color:#b8860b>$LEVEL</span>
</code></pre></div>
<h3 id=bypass-psp>3.d. 绕过 PodSecurityPolicy</h3>
<p>最后，你可以通过将
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/policy/privileged-psp.yaml download=policy/privileged-psp.yaml>完全特权的 PSP</a>
绑定到某名字空间中所有服务账户上，在名字空间层面绕过所有 PodSecurityPolicy。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=color:#080;font-style:italic># 下面集群范围的命令只需要执行一次</span>
kubectl apply -f privileged-psp.yaml
kubectl create clusterrole privileged-psp --verb use --resource podsecuritypolicies.policy --resource-name privileged

<span style=color:#080;font-style:italic># 逐个名字空间地禁用</span>
kubectl create -n <span style=color:#b8860b>$NAMESPACE</span> rolebinding disable-psp --clusterrole privileged-psp --group system:serviceaccounts:<span style=color:#b8860b>$NAMESPACE</span>
</code></pre></div>
<p>由于特权 PSP 是非变更性的，PSP 准入控制器总是优选非变更性的 PSP，
上面的操作会确保对应名字空间中的所有 Pod 不再会被 PodSecurityPolicy
所更改或限制。</p>
<p>按上述操作逐个名字空间地禁用 PodSecurityPolicy 这种做法的好处是，
如果出现问题，你可以很方便地通过删除 RoleBinding 来回滚所作的更改。
你所要做的只是确保之前存在的 PodSecurityPolicy 还在。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=color:#080;font-style:italic># 撤销 PodSecurityPolicy 的禁用</span>
kubectl delete -n <span style=color:#b8860b>$NAMESPACE</span> rolebinding disable-psp
</code></pre></div>
<h2 id=review-namespace-creation-process>4. 审阅名字空间创建过程 </h2>
<p>现在，现有的名字空间都已被更新，强制实施 Pod 安全性准入，
你应该确保你用来管控新名字空间创建的流程与/或策略也被更新，这样合适的 Pod
安全性配置会被应用到新的名字空间上。</p>
<p>你也可以静态配置 Pod 安全性准入控制器，为尚未打标签的名字空间设置默认的
enforce、audit 与/或 warn 级别。详细信息可参阅
<a href=/zh/docs/tasks/configure-pod-container/enforce-standards-admission-controller/#configure-the-admission-controller>配置准入控制器</a>
页面。</p>
<h2 id=disable-psp>5. 禁用 PodSecurityPolicy </h2>
<p>最后，你已为禁用 PodSecurityPolicy 做好准备。要禁用 PodSecurityPolicy，
你需要更改 API 服务器上的准入配置：
<a href=/zh/docs/reference/access-authn-authz/admission-controllers/#how-do-i-turn-off-an-admission-controller>我如何关闭某个准入控制器？</a></p>
<p>如果需要验证 PodSecurityPolicy 准入控制器不再被启用，你可以通过扮演某个无法访问任何
PodSecurityPolicy 的用户来执行测试（参见
<a href=/zh/docs/concepts/policy/pod-security-policy/#example>PodSecurityPolicy 示例</a>），
或者通过检查 API 服务器的日志来进行验证。在启动期间，API
服务器会输出日志行，列举所挂载的准入控制器插件。</p>
<pre><code>I0218 00:59:44.903329      13 plugins.go:158] Loaded 16 mutating admission controller(s) successfully in the following order: NamespaceLifecycle,LimitRanger,ServiceAccount,NodeRestriction,TaintNodesByCondition,Priority,DefaultTolerationSeconds,ExtendedResourceToleration,PersistentVolumeLabel,DefaultStorageClass,StorageObjectInUseProtection,RuntimeClass,DefaultIngressClass,MutatingAdmissionWebhook.
I0218 00:59:44.903350      13 plugins.go:161] Loaded 14 validating admission controller(s) successfully in the following order: LimitRanger,ServiceAccount,PodSecurity,Priority,PersistentVolumeClaimResize,RuntimeClass,CertificateApproval,CertificateSigning,CertificateSubjectRestriction,DenyServiceExternalIPs,ValidatingAdmissionWebhook,ResourceQuota.
</code></pre>
<p>你应该会看到 <code>PodSecurity</code>（在 validating admission controllers 列表中），
并且两个列表中都不应该包含 <code>PodSecurityPolicy</code>。</p>
<p>一旦你确定 PSP 准入控制器已被禁用（并且这种状况已经持续了一段时间，
这样你才会比较确定不需要回滚），你就可以放心地删除你的 PodSecurityPolicy
以及所关联的所有 Role、ClusterRole、RoleBinding、ClusterRoleBinding 等对象
（仅需要确保他们不再授予其他不相关的访问权限）。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-9c9966a13899846a35113763603cd6db>5.24 - 使用名字空间标签来实施 Pod 安全性标准</h1>
<p>你可以通过为名字空间设置标签来强制实施 <a href=/zh/docs/concepts/security/pod-security-standards>Pod 安全标准</a>。</p>
<h2 id=before-you-begin>Before you begin</h2>
<p>Your Kubernetes server must be at or later than version v1.22.
To check the version, enter <code>kubectl version</code>.</p>
<ul>
<li>确保 <code>PodSecurity</code> <a href=/zh/docs/reference/command-line-tools-reference/feature-gates/#feature-gates-for-alpha-or-beta-features>特性门控</a>已被启用。</li>
</ul>
<h2 id=通过名字空间标签来要求实施-baseline-pod-容器标准>通过名字空间标签来要求实施 <code>baseline</code> Pod 容器标准</h2>
<p>下面的清单定义了一个 <code>my-baseline-namespace</code> 名字空间，其中</p>
<ul>
<li><em>阻止</em>任何不满足 <code>baseline</code> 策略要求的 Pods；</li>
<li>针对任何无法满足 <code>restricted</code> 策略要求的、已创建的 Pod 为用户生成警告信息，
并添加审计注解；</li>
<li>将 <code>baseline</code> 和 <code>restricted</code> 策略的版本锁定到 v1.27。</li>
</ul>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Namespace<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-baseline-namespace<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>pod-security.kubernetes.io/enforce</span>:<span style=color:#bbb> </span>baseline<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>pod-security.kubernetes.io/enforce-version</span>:<span style=color:#bbb> </span>v1.27<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 我们将这些标签设置为我们所 _期望_ 的 `enforce` 级别</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>pod-security.kubernetes.io/audit</span>:<span style=color:#bbb> </span>restricted<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>pod-security.kubernetes.io/audit-version</span>:<span style=color:#bbb> </span>v1.27<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>pod-security.kubernetes.io/warn</span>:<span style=color:#bbb> </span>restricted<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>pod-security.kubernetes.io/warn-version</span>:<span style=color:#bbb> </span>v1.27<span style=color:#bbb>
</span></code></pre></div>
<h2 id=使用-kubectl-label-为现有名字空间添加标签>使用 <code>kubectl label</code> 为现有名字空间添加标签</h2>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong>
<p>在添加或变更 <code>enforce</code> 策略（或版本）标签时，准入插件会测试名字空间中的每个
Pod 以检查其是否满足新的策略。不符合策略的情况会被以警告的形式返回给用户。
</div>
<p>在刚开始为名字空间评估安全性策略变更时，使用 <code>--dry-run</code> 标志是很有用的。
Pod 安全性标准会在 <em>dry run（试运行）</em>
模式下运行，在这种模式下会生成新策略如何处理现有 Pod 的信息，
但不会真正更新策略。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl label --dry-run<span style=color:#666>=</span>server --overwrite ns --all <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>    pod-security.kubernetes.io/enforce<span style=color:#666>=</span>baseline
</code></pre></div>
<h3 id=应用到所有名字空间>应用到所有名字空间</h3>
<p>如果你是刚刚开始使用 Pod 安全性标准，一种比较合适的初始步骤是针对所有名字空间为类似
<code>baseline</code> 这种比较严格的安全级别配置审计注解。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl label --overwrite ns --all <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  pod-security.kubernetes.io/audit<span style=color:#666>=</span>baseline <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  pod-security.kubernetes.io/warn<span style=color:#666>=</span>baseline
</code></pre></div>
<p>注意，这里没有设置 enforce 级别，因而没有被显式评估的名字空间可以被识别出来。
你可以使用下面的命令列举那些没有显式设置 enforce 级别的名字空间：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get namespaces --selector<span style=color:#666>=</span><span style=color:#b44>&#39;!pod-security.kubernetes.io/enforce&#39;</span>
</code></pre></div>
<h3 id=应用到单个名字空间>应用到单个名字空间</h3>
<p>你也可以更新特定的名字空间。下面的命令将 <code>enforce=restricted</code> 策略应用到
<code>my-existing-namespace</code> 名字空间，将 restricted 策略的版本锁定到 v1.27。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl label --overwrite ns my-existing-namespace <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  pod-security.kubernetes.io/enforce<span style=color:#666>=</span>restricted <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  pod-security.kubernetes.io/enforce-version<span style=color:#666>=</span>v1.27
</code></pre></div>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-108be708e50a97cae1cc0b67d5f360b7>5.25 - 通过配置内置准入控制器实施 Pod 安全标准</h1>
<p>在 v1.22 版本中，Kubernetes 提供一种内置的<a href=/zh/docs/reference/access-authn-authz/admission-controllers/#podsecurity>准入控制器</a>
用来强制实施 <a href=/zh/docs/concepts/security/pod-security-standards>Pod 安全标准</a>。
你可以配置此准入控制器来设置集群范围的默认值和<a href=/zh/docs/concepts/security/pod-security-admission/#exemptions>豁免选项</a>。</p>
<h2 id=before-you-begin>Before you begin</h2>
<p>Your Kubernetes server must be at or later than version v1.22.
To check the version, enter <code>kubectl version</code>.</p>
<ul>
<li>确保 <code>PodSecurity</code> <a href=/zh/docs/reference/command-line-tools-reference/feature-gates/#feature-gates-for-alpha-or-beta-features>特性门控</a>已被启用。</li>
</ul>
<h2 id=configure-the-admission-controller>配置准入控制器 </h2>
<ul class="nav nav-tabs" id=podsecurityconfiguration-example-1 role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#podsecurityconfiguration-example-1-0 role=tab aria-controls=podsecurityconfiguration-example-1-0 aria-selected=true>pod-security.admission.config.k8s.io/v1beta1</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#podsecurityconfiguration-example-1-1 role=tab aria-controls=podsecurityconfiguration-example-1-1>pod-security.admission.config.k8s.io/v1alpha1</a></li></ul>
<div class=tab-content id=podsecurityconfiguration-example-1><div id=podsecurityconfiguration-example-1-0 class="tab-pane show active" role=tabpanel aria-labelledby=podsecurityconfiguration-example-1-0>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apiserver.config.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>AdmissionConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>plugins</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>PodSecurity<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>configuration</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>pod-security.admission.config.k8s.io/v1beta1<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PodSecurityConfiguration<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 当未设置 mode 标签时会应用的默认设置</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic>#</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># level 标签必须是以下取值之一：</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># - &#34;privileged&#34; (默认)</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># - &#34;baseline&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># - &#34;restricted&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic>#</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># version 标签必须是如下取值之一：</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># - &#34;latest&#34; (默认) </span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># - 诸如 &#34;v1.27&#34; 这类版本号</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>defaults</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>enforce</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;privileged&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>enforce-version</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;latest&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>audit</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;privileged&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>audit-version</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;latest&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>warn</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;privileged&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>warn-version</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;latest&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>exemptions</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 要豁免的已认证用户名列表</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>usernames</span>:<span style=color:#bbb> </span>[]<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 要豁免的运行时类名称列表</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>runtimeClasses</span>:<span style=color:#bbb> </span>[]<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 要豁免的名字空间列表</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>namespaces</span>:<span style=color:#bbb> </span>[]<span style=color:#bbb>
</span></code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>Note:</strong>
<p>v1beta1 配置结构需要使用 v1.23+ 版本；对于 v1.22 版本，可使用 v1alpha1。
</div>
</div>
<div id=podsecurityconfiguration-example-1-1 class=tab-pane role=tabpanel aria-labelledby=podsecurityconfiguration-example-1-1>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apiserver.config.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>AdmissionConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>plugins</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>PodSecurity<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>configuration</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>pod-security.admission.config.k8s.io/v1alpha1<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PodSecurityConfiguration<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 当未设置 mode 标签时会应用的默认设置</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic>#</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># level 标签必须是以下取值之一：</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># - &#34;privileged&#34; (默认)</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># - &#34;baseline&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># - &#34;restricted&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic>#</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># version 标签必须是如下取值之一：</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># - &#34;latest&#34; (默认) </span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># - 诸如 &#34;v1.27&#34; 这类版本号</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>defaults</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>enforce</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;privileged&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>enforce-version</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;latest&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>audit</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;privileged&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>audit-version</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;latest&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>warn</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;privileged&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>warn-version</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;latest&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>exemptions</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 要豁免的已认证用户名列表</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>usernames</span>:<span style=color:#bbb> </span>[]<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 要豁免的运行时类名称列表</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>runtimeClasses</span>:<span style=color:#bbb> </span>[]<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 要豁免的名字空间列表</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>namespaces</span>:<span style=color:#bbb> </span>[]<span style=color:#bbb>
</span></code></pre></div></div></div>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-aa0731e8aa8e2f6cc9e3c1a5e9895863>6 - 管理 Kubernetes 对象</h1>
<div class=lead>用声明式和命令式范型与 Kubernetes API 交互。</div>
</div>
<div class=td-content>
<h1 id=pg-df206392be6f4d19bd8da41cee7170fa>6.1 - 使用配置文件对 Kubernetes 对象进行声明式管理</h1>
<p>你可以通过在一个目录中存储多个对象配置文件、并使用 <code>kubectl apply</code>
来递归地创建和更新对象来创建、更新和删除 Kubernetes 对象。
这种方法会保留对现有对象已作出的修改，而不会将这些更改写回到对象配置文件中。
<code>kubectl diff</code> 也会给你呈现 <code>apply</code> 将作出的变更的预览。</p>
<h2 id=before-you-begin>Before you begin</h2>
<p>安装 <a href=/zh/docs/tasks/tools/><code>kubectl</code></a>。</p>
<p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li>
</ul>
To check the version, enter <code>kubectl version</code>.
</p>
<h2 id=trade-offs>权衡取舍 </h2>
<p><code>kubectl</code> 工具能够支持三种对象管理方式：</p>
<ul>
<li>指令式命令</li>
<li>指令式对象配置</li>
<li>声明式对象配置</li>
</ul>
<p>关于每种对象管理的优缺点的讨论，可参见
<a href=/zh/docs/concepts/overview/working-with-objects/object-management/>Kubernetes 对象管理</a>。</p>
<h2 id=overview>概览 </h2>
<p>声明式对象管理需要用户对 Kubernetes 对象定义和配置有比较深刻的理解。
如果你还没有这方面的知识储备，请先阅读下面的文档：</p>
<ul>
<li><a href=/zh/docs/tasks/manage-kubernetes-objects/imperative-command/>使用指令式命令管理 Kubernetes 对象</a></li>
<li><a href=/zh/docs/tasks/manage-kubernetes-objects/imperative-config/>使用配置文件对 Kubernetes 对象进行指令式管理</a></li>
</ul>
<p>以下是本文档中使用的术语的定义：</p>
<ul>
<li><em>对象配置文件/配置文件</em>：一个定义 Kubernetes 对象的配置的文件。
本主题展示如何将配置文件传递给 <code>kubectl apply</code>。
配置文件通常存储于类似 Git 这种源码控制系统中。</li>
<li><em>现时对象配置/现时配置</em>：由 Kubernetes 集群所观测到的对象的现时配置值。
这些配置保存在 Kubernetes 集群存储（通常是 etcd）中。</li>
<li><em>声明式配置写者/声明式写者</em>：负责更新现时对象的人或者软件组件。
本主题中的声明式写者负责改变对象配置文件并执行 <code>kubectl apply</code> 命令
以写入变更。</li>
</ul>
<h2 id=how-to-create-objects>如何创建对象</h2>
<p>使用 <code>kubectl apply</code> 来创建指定目录中配置文件所定义的所有对象，除非对应对象已经存在：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f &lt;目录&gt;/
</code></pre></div><p>此操作会在每个对象上设置 <code>kubectl.kubernetes.io/last-applied-configuration: '{...}'</code>
注解。注解值中包含了用来创建对象的配置文件的内容。</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 添加 <code>-R</code> 标志可以递归地处理目录。
</div>
<p>下面是一个对象配置文件示例：</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/application/simple_deployment.yaml download=application/simple_deployment.yaml><code>application/simple_deployment.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('application-simple-deployment-yaml')" title="Copy application/simple_deployment.yaml to clipboard">
</img>
</div>
<div class=includecode id=application-simple-deployment-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-deployment<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>minReadySeconds</span>:<span style=color:#bbb> </span><span style=color:#666>5</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.14.2<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>执行 <code>kubectl diff</code> 可以打印出将被创建的对象：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl diff -f https://k8s.io/examples/application/simple_deployment.yaml
</code></pre></div>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> <p><code>diff</code> 使用<a href=/zh/docs/reference/using-api/api-concepts/#dry-run>服务器端试运行（Server-side Dry-run）</a>
功能特性；而该功能特性需要在 <code>kube-apiserver</code> 上启用。</p>
<p>由于 <code>diff</code> 操作会使用试运行模式执行服务器端 apply 请求，因此需要为
用户配置 <code>PATCH</code>、<code>CREATE</code> 和 <code>UPDATE</code> 操作权限。
参阅<a href=/zh/docs/reference/using-api/api-concepts#dry-run-authorization>试运行授权</a>
了解详情。</p>
</div>
<p>使用 <code>kubectl apply</code> 来创建对象：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/application/simple_deployment.yaml
</code></pre></div>
<p>使用 <code>kubectl get</code> 打印其现时配置：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get -f https://k8s.io/examples/application/simple_deployment.yaml -o yaml
</code></pre></div>
<p>输出显示注解 <code>kubectl.kubernetes.io/last-applied-configuration</code> 被写入到
现时配置中，并且其内容与配置文件相同：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># This is the json representation of simple_deployment.yaml</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># It was written by kubectl apply when the object was created</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubectl.kubernetes.io/last-applied-configuration</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span><span style=color:#b44;font-style:italic>      {&#34;apiVersion&#34;:&#34;apps/v1&#34;,&#34;kind&#34;:&#34;Deployment&#34;,
</span><span style=color:#b44;font-style:italic>      &#34;metadata&#34;:{&#34;annotations&#34;:{},&#34;name&#34;:&#34;nginx-deployment&#34;,&#34;namespace&#34;:&#34;default&#34;},
</span><span style=color:#b44;font-style:italic>      &#34;spec&#34;:{&#34;minReadySeconds&#34;:5,&#34;selector&#34;:{&#34;matchLabels&#34;:{&#34;app&#34;:nginx}},&#34;template&#34;:{&#34;metadata&#34;:{&#34;labels&#34;:{&#34;app&#34;:&#34;nginx&#34;}},
</span><span style=color:#b44;font-style:italic>      &#34;spec&#34;:{&#34;containers&#34;:[{&#34;image&#34;:&#34;nginx:1.14.2&#34;,&#34;name&#34;:&#34;nginx&#34;,
</span><span style=color:#b44;font-style:italic>      &#34;ports&#34;:[{&#34;containerPort&#34;:80}]}]}}}}</span><span style=color:#bbb>      
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>minReadySeconds</span>:<span style=color:#bbb> </span><span style=color:#666>5</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.14.2<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span></code></pre></div>
<h2 id=how-to-update-objects>如何更新对象 </h2>
<p>你也可以使用 <code>kubectl apply</code> 来更新某个目录中定义的所有对象，即使那些对象已经存在。
这一操作会隐含以下行为：</p>
<ol>
<li>在现时配置中设置配置文件中出现的字段；</li>
<li>在现时配置中清除配置文件中已删除的字段。</li>
</ol>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl diff -f &lt;目录&gt;/
kubectl apply -f &lt;目录&gt;/
</code></pre></div>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 使用 <code>-R</code> 标志递归处理目录。
</div>
<p>下面是一个配置文件示例：</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/application/simple_deployment.yaml download=application/simple_deployment.yaml><code>application/simple_deployment.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('application-simple-deployment-yaml')" title="Copy application/simple_deployment.yaml to clipboard">
</img>
</div>
<div class=includecode id=application-simple-deployment-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-deployment<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>minReadySeconds</span>:<span style=color:#bbb> </span><span style=color:#666>5</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.14.2<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>使用 <code>kubectl apply</code> 来创建对象：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/application/simple_deployment.yaml
</code></pre></div>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 出于演示的目的，上面的命令引用的是单个文件而不是整个目录。
</div>
<p>使用 <code>kubectl get</code> 打印现时配置：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get -f https://k8s.io/examples/application/simple_deployment.yaml -o yaml
</code></pre></div>
<p>输出显示，注解 <code>kubectl.kubernetes.io/last-applied-configuration</code> 被写入到
现时配置中，并且其取值与配置文件内容相同。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 此为 simple_deployment.yaml 的 JSON 表示</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 在对象创建时由 kubectl apply 命令写入</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubectl.kubernetes.io/last-applied-configuration</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span><span style=color:#b44;font-style:italic>      {&#34;apiVersion&#34;:&#34;apps/v1&#34;,&#34;kind&#34;:&#34;Deployment&#34;,
</span><span style=color:#b44;font-style:italic>      &#34;metadata&#34;:{&#34;annotations&#34;:{},&#34;name&#34;:&#34;nginx-deployment&#34;,&#34;namespace&#34;:&#34;default&#34;},
</span><span style=color:#b44;font-style:italic>      &#34;spec&#34;:{&#34;minReadySeconds&#34;:5,&#34;selector&#34;:{&#34;matchLabels&#34;:{&#34;app&#34;:nginx}},&#34;template&#34;:{&#34;metadata&#34;:{&#34;labels&#34;:{&#34;app&#34;:&#34;nginx&#34;}},
</span><span style=color:#b44;font-style:italic>      &#34;spec&#34;:{&#34;containers&#34;:[{&#34;image&#34;:&#34;nginx:1.14.2&#34;,&#34;name&#34;:&#34;nginx&#34;,
</span><span style=color:#b44;font-style:italic>      &#34;ports&#34;:[{&#34;containerPort&#34;:80}]}]}}}}</span><span style=color:#bbb>      
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>minReadySeconds</span>:<span style=color:#bbb> </span><span style=color:#666>5</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.14.2<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span></code></pre></div>
<p>通过 <code>kubectl scale</code> 命令直接更新现时配置中的 <code>replicas</code> 字段。
这一命令没有使用 <code>kubectl apply</code>：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl scale deployment/nginx-deployment --replicas<span style=color:#666>=</span><span style=color:#666>2</span>
</code></pre></div>
<p>使用 <code>kubectl get</code> 来打印现时配置：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get deployment nginx-deployment -o yaml
</code></pre></div>
<p>输出显示，<code>replicas</code> 字段已经被设置为 2，而 <code>last-applied-configuration</code> 注解中
并不包含 <code>replicas</code> 字段。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 注意注解中并不包含 replicas</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 这是因为更新并不是通过 kubectl apply 来执行的</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubectl.kubernetes.io/last-applied-configuration</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span><span style=color:#b44;font-style:italic>      {&#34;apiVersion&#34;:&#34;apps/v1&#34;,&#34;kind&#34;:&#34;Deployment&#34;,
</span><span style=color:#b44;font-style:italic>      &#34;metadata&#34;:{&#34;annotations&#34;:{},&#34;name&#34;:&#34;nginx-deployment&#34;,&#34;namespace&#34;:&#34;default&#34;},
</span><span style=color:#b44;font-style:italic>      &#34;spec&#34;:{&#34;minReadySeconds&#34;:5,&#34;selector&#34;:{&#34;matchLabels&#34;:{&#34;app&#34;:nginx}},&#34;template&#34;:{&#34;metadata&#34;:{&#34;labels&#34;:{&#34;app&#34;:&#34;nginx&#34;}},
</span><span style=color:#b44;font-style:italic>      &#34;spec&#34;:{&#34;containers&#34;:[{&#34;image&#34;:&#34;nginx:1.14.2&#34;,&#34;name&#34;:&#34;nginx&#34;,
</span><span style=color:#b44;font-style:italic>      &#34;ports&#34;:[{&#34;containerPort&#34;:80}]}]}}}}</span><span style=color:#bbb>      
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>2</span><span style=color:#bbb> </span><span style=color:#080;font-style:italic># written by scale</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>minReadySeconds</span>:<span style=color:#bbb> </span><span style=color:#666>5</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.14.2<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span></code></pre></div>
<p>现在更新 <code>simple_deployment.yaml</code> 配置文件，将镜像文件从
<code>nginx:1.14.2</code> 更改为 <code>nginx:1.16.1</code>，同时删除<code>minReadySeconds</code> 字段：</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/application/update_deployment.yaml download=application/update_deployment.yaml><code>application/update_deployment.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('application-update-deployment-yaml')" title="Copy application/update_deployment.yaml to clipboard">
</img>
</div>
<div class=includecode id=application-update-deployment-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-deployment<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.16.1<span style=color:#bbb> </span><span style=color:#080;font-style:italic># update the image</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>应用对配置文件所作更改：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl diff -f https://k8s.io/examples/application/update_deployment.yaml
kubectl apply -f https://k8s.io/examples/application/update_deployment.yaml
</code></pre></div>
<p>使用 <code>kubectl get</code> 打印现时配置：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get -f https://k8s.io/examples/application/update_deployment.yaml -o yaml
</code></pre></div>
<p>输出显示现时配置中发生了以下更改：</p>
<ul>
<li>字段 <code>replicas</code> 保留了 <code>kubectl scale</code> 命令所设置的值：2；
之所以该字段被保留是因为配置文件中并没有设置 <code>replicas</code>。</li>
<li>字段 <code>image</code> 的内容已经从 <code>nginx:1.14.2</code> 更改为 <code>nginx:1.16.1</code>。</li>
<li>注解 <code>last-applied-configuration</code> 内容被更改为新的镜像名称。</li>
<li>字段 <code>minReadySeconds</code> 被移除。</li>
<li>注解 <code>last-applied-configuration</code> 中不再包含 <code>minReadySeconds</code> 字段。</li>
</ul>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 注解中包含更新后的镜像 nginx 1.16.1</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 但是其中并不包含更改后的 replicas 值 2</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubectl.kubernetes.io/last-applied-configuration</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span><span style=color:#b44;font-style:italic>      {&#34;apiVersion&#34;:&#34;apps/v1&#34;,&#34;kind&#34;:&#34;Deployment&#34;,
</span><span style=color:#b44;font-style:italic>      &#34;metadata&#34;:{&#34;annotations&#34;:{},&#34;name&#34;:&#34;nginx-deployment&#34;,&#34;namespace&#34;:&#34;default&#34;},
</span><span style=color:#b44;font-style:italic>      &#34;spec&#34;:{&#34;selector&#34;:{&#34;matchLabels&#34;:{&#34;app&#34;:nginx}},&#34;template&#34;:{&#34;metadata&#34;:{&#34;labels&#34;:{&#34;app&#34;:&#34;nginx&#34;}},
</span><span style=color:#b44;font-style:italic>      &#34;spec&#34;:{&#34;containers&#34;:[{&#34;image&#34;:&#34;nginx:1.16.1&#34;,&#34;name&#34;:&#34;nginx&#34;,
</span><span style=color:#b44;font-style:italic>      &#34;ports&#34;:[{&#34;containerPort&#34;:80}]}]}}}}</span><span style=color:#bbb>      
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>2</span><span style=color:#bbb> </span><span style=color:#080;font-style:italic># 由 `kubectl scale` 设置，被 `kubectl apply` 命令忽略</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># minReadySeconds 被 `kubectl apply` 清除</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.16.1<span style=color:#bbb> </span><span style=color:#080;font-style:italic># 由 `kubectl apply` 设置</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span></code></pre></div>
<div class="alert alert-danger warning callout" role=alert>
<strong>Warning:</strong> 将 <code>kubectl apply</code> 与指令式对象配置命令 <code>kubectl create</code> 或 <code>kubectl replace</code>
混合使用是不受支持的。这是因为 <code>create</code> 和 <code>replace</code> 命令都不会保留
<code>kubectl apply</code> 用来计算更新内容所使用的
<code>kubectl.kubernetes.io/last-applied-configuration</code> 注解值。
</div>
<h2 id=how-to-delete-objects>如何删除对象 </h2>
<p>有两种方法来删除 <code>kubectl apply</code> 管理的对象。</p>
<h3 id=建议操作-kubectl-delete-f-文件名>建议操作：<code>kubectl delete -f &lt;文件名></code></h3>
<p>使用指令式命令来手动删除对象是建议的方法，因为这种方法更为明确地给出了
要删除的内容是什么，且不容易造成用户不小心删除了其他对象的情况。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete -f &lt;文件名&gt;
</code></pre></div>
<h3 id=替代方式-kubectl-apply-f-目录名称-prune-l-your-label>替代方式：<code>kubectl apply -f &lt;目录名称/> --prune -l your=label</code></h3>
<p>只有在充分理解此命令背后含义的情况下才建议这样操作。</p>
<div class="alert alert-danger warning callout" role=alert>
<strong>Warning:</strong> <code>kubectl apply --prune</code> 命令本身仍处于 Alpha 状态，在后续发布版本中可能会
引入一些向后不兼容的变化。
</div>
<div class="alert alert-danger warning callout" role=alert>
<strong>Warning:</strong> 在使用此命令时必须小心，这样才不会无意中删除不想删除的对象。
</div>
<p>作为 <code>kubectl delete</code> 操作的替代方式，你可以在目录中对象配置文件被删除之后，
使用 <code>kubectl apply</code> 来辩识要删除的对象。
带 <code>--prune</code> 标志的 <code>apply</code> 命令会首先查询 API 服务器，获得与某组标签相匹配
的对象列表，之后将返回的现时对象配置与目录中的对象配置文件相比较。
如果某对象在查询中被匹配到，但在目录中没有文件与其相对应，并且其中还包含
<code>last-applied-configuration</code> 注解，则该对象会被删除。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f &lt;directory/&gt; --prune -l &lt;labels&gt;
</code></pre></div>
<div class="alert alert-danger warning callout" role=alert>
<strong>Warning:</strong> 带剪裁（prune）行为的 <code>apply</code> 操作应在包含对象配置文件的目录的根目录运行。
如果在其子目录中运行，可能导致对象被不小心删除。
因为某些对象可能与 <code>-l &lt;标签></code> 的标签选择算符匹配，但其配置文件不在当前
子目录下。
</div>
<h2 id=how-to-view-an-object>如何查看对象 </h2>
<p>你可以使用 <code>kubectl get</code> 并指定 <code>-o yaml</code> 选项来查看现时对象的配置：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get -f &lt;文件名 | URL&gt; -o yaml
</code></pre></div>
<h2 id=apply-操作是如何计算配置差异并合并变更的>apply 操作是如何计算配置差异并合并变更的？</h2>
<div class="alert alert-warning caution callout" role=alert>
<strong>Caution:</strong> <em>patch</em> 是一种更新操作，其作用域为对象的一些特定字段而不是整个对象。
这使得你可以更新对象的特定字段集合而不必先要读回对象。
</div>
<p><code>kubectl apply</code> 更新对象的现时配置，它是通过向 API 服务器发送一个 patch 请求
来执行更新动作的。
所提交的补丁中定义了对现时对象配置中特定字段的更新。
<code>kubectl apply</code> 命令会使用当前的配置文件、现时配置以及现时配置中保存的
<code>last-applied-configuration</code> 注解内容来计算补丁更新内容。</p>
<h3 id=merge-patch-calculation>合并补丁计算 </h3>
<p><code>kubectl apply</code> 命令将配置文件的内容写入到
<code>kubectl.kubernetes.io/last-applied-configuration</code> 注解中。
这些内容用来识别配置文件中已经移除的、因而也需要从现时配置中删除的字段。
用来计算要删除或设置哪些字段的步骤如下：</p>
<ol>
<li>计算要删除的字段，即在 <code>last-applied-configuration</code> 中存在但在
配置文件中不再存在的字段。</li>
<li>计算要添加或设置的字段，即在配置文件中存在但其取值与现时配置不同的字段。</li>
</ol>
<p>下面是一个例子。假定此文件是某 Deployment 对象的配置文件：</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/application/update_deployment.yaml download=application/update_deployment.yaml><code>application/update_deployment.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('application-update-deployment-yaml')" title="Copy application/update_deployment.yaml to clipboard">
</img>
</div>
<div class=includecode id=application-update-deployment-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-deployment<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.16.1<span style=color:#bbb> </span><span style=color:#080;font-style:italic># update the image</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>同时假定同一 Deployment 对象的现时配置如下：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubectl.kubernetes.io/last-applied-configuration</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span><span style=color:#b44;font-style:italic>      {&#34;apiVersion&#34;:&#34;apps/v1&#34;,&#34;kind&#34;:&#34;Deployment&#34;,
</span><span style=color:#b44;font-style:italic>      &#34;metadata&#34;:{&#34;annotations&#34;:{},&#34;name&#34;:&#34;nginx-deployment&#34;,&#34;namespace&#34;:&#34;default&#34;},
</span><span style=color:#b44;font-style:italic>      &#34;spec&#34;:{&#34;minReadySeconds&#34;:5,&#34;selector&#34;:{&#34;matchLabels&#34;:{&#34;app&#34;:nginx}},&#34;template&#34;:{&#34;metadata&#34;:{&#34;labels&#34;:{&#34;app&#34;:&#34;nginx&#34;}},
</span><span style=color:#b44;font-style:italic>      &#34;spec&#34;:{&#34;containers&#34;:[{&#34;image&#34;:&#34;nginx:1.14.2&#34;,&#34;name&#34;:&#34;nginx&#34;,
</span><span style=color:#b44;font-style:italic>      &#34;ports&#34;:[{&#34;containerPort&#34;:80}]}]}}}}</span><span style=color:#bbb>      
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>2</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>minReadySeconds</span>:<span style=color:#bbb> </span><span style=color:#666>5</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.14.2<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span></code></pre></div>
<p>下面是 <code>kubectl apply</code> 将执行的合并计算：</p>
<ol>
<li>通过读取 <code>last-applied-configuration</code> 并将其与配置文件中的值相比较，
计算要删除的字段。
对于本地对象配置文件中显式设置为空的字段，清除其在现时配置中的设置，
无论这些字段是否出现在 <code>last-applied-configuration</code> 中。
在此例中，<code>minReadySeconds</code> 出现在 <code>last-applied-configuration</code> 注解中，但
并不存在于配置文件中。
<strong>动作：</strong> 从现时配置中删除 <code>minReadySeconds</code> 字段。</li>
<li>通过读取配置文件中的值并将其与现时配置相比较，计算要设置的字段。
在这个例子中，配置文件中的 <code>image</code> 值与现时配置中的 <code>image</code> 不匹配。
<strong>动作</strong>：设置现时配置中的 <code>image</code> 值。</li>
<li>设置 <code>last-applied-configuration</code> 注解的内容，使之与配置文件匹配。</li>
<li>将第 1、2、3 步骤得出的结果合并，构成向 API 服务器发送的补丁请求内容。</li>
</ol>
<p>下面是此合并操作之后形成的现时配置：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 注解中包含更新后的 image，nginx 1.11.9,</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 但不包含更新后的 replicas</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubectl.kubernetes.io/last-applied-configuration</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span><span style=color:#b44;font-style:italic>      {&#34;apiVersion&#34;:&#34;apps/v1&#34;,&#34;kind&#34;:&#34;Deployment&#34;,
</span><span style=color:#b44;font-style:italic>      &#34;metadata&#34;:{&#34;annotations&#34;:{},&#34;name&#34;:&#34;nginx-deployment&#34;,&#34;namespace&#34;:&#34;default&#34;},
</span><span style=color:#b44;font-style:italic>      &#34;spec&#34;:{&#34;selector&#34;:{&#34;matchLabels&#34;:{&#34;app&#34;:nginx}},&#34;template&#34;:{&#34;metadata&#34;:{&#34;labels&#34;:{&#34;app&#34;:&#34;nginx&#34;}},
</span><span style=color:#b44;font-style:italic>      &#34;spec&#34;:{&#34;containers&#34;:[{&#34;image&#34;:&#34;nginx:1.16.1&#34;,&#34;name&#34;:&#34;nginx&#34;,
</span><span style=color:#b44;font-style:italic>      &#34;ports&#34;:[{&#34;containerPort&#34;:80}]}]}}}}</span><span style=color:#bbb>      
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>2</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># minReadySeconds  此字段被清除</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.16.1<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span></code></pre></div>
<h3 id=不同类型字段的合并方式>不同类型字段的合并方式</h3>
<p>配置文件中的特定字段与现时配置合并时，合并方式取决于字段类型。
字段类型有几种：</p>
<ul>
<li>
<p><em>基本类型</em>：字段类型为 <code>string</code>、<code>integer</code> 或 <code>boolean</code> 之一。
例如：<code>image</code> 和 <code>replicas</code> 字段都是基本类型字段。</p>
<p><strong>动作：</strong> 替换。</p>
</li>
<li>
<p><em>map</em>：也称作 <em>object</em>。类型为 <code>map</code> 或包含子域的复杂结构。例如，<code>labels</code>、
<code>annotations</code>、<code>spec</code> 和 <code>metadata</code> 都是 map。</p>
<p><strong>动作：</strong> 合并元素或子字段。</p>
</li>
<li>
<p><em>list</em>：包含元素列表的字段，其中每个元素可以是基本类型或 map。
例如，<code>containers</code>、<code>ports</code> 和 <code>args</code> 都是 list。</p>
<p><strong>动作：</strong> 不一定。</p>
</li>
</ul>
<p>当 <code>kubectl apply</code> 更新某个 map 或 list 字段时，它通常不会替换整个字段，而是会
更新其中的各个子元素。例如，当合并 Deployment 的 <code>spec</code> 时，<code>kubectl</code> 并不会
将其整个替换掉。相反，实际操作会是对 <code>replicas</code> 这类 <code>spec</code>
的子字段来执行比较和更新。</p>
<h3 id=合并对基本类型字段的更新>合并对基本类型字段的更新</h3>
<p>基本类型字段会被替换或清除。</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> <code>-</code> 表示的是“不适用”，因为指定数值未被使用。
</div>
<table>
<thead>
<tr>
<th>字段在对象配置文件中</th>
<th>字段在现时对象配置中</th>
<th>字段在 <code>last-applied-configuration</code> 中</th>
<th>动作</th>
</tr>
</thead>
<tbody>
<tr>
<td>是</td>
<td>是</td>
<td>-</td>
<td>将配置文件中值设置到现时配置上。</td>
</tr>
<tr>
<td>是</td>
<td>否</td>
<td>-</td>
<td>将配置文件中值设置到现时配置上。</td>
</tr>
<tr>
<td>否</td>
<td>-</td>
<td>是</td>
<td>从现时配置中移除。</td>
</tr>
<tr>
<td>否</td>
<td>-</td>
<td>否</td>
<td>什么也不做。保持现时值。</td>
</tr>
</tbody>
</table>
<h3 id=合并对-map-字段的变更>合并对 map 字段的变更</h3>
<p>用来表示映射的字段在合并时会逐个子字段或元素地比较：</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> <code>-</code> 表示的是“不适用”，因为指定数值未被使用。
</div>
<table>
<thead>
<tr>
<th>键存在于对象配置文件中</th>
<th>键存在于现时对象配置中</th>
<th>键存在于 <code>last-applied-configuration</code> 中</th>
<th>动作</th>
</tr>
</thead>
<tbody>
<tr>
<td>是</td>
<td>是</td>
<td>-</td>
<td>比较子域取值。</td>
</tr>
<tr>
<td>是</td>
<td>否</td>
<td>-</td>
<td>将现时配置设置为本地配置值。</td>
</tr>
<tr>
<td>否</td>
<td>-</td>
<td>是</td>
<td>从现时配置中删除键。</td>
</tr>
<tr>
<td>否</td>
<td>-</td>
<td>否</td>
<td>什么也不做，保留现时值。</td>
</tr>
</tbody>
</table>
<h3 id=合并-list-类型字段的变更>合并 list 类型字段的变更</h3>
<p>对 list 类型字段的变更合并会使用以下三种策略之一：</p>
<ul>
<li>如果 list 所有元素都是基本类型则替换整个 list。</li>
<li>如果 list 中元素是复合结构则逐个元素执行合并操作。</li>
<li>合并基本类型元素构成的 list。</li>
</ul>
<p>策略的选择是基于各个字段做出的。</p>
<h4 id=如果-list-中元素都是基本类型则替换整个-list>如果 list 中元素都是基本类型则替换整个 list</h4>
<p>将整个 list 视为一个基本类型字段。或者整个替换或者整个删除。
此操作会保持 list 中元素顺序不变</p>
<p><strong>示例：</strong> 使用 <code>kubectl apply</code> 来更新 Pod 中 Container 的 <code>args</code> 字段。此操作会
将现时配置中的 <code>args</code> 值设为配置文件中的值。
所有之前添加到现时配置中的 <code>args</code> 元素都会丢失。
配置文件中的 <code>args</code> 元素的顺序在被添加到现时配置中时保持不变。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#080;font-style:italic># last-applied-configuration 值</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;a&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;b&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># 配置文件值</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;a&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;c&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># 现时配置</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;a&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;b&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;d&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># 合并结果</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;a&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;c&#34;</span>]<span style=color:#bbb>
</span></code></pre></div>
<p><strong>解释：</strong> 合并操作将配置文件中的值当做新的 list 值。</p>
<h4 id=如果-list-中元素为复合类型则逐个执行合并>如果 list 中元素为复合类型则逐个执行合并</h4>
<p>此操作将 list 视为 map，并将每个元素中的特定字段当做其主键。
逐个元素地执行添加、删除或更新操作。结果顺序无法得到保证。</p>
<p>此合并策略会使用每个字段上的一个名为 <code>patchMergeKey</code> 的特殊标签。
Kubernetes 源代码中为每个字段定义了 <code>patchMergeKey</code>：
<a href=https://github.com/kubernetes/api/blob/d04500c8c3dda9c980b668c57abc2ca61efcf5c4/core/v1/types.go#L2747>types.go</a>
当合并由 map 组成的 list 时，给定元素中被设置为 <code>patchMergeKey</code> 的字段会被
当做该元素的 map 键值来使用。</p>
<p><strong>例如：</strong> 使用 <code>kubectl apply</code> 来更新 Pod 规约中的 <code>containers</code> 字段。
此操作会将 <code>containers</code> 列表视作一个映射来执行合并，每个元素的主键为 <code>name</code>。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#080;font-style:italic># last-applied-configuration 值</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.16<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-helper-a<span style=color:#bbb> </span><span style=color:#080;font-style:italic># 键 nginx-helper-a 会被删除</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>helper:1.3<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-helper-b<span style=color:#bbb> </span><span style=color:#080;font-style:italic># 键 nginx-helper-b 会被保留</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>helper:1.3<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># 配置文件值</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.16<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-helper-b<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>helper:1.3<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-helper-c<span style=color:#bbb> </span><span style=color:#080;font-style:italic># 键 nginx-helper-c 会被添加</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>helper:1.3<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># 现时配置</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.16<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-helper-a<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>helper:1.3<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-helper-b<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>helper:1.3<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;run&#34;</span>]<span style=color:#bbb>        </span><span style=color:#080;font-style:italic># 字段会被保留</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-helper-d<span style=color:#bbb> </span><span style=color:#080;font-style:italic># 键 nginx-helper-d 会被保留</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>helper:1.3<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># 合并结果</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.16<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 元素 nginx-helper-a 被删除</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-helper-b<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>helper:1.3<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;run&#34;</span>]<span style=color:#bbb>        </span><span style=color:#080;font-style:italic># 字段被保留</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-helper-c<span style=color:#bbb> </span><span style=color:#080;font-style:italic># 新增元素</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>helper:1.3<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-helper-d<span style=color:#bbb> </span><span style=color:#080;font-style:italic># 此元素被忽略（保留）</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>helper:1.3<span style=color:#bbb>
</span></code></pre></div>
<p><strong>解释：</strong></p>
<ul>
<li>名为 "nginx-helper-a" 的容器被删除，因为配置文件中不存在同名的容器。</li>
<li>名为 "nginx-helper-b" 的容器的现时配置中的 <code>args</code> 被保留。
<code>kubectl apply</code> 能够辩识出现时配置中的容器 "nginx-helper-b" 与配置文件
中的容器 "nginx-helper-b" 相同，即使它们的字段值有些不同（配置文件中未给定
<code>args</code> 值）。这是因为 <code>patchMergeKey</code> 字段（name）的值在两个版本中都一样。</li>
<li>名为 "nginx-helper-c" 的容器是新增的，因为在配置文件中的这个容器尚不存在
于现时配置中。</li>
<li>名为 "nginx-helper-d" 的容器被保留下来，因为在 last-applied-configuration
中没有与之同名的元素。</li>
</ul>
<h4 id=合并基本类型元素-list>合并基本类型元素 list</h4>
<p>在 Kubernetes 1.5 中，尚不支持对由基本类型元素构成的 list 进行合并。</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 选择上述哪种策略是由源码中给定字段的 <code>patchStrategy</code> 标记来控制的：
<a href=https://github.com/kubernetes/api/blob/d04500c8c3dda9c980b668c57abc2ca61efcf5c4/core/v1/types.go#L2748>types.go</a>
如果 list 类型字段未设置 <code>patchStrategy</code>，则整个 list 会被替换掉。
</div>
<h2 id=default-field-values>默认字段值 </h2>
<p>API 服务器会在对象创建时其中某些字段未设置的情况下在现时配置中为其设置默认值。</p>
<p>下面是一个 Deployment 的配置文件。文件未设置 <code>strategy</code>：</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/application/simple_deployment.yaml download=application/simple_deployment.yaml><code>application/simple_deployment.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('application-simple-deployment-yaml')" title="Copy application/simple_deployment.yaml to clipboard">
</img>
</div>
<div class=includecode id=application-simple-deployment-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-deployment<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>minReadySeconds</span>:<span style=color:#bbb> </span><span style=color:#666>5</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.14.2<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>使用 <code>kubectl apply</code> 创建对象：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/application/simple_deployment.yaml
</code></pre></div>
<p>使用 <code>kubectl get</code> 打印现时配置：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get -f https://k8s.io/examples/application/simple_deployment.yaml -o yaml
</code></pre></div>
<p>输出显示 API 在现时配置中为某些字段设置了默认值。
这些字段在配置文件中并未设置。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>minReadySeconds</span>:<span style=color:#bbb> </span><span style=color:#666>5</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>           </span><span style=color:#080;font-style:italic># API 服务器所设默认值</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>strategy</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>rollingUpdate</span>:<span style=color:#bbb>      </span><span style=color:#080;font-style:italic># API 服务器基于 strategy.type 所设默认值</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>maxSurge</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>maxUnavailable</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>RollingUpdate<span style=color:#bbb> </span><span style=color:#080;font-style:italic># API 服务器所设默认值</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>creationTimestamp</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>null</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.14.2<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>imagePullPolicy</span>:<span style=color:#bbb> </span>IfNotPresent   <span style=color:#bbb> </span><span style=color:#080;font-style:italic># API 服务器所设默认值</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP      <span style=color:#bbb> </span><span style=color:#080;font-style:italic># API 服务器所设默认值</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>         </span><span style=color:#080;font-style:italic># API 服务器所设默认值</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>terminationMessagePath</span>:<span style=color:#bbb> </span>/dev/termination-log   <span style=color:#bbb> </span><span style=color:#080;font-style:italic># API 服务器所设默认值</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>dnsPolicy</span>:<span style=color:#bbb> </span>ClusterFirst      <span style=color:#bbb> </span><span style=color:#080;font-style:italic># API 服务器所设默认值</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Always        <span style=color:#bbb> </span><span style=color:#080;font-style:italic># API 服务器所设默认值</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>securityContext</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>           </span><span style=color:#080;font-style:italic># API 服务器所设默认值</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>terminationGracePeriodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>30</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># API 服务器所设默认值</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span></code></pre></div>
<p>在补丁请求中，已经设置了默认值的字段不会被重新设回其默认值，除非
在补丁请求中显式地要求清除。对于默认值取决于其他字段的某些字段而言，
这可能会引发一些意想不到的行为。当所依赖的其他字段后来发生改变时，
基于它们所设置的默认值只能在显式执行清除操作时才会被更新。</p>
<p>为此，建议在配置文件中为服务器设置默认值的字段显式提供定义，即使所
给的定义与服务器端默认值设定相同。这样可以使得辩识无法被服务器重新
基于默认值来设置的冲突字段变得容易。</p>
<p><strong>示例：</strong></p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#080;font-style:italic># last-applied-configuration</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.14.2<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># 配置文件</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>strategy</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Recreate  <span style=color:#bbb> </span><span style=color:#080;font-style:italic># 更新的值</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.14.2<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># 现时配置</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>strategy</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>RollingUpdate   <span style=color:#bbb> </span><span style=color:#080;font-style:italic># 默认设置的值</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>rollingUpdate</span>:<span style=color:#bbb>         </span><span style=color:#080;font-style:italic># 基于 type 设置的默认值</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>maxSurge </span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>maxUnavailable</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.14.2<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># 合并后的结果 - 出错！</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>strategy</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Recreate    <span style=color:#bbb> </span><span style=color:#080;font-style:italic># 更新的值：与 rollingUpdate 不兼容</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>rollingUpdate</span>:<span style=color:#bbb>     </span><span style=color:#080;font-style:italic># 默认设置的值：与 &#34;type: Recreate&#34; 冲突</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>maxSurge </span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>maxUnavailable</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.14.2<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></code></pre></div>
<p><strong>解释：</strong></p>
<ol>
<li>用户创建 Deployment，未设置 <code>strategy.type</code>。</li>
<li>服务器为 <code>strategy.type</code> 设置默认值 <code>RollingUpdate</code>，并为 <code>strategy.rollingUpdate</code>
设置默认值。</li>
<li>用户改变 <code>strategy.type</code> 为 <code>Recreate</code>。字段 <code>strategy.rollingUpdate</code> 仍会取其
默认设置值，尽管服务器期望该字段被清除。
如果 <code>strategy.rollingUpdate</code> 值最初于配置文件中定义，则它们需要被清除
这一点就更明确一些。</li>
<li><code>apply</code> 操作失败，因为 <code>strategy.rollingUpdate</code> 未被清除。
<code>strategy.rollingupdate</code> 在 <code>strategy.type</code> 为 <code>Recreate</code> 不可被设定。</li>
</ol>
<p>建议：以下字段应该在对象配置文件中显式定义：</p>
<ul>
<li>如 Deployment、StatefulSet、Job、DaemonSet、ReplicaSet 和 ReplicationController
这类负载的选择算符和 <code>PodTemplate</code> 标签</li>
<li>Deployment 的上线策略</li>
</ul>
<h3 id=如何清除服务器端按默认值设置的字段或者被其他写者设置的字段>如何清除服务器端按默认值设置的字段或者被其他写者设置的字段</h3>
<p>没有出现在配置文件中的字段可以通过将其值设置为 <code>null</code> 并应用配置文件来清除。
对于由服务器按默认值设置的字段，清除操作会触发重新为字段设置新的默认值。</p>
<h2 id=如何将字段的属主在配置文件和直接指令式写者之间切换>如何将字段的属主在配置文件和直接指令式写者之间切换</h2>
<p>更改某个对象字段时，应该采用下面的方法：</p>
<ul>
<li>使用 <code>kubectl apply</code>.</li>
<li>直接写入到现时配置，但不更改配置文件本身，例如使用 <code>kubectl scale</code>。</li>
</ul>
<h3 id=将属主从直接指令式写者更改为配置文件>将属主从直接指令式写者更改为配置文件</h3>
<p>将字段添加到配置文件。针对该字段，不再直接执行对现时配置的修改。
修改均通过 <code>kubectl apply</code> 来执行。</p>
<h3 id=将属主从配置文件改为直接指令式写者>将属主从配置文件改为直接指令式写者</h3>
<p>在 Kubernetes 1.5 中，将字段的属主从配置文件切换到某指令式写者需要手动
执行以下步骤：</p>
<ul>
<li>从配置文件中删除该字段；</li>
<li>将字段从现时对象的 <code>kubectl.kubernetes.io/last-applied-configuration</code> 注解
中删除。</li>
</ul>
<h2 id=changing-management-methods>更改管理方法 </h2>
<p>Kubernetes 对象在同一时刻应该只用一种方法来管理。
从一种方法切换到另一种方法是可能的，但这一切换是一个手动过程。</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 在声明式管理方法中使用指令式命令来删除对象是可以的。
</div>
<h3 id=从指令式命令管理切换到声明式对象配置>从指令式命令管理切换到声明式对象配置</h3>
<p>从指令式命令管理切换到声明式对象配置管理的切换包含以下几个手动步骤：</p>
<ol>
<li>
<p>将现时对象导出到本地配置文件：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get &lt;kind&gt;/&lt;name&gt; -o yaml &gt; &lt;kind&gt;_&lt;name&gt;.yaml
</code></pre></div></li>
<li>
<p>手动移除配置文件中的 <code>status</code> 字段。</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 这一步骤是可选的，因为 <code>kubectl apply</code> 并不会更新 status 字段，即便
配置文件中包含 status 字段。
</div>
</li>
<li>
<p>设置对象上的 <code>kubectl.kubernetes.io/last-applied-configuration</code> 注解：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl replace --save-config -f &lt;kind&gt;_&lt;name&gt;.yaml
</code></pre></div></li>
<li>
<p>更改过程，使用 <code>kubectl apply</code> 专门管理对象。</p>
</li>
</ol>
<h3 id=从指令式对象配置切换到声明式对象配置>从指令式对象配置切换到声明式对象配置</h3>
<ol>
<li>
<p>在对象上设置 <code>kubectl.kubernetes.io/last-applied-configuration</code> 注解：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl replace -save-config -f &lt;kind&gt;_&lt;name&gt;.yaml
</code></pre></div></li>
<li>
<p>自此排他性地使用 <code>kubectl apply</code> 来管理对象。</p>
</li>
</ol>
<h2 id=定义控制器选择算符和-podtemplate-标签>定义控制器选择算符和 PodTemplate 标签</h2>
<div class="alert alert-danger warning callout" role=alert>
<strong>Warning:</strong> 强烈不建议更改控制器上的选择算符。
</div>
<p>建议的方法是定义一个不可变更的 PodTemplate 标签，仅用于控制器选择算符且
不包含其他语义性的含义。</p>
<p><strong>示例：</strong></p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>controller-selector</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;apps/v1/deployment/nginx&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>controller-selector</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;apps/v1/deployment/nginx&#34;</span><span style=color:#bbb>
</span></code></pre></div><h2 id=what-s-next>What's next</h2>
<ul>
<li><a href=/zh/docs/tasks/manage-kubernetes-objects/imperative-command/>使用指令式命令管理 Kubernetes 对象</a></li>
<li><a href=/zh/docs/tasks/manage-kubernetes-objects/imperative-config/>使用配置文件对 Kubernetes 对象执行指令式管理</a></li>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands/>Kubectl 命令参考</a></li>
<li><a href=/docs/reference/generated/kubernetes-api/v1.23/>Kubernetes API 参考</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-11aa6950fcb203094823c8e2cbdd517f>6.2 - 使用 Kustomize 对 Kubernetes 对象进行声明式管理</h1>
<p><a href=https://github.com/kubernetes-sigs/kustomize>Kustomize</a> 是一个独立的工具，用来通过
<a href=https://kubectl.docs.kubernetes.io/references/kustomize/glossary/#kustomization>kustomization 文件</a>
定制 Kubernetes 对象。</p>
<p>从 1.14 版本开始，<code>kubectl</code> 也开始支持使用 kustomization 文件来管理 Kubernetes 对象。
要查看包含 kustomization 文件的目录中的资源，执行下面的命令：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl kustomize &lt;kustomization_directory&gt;
</code></pre></div>
<p>要应用这些资源，使用参数 <code>--kustomize</code> 或 <code>-k</code> 标志来执行 <code>kubectl apply</code>：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -k &lt;kustomization_directory&gt;
</code></pre></div><h2 id=before-you-begin>Before you begin</h2>
<p>安装 <a href=/zh/docs/tasks/tools/><code>kubectl</code></a>.</p>
<p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li>
</ul>
To check the version, enter <code>kubectl version</code>.
</p>
<h2 id=overview-of-kustomize>Kustomize 概述 </h2>
<p>Kustomize 是一个用来定制 Kubernetes 配置的工具。它提供以下功能特性来管理
应用配置文件：</p>
<ul>
<li>从其他来源生成资源</li>
<li>为资源设置贯穿性（Cross-Cutting）字段</li>
<li>组织和定制资源集合</li>
</ul>
<h3 id=generating-resources>生成资源 </h3>
<p>ConfigMap 和 Secret 包含其他 Kubernetes 对象（如 Pod）所需要的配置或敏感数据。
ConfigMap 或 Secret 中数据的来源往往是集群外部，例如某个 <code>.properties</code>
文件或者 SSH 密钥文件。
Kustomize 提供 <code>secretGenerator</code> 和 <code>configMapGenerator</code>，可以基于文件或字面
值来生成 Secret 和 ConfigMap。</p>
<h4 id=configmapgenerator>configMapGenerator</h4>
<p>要基于文件来生成 ConfigMap，可以在 <code>configMapGenerator</code> 的 <code>files</code>
列表中添加表项。
下面是一个根据 <code>.properties</code> 文件中的数据条目来生成 ConfigMap 的示例：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># 生成一个  application.properties 文件</span>
cat <span style=color:#b44>&lt;&lt;EOF &gt;application.properties
</span><span style=color:#b44>FOO=Bar
</span><span style=color:#b44>EOF</span>

cat <span style=color:#b44>&lt;&lt;EOF &gt;./kustomization.yaml
</span><span style=color:#b44>configMapGenerator:
</span><span style=color:#b44>- name: example-configmap-1
</span><span style=color:#b44>  files:
</span><span style=color:#b44>  - application.properties
</span><span style=color:#b44>EOF</span>
</code></pre></div>
<p>所生成的 ConfigMap 可以使用下面的命令来检查：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl kustomize ./
</code></pre></div>
<p>所生成的 ConfigMap 为：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>application.properties</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span><span style=color:#b44;font-style:italic>    </span><span style=color:#bbb>    </span>FOO=Bar<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>example-configmap-1-8mbdf7882g<span style=color:#bbb>
</span></code></pre></div>
<p>要从 env 文件生成 ConfigMap，请在 <code>configMapGenerator</code> 中的 <code>envs</code> 列表中添加一个条目。
这也可以用于通过省略 <code>=</code> 和值来设置本地环境变量的值。</p>
<p>建议谨慎使用本地环境变量填充功能 —— 用补丁覆盖通常更易于维护。
当无法轻松预测变量的值时，从环境中设置值可能很有用，例如 git SHA。</p>
<p>下面是一个用来自 <code>.env</code> 文件的数据生成 ConfigMap 的例子：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># 创建一个 .env 文件</span>
<span style=color:#080;font-style:italic># BAZ 将使用本地环境变量 $BAZ 的取值填充</span>
cat <span style=color:#b44>&lt;&lt;EOF &gt;.env
</span><span style=color:#b44>FOO=Bar
</span><span style=color:#b44>BAZ
</span><span style=color:#b44>EOF</span>

cat <span style=color:#b44>&lt;&lt;EOF &gt;./kustomization.yaml
</span><span style=color:#b44>configMapGenerator:
</span><span style=color:#b44>- name: example-configmap-1
</span><span style=color:#b44>  envs:
</span><span style=color:#b44>  - .env
</span><span style=color:#b44>EOF</span>
</code></pre></div>
<p>可以使用以下命令检查生成的 ConfigMap：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#b8860b>BAZ</span><span style=color:#666>=</span>Qux kubectl kustomize ./
</code></pre></div>
<p>生成的 ConfigMap 为：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>BAZ</span>:<span style=color:#bbb> </span>Qux<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>FOO</span>:<span style=color:#bbb> </span>Bar<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>example-configmap-1-892ghb99c8<span style=color:#bbb>
</span></code></pre></div>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> <code>.env</code> 文件中的每个变量在生成的 ConfigMap 中成为一个单独的键。
这与之前的示例不同，前一个示例将一个名为 <code>.properties</code> 的文件（及其所有条目）嵌入到同一个键的值中。
</div>
<p>ConfigMap 也可基于字面的键值偶对来生成。要基于键值偶对来生成 ConfigMap，
在 <code>configMapGenerator</code> 的 <code>literals</code> 列表中添加表项。下面是一个例子，展示
如何使用键值偶对中的数据条目来生成 ConfigMap 对象：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>cat <span style=color:#b44>&lt;&lt;EOF &gt;./kustomization.yaml
</span><span style=color:#b44>configMapGenerator:
</span><span style=color:#b44>- name: example-configmap-2
</span><span style=color:#b44>  literals:
</span><span style=color:#b44>  - FOO=Bar
</span><span style=color:#b44>EOF</span>
</code></pre></div>
<p>可以用下面的命令检查所生成的 ConfigMap：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl kustomize ./
</code></pre></div>
<p>所生成的 ConfigMap 为：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>FOO</span>:<span style=color:#bbb> </span>Bar<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>example-configmap-2-g2hdhfc6tk<span style=color:#bbb>
</span></code></pre></div>
<p>要在 Deployment 中使用生成的 ConfigMap，使用 configMapGenerator 的名称对其进行引用。
Kustomize 将自动使用生成的名称替换该名称。</p>
<p>这是使用生成的 ConfigMap 的 deployment 示例：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#080;font-style:italic># 创建一个 application.properties 文件</span><span style=color:#bbb>
</span><span style=color:#bbb></span>cat &lt;&lt;EOF &gt;application.properties<span style=color:#bbb>
</span><span style=color:#bbb></span>FOO=Bar<span style=color:#bbb>
</span><span style=color:#bbb></span>EOF<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb></span>cat &lt;&lt;EOF &gt;deployment.yaml<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-app<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>my-app<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>my-app<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>my-app<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>app<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>my-app<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>config<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/config<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>config<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>configMap</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>example-configmap-1<span style=color:#bbb>
</span><span style=color:#bbb></span>EOF<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb></span>cat &lt;&lt;EOF &gt;./kustomization.yaml<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- deployment.yaml<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>configMapGenerator</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>example-configmap-1<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>files</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- application.properties<span style=color:#bbb>
</span><span style=color:#bbb></span>EOF<span style=color:#bbb>
</span></code></pre></div>
<p>生成 ConfigMap 和 Deployment：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl kustomize ./
</code></pre></div>
<p>生成的 Deployment 将通过名称引用生成的 ConfigMap：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>application.properties</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span><span style=color:#b44;font-style:italic>    </span><span style=color:#bbb>    </span>FOO=Bar<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>example-configmap-1-g4hk9g2ff8<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>my-app<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-app<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>my-app<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>my-app<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>my-app<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>app<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/config<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>config<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>configMap</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>example-configmap-1-g4hk9g2ff8<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>config<span style=color:#bbb>
</span></code></pre></div><h4 id=secretgenerator>secretGenerator</h4>
<p>你可以基于文件或者键值偶对来生成 Secret。要使用文件内容来生成 Secret，
在 <code>secretGenerator</code> 下面的 <code>files</code> 列表中添加表项。
下面是一个根据文件中数据来生成 Secret 对象的示例：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># 创建一个 password.txt 文件</span>
cat <span style=color:#b44>&lt;&lt;EOF &gt;./password.txt
</span><span style=color:#b44>username=admin
</span><span style=color:#b44>password=secret
</span><span style=color:#b44>EOF</span>

cat <span style=color:#b44>&lt;&lt;EOF &gt;./kustomization.yaml
</span><span style=color:#b44>secretGenerator:
</span><span style=color:#b44>- name: example-secret-1
</span><span style=color:#b44>  files:
</span><span style=color:#b44>  - password.txt
</span><span style=color:#b44>EOF</span>
</code></pre></div>
<p>所生成的 Secret 如下：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>password.txt</span>:<span style=color:#bbb> </span>dXNlcm5hbWU9YWRtaW4KcGFzc3dvcmQ9c2VjcmV0Cg==<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>example-secret-1-t2kt65hgtb<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Opaque<span style=color:#bbb>
</span></code></pre></div>
<p>要基于键值偶对字面值生成 Secret，先要在 <code>secretGenerator</code> 的 <code>literals</code>
列表中添加表项。下面是基于键值偶对中数据条目来生成 Secret 的示例：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>cat <span style=color:#b44>&lt;&lt;EOF &gt;./kustomization.yaml
</span><span style=color:#b44>secretGenerator:
</span><span style=color:#b44>- name: example-secret-2
</span><span style=color:#b44>  literals:
</span><span style=color:#b44>  - username=admin
</span><span style=color:#b44>  - password=secret
</span><span style=color:#b44>EOF</span>
</code></pre></div>
<p>所生成的 Secret 如下：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>password</span>:<span style=color:#bbb> </span>c2VjcmV0<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>username</span>:<span style=color:#bbb> </span>YWRtaW4=<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>example-secret-2-t52t6g96d8<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Opaque<span style=color:#bbb>
</span></code></pre></div>
<p>与 ConfigMaps 一样，生成的 Secrets 可以通过引用 secretGenerator 的名称在部署中使用：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># 创建一个 password.txt 文件</span>
cat <span style=color:#b44>&lt;&lt;EOF &gt;./password.txt
</span><span style=color:#b44>username=admin
</span><span style=color:#b44>password=secret
</span><span style=color:#b44>EOF</span>

cat <span style=color:#b44>&lt;&lt;EOF &gt;deployment.yaml
</span><span style=color:#b44>apiVersion: apps/v1
</span><span style=color:#b44>kind: Deployment
</span><span style=color:#b44>metadata:
</span><span style=color:#b44>  name: my-app
</span><span style=color:#b44>  labels:
</span><span style=color:#b44>    app: my-app
</span><span style=color:#b44>spec:
</span><span style=color:#b44>  selector:
</span><span style=color:#b44>    matchLabels:
</span><span style=color:#b44>      app: my-app
</span><span style=color:#b44>  template:
</span><span style=color:#b44>    metadata:
</span><span style=color:#b44>      labels:
</span><span style=color:#b44>        app: my-app
</span><span style=color:#b44>    spec:
</span><span style=color:#b44>      containers:
</span><span style=color:#b44>      - name: app
</span><span style=color:#b44>        image: my-app
</span><span style=color:#b44>        volumeMounts:
</span><span style=color:#b44>        - name: password
</span><span style=color:#b44>          mountPath: /secrets
</span><span style=color:#b44>      volumes:
</span><span style=color:#b44>      - name: password
</span><span style=color:#b44>        secret:
</span><span style=color:#b44>          secretName: example-secret-1
</span><span style=color:#b44>EOF</span>

cat <span style=color:#b44>&lt;&lt;EOF &gt;./kustomization.yaml
</span><span style=color:#b44>resources:
</span><span style=color:#b44>- deployment.yaml
</span><span style=color:#b44>secretGenerator:
</span><span style=color:#b44>- name: example-secret-1
</span><span style=color:#b44>  files:
</span><span style=color:#b44>  - password.txt
</span><span style=color:#b44>EOF</span>
</code></pre></div><h4 id=generatoroptions>generatorOptions</h4>
<p>所生成的 ConfigMap 和 Secret 都会包含内容哈希值后缀。
这是为了确保内容发生变化时，所生成的是新的 ConfigMap 或 Secret。
要禁止自动添加后缀的行为，用户可以使用 <code>generatorOptions</code>。
除此以外，为生成的 ConfigMap 和 Secret 指定贯穿性选项也是可以的。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>cat <span style=color:#b44>&lt;&lt;EOF &gt;./kustomization.yaml
</span><span style=color:#b44>configMapGenerator:
</span><span style=color:#b44>- name: example-configmap-3
</span><span style=color:#b44>  literals:
</span><span style=color:#b44>  - FOO=Bar
</span><span style=color:#b44>generatorOptions:
</span><span style=color:#b44>  disableNameSuffixHash: true
</span><span style=color:#b44>  labels:
</span><span style=color:#b44>    type: generated
</span><span style=color:#b44>  annotations:
</span><span style=color:#b44>    note: generated
</span><span style=color:#b44>EOF</span>
</code></pre></div>
<p>运行 <code>kubectl kustomize ./</code> 来查看所生成的 ConfigMap：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>FOO</span>:<span style=color:#bbb> </span>Bar<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>note</span>:<span style=color:#bbb> </span>generated<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>generated<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>example-configmap-3<span style=color:#bbb>
</span></code></pre></div>
<h3 id=setting-cross-cutting-fields>设置贯穿性字段 </h3>
<p>在项目中为所有 Kubernetes 对象设置贯穿性字段是一种常见操作。
贯穿性字段的一些使用场景如下：</p>
<ul>
<li>为所有资源设置相同的名字空间</li>
<li>为所有对象添加相同的前缀或后缀</li>
<li>为对象添加相同的标签集合</li>
<li>为对象添加相同的注解集合</li>
</ul>
<p>下面是一个例子：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># 创建一个 deployment.yaml</span>
cat <span style=color:#b44>&lt;&lt;EOF &gt;./deployment.yaml
</span><span style=color:#b44>apiVersion: apps/v1
</span><span style=color:#b44>kind: Deployment
</span><span style=color:#b44>metadata:
</span><span style=color:#b44>  name: nginx-deployment
</span><span style=color:#b44>  labels:
</span><span style=color:#b44>    app: nginx
</span><span style=color:#b44>spec:
</span><span style=color:#b44>  selector:
</span><span style=color:#b44>    matchLabels:
</span><span style=color:#b44>      app: nginx
</span><span style=color:#b44>  template:
</span><span style=color:#b44>    metadata:
</span><span style=color:#b44>      labels:
</span><span style=color:#b44>        app: nginx
</span><span style=color:#b44>    spec:
</span><span style=color:#b44>      containers:
</span><span style=color:#b44>      - name: nginx
</span><span style=color:#b44>        image: nginx
</span><span style=color:#b44>EOF</span>

cat <span style=color:#b44>&lt;&lt;EOF &gt;./kustomization.yaml
</span><span style=color:#b44>namespace: my-namespace
</span><span style=color:#b44>namePrefix: dev-
</span><span style=color:#b44>nameSuffix: &#34;-001&#34;
</span><span style=color:#b44>commonLabels:
</span><span style=color:#b44>  app: bingo
</span><span style=color:#b44>commonAnnotations:
</span><span style=color:#b44>  oncallPager: 800-555-1212
</span><span style=color:#b44>resources:
</span><span style=color:#b44>- deployment.yaml
</span><span style=color:#b44>EOF</span>
</code></pre></div>
<p>执行 <code>kubectl kustomize ./</code> 查看这些字段都被设置到 Deployment 资源上：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>oncallPager</span>:<span style=color:#bbb> </span><span style=color:#666>800-555-1212</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>bingo<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>dev-nginx-deployment-001<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>my-namespace<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>bingo<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>oncallPager</span>:<span style=color:#bbb> </span><span style=color:#666>800-555-1212</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>bingo<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></code></pre></div>
<h3 id=composing-and-customizing-resources>组织和定制资源 </h3>
<p>一种常见的做法是在项目中构造资源集合并将其放到同一个文件或目录中管理。
Kustomize 提供基于不同文件来组织资源并向其应用补丁或者其他定制的能力。</p>
<h4 id=composing>组织 </h4>
<p>Kustomize 支持组合不同的资源。<code>kustomization.yaml</code> 文件的 <code>resources</code> 字段
定义配置中要包含的资源列表。你可以将 <code>resources</code> 列表中的路径设置为资源配置文件
的路径。下面是由 Deployment 和 Service 构成的 NGINX 应用的示例：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># 创建 deployment.yaml 文件</span>
cat <span style=color:#b44>&lt;&lt;EOF &gt; deployment.yaml
</span><span style=color:#b44>apiVersion: apps/v1
</span><span style=color:#b44>kind: Deployment
</span><span style=color:#b44>metadata:
</span><span style=color:#b44>  name: my-nginx
</span><span style=color:#b44>spec:
</span><span style=color:#b44>  selector:
</span><span style=color:#b44>    matchLabels:
</span><span style=color:#b44>      run: my-nginx
</span><span style=color:#b44>  replicas: 2
</span><span style=color:#b44>  template:
</span><span style=color:#b44>    metadata:
</span><span style=color:#b44>      labels:
</span><span style=color:#b44>        run: my-nginx
</span><span style=color:#b44>    spec:
</span><span style=color:#b44>      containers:
</span><span style=color:#b44>      - name: my-nginx
</span><span style=color:#b44>        image: nginx
</span><span style=color:#b44>        ports:
</span><span style=color:#b44>        - containerPort: 80
</span><span style=color:#b44>EOF</span>

<span style=color:#080;font-style:italic># 创建 service.yaml 文件</span>
cat <span style=color:#b44>&lt;&lt;EOF &gt; service.yaml
</span><span style=color:#b44>apiVersion: v1
</span><span style=color:#b44>kind: Service
</span><span style=color:#b44>metadata:
</span><span style=color:#b44>  name: my-nginx
</span><span style=color:#b44>  labels:
</span><span style=color:#b44>    run: my-nginx
</span><span style=color:#b44>spec:
</span><span style=color:#b44>  ports:
</span><span style=color:#b44>  - port: 80
</span><span style=color:#b44>    protocol: TCP
</span><span style=color:#b44>  selector:
</span><span style=color:#b44>    run: my-nginx
</span><span style=color:#b44>EOF</span>

<span style=color:#080;font-style:italic># 创建 kustomization.yaml 来组织以上两个资源</span>
cat <span style=color:#b44>&lt;&lt;EOF &gt;./kustomization.yaml
</span><span style=color:#b44>resources:
</span><span style=color:#b44>- deployment.yaml
</span><span style=color:#b44>- service.yaml
</span><span style=color:#b44>EOF</span>
</code></pre></div>
<p><code>kubectl kustomize ./</code> 所得到的资源中既包含 Deployment 也包含 Service 对象。</p>
<h4 id=customizing>定制 </h4>
<p>补丁文件（Patches）可以用来对资源执行不同的定制。
Kustomize 通过 <code>patchesStrategicMerge</code> 和 <code>patchesJson6902</code> 支持不同的打补丁
机制。<code>patchesStrategicMerge</code> 的内容是一个文件路径的列表，其中每个文件都应可解析为
<a href=https://github.com/kubernetes/community/blob/master/contributors/devel/sig-api-machinery/strategic-merge-patch.md>策略性合并补丁（Strategic Merge Patch）</a>。
补丁文件中的名称必须与已经加载的资源的名称匹配。
建议构造规模较小的、仅做一件事情的补丁。
例如，构造一个补丁来增加 Deployment
的副本个数；构造另外一个补丁来设置内存限制。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># 创建 deployment.yaml 文件</span>
cat <span style=color:#b44>&lt;&lt;EOF &gt; deployment.yaml
</span><span style=color:#b44>apiVersion: apps/v1
</span><span style=color:#b44>kind: Deployment
</span><span style=color:#b44>metadata:
</span><span style=color:#b44>  name: my-nginx
</span><span style=color:#b44>spec:
</span><span style=color:#b44>  selector:
</span><span style=color:#b44>    matchLabels:
</span><span style=color:#b44>      run: my-nginx
</span><span style=color:#b44>  replicas: 2
</span><span style=color:#b44>  template:
</span><span style=color:#b44>    metadata:
</span><span style=color:#b44>      labels:
</span><span style=color:#b44>        run: my-nginx
</span><span style=color:#b44>    spec:
</span><span style=color:#b44>      containers:
</span><span style=color:#b44>      - name: my-nginx
</span><span style=color:#b44>        image: nginx
</span><span style=color:#b44>        ports:
</span><span style=color:#b44>        - containerPort: 80
</span><span style=color:#b44>EOF</span>

<span style=color:#080;font-style:italic># 生成一个补丁 increase_replicas.yaml</span>
cat <span style=color:#b44>&lt;&lt;EOF &gt; increase_replicas.yaml
</span><span style=color:#b44>apiVersion: apps/v1
</span><span style=color:#b44>kind: Deployment
</span><span style=color:#b44>metadata:
</span><span style=color:#b44>  name: my-nginx
</span><span style=color:#b44>spec:
</span><span style=color:#b44>  replicas: 3
</span><span style=color:#b44>EOF</span>

<span style=color:#080;font-style:italic># 生成另一个补丁 set_memory.yaml</span>
cat <span style=color:#b44>&lt;&lt;EOF &gt; set_memory.yaml
</span><span style=color:#b44>apiVersion: apps/v1
</span><span style=color:#b44>kind: Deployment
</span><span style=color:#b44>metadata:
</span><span style=color:#b44>  name: my-nginx
</span><span style=color:#b44>spec:
</span><span style=color:#b44>  template:
</span><span style=color:#b44>    spec:
</span><span style=color:#b44>      containers:
</span><span style=color:#b44>      - name: my-nginx
</span><span style=color:#b44>        resources:
</span><span style=color:#b44>          limits:
</span><span style=color:#b44>            memory: 512Mi
</span><span style=color:#b44>EOF</span>

cat <span style=color:#b44>&lt;&lt;EOF &gt;./kustomization.yaml
</span><span style=color:#b44>resources:
</span><span style=color:#b44>- deployment.yaml
</span><span style=color:#b44>patchesStrategicMerge:
</span><span style=color:#b44>- increase_replicas.yaml
</span><span style=color:#b44>- set_memory.yaml
</span><span style=color:#b44>EOF</span>
</code></pre></div>
<p>执行 <code>kubectl kustomize ./</code> 来查看 Deployment：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-nginx<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>run</span>:<span style=color:#bbb> </span>my-nginx<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>run</span>:<span style=color:#bbb> </span>my-nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-nginx<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>512Mi<span style=color:#bbb>
</span></code></pre></div>
<p>并非所有资源或者字段都支持策略性合并补丁。为了支持对任何资源的任何字段进行修改，
Kustomize 提供通过 <code>patchesJson6902</code> 来应用 <a href=https://tools.ietf.org/html/rfc6902>JSON 补丁</a>
的能力。为了给 JSON 补丁找到正确的资源，需要在 <code>kustomization.yaml</code> 文件中指定资源的
组（group）、版本（version）、类别（kind）和名称（name）。
例如，为某 Deployment 对象增加副本个数的操作也可以通过 <code>patchesJson6902</code>
来完成：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># 创建一个 deployment.yaml 文件</span>
cat <span style=color:#b44>&lt;&lt;EOF &gt; deployment.yaml
</span><span style=color:#b44>apiVersion: apps/v1
</span><span style=color:#b44>kind: Deployment
</span><span style=color:#b44>metadata:
</span><span style=color:#b44>  name: my-nginx
</span><span style=color:#b44>spec:
</span><span style=color:#b44>  selector:
</span><span style=color:#b44>    matchLabels:
</span><span style=color:#b44>      run: my-nginx
</span><span style=color:#b44>  replicas: 2
</span><span style=color:#b44>  template:
</span><span style=color:#b44>    metadata:
</span><span style=color:#b44>      labels:
</span><span style=color:#b44>        run: my-nginx
</span><span style=color:#b44>    spec:
</span><span style=color:#b44>      containers:
</span><span style=color:#b44>      - name: my-nginx
</span><span style=color:#b44>        image: nginx
</span><span style=color:#b44>        ports:
</span><span style=color:#b44>        - containerPort: 80
</span><span style=color:#b44>EOF</span>

<span style=color:#080;font-style:italic># 创建一个 JSON 补丁文件</span>
cat <span style=color:#b44>&lt;&lt;EOF &gt; patch.yaml
</span><span style=color:#b44>- op: replace
</span><span style=color:#b44>  path: /spec/replicas
</span><span style=color:#b44>  value: 3
</span><span style=color:#b44>EOF</span>

<span style=color:#080;font-style:italic># 创建一个 kustomization.yaml</span>
cat <span style=color:#b44>&lt;&lt;EOF &gt;./kustomization.yaml
</span><span style=color:#b44>resources:
</span><span style=color:#b44>- deployment.yaml
</span><span style=color:#b44>
</span><span style=color:#b44>patchesJson6902:
</span><span style=color:#b44>- target:
</span><span style=color:#b44>    group: apps
</span><span style=color:#b44>    version: v1
</span><span style=color:#b44>    kind: Deployment
</span><span style=color:#b44>    name: my-nginx
</span><span style=color:#b44>  path: patch.yaml
</span><span style=color:#b44>EOF</span>
</code></pre></div>
<p>执行 <code>kubectl kustomize ./</code> 以查看 <code>replicas</code> 字段被更新：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-nginx<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>run</span>:<span style=color:#bbb> </span>my-nginx<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>run</span>:<span style=color:#bbb> </span>my-nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-nginx<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></code></pre></div>
<p>除了补丁之外，Kustomize 还提供定制容器镜像或者将其他对象的字段值注入到容器
中的能力，并且不需要创建补丁。
例如，你可以通过在 <code>kustomization.yaml</code> 文件的 <code>images</code> 字段设置新的镜像来
更改容器中使用的镜像。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>cat <span style=color:#b44>&lt;&lt;EOF &gt; deployment.yaml
</span><span style=color:#b44>apiVersion: apps/v1
</span><span style=color:#b44>kind: Deployment
</span><span style=color:#b44>metadata:
</span><span style=color:#b44>  name: my-nginx
</span><span style=color:#b44>spec:
</span><span style=color:#b44>  selector:
</span><span style=color:#b44>    matchLabels:
</span><span style=color:#b44>      run: my-nginx
</span><span style=color:#b44>  replicas: 2
</span><span style=color:#b44>  template:
</span><span style=color:#b44>    metadata:
</span><span style=color:#b44>      labels:
</span><span style=color:#b44>        run: my-nginx
</span><span style=color:#b44>    spec:
</span><span style=color:#b44>      containers:
</span><span style=color:#b44>      - name: my-nginx
</span><span style=color:#b44>        image: nginx
</span><span style=color:#b44>        ports:
</span><span style=color:#b44>        - containerPort: 80
</span><span style=color:#b44>EOF</span>

cat <span style=color:#b44>&lt;&lt;EOF &gt;./kustomization.yaml
</span><span style=color:#b44>resources:
</span><span style=color:#b44>- deployment.yaml
</span><span style=color:#b44>images:
</span><span style=color:#b44>- name: nginx
</span><span style=color:#b44>  newName: my.image.registry/nginx
</span><span style=color:#b44>  newTag: 1.4.0
</span><span style=color:#b44>EOF</span>
</code></pre></div>
<p>执行 <code>kubectl kustomize ./</code> 以查看所使用的镜像已被更新：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-nginx<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>2</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>run</span>:<span style=color:#bbb> </span>my-nginx<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>run</span>:<span style=color:#bbb> </span>my-nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>my.image.registry/nginx:1.4.0<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-nginx<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></code></pre></div>
<p>有些时候，Pod 中运行的应用可能需要使用来自其他对象的配置值。
例如，某 Deployment 对象的 Pod 需要从环境变量或命令行参数中读取读取
Service 的名称。
由于在 <code>kustomization.yaml</code> 文件中添加 <code>namePrefix</code> 或 <code>nameSuffix</code> 时
Service 名称可能发生变化，建议不要在命令参数中硬编码 Service 名称。
对于这种使用场景，Kustomize 可以通过 <code>vars</code> 将 Service 名称注入到容器中。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># 创建一个 deployment.yaml 文件（引用此处的文档分隔符）</span>
cat <span style=color:#b44>&lt;&lt;&#39;EOF&#39; &gt; deployment.yaml
</span><span style=color:#b44>apiVersion: apps/v1
</span><span style=color:#b44>kind: Deployment
</span><span style=color:#b44>metadata:
</span><span style=color:#b44>  name: my-nginx
</span><span style=color:#b44>spec:
</span><span style=color:#b44>  selector:
</span><span style=color:#b44>    matchLabels:
</span><span style=color:#b44>      run: my-nginx
</span><span style=color:#b44>  replicas: 2
</span><span style=color:#b44>  template:
</span><span style=color:#b44>    metadata:
</span><span style=color:#b44>      labels:
</span><span style=color:#b44>        run: my-nginx
</span><span style=color:#b44>    spec:
</span><span style=color:#b44>      containers:
</span><span style=color:#b44>      - name: my-nginx
</span><span style=color:#b44>        image: nginx
</span><span style=color:#b44>        command: [&#34;start&#34;, &#34;--host&#34;, &#34;$(MY_SERVICE_NAME)&#34;]
</span><span style=color:#b44>EOF</span>

<span style=color:#080;font-style:italic># 创建一个 service.yaml 文件</span>
cat <span style=color:#b44>&lt;&lt;EOF &gt; service.yaml
</span><span style=color:#b44>apiVersion: v1
</span><span style=color:#b44>kind: Service
</span><span style=color:#b44>metadata:
</span><span style=color:#b44>  name: my-nginx
</span><span style=color:#b44>  labels:
</span><span style=color:#b44>    run: my-nginx
</span><span style=color:#b44>spec:
</span><span style=color:#b44>  ports:
</span><span style=color:#b44>  - port: 80
</span><span style=color:#b44>    protocol: TCP
</span><span style=color:#b44>  selector:
</span><span style=color:#b44>    run: my-nginx
</span><span style=color:#b44>EOF</span>

cat <span style=color:#b44>&lt;&lt;EOF &gt;./kustomization.yaml
</span><span style=color:#b44>namePrefix: dev-
</span><span style=color:#b44>nameSuffix: &#34;-001&#34;
</span><span style=color:#b44>
</span><span style=color:#b44>resources:
</span><span style=color:#b44>- deployment.yaml
</span><span style=color:#b44>- service.yaml
</span><span style=color:#b44>
</span><span style=color:#b44>vars:
</span><span style=color:#b44>- name: MY_SERVICE_NAME
</span><span style=color:#b44>  objref:
</span><span style=color:#b44>    kind: Service
</span><span style=color:#b44>    name: my-nginx
</span><span style=color:#b44>    apiVersion: v1
</span><span style=color:#b44>EOF</span>
</code></pre></div>
<p>执行 <code>kubectl kustomize ./</code> 以查看注入到容器中的 Service 名称是 <code>dev-my-nginx-001</code>：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>dev-my-nginx-001<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>2</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>run</span>:<span style=color:#bbb> </span>my-nginx<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>run</span>:<span style=color:#bbb> </span>my-nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>command</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- start<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- --host<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- dev-my-nginx-001<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-nginx<span style=color:#bbb>
</span></code></pre></div>
<h2 id=基准-bases-与覆盖-overlays>基准（Bases）与覆盖（Overlays）</h2>
<p>Kustomize 中有 <strong>基准（bases）</strong> 和 <strong>覆盖（overlays）</strong> 的概念区分。
<strong>基准</strong> 是包含 <code>kustomization.yaml</code> 文件的一个目录，其中包含一组资源及其相关的定制。
基准可以是本地目录或者来自远程仓库的目录，只要其中存在 <code>kustomization.yaml</code> 文件即可。
<strong>覆盖</strong> 也是一个目录，其中包含将其他 kustomization 目录当做 <code>bases</code> 来引用的
<code>kustomization.yaml</code> 文件。
<strong>基准</strong>不了解覆盖的存在，且可被多个覆盖所使用。
覆盖则可以有多个基准，且可针对所有基准中的资源执行组织操作，还可以在其上执行定制。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># 创建一个包含基准的目录 </span>
mkdir base
<span style=color:#080;font-style:italic># 创建 base/deployment.yaml</span>
cat <span style=color:#b44>&lt;&lt;EOF &gt; base/deployment.yaml
</span><span style=color:#b44>apiVersion: apps/v1
</span><span style=color:#b44>kind: Deployment
</span><span style=color:#b44>metadata:
</span><span style=color:#b44>  name: my-nginx
</span><span style=color:#b44>spec:
</span><span style=color:#b44>  selector:
</span><span style=color:#b44>    matchLabels:
</span><span style=color:#b44>      run: my-nginx
</span><span style=color:#b44>  replicas: 2
</span><span style=color:#b44>  template:
</span><span style=color:#b44>    metadata:
</span><span style=color:#b44>      labels:
</span><span style=color:#b44>        run: my-nginx
</span><span style=color:#b44>    spec:
</span><span style=color:#b44>      containers:
</span><span style=color:#b44>      - name: my-nginx
</span><span style=color:#b44>        image: nginx
</span><span style=color:#b44>EOF</span>

<span style=color:#080;font-style:italic># 创建 base/service.yaml 文件</span>
cat <span style=color:#b44>&lt;&lt;EOF &gt; base/service.yaml
</span><span style=color:#b44>apiVersion: v1
</span><span style=color:#b44>kind: Service
</span><span style=color:#b44>metadata:
</span><span style=color:#b44>  name: my-nginx
</span><span style=color:#b44>  labels:
</span><span style=color:#b44>    run: my-nginx
</span><span style=color:#b44>spec:
</span><span style=color:#b44>  ports:
</span><span style=color:#b44>  - port: 80
</span><span style=color:#b44>    protocol: TCP
</span><span style=color:#b44>  selector:
</span><span style=color:#b44>    run: my-nginx
</span><span style=color:#b44>EOF</span>

<span style=color:#080;font-style:italic># 创建 base/kustomization.yaml</span>
cat <span style=color:#b44>&lt;&lt;EOF &gt; base/kustomization.yaml
</span><span style=color:#b44>resources:
</span><span style=color:#b44>- deployment.yaml
</span><span style=color:#b44>- service.yaml
</span><span style=color:#b44>EOF</span>
</code></pre></div>
<p>此基准可在多个覆盖中使用。你可以在不同的覆盖中添加不同的 <code>namePrefix</code> 或
其他贯穿性字段。下面是两个使用同一基准的覆盖：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>mkdir dev
cat <span style=color:#b44>&lt;&lt;EOF &gt; dev/kustomization.yaml
</span><span style=color:#b44>bases:
</span><span style=color:#b44>- ../base
</span><span style=color:#b44>namePrefix: dev-
</span><span style=color:#b44>EOF</span>

mkdir prod
cat <span style=color:#b44>&lt;&lt;EOF &gt; prod/kustomization.yaml
</span><span style=color:#b44>bases:
</span><span style=color:#b44>- ../base
</span><span style=color:#b44>namePrefix: prod-
</span><span style=color:#b44>EOF</span>
</code></pre></div>
<h2 id=如何使用-kustomize-来应用-查看和删除对象>如何使用 Kustomize 来应用、查看和删除对象</h2>
<p>在 <code>kubectl</code> 命令中使用 <code>--kustomize</code> 或 <code>-k</code> 参数来识别被 <code>kustomization.yaml</code> 所管理的资源。
注意 <code>-k</code> 要指向一个 kustomization 目录。例如：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -k &lt;kustomization 目录&gt;/
</code></pre></div>
<p>假定使用下面的 <code>kustomization.yaml</code>，</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># 创建 deployment.yaml 文件</span>
cat <span style=color:#b44>&lt;&lt;EOF &gt; deployment.yaml
</span><span style=color:#b44>apiVersion: apps/v1
</span><span style=color:#b44>kind: Deployment
</span><span style=color:#b44>metadata:
</span><span style=color:#b44>  name: my-nginx
</span><span style=color:#b44>spec:
</span><span style=color:#b44>  selector:
</span><span style=color:#b44>    matchLabels:
</span><span style=color:#b44>      run: my-nginx
</span><span style=color:#b44>  replicas: 2
</span><span style=color:#b44>  template:
</span><span style=color:#b44>    metadata:
</span><span style=color:#b44>      labels:
</span><span style=color:#b44>        run: my-nginx
</span><span style=color:#b44>    spec:
</span><span style=color:#b44>      containers:
</span><span style=color:#b44>      - name: my-nginx
</span><span style=color:#b44>        image: nginx
</span><span style=color:#b44>        ports:
</span><span style=color:#b44>        - containerPort: 80
</span><span style=color:#b44>EOF</span>

<span style=color:#080;font-style:italic># 创建 kustomization.yaml</span>
cat <span style=color:#b44>&lt;&lt;EOF &gt;./kustomization.yaml
</span><span style=color:#b44>namePrefix: dev-
</span><span style=color:#b44>commonLabels:
</span><span style=color:#b44>  app: my-nginx
</span><span style=color:#b44>resources:
</span><span style=color:#b44>- deployment.yaml
</span><span style=color:#b44>EOF</span>
</code></pre></div>
<p>执行下面的命令来应用 Deployment 对象 <code>dev-my-nginx</code>：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -k ./
</code></pre></div><pre><code>deployment.apps/dev-my-nginx created
</code></pre>
<p>运行下面的命令之一来查看 Deployment 对象 <code>dev-my-nginx</code>：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get -k ./
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe -k ./
</code></pre></div>
<p>执行下面的命令来比较 Deployment 对象 <code>dev-my-nginx</code> 与清单被应用之后
集群将处于的状态：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl diff -k ./
</code></pre></div>
<p>执行下面的命令删除 Deployment 对象 <code>dev-my-nginx</code>：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete -k ./
</code></pre></div><pre><code>deployment.apps &quot;dev-my-nginx&quot; deleted
</code></pre>
<h2 id=kustomize-功能特性列表>Kustomize 功能特性列表</h2>
<table>
<thead>
<tr>
<th>字段</th>
<th>类型</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>namespace</td>
<td>string</td>
<td>为所有资源添加名字空间</td>
</tr>
<tr>
<td>namePrefix</td>
<td>string</td>
<td>此字段的值将被添加到所有资源名称前面</td>
</tr>
<tr>
<td>nameSuffix</td>
<td>string</td>
<td>此字段的值将被添加到所有资源名称后面</td>
</tr>
<tr>
<td>commonLabels</td>
<td>map[string]string</td>
<td>要添加到所有资源和选择算符的标签</td>
</tr>
<tr>
<td>commonAnnotations</td>
<td>map[string]string</td>
<td>要添加到所有资源的注解</td>
</tr>
<tr>
<td>resources</td>
<td>[]string</td>
<td>列表中的每个条目都必须能够解析为现有的资源配置文件</td>
</tr>
<tr>
<td>configMapGenerator</td>
<td>[]<a href=https://github.com/kubernetes-sigs/kustomize/blob/master/api/types/configmapargs.go#L7>ConfigMapArgs</a></td>
<td>列表中的每个条目都会生成一个 ConfigMap</td>
</tr>
<tr>
<td>secretGenerator</td>
<td>[]<a href=https://github.com/kubernetes-sigs/kustomize/blob/master/api/types/secretargs.go#L7>SecretArgs</a></td>
<td>列表中的每个条目都会生成一个 Secret</td>
</tr>
<tr>
<td>generatorOptions</td>
<td><a href=https://github.com/kubernetes-sigs/kustomize/blob/master/api/types/generatoroptions.go#L7>GeneratorOptions</a></td>
<td>更改所有 ConfigMap 和 Secret 生成器的行为</td>
</tr>
<tr>
<td>bases</td>
<td>[]string</td>
<td>列表中每个条目都应能解析为一个包含 kustomization.yaml 文件的目录</td>
</tr>
<tr>
<td>patchesStrategicMerge</td>
<td>[]string</td>
<td>列表中每个条目都能解析为某 Kubernetes 对象的策略性合并补丁</td>
</tr>
<tr>
<td>patchesJson6902</td>
<td>[]<a href=https://github.com/kubernetes-sigs/kustomize/blob/master/api/types/patch.go#L10>Patch</a></td>
<td>列表中每个条目都能解析为一个 Kubernetes 对象和一个 JSON 补丁</td>
</tr>
<tr>
<td>vars</td>
<td>[]<a href=https://github.com/kubernetes-sigs/kustomize/blob/master/api/types/var.go#L19>Var</a></td>
<td>每个条目用来从某资源的字段来析取文字</td>
</tr>
<tr>
<td>images</td>
<td>[]<a href=https://github.com/kubernetes-sigs/kustomize/blob/master/api/types/image.go#L8>Image</a></td>
<td>每个条目都用来更改镜像的名称、标记与/或摘要，不必生成补丁</td>
</tr>
<tr>
<td>configurations</td>
<td>[]string</td>
<td>列表中每个条目都应能解析为一个包含 <a href=https://github.com/kubernetes-sigs/kustomize/tree/master/examples/transformerconfigs>Kustomize 转换器配置</a> 的文件</td>
</tr>
<tr>
<td>crds</td>
<td>[]string</td>
<td>列表中每个条目都赢能够解析为 Kubernetes 类别的 OpenAPI 定义文件</td>
</tr>
</tbody>
</table>
<h2 id=what-s-next>What's next</h2>
<ul>
<li><a href=https://github.com/kubernetes-sigs/kustomize>Kustomize</a></li>
<li><a href=https://kubectl.docs.kubernetes.io>Kubectl Book</a></li>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands/>Kubectl 命令参考</a></li>
<li><a href=/docs/reference/generated/kubernetes-api/v1.23/>Kubernetes API 参考</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-80c83fe9b80d0fef2681c8d59c0aa197>6.3 - 使用指令式命令管理 Kubernetes 对象</h1>
<p>使用构建在 <code>kubectl</code> 命令行工具中的指令式命令可以直接快速创建、更新和删除
Kubernetes 对象。本文档解释这些命令的组织方式以及如何使用它们来管理现时对象。</p>
<h2 id=before-you-begin>Before you begin</h2>
<p>安装<a href=/zh/docs/tasks/tools/><code>kubectl</code></a>。</p>
<p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li>
</ul>
To check the version, enter <code>kubectl version</code>.
</p>
<h2 id=trade-offs>权衡取舍 </h2>
<p><code>kubectl</code> 工具能够支持三种对象管理方式：</p>
<ul>
<li>指令式命令</li>
<li>指令式对象配置</li>
<li>声明式对象配置</li>
</ul>
<p>关于每种对象管理的优缺点的讨论，可参见
<a href=/zh/docs/concepts/overview/working-with-objects/object-management/>Kubernetes 对象管理</a>。</p>
<h2 id=how-to-create-objects>如何创建对象 </h2>
<p><code>kubectl</code> 工具支持动词驱动的命令，用来创建一些最常见的对象类别。
命令的名称设计使得不熟悉 Kubernetes 对象类型的用户也能做出判断。</p>
<ul>
<li><code>run</code>：创建一个新的 Pod 来运行一个容器。</li>
<li><code>expose</code>：创建一个新的 Service 对象为若干 Pod 提供流量负载均衡。</li>
<li><code>autoscale</code>：创建一个新的 Autoscaler 对象来自动对某控制器（如 Deployment）
执行水平扩缩。</li>
</ul>
<p><code>kubectl</code> 命令也支持一些对象类型驱动的创建命令。
这些命令可以支持更多的对象类别，并且在其动机上体现得更为明显，不过要求
用户了解它们所要创建的对象的类别。</p>
<ul>
<li><code>create &lt;对象类别> [&lt;子类别>] &lt;实例名称></code></li>
</ul>
<p>某些对象类别拥有自己的子类别，可以在 <code>create</code> 命令中设置。
例如，Service 对象有 ClusterIP、LoadBalancer 和 NodePort 三种子类别。
下面是一个创建 NodePort 子类别的 Service 的示例：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create service nodeport &lt;服务名称&gt;
</code></pre></div>
<p>在前述示例中，<code>create service nodeport</code> 命令也称作 <code>create service</code>
命令的子命令。
可以使用 <code>-h</code> 标志找到一个子命令所支持的参数和标志。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create service nodeport -h
</code></pre></div>
<h2 id=how-to-update-objects>如何更新对象 </h2>
<p><code>kubectl</code> 命令也支持一些动词驱动的命令，用来执行一些常见的更新操作。
这些命令的设计是为了让一些不了解 Kubernetes 对象的用户也能执行更新操作，
但不需要了解哪些字段必须设置：</p>
<ul>
<li><code>scale</code>：对某控制器进行水平扩缩以便通过更新控制器的副本个数来添加或删除 Pod。</li>
<li><code>annotate</code>：为对象添加或删除注解。</li>
<li><code>label</code>：为对象添加或删除标签。</li>
</ul>
<p><code>kubectl</code> 命令也支持由对象的某一方面来驱动的更新命令。
设置对象的这一方面可能对不同类别的对象意味着不同的字段：</p>
<ul>
<li><code>set &lt;字段></code>：设置对象的某一方面。</li>
</ul>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 在 Kubernetes 1.5 版本中，并非所有动词驱动的命令都有对应的方面驱动的命令。
</div>
<p><code>kubectl</code> 工具支持以下额外的方式用来直接更新现时对象，不过这些操作要求
用户对 Kubernetes 对象的模式定义有很好的了解：</p>
<ul>
<li><code>edit</code>：通过在编辑器中打开现时对象的配置，直接编辑其原始配置。</li>
<li><code>patch</code>：通过使用补丁字符串（Patch String）直接更改某现时对象的的特定字段。
关于补丁字符串的更详细信息，参见
<a href=https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#patch-operations>API 约定</a>
的 patch 节。</li>
</ul>
<h2 id=how-to-delete-objects>如何删除对象 </h2>
<p>你可以使用 <code>delete</code> 命令从集群中删除一个对象：</p>
<ul>
<li><code>delete &lt;类别>/&lt;名称></code></li>
</ul>
<p>你可以使用 <code>kubectl delete</code> 来执行指令式命令或者指令式对象配置。不同之处在于
传递给命令的参数。要将 <code>kubectl delete</code> 作为指令式命令使用，将要删除的对象作为
参数传递给它。下面是一个删除名为 <code>nginx</code> 的 Deployment 对象的命令：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete deployment/nginx
</code></pre></div>
<h2 id=how-to-view-an-object>如何查看对象 </h2>
<p>用来打印对象信息的命令有好几个：</p>
<ul>
<li><code>get</code>：打印匹配到的对象的基本信息。使用 <code>get -h</code> 可以查看选项列表。</li>
<li><code>describe</code>：打印匹配到的对象的详细信息的汇集版本。</li>
<li><code>logs</code>：打印 Pod 中运行的容器的 stdout 和 stderr 输出。</li>
</ul>
<h2 id=使用-set-命令在创建对象之前修改对象>使用 <code>set</code> 命令在创建对象之前修改对象</h2>
<p>有些对象字段在 <code>create</code> 命令中没有对应的标志。在这些场景中，
你可以使用 <code>set</code> 和 <code>create</code> 命令的组合来在对象创建之前设置字段值。
这是通过将 <code>create</code> 命令的输出用管道方式传递给 <code>set</code> 命令来实现的，
最后执行 <code>create</code> 命令来创建对象。下面是一个例子：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>kubectl create service clusterip my-svc --clusterip<span style=color:#666>=</span><span style=color:#b44>&#34;None&#34;</span> -o yaml --dry-run<span style=color:#666>=</span>client | kubectl <span style=color:#a2f>set</span> selector --local -f - <span style=color:#b44>&#39;environment=qa&#39;</span> -o yaml | kubectl create -f -
</code></pre></div>
<ol>
<li>命令 <code>kubectl create service -o yaml --dry-run=client</code> 创建 Service 的配置，但
将其以 YAML 格式在标准输出上打印而不是发送给 API 服务器。</li>
<li>命令 <code>kubectl set selector --local -f - -o yaml</code> 从标准输入读入配置，并将更新后的
配置以 YAML 格式输出到标准输出。</li>
<li>命令 <code>kubectl create -f -</code> 使用标准输入上获得的配置创建对象。</li>
</ol>
<h2 id=在创建之前使用-edit-更改对象>在创建之前使用 <code>--edit</code> 更改对象</h2>
<p>你可以用 <code>kubectl create --edit</code> 来在对象被创建之前执行任意的变更。
下面是一个例子：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>kubectl create service clusterip my-svc --clusterip<span style=color:#666>=</span><span style=color:#b44>&#34;None&#34;</span> -o yaml --dry-run<span style=color:#666>=</span>client &gt; /tmp/srv.yaml
kubectl create --edit -f /tmp/srv.yaml
</code></pre></div>
<ol>
<li>命令 <code>kubectl create service</code> 创建 Service 的配置并将其保存到
<code>/tmp/srv.yaml</code> 文件。</li>
<li>命令 <code>kubectl create --edit</code> 在创建 Service 对象打开其配置文件进行编辑。</li>
</ol>
<h2 id=what-s-next>What's next</h2>
<ul>
<li><a href=/zh/docs/tasks/manage-kubernetes-objects/imperative-config/>使用指令式对象配置管理 Kubernetes 对象</a></li>
<li><a href=/zh/docs/tasks/manage-kubernetes-objects/declarative-config/>使用声明式对象配置管理 Kubernetes 对象</a></li>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands/>Kubectl 命令参考</a></li>
<li><a href=/docs/reference/generated/kubernetes-api/v1.23/>Kubernetes API 参考</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-b18886277c410fc6f32ce068e2160537>6.4 - 使用配置文件对 Kubernetes 对象进行命令式管理</h1>
<p>可以使用 <code>kubectl</code> 命令行工具以及用 YAML 或 JSON 编写的对象配置文件来创建、更新和删除 Kubernetes 对象。
本文档说明了如何使用配置文件定义和管理对象。</p>
<h2 id=before-you-begin>Before you begin</h2>
<p>安装 <a href=/zh/docs/tasks/tools/><code>kubectl</code></a> 。</p>
<p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li>
</ul>
To check the version, enter <code>kubectl version</code>.
</p>
<h2 id=权衡>权衡</h2>
<p><code>kubectl</code> 工具支持三种对象管理：</p>
<ul>
<li>命令式命令</li>
<li>命令式对象配置</li>
<li>声明式对象配置</li>
</ul>
<p>参看 <a href=/zh/docs/concepts/overview/working-with-objects/object-management/>Kubernetes 对象管理</a>
中关于每种对象管理的优缺点的讨论。</p>
<h2 id=如何创建对象>如何创建对象</h2>
<p>你可以使用 <code>kubectl create -f</code> 从配置文件创建一个对象。
请参考 <a href=/docs/reference/generated/kubernetes-api/v1.23/>kubernetes API 参考</a> 有关详细信息。</p>
<ul>
<li><code>kubectl create -f &lt;filename|url></code></li>
</ul>
<h2 id=如何更新对象>如何更新对象</h2>
<div class="alert alert-danger warning callout" role=alert>
<strong>Warning:</strong> 使用 <code>replace</code> 命令更新对象会删除所有未在配置文件中指定的规范的某些部分。
不应将其规范由集群部分管理的对象使用，比如类型为 <code>LoadBalancer</code> 的服务，
其中 <code>externalIPs</code> 字段独立于配置文件进行管理。
必须将独立管理的字段复制到配置文件中，以防止 <code>replace</code> 删除它们。
</div>
<p>你可以使用 <code>kubectl replace -f</code> 根据配置文件更新活动对象。</p>
<ul>
<li><code>kubectl replace -f &lt;filename|url></code></li>
</ul>
<h2 id=如何删除对象>如何删除对象</h2>
<p>你可以使用 <code>kubectl delete -f</code> 删除配置文件中描述的对象。</p>
<ul>
<li><code>kubectl delete -f &lt;filename|url></code></li>
</ul>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> <p>如果配置文件在 <code>metadata</code> 节中设置了 <code>generateName</code> 字段而非 <code>name</code> 字段，
你无法使用 <code>kubectl delete -f &lt;filename|url></code> 来删除该对象。
你必须使用其他标志才能删除对象。例如：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete &lt;type&gt; &lt;name&gt;
kubectl delete &lt;type&gt; -l &lt;label&gt;
</code></pre></div>
</div>
<h2 id=如何查看对象>如何查看对象</h2>
<p>你可以使用 <code>kubectl get -f</code> 查看有关配置文件中描述的对象的信息。</p>
<ul>
<li><code>kubectl get -f &lt;filename|url> -o yaml</code></li>
</ul>
<p><code>-o yaml</code> 标志指定打印完整的对象配置。
使用 <code>kubectl get -h</code> 查看选项列表。</p>
<h2 id=局限性>局限性</h2>
<p>当完全定义每个对象的配置并将其记录在其配置文件中时，<code>create</code>、 <code>replace</code> 和<code>delete</code> 命令会很好的工作。
但是，当更新一个活动对象，并且更新没有合并到其配置文件中时，下一次执行 <code>replace</code> 时，更新将丢失。
如果控制器,例如 HorizontalPodAutoscaler ,直接对活动对象进行更新，则会发生这种情况。
这有一个例子：</p>
<ol>
<li>从配置文件创建一个对象。</li>
<li>另一个源通过更改某些字段来更新对象。</li>
<li>从配置文件中替换对象。在步骤2中所做的其他源的更改将丢失。</li>
</ol>
<p>如果需要支持同一对象的多个编写器，则可以使用 <code>kubectl apply</code> 来管理该对象。</p>
<h2 id=从-url-创建和编辑对象而不保存配置>从 URL 创建和编辑对象而不保存配置</h2>
<p>假设你具有对象配置文件的 URL。
你可以在创建对象之前使用 <code>kubectl create --edit</code> 对配置进行更改。
这对于指向可以由读者修改的配置文件的教程和任务特别有用。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create -f &lt;url&gt; --edit
</code></pre></div>
<h2 id=从命令式命令迁移到命令式对象配置>从命令式命令迁移到命令式对象配置</h2>
<p>从命令式命令迁移到命令式对象配置涉及几个手动步骤。</p>
<ol>
<li>
<p>将活动对象导出到本地对象配置文件：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get &lt;kind&gt;/&lt;name&gt; -o yaml &gt; &lt;kind&gt;_&lt;name&gt;.yaml
</code></pre></div></li>
</ol>
<ol start=2>
<li>从对象配置文件中手动删除状态字段。</li>
</ol>
<ol start=3>
<li>
<p>对于后续的对象管理，只能使用 <code>replace</code> 。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl replace -f &lt;kind&gt;_&lt;name&gt;.yaml
</code></pre></div></li>
</ol>
<h2 id=定义控制器选择器和-podtemplate-标签>定义控制器选择器和 PodTemplate 标签</h2>
<div class="alert alert-danger warning callout" role=alert>
<strong>Warning:</strong> 不建议在控制器上更新选择器。
</div>
<p>推荐的方法是定义单个不变的 PodTemplate 标签，该标签仅由控制器选择器使用，而没有其他语义。</p>
<p>标签示例：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>controller-selector</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;apps/v1/deployment/nginx&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>controller-selector</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;apps/v1/deployment/nginx&#34;</span><span style=color:#bbb>
</span></code></pre></div><h2 id=what-s-next>What's next</h2>
<ul>
<li><a href=/zh/docs/tasks/manage-kubernetes-objects/imperative-command/>使用命令式命令管理 Kubernetes 对象</a></li>
<li><a href=/zh/docs/tasks/manage-kubernetes-objects/declarative-config/>使用对象配置管理 Kubernetes 对象 (声明式)</a></li>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands/>Kubectl 命令参考</a></li>
<li><a href=/docs/reference/generated/kubernetes-api/v1.23/>Kubernetes API 参考</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-d4d4414dc91b63cfe0f65ca4f0c2fe31>6.5 - 使用 kubectl patch 更新 API 对象</h1>
<div class=lead>使用 kubectl patch 更新 Kubernetes API 对象。做一个策略性的合并 patch 或 JSON 合并 patch。</div>
<p>这个任务展示如何使用 <code>kubectl patch</code> 就地更新 API 对象。
这个任务中的练习演示了一个策略性合并 patch 和一个 JSON 合并 patch。</p>
<h2 id=before-you-begin>Before you begin</h2>
<p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li>
</ul>
To check the version, enter <code>kubectl version</code>.
</p>
<h2 id=使用策略合并-patch-更新-deployment>使用策略合并 patch 更新 Deployment</h2>
<p>下面是具有两个副本的 Deployment 的配置文件。每个副本是一个 Pod，有一个容器：</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/application/deployment-patch.yaml download=application/deployment-patch.yaml><code>application/deployment-patch.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('application-deployment-patch-yaml')" title="Copy application/deployment-patch.yaml to clipboard">
</img>
</div>
<div class=includecode id=application-deployment-patch-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>patch-demo<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>2</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>patch-demo-ctr<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>tolerations</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>effect</span>:<span style=color:#bbb> </span>NoSchedule<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>dedicated<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span>test-team<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>创建 Deployment：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create -f https://k8s.io/examples/application/deployment-patch.yaml
</code></pre></div>
<p>查看与 Deployment 相关的 Pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods
</code></pre></div>
<p>输出显示 Deployment 有两个 Pod。<code>1/1</code> 表示每个 Pod 有一个容器:</p>
<pre><code>NAME                        READY     STATUS    RESTARTS   AGE
patch-demo-28633765-670qr   1/1       Running   0          23s
patch-demo-28633765-j5qs3   1/1       Running   0          23s
</code></pre>
<p>把运行的 Pod 的名字记下来。稍后，你将看到这些 Pod 被终止并被新的 Pod 替换。</p>
<p>此时，每个 Pod 都有一个运行 nginx 镜像的容器。现在假设你希望每个 Pod 有两个容器：一个运行 nginx，另一个运行 redis。</p>
<p>创建一个名为 <code>patch-file-containers.yaml</code> 的文件。内容如下:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>patch-demo-ctr-2<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span></code></pre></div>
<p>修补你的 Deployment：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl patch deployment patch-demo --patch <span style=color:#b44>&#34;</span><span style=color:#a2f;font-weight:700>$(</span>cat patch-file-containers.yaml<span style=color:#a2f;font-weight:700>)</span><span style=color:#b44>&#34;</span>
</code></pre></div>
<p>查看修补后的 Deployment：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get deployment patch-demo --output yaml
</code></pre></div>
<p>输出显示 Deployment 中的 PodSpec 有两个容器:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>imagePullPolicy</span>:<span style=color:#bbb> </span>Always<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>patch-demo-ctr-2<span style=color:#bbb>
</span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>imagePullPolicy</span>:<span style=color:#bbb> </span>Always<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>patch-demo-ctr<span style=color:#bbb>
</span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></code></pre></div>
<p>查看与 patch Deployment 相关的 Pod:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods
</code></pre></div>
<p>输出显示正在运行的 Pod 与以前运行的 Pod 有不同的名称。Deployment 终止了旧的 Pod，并创建了两个
符合更新的部署规范的新 Pod。<code>2/2</code> 表示每个 Pod 有两个容器:</p>
<pre><code>NAME                          READY     STATUS    RESTARTS   AGE
patch-demo-1081991389-2wrn5   2/2       Running   0          1m
patch-demo-1081991389-jmg7b   2/2       Running   0          1m
</code></pre>
<p>仔细查看其中一个 patch-demo Pod:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod &lt;your-pod-name&gt; --output yaml
</code></pre></div>
<p>输出显示 Pod 有两个容器:一个运行 nginx，一个运行 redis:</p>
<pre><code>containers:
- image: redis
  ...
- image: nginx
  ...
</code></pre>
<h3 id=策略性合并类的-patch-的说明>策略性合并类的 patch 的说明</h3>
<p>你在前面的练习中所做的 patch 称为<code>策略性合并 patch（Strategic Merge Patch)</code>。
请注意，patch 没有替换<code>containers</code> 列表。相反，它向列表中添加了一个新 Container。换句话说，
patch 中的列表与现有列表合并。当你在列表中使用策略性合并 patch 时，并不总是这样。
在某些情况下，列表是替换的，而不是合并的。</p>
<p>对于策略性合并 patch，列表可以根据其 patch 策略进行替换或合并。
patch 策略由 Kubernetes 源代码中字段标记中的 <code>patchStrategy</code> 键的值指定。
例如，<code>PodSpec</code> 结构体的 <code>Containers</code> 字段的 <code>patchStrategy</code> 为 <code>merge</code>：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a2f;font-weight:700>type</span> PodSpec <span style=color:#a2f;font-weight:700>struct</span> {
  <span style=color:#666>...</span>
  Containers []Container <span style=color:#b44>`json:&#34;containers&#34; patchStrategy:&#34;merge&#34; patchMergeKey:&#34;name&#34; ...`</span>
</code></pre></div>
<p>你还可以在 <a href=https://raw.githubusercontent.com/kubernetes/kubernetes/master/api/openapi-spec/swagger.json>OpenApi spec</a>
规范中看到 patch 策略：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=color:#b44>&#34;io.k8s.api.core.v1.PodSpec&#34;</span><span>:</span> {
    <span>...</span>
     <span style=color:green;font-weight:700>&#34;containers&#34;</span>: {
      <span style=color:green;font-weight:700>&#34;description&#34;</span>: <span style=color:#b44>&#34;List of containers belonging to the pod. ...
</span><span style=color:#b44>      },
</span><span style=color:#b44>      &#34;</span><span>x-kubernetes-patch-merge-key</span><span style=color:#b44>&#34;: &#34;</span><span>name</span><span style=color:#b44>&#34;,
</span><span style=color:#b44>      &#34;</span><span>x-kubernetes-patch-strategy</span><span style=color:#b44>&#34;: &#34;</span><span>merge&#34;</span>
     },
</code></pre></div>
<p>你可以在 <a href=/docs/reference/generated/kubernetes-api/v1.23/#podspec-v1-core>Kubernetes API 文档</a>
中看到 patch 策略。</p>
<p>创建一个名为 <code>patch-file-tolerations.yaml</code> 的文件。内容如下:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>tolerations</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>effect</span>:<span style=color:#bbb> </span>NoSchedule<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>disktype<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span>ssd<span style=color:#bbb>
</span></code></pre></div>
<p>对 Deployment 执行 patch 操作：</p>
<pre><code>kubectl patch deployment patch-demo --patch-file patch-file-tolerations.yaml&quot;
</code></pre>
<p>查看修补后的 Deployment：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get deployment patch-demo --output yaml
</code></pre></div>
<p>输出结果显示 Deployment 中的 PodSpec 只有一个容忍度设置：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>
containers:
- image: redis
  imagePullPolicy: Always
  name: patch-demo-ctr-2
  ...
- image: nginx
  imagePullPolicy: Always
  name: patch-demo-ctr
  ...
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>tolerations</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>effect</span>:<span style=color:#bbb> </span>NoSchedule<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>disktype<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span>ssd<span style=color:#bbb>
</span></code></pre></div>
<p>请注意，PodSpec 中的 <code>tolerations</code> 列表被替换，而不是合并。这是因为 PodSpec 的 <code>tolerations</code>
的字段标签中没有 <code>patchStrategy</code> 键。所以策略合并 patch 操作使用默认的 patch 策略，也就是 <code>replace</code>。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a2f;font-weight:700>type</span> PodSpec <span style=color:#a2f;font-weight:700>struct</span> {
  <span style=color:#666>...</span>
  Tolerations []Toleration <span style=color:#b44>`json:&#34;tolerations,omitempty&#34; protobuf:&#34;bytes,22,opt,name=tolerations&#34;`</span>
</code></pre></div>
<h2 id=使用-json-合并-patch-更新-deployment>使用 JSON 合并 patch 更新 Deployment</h2>
<p>策略性合并 patch 不同于 <a href=https://tools.ietf.org/html/rfc7386>JSON 合并 patch</a>。
使用 JSON 合并 patch，如果你想更新列表，你必须指定整个新列表。新的列表完全取代现有的列表。</p>
<p><code>kubectl patch</code> 命令有一个 <code>type</code> 参数，你可以将其设置为以下值之一:</p>
<table>
<tr><th>参数值</th><th>合并类型</th></tr>
<tr><td>json</td><td><a href=https://tools.ietf.org/html/rfc6902>JSON Patch, RFC 6902</a></td></tr>
<tr><td>merge</td><td><a href=https://tools.ietf.org/html/rfc7386>JSON Merge Patch, RFC 7386</a></td></tr>
<tr><td>strategic</td><td>策略合并 patch</td></tr>
</table>
<p>有关 JSON patch 和 JSON 合并 patch 的比较，查看
<a href=https://erosb.github.io/post/json-patch-vs-merge-patch/>JSON patch 和 JSON 合并 patch</a>。</p>
<p><code>type</code> 参数的默认值是 <code>strategic</code>。在前面的练习中，我们做了一个策略性的合并 patch。</p>
<p>下一步，在相同的 Deployment 上执行 JSON 合并 patch。创建一个名为 <code>patch-file-2</code> 的文件。内容如下:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>patch-demo-ctr-3<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>gcr.io/google-samples/node-hello:1.0<span style=color:#bbb>
</span></code></pre></div>
<p>在 patch 命令中，将 <code>type</code> 设置为 <code>merge</code>：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl patch deployment patch-demo --type merge --patch-file patch-file-2.yaml
</code></pre></div>
<p>查看修补后的 Deployment：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get deployment patch-demo --output yaml
</code></pre></div>
<p>patch 中指定的<code>containers</code>列表只有一个 Container。
输出显示你所给出的 Contaier 列表替换了现有的 <code>containers</code> 列表。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>gcr.io/google-samples/node-hello:1.0<span style=color:#bbb>
</span><span style=color:#bbb>    </span>...<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>patch-demo-ctr-3<span style=color:#bbb>
</span></code></pre></div>
<p>列表中运行的 Pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods
</code></pre></div>
<p>在输出中，你可以看到已经终止了现有的 Pod，并创建了新的 Pod。<code>1/1</code> 表示每个新 Pod只运行一个容器。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>NAME                          READY     STATUS    RESTARTS   AGE
patch-demo-1307768864-69308   1/1       Running   <span style=color:#666>0</span>          1m
patch-demo-1307768864-c86dc   1/1       Running   <span style=color:#666>0</span>          1m
</code></pre></div>
<h2 id=使用带-retainkeys-策略的策略合并-patch-更新-deployment>使用带 retainKeys 策略的策略合并 patch 更新 Deployment</h2>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/application/deployment-retainkeys.yaml download=application/deployment-retainkeys.yaml><code>application/deployment-retainkeys.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('application-deployment-retainkeys-yaml')" title="Copy application/deployment-retainkeys.yaml to clipboard">
</img>
</div>
<div class=includecode id=application-deployment-retainkeys-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>retainkeys-demo<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>strategy</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>rollingUpdate</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>maxSurge</span>:<span style=color:#bbb> </span><span style=color:#666>30</span>%<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>retainkeys-demo-ctr<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>创建 Deployment：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/application/deployment-retainkeys.yaml
</code></pre></div>
<p>这时，Deployment 被创建，并使用 <code>RollingUpdate</code> 策略。</p>
<p>创建一个名为 <code>patch-file-no-retainkeys.yaml</code> 的文件，内容如下：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>strategy</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Recreate<span style=color:#bbb>
</span></code></pre></div>
<p>修补你的 Deployment:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl patch deployment patch-demo --patch-file patch-file.yaml
</code></pre></div>
<p>在输出中，你可以看到，当 <code>spec.strategy.rollingUpdate</code> 已经拥有取值定义时，
将其 <code>type</code> 设置为 <code>Recreate</code> 是不可能的。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>The Deployment <span style=color:#b44>&#34;retainkeys-demo&#34;</span> is invalid: spec.strategy.rollingUpdate: Forbidden: may not be specified when strategy <span style=color:#b44>`</span><span style=color:#a2f>type</span><span style=color:#b44>`</span> is <span style=color:#b44>&#39;Recreate&#39;</span>
</code></pre></div>
<p>更新 <code>type</code> 取值的同时移除 <code>spec.strategy.rollingUpdate</code> 现有值的方法是
为策略性合并操作设置 <code>retainKeys</code> 策略：</p>
<p>创建另一个名为 <code>patch-file-retainkeys.yaml</code> 的文件，内容如下：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>strategy</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>$retainKeys</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- type<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Recreate<span style=color:#bbb>
</span></code></pre></div>
<p>使用此 patch，我们表达了希望只保留 <code>strategy</code> 对象的 <code>type</code> 键。
这样，在 patch 操作期间 <code>rollingUpdate</code> 会被删除。</p>
<p>使用新的 patch 重新修补 Deployment：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl patch deployment retainkeys-demo --type merge --patch-file patch-file-no-retainkeys.yaml
</code></pre></div>
<p>检查 Deployment 的内容：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get deployment retainkeys-demo --output yaml
</code></pre></div>
<p>输出显示 Deployment 中的 <code>strategy</code> 对象不再包含 <code>rollingUpdate</code> 键：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>spec:
  strategy:
    type: Recreate
  template:
</code></pre></div>
<h3 id=关于使用-retainkeys-策略的策略合并-patch-操作的说明>关于使用 retainKeys 策略的策略合并 patch 操作的说明</h3>
<p>在前文练习中所执行的称作 <em>带 <code>retainKeys</code> 策略的策略合并 patch（Strategic Merge
Patch with retainKeys Strategy）</em>。
这种方法引入了一种新的 <code>$retainKey</code> 指令，具有如下策略：</p>
<ul>
<li>其中包含一个字符串列表；</li>
<li>所有需要被保留的字段必须在 <code>$retainKeys</code> 列表中给出；</li>
<li>对于已有的字段，会和对象上对应的内容合并；</li>
<li>在修补操作期间，未找到的字段都会被清除；</li>
<li>列表 <code>$retainKeys</code> 中的所有字段必须 patch 操作所给字段的超集，或者与之完全一致。</li>
</ul>
<p>策略 <code>retainKeys</code> 并不能对所有对象都起作用。它仅对那些 Kubernetes 源码中
<code>patchStrategy</code> 字段标志值包含 <code>retainKeys</code> 的字段有用。
例如 <code>DeploymentSpec</code> 结构的 <code>Strategy</code> 字段就包含了 <code>patchStrategy</code> 为
<code>retainKeys</code> 的标志。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a2f;font-weight:700>type</span> DeploymentSpec <span style=color:#a2f;font-weight:700>struct</span> {
  <span style=color:#666>...</span>
  <span style=color:#080;font-style:italic>// +patchStrategy=retainKeys
</span><span style=color:#080;font-style:italic></span>  Strategy DeploymentStrategy <span style=color:#b44>`json:&#34;strategy,omitempty&#34; patchStrategy:&#34;retainKeys&#34; ...`</span>
</code></pre></div>
<p>你也可以查看 <a href=https://raw.githubusercontent.com/kubernetes/kubernetes/master/api/openapi-spec/swagger.json>OpenAPI 规范</a>中的 <code>retainKeys</code> 策略：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=color:#b44>&#34;io.k8s.api.apps.v1.DeploymentSpec&#34;</span><span>:</span> {
   <span>...</span>
  <span style=color:green;font-weight:700>&#34;strategy&#34;</span>: {
    <span style=color:green;font-weight:700>&#34;$ref&#34;</span>: <span style=color:#b44>&#34;#/definitions/io.k8s.api.apps.v1.DeploymentStrategy&#34;</span>,
    <span style=color:green;font-weight:700>&#34;description&#34;</span>: <span style=color:#b44>&#34;The deployment strategy to use to replace existing pods with new ones.&#34;</span>,
    <span style=color:green;font-weight:700>&#34;x-kubernetes-patch-strategy&#34;</span>: <span style=color:#b44>&#34;retainKeys&#34;</span>
  },
</code></pre></div>
<p>而且你也可以在
<a href=/docs/reference/generated/kubernetes-api/v1.23/#deploymentspec-v1-apps>Kubernetes API 文档</a>.
中看到 <code>retainKey</code> 策略。</p>
<h2 id=kubectl-patch-命令的其他形式>kubectl patch 命令的其他形式</h2>
<p><code>kubectl patch</code> 命令使用 YAML 或 JSON。它可以接受以文件形式提供的补丁，也可以
接受直接在命令行中给出的补丁。</p>
<p>创建一个文件名称是 <code>patch-file.json</code> 内容如下：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
   <span style=color:green;font-weight:700>&#34;spec&#34;</span>: {
      <span style=color:green;font-weight:700>&#34;template&#34;</span>: {
         <span style=color:green;font-weight:700>&#34;spec&#34;</span>: {
            <span style=color:green;font-weight:700>&#34;containers&#34;</span>: [
               {
                  <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;patch-demo-ctr-2&#34;</span>,
                  <span style=color:green;font-weight:700>&#34;image&#34;</span>: <span style=color:#b44>&#34;redis&#34;</span>
               }
            ]
         }
      }
   }
}
</code></pre></div>
<p>以下命令是等价的：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl patch deployment patch-demo --patch-file patch-file.yaml
kubectl patch deployment patch-demo --patch <span style=color:#b44>&#39;spec:\n template:\n  spec:\n   containers:\n   - name: patch-demo-ctr-2\n     image: redis&#39;</span>

kubectl patch deployment patch-demo --patch-file patch-file.json
kubectl patch deployment patch-demo --patch <span style=color:#b44>&#39;{&#34;spec&#34;: {&#34;template&#34;: {&#34;spec&#34;: {&#34;containers&#34;: [{&#34;name&#34;: &#34;patch-demo-ctr-2&#34;,&#34;image&#34;: &#34;redis&#34;}]}}}}&#39;</span>
</code></pre></div>
<h2 id=总结>总结</h2>
<p>在本练习中，你使用 <code>kubectl patch</code> 更改了 Deployment 对象的当前配置。
你没有更改最初用于创建 Deployment 对象的配置文件。
用于更新 API 对象的其他命令包括
<a href=/docs/reference/generated/kubectl/kubectl-commands/#annotate><code>kubectl annotate</code></a>，
<a href=/docs/reference/generated/kubectl/kubectl-commands/#edit><code>kubectl edit</code></a>，
<a href=/docs/reference/generated/kubectl/kubectl-commands/#replace><code>kubectl replace</code></a>，
<a href=/docs/reference/generated/kubectl/kubectl-commands/#scale><code>kubectl scale</code></a>，
和
<a href=/docs/reference/generated/kubectl/kubectl-commands/#apply><code>kubectl apply</code></a>。</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 定制资源不支持策略性合并 patch。
</div>
<h2 id=what-s-next>What's next</h2>
<ul>
<li><a href=/zh/docs/concepts/overview/working-with-objects/object-management/>Kubernetes 对象管理</a></li>
<li><a href=/zh/docs/tasks/manage-kubernetes-objects/imperative-command/>使用指令式命令管理 Kubernetes 对象</a></li>
<li><a href=/zh/docs/tasks/manage-kubernetes-objects/imperative-config>使用配置文件执行 Kubernetes 对象的指令式管理</a></li>
<li><a href=/zh/docs/tasks/manage-kubernetes-objects/declarative-config/>使用配置文件对 Kubernetes 对象进行声明式管理</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-94f49ece137035764368f22a98942872>7 - 管理 Secrets</h1>
<div class=lead>使用 Secrets 管理机密配置数据。</div>
</div>
<div class=td-content>
<h1 id=pg-0ed63ce3c9665aed7ff5a560ff1da843>7.1 - 使用 kubectl 管理 Secret</h1>
<div class=lead>使用 kubectl 命令行创建 Secret 对象。</div>
<h2 id=before-you-begin>Before you begin</h2>
<p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li>
</ul>
<h2 id=create-a-secret>创建 Secret </h2>
<p>一个 <code>Secret</code> 可以包含 Pod 访问数据库所需的用户凭证。
例如，由用户名和密码组成的数据库连接字符串。
你可以在本地计算机上，将用户名存储在文件 <code>./username.txt</code> 中，将密码存储在文件 <code>./password.txt</code> 中。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#a2f>echo</span> -n <span style=color:#b44>&#39;admin&#39;</span> &gt; ./username.txt
<span style=color:#a2f>echo</span> -n <span style=color:#b44>&#39;1f2d1e2e67df&#39;</span> &gt; ./password.txt
</code></pre></div>
<p>在这些命令中，<code>-n</code> 标志确保生成的文件在文本末尾不包含额外的换行符。
这一点很重要，因为当 <code>kubectl</code> 读取文件并将内容编码为 base64 字符串时，多余的换行符也会被编码。</p>
<p><code>kubectl create secret</code> 命令将这些文件打包成一个 Secret 并在 API 服务器上创建对象。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create secret generic db-user-pass <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --from-file<span style=color:#666>=</span>./username.txt <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --from-file<span style=color:#666>=</span>./password.txt
</code></pre></div>
<p>输出类似于：</p>
<pre><code>secret/db-user-pass created
</code></pre>
<p>默认密钥名称是文件名。 你可以选择使用 <code>--from-file=[key=]source</code> 来设置密钥名称。例如：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create secret generic db-user-pass <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --from-file<span style=color:#666>=</span><span style=color:#b8860b>username</span><span style=color:#666>=</span>./username.txt <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --from-file<span style=color:#666>=</span><span style=color:#b8860b>password</span><span style=color:#666>=</span>./password.txt
</code></pre></div>
<p>你不需要对文件中包含的密码字符串中的特殊字符进行转义。</p>
<p>你还可以使用 <code>--from-literal=&lt;key>=&lt;value></code> 标签提供 Secret 数据。
可以多次使用此标签，提供多个键值对。
请注意，特殊字符（例如：<code>$</code>，<code>\</code>，<code>*</code>，<code>=</code> 和 <code>!</code>）由你的 <a href=https://en.wikipedia.org/wiki/Shell_(computing)>shell</a>
解释执行，而且需要转义。</p>
<p>在大多数 shell 中，转义密码最简便的方法是用单引号括起来。
比如，如果你的密码是 <code>S!B\*d$zDsb=</code>，
可以像下面一样执行命令：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create secret generic db-user-pass <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --from-literal<span style=color:#666>=</span><span style=color:#b8860b>username</span><span style=color:#666>=</span>devuser <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --from-literal<span style=color:#666>=</span><span style=color:#b8860b>password</span><span style=color:#666>=</span><span style=color:#b44>&#39;S!B\*d$zDsb=&#39;</span>
</code></pre></div>
<h2 id=verify-the-secret>验证 Secret </h2>
<p>检查 secret 是否已创建：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get secrets
</code></pre></div>
<p>输出类似于：</p>
<pre><code>NAME                  TYPE                                  DATA      AGE
db-user-pass          Opaque                                2         51s
</code></pre>
<p>你可以查看 <code>Secret</code> 的描述：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe secrets/db-user-pass
</code></pre></div>
<p>输出类似于：</p>
<pre><code>Name:            db-user-pass
Namespace:       default
Labels:          &lt;none&gt;
Annotations:     &lt;none&gt;

Type:            Opaque

Data
====
password:    12 bytes
username:    5 bytes
</code></pre>
<p><code>kubectl get</code> 和 <code>kubectl describe</code> 命令默认不显示 <code>Secret</code> 的内容。
这是为了防止 <code>Secret</code> 被意外暴露或存储在终端日志中。</p>
<h2 id=decoding-secret>解码 Secret </h2>
<p>要查看创建的 Secret 的内容，运行以下命令：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get secret db-user-pass -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.data}&#39;</span>
</code></pre></div>
<p>输出类似于：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{<span style=color:green;font-weight:700>&#34;password&#34;</span>:<span style=color:#b44>&#34;MWYyZDFlMmU2N2Rm&#34;</span>,<span style=color:green;font-weight:700>&#34;username&#34;</span>:<span style=color:#b44>&#34;YWRtaW4=&#34;</span>}
</code></pre></div>
<p>现在你可以解码 <code>password</code> 的数据：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># 这是一个用于文档说明的示例。</span>
<span style=color:#080;font-style:italic># 如果你这样做，数据 &#39;MWYyZDFlMmU2N2Rm&#39; 可以存储在你的 shell 历史中。</span>
<span style=color:#080;font-style:italic># 可以进入你电脑的人可以找到那个记住的命令并可以在你不知情的情况下 base-64 解码这个 Secret。</span>
<span style=color:#080;font-style:italic># 通常最好将这些步骤结合起来，如页面后面所示。</span>
<span style=color:#a2f>echo</span> <span style=color:#b44>&#39;MWYyZDFlMmU2N2Rm&#39;</span> | base64 --decode
</code></pre></div>
<p>输出类似于：</p>
<pre><code>1f2d1e2e67df
</code></pre>
<p>为了避免在 shell 历史记录中存储 Secret 的编码值，可以执行如下命令:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get secret db-user-pass -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.data.password}&#39;</span> | base64 --decode
</code></pre></div>
<p>输出应与上述类似。</p>
<h2 id=clean-up>清理 </h2>
<p>删除创建的 Secret：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete secret db-user-pass
</code></pre></div>
<h2 id=what-s-next>What's next</h2>
<ul>
<li>进一步阅读 <a href=/zh/docs/concepts/configuration/secret/>Secret 概念</a></li>
<li>了解如何<a href=/zh/docs/tasks/configmap-secret/managing-secret-using-config-file/>使用配置文件管理 Secret</a></li>
<li>了解如何<a href=/zh/docs/tasks/configmap-secret/managing-secret-using-kustomize/>使用 kustomize 管理 Secret</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-e841cf91fd3566db1e86143ed7a9e13c>7.2 - 使用配置文件管理 Secret</h1>
<div class=lead>使用资源配置文件创建 Secret 对象。</div>
<h2 id=before-you-begin>Before you begin</h2>
<p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li>
</ul>
<h2 id=create-the-config-file>创建配置文件 </h2>
<p>你可以先用 JSON 或 YAML 格式在文件中创建 Secret，然后创建该对象。
<a href=/docs/reference/generated/kubernetes-api/v1.23/#secret-v1-core>Secret</a>
资源包含2个键值对： <code>data</code> 和 <code>stringData</code>。
<code>data</code> 字段用来存储 base64 编码的任意数据。
提供 <code>stringData</code> 字段是为了方便，它允许 Secret 使用未编码的字符串。
<code>data</code> 和 <code>stringData</code> 的键必须由字母、数字、<code>-</code>，<code>_</code> 或 <code>.</code> 组成。</p>
<p>例如，要使用 Secret 的 <code>data</code> 字段存储两个字符串，请将字符串转换为 base64 ，如下所示：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#a2f>echo</span> -n <span style=color:#b44>&#39;admin&#39;</span> | base64
</code></pre></div>
<p>输出类似于：</p>
<pre><code>YWRtaW4=
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#a2f>echo</span> -n <span style=color:#b44>&#39;1f2d1e2e67df&#39;</span> | base64
</code></pre></div>
<p>输出类似于：</p>
<pre><code>MWYyZDFlMmU2N2Rm
</code></pre>
<p>编写一个 Secret 配置文件，如下所示：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Opaque<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>username</span>:<span style=color:#bbb> </span>YWRtaW4=<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>password</span>:<span style=color:#bbb> </span>MWYyZDFlMmU2N2Rm<span style=color:#bbb>
</span></code></pre></div>
<p>注意，Secret 对象的名称必须是有效的 <a href=/zh/docs/concepts/overview/working-with-objects/names#dns-subdomain-names>DNS 子域名</a>.</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong>
<p>Secret 数据的 JSON 和 YAML 序列化结果是以 base64 编码的。
换行符在这些字符串中无效，必须省略。
在 Darwin/macOS 上使用 <code>base64</code> 工具时，用户不应该使用 <code>-b</code> 选项分割长行。
相反地，Linux 用户 <em>应该</em> 在 <code>base64</code> 地命令中添加 <code>-w 0</code> 选项，
或者在 <code>-w</code> 选项不可用的情况下，输入 <code>base64 | tr -d '\n'</code>。
</div>
<p>对于某些场景，你可能希望使用 <code>stringData</code> 字段。
这字段可以将一个非 base64 编码的字符串直接放入 Secret 中，
当创建或更新该 Secret 时，此字段将被编码。</p>
<p>上述用例的实际场景可能是这样：当你部署应用时，使用 Secret 存储配置文件，
你希望在部署过程中，填入部分内容到该配置文件。</p>
<p>例如，如果你的应用程序使用以下配置文件:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiUrl</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;https://my.api.com/api/v1&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>username</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&lt;user&gt;&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>password</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&lt;password&gt;&#34;</span><span style=color:#bbb>
</span></code></pre></div>
<p>你可以使用以下定义将其存储在 Secret 中:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Opaque<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>stringData</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>config.yaml</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span><span style=color:#b44;font-style:italic>    apiUrl: &#34;https://my.api.com/api/v1&#34;
</span><span style=color:#b44;font-style:italic>    username: &lt;user&gt;
</span><span style=color:#b44;font-style:italic>    password: &lt;password&gt;</span><span style=color:#bbb>    
</span></code></pre></div>
<h2 id=create-the-secret-object>创建 Secret 对象 </h2>
<p>现在使用 <a href=/docs/reference/generated/kubectl/kubectl-commands#apply><code>kubectl apply</code></a> 创建 Secret：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f ./secret.yaml
</code></pre></div>
<p>输出类似于：</p>
<pre><code>secret/mysecret created
</code></pre>
<h2 id=check-the-secret>检查 Secret </h2>
<p><code>stringData</code> 字段是只写的。获取 Secret 时，此字段永远不会输出。
例如，如果你运行以下命令：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get secret mysecret -o yaml
</code></pre></div>
<p>输出类似于：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>config.yaml</span>:<span style=color:#bbb> </span>YXBpVXJsOiAiaHR0cHM6Ly9teS5hcGkuY29tL2FwaS92MSIKdXNlcm5hbWU6IHt7dXNlcm5hbWV9fQpwYXNzd29yZDoge3twYXNzd29yZH19<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>creationTimestamp</span>:<span style=color:#bbb> </span>2018-11-15T20:40:59Z<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resourceVersion</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;7225&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>uid</span>:<span style=color:#bbb> </span>c280ad2e-e916-11e8-98f2-025000000001<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Opaque<span style=color:#bbb>
</span></code></pre></div>
<p>命令 <code>kubectl get</code> 和 <code>kubectl describe</code> 默认不显示 <code>Secret</code> 的内容。
这是为了防止 <code>Secret</code> 意外地暴露给旁观者或者保存在终端日志中。
检查编码数据的实际内容，请参考<a href=/zh/docs/tasks/configmap-secret/managing-secret-using-kubectl/#decoding-secret>解码 secret</a>.</p>
<p>如果在 <code>data</code> 和 <code>stringData</code> 中都指定了一个字段，比如 <code>username</code>，字段值来自 <code>stringData</code>。
例如，下面的 Secret 定义:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Opaque<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>username</span>:<span style=color:#bbb> </span>YWRtaW4=<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>stringData</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>username</span>:<span style=color:#bbb> </span>administrator<span style=color:#bbb>
</span></code></pre></div>
<p>结果有以下 Secret：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>username</span>:<span style=color:#bbb> </span>YWRtaW5pc3RyYXRvcg==<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>creationTimestamp</span>:<span style=color:#bbb> </span>2018-11-15T20:46:46Z<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resourceVersion</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;7579&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>uid</span>:<span style=color:#bbb> </span>91460ecb-e917-11e8-98f2-025000000001<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Opaque<span style=color:#bbb>
</span></code></pre></div>
<p>其中 <code>YWRtaW5pc3RyYXRvcg==</code> 解码成 <code>administrator</code>。</p>
<h2 id=clean-up>清理 </h2>
<p>删除你创建的 Secret：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete secret mysecret
</code></pre></div><h2 id=what-s-next>What's next</h2>
<ul>
<li>进一步阅读 <a href=/zh/docs/concepts/configuration/secret/>Secret 概念</a></li>
<li>了解如何<a href=/zh/docs/tasks/configmap-secret/managing-secret-using-kubectl/>使用 <code>kubectl</code> 命令管理 Secret</a></li>
<li>了解如何<a href=/zh/docs/tasks/configmap-secret/managing-secret-using-kustomize/>使用 kustomize 管理 Secret</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-a0ff2e3ba8af5670d5dc3d94c4bd0a68>7.3 - 使用 Kustomize 管理 Secret</h1>
<div class=lead>使用 kustomization.yaml 文件创建 Secret 对象。</div>
<p>从 kubernetes v1.14 开始，<code>kubectl</code> 支持<a href=/zh/docs/tasks/manage-kubernetes-objects/kustomization/>使用 Kustomize 管理对象</a>。
Kustomize 提供了资源生成器（Generators）来创建 Secret 和 ConfigMap。
Kustomize 生成器应该在某个目录的 <code>kustomization.yaml</code> 文件中指定。
生成 Secret 后，你可以使用 <code>kubectl apply</code> 在 API 服务器上创建该 Secret。</p>
<h2 id=before-you-begin>Before you begin</h2>
<p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li>
</ul>
<h2 id=create-the-kustomization-file>创建 Kustomization 文件 </h2>
<p>你可以在 <code>kustomization.yaml</code> 中定义 <code>secreteGenerator</code>，并在定义中引用其他现成的文件，生成 Secret。
例如：下面的 kustomization 文件 引用了 <code>./username.txt</code> 和 <code>./password.txt</code> 文件：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>secretGenerator</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>db-user-pass<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>files</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- username.txt<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- password.txt<span style=color:#bbb>
</span></code></pre></div>
<p>你也可以在 <code>kustomization.yaml</code> 文件中指定一些字面量定义 <code>secretGenerator</code>。
例如：下面的 <code>kustomization.yaml</code> 文件中包含了 <code>username</code> 和 <code>password</code> 两个字面量：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>secretGenerator</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>db-user-pass<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>literals</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- username=admin<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- password=1f2d1e2e67df<span style=color:#bbb>
</span></code></pre></div>
<p>你也可以使用 <code>.env</code> 文件在 <code>kustomization.yaml</code> 中定义 <code>secretGenerator</code>。
例如：下面的 <code>kustomization.yaml</code> 文件从 <code>.env.secret</code> 文件获取数据。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>secretGenerator</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>db-user-pass<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>envs</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- .env.secret<span style=color:#bbb>
</span></code></pre></div>
<p>注意，上面两种情况，你都不需要使用 base64 编码。</p>
<h2 id=create-the-secret>创建 Secret </h2>
<p>使用 <code>kubectl apply</code> 命令应用包含 <code>kustomization.yaml</code> 文件的目录创建 Secret。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -k .
</code></pre></div>
<p>输出类似于：</p>
<pre><code>secret/db-user-pass-96mffmfh4k created
</code></pre>
<p>请注意，生成 Secret 时，Secret 的名称最终是由 <code>name</code> 字段和数据的哈希值拼接而成。
这将保证每次修改数据时生成一个新的 Secret。</p>
<h2 id=check-the-secret-created>检查创建的 Secret </h2>
<p>你可以检查刚才创建的 Secret：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get secrets
</code></pre></div>
<p>输出类似于：</p>
<pre><code>NAME                             TYPE                                  DATA      AGE
db-user-pass-96mffmfh4k          Opaque                                2         51s
</code></pre>
<p>你可以看到 Secret 的描述：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe secrets/db-user-pass-96mffmfh4k
</code></pre></div>
<p>输出类似于：</p>
<pre><code>Name:            db-user-pass-96mffmfh4k
Namespace:       default
Labels:          &lt;none&gt;
Annotations:     &lt;none&gt;

Type:            Opaque

Data
====
password.txt:    12 bytes
username.txt:    5 bytes
</code></pre>
<p><code>kubectl get</code> 和 <code>kubectl describe</code> 命令默认不显示 <code>Secret</code> 的内容。
这是为了防止 <code>Secret</code> 被意外暴露给旁观者或存储在终端日志中。
检查编码后的实际内容，请参考<a href=/zh/docs/tasks/configmap-secret/managing-secret-using-kubectl/#decoding-secret>解码 secret</a>。
--></p>
<h2 id=clean-up>清理 </h2>
<p>删除你创建的 Secret：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete secret db-user-pass-96mffmfh4k
</code></pre></div>
<h2 id=what-s-next>What's next</h2>
<ul>
<li>进一步阅读 <a href=/zh/docs/concepts/configuration/secret/>Secret 概念</a></li>
<li>了解如何<a href=/zh/docs/tasks/configmap-secret/managing-secret-using-kubectl/>使用 <code>kubectl</code> 命令管理 Secret</a></li>
<li>了解如何<a href=/zh/docs/tasks/configmap-secret/managing-secret-using-config-file/>使用配置文件管理 Secret</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-866924fa095f897ede8dfdcab9e97942>8 - 给应用注入数据</h1>
<div class=lead>给你的工作负载 Pod 指定配置和其他数据。</div>
</div>
<div class=td-content>
<h1 id=pg-c9af1e81bb6e109f6c41febe44f0931b>8.1 - 为容器设置启动时要执行的命令和参数</h1>
<p>本页将展示如何为 <a class=glossary-tooltip title="Pod 表示您的集群上一组正在运行的容器。" data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a>
中容器设置启动时要执行的命令及其参数。</p>
<h2 id=before-you-begin>Before you begin</h2>
<p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li>
</ul>
To check the version, enter <code>kubectl version</code>.
</p>
<h2 id=创建-pod-时设置命令及参数>创建 Pod 时设置命令及参数</h2>
<p>创建 Pod 时，可以为其下的容器设置启动时要执行的命令及其参数。如果要设置命令，就填写在配置文件的 <code>command</code> 字段下，如果要设置命令的参数，就填写在配置文件的 <code>args</code> 字段下。一旦 Pod 创建完成，该命令及其参数就无法再进行更改了。</p>
<p>如果在配置文件中设置了容器启动时要执行的命令及其参数，那么容器镜像中自带的命令与参数将会被覆盖而不再执行。如果配置文件中只是设置了参数，却没有设置其对应的命令，那么容器镜像中自带的命令会使用该新参数作为其执行时的参数。</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 在有些容器运行时中，<code>command</code> 字段对应 <code>entrypoint</code>，请参阅下面的
<a href=#notes>说明事项</a>。
</div>
<p>本示例中，将创建一个只包含单个容器的 Pod。在 Pod 配置文件中设置了一个命令与两个参数：</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/pods/commands.yaml download=pods/commands.yaml><code>pods/commands.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-commands-yaml')" title="Copy pods/commands.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-commands-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>command-demo<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>purpose</span>:<span style=color:#bbb> </span>demonstrate-command<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>command-demo-container<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>debian<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;printenv&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;HOSTNAME&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;KUBERNETES_PORT&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>OnFailure<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<ol>
<li>
<p>基于 YAML 文件创建一个 Pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/pods/commands.yaml
</code></pre></div></li>
</ol>
<ol start=2>
<li>
<p>获取正在运行的 Pods：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods
</code></pre></div>
<p>查询结果显示在 command-demo 这个 Pod 下运行的容器已经启动完成。</p>
</li>
</ol>
<ol start=3>
<li>
<p>如果要获取容器启动时执行命令的输出结果，可以通过 Pod 的日志进行查看：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl logs command-demo
</code></pre></div>
<p>日志中显示了 HOSTNAME 与 KUBERNETES_PORT 这两个环境变量的值：</p>
<pre><code>command-demo
tcp://10.3.240.1:443
</code></pre></li>
</ol>
<h2 id=使用环境变量来设置参数>使用环境变量来设置参数</h2>
<p>在上面的示例中，我们直接将一串字符作为命令的参数。除此之外，我们还可以将环境变量作为命令的参数。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>MESSAGE<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;hello world&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;/bin/echo&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;$(MESSAGE)&#34;</span>]<span style=color:#bbb>
</span></code></pre></div>
<p>这意味着你可以将那些用来设置环境变量的方法应用于设置命令的参数，其中包括了
<a href=/zh/docs/tasks/configure-pod-container/configure-pod-configmap/>ConfigMaps</a> 与
<a href=/zh/docs/concepts/configuration/secret/>Secrets</a>。</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 环境变量需要加上括号，类似于 <code>"$(VAR)"</code>。这是在 <code>command</code> 或 <code>args</code> 字段使用变量的格式要求。
</div>
<h2 id=在-shell-来执行命令>在 Shell 来执行命令</h2>
<p>有时候，你需要在 Shell 脚本中运行命令。
例如，你要执行的命令可能由多个命令组合而成，或者它就是一个 Shell 脚本。
这时，就可以通过如下方式在 Shell 中执行命令：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>command: <span style=color:#666>[</span><span style=color:#b44>&#34;/bin/sh&#34;</span><span style=color:#666>]</span>
args: <span style=color:#666>[</span><span style=color:#b44>&#34;-c&#34;</span>, <span style=color:#b44>&#34;while true; do echo hello; sleep 10;done&#34;</span><span style=color:#666>]</span>
</code></pre></div><h2 id=what-s-next>What's next</h2>
<ul>
<li>进一步了解<a href=/zh/docs/tasks/>配置 Pod 和容器</a></li>
<li>进一步了解<a href=/zh/docs/tasks/debug-application-cluster/get-shell-running-container/>在容器中运行命令</a></li>
<li>参阅 <a href=/docs/reference/generated/kubernetes-api/v1.23/#container-v1-core>Container</a>
API 资源</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-82c93897176489678232542102daea40>8.2 - 为容器设置环境变量</h1>
<p>本页将展示如何为 kubernetes Pod 下的容器设置环境变量。</p>
<h2 id=before-you-begin>Before you begin</h2>
<p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li>
</ul>
<h2 id=为容器设置一个环境变量>为容器设置一个环境变量</h2>
<p>创建 Pod 时，可以为其下的容器设置环境变量。通过配置文件的 <code>env</code> 或者 <code>envFrom</code> 字段来设置环境变量。</p>
<p>本示例中，将创建一个只包含单个容器的 Pod。Pod 的配置文件中设置环境变量的名称为 <code>DEMO_GREETING</code>，
其值为 <code>"Hello from the environment"</code>。下面是 Pod 的配置清单：</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/pods/inject/envars.yaml download=pods/inject/envars.yaml><code>pods/inject/envars.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-inject-envars-yaml')" title="Copy pods/inject/envars.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-inject-envars-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>envar-demo<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>purpose</span>:<span style=color:#bbb> </span>demonstrate-envars<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>envar-demo-container<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>gcr.io/google-samples/node-hello:1.0<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>DEMO_GREETING<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;Hello from the environment&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>DEMO_FAREWELL<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;Such a sweet sorrow&#34;</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<ol>
<li>
<p>基于配置清单创建一个 Pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/pods/inject/envars.yaml
</code></pre></div></li>
</ol>
<ol start=2>
<li>
<p>获取一下当前正在运行的 Pods 信息：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods -l <span style=color:#b8860b>purpose</span><span style=color:#666>=</span>demonstrate-envars
</code></pre></div>
<p>查询结果应为：</p>
<pre><code>NAME            READY     STATUS    RESTARTS   AGE
envar-demo      1/1       Running   0          9s
</code></pre></li>
</ol>
<ol start=3>
<li>
<p>列出 Pod 容器的环境变量：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#a2f>exec</span> envar-demo -- printenv
</code></pre></div>
<p>打印结果应为：</p>
<pre><code>NODE_VERSION=4.4.2
EXAMPLE_SERVICE_PORT_8080_TCP_ADDR=10.3.245.237
HOSTNAME=envar-demo
...
DEMO_GREETING=Hello from the environment
DEMO_FAREWELL=Such a sweet sorrow
</code></pre></li>
</ol>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 通过 <code>env</code> 或 <code>envFrom</code> 字段设置的环境变量将覆盖容器镜像中指定的所有环境变量。
</div>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 环境变量可以互相引用，但是顺序很重要。
使用在相同上下文中定义的其他变量的变量必须在列表的后面。
同样，请避免使用循环引用。
</div>
<h2 id=在配置中使用环境变量>在配置中使用环境变量</h2>
<p>您在 Pod 的配置中定义的环境变量可以在配置的其他地方使用，
例如可用在为 Pod 的容器设置的命令和参数中。
在下面的示例配置中，环境变量 <code>GREETING</code> ，<code>HONORIFIC</code> 和 <code>NAME</code> 分别设置为 <code>Warm greetings to</code> ，
<code>The Most Honorable</code> 和 <code>Kubernetes</code>。然后这些环境变量在传递给容器 <code>env-print-demo</code> 的 CLI 参数中使用。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>print-greeting<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>env-print-demo<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>bash<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>GREETING<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;Warm greetings to&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>HONORIFIC<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;The Most Honorable&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>NAME<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;Kubernetes&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;echo&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;$(GREETING) $(HONORIFIC) $(NAME)&#34;</span>]<span style=color:#bbb>
</span></code></pre></div>
<p>创建后，命令 <code>echo Warm greetings to The Most Honorable Kubernetes</code> 将在容器中运行。</p>
<h2 id=what-s-next>What's next</h2>
<ul>
<li>进一步了解<a href=/zh/docs/tasks/inject-data-application/environment-variable-expose-pod-information/>环境变量</a></li>
<li>进一步了解<a href=/zh/docs/concepts/configuration/secret/#using-secrets-as-environment-variables>通过环境变量来使用 Secret</a></li>
<li>关于 <a href=/docs/reference/generated/kubernetes-api/v1.23/#envvarsource-v1-core>EnvVarSource</a> 资源的信息。</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-eff97c25c917cdb414eda016df0e2bca>8.3 - 定义相互依赖的环境变量</h1>
<p>本页展示了如何为 Kubernetes Pod 中的容器定义相互依赖的环境变量。</p>
<h2 id=before-you-begin>Before you begin</h2>
<p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li>
</ul>
<h2 id=define-an-environment-dependent-variable-for-a-container>为容器定义相互依赖的环境变量 </h2>
<p>当创建一个 Pod 时，你可以为运行在 Pod 中的容器设置相互依赖的环境变量。
设置相互依赖的环境变量，你就可以在配置清单文件的 <code>env</code> 的 <code>value</code> 中使用 $(VAR_NAME)。</p>
<p>在本练习中，你会创建一个单容器的 Pod。
此 Pod 的配置文件定义了一个已定义常用用法的相互依赖的环境变量。
下面是 Pod 的配置清单：</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/pods/inject/dependent-envars.yaml download=pods/inject/dependent-envars.yaml><code>pods/inject/dependent-envars.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-inject-dependent-envars-yaml')" title="Copy pods/inject/dependent-envars.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-inject-dependent-envars-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>dependent-envars-demo<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>dependent-envars-demo<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- while true; do echo -en &#39;\n&#39;; printf UNCHANGED_REFERENCE=$UNCHANGED_REFERENCE&#39;\n&#39;; printf SERVICE_ADDRESS=$SERVICE_ADDRESS&#39;\n&#39;;printf ESCAPED_REFERENCE=$ESCAPED_REFERENCE&#39;\n&#39;; sleep 30; done;<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- sh<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- -c<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox:1.28<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>SERVICE_PORT<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;80&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>SERVICE_IP<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;172.17.0.1&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>UNCHANGED_REFERENCE<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;$(PROTOCOL)://$(SERVICE_IP):$(SERVICE_PORT)&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>PROTOCOL<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;https&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>SERVICE_ADDRESS<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;$(PROTOCOL)://$(SERVICE_IP):$(SERVICE_PORT)&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>ESCAPED_REFERENCE<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;$$(PROTOCOL)://$(SERVICE_IP):$(SERVICE_PORT)&#34;</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<ol>
<li>
<p>依据清单创建 Pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/pods/inject/dependent-envars.yaml
</code></pre></div><pre><code>pod/dependent-envars-demo created
</code></pre>
</li>
<li>
<p>列出运行的 Pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods dependent-envars-demo
</code></pre></div><pre><code>NAME                      READY     STATUS    RESTARTS   AGE
dependent-envars-demo     1/1       Running   0          9s
</code></pre>
</li>
<li>
<p>检查 Pod 中运行容器的日志：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl logs pod/dependent-envars-demo
</code></pre></div><pre><code>
UNCHANGED_REFERENCE=$(PROTOCOL)://172.17.0.1:80
SERVICE_ADDRESS=https://172.17.0.1:80
ESCAPED_REFERENCE=$(PROTOCOL)://172.17.0.1:80
</code></pre></li>
</ol>
<p>如上所示，你已经定义了 <code>SERVICE_ADDRESS</code> 的正确依赖引用，
<code>UNCHANGED_REFERENCE</code> 的错误依赖引用，
并跳过了 <code>ESCAPED_REFERENCE</code> 的依赖引用。</p>
<p>如果环境变量被引用时已事先定义，则引用可以正确解析，
比如 <code>SERVICE_ADDRESS</code> 的例子。</p>
<p>当环境变量未定义或仅包含部分变量时，未定义的变量会被当做普通字符串对待，
比如 <code>UNCHANGED_REFERENCE</code> 的例子。
注意，解析不正确的环境变量通常不会阻止容器启动。</p>
<p><code>$(VAR_NAME)</code> 这样的语法可以用两个 <code>$</code> 转义，既：<code>$$(VAR_NAME)</code>。
无论引用的变量是否定义，转义的引用永远不会展开。
这一点可以从上面 <code>ESCAPED_REFERENCE</code> 的例子得到印证。</p>
<h2 id=what-s-next>What's next</h2>
<ul>
<li>进一步了解<a href=/zh/docs/tasks/inject-data-application/environment-variable-expose-pod-information/>环境变量</a>.</li>
<li>参阅 <a href=/docs/reference/generated/kubernetes-api/v1.23/#envvarsource-v1-core>EnvVarSource</a>.</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-66c0456fdbef5e5116dd606d1e6f73cc>8.4 - 通过环境变量将 Pod 信息呈现给容器</h1>
<p>此页面展示 Pod 如何使用环境变量把自己的信息呈现给 Pod 中运行的容器。
环境变量可以呈现 Pod 的字段和容器字段。</p>
<h2 id=before-you-begin>Before you begin</h2>
<p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li>
</ul>
To check the version, enter <code>kubectl version</code>.
</p>
<h2 id=downward-api>Downward API</h2>
<p>有两种方式可以将 Pod 和 Container 字段呈现给运行中的容器：</p>
<ul>
<li>环境变量</li>
<li><a href=/zh/docs/tasks/inject-data-application/downward-api-volume-expose-pod-information/#the-downward-api>卷文件</a></li>
</ul>
<p>这两种呈现 Pod 和 Container 字段的方式统称为 <em>Downward API</em>。</p>
<h2 id=用-pod-字段作为环境变量的值>用 Pod 字段作为环境变量的值</h2>
<p>在这个练习中，你将创建一个包含一个容器的 Pod。这是该 Pod 的配置文件：</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/pods/inject/dapi-envars-pod.yaml download=pods/inject/dapi-envars-pod.yaml><code>pods/inject/dapi-envars-pod.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-inject-dapi-envars-pod-yaml')" title="Copy pods/inject/dapi-envars-pod.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-inject-dapi-envars-pod-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>dapi-envars-fieldref<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-container<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/busybox<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#bbb> </span><span style=color:#b44>&#34;sh&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;-c&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- while true; do<span style=color:#bbb>
</span><span style=color:#bbb>          </span>echo -en &#39;\n&#39;;<span style=color:#bbb>
</span><span style=color:#bbb>          </span>printenv MY_NODE_NAME MY_POD_NAME MY_POD_NAMESPACE;<span style=color:#bbb>
</span><span style=color:#bbb>          </span>printenv MY_POD_IP MY_POD_SERVICE_ACCOUNT;<span style=color:#bbb>
</span><span style=color:#bbb>          </span>sleep 10;<span style=color:#bbb>
</span><span style=color:#bbb>        </span>done;<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>MY_NODE_NAME<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>fieldRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>fieldPath</span>:<span style=color:#bbb> </span>spec.nodeName<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>MY_POD_NAME<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>fieldRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>fieldPath</span>:<span style=color:#bbb> </span>metadata.name<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>MY_POD_NAMESPACE<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>fieldRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>fieldPath</span>:<span style=color:#bbb> </span>metadata.namespace<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>MY_POD_IP<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>fieldRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>fieldPath</span>:<span style=color:#bbb> </span>status.podIP<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>MY_POD_SERVICE_ACCOUNT<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>fieldRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>fieldPath</span>:<span style=color:#bbb> </span>spec.serviceAccountName<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>这个配置文件中，你可以看到五个环境变量。<code>env</code> 字段是一个
<a href=/docs/reference/generated/kubernetes-api/v1.23/#envvar-v1-core>EnvVars</a>.
对象的数组。
数组中第一个元素指定 <code>MY_NODE_NAME</code> 这个环境变量从 Pod 的 <code>spec.nodeName</code> 字段获取变量值。
同样，其它环境变量也是从 Pod 的字段获取它们的变量值。</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 本示例中的字段是 Pod 字段，不是 Pod 中 Container 的字段。
</div>
<p>创建Pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/pods/inject/dapi-envars-pod.yaml
</code></pre></div>
<p>验证 Pod 中的容器运行正常：</p>
<pre><code>kubectl get pods
</code></pre>
<p>查看容器日志：</p>
<pre><code>kubectl logs dapi-envars-fieldref
</code></pre>
<p>输出信息显示了所选择的环境变量的值：</p>
<pre><code>minikube
dapi-envars-fieldref
default
172.17.0.4
default
</code></pre>
<p>要了解为什么这些值在日志中，请查看配置文件中的<code>command</code> 和 <code>args</code>字段。
当容器启动时，它将五个环境变量的值写入 stdout。每十秒重复执行一次。</p>
<p>接下来，通过打开一个 Shell 进入 Pod 中运行的容器：</p>
<pre><code>kubectl exec -it dapi-envars-fieldref -- sh
</code></pre>
<p>在 Shell 中，查看环境变量：</p>
<pre><code>/# printenv
</code></pre>
<p>输出信息显示环境变量已经设置为 Pod 字段的值。</p>
<pre><code>MY_POD_SERVICE_ACCOUNT=default
...
MY_POD_NAMESPACE=default
MY_POD_IP=172.17.0.4
...
MY_NODE_NAME=minikube
...
MY_POD_NAME=dapi-envars-fieldref
</code></pre>
<h2 id=用-container-字段作为环境变量的值>用 Container 字段作为环境变量的值</h2>
<p>前面的练习中，你将 Pod 字段作为环境变量的值。
接下来这个练习中，你将用 Container 字段作为环境变量的值。这里是包含一个容器的 Pod 的配置文件：</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/pods/inject/dapi-envars-container.yaml download=pods/inject/dapi-envars-container.yaml><code>pods/inject/dapi-envars-container.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-inject-dapi-envars-container-yaml')" title="Copy pods/inject/dapi-envars-container.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-inject-dapi-envars-container-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>dapi-envars-resourcefieldref<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-container<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/busybox:1.24<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#bbb> </span><span style=color:#b44>&#34;sh&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;-c&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- while true; do<span style=color:#bbb>
</span><span style=color:#bbb>          </span>echo -en &#39;\n&#39;;<span style=color:#bbb>
</span><span style=color:#bbb>          </span>printenv MY_CPU_REQUEST MY_CPU_LIMIT;<span style=color:#bbb>
</span><span style=color:#bbb>          </span>printenv MY_MEM_REQUEST MY_MEM_LIMIT;<span style=color:#bbb>
</span><span style=color:#bbb>          </span>sleep 10;<span style=color:#bbb>
</span><span style=color:#bbb>        </span>done;<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;32Mi&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;125m&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;64Mi&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;250m&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>MY_CPU_REQUEST<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>resourceFieldRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>containerName</span>:<span style=color:#bbb> </span>test-container<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>resource</span>:<span style=color:#bbb> </span>requests.cpu<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>MY_CPU_LIMIT<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>resourceFieldRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>containerName</span>:<span style=color:#bbb> </span>test-container<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>resource</span>:<span style=color:#bbb> </span>limits.cpu<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>MY_MEM_REQUEST<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>resourceFieldRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>containerName</span>:<span style=color:#bbb> </span>test-container<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>resource</span>:<span style=color:#bbb> </span>requests.memory<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>MY_MEM_LIMIT<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>resourceFieldRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>containerName</span>:<span style=color:#bbb> </span>test-container<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>resource</span>:<span style=color:#bbb> </span>limits.memory<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>这个配置文件中，你可以看到四个环境变量。<code>env</code> 字段是一个
<a href=/docs/reference/generated/kubernetes-api/v1.23/#envvar-v1-core>EnvVars</a>.
对象的数组。数组中第一个元素指定 <code>MY_CPU_REQUEST</code> 这个环境变量从 Container 的 <code>requests.cpu</code>
字段获取变量值。同样，其它环境变量也是从 Container 的字段获取它们的变量值。</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 本例中使用的是 Container 的字段而不是 Pod 的字段。
</div>
<p>创建Pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/pods/inject/dapi-envars-container.yaml
</code></pre></div>
<p>验证 Pod 中的容器运行正常：</p>
<pre><code>kubectl get pods
</code></pre>
<p>查看容器日志：</p>
<pre><code>kubectl logs dapi-envars-resourcefieldref
</code></pre>
<p>输出信息显示了所选择的环境变量的值：</p>
<pre><code>1
1
33554432
67108864
</code></pre><h2 id=what-s-next>What's next</h2>
<ul>
<li><a href=/zh/docs/tasks/inject-data-application/define-environment-variable-container/>给容器定义环境变量</a></li>
<li><a href=/docs/reference/generated/kubernetes-api/v1.23/#podspec-v1-core>PodSpec</a></li>
<li><a href=/docs/reference/generated/kubernetes-api/v1.23/#container-v1-core>Container</a></li>
<li><a href=/docs/reference/generated/kubernetes-api/v1.23/#envvar-v1-core>EnvVar</a></li>
<li><a href=/docs/reference/generated/kubernetes-api/v1.23/#envvarsource-v1-core>EnvVarSource</a></li>
<li><a href=/docs/reference/generated/kubernetes-api/v1.23/#objectfieldselector-v1-core>ObjectFieldSelector</a></li>
<li><a href=/docs/reference/generated/kubernetes-api/v1.23/#resourcefieldselector-v1-core>ResourceFieldSelector</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-bcf93d1cd019501fd0b7649e9fbcaf60>8.5 - 通过文件将 Pod 信息呈现给容器</h1>
<p>此页面描述 Pod 如何使用 DownwardAPIVolumeFile 把自己的信息呈现给 Pod 中运行的容器。
DownwardAPIVolumeFile 可以呈现 Pod 的字段和容器字段。</p>
<h2 id=before-you-begin>Before you begin</h2>
<p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li>
</ul>
To check the version, enter <code>kubectl version</code>.
</p>
<h2 id=downward-api>Downward API</h2>
<p>有两种方式可以将 Pod 和 Container 字段呈现给运行中的容器：</p>
<ul>
<li><a href=/zh/docs/tasks/inject-data-application/environment-variable-expose-pod-information/#the-downward-api>环境变量</a></li>
<li>卷文件</li>
</ul>
<p>这两种呈现 Pod 和 Container 字段的方式都称为 <em>Downward API</em>。</p>
<h2 id=存储-pod-字段>存储 Pod 字段</h2>
<p>在这个练习中，你将创建一个包含一个容器的 Pod。Pod 的配置文件如下：</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/pods/inject/dapi-volume.yaml download=pods/inject/dapi-volume.yaml><code>pods/inject/dapi-volume.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-inject-dapi-volume-yaml')" title="Copy pods/inject/dapi-volume.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-inject-dapi-volume-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>kubernetes-downwardapi-volume-example<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>zone</span>:<span style=color:#bbb> </span>us-est-coast<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>cluster</span>:<span style=color:#bbb> </span>test-cluster1<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>rack</span>:<span style=color:#bbb> </span>rack-22<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>build</span>:<span style=color:#bbb> </span>two<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>builder</span>:<span style=color:#bbb> </span>john-doe<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>client-container<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/busybox<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;sh&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;-c&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- while true; do<span style=color:#bbb>
</span><span style=color:#bbb>          </span>if [[ -e /etc/podinfo/labels ]]; then<span style=color:#bbb>
</span><span style=color:#bbb>            </span>echo -en &#39;\n\n&#39;; cat /etc/podinfo/labels; fi;<span style=color:#bbb>
</span><span style=color:#bbb>          </span>if [[ -e /etc/podinfo/annotations ]]; then<span style=color:#bbb>
</span><span style=color:#bbb>            </span>echo -en &#39;\n\n&#39;; cat /etc/podinfo/annotations; fi;<span style=color:#bbb>
</span><span style=color:#bbb>          </span>sleep 5;<span style=color:#bbb>
</span><span style=color:#bbb>        </span>done;<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>podinfo<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/etc/podinfo<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>podinfo<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>downwardAPI</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>items</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span>- <span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;labels&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>fieldRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>fieldPath</span>:<span style=color:#bbb> </span>metadata.labels<span style=color:#bbb>
</span><span style=color:#bbb>          </span>- <span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;annotations&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>fieldRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>fieldPath</span>:<span style=color:#bbb> </span>metadata.annotations<span style=color:#bbb>
</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>在配置文件中，你可以看到 Pod 有一个 <code>downwardAPI</code> 类型的卷，并且挂载到容器中的
<code>/etc/podinfo</code> 目录。</p>
<p>查看 <code>downwardAPI</code> 下面的 <code>items</code> 数组。
每个数组元素都是一个
<a href=/docs/reference/generated/kubernetes-api/v1.23/#downwardapivolumefile-v1-core>DownwardAPIVolumeFile</a>
对象。
第一个元素指示 Pod 的 <code>metadata.labels</code> 字段的值保存在名为 <code>labels</code> 的文件中。
第二个元素指示 Pod 的 <code>annotations</code> 字段的值保存在名为 <code>annotations</code> 的文件中。</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 本示例中的字段是Pod字段，不是Pod中容器的字段。
</div>
<p>创建 Pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/pods/inject/dapi-volume.yaml
</code></pre></div>
<p>验证Pod中的容器运行正常：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods
</code></pre></div>
<p>查看容器的日志：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl logs kubernetes-downwardapi-volume-example
</code></pre></div>
<p>输出显示 <code>labels</code> 和 <code>annotations</code> 文件的内容：</p>
<pre><code>cluster=&quot;test-cluster1&quot;
rack=&quot;rack-22&quot;
zone=&quot;us-est-coast&quot;

build=&quot;two&quot;
builder=&quot;john-doe&quot;
</code></pre>
<p>进入 Pod 中运行的容器，打开一个 Shell：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#a2f>exec</span> -it kubernetes-downwardapi-volume-example -- sh
</code></pre></div>
<p>在该 Shell中，查看 <code>labels</code> 文件：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>/# cat /etc/podinfo/labels
</code></pre></div>
<p>输出显示 Pod 的所有标签都已写入 <code>labels</code> 文件。</p>
<pre><code>cluster=&quot;test-cluster1&quot;
rack=&quot;rack-22&quot;
zone=&quot;us-est-coast&quot;
</code></pre>
<p>同样，查看<code>annotations</code>文件：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>/# cat /etc/podinfo/annotations
</code></pre></div>
<p>查看<code>/etc/podinfo</code>目录下的文件：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>/# ls -laR /etc/podinfo
</code></pre></div>
<p>在输出中可以看到，<code>labels</code> 和 <code>annotations</code> 文件都在一个临时子目录中。
在这个例子，<code>..2982_06_02_21_47_53.299460680</code>。
在 <code>/etc/podinfo</code> 目录中，<code>..data</code> 是一个指向临时子目录
的符号链接。<code>/etc/podinfo</code> 目录中，<code>labels</code> 和 <code>annotations</code> 也是符号链接。</p>
<pre><code>drwxr-xr-x  ... Feb 6 21:47 ..2982_06_02_21_47_53.299460680
lrwxrwxrwx  ... Feb 6 21:47 ..data -&gt; ..2982_06_02_21_47_53.299460680
lrwxrwxrwx  ... Feb 6 21:47 annotations -&gt; ..data/annotations
lrwxrwxrwx  ... Feb 6 21:47 labels -&gt; ..data/labels

/etc/podinfo/..2982_06_02_21_47_53.299460680:
total 8
-rw-r--r--  ... Feb  6 21:47 annotations
-rw-r--r--  ... Feb  6 21:47 labels
</code></pre>
<p>用符号链接可实现元数据的动态原子性刷新；更新将写入一个新的临时目录，
然后通过使用<a href=http://man7.org/linux/man-pages/man2/rename.2.html>rename(2)</a>
完成 <code>..data</code> 符号链接的原子性更新。</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 如果容器以
<a href=/zh/docs/concepts/storage/volumes/#using-subpath>subPath</a>卷挂载方式来使用
Downward API，则该容器无法收到更新事件。
</div>
<p>退出 Shell：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>/# <span style=color:#a2f>exit</span>
</code></pre></div><h2 id=存储容器字段>存储容器字段</h2>
<p>前面的练习中，你将 Pod 字段保存到 DownwardAPIVolumeFile 中。
接下来这个练习，你将存储 Container 字段。这里是包含一个容器的 Pod 的配置文件：</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/pods/inject/dapi-volume-resources.yaml download=pods/inject/dapi-volume-resources.yaml><code>pods/inject/dapi-volume-resources.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-inject-dapi-volume-resources-yaml')" title="Copy pods/inject/dapi-volume-resources.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-inject-dapi-volume-resources-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>kubernetes-downwardapi-volume-example-2<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>client-container<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/busybox:1.24<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;sh&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;-c&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- while true; do<span style=color:#bbb>
</span><span style=color:#bbb>          </span>echo -en &#39;\n&#39;;<span style=color:#bbb>
</span><span style=color:#bbb>          </span>if [[ -e /etc/podinfo/cpu_limit ]]; then<span style=color:#bbb>
</span><span style=color:#bbb>            </span>echo -en &#39;\n&#39;; cat /etc/podinfo/cpu_limit; fi;<span style=color:#bbb>
</span><span style=color:#bbb>          </span>if [[ -e /etc/podinfo/cpu_request ]]; then<span style=color:#bbb>
</span><span style=color:#bbb>            </span>echo -en &#39;\n&#39;; cat /etc/podinfo/cpu_request; fi;<span style=color:#bbb>
</span><span style=color:#bbb>          </span>if [[ -e /etc/podinfo/mem_limit ]]; then<span style=color:#bbb>
</span><span style=color:#bbb>            </span>echo -en &#39;\n&#39;; cat /etc/podinfo/mem_limit; fi;<span style=color:#bbb>
</span><span style=color:#bbb>          </span>if [[ -e /etc/podinfo/mem_request ]]; then<span style=color:#bbb>
</span><span style=color:#bbb>            </span>echo -en &#39;\n&#39;; cat /etc/podinfo/mem_request; fi;<span style=color:#bbb>
</span><span style=color:#bbb>          </span>sleep 5;<span style=color:#bbb>
</span><span style=color:#bbb>        </span>done;<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;32Mi&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;125m&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;64Mi&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;250m&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>podinfo<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/etc/podinfo<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>podinfo<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>downwardAPI</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>items</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span>- <span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;cpu_limit&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>resourceFieldRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>containerName</span>:<span style=color:#bbb> </span>client-container<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>resource</span>:<span style=color:#bbb> </span>limits.cpu<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>divisor</span>:<span style=color:#bbb> </span>1m<span style=color:#bbb>
</span><span style=color:#bbb>          </span>- <span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;cpu_request&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>resourceFieldRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>containerName</span>:<span style=color:#bbb> </span>client-container<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>resource</span>:<span style=color:#bbb> </span>requests.cpu<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>divisor</span>:<span style=color:#bbb> </span>1m<span style=color:#bbb>
</span><span style=color:#bbb>          </span>- <span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;mem_limit&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>resourceFieldRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>containerName</span>:<span style=color:#bbb> </span>client-container<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>resource</span>:<span style=color:#bbb> </span>limits.memory<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>divisor</span>:<span style=color:#bbb> </span>1Mi<span style=color:#bbb>
</span><span style=color:#bbb>          </span>- <span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;mem_request&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>resourceFieldRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>containerName</span>:<span style=color:#bbb> </span>client-container<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>resource</span>:<span style=color:#bbb> </span>requests.memory<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>divisor</span>:<span style=color:#bbb> </span>1Mi<span style=color:#bbb>
</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>在这个配置文件中，你可以看到 Pod 有一个 <code>downwardAPI</code> 类型的卷，并且挂载到容器的
<code>/etc/podinfo</code> 目录。</p>
<p>查看 <code>downwardAPI</code> 下面的 <code>items</code> 数组。每个数组元素都是一个 DownwardAPIVolumeFile。</p>
<p>第一个元素指定名为 <code>client-container</code> 的容器中 <code>limits.cpu</code> 字段的值应保存在名为
<code>cpu_limit</code> 的文件中。</p>
<p>创建Pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/pods/inject/dapi-volume-resources.yaml
</code></pre></div>
<p>打开一个 Shell，进入 Pod 中运行的容器：</p>
<pre><code>kubectl exec -it kubernetes-downwardapi-volume-example-2 -- sh
</code></pre>
<p>在 Shell 中，查看 <code>cpu_limit</code> 文件：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>/# cat /etc/podinfo/cpu_limit
</code></pre></div>
<p>你可以使用同样的命令查看 <code>cpu_request</code>、<code>mem_limit</code> 和 <code>mem_request</code> 文件.</p>
<h2 id=downward-api-的能力>Downward API 的能力</h2>
<p>下面这些信息可以通过环境变量和 <code>downwardAPI</code> 卷提供给容器：</p>
<ul>
<li>能通过 <code>fieldRef</code> 获得的：
<ul>
<li><code>metadata.name</code> - Pod 名称</li>
<li><code>metadata.namespace</code> - Pod 名字空间</li>
<li><code>metadata.uid</code> - Pod 的 UID</li>
<li><code>metadata.labels['&lt;KEY>']</code> - Pod 标签 <code>&lt;KEY></code> 的值 (例如, <code>metadata.labels['mylabel']</code>）</li>
<li><code>metadata.annotations['&lt;KEY>']</code> - Pod 的注解 <code>&lt;KEY></code> 的值（例如, <code>metadata.annotations['myannotation']</code>）</li>
</ul>
</li>
</ul>
<ul>
<li>能通过 <code>resourceFieldRef</code> 获得的：
<ul>
<li>容器的 CPU 约束值</li>
<li>容器的 CPU 请求值</li>
<li>容器的内存约束值</li>
<li>容器的内存请求值</li>
<li>容器的巨页限制值（前提是启用了 <code>DownwardAPIHugePages</code> <a href=/zh/docs/reference/command-line-tools-reference/feature-gates/>特性门控</a>）</li>
<li>容器的巨页请求值（前提是启用了 <code>DownwardAPIHugePages</code> <a href=/zh/docs/reference/command-line-tools-reference/feature-gates/>特性门控</a>）</li>
<li>容器的临时存储约束值</li>
<li>容器的临时存储请求值</li>
</ul>
</li>
</ul>
<p>此外，以下信息可通过 <code>downwardAPI</code> 卷从 <code>fieldRef</code> 获得：</p>
<ul>
<li><code>metadata.labels</code> - Pod 的所有标签，以 <code>label-key="escaped-label-value"</code> 格式显示，每行显示一个标签</li>
<li><code>metadata.annotations</code> - Pod 的所有注解，以 <code>annotation-key="escaped-annotation-value"</code>
格式显示，每行显示一个标签</li>
</ul>
<p>以下信息可通过环境变量获得：</p>
<ul>
<li><code>status.podIP</code> - 节点 IP</li>
<li><code>spec.serviceAccountName</code> - Pod 服务帐号名称, 版本要求 v1.4.0-alpha.3</li>
<li><code>spec.nodeName</code> - 节点名称, 版本要求 v1.4.0-alpha.3</li>
<li><code>status.hostIP</code> - 节点 IP, 版本要求 v1.7.0-alpha.1</li>
</ul>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 如果容器未指定 CPU 和内存限制，则 Downward API 默认将节点可分配值
视为容器的 CPU 和内存限制。
</div>
<h2 id=投射键名到指定路径并且指定文件权限>投射键名到指定路径并且指定文件权限</h2>
<p>你可以将键名投射到指定路径并且指定每个文件的访问权限。
更多信息，请参阅<a href=/zh/docs/concepts/configuration/secret/>Secrets</a>.</p>
<h2 id=downward-api的动机>Downward API的动机</h2>
<p>对于容器来说，有时候拥有自己的信息是很有用的，可避免与 Kubernetes 过度耦合。
Downward API 使得容器使用自己或者集群的信息，而不必通过 Kubernetes 客户端或
API 服务器来获得。</p>
<p>一个例子是有一个现有的应用假定要用一个非常熟悉的环境变量来保存一个唯一标识。
一种可能是给应用增加处理层，但这样是冗余和易出错的，而且它违反了低耦合的目标。
更好的选择是使用 Pod 名称作为标识，把 Pod 名称注入这个环境变量中。</p>
<h2 id=what-s-next>What's next</h2>
<ul>
<li><a href=/docs/reference/generated/kubernetes-api/v1.23/#podspec-v1-core>PodSpec</a></li>
<li><a href=/docs/reference/generated/kubernetes-api/v1.23/#volume-v1-core>Volume</a></li>
<li><a href=/docs/reference/generated/kubernetes-api/v1.23/#downwardapivolumesource-v1-core>DownwardAPIVolumeSource</a></li>
<li><a href=/docs/reference/generated/kubernetes-api/v1.23/#downwardapivolumefile-v1-core>DownwardAPIVolumeFile</a></li>
<li><a href=/docs/reference/generated/kubernetes-api/v1.23/#resourcefieldselector-v1-core>ResourceFieldSelector</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-7f9454a1e775548c23ee5b300a9218a3>8.6 - 使用 Secret 安全地分发凭证</h1>
<p>本文展示如何安全地将敏感数据（如密码和加密密钥）注入到 Pods 中。</p>
<h2 id=before-you-begin>Before you begin</h2>
<p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li>
</ul>
<h3 id=将-secret-数据转换为-base-64-形式>将 secret 数据转换为 base-64 形式</h3>
<p>假设用户想要有两条 Secret 数据：用户名 <code>my-app</code> 和密码 <code>39528$vdg7Jb</code>。
首先使用 <a href=https://www.base64encode.org/>Base64 编码</a> 将用户名和密码转化为 base-64 形式。
下面是一个使用常用的 base64 程序的示例：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#a2f>echo</span> -n <span style=color:#b44>&#39;my-app&#39;</span> | base64
<span style=color:#a2f>echo</span> -n <span style=color:#b44>&#39;39528$vdg7Jb&#39;</span> | base64
</code></pre></div>
<p>结果显示 base-64 形式的用户名为 <code>bXktYXBw</code>，
base-64 形式的密码为 <code>Mzk1MjgkdmRnN0pi</code>。</p>
<div class="alert alert-warning caution callout" role=alert>
<strong>Caution:</strong> 使用你的操作系统所能信任的本地工具以降低使用外部工具的风险。
</div>
<h2 id=创建-secret>创建 Secret</h2>
<p>这里是一个配置文件，可以用来创建存有用户名和密码的 Secret:</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/pods/inject/secret.yaml download=pods/inject/secret.yaml><code>pods/inject/secret.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-inject-secret-yaml')" title="Copy pods/inject/secret.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-inject-secret-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-secret<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>username</span>:<span style=color:#bbb> </span>bXktYXBw<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>password</span>:<span style=color:#bbb> </span>Mzk1MjgkdmRnN0pi<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<ol>
<li>
<p>创建 Secret：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/pods/inject/secret.yaml
</code></pre></div></li>
<li>
<p>查看 Secret 相关信息：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get secret test-secret
</code></pre></div>
<p>输出：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>NAME          TYPE      DATA      AGE
test-secret   Opaque    <span style=color:#666>2</span>         1m
</code></pre></div></li>
<li>
<p>查看 Secret 相关的更多详细信息：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe secret test-secret
</code></pre></div>
<p>输出：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>Name:       test-secret
Namespace:  default
Labels:     &lt;none&gt;
Annotations:    &lt;none&gt;

Type:   Opaque

<span style=color:#b8860b>Data</span>
<span style=color:#666>====</span>
password:   <span style=color:#666>13</span> bytes
username:   <span style=color:#666>7</span>  bytes
</code></pre></div></li>
</ol>
<h3 id=直接用-kubectl-创建-secret>直接用 kubectl 创建 Secret</h3>
<p>如果你希望略过 Base64 编码的步骤，你也可以使用 <code>kubectl create secret</code>
命令直接创建 Secret。例如：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create secret generic test-secret --from-literal<span style=color:#666>=</span><span style=color:#b44>&#39;username=my-app&#39;</span> --from-literal<span style=color:#666>=</span><span style=color:#b44>&#39;password=39528$vdg7Jb&#39;</span>
</code></pre></div>
<p>这是一种更为方便的方法。
前面展示的详细分解步骤有助于了解究竟发生了什么事情。</p>
<h2 id=创建一个可以通过卷访问-secret-数据的-pod>创建一个可以通过卷访问 secret 数据的 Pod</h2>
<p>这里是一个可以用来创建 pod 的配置文件：</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/pods/inject/secret-pod.yaml download=pods/inject/secret-pod.yaml><code>pods/inject/secret-pod.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-inject-secret-pod-yaml')" title="Copy pods/inject/secret-pod.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-inject-secret-pod-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-test-pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-container<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># name must match the volume name below</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-volume<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/etc/secret-volume<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># The secret data is exposed to Containers in the Pod through a Volume.</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-volume<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>secret</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>secretName</span>:<span style=color:#bbb> </span>test-secret<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<ol>
<li>
<p>创建 Pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create -f secret-pod.yaml
</code></pre></div></li>
<li>
<p>确认 Pod 正在运行：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod secret-test-pod
</code></pre></div><p>输出：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>NAME              READY     STATUS    RESTARTS   AGE
secret-test-pod   1/1       Running   <span style=color:#666>0</span>          42m
</code></pre></div></li>
<li>
<p>获取一个 shell 进入 Pod 中运行的容器：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#a2f>exec</span> -it secret-test-pod -- /bin/bash
</code></pre></div></li>
<li>
<p>Secret 数据通过挂载在 <code>/etc/secret-volume</code> 目录下的卷暴露在容器中。</p>
<p>在 shell 中，列举 <code>/etc/secret-volume</code> 目录下的文件：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>ls /etc/secret-volume
</code></pre></div>
<p>输出包含两个文件，每个对应一个 Secret 数据条目：</p>
<pre><code>password username
</code></pre></li>
<li>
<p>在 Shell 中，显示 <code>username</code> 和 <code>password</code> 文件的内容：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># 在容器中 Shell 运行下面命令</span>
<span style=color:#a2f>echo</span> <span style=color:#b44>&#34;</span><span style=color:#a2f;font-weight:700>$(</span>cat /etc/secret-volume/username<span style=color:#a2f;font-weight:700>)</span><span style=color:#b44>&#34;</span>
<span style=color:#a2f>echo</span> <span style=color:#b44>&#34;</span><span style=color:#a2f;font-weight:700>$(</span>cat /etc/secret-volume/password<span style=color:#a2f;font-weight:700>)</span><span style=color:#b44>&#34;</span>
</code></pre></div>
<p>输出为用户名和密码：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>my-app
39528<span style=color:#b8860b>$vdg7Jb</span>
</code></pre></div></li>
</ol>
<h2 id=使用-secret-数据定义容器变量>使用 Secret 数据定义容器变量</h2>
<h3 id=使用来自-secret-中的数据定义容器变量>使用来自 Secret 中的数据定义容器变量</h3>
<ul>
<li>
<p>定义环境变量为 Secret 中的键值偶对：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create secret generic backend-user --from-literal<span style=color:#666>=</span>backend-username<span style=color:#666>=</span><span style=color:#b44>&#39;backend-admin&#39;</span>
</code></pre></div></li>
</ul>
<ul>
<li>
<p>在 Pod 规约中，将 Secret 中定义的值 <code>backend-username</code> 赋给 <code>SECRET_USERNAME</code> 环境变量</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/pods/inject/pod-single-secret-env-variable.yaml download=pods/inject/pod-single-secret-env-variable.yaml><code>pods/inject/pod-single-secret-env-variable.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-inject-pod-single-secret-env-variable-yaml')" title="Copy pods/inject/pod-single-secret-env-variable.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-inject-pod-single-secret-env-variable-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>env-single-secret<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>envars-test-container<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>SECRET_USERNAME<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>secretKeyRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>backend-user<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>backend-username<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
</li>
</ul>
<ul>
<li>
<p>创建 Pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create -f https://k8s.io/examples/pods/inject/pod-single-secret-env-variable.yaml
</code></pre></div></li>
</ul>
<ul>
<li>
<p>在 Shell 中，显示容器环境变量 <code>SECRET_USERNAME</code> 的内容：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#a2f>exec</span> -i -t env-single-secret -- /bin/sh -c <span style=color:#b44>&#39;echo $SECRET_USERNAME&#39;</span>
</code></pre></div><p>输出为：</p>
<pre><code>backend-admin
</code></pre></li>
</ul>
<h3 id=使用来自多个-secret-的数据定义环境变量>使用来自多个 Secret 的数据定义环境变量</h3>
<ul>
<li>
<p>和前面的例子一样，先创建 Secret：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create secret generic backend-user --from-literal<span style=color:#666>=</span>backend-username<span style=color:#666>=</span><span style=color:#b44>&#39;backend-admin&#39;</span>
kubectl create secret generic db-user --from-literal<span style=color:#666>=</span>db-username<span style=color:#666>=</span><span style=color:#b44>&#39;db-admin&#39;</span>
</code></pre></div></li>
</ul>
<ul>
<li>
<p>在 Pod 规约中定义环境变量：</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/pods/inject/pod-multiple-secret-env-variable.yaml download=pods/inject/pod-multiple-secret-env-variable.yaml><code>pods/inject/pod-multiple-secret-env-variable.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-inject-pod-multiple-secret-env-variable-yaml')" title="Copy pods/inject/pod-multiple-secret-env-variable.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-inject-pod-multiple-secret-env-variable-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>envvars-multiple-secrets<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>envars-test-container<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>BACKEND_USERNAME<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>secretKeyRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>backend-user<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>backend-username<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>DB_USERNAME<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>secretKeyRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>db-user<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>db-username<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
</li>
</ul>
<ul>
<li>
<p>创建 Pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create -f https://k8s.io/examples/pods/inject/pod-multiple-secret-env-variable.yaml
</code></pre></div></li>
</ul>
<ul>
<li>
<p>在你的 Shell 中，显示容器环境变量的内容：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#a2f>exec</span> -i -t envvars-multiple-secrets -- /bin/sh -c <span style=color:#b44>&#39;env | grep _USERNAME&#39;</span>
</code></pre></div><p>输出：</p>
<pre><code>DB_USERNAME=db-admin
BACKEND_USERNAME=backend-admin
</code></pre></li>
</ul>
<h2 id=将-secret-中的所有键值偶对定义为环境变量>将 Secret 中的所有键值偶对定义为环境变量</h2>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 此功能在 Kubernetes 1.6 版本之后可用。
</div>
<ul>
<li>
<p>创建包含多个键值偶对的 Secret：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create secret generic test-secret --from-literal<span style=color:#666>=</span><span style=color:#b8860b>username</span><span style=color:#666>=</span><span style=color:#b44>&#39;my-app&#39;</span> --from-literal<span style=color:#666>=</span><span style=color:#b8860b>password</span><span style=color:#666>=</span><span style=color:#b44>&#39;39528$vdg7Jb&#39;</span>
</code></pre></div></li>
</ul>
<ul>
<li>
<p>使用 <code>envFrom</code> 来将 Secret 中的所有数据定义为环境变量。
Secret 中的键名成为容器中的环境变量名：</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/pods/inject/pod-secret-envFrom.yaml download=pods/inject/pod-secret-envFrom.yaml><code>pods/inject/pod-secret-envFrom.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-inject-pod-secret-envfrom-yaml')" title="Copy pods/inject/pod-secret-envFrom.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-inject-pod-secret-envfrom-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>envfrom-secret<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>envars-test-container<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>envFrom</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>secretRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-secret<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
</li>
</ul>
<ul>
<li>
<p>创建 Pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create -f https://k8s.io/examples/pods/inject/pod-secret-envFrom.yaml
</code></pre></div></li>
</ul>
<ul>
<li>
<p>在 Shell 中，显示环境变量 <code>username</code> 和 <code>password</code> 的内容：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#a2f>exec</span> -i -t envfrom-secret -- /bin/sh -c <span style=color:#b44>&#39;echo &#34;username: $username\npassword: $password\n&#34;&#39;</span>
</code></pre></div><p>输出为：</p>
<pre><code>username: my-app
password: 39528$vdg7Jb
</code></pre></li>
</ul>
<h3 id=参考>参考</h3>
<ul>
<li><a href=/docs/api-reference/v1.23/#secret-v1-core>Secret</a></li>
<li><a href=/docs/api-reference/v1.23/#volume-v1-core>Volume</a></li>
<li><a href=/docs/api-reference/v1.23/#pod-v1-core>Pod</a></li>
</ul>
<h2 id=what-s-next>What's next</h2>
<ul>
<li>进一步了解 <a href=/zh/docs/concepts/configuration/secret/>Secret</a>。</li>
<li>了解 <a href=/zh/docs/concepts/storage/volumes/>Volumes</a>。</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-a78a5e7e765fd8c49c8f7c0d72499f72>9 - 运行应用</h1>
<div class=lead>运行和管理无状态和有状态的应用程序。</div>
</div>
<div class=td-content>
<h1 id=pg-790ea02857492b3a822e981e93e3a98b>9.1 - 使用 Deployment 运行一个无状态应用</h1>
<p>本文介绍如何通过 Kubernetes Deployment 对象去运行一个应用.</p>
<h2 id=objectives>Objectives</h2>
<ul>
<li>创建一个 nginx Deployment.</li>
<li>使用 kubectl 列举关于 Deployment 的信息.</li>
<li>更新 Deployment。</li>
</ul>
<h2 id=before-you-begin>Before you begin</h2>
<p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li>
</ul>
Your Kubernetes server must be at or later than version v1.9.
To check the version, enter <code>kubectl version</code>.
</p>
<h2 id=创建并了解一个-nginx-deployment>创建并了解一个 nginx Deployment</h2>
<p>你可以通过创建一个 Kubernetes Deployment 对象来运行一个应用, 且你可以在一个
YAML 文件中描述 Deployment。例如, 下面这个 YAML 文件描述了一个运行 nginx:1.14.2
Docker 镜像的 Deployment：</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/application/deployment.yaml download=application/deployment.yaml><code>application/deployment.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('application-deployment-yaml')" title="Copy application/deployment.yaml to clipboard">
</img>
</div>
<div class=includecode id=application-deployment-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-deployment<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>2</span><span style=color:#bbb> </span><span style=color:#080;font-style:italic># tells deployment to run 2 pods matching the template</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.14.2<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<ol>
<li>
<p>通过 YAML 文件创建一个 Deployment：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/application/deployment.yaml
</code></pre></div></li>
</ol>
<ol start=2>
<li>
<p>显示 Deployment 相关信息：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe deployment nginx-deployment
</code></pre></div>
<p>输出类似于这样：</p>
<pre><code>Name:     nginx-deployment
Namespace:    default
CreationTimestamp:  Tue, 30 Aug 2016 18:11:37 -0700
Labels:     app=nginx
Annotations:    deployment.kubernetes.io/revision=1
Selector:   app=nginx
Replicas:   2 desired | 2 updated | 2 total | 2 available | 0 unavailable
StrategyType:   RollingUpdate
MinReadySeconds:  0
RollingUpdateStrategy:  1 max unavailable, 1 max surge
Pod Template:
  Labels:       app=nginx
  Containers:
   nginx:
    Image:              nginx:1.7.9
    Port:               80/TCP
    Environment:        &lt;none&gt;
    Mounts:             &lt;none&gt;
  Volumes:              &lt;none&gt;
Conditions:
  Type          Status  Reason
  ----          ------  ------
  Available     True    MinimumReplicasAvailable
  Progressing   True    NewReplicaSetAvailable
OldReplicaSets:   &lt;none&gt;
NewReplicaSet:    nginx-deployment-1771418926 (2/2 replicas created)
No events.
</code></pre></li>
</ol>
<ol start=3>
<li>
<p>列出 Deployment 创建的 Pods：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>nginx
</code></pre></div>
<p>输出类似于这样：</p>
<pre><code>NAME                                READY     STATUS    RESTARTS   AGE
nginx-deployment-1771418926-7o5ns   1/1       Running   0          16h
nginx-deployment-1771418926-r18az   1/1       Running   0          16h
</code></pre></li>
</ol>
<ol start=4>
<li>
<p>展示某一个 Pod 信息：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe pod &lt;pod-name&gt;
</code></pre></div>
<p>这里的 <code>&lt;pod-name></code> 是某一 Pod 的名称。</p>
</li>
</ol>
<h2 id=更新-deployment>更新 Deployment</h2>
<p>你可以通过更新一个新的 YAML 文件来更新 Deployment。下面的 YAML 文件指定该
Deployment 镜像更新为 nginx 1.16.1。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/application/deployment-update.yaml download=application/deployment-update.yaml><code>application/deployment-update.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('application-deployment-update-yaml')" title="Copy application/deployment-update.yaml to clipboard">
</img>
</div>
<div class=includecode id=application-deployment-update-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-deployment<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>2</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.16.1<span style=color:#bbb> </span><span style=color:#080;font-style:italic># Update the version of nginx from 1.14.2 to 1.16.1</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<ol>
<li>
<p>应用新的 YAML：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/application/deployment-update.yaml
</code></pre></div></li>
</ol>
<ol start=2>
<li>
<p>查看该 Deployment 以新的名称创建 Pods 同时删除旧的 Pods：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>nginx
</code></pre></div></li>
</ol>
<h2 id=通过增加副本数来扩缩应用>通过增加副本数来扩缩应用</h2>
<p>你可以通过应用新的 YAML 文件来增加 Deployment 中 Pods 的数量。
下面的 YAML 文件将 <code>replicas</code> 设置为 4，指定该 Deployment 应有 4 个 Pods：</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/application/deployment-scale.yaml download=application/deployment-scale.yaml><code>application/deployment-scale.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('application-deployment-scale-yaml')" title="Copy application/deployment-scale.yaml to clipboard">
</img>
</div>
<div class=includecode id=application-deployment-scale-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-deployment<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>4</span><span style=color:#bbb> </span><span style=color:#080;font-style:italic># Update the replicas from 2 to 4</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.14.2<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<ol>
<li>
<p>应用新的 YAML 文件：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/application/deployment-scale.yaml
</code></pre></div></li>
</ol>
<ol start=2>
<li>
<p>验证 Deployment 有 4 个 Pods：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>nginx
</code></pre></div>
<p>输出的结果类似于:</p>
<pre><code>NAME                               READY     STATUS    RESTARTS   AGE
nginx-deployment-148880595-4zdqq   1/1       Running   0          25s
nginx-deployment-148880595-6zgi1   1/1       Running   0          25s
nginx-deployment-148880595-fxcez   1/1       Running   0          2m
nginx-deployment-148880595-rwovn   1/1       Running   0          2m
</code></pre></li>
</ol>
<h2 id=删除-deployment>删除 Deployment</h2>
<p>基于名称删除 Deployment：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete deployment nginx-deployment
</code></pre></div>
<h2 id=replicationcontrollers-旧的方式>ReplicationControllers -- 旧的方式</h2>
<p>创建一个多副本应用首选方法是使用 Deployment，Deployment 内部使用 ReplicaSet。
在 Deployment 和 ReplicaSet 被引入到 Kubernetes 之前，多副本应用通过
<a href=/zh/docs/concepts/workloads/controllers/replicationcontroller/>ReplicationController</a>
来配置。</p>
<h2 id=what-s-next>What's next</h2>
<ul>
<li>进一步了解 <a href=/zh/docs/concepts/workloads/controllers/deployment/>Deployment 对象</a>。</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-43398a6f5dc7ce19df59f5f4c2e7922d>9.2 - 运行一个单实例有状态应用</h1>
<p>本文介绍在 Kubernetes 中如何使用 PersistentVolume 和 Deployment 运行一个单实例有状态应用。该应用是 MySQL.</p>
<h2 id=objectives>Objectives</h2>
<ul>
<li>在你的环境中创建一个引用磁盘的 PersistentVolume</li>
<li>创建一个 MySQL Deployment.</li>
<li>在集群内以一个已知的 DNS 名称将 MySQL 暴露给其他 Pod</li>
</ul>
<h2 id=before-you-begin>Before you begin</h2>
<ul>
<li><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li>
</ul>
To check the version, enter <code>kubectl version</code>.
</li>
<li><p>你需要有一个带有默认 <a href=/zh/docs/concepts/storage/storage-classes/>StorageClass</a>的
<a href=/zh/docs/concepts/storage/dynamic-provisioning/>动态 PersistentVolume 供应程序</a>，
或者自己<a href=/zh/docs/concepts/storage/persistent-volumes/#provisioning>静态的提供 PersistentVolume</a>
来满足这里使用的 <a href=/zh/docs/concepts/storage/persistent-volumes/#persistentvolumeclaims>PersistentVolumeClaim</a>。</p>
</li>
</ul>
<h2 id=deploy-mysql>部署 MySQL </h2>
<p>你可以通过创建一个 Kubernetes Deployment 并使用 PersistentVolumeClaim 将其连接到
某已有的 PV 卷来运行一个有状态的应用。
例如，这里的 YAML 描述的是一个运行 MySQL 的 Deployment，其中引用了 PVC 申领。
文件为 /var/lib/mysql 定义了加载卷，并创建了一个 PVC 申领，寻找一个 20G 大小的卷。
该申领可以通过现有的满足需求的卷来满足，也可以通过动态供应卷的机制来满足。</p>
<p>注意：在配置的 YAML 文件中定义密码的做法是不安全的。具体安全解决方案请参考
<a href=/zh/docs/concepts/configuration/secret/>Kubernetes Secrets</a>.</p>
<p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/application/mysql/mysql-deployment.yaml download=application/mysql/mysql-deployment.yaml><code>application/mysql/mysql-deployment.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('application-mysql-mysql-deployment-yaml')" title="Copy application/mysql/mysql-deployment.yaml to clipboard">
</img>
</div>
<div class=includecode id=application-mysql-mysql-deployment-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>3306</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>clusterIP</span>:<span style=color:#bbb> </span>None<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>strategy</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Recreate<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>mysql:5.6<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:#080;font-style:italic># Use secret in real usage</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>MYSQL_ROOT_PASSWORD<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span>password<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>3306</span><span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysql-persistent-storage<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/var/lib/mysql<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysql-persistent-storage<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>persistentVolumeClaim</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>claimName</span>:<span style=color:#bbb> </span>mysql-pv-claim<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/application/mysql/mysql-pv.yaml download=application/mysql/mysql-pv.yaml><code>application/mysql/mysql-pv.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('application-mysql-mysql-pv-yaml')" title="Copy application/mysql/mysql-pv.yaml to clipboard">
</img>
</div>
<div class=includecode id=application-mysql-mysql-pv-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolume<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysql-pv-volume<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>local<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>storageClassName</span>:<span style=color:#bbb> </span>manual<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>capacity</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>20Gi<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- ReadWriteOnce<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>hostPath</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/mnt/data&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolumeClaim<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysql-pv-claim<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>storageClassName</span>:<span style=color:#bbb> </span>manual<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- ReadWriteOnce<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>20Gi<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
</p>
<ol>
<li>
<p>部署 YAML 文件中定义的 PV 和 PVC：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/application/mysql/mysql-pv.yaml
</code></pre></div></li>
<li>
<p>部署 YAML 文件中定义的 Deployment：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/application/mysql/mysql-deployment.yaml
</code></pre></div></li>
<li>
<p>展示 Deployment 相关信息:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe deployment mysql
</code></pre></div>
<p>输出类似于：</p>
<pre><code>Name:                 mysql
Namespace:            default
CreationTimestamp:    Tue, 01 Nov 2016 11:18:45 -0700
Labels:               app=mysql
Annotations:          deployment.kubernetes.io/revision=1
Selector:             app=mysql
Replicas:             1 desired | 1 updated | 1 total | 0 available | 1 unavailable
StrategyType:         Recreate
MinReadySeconds:      0
Pod Template:
  Labels:       app=mysql
  Containers:
   mysql:
    Image:      mysql:5.6
    Port:       3306/TCP
    Environment:
      MYSQL_ROOT_PASSWORD:      password
    Mounts:
      /var/lib/mysql from mysql-persistent-storage (rw)
  Volumes:
   mysql-persistent-storage:
    Type:       PersistentVolumeClaim (a reference to a PersistentVolumeClaim in the same namespace)
    ClaimName:  mysql-pv-claim
    ReadOnly:   false
    Conditions:
      Type          Status  Reason
      ----          ------  ------
      Available     False   MinimumReplicasUnavailable
      Progressing   True    ReplicaSetUpdated
      OldReplicaSets:       &lt;none&gt;
      NewReplicaSet:        mysql-63082529 (1/1 replicas created)
      Events:
        FirstSeen    LastSeen    Count    From                SubobjectPath    Type        Reason            Message
        ---------    --------    -----    ----                -------------    --------    ------            -------
        33s          33s         1        {deployment-controller }             Normal      ScalingReplicaSet Scaled up replica set mysql-63082529 to 1
</code></pre></li>
<li>
<p>列举出 Deployment 创建的 pods:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>mysql
</code></pre></div>
<p>输出类似于：</p>
<pre><code>NAME                   READY     STATUS    RESTARTS   AGE
mysql-63082529-2z3ki   1/1       Running   0          3m
</code></pre></li>
<li>
<p>查看 PersistentVolumeClaim：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe pvc mysql-pv-claim
</code></pre></div>
<p>输出类似于：</p>
<pre><code>Name:         mysql-pv-claim
Namespace:    default
StorageClass:
Status:       Bound
Volume:       mysql-pv-volume
Labels:       &lt;none&gt;
Annotations:    pv.kubernetes.io/bind-completed=yes
                pv.kubernetes.io/bound-by-controller=yes
Capacity:     20Gi
Access Modes: RWO
Events:       &lt;none&gt;
</code></pre></li>
</ol>
<h2 id=accessing-the-mysql-instance>访问 MySQL 实例 </h2>
<p>前面 YAML 文件中创建了一个允许集群内其他 Pod 访问的数据库服务。该服务中选项
<code>clusterIP: None</code> 让服务 DNS 名称直接解析为 Pod 的 IP 地址。
当在一个服务下只有一个 Pod 并且不打算增加 Pod 的数量这是最好的.</p>
<p>运行 MySQL 客户端以连接到服务器:</p>
<pre><code>kubectl run -it --rm --image=mysql:5.6 --restart=Never mysql-client -- mysql -h mysql -ppassword
</code></pre>
<p>此命令在集群内创建一个新的 Pod 并运行 MySQL 客户端，并通过 Service 连接到服务器。
如果连接成功，你就知道有状态的 MySQL 数据库正处于运行状态。</p>
<pre><code>Waiting for pod default/mysql-client-274442439-zyp6i to be running, status is Pending, pod ready: false
If you don't see a command prompt, try pressing enter.

mysql&gt;
</code></pre>
<h2 id=updating>更新 </h2>
<p>Deployment 中镜像或其他部分同往常一样可以通过 <code>kubectl apply</code> 命令更新。
以下是特定于有状态应用的一些注意事项:</p>
<ul>
<li>不要对应用进行规模扩缩。这里的设置仅适用于单实例应用。下层的 PersistentVolume
仅只能挂载到一个 Pod 上。对于集群级有状态应用，请参考
<a href=/zh/docs/concepts/workloads/controllers/statefulset/>StatefulSet 文档</a>.</li>
<li>在 Deployment 的 YAML 文件中使用 <code>strategy:</code> <code>type: Recreate</code>。
该选项指示 Kubernetes <em>不</em> 使用滚动升级。滚动升级无法工作，因为这里一次不能
运行多个 Pod。在使用更新的配置文件创建新的 Pod 前，<code>Recreate</code> 策略将
保证先停止第一个 Pod。</li>
</ul>
<h2 id=deleting-a-deployment>删除 Deployment </h2>
<p>通过名称删除部署的对象:</p>
<pre><code>kubectl delete deployment,svc mysql
kubectl delete pvc mysql-pv-claim
kubectl delete pv mysql-pv-volume
</code></pre>
<p>如果通过手动的方式供应 PersistentVolume, 那么也需要手动删除它以释放下层资源。
如果是用动态供应方式创建的 PersistentVolume，在删除 PersistentVolumeClaim 后
PersistentVolume 将被自动删除。
一些存储服务（比如 EBS 和 PD）也会在 PersistentVolume 被删除时自动回收下层资源。</p>
<h2 id=what-s-next>What's next</h2>
<ul>
<li>
<p>欲进一步了解 Deployment 对象，请参考 <a href=/zh/docs/concepts/workloads/controllers/deployment/>Deployment 对象</a></p>
</li>
<li>
<p>进一步了解<a href=/zh/docs/tasks/run-application/run-stateless-application-deployment/>部署应用</a></p>
</li>
<li>
<p>参阅 <a href=/docs/reference/generated/kubectl/kubectl-commands/#run>kubectl run 文档</a></p>
</li>
<li>
<p>参阅<a href=/zh/docs/concepts/storage/volumes/>卷</a>和<a href=/zh/docs/concepts/storage/persistent-volumes/>持久卷</a></p>
</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-95b3d561509c573e53bec2368264cf6a>9.3 - 运行一个有状态的应用程序</h1>
<p>本页展示如何使用 <a href=/zh/docs/concepts/workloads/controllers/statefulset/>StatefulSet</a>
控制器运行一个有状态的应用程序。此例是多副本的 MySQL 数据库。
示例应用的拓扑结构有一个主服务器和多个副本，使用异步的基于行（Row-Based）
的数据复制。</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> <strong>这不是生产环境下配置</strong>。
尤其注意，MySQL 设置都使用的是不安全的默认值，这是因为我们想把重点放在 Kubernetes
中运行有状态应用程序的一般模式上。
</div>
<h2 id=before-you-begin>Before you begin</h2>
<ul>
<li><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li>
</ul>
To check the version, enter <code>kubectl version</code>.
</li>
<li><p>你需要有一个带有默认 <a href=/zh/docs/concepts/storage/storage-classes/>StorageClass</a>的
<a href=/zh/docs/concepts/storage/dynamic-provisioning/>动态 PersistentVolume 供应程序</a>，
或者自己<a href=/zh/docs/concepts/storage/persistent-volumes/#provisioning>静态的提供 PersistentVolume</a>
来满足这里使用的 <a href=/zh/docs/concepts/storage/persistent-volumes/#persistentvolumeclaims>PersistentVolumeClaim</a>。</p>
</li>
</ul>
<ul>
<li>本教程假定你熟悉
<a href=/zh/docs/concepts/storage/persistent-volumes/>PersistentVolumes</a>
与 <a href=/zh/docs/concepts/workloads/controllers/statefulset/>StatefulSet</a>,
以及其他核心概念，例如 <a href=/zh/docs/concepts/workloads/pods/>Pod</a>、
<a href=/zh/docs/concepts/services-networking/service/>服务</a> 与
<a href=/zh/docs/tasks/configure-pod-container/configure-pod-configmap/>ConfigMap</a>.</li>
<li>熟悉 MySQL 会有所帮助，但是本教程旨在介绍对其他系统应该有用的常规模式。</li>
<li>您正在使用默认命名空间或不包含任何冲突对象的另一个命名空间。</li>
</ul>
<h2 id=objectives>Objectives</h2>
<ul>
<li>使用 StatefulSet 控制器部署多副本 MySQL 拓扑架构。</li>
<li>发送 MySQL 客户端请求</li>
<li>观察对宕机的抵抗力</li>
<li>扩缩 StatefulSet 的规模</li>
</ul>
<h2 id=deploy-mysql>部署 MySQL </h2>
<p>MySQL 示例部署包含一个 ConfigMap、两个 Service 与一个 StatefulSet。</p>
<h3 id=configmap>ConfigMap</h3>
<p>使用以下的 YAML 配置文件创建 ConfigMap ：</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/application/mysql/mysql-configmap.yaml download=application/mysql/mysql-configmap.yaml><code>application/mysql/mysql-configmap.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('application-mysql-mysql-configmap-yaml')" title="Copy application/mysql/mysql-configmap.yaml to clipboard">
</img>
</div>
<div class=includecode id=application-mysql-mysql-configmap-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>primary.cnf</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span><span style=color:#b44;font-style:italic>    # Apply this config only on the primary.
</span><span style=color:#b44;font-style:italic>    [mysqld]
</span><span style=color:#b44;font-style:italic>    log-bin
</span><span style=color:#b44;font-style:italic>    datadir=/var/lib/mysql/mysql</span><span style=color:#bbb>    
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replica.cnf</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span><span style=color:#b44;font-style:italic>    # Apply this config only on replicas.
</span><span style=color:#b44;font-style:italic>    [mysqld]
</span><span style=color:#b44;font-style:italic>    super-read-only
</span><span style=color:#b44;font-style:italic>    datadir=/var/lib/mysql/mysql</span><span style=color:#bbb>    
</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/application/mysql/mysql-configmap.yaml
</code></pre></div>
<p>这个 ConfigMap 提供 <code>my.cnf</code> 覆盖设置，使你可以独立控制 MySQL 主服务器和从服务器的配置。
在这里，你希望主服务器能够将复制日志提供给副本服务器，并且希望副本服务器拒绝任何不是通过
复制进行的写操作。</p>
<p>ConfigMap 本身没有什么特别之处，因而也不会出现不同部分应用于不同的 Pod 的情况。
每个 Pod 都会在初始化时基于 StatefulSet 控制器提供的信息决定要查看的部分。</p>
<h3 id=services>服务 </h3>
<p>使用以下 YAML 配置文件创建服务：</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/application/mysql/mysql-services.yaml download=application/mysql/mysql-services.yaml><code>application/mysql/mysql-services.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('application-mysql-mysql-services-yaml')" title="Copy application/mysql/mysql-services.yaml to clipboard">
</img>
</div>
<div class=includecode id=application-mysql-mysql-services-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#080;font-style:italic># Headless service for stable DNS entries of StatefulSet members.</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>3306</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>clusterIP</span>:<span style=color:#bbb> </span>None<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># Client service for connecting to any MySQL instance for reads.</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># For writes, you must instead connect to the primary: mysql-0.mysql.</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysql-read<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>3306</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/application/mysql/mysql-services.yaml
</code></pre></div>
<p>这个无头服务给 StatefulSet 控制器为集合中每个 Pod 创建的 DNS 条目提供了一个宿主。
因为无头服务名为 <code>mysql</code>，所以可以通过在同一 Kubernetes 集群和命名空间中的任何其他 Pod
内解析 <code>&lt;Pod 名称>.mysql</code> 来访问 Pod。</p>
<p>客户端服务称为 <code>mysql-read</code>，是一种常规服务，具有其自己的集群 IP。
该集群 IP 在报告就绪的所有MySQL Pod 之间分配连接。
可能的端点集合包括 MySQL 主节点和所有副本节点。</p>
<p>请注意，只有读查询才能使用负载平衡的客户端服务。
因为只有一个 MySQL 主服务器，所以客户端应直接连接到 MySQL 主服务器 Pod
（通过其在无头服务中的 DNS 条目）以执行写入操作。</p>
<h3 id=statefulset>StatefulSet</h3>
<p>最后，使用以下 YAML 配置文件创建 StatefulSet：</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/application/mysql/mysql-statefulset.yaml download=application/mysql/mysql-statefulset.yaml><code>application/mysql/mysql-statefulset.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('application-mysql-mysql-statefulset-yaml')" title="Copy application/mysql/mysql-statefulset.yaml to clipboard">
</img>
</div>
<div class=includecode id=application-mysql-mysql-statefulset-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StatefulSet<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>serviceName</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>initContainers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>init-mysql<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>mysql:5.7<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- bash<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:#b44>&#34;-c&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span>- |<span style=color:#b44;font-style:italic>
</span><span style=color:#b44;font-style:italic>          set -ex
</span><span style=color:#b44;font-style:italic>          # 基于 Pod 序号生成 MySQL 服务器的 ID。
</span><span style=color:#b44;font-style:italic>          [[ `hostname` =~ -([0-9]+)$ ]] || exit 1
</span><span style=color:#b44;font-style:italic>          ordinal=${BASH_REMATCH[1]}
</span><span style=color:#b44;font-style:italic>          echo [mysqld] &gt; /mnt/conf.d/server-id.cnf
</span><span style=color:#b44;font-style:italic>          # 添加偏移量以避免使用 server-id=0 这一保留值。
</span><span style=color:#b44;font-style:italic>          echo server-id=$((100 + $ordinal)) &gt;&gt; /mnt/conf.d/server-id.cnf
</span><span style=color:#b44;font-style:italic>          # Copy appropriate conf.d files from config-map to emptyDir.
</span><span style=color:#b44;font-style:italic>          # 将合适的 conf.d 文件从 config-map 复制到 emptyDir。
</span><span style=color:#b44;font-style:italic>          if [[ $ordinal -eq 0 ]]; then
</span><span style=color:#b44;font-style:italic>            cp /mnt/config-map/primary.cnf /mnt/conf.d/
</span><span style=color:#b44;font-style:italic>          else
</span><span style=color:#b44;font-style:italic>            cp /mnt/config-map/replica.cnf /mnt/conf.d/
</span><span style=color:#b44;font-style:italic>          fi</span><span style=color:#bbb>          
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>conf<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/mnt/conf.d<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>config-map<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/mnt/config-map<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>clone-mysql<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>gcr.io/google-samples/xtrabackup:1.0<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- bash<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:#b44>&#34;-c&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span>- |<span style=color:#b44;font-style:italic>
</span><span style=color:#b44;font-style:italic>          set -ex
</span><span style=color:#b44;font-style:italic>          # 如果已有数据，则跳过克隆。
</span><span style=color:#b44;font-style:italic>          [[ -d /var/lib/mysql/mysql ]] &amp;&amp; exit 0
</span><span style=color:#b44;font-style:italic>          # 跳过主实例（序号索引 0）的克隆。
</span><span style=color:#b44;font-style:italic>          [[ `hostname` =~ -([0-9]+)$ ]] || exit 1
</span><span style=color:#b44;font-style:italic>          ordinal=${BASH_REMATCH[1]}
</span><span style=color:#b44;font-style:italic>          [[ $ordinal -eq 0 ]] &amp;&amp; exit 0
</span><span style=color:#b44;font-style:italic>          # 从原来的对等节点克隆数据。
</span><span style=color:#b44;font-style:italic>          ncat --recv-only mysql-$(($ordinal-1)).mysql 3307 | xbstream -x -C /var/lib/mysql
</span><span style=color:#b44;font-style:italic>          # 准备备份。
</span><span style=color:#b44;font-style:italic>          xtrabackup --prepare --target-dir=/var/lib/mysql</span><span style=color:#bbb>          
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>data<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/var/lib/mysql<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>subPath</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>conf<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/etc/mysql/conf.d<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>mysql:5.7<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>MYSQL_ALLOW_EMPTY_PASSWORD<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;1&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>3306</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>data<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/var/lib/mysql<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>subPath</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>conf<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/etc/mysql/conf.d<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span>500m<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>1Gi<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>livenessProbe</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>exec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;mysqladmin&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;ping&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>initialDelaySeconds</span>:<span style=color:#bbb> </span><span style=color:#666>30</span><span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>periodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>10</span><span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>timeoutSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>5</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>readinessProbe</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>exec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:#080;font-style:italic># 检查我们是否可以通过 TCP 执行查询（skip-networking 是关闭的）。</span><span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;mysql&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;-h&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;127.0.0.1&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;-e&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;SELECT 1&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>initialDelaySeconds</span>:<span style=color:#bbb> </span><span style=color:#666>5</span><span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>periodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>2</span><span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>timeoutSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>xtrabackup<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>gcr.io/google-samples/xtrabackup:1.0<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>xtrabackup<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>3307</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- bash<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:#b44>&#34;-c&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span>- |<span style=color:#b44;font-style:italic>
</span><span style=color:#b44;font-style:italic>          set -ex
</span><span style=color:#b44;font-style:italic>          cd /var/lib/mysql
</span><span style=color:#b44;font-style:italic>
</span><span style=color:#b44;font-style:italic>          # 确定克隆数据的 binlog 位置（如果有的话）。
</span><span style=color:#b44;font-style:italic>          if [[ -f xtrabackup_slave_info &amp;&amp; &#34;x$(&lt;xtrabackup_slave_info)&#34; != &#34;x&#34; ]]; then
</span><span style=color:#b44;font-style:italic>            # XtraBackup 已经生成了部分的 “CHANGE MASTER TO” 查询
</span><span style=color:#b44;font-style:italic>            # 因为我们从一个现有副本进行克隆。(需要删除末尾的分号!)
</span><span style=color:#b44;font-style:italic>            cat xtrabackup_slave_info | sed -E &#39;s/;$//g&#39; &gt; change_master_to.sql.in
</span><span style=color:#b44;font-style:italic>            # 在这里要忽略 xtrabackup_binlog_info （它是没用的）。
</span><span style=color:#b44;font-style:italic>            rm -f xtrabackup_slave_info xtrabackup_binlog_info
</span><span style=color:#b44;font-style:italic>          elif [[ -f xtrabackup_binlog_info ]]; then
</span><span style=color:#b44;font-style:italic>            # 我们直接从主实例进行克隆。解析 binlog 位置。
</span><span style=color:#b44;font-style:italic>            [[ `cat xtrabackup_binlog_info` =~ ^(.*?)[[:space:]]+(.*?)$ ]] || exit 1
</span><span style=color:#b44;font-style:italic>            rm -f xtrabackup_binlog_info xtrabackup_slave_info
</span><span style=color:#b44;font-style:italic>            echo &#34;CHANGE MASTER TO MASTER_LOG_FILE=&#39;${BASH_REMATCH[1]}&#39;,\
</span><span style=color:#b44;font-style:italic>                  MASTER_LOG_POS=${BASH_REMATCH[2]}&#34; &gt; change_master_to.sql.in
</span><span style=color:#b44;font-style:italic>          fi
</span><span style=color:#b44;font-style:italic>
</span><span style=color:#b44;font-style:italic>          # 检查我们是否需要通过启动复制来完成克隆。
</span><span style=color:#b44;font-style:italic>          if [[ -f change_master_to.sql.in ]]; then
</span><span style=color:#b44;font-style:italic>            echo &#34;Waiting for mysqld to be ready (accepting connections)&#34;
</span><span style=color:#b44;font-style:italic>            until mysql -h 127.0.0.1 -e &#34;SELECT 1&#34;; do sleep 1; done
</span><span style=color:#b44;font-style:italic>
</span><span style=color:#b44;font-style:italic>            echo &#34;Initializing replication from clone position&#34;
</span><span style=color:#b44;font-style:italic>            mysql -h 127.0.0.1 \
</span><span style=color:#b44;font-style:italic>                  -e &#34;$(&lt;change_master_to.sql.in), \
</span><span style=color:#b44;font-style:italic>                          MASTER_HOST=&#39;mysql-0.mysql&#39;, \
</span><span style=color:#b44;font-style:italic>                          MASTER_USER=&#39;root&#39;, \
</span><span style=color:#b44;font-style:italic>                          MASTER_PASSWORD=&#39;&#39;, \
</span><span style=color:#b44;font-style:italic>                          MASTER_CONNECT_RETRY=10; \
</span><span style=color:#b44;font-style:italic>                        START SLAVE;&#34; || exit 1
</span><span style=color:#b44;font-style:italic>            # 如果容器重新启动，最多尝试一次。
</span><span style=color:#b44;font-style:italic>            mv change_master_to.sql.in change_master_to.sql.orig
</span><span style=color:#b44;font-style:italic>          fi
</span><span style=color:#b44;font-style:italic>
</span><span style=color:#b44;font-style:italic>          # 当对等点请求时，启动服务器发送备份。
</span><span style=color:#b44;font-style:italic>          exec ncat --listen --keep-open --send-only --max-conns=1 3307 -c \
</span><span style=color:#b44;font-style:italic>            &#34;xtrabackup --backup --slave-info --stream=xbstream --host=127.0.0.1 --user=root&#34;</span><span style=color:#bbb>          
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>data<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/var/lib/mysql<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>subPath</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>conf<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/etc/mysql/conf.d<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span>100m<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>100Mi<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>conf<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>emptyDir</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>config-map<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>configMap</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumeClaimTemplates</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>data<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;ReadWriteOnce&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>10Gi<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/application/mysql/mysql-statefulset.yaml
</code></pre></div>
<p>你可以通过运行以下命令查看启动进度：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>mysql --watch
</code></pre></div>
<p>一段时间后，你应该看到所有 3 个 Pod 进入 Running 状态：</p>
<pre><code>NAME      READY     STATUS    RESTARTS   AGE
mysql-0   2/2       Running   0          2m
mysql-1   2/2       Running   0          1m
mysql-2   2/2       Running   0          1m
</code></pre>
<p>输入 <strong>Ctrl+C</strong> 结束 watch 操作。
如果你看不到任何进度，确保已启用<a href=#%E5%87%86%E5%A4%87%E5%BC%80%E5%A7%8B>前提条件</a>
中提到的动态 PersistentVolume 预配器。</p>
<p>此清单使用多种技术来管理作为 StatefulSet 的一部分的有状态 Pod。
下一节重点介绍其中的一些技巧，以解释 StatefulSet 创建 Pod 时发生的状况。</p>
<h2 id=了解有状态的-pod-初始化>了解有状态的 Pod 初始化</h2>
<p>StatefulSet 控制器按序数索引顺序地每次启动一个 Pod。
它一直等到每个 Pod 报告就绪才再启动下一个 Pod。</p>
<p>此外，控制器为每个 Pod 分配一个唯一、稳定的名称，形如 <code>&lt;statefulset 名称>-&lt;序数索引></code>，
其结果是 Pods 名为 <code>mysql-0</code>、<code>mysql-1</code> 和 <code>mysql-2</code>。</p>
<p>上述 StatefulSet 清单中的 Pod 模板利用这些属性来执行 MySQL 副本的有序启动。</p>
<h3 id=生成配置>生成配置</h3>
<p>在启动 Pod 规约中的任何容器之前，Pod 首先按顺序运行所有的
<a href=/zh/docs/concepts/workloads/pods/init-containers/>Init 容器</a>。</p>
<p>第一个名为 <code>init-mysql</code> 的 Init 容器根据序号索引生成特殊的 MySQL 配置文件。</p>
<p>该脚本通过从 Pod 名称的末尾提取索引来确定自己的序号索引，而 Pod 名称由 <code>hostname</code> 命令返回。
然后将序数（带有数字偏移量以避免保留值）保存到 MySQL <code>conf.d</code> 目录中的文件 <code>server-id.cnf</code>。
这一操作将 StatefulSet 所提供的唯一、稳定的标识转换为 MySQL 服务器的 ID，
而这些 ID 也是需要唯一性、稳定性保证的。</p>
<p>通过将内容复制到 <code>conf.d</code> 中，<code>init-mysql</code> 容器中的脚本也可以应用 ConfigMap 中的
<code>primary.cnf</code> 或 <code>replica.cnf</code>。
由于示例部署结构由单个 MySQL 主节点和任意数量的副本节点组成，
因此脚本仅将序数 <code>0</code> 指定为主节点，而将其他所有节点指定为副本节点。</p>
<p>与 StatefulSet 控制器的
<a href=/zh/docs/concepts/workloads/controllers/statefulset/#deployment-and-scaling-guarantees>部署顺序保证</a>
相结合，
可以确保 MySQL 主服务器在创建副本服务器之前已准备就绪，以便它们可以开始复制。</p>
<h3 id=克隆现有数据>克隆现有数据</h3>
<p>通常，当新 Pod 作为副本节点加入集合时，必须假定 MySQL 主节点可能已经有数据。
还必须假设复制日志可能不会一直追溯到时间的开始。</p>
<p>这些保守的假设是允许正在运行的 StatefulSet 随时间扩大和缩小而不是固定在其初始大小的关键。</p>
<p>第二个名为 <code>clone-mysql</code> 的 Init 容器，第一次在带有空 PersistentVolume 的副本 Pod
上启动时，会在从属 Pod 上执行克隆操作。
这意味着它将从另一个运行中的 Pod 复制所有现有数据，使此其本地状态足够一致，
从而可以开始从主服务器复制。</p>
<p>MySQL 本身不提供执行此操作的机制，因此本示例使用了一种流行的开源工具 Percona XtraBackup。
在克隆期间，源 MySQL 服务器性能可能会受到影响。
为了最大程度地减少对 MySQL 主服务器的影响，该脚本指示每个 Pod 从序号较低的 Pod 中克隆。
可以这样做的原因是 StatefulSet 控制器始终确保在启动 Pod <code>N + 1</code> 之前 Pod <code>N</code> 已准备就绪。</p>
<h3 id=开始复制>开始复制</h3>
<p>Init 容器成功完成后，应用容器将运行。
MySQL Pod 由运行实际 <code>mysqld</code> 服务的 <code>mysql</code> 容器和充当
<a href=https://kubernetes.io/blog/2015/06/the-distributed-system-toolkit-patterns>辅助工具</a>
的 xtrabackup 容器组成。</p>
<p><code>xtrabackup</code> sidecar 容器查看克隆的数据文件，并确定是否有必要在副本服务器上初始化 MySQL 复制。
如果是这样，它将等待 <code>mysqld</code> 准备就绪，然后使用从 XtraBackup 克隆文件中提取的复制参数
执行 <code>CHANGE MASTER TO</code> 和 <code>START SLAVE</code> 命令。</p>
<p>一旦副本服务器开始复制后，它会记住其 MySQL 主服务器，并且如果服务器重新启动或
连接中断也会自动重新连接。
另外，因为副本服务器会以其稳定的 DNS 名称查找主服务器（<code>mysql-0.mysql</code>），
即使由于重新调度而获得新的 Pod IP，它们也会自动找到主服务器。</p>
<p>最后，开始复制后，<code>xtrabackup</code> 容器监听来自其他 Pod 的连接，处理其数据克隆请求。
如果 StatefulSet 扩大规模，或者下一个 Pod 失去其 PersistentVolumeClaim 并需要重新克隆，
则此服务器将无限期保持运行。</p>
<h2 id=发送客户端请求>发送客户端请求</h2>
<p>你可以通过运行带有 <code>mysql:5.7</code> 镜像的临时容器并运行 <code>mysql</code> 客户端二进制文件，
将测试查询发送到 MySQL 主服务器（主机名 <code>mysql-0.mysql</code>）。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl run mysql-client --image<span style=color:#666>=</span>mysql:5.7 -i --rm --restart<span style=color:#666>=</span>Never --<span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  mysql -h mysql-0.mysql <span style=color:#b44>&lt;&lt;EOF
</span><span style=color:#b44>CREATE DATABASE test;
</span><span style=color:#b44>CREATE TABLE test.messages (message VARCHAR(250));
</span><span style=color:#b44>INSERT INTO test.messages VALUES (&#39;hello&#39;);
</span><span style=color:#b44>EOF</span>
</code></pre></div>
<p>使用主机名 <code>mysql-read</code> 将测试查询发送到任何报告为就绪的服务器：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl run mysql-client --image<span style=color:#666>=</span>mysql:5.7 -i -t --rm --restart<span style=color:#666>=</span>Never --<span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  mysql -h mysql-read -e <span style=color:#b44>&#34;SELECT * FROM test.messages&#34;</span>
</code></pre></div>
<p>你应该获得如下输出：</p>
<pre><code>Waiting for pod default/mysql-client to be running, status is Pending, pod ready: false
+---------+
| message |
+---------+
| hello   |
+---------+
pod &quot;mysql-client&quot; deleted
</code></pre>
<p>为了演示 <code>mysql-read</code> 服务在服务器之间分配连接，你可以在循环中运行 <code>SELECT @@server_id</code>：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl run mysql-client-loop --image<span style=color:#666>=</span>mysql:5.7 -i -t --rm --restart<span style=color:#666>=</span>Never --<span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  bash -ic <span style=color:#b44>&#34;while sleep 1; do mysql -h mysql-read -e &#39;SELECT @@server_id,NOW()&#39;; done&#34;</span>
</code></pre></div>
<p>你应该看到报告的 <code>@@server_id</code> 发生随机变化，因为每次尝试连接时都可能选择了不同的端点：</p>
<pre><code>+-------------+---------------------+
| @@server_id | NOW()               |
+-------------+---------------------+
|         100 | 2006-01-02 15:04:05 |
+-------------+---------------------+
+-------------+---------------------+
| @@server_id | NOW()               |
+-------------+---------------------+
|         102 | 2006-01-02 15:04:06 |
+-------------+---------------------+
+-------------+---------------------+
| @@server_id | NOW()               |
+-------------+---------------------+
|         101 | 2006-01-02 15:04:07 |
+-------------+---------------------+
</code></pre>
<p>要停止循环时可以按 <strong>Ctrl+C</strong> ，但是让它在另一个窗口中运行非常有用，
这样你就可以看到以下步骤的效果。</p>
<h2 id=模拟-pod-和-node-的宕机时间>模拟 Pod 和 Node 的宕机时间</h2>
<p>为了证明从副本节点缓存而不是单个服务器读取数据的可用性提高，请在使 Pod 退出 Ready
状态时，保持上述 <code>SELECT @@server_id</code> 循环一直运行。</p>
<h3 id=破坏就绪态探测>破坏就绪态探测</h3>
<p><code>mysql</code> 容器的
<a href=/zh/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/#define-readiness-probes>就绪态探测</a>
运行命令 <code>mysql -h 127.0.0.1 -e 'SELECT 1'</code>，以确保服务器已启动并能够执行查询。</p>
<p>迫使就绪态探测失败的一种方法就是中止该命令：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#a2f>exec</span> mysql-2 -c mysql -- mv /usr/bin/mysql /usr/bin/mysql.off
</code></pre></div>
<p>此命令会进入 Pod <code>mysql-2</code> 的实际容器文件系统，重命名 <code>mysql</code> 命令，导致就绪态探测无法找到它。
几秒钟后， Pod 会报告其中一个容器未就绪。你可以通过运行以下命令进行检查：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod mysql-2
</code></pre></div>
<p>在 <code>READY</code> 列中查找 <code>1/2</code>：</p>
<pre><code>NAME      READY     STATUS    RESTARTS   AGE
mysql-2   1/2       Running   0          3m
</code></pre>
<p>此时，你应该会看到 <code>SELECT @@server_id</code> 循环继续运行，尽管它不再报告 <code>102</code>。
回想一下，<code>init-mysql</code> 脚本将 <code>server-id</code> 定义为 <code>100 + $ordinal</code>，
因此服务器 ID <code>102</code> 对应于 Pod <code>mysql-2</code>。</p>
<p>现在修复 Pod，几秒钟后它应该重新出现在循环输出中：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#a2f>exec</span> mysql-2 -c mysql -- mv /usr/bin/mysql.off /usr/bin/mysql
</code></pre></div>
<h3 id=删除-pods>删除 Pods</h3>
<p>如果删除了 Pod，则 StatefulSet 还会重新创建 Pod，类似于 ReplicaSet 对无状态 Pod 所做的操作。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete pod mysql-2
</code></pre></div>
<p>StatefulSet 控制器注意到不再存在 <code>mysql-2</code> Pod，于是创建一个具有相同名称并链接到相同
PersistentVolumeClaim 的新 Pod。
你应该看到服务器 ID <code>102</code> 从循环输出中消失了一段时间，然后又自行出现。</p>
<h3 id=drain-a-node>腾空节点 </h3>
<p>如果你的 Kubernetes 集群具有多个节点，则可以通过发出以下
<a href=/docs/reference/generated/kubectl/kubectl-commands/#drain>drain</a>
命令来模拟节点停机（就好像节点在被升级）。</p>
<p>首先确定 MySQL Pod 之一在哪个节点上：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod mysql-2 -o wide
</code></pre></div>
<p>节点名称应显示在最后一列中：</p>
<pre><code>NAME      READY     STATUS    RESTARTS   AGE       IP            NODE
mysql-2   2/2       Running   0          15m       10.244.5.27   kubernetes-node-9l2t
</code></pre>
<p>然后通过运行以下命令腾空节点，该命令将其保护起来，以使新的 Pod 不能调度到该节点，
然后逐出所有现有的 Pod。将 <code>&lt;节点名称></code> 替换为在上一步中找到的节点名称。</p>
<p>这可能会影响节点上的其他应用程序，因此最好 <strong>仅在测试集群中执行此操作</strong>。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl drain &lt;节点名称&gt; --force --delete-local-data --ignore-daemonsets
</code></pre></div>
<p>现在，你可以看到 Pod 被重新调度到其他节点上：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod mysql-2 -o wide --watch
</code></pre></div>
<p>它看起来应该像这样：</p>
<pre><code>NAME      READY   STATUS          RESTARTS   AGE       IP            NODE
mysql-2   2/2     Terminating     0          15m       10.244.1.56   kubernetes-node-9l2t
[...]
mysql-2   0/2     Pending         0          0s        &lt;none&gt;        kubernetes-node-fjlm
mysql-2   0/2     Init:0/2        0          0s        &lt;none&gt;        kubernetes-node-fjlm
mysql-2   0/2     Init:1/2        0          20s       10.244.5.32   kubernetes-node-fjlm
mysql-2   0/2     PodInitializing 0          21s       10.244.5.32   kubernetes-node-fjlm
mysql-2   1/2     Running         0          22s       10.244.5.32   kubernetes-node-fjlm
mysql-2   2/2     Running         0          30s       10.244.5.32   kubernetes-node-fjlm
</code></pre>
<p>再次，你应该看到服务器 ID <code>102</code> 从 <code>SELECT @@server_id</code> 循环输出
中消失一段时间，然后自行出现。</p>
<p>现在去掉节点保护（Uncordon），使其恢复为正常模式:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl uncordon &lt;节点名称&gt;
</code></pre></div>
<h2 id=扩展副本节点数量>扩展副本节点数量</h2>
<p>使用 MySQL 复制，你可以通过添加副本节点来扩展读取查询的能力。
使用 StatefulSet，你可以使用单个命令执行此操作：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl scale statefulset mysql --replicas<span style=color:#666>=</span><span style=color:#666>5</span>
</code></pre></div>
<p>查看新的 Pod 的运行情况：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>mysql --watch
</code></pre></div>
<p>一旦 Pod 启动，你应该看到服务器 IDs <code>103</code> 和 <code>104</code> 开始出现在 <code>SELECT @@server_id</code> 循环输出中。</p>
<p>你还可以验证这些新服务器在存在之前已添加了数据：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl run mysql-client --image<span style=color:#666>=</span>mysql:5.7 -i -t --rm --restart<span style=color:#666>=</span>Never --<span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  mysql -h mysql-3.mysql -e <span style=color:#b44>&#34;SELECT * FROM test.messages&#34;</span>
</code></pre></div><pre><code>Waiting for pod default/mysql-client to be running, status is Pending, pod ready: false
+---------+
| message |
+---------+
| hello   |
+---------+
pod &quot;mysql-client&quot; deleted
</code></pre>
<p>向下缩容操作也是很平滑的：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl scale statefulset mysql --replicas<span style=color:#666>=</span><span style=color:#666>3</span>
</code></pre></div>
<p>但是请注意，按比例扩大会自动创建新的 PersistentVolumeClaims，而按比例缩小不会自动删除这些 PVC。
这使你可以选择保留那些初始化的 PVC，以更快地进行缩放，或者在删除它们之前提取数据。</p>
<p>你可以通过运行以下命令查看此信息：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pvc -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>mysql
</code></pre></div>
<p>这表明，尽管将 StatefulSet 缩小为3，所有5个 PVC 仍然存在：</p>
<pre><code>NAME           STATUS    VOLUME                                     CAPACITY   ACCESSMODES   AGE
data-mysql-0   Bound     pvc-8acbf5dc-b103-11e6-93fa-42010a800002   10Gi       RWO           20m
data-mysql-1   Bound     pvc-8ad39820-b103-11e6-93fa-42010a800002   10Gi       RWO           20m
data-mysql-2   Bound     pvc-8ad69a6d-b103-11e6-93fa-42010a800002   10Gi       RWO           20m
data-mysql-3   Bound     pvc-50043c45-b1c5-11e6-93fa-42010a800002   10Gi       RWO           2m
data-mysql-4   Bound     pvc-500a9957-b1c5-11e6-93fa-42010a800002   10Gi       RWO           2m
</code></pre>
<p>如果你不打算重复使用多余的 PVC，则可以删除它们：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete pvc data-mysql-3
kubectl delete pvc data-mysql-4
</code></pre></div><h2 id=cleaning-up>Cleaning up</h2>
<ol>
<li>
<p>通过在终端上按 <strong>Ctrl+C</strong> 取消 <code>SELECT @@server_id</code> 循环，或从另一个终端运行以下命令：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete pod mysql-client-loop --now
</code></pre></div></li>
</ol>
<ol start=2>
<li>
<p>删除 StatefulSet。这也会开始终止 Pod。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete statefulset mysql
</code></pre></div></li>
</ol>
<ol start=3>
<li>
<p>验证 Pod 消失。他们可能需要一些时间才能完成终止。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>mysql
</code></pre></div>
<p>当上述命令返回如下内容时，你就知道 Pod 已终止：</p>
<pre><code>No resources found.
</code></pre></li>
</ol>
<ol start=4>
<li>
<p>删除 ConfigMap、Services 和 PersistentVolumeClaims。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete configmap,service,pvc -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>mysql
</code></pre></div></li>
</ol>
<ol start=5>
<li>如果你手动供应 PersistentVolume，则还需要手动删除它们，并释放下层资源。
如果你使用了动态预配器，当得知你删除 PersistentVolumeClaims 时，它将自动删除 PersistentVolumes。
一些动态预配器（例如用于 EBS 和 PD 的预配器）也会在删除 PersistentVolumes 时释放下层资源。</li>
</ol>
<h2 id=what-s-next>What's next</h2>
<ul>
<li>进一步了解<a href=/zh/docs/tasks/run-application/scale-stateful-set/>为 StatefulSet 扩缩容</a>.</li>
<li>进一步了解<a href=/zh/docs/tasks/debug-application-cluster/debug-stateful-set/>调试 StatefulSet</a>.</li>
<li>进一步了解<a href=/zh/docs/tasks/run-application/delete-stateful-set/>删除 StatefulSet</a>.</li>
<li>进一步了解<a href=/zh/docs/tasks/run-application/force-delete-stateful-set-pod/>强制删除 StatefulSet Pods</a>.</li>
<li>在 <a href=https://artifacthub.io/>Helm Charts 仓库</a>中查找其他有状态的应用程序示例。</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-c43537b0ee1da992ecb7488f87e6c934>9.4 - 删除 StatefulSet</h1>
<p>本任务展示如何删除 StatefulSet。</p>
<h2 id=before-you-begin>Before you begin</h2>
<ul>
<li>本任务假设在你的集群上已经运行了由 StatefulSet 创建的应用。</li>
</ul>
<h2 id=deleting-a-statefulset>删除 StatefulSet </h2>
<p>你可以像删除 Kubernetes 中的其他资源一样删除 StatefulSet：使用 <code>kubectl delete</code> 命令，并按文件或者名字指定 StatefulSet。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete -f &lt;file.yaml&gt;
</code></pre></div>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete statefulsets &lt;statefulset 名称&gt;
</code></pre></div>
<p>删除 StatefulSet 之后，你可能需要单独删除关联的无头服务。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete service &lt;服务名称&gt;
</code></pre></div>
<p>当通过 <code>kubectl</code> 删除 StatefulSet 时，StatefulSet 会被缩容为 0。
属于该 StatefulSet 的所有 Pod 也被删除。
如果你只想删除 StatefulSet 而不删除 Pod，使用 <code>--cascade=orphan</code>。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete -f &lt;file.yaml&gt; --cascade<span style=color:#666>=</span>orphan
</code></pre></div>
<p>通过将 <code>--cascade=orphan</code> 传递给 <code>kubectl delete</code>，在删除 StatefulSet 对象之后，
StatefulSet 管理的 Pod 会被保留下来。如果 Pod 具有标签 <code>app=myapp</code>，则可以按照
如下方式删除它们：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete pods -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>myapp
</code></pre></div>
<h3 id=persistent-volumes>持久卷 </h3>
<p>删除 StatefulSet 管理的 Pod 并不会删除关联的卷。这是为了确保你有机会在删除卷之前从卷中复制数据。
在 Pod 离开<a href=/zh/docs/concepts/workloads/pods/pod-lifecycle/#pod-termination>终止状态</a>
后删除 PVC 可能会触发删除背后的 PV 持久卷，具体取决于存储类和回收策略。
永远不要假定在 PVC 删除后仍然能够访问卷。</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 删除 PVC 时要谨慎，因为这可能会导致数据丢失。
</div>
<h3 id=complete-deletion-of-a-statefulset>完全删除 StatefulSet </h3>
<p>要删除 StatefulSet 中的所有内容，包括关联的 pods，你可以运行
一系列如下所示的命令：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#b8860b>grace</span><span style=color:#666>=</span><span style=color:#a2f;font-weight:700>$(</span>kubectl get pods &lt;stateful-set-pod&gt; --template <span style=color:#b44>&#39;{{.spec.terminationGracePeriodSeconds}}&#39;</span><span style=color:#a2f;font-weight:700>)</span>
kubectl delete statefulset -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>myapp
sleep <span style=color:#b8860b>$grace</span>
kubectl delete pvc -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>myapp
</code></pre></div>
<p>在上面的例子中，Pod 的标签为 <code>app=myapp</code>；适当地替换你自己的标签。</p>
<h3 id=强制删除-statefulset-的-pod>强制删除 StatefulSet 的 Pod</h3>
<p>如果你发现 StatefulSet 的某些 Pod 长时间处于 'Terminating' 或者 'Unknown' 状态，
则可能需要手动干预以强制从 API 服务器中删除这些 Pod。
这是一项有点危险的任务。详细信息请阅读
<a href=/zh/docs/tasks/run-application/force-delete-stateful-set-pod/>删除 StatefulSet 类型的 Pods</a>。</p>
<h2 id=what-s-next>What's next</h2>
<p>进一步了解<a href=/zh/docs/tasks/run-application/force-delete-stateful-set-pod/>强制删除 StatefulSet 的 Pods</a>。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-f5f2f7a74377a9d45325c5253353fa8f>9.5 - 强制删除 StatefulSet 中的 Pods</h1>
<p>本文介绍如何删除 <a class=glossary-tooltip title="StatefulSet 用来管理某 Pod 集合的部署和扩缩，并为这些 Pod 提供持久存储和持久标识符。" data-toggle=tooltip data-placement=top href=/zh/docs/concepts/workloads/controllers/statefulset/ target=_blank aria-label=StatefulSet>StatefulSet</a>
管理的 Pods，并解释这样操作时需要记住的注意事项。</p>
<h2 id=before-you-begin>Before you begin</h2>
<ul>
<li>这是一项相当高级的任务，并且可能会违反 StatefulSet 固有的某些属性。</li>
<li>继续任务之前，请熟悉下面列举的注意事项。</li>
</ul>
<h2 id=statefulset-注意事项>StatefulSet 注意事项</h2>
<p>在 StatefulSet 的正常操作中，<strong>永远不</strong>需要强制删除 StatefulSet 管理的 Pod。
<a href=/zh/docs/concepts/workloads/controllers/statefulset/>StatefulSet 控制器</a>负责创建、
扩缩和删除 StatefulSet 管理的 Pods。它尝试确保指定数量的从序数 0 到 N-1 的 Pod
处于活跃状态并准备就绪。StatefulSet 确保在任何时候，集群中最多只有一个具有给定标识的 Pod。
这就是所谓的由 StatefulSet 提供的*最多一个（At Most One）*的语义。</p>
<p>应谨慎进行手动强制删除操作，因为它可能会违反 StatefulSet 固有的至多一个的语义。
StatefulSets 可用于运行分布式和集群级的应用，这些应用需要稳定的网络标识和可靠的存储。
这些应用通常配置为具有固定标识固定数量的成员集合。
具有相同身份的多个成员可能是灾难性的，并且可能导致数据丢失 (例如：票选系统中的脑裂场景)。</p>
<h2 id=delete-pods>删除 Pods </h2>
<p>你可以使用下面的命令执行体面地删除 Pod:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete pods &lt;pod&gt;
</code></pre></div>
<p>为了让上面操作能够体面地终止 Pod，Pod <strong>一定不能</strong> 设置 <code>pod.Spec.TerminationGracePeriodSeconds</code> 为 0。
将 <code>pod.Spec.TerminationGracePeriodSeconds</code> 设置为 0s 的做法是不安全的，强烈建议 StatefulSet 类型的
Pod 不要使用。体面删除是安全的，并且会在 kubelet 从 API 服务器中删除资源名称之前确保
<a href=/zh/docs/concepts/workloads/pods/pod-lifecycle/#pod-termination>体面地结束 pod </a>。</p>
<p>当某个节点不可达时，不会引发自动删除 Pod。
在无法访问的节点上运行的 Pod 在
<a href=/zh/docs/concepts/architecture/nodes/#condition>超时</a>
后会进入'Terminating' 或者 'Unknown' 状态。
当用户尝试体面地删除无法访问的节点上的 Pod 时 Pod 也可能会进入这些状态。
从 API 服务器上删除处于这些状态 Pod 的仅有可行方法如下：</p>
<ul>
<li>删除 Node 对象（要么你来删除, 要么<a href=/zh/docs/concepts/architecture/nodes/#node-controller>节点控制器</a>
来删除）</li>
<li>无响应节点上的 kubelet 开始响应，杀死 Pod 并从 API 服务器上移除 Pod 对象</li>
<li>用户强制删除 pod</li>
</ul>
<p>推荐使用第一种或者第二种方法。如果确认节点已经不可用了 (比如，永久断开网络、断电等)，
则应删除 Node 对象。
如果节点遇到网裂问题，请尝试解决该问题或者等待其解决。
当网裂愈合时，kubelet 将完成 Pod 的删除并从 API 服务器上释放其名字。</p>
<p>通常，Pod 一旦不在节点上运行，或者管理员删除了节点，系统就会完成其删除动作。
你也可以通过强制删除 Pod 来绕过这一机制。</p>
<h3 id=force-deletion>强制删除 </h3>
<p>强制删除<strong>不会</strong>等待来自 kubelet 对 Pod 已终止的确认消息。
无论强制删除是否成功杀死了 Pod，它都会立即从 API 服务器中释放该名字。
这将让 StatefulSet 控制器创建一个具有相同标识的替身 Pod；因而可能导致正在运行 Pod 的重复，
并且如果所述 Pod 仍然可以与 StatefulSet 的成员通信，则将违反 StatefulSet 所要保证的
最多一个的语义。</p>
<p>当你强制删除 StatefulSet 类型的 Pod 时，你要确保有问题的 Pod 不会再和 StatefulSet 管理的其他
Pod 通信并且可以安全地释放其名字以便创建替代 Pod。</p>
<p>如果要使用 kubectl 1.5 以上版本强制删除 Pod，请执行下面命令：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete pods &lt;pod&gt; --grace-period<span style=color:#666>=</span><span style=color:#666>0</span> --force
</code></pre></div>
<p>如果你使用 kubectl 的 1.4 以下版本，则应省略 <code>--force</code> 选项：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete pods &lt;pod&gt; --grace-period<span style=color:#666>=</span><span style=color:#666>0</span>
</code></pre></div>
<p>如果在这些命令后 Pod 仍处于 <code>Unknown</code> 状态，请使用以下命令从集群中删除 Pod:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl patch pod &lt;pod&gt; -p <span style=color:#b44>&#39;{&#34;metadata&#34;:{&#34;finalizers&#34;:null}}&#39;</span>
</code></pre></div>
<p>请始终谨慎地执行强制删除 StatefulSet 类型的 pods，并完全了解所涉及地风险。</p>
<h2 id=what-s-next>What's next</h2>
<p>进一步了解<a href=/zh/docs/tasks/debug-application-cluster/debug-stateful-set/>调试 StatefulSet</a>。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-0c0bb1bd76d2a9069e50e2cec6d20c2a>9.6 - Pod 水平自动扩缩</h1>
<p>在 Kubernetes 中，<em>HorizontalPodAutoscaler</em> 自动更新工作负载资源
（例如 <a class=glossary-tooltip title="Deployment 是管理应用副本的 API 对象。" data-toggle=tooltip data-placement=top href=/zh/docs/concepts/workloads/controllers/deployment/ target=_blank aria-label=Deployment>Deployment</a> 或者
<a class=glossary-tooltip title="StatefulSet 用来管理某 Pod 集合的部署和扩缩，并为这些 Pod 提供持久存储和持久标识符。" data-toggle=tooltip data-placement=top href=/zh/docs/concepts/workloads/controllers/statefulset/ target=_blank aria-label=StatefulSet>StatefulSet</a>），
目的是自动扩缩工作负载以满足需求。</p>
<p>水平扩缩意味着对增加的负载的响应是部署更多的 <a class=glossary-tooltip title="Pod 表示您的集群上一组正在运行的容器。" data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pods>Pods</a>。
这与 “垂直（Vertical）” 扩缩不同，对于 Kubernetes，
垂直扩缩意味着将更多资源（例如：内存或 CPU）分配给已经为工作负载运行的 Pod。</p>
<p>如果负载减少，并且 Pod 的数量高于配置的最小值，
HorizontalPodAutoscaler 会指示工作负载资源（ Deployment、StatefulSet 或其他类似资源）缩减。</p>
<p>水平 Pod 自动扩缩不适用于无法扩缩的对象（例如：<a class=glossary-tooltip title="确保 Pod 的副本在集群中的一组节点上运行。" data-toggle=tooltip data-placement=top href=/zh/docs/concepts/workloads/controllers/daemonset/ target=_blank aria-label=DaemonSet>DaemonSet</a>。）</p>
<p>HorizontalPodAutoscaler 被实现为 Kubernetes API 资源和<a class=glossary-tooltip title="控制器通过 apiserver 监控集群的公共状态，并致力于将当前状态转变为期望的状态。" data-toggle=tooltip data-placement=top href=/zh/docs/concepts/architecture/controller/ target=_blank aria-label=控制器>控制器</a>。</p>
<p>资源决定了控制器的行为。在 Kubernetes <a class=glossary-tooltip title="控制平面是指容器编排层，它暴露 API 和接口来定义、部署容器和管理容器的生命周期。" data-toggle=tooltip data-placement=top href="/zh/docs/reference/glossary/?all=true#term-control-plane" target=_blank aria-label=控制平面>控制平面</a>内运行的水平
Pod 自动扩缩控制器会定期调整其目标（例如：Deployment）的所需规模，以匹配观察到的指标，
例如，平均 CPU 利用率、平均内存利用率或你指定的任何其他自定义指标。</p>
<p>使用水平 Pod 自动扩缩<a href=/zh/docs/tasks/run-application/horizontal-pod-autoscale-walkthrough/>演练示例</a>。</p>
<h2 id=how-does-a-horizontalpodautoscaler-work>HorizontalPodAutoscaler 是如何工作的？</h2>
<figure class=diagram-medium>
<img src=/images/docs/horizontal-pod-autoscaler.svg alt="HorizontalPodAutoscaler 控制 Deployment 及其 ReplicaSet 的规模"> <figcaption>
<p>HorizontalPodAutoscaler 控制 Deployment 及其 ReplicaSet 的规模</p>
</figcaption>
</figure>
<p>Kubernetes 将水平 Pod 自动扩缩实现为一个间歇运行的控制回路（它不是一个连续的过程）。间隔由
<a href=/zh/docs/reference/command-line-tools-reference/kube-controller-manager/><code>kube-controller-manager</code></a>
的 <code>--horizontal-pod-autoscaler-sync-period</code> 参数设置（默认间隔为 15 秒）。</p>
<p>在每个时间段内，控制器管理器都会根据每个 HorizontalPodAutoscaler 定义中指定的指标查询资源利用率。
控制器管理器找到由 <code>scaleTargetRef</code> 定义的目标资源，然后根据目标资源的 <code>.spec.selector</code> 标签选择 Pod，
并从资源指标 API（针对每个 Pod 的资源指标）或自定义指标获取指标 API（适用于所有其他指标）。</p>
<ul>
<li>
<p>对于按 Pod 统计的资源指标（如 CPU），控制器从资源指标 API 中获取每一个
HorizontalPodAutoscaler 指定的 Pod 的度量值，如果设置了目标使用率，
控制器获取每个 Pod 中的容器<a href=/zh/docs/concepts/configuration/manage-resources-containers/#requests-and-limits>资源使用</a> 情况，
并计算资源使用率。如果设置了 target 值，将直接使用原始数据（不再计算百分比）。
接下来，控制器根据平均的资源使用率或原始值计算出扩缩的比例，进而计算出目标副本数。</p>
<p>需要注意的是，如果 Pod 某些容器不支持资源采集，那么控制器将不会使用该 Pod 的 CPU 使用率。
下面的<a href=#algorithm-details>算法细节</a>章节将会介绍详细的算法。</p>
</li>
</ul>
<ul>
<li>如果 Pod 使用自定义指示，控制器机制与资源指标类似，区别在于自定义指标只使用
原始值，而不是使用率。</li>
</ul>
<ul>
<li>如果 Pod 使用对象指标和外部指标（每个指标描述一个对象信息）。
这个指标将直接根据目标设定值相比较，并生成一个上面提到的扩缩比例。
在 <code>autoscaling/v2beta2</code> 版本 API 中，这个指标也可以根据 Pod 数量平分后再计算。</li>
</ul>
<p>HorizontalPodAutoscaler 的常见用途是将其配置为从<a class=glossary-tooltip title="聚合层允许您在自己的集群上安装额外的 Kubernetes 风格的 API。" data-toggle=tooltip data-placement=top href=/zh/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/ target=_blank aria-label="聚合 API">聚合 API</a>
（<code>metrics.k8s.io</code>、<code>custom.metrics.k8s.io</code> 或 <code>external.metrics.k8s.io</code>）获取指标。
<code>metrics.k8s.io</code> API 通常由名为 Metrics Server 的插件提供，需要单独启动。有关资源指标的更多信息，
请参阅 <a href=/zh/docs/tasks/debug/debug-cluster/resource-metrics-pipeline/#metrics-server>Metrics Server</a>。</p>
<p>对 <a href=#support-for-metrics-apis>Metrics API 的支持</a>解释了这些不同 API 的稳定性保证和支持状态</p>
<p>HorizontalPodAutoscaler 控制器访问支持扩缩的相应工作负载资源（例如：Deployments 和 StatefulSet）。
这些资源每个都有一个名为 <code>scale</code> 的子资源，该接口允许你动态设置副本的数量并检查它们的每个当前状态。
有关 Kubernetes API 子资源的一般信息，
请参阅 <a href=/zh/docs/reference/using-api/api-concepts/>Kubernetes API 概念</a>。</p>
<h3 id=algorithm-details>算法细节 </h3>
<p>从最基本的角度来看，Pod 水平自动扩缩控制器根据当前指标和期望指标来计算扩缩比例。</p>
<pre><code>期望副本数 = ceil[当前副本数 * (当前指标 / 期望指标)]
</code></pre>
<p>例如，如果当前指标值为 <code>200m</code>，而期望值为 <code>100m</code>，则副本数将加倍，
因为 <code>200.0 / 100.0 == 2.0</code> 如果当前值为 <code>50m</code>，则副本数将减半，
因为 <code>50.0 / 100.0 == 0.5</code>。如果比率足够接近 1.0（在全局可配置的容差范围内，默认为 0.1），
则控制平面会跳过扩缩操作。</p>
<p>如果 HorizontalPodAutoscaler 指定的是 <code>targetAverageValue</code> 或 <code>targetAverageUtilization</code>，
那么将会把指定 Pod 度量值的平均值做为 <code>currentMetricValue</code>。</p>
<p>在检查容差并决定最终值之前，控制平面还会考虑是否缺少任何指标，
以及有多少 Pod <a href=/zh/docs/concepts/workloads/pods/pod-lifecycle/#pod-conditions><code>已就绪</code></a>。</p>
<p>所有设置了删除时间戳的 Pod（带有删除时间戳的对象正在关闭/移除的过程中）都会被忽略，
所有失败的 Pod 都会被丢弃。</p>
<p>如果某个 Pod 缺失度量值，它将会被搁置，只在最终确定扩缩数量时再考虑。</p>
<p>当使用 CPU 指标来扩缩时，任何还未就绪（还在初始化，或者可能是不健康的）状态的 Pod <strong>或</strong>
最近的指标度量值采集于就绪状态前的 Pod，该 Pod 也会被搁置。</p>
<p>由于技术限制，HorizontalPodAutoscaler 控制器在确定是否保留某些 CPU 指标时无法准确确定 Pod 首次就绪的时间。
相反，如果 Pod 未准备好并在其启动后的一个可配置的短时间窗口内转换为未准备好，它会认为 Pod “尚未准备好”。
该值使用 <code>--horizontal-pod-autoscaler-initial-readiness-delay</code> 标志配置，默认值为 30 秒。
一旦 Pod 准备就绪，如果它发生在自启动后较长的、可配置的时间内，它就会认为任何向准备就绪的转换都是第一个。
该值由 <code>-horizontal-pod-autoscaler-cpu-initialization-period</code> 标志配置，默认为 5 分钟。</p>
<p>在排除掉被搁置的 Pod 后，扩缩比例就会根据 <code>currentMetricValue/desiredMetricValue</code>
计算出来。</p>
<p>如果缺失某些度量值，控制平面会更保守地重新计算平均值，在需要缩小时假设这些 Pod 消耗了目标值的 100%，
在需要放大时假设这些 Pod 消耗了 0% 目标值。这可以在一定程度上抑制扩缩的幅度。</p>
<p>此外，如果存在任何尚未就绪的 Pod，工作负载会在不考虑遗漏指标或尚未就绪的 Pod 的情况下进行扩缩，
控制器保守地假设尚未就绪的 Pod 消耗了期望指标的 0%，从而进一步降低了扩缩的幅度。</p>
<p>考虑到尚未准备好的 Pod 和缺失的指标后，控制器会重新计算使用率。
如果新的比率与扩缩方向相反，或者在容差范围内，则控制器不会执行任何扩缩操作。
在其他情况下，新比率用于决定对 Pod 数量的任何更改。</p>
<p>注意，平均利用率的 <strong>原始</strong> 值是通过 HorizontalPodAutoscaler 状态体现的，
而不考虑尚未准备好的 Pod 或缺少的指标，即使使用新的使用率也是如此。</p>
<p>如果创建 HorizontalPodAutoscaler 时指定了多个指标，
那么会按照每个指标分别计算扩缩副本数，取最大值进行扩缩。
如果任何一个指标无法顺利地计算出扩缩副本数（比如，通过 API 获取指标时出错），
并且可获取的指标建议缩容，那么本次扩缩会被跳过。
这表示，如果一个或多个指标给出的 <code>desiredReplicas</code> 值大于当前值，HPA 仍然能实现扩容。</p>
<p>最后，在 HPA 控制器执行扩缩操作之前，会记录扩缩建议信息。
控制器会在操作时间窗口中考虑所有的建议信息，并从中选择得分最高的建议。
这个值可通过 <code>kube-controller-manager</code> 服务的启动参数
<code>--horizontal-pod-autoscaler-downscale-stabilization</code> 进行配置，
默认值为 5 分钟。
这个配置可以让系统更为平滑地进行缩容操作，从而消除短时间内指标值快速波动产生的影响。</p>
<h2 id=api-object>API 对象 </h2>
<p>HorizontalPodAutoscaler 是 Kubernetes <code>autoscaling</code> API 组中的 API 资源。
当前的稳定版本可以在 <code>autoscaling/v2</code> API 版本中找到，其中包括对基于内存和自定义指标执行扩缩的支持。
在使用 <code>autoscaling/v1</code> 时，<code>autoscaling/v2</code> 中引入的新字段作为注释保留。</p>
<p>创建 HorizontalPodAutoscaler 对象时，需要确保所给的名称是一个合法的
<a href=/zh/docs/concepts/overview/working-with-objects/names#dns-subdomain-names>DNS 子域名</a>。
有关 API 对象的更多信息，请查阅
<a href=/docs/reference/generated/kubernetes-api/v1.23/#horizontalpodautoscaler-v2-autoscaling>HorizontalPodAutoscaler 对象设计文档</a>。</p>
<h2 id=flapping>工作量规模的稳定性</h2>
<p>在使用 HorizontalPodAutoscaler 管理一组副本的规模时，由于评估的指标的动态特性，
副本的数量可能会经常波动。这有时被称为 <strong>抖动（thrashing）</strong> 或 <strong>波动（flapping）</strong>。它类似于控制论中的 <strong>滞后（hysteresis）</strong> 概念。</p>
<h2 id=autoscaling-during-rolling-update>滚动升级时扩缩 </h2>
<p>Kubernetes 允许你在 Deployment 上执行滚动更新。在这种情况下，Deployment 为你管理下层的 ReplicaSet。
当你为一个 Deployment 配置自动扩缩时，你要为每个 Deployment 绑定一个 HorizontalPodAutoscaler。
HorizontalPodAutoscaler 管理 Deployment 的 <code>replicas</code> 字段。
Deployment Controller 负责设置下层 ReplicaSet 的 <code>replicas</code> 字段，
以便确保在上线及后续过程副本个数合适。</p>
<p>如果你对一个副本个数被自动扩缩的 StatefulSet 执行滚动更新， 该 StatefulSet
会直接管理它的 Pod 集合 （不存在类似 ReplicaSet 这样的中间资源）。</p>
<h2 id=support-for-resource-metrics>对资源指标的支持 </h2>
<p>HPA 的任何目标资源都可以基于其中的 Pods 的资源用量来实现扩缩。
在定义 Pod 规约时，类似 <code>cpu</code> 和 <code>memory</code> 这类资源请求必须被设定。
这些设定值被用来确定资源利用量并被 HPA 控制器用来对目标资源完成扩缩操作。
要使用基于资源利用率的扩缩，可以像下面这样指定一个指标源：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Resource<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>resource</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cpu<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>target</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Utilization<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>averageUtilization</span>:<span style=color:#bbb> </span><span style=color:#666>60</span><span style=color:#bbb>
</span></code></pre></div>
<p>基于这一指标设定，HPA 控制器会维持扩缩目标中的 Pods 的平均资源利用率在 60%。
利用率是 Pod 的当前资源用量与其请求值之间的比值。关于如何计算利用率以及如何计算平均值
的细节可参考<a href=#algorithm-details>算法</a>小节。</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong>
<p>由于所有的容器的资源用量都会被累加起来，Pod 的总体资源用量值可能不会精确体现
各个容器的资源用量。这一现象也会导致一些问题，例如某个容器运行时的资源用量非常
高，但因为 Pod 层面的资源用量总值让人在可接受的约束范围内，HPA 不会执行扩大
目标对象规模的操作。
</div>
<h3 id=container-resource-metrics>容器资源指标 </h3>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.20 [alpha]</code>
</div>
<p>HorizontalPodAutoscaler API 也支持容器指标源，这时 HPA 可以跟踪记录一组 Pods 中各个容器的
资源用量，进而触发扩缩目标对象的操作。
容器资源指标的支持使得你可以为特定 Pod 中最重要的容器配置规模扩缩阈值。
例如，如果你有一个 Web 应用和一个执行日志操作的边车容器，你可以基于 Web 应用的
资源用量来执行扩缩，忽略边车容器的存在及其资源用量。</p>
<p>如果你更改扩缩目标对象，令其使用新的、包含一组不同的容器的 Pod 规约，你就需要
修改 HPA 的规约才能基于新添加的容器来执行规模扩缩操作。
如果指标源中指定的容器不存在或者仅存在于部分 Pods 中，那么这些 Pods 会被忽略，
HPA 会重新计算资源用量值。参阅<a href=#algorithm-details>算法</a>小节进一步了解计算细节。
要使用容器资源用量来完成自动扩缩，可以像下面这样定义指标源：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>ContainerResource<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>containerResource</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cpu<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>container</span>:<span style=color:#bbb> </span>application<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>target</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Utilization<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>averageUtilization</span>:<span style=color:#bbb> </span><span style=color:#666>60</span><span style=color:#bbb>
</span></code></pre></div>
<p>在上面的例子中，HPA 控制器会对目标对象执行扩缩操作以确保所有 Pods 中
<code>application</code> 容器的平均 CPU 用量为 60%。</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong>
<p>如果你要更改 HorizontalPodAutoscaler 所跟踪记录的容器的名称，你可以按一定顺序
来执行这一更改，确保在应用更改的过程中用来判定扩缩行为的容器可用。
在更新定义容器的资源（如 Deployment）之前，你需要更新相关的 HPA，使之能够同时
跟踪记录新的和老的容器名称。这样，HPA 就能够在整个更新过程中继续计算并提供扩缩操作建议。</p>
<p>一旦你已经将容器名称变更这一操作应用到整个负载对象至上，就可以从 HPA
的规约中去掉老的容器名称，完成清理操作。</p>
</div>
<h2 id=scaling-on-custom-metrics>扩展自定义指标</h2>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.23 [stable]</code>
</div>
<p>（之前的 <code>autoscaling/v2beta2</code> API 版本将此功能作为 beta 功能提供）</p>
<p>如果你使用 <code>autoscaling/v2</code> API 版本，则可以将 HorizontalPodAutoscaler
配置为基于自定义指标（未内置于 Kubernetes 或任何 Kubernetes 组件）进行扩缩。
HorizontalPodAutoscaler 控制器能够从 Kubernetes API 查询这些自定义指标。</p>
<p>有关要求，请参阅对 <a href=#support-for-metrics-apis>Metrics APIs 的支持</a>。</p>
<h2 id=scaling-on-multiple-metrics>基于多个指标来执行扩缩</h2>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.23 [stable]</code>
</div>
<p>（之前的 <code>autoscaling/v2beta2</code> API 版本将此功能作为 beta 功能提供）</p>
<p>如果你使用 <code>autoscaling/v2</code> API 版本，你可以为 HorizontalPodAutoscaler 指定多个指标以进行扩缩。
HorizontalPodAutoscaler 控制器评估每个指标，并根据该指标提出一个新的比例。
HorizontalPodAutoscaler 采用为每个指标推荐的最大比例，
并将工作负载设置为该大小（前提是这不大于你配置的总体最大值）。</p>
<h2 id=support-for-metrics-apis>对 Metrics API 的支持 </h2>
<p>默认情况下，HorizontalPodAutoscaler 控制器会从一系列的 API 中检索度量值。
集群管理员需要确保下述条件，以保证 HPA 控制器能够访问这些 API：</p>
<ul>
<li>
<p>启用了 <a href=/zh/docs/tasks/extend-kubernetes/configure-aggregation-layer/>API 聚合层</a></p>
</li>
<li>
<p>相应的 API 已注册：</p>
<ul>
<li>
<p>对于资源指标，将使用 <code>metrics.k8s.io</code> API，一般由 <a href=https://github.com/kubernetes-incubator/metrics-server>metrics-server</a> 提供。
它可以作为集群插件启动。</p>
</li>
<li>
<p>对于自定义指标，将使用 <code>custom.metrics.k8s.io</code> API。
它由其他度量指标方案厂商的“适配器（Adapter）” API 服务器提供。
检查你的指标管道以查看是否有可用的 Kubernetes 指标适配器。</p>
</li>
<li>
<p>对于外部指标，将使用 <code>external.metrics.k8s.io</code> API。可能由上面的自定义指标适配器提供。</p>
</li>
</ul>
</li>
</ul>
<p>关于指标来源以及其区别的更多信息，请参阅相关的设计文档，
<a href=https://github.com/kubernetes/design-proposals-archive/blob/main/autoscaling/hpa-v2.md>HPA V2</a>，
<a href=https://github.com/kubernetes/design-proposals-archive/blob/main/instrumentation/custom-metrics-api.md>custom.metrics.k8s.io</a> 和
<a href=https://github.com/kubernetes/design-proposals-archive/blob/main/instrumentation/external-metrics-api.md>external.metrics.k8s.io</a>。</p>
<p>关于如何使用它们的示例，请参考
<a href=/zh/docs/tasks/run-application/horizontal-pod-autoscale-walkthrough/#autoscaling-on-multiple-metrics-and-custom-metrics>使用自定义指标的教程</a>
和<a href=/zh/docs/tasks/run-application/horizontal-pod-autoscale-walkthrough/#autoscaling-on-metrics-not-related-to-kubernetes-objects>使用外部指标的教程</a>。</p>
<h2 id=configurable-scaling-behavior>可配置的扩缩行为</h2>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.23 [stable]</code>
</div>
<p>（之前的 <code>autoscaling/v2beta2</code> API 版本将此功能作为 beta 功能提供）</p>
<p>如果你使用 <code>v2</code> HorizontalPodAutoscaler API，你可以使用 <code>behavior</code> 字段
（请参阅 <a href=/zh/docs/reference/kubernetes-api/workload-resources/horizontal-pod-autoscaler-v2/#HorizontalPodAutoscalerSpec>API 参考</a>）
来配置单独的放大和缩小行为。你可以通过在行为字段下设置 <code>scaleUp</code> 和/或 <code>scaleDown</code> 来指定这些行为。</p>
<p>你可以指定一个 “稳定窗口” ，以防止扩缩目标的副本计数发生<a href=#flapping>波动</a>。
扩缩策略还允许你在扩缩时控制副本的变化率。</p>
<h3 id=scaling-policies>扩缩策略</h3>
<p>可以在规约的 <code>behavior</code> 部分中指定一个或多个扩缩策略。当指定多个策略时，
允许最大更改量的策略是默认选择的策略。以下示例显示了缩小时的这种行为：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>behavior</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>scaleDown</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>policies</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Pods<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#666>4</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>periodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>60</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Percent<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#666>10</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>periodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>60</span><span style=color:#bbb>
</span></code></pre></div>
<p><code>periodSeconds</code> 表示在过去的多长时间内要求策略值为真。
第一个策略（Pods）允许在一分钟内最多缩容 4 个副本。第二个策略（Percent）
允许在一分钟内最多缩容当前副本个数的百分之十。</p>
<p>由于默认情况下会选择容许更大程度作出变更的策略，只有 Pod 副本数大于 40 时，
第二个策略才会被采用。如果副本数为 40 或者更少，则应用第一个策略。
例如，如果有 80 个副本，并且目标必须缩小到 10 个副本，那么在第一步中将减少 8 个副本。
在下一轮迭代中，当副本的数量为 72 时，10% 的 Pod 数为 7.2，但是这个数字向上取整为 8。
在 autoscaler 控制器的每个循环中，将根据当前副本的数量重新计算要更改的 Pod 数量。
当副本数量低于 40 时，应用第一个策略（Pods），一次减少 4 个副本。</p>
<p>可以指定扩缩方向的 <code>selectPolicy</code> 字段来更改策略选择。
通过设置 <code>Min</code> 的值，它将选择副本数变化最小的策略。
将该值设置为 <code>Disabled</code> 将完全禁用该方向的扩缩。</p>
<h3 id=stabilization-window>稳定窗口</h3>
<p>当用于扩缩的指标不断波动时，稳定窗口用于限制副本计数的<a href=#flapping>波动</a>。
自动扩缩算法使用此窗口来推断先前的期望状态并避免对工作负载规模进行不必要的更改。</p>
<p>例如，在以下示例代码段中，为 <code>scaleDown</code> 指定了稳定窗口。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>behavior</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>scaleDown</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>stabilizationWindowSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>300</span><span style=color:#bbb>
</span></code></pre></div>
<p>当指标显示目标应该缩容时，自动扩缩算法查看之前计算的期望状态，并使用指定时间间隔内的最大值。
在上面的例子中，过去 5 分钟的所有期望状态都会被考虑。</p>
<p>这近似于滚动最大值，并避免了扩缩算法频繁删除 Pod 而又触发重新创建等效 Pod。</p>
<h3 id=default-behavior>默认行为</h3>
<p>要使用自定义扩缩，不必指定所有字段。
只有需要自定义的字段才需要指定。
这些自定义值与默认值合并。
默认值与 HPA 算法中的现有行为匹配。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>behavior</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>scaleDown</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>stabilizationWindowSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>300</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>policies</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Percent<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#666>100</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>periodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>15</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>scaleUp</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>stabilizationWindowSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>0</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>policies</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Percent<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#666>100</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>periodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>15</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Pods<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#666>4</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>periodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>15</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>selectPolicy</span>:<span style=color:#bbb> </span>Max<span style=color:#bbb>
</span></code></pre></div>
<p>用于缩小稳定窗口的时间为 <em>300</em> 秒(或是 <code>--horizontal-pod-autoscaler-downscale-stabilization</code>
参数设定值)。
只有一种缩容的策略，允许 100% 删除当前运行的副本，这意味着扩缩目标可以缩小到允许的最小副本数。
对于扩容，没有稳定窗口。当指标显示目标应该扩容时，目标会立即扩容。
这里有两种策略，每 15 秒添加 4 个 Pod 或 100% 当前运行的副本数，直到 HPA 达到稳定状态。</p>
<h3 id=example-change-downscale-stabilization-window>示例：更改缩容稳定窗口</h3>
<p>将下面的 behavior 配置添加到 HPA 中，可提供一个 1 分钟的自定义缩容稳定窗口：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>behavior</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>scaleDown</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>stabilizationWindowSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>60</span><span style=color:#bbb>
</span></code></pre></div>
<h3 id=example-limit-scale-down-rate>示例：限制缩容速率</h3>
<p>将下面的 behavior 配置添加到 HPA 中，可限制 Pod 被 HPA 删除速率为每分钟 10%：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>behavior</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>scaleDown</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>policies</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Percent<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#666>10</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>periodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>60</span><span style=color:#bbb>
</span></code></pre></div>
<p>为了确保每分钟删除的 Pod 数不超过 5 个，可以添加第二个缩容策略，大小固定为 5，并将 <code>selectPolicy</code> 设置为最小值。
将 <code>selectPolicy</code> 设置为 <code>Min</code> 意味着 autoscaler 会选择影响 Pod 数量最小的策略:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>behavior</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>scaleDown</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>policies</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Percent<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#666>10</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>periodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>60</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Pods<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#666>5</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>periodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>60</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>selectPolicy</span>:<span style=color:#bbb> </span>Min<span style=color:#bbb>
</span></code></pre></div>
<h3 id=example-disable-scale-down>示例：禁用缩容</h3>
<p><code>selectPolicy</code> 的值 <code>Disabled</code> 会关闭对给定方向的缩容。
因此使用以下策略，将会阻止缩容：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>behavior</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>scaleDown</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>selectPolicy</span>:<span style=color:#bbb> </span>Disabled<span style=color:#bbb>
</span></code></pre></div>
<h2 id=support-for-horizontalpodautoscaler-in-kubectl>kubectl 对 HorizontalPodAutoscaler 的支持</h2>
<p>与每个 API 资源一样，HorizontalPodAutoscaler 都被 <code>kubectl</code> 以标准方式支持。
你可以使用 <code>kubectl create</code> 命令创建一个新的自动扩缩器。
你可以通过 <code>kubectl get hpa</code> 列出自动扩缩器或通过 <code>kubectl describe hpa</code> 获取详细描述。
最后，你可以使用 <code>kubectl delete hpa</code> 删除自动扩缩器。</p>
<p>此外，还有一个特殊的 <code>kubectl autoscale</code> 命令用于创建 HorizontalPodAutoscaler 对象。
例如，执行 <code>kubectl autoscale rs foo --min=2 --max=5 --cpu-percent=80</code>
将为 ReplicaSet <em>foo</em> 创建一个自动扩缩器，目标 CPU 利用率设置为 <code>80%</code>，副本数在 2 到 5 之间。</p>
<h2 id=implicit-maintenance-mode-deactivation>隐式维护状态禁用</h2>
<p>你可以在不必更改 HPA 配置的情况下隐式地为某个目标禁用 HPA。
如果此目标的期望副本个数被设置为 0，而 HPA 的最小副本个数大于 0，
则 HPA 会停止调整目标（并将其自身的 <code>ScalingActive</code> 状况设置为 <code>false</code>），
直到你通过手动调整目标的期望副本个数或 HPA 的最小副本个数来重新激活。</p>
<h3 id=migrating-deployments-and-statefulsets-to-horizontal-autoscaling>将 Deployment 和 StatefulSet 迁移到水平自动扩缩</h3>
<p>当启用 HPA 时，建议从它们的<a class=glossary-tooltip title="一个或多个 Kubernetes API 对象的序列化规范。" data-toggle=tooltip data-placement=top href="/zh/docs/reference/glossary/?all=true#term-manifest" target=_blank aria-label=清单>清单</a>中
删除 Deployment 和/或 StatefulSet 的 <code>spec.replicas</code> 的值。
如果不这样做，则只要应用对该对象的更改，例如通过 <code>kubectl apply -f deployment.yaml</code>，
这将指示 Kubernetes 将当前 Pod 数量扩缩到 <code>spec.replicas</code> 键的值。这可能不是所希望的，
并且当 HPA 处于活动状态时可能会很麻烦。</p>
<p>请记住，删除 <code>spec.replicas</code> 可能会导致 Pod 计数一次性降级，因为此键的默认值为 1
（参考 <a href=/zh/docs/concepts/workloads/controllers/deployment#replicas>Deployment Replicas</a>）。
更新后，除 1 之外的所有 Pod 都将开始其终止程序。之后的任何部署应用程序都将正常运行，
并根据需要遵守滚动更新配置。你可以根据修改部署的方式选择以下两种方法之一来避免这种降级：</p>
<ul class="nav nav-tabs" id=fix-replicas-instructions role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#fix-replicas-instructions-0 role=tab aria-controls=fix-replicas-instructions-0 aria-selected=true>客户端 apply 操作（默认行为）</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#fix-replicas-instructions-1 role=tab aria-controls=fix-replicas-instructions-1>服务器端 apply 操作</a></li></ul>
<div class=tab-content id=fix-replicas-instructions><div id=fix-replicas-instructions-0 class="tab-pane show active" role=tabpanel aria-labelledby=fix-replicas-instructions-0>
<p>
<ol>
<li><code>kubectl apply edit-last-applied deployment/&lt;Deployment 名称></code></li>
<li>在编辑器中，删除 <code>spec.replicas</code>。当你保存并退出编辑器时，<code>kubectl</code> 会应用更新。
在此步骤中不会更改 Pod 计数。</li>
<li>你现在可以从清单中删除 <code>spec.replicas</code>。如果你使用源代码管理，
还应提交你的更改或采取任何其他步骤来修改源代码，以适应你如何跟踪更新。</li>
<li>从这里开始，你可以运行 <code>kubectl apply -f deployment.yaml</code></li>
</ol>
</div>
<div id=fix-replicas-instructions-1 class=tab-pane role=tabpanel aria-labelledby=fix-replicas-instructions-1>
<p>
<p>使用<a href=/zh/docs/reference/using-api/server-side-apply/>服务器端 Apply</a> 机制，
你可以遵循<a href=/zh/docs/reference/using-api/server-side-apply/#transferring-ownership>交出所有权</a> 说明，
该指南涵盖了这个确切的用例。</p>
</div></div>
<h2 id=what-s-next>What's next</h2>
<p>如果你在集群中配置自动扩缩，你可能还需要考虑运行集群级别的自动扩缩器，
例如 <a href=https://github.com/kubernetes/autoscaler/tree/master/cluster-autoscaler>Cluster Autoscaler</a>。</p>
<p>有关 HorizontalPodAutoscaler 的更多信息：</p>
<ul>
<li>阅读水平 Pod 自动扩缩的<a href=/zh/docs/tasks/run-application/horizontal-pod-autoscale-walkthrough/>演练示例</a>。</li>
<li>阅读 <a href=/zh/docs/reference/generated/kubectl/kubectl-commands/#autoscale><code>kubectl autoscale</code></a> 的文档。</li>
<li>如果你想编写自己的自定义指标适配器，
请查看 <a href=https://github.com/kubernetes-sigs/custom-metrics-apiserver>boilerplate</a> 以开始使用。</li>
<li>阅读 <a href=/docs/reference/kubernetes-api/workload-resources/horizontal-pod-autoscaler-v2/>API 参考</a>。</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-8138226ce9660ac8e3e82ff86fff8ad2>9.7 - Horizontal Pod Autoscaler 演练</h1>
<p>Horizontal Pod Autoscaler 可以根据 CPU 利用率自动扩缩 ReplicationController、
Deployment、ReplicaSet 或 StatefulSet 中的 Pod 数量
（也可以基于其他应用程序提供的度量指标，目前这一功能处于 beta 版本）。</p>
<p>本文将引领你了解如何为 php-apache 服务器配置和使用 Horizontal Pod Autoscaler。
与 Horizontal Pod Autoscaler 相关的更多信息请参阅
<a href=/zh/docs/tasks/run-application/horizontal-pod-autoscale/>Horizontal Pod Autoscaler 用户指南</a>。</p>
<h2 id=before-you-begin>Before you begin</h2>
<p>本文示例需要一个运行中的 Kubernetes 集群以及 kubectl，版本为 1.2 或更高。
<a href=https://github.com/kubernetes-incubator/metrics-server/>Metrics 服务器</a>
需要被部署到集群中，以便通过 <a href=https://github.com/kubernetes/metrics>Metrics API</a>
提供度量数据。
Horizontal Pod Autoscaler 根据此 API 来获取度量数据。
要了解如何部署 metrics-server，请参考
<a href=https://github.com/kubernetes-incubator/metrics-server/>metrics-server 文档</a> 。</p>
<p>如果需要为 Horizontal Pod Autoscaler 指定多种资源度量指标，你的 Kubernetes
集群以及 kubectl 至少需要达到 1.6 版本。
此外，如果要使用自定义度量指标，你的 Kubernetes 集群还必须能够与提供这些自定义指标
的 API 服务器通信。
最后，如果要使用与 Kubernetes 对象无关的度量指标，则 Kubernetes 集群版本至少需要
达到 1.10 版本，同样，需要保证集群能够与提供这些外部指标的 API 服务器通信。
更多详细信息，请参阅
<a href=/zh/docs/tasks/run-application/horizontal-pod-autoscale/#support-for-custom-metrics>Horizontal Pod Autoscaler 用户指南</a>。</p>
<h2 id=运行-php-apache-服务器并暴露服务>运行 php-apache 服务器并暴露服务</h2>
<p>为了演示 Horizontal Pod Autoscaler，我们将使用一个基于 php-apache 镜像的
定制 Docker 镜像。Dockerfile 内容如下：</p>
<pre><code>FROM php:5-apache
COPY index.php /var/www/html/index.php
RUN chmod a+rx index.php
</code></pre>
<p>该文件定义了一个 index.php 页面来执行一些 CPU 密集型计算：</p>
<pre><code>&lt;?php
  $x = 0.0001;
  for ($i = 0; $i &lt;= 1000000; $i++) {
    $x += sqrt($x);
  }
  echo &quot;OK!&quot;;
?&gt;
</code></pre>
<p>首先，我们使用下面的配置启动一个 Deployment 来运行这个镜像并暴露一个服务：</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/application/php-apache.yaml download=application/php-apache.yaml><code>application/php-apache.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('application-php-apache-yaml')" title="Copy application/php-apache.yaml to clipboard">
</img>
</div>
<div class=includecode id=application-php-apache-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>php-apache<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>run</span>:<span style=color:#bbb> </span>php-apache<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>run</span>:<span style=color:#bbb> </span>php-apache<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>php-apache<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/hpa-example<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span>500m<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span>200m<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>php-apache<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>run</span>:<span style=color:#bbb> </span>php-apache<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>run</span>:<span style=color:#bbb> </span>php-apache<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>运行下面的命令：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/application/php-apache.yaml
</code></pre></div><pre><code>deployment.apps/php-apache created
service/php-apache created
</code></pre>
<h2 id=create-horizontal-pod-autoscaler>创建 Horizontal Pod Autoscaler </h2>
<p>现在，php-apache 服务器已经运行，我们将通过
<a href=/docs/reference/generated/kubectl/kubectl-commands#autoscale>kubectl autoscale</a>
命令创建 Horizontal Pod Autoscaler。
以下命令将创建一个 Horizontal Pod Autoscaler 用于控制我们上一步骤中创建的
Deployment，使 Pod 的副本数量维持在 1 到 10 之间。
大致来说，HPA 将（通过 Deployment）增加或者减少 Pod 副本的数量以保持所有 Pod
的平均 CPU 利用率在 50% 左右。由于每个 Pod 请求 200 毫核的 CPU，这意味着平均
CPU 用量为 100 毫核。
算法的详情请参阅<a href=/zh/docs/tasks/run-application/horizontal-pod-autoscale/#algorithm-details>相关文档</a>。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl autoscale deployment php-apache --cpu-percent<span style=color:#666>=</span><span style=color:#666>50</span> --min<span style=color:#666>=</span><span style=color:#666>1</span> --max<span style=color:#666>=</span><span style=color:#666>10</span>
</code></pre></div><pre><code>horizontalpodautoscaler.autoscaling/php-apache autoscaled
</code></pre>
<p>我们可以通过以下命令查看 Autoscaler 的状态：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get hpa
</code></pre></div><pre><code>NAME         REFERENCE                     TARGET    MINPODS   MAXPODS   REPLICAS   AGE
php-apache   Deployment/php-apache/scale   0% / 50%  1         10        1          18s

</code></pre>
<p>请注意当前的 CPU 利用率是 0%，这是由于我们尚未发送任何请求到服务器
（<code>CURRENT</code> 列显示了相应 Deployment 所控制的所有 Pod 的平均 CPU 利用率）。</p>
<h2 id=increase-load>增加负载 </h2>
<p>现在，我们将看到 Autoscaler 如何对增加负载作出反应。
我们将启动一个容器，并通过一个循环向 php-apache 服务器发送无限的查询请求
（请在另一个终端中运行以下命令）：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl run -i --tty load-generator --rm --image<span style=color:#666>=</span>busybox --restart<span style=color:#666>=</span>Never -- /bin/sh -c <span style=color:#b44>&#34;while sleep 0.01; do wget -q -O- http://php-apache; done&#34;</span>
</code></pre></div>
<p>一分钟时间左右之后，通过以下命令，我们可以看到 CPU 负载升高了：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get hpa
</code></pre></div><pre><code>NAME         REFERENCE                     TARGET      MINPODS   MAXPODS   REPLICAS   AGE
php-apache   Deployment/php-apache/scale   305% / 50%  1         10        1          3m
</code></pre>
<p>这时，由于请求增多，CPU 利用率已经升至请求值的 305%。
可以看到，Deployment 的副本数量已经增长到了 7：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get deployment php-apache
</code></pre></div><pre><code>NAME         READY   UP-TO-DATE   AVAILABLE   AGE
php-apache   7/7      7           7           19m
</code></pre>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 有时最终副本的数量可能需要几分钟才能稳定下来。由于环境的差异，
不同环境中最终的副本数量可能与本示例中的数量不同。
</div>
<h2 id=停止负载>停止负载</h2>
<p>我们将通过停止负载来结束我们的示例。</p>
<p>在我们创建 busybox 容器的终端中，输入<code>&lt;Ctrl> + C</code> 来终止负载的产生。</p>
<p>然后我们可以再次检查负载状态（等待几分钟时间）：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get hpa
</code></pre></div><pre><code>NAME         REFERENCE                     TARGET       MINPODS   MAXPODS   REPLICAS   AGE
php-apache   Deployment/php-apache/scale   0% / 50%     1         10        1          11m
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get deployment php-apache
</code></pre></div><pre><code>NAME         READY   UP-TO-DATE   AVAILABLE   AGE
php-apache   1/1     1            1           27m
</code></pre>
<p>这时，CPU 利用率已经降到 0，所以 HPA 将自动缩减副本数量至 1。</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 自动扩缩完成副本数量的改变可能需要几分钟的时间。
</div>
<h2 id=autoscaling-on-multiple-metrics-and-custom-metrics>基于多项度量指标和自定义度量指标自动扩缩</h2>
<p>利用 <code>autoscaling/v2beta2</code> API 版本，你可以在自动扩缩 php-apache 这个
Deployment 时使用其他度量指标。</p>
<p>首先，将 HorizontalPodAutoscaler 的 YAML 文件改为 <code>autoscaling/v2beta2</code> 格式：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get hpa php-apache -o yaml &gt; /tmp/hpa-v2.yaml
</code></pre></div>
<p>在编辑器中打开 <code>/tmp/hpa-v2.yaml</code>：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>autoscaling/v2beta2<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>HorizontalPodAutoscaler<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>php-apache<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>scaleTargetRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>php-apache<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>minReplicas</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>maxReplicas</span>:<span style=color:#bbb> </span><span style=color:#666>10</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>metrics</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Resource<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resource</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cpu<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>target</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Utilization<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>averageUtilization</span>:<span style=color:#bbb> </span><span style=color:#666>50</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>observedGeneration</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>lastScaleTime</span>:<span style=color:#bbb> </span>&lt;some-time&gt;<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>currentReplicas</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>desiredReplicas</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>currentMetrics</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Resource<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resource</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cpu<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>current</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>averageUtilization</span>:<span style=color:#bbb> </span><span style=color:#666>0</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>averageValue</span>:<span style=color:#bbb> </span><span style=color:#666>0</span><span style=color:#bbb>
</span></code></pre></div>
<p>需要注意的是，<code>targetCPUUtilizationPercentage</code> 字段已经被名为 <code>metrics</code> 的数组所取代。
CPU 利用率这个度量指标是一个 <em>resource metric</em>（资源度量指标），因为它表示容器上指定资源的百分比。
除 CPU 外，你还可以指定其他资源度量指标。默认情况下，目前唯一支持的其他资源度量指标为内存。
只要 <code>metrics.k8s.io</code> API 存在，这些资源度量指标就是可用的，并且他们不会在不同的 Kubernetes 集群中改变名称。</p>
<p>你还可以指定资源度量指标使用绝对数值，而不是百分比，你需要将 <code>target.type</code> 从
<code>Utilization</code> 替换成 <code>AverageValue</code>，同时设置 <code>target.averageValue</code>
而非 <code>target.averageUtilization</code> 的值。</p>
<p>还有两种其他类型的度量指标，他们被认为是 <em>custom metrics</em>（自定义度量指标）：
即 Pod 度量指标和 Object 度量指标。
这些度量指标可能具有特定于集群的名称，并且需要更高级的集群监控设置。</p>
<p>第一种可选的度量指标类型是 Pod 度量指标。这些指标从某一方面描述了 Pod，
在不同 Pod 之间进行平均，并通过与一个目标值比对来确定副本的数量。
它们的工作方式与资源度量指标非常相像，只是它们仅支持 <code>target</code> 类型为 <code>AverageValue</code>。</p>
<p>pod 度量指标通过如下代码块定义：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Pods<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>pods</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>metric</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>packets-per-second<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>target</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>AverageValue<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>averageValue</span>:<span style=color:#bbb> </span>1k<span style=color:#bbb>
</span></code></pre></div>
<p>第二种可选的度量指标类型是对象（Object）度量指标。这些度量指标用于描述
在相同名字空间中的别的对象，而非 Pods。
请注意这些度量指标不一定来自某对象，它们仅用于描述这些对象。
对象度量指标支持的 <code>target</code> 类型包括 <code>Value</code> 和 <code>AverageValue</code>。
如果是 <code>Value</code> 类型，<code>target</code> 值将直接与 API 返回的度量指标比较，
而对于 <code>AverageValue</code> 类型，API 返回的度量值将按照 Pod 数量拆分，
然后再与 <code>target</code> 值比较。
下面的 YAML 文件展示了一个表示 <code>requests-per-second</code> 的度量指标。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Object<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>object</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>metric</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>requests-per-second<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>describedObject</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>networking.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Ingress<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>main-route<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>target</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Value<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span>2k<span style=color:#bbb>
</span></code></pre></div>
<p>如果你指定了多个上述类型的度量指标，HorizontalPodAutoscaler 将会依次考量各个指标。
HorizontalPodAutoscaler 将会计算每一个指标所提议的副本数量，然后最终选择一个最高值。</p>
<p>比如，如果你的监控系统能够提供网络流量数据，你可以通过 <code>kubectl edit</code> 命令
将上述 Horizontal Pod Autoscaler 的定义更改为：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>autoscaling/v2beta1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>HorizontalPodAutoscaler<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>php-apache<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>scaleTargetRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>php-apache<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>minReplicas</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>maxReplicas</span>:<span style=color:#bbb> </span><span style=color:#666>10</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>metrics</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Resource<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resource</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cpu<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>target</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>AverageUtilization<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>averageUtilization</span>:<span style=color:#bbb> </span><span style=color:#666>50</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Pods<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>pods</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>metric</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>packets-per-second<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>target</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>AverageValue<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>averageValue</span>:<span style=color:#bbb> </span>1k<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Object<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>object</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>metric</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>requests-per-second<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>describedObject</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>networking.k8s.io/v1beta1<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Ingress<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>main-route<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>target</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Value<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span>10k<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>observedGeneration</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>lastScaleTime</span>:<span style=color:#bbb> </span>&lt;some-time&gt;<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>currentReplicas</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>desiredReplicas</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>currentMetrics</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Resource<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resource</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cpu<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>current</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>averageUtilization</span>:<span style=color:#bbb> </span><span style=color:#666>0</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>averageValue</span>:<span style=color:#bbb> </span><span style=color:#666>0</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Object<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>object</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>metric</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>requests-per-second<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>describedObject</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>networking.k8s.io/v1beta1<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Ingress<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>main-route<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>current</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span>10k<span style=color:#bbb>
</span></code></pre></div>
<p>这样，你的 HorizontalPodAutoscaler 将会尝试确保每个 Pod 的 CPU 利用率在 50% 以内，
每秒能够服务 1000 个数据包请求，
并确保所有在 Ingress 后的 Pod 每秒能够服务的请求总数达到 10000 个。</p>
<h3 id=autoscaing-on-more-specific-metrics>基于更特别的度量值来扩缩 </h3>
<p>许多度量流水线允许你通过名称或附加的 <em>标签</em> 来描述度量指标。
对于所有非资源类型度量指标（Pod、Object 和后面将介绍的 External），
可以额外指定一个标签选择算符。例如，如果你希望收集包含 <code>verb</code> 标签的
<code>http_requests</code> 度量指标，可以按如下所示设置度量指标块，使得扩缩操作仅针对
GET 请求执行：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Object<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>object</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>metric</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>`http_requests`<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb> </span>`verb=GET`<span style=color:#bbb>
</span></code></pre></div>
<p>这个选择算符使用与 Kubernetes 标签选择算符相同的语法。
如果名称和标签选择算符匹配到多个系列，监测管道会决定如何将多个系列合并成单个值。
选择算符是可以累加的，它不会选择目标以外的对象（类型为 <code>Pods</code> 的目标 Pods 或者
类型为 <code>Object</code> 的目标对象）。</p>
<h3 id=基于与-kubernetes-对象无关的度量指标执行扩缩>基于与 Kubernetes 对象无关的度量指标执行扩缩</h3>
<p>运行在 Kubernetes 上的应用程序可能需要基于与 Kubernetes 集群中的任何对象
没有明显关系的度量指标进行自动扩缩，
例如那些描述与任何 Kubernetes 名字空间中的服务都无直接关联的度量指标。
在 Kubernetes 1.10 及之后版本中，你可以使用外部度量指标（external metrics）。</p>
<p>使用外部度量指标时，需要了解你所使用的监控系统，相关的设置与使用自定义指标时类似。
外部度量指标使得你可以使用你的监控系统的任何指标来自动扩缩你的集群。
你需要在 <code>metric</code> 块中提供 <code>name</code> 和 <code>selector</code>，同时将类型由 <code>Object</code> 改为 <code>External</code>。
如果 <code>metricSelector</code> 匹配到多个度量指标，HorizontalPodAutoscaler 将会把它们加和。
外部度量指标同时支持 <code>Value</code> 和 <code>AverageValue</code> 类型，这与 <code>Object</code> 类型的度量指标相同。</p>
<p>例如，如果你的应用程序处理来自主机上消息队列的任务，
为了让每 30 个任务有 1 个工作者实例，你可以将下面的内容添加到
HorizontalPodAutoscaler 的配置中。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>- <span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>External<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>external</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metric</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>queue_messages_ready<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>queue</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;worker_tasks&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>target</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>AverageValue<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>averageValue</span>:<span style=color:#bbb> </span><span style=color:#666>30</span><span style=color:#bbb>
</span></code></pre></div>
<p>如果可能，还是推荐定制度量指标而不是外部度量指标，因为这便于让系统管理员加固定制度量指标 API。
而外部度量指标 API 可以允许访问所有的度量指标。
当暴露这些服务时，系统管理员需要仔细考虑这个问题。</p>
<h2 id=附录-horizontal-pod-autoscaler-状态条件>附录：Horizontal Pod Autoscaler 状态条件</h2>
<p>使用 <code>autoscaling/v2beta2</code> 格式的 HorizontalPodAutoscaler 时，你将可以看到
Kubernetes 为 HorizongtalPodAutoscaler 设置的状态条件（Status Conditions）。
这些状态条件可以显示当前 HorizontalPodAutoscaler 是否能够执行扩缩以及是否受到一定的限制。</p>
<p><code>status.conditions</code> 字段展示了这些状态条件。
可以通过 <code>kubectl describe hpa</code> 命令查看当前影响 HorizontalPodAutoscaler
的各种状态条件信息：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe hpa cm-test
</code></pre></div><pre><code>Name:                           cm-test
Namespace:                      prom
Labels:                         &lt;none&gt;
Annotations:                    &lt;none&gt;
CreationTimestamp:              Fri, 16 Jun 2017 18:09:22 +0000
Reference:                      ReplicationController/cm-test
Metrics:                        ( current / target )
  &quot;http_requests&quot; on pods:      66m / 500m
Min replicas:                   1
Max replicas:                   4
ReplicationController pods:     1 current / 1 desired
Conditions:
  Type                  Status  Reason                  Message
  ----                  ------  ------                  -------
  AbleToScale           True    ReadyForNewScale        the last scale time was sufficiently old as to warrant a new scale
  ScalingActive         True    ValidMetricFound        the HPA was able to successfully calculate a replica count from pods metric http_requests
  ScalingLimited        False   DesiredWithinRange      the desired replica count is within the acceptable range
Events:
</code></pre>
<p>对于上面展示的这个 HorizontalPodAutoscaler，我们可以看出有若干状态条件处于健康状态。
首先，<code>AbleToScale</code> 表明 HPA 是否可以获取和更新扩缩信息，以及是否存在阻止扩缩的各种回退条件。
其次，<code>ScalingActive</code> 表明 HPA 是否被启用（即目标的副本数量不为零） 以及是否能够完成扩缩计算。
当这一状态为 <code>False</code> 时，通常表明获取度量指标存在问题。
最后一个条件 <code>ScalingLimitted</code> 表明所需扩缩的值被 HorizontalPodAutoscaler
所定义的最大或者最小值所限制（即已经达到最大或者最小扩缩值）。
这通常表明你可能需要调整 HorizontalPodAutoscaler 所定义的最大或者最小副本数量的限制了。</p>
<h2 id=appendix-quantities>附录：量纲 </h2>
<p>HorizontalPodAutoscaler 和 度量指标 API 中的所有的度量指标使用 Kubernetes 中称为
<a class=glossary-tooltip title="使用全数字来表示较小数值或使用 SI 后缀表示较大数值的表示法。" data-toggle=tooltip data-placement=top href="/zh/docs/reference/glossary/?all=true#term-quantity" target=_blank aria-label=量纲（Quantity）>量纲（Quantity）</a>
的特殊整数表示。
例如，数量 <code>10500m</code> 用十进制表示为 <code>10.5</code>。
如果可能的话，度量指标 API 将返回没有后缀的整数，否则返回以千分单位的数量。
这意味着你可能会看到你的度量指标在 <code>1</code> 和 <code>1500m</code> （也就是在十进制记数法中的 <code>1</code> 和 <code>1.5</code>）之间波动。</p>
<h2 id=appendix-other-possible-scenarios>附录：其他可能的情况 </h2>
<h3 id=creating-the-autoscaler-declaratively>以声明式方式创建 Autoscaler </h3>
<p>除了使用 <code>kubectl autoscale</code> 命令，也可以文件创建 HorizontalPodAutoscaler：</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/application/hpa/php-apache.yaml download=application/hpa/php-apache.yaml><code>application/hpa/php-apache.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('application-hpa-php-apache-yaml')" title="Copy application/hpa/php-apache.yaml to clipboard">
</img>
</div>
<div class=includecode id=application-hpa-php-apache-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>autoscaling/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>HorizontalPodAutoscaler<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>php-apache<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>scaleTargetRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>php-apache<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>minReplicas</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>maxReplicas</span>:<span style=color:#bbb> </span><span style=color:#666>10</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>targetCPUUtilizationPercentage</span>:<span style=color:#bbb> </span><span style=color:#666>50</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>使用如下命令创建 autoscaler：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create -f https://k8s.io/examples/application/hpa/php-apache.yaml
</code></pre></div><pre><code>horizontalpodautoscaler.autoscaling/php-apache created
</code></pre>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-fbe2744f00d1aa4df4cdf4eea6a082d4>9.8 - 为应用程序设置干扰预算（Disruption Budget）</h1>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.21 [stable]</code>
</div>
<p>本文展示如何限制应用程序的并发干扰数量，在允许集群管理员管理集群节点的同时保证高可用。</p>
<h2 id=before-you-begin>Before you begin</h2>
Your Kubernetes server must be at or later than version v1.21.
To check the version, enter <code>kubectl version</code>.
<ul>
<li>你是 Kubernetes 集群中某应用的所有者，该应用有高可用要求。</li>
<li>你应了解如何部署<a href=/zh/docs/tasks/run-application/run-stateless-application-deployment/>无状态应用</a>
和/或<a href=/zh/docs/tasks/run-application/run-replicated-stateful-application/>有状态应用</a>。</li>
<li>你应当已经阅读过关于 <a href=/zh/docs/concepts/workloads/pods/disruptions/>Pod 干扰</a> 的文档。</li>
<li>用户应当与集群所有者或服务提供者确认其遵从 Pod 干扰预算（Pod Disruption Budgets）的规则。</li>
</ul>
<h2 id=用-poddisruptionbudget-来保护应用>用 PodDisruptionBudget 来保护应用</h2>
<ol>
<li>确定想要使用 PodDisruptionBudget (PDB) 来保护的应用。</li>
<li>考虑应用对干扰的反应。</li>
<li>以 YAML 文件形式定义 PDB 。</li>
<li>通过 YAML 文件创建 PDB 对象。</li>
</ol>
<h2 id=确定要保护的应用>确定要保护的应用</h2>
<p>用户想要保护通过内置的 Kubernetes 控制器指定的应用，这是最常见的使用场景：</p>
<ul>
<li>Deployment</li>
<li>ReplicationController</li>
<li>ReplicaSet</li>
<li>StatefulSet</li>
</ul>
<p>在这种情况下，在控制器的 <code>.spec.selector</code> 字段中做记录，并在 PDB 的
<code>.spec.selector</code> 字段中加入同样的选择算符。</p>
<p>从 1.15 版本开始，PDB 支持启用
<a href=/zh/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/#scale-subresource>scale 子资源</a>
的自定义控制器。</p>
<p>用户也可以用 PDB 来保护不受上述控制器控制的 Pod，或任意的 Pod 集合，但是正如
<a href=#arbitrary-controllers-and-selectors>任意控制器和选择算符</a>中描述的，这里存在一些限制。</p>
<h2 id=考虑应用对干扰的反应>考虑应用对干扰的反应</h2>
<p>确定在自发干扰时，多少实例可以在短时间内同时关闭。</p>
<ul>
<li>无状态的前端：
<ul>
<li>关注：不能降低服务能力 10% 以上。
<ul>
<li>解决方案：例如，使用 PDB，指定其 minAvailable 值为 90%。</li>
</ul>
</li>
</ul>
</li>
<li>单实例有状态应用：
<ul>
<li>关注：不要在不通知的情况下终止该应用。
<ul>
<li>可能的解决方案 1：不使用 PDB，并忍受偶尔的停机。</li>
<li>可能的解决方案 2：设置 maxUnavailable=0 的 PDB。
意为（Kubernetes 范畴之外的）集群操作人员需要在终止应用前与用户协商，
协商后准备停机，然后删除 PDB 表示准备接受干扰，后续再重新创建。</li>
</ul>
</li>
</ul>
</li>
<li>多实例有状态应用，如 Consul、ZooKeeper 或 etcd：
<ul>
<li>关注：不要将实例数量减少至低于仲裁规模，否则将出现写入失败。
<ul>
<li>可能的解决方案 1：设置 maxUnavailable 值为 1 (适用于不同规模的应用)。</li>
<li>可能的解决方案 2：设置 minAvailable 值为仲裁规模（例如规模为 5 时设置为 3）。
(允许同时出现更多的干扰)。</li>
</ul>
</li>
</ul>
</li>
<li>可重新启动的批处理任务：
<ul>
<li>关注：自发干扰的情况下，需要确保任务完成。
<ul>
<li>可能的解决方案：不创建 PDB。 任务控制器会创建一个替换 Pod。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id=指定百分比时的舍入逻辑>指定百分比时的舍入逻辑</h3>
<p><code>minAvailable</code> 或 <code>maxUnavailable</code> 的值可以表示为整数或百分比。</p>
<ul>
<li>指定整数值时，它表示 Pod 个数。例如，如果将 minAvailable 设置为 10，
那么即使在干扰期间，也必须始终有 10 个Pod可用。</li>
<li>通过将值设置为百分比的字符串表示形式（例如 “50％”）来指定百分比时，它表示占总 Pod 数的百分比。
例如，如果将 "minUnavailable" 设置为 “50％”，则干扰期间只允许 50％ 的 Pod 不可用。</li>
</ul>
<p>如果将值指定为百分比，则可能无法映射到确切数量的 Pod。例如，如果你有 7 个 Pod，
并且你将 <code>minAvailable</code> 设置为 <code>"50％"</code>，具体是 3 个 Pod 或 4 个 Pod 必须可用
并非显而易见。
Kubernetes 采用向上取整到最接近的整数的办法，因此在这种情况下，必须有 4 个 Pod。
你可以检查控制此行为的
<a href=https://github.com/kubernetes/kubernetes/blob/23be9587a0f8677eb8091464098881df939c44a9/pkg/controller/disruption/disruption.go#L539>代码</a>。</p>
<h2 id=指定-poddisruptionbudget>指定 PodDisruptionBudget</h2>
<p>一个 <code>PodDisruptionBudget</code> 有 3 个字段：</p>
<ul>
<li>标签选择算符 <code>.spec.selector</code> 用于指定其所作用的 Pod 集合，该字段为必需字段。</li>
<li><code>.spec.minAvailable</code> 表示驱逐后仍须保证可用的 Pod 数量。即使因此影响到 Pod 驱逐
（即该条件在和 Pod 驱逐发生冲突时优先保证）。
<code>minAvailable</code> 值可以是绝对值，也可以是百分比。</li>
<li><code>.spec.maxUnavailable</code> （Kubernetes 1.7 及更高的版本中可用）表示驱逐后允许不可用的
Pod 的最大数量。其值可以是绝对值或是百分比。</li>
</ul>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong>
<p><code>policy/v1beta1</code> 和 <code>policy/v1</code> API 中 PodDisruptionBudget 的空选择算符的行为
略有不同。在 <code>policy/v1beta1</code> 中，空的选择算符不会匹配任何 Pods，而
<code>policy/v1</code> 中，空的选择算符会匹配名字空间中所有 Pods。
</div>
<p>用户在同一个 <code>PodDisruptionBudget</code> 中只能够指定 <code>maxUnavailable</code> 和 <code>minAvailable</code> 中的一个。
<code>maxUnavailable</code> 只能够用于控制存在相应控制器的 Pod 的驱逐（即不受控制器控制的 Pod 不在
<code>maxUnavailable</code> 控制范围内）。在下面的示例中，
“所需副本” 指的是相应控制器的 <code>scale</code>，控制器对 <code>PodDisruptionBudget</code> 所选择的 Pod 进行管理。</p>
<p>示例 1：设置 <code>minAvailable</code> 值为 5 的情况下，驱逐时需保证 PodDisruptionBudget 的 <code>selector</code>
选中的 Pod 中 5 个或 5 个以上处于健康状态。</p>
<p>示例 2：设置 <code>minAvailable</code> 值为 30% 的情况下，驱逐时需保证 Pod 所需副本的至少 30% 处于健康状态。</p>
<p>示例 3：设置 <code>maxUnavailable</code> 值为 5 的情况下，驱逐时需保证所需副本中最多 5 个处于不可用状态。</p>
<p>示例 4：设置 <code>maxUnavailable</code> 值为 30% 的情况下，驱逐时需保证所需副本中最多 30% 处于不可用状态。</p>
<p>在典型用法中，干扰预算会被用于一个控制器管理的一组 Pod 中 —— 例如：一个 ReplicaSet 或 StatefulSet
中的 Pod。</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 干扰预算并不能真正保证指定数量/百分比的 Pod 一直处于运行状态。例如： 当 Pod 集合的
规模处于预算指定的最小值时，承载集合中某个 Pod 的节点发生了故障，这样就导致集合中可用 Pod 的
数量低于预算指定值。预算只能够针对自发的驱逐提供保护，而不能针对所有 Pod 不可用的诱因。
</div>
<p>设置 <code>maxUnavailable</code> 值为 0%（或 0）或设置 <code>minAvailable</code> 值为 100%（或等于副本数）
可能会阻塞节点，导致资源耗尽。按照 <code>PodDisruptionBudget</code> 的语义，这是允许的。</p>
<p>用户可以在下面看到 pod 干扰预算定义的示例，它们与带有 <code>app: zookeeper</code> 标签的 pod 相匹配：</p>
<p>使用 minAvailable 的PDB 示例：</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/policy/zookeeper-pod-disruption-budget-minavailable.yaml download=policy/zookeeper-pod-disruption-budget-minavailable.yaml><code>policy/zookeeper-pod-disruption-budget-minavailable.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('policy-zookeeper-pod-disruption-budget-minavailable-yaml')" title="Copy policy/zookeeper-pod-disruption-budget-minavailable.yaml to clipboard">
</img>
</div>
<div class=includecode id=policy-zookeeper-pod-disruption-budget-minavailable-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>policy/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PodDisruptionBudget<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>zk-pdb<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>minAvailable</span>:<span style=color:#bbb> </span><span style=color:#666>2</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>zookeeper<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>使用 maxUnavailable 的 PDB 示例：</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/policy/zookeeper-pod-disruption-budget-maxunavailable.yaml download=policy/zookeeper-pod-disruption-budget-maxunavailable.yaml><code>policy/zookeeper-pod-disruption-budget-maxunavailable.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('policy-zookeeper-pod-disruption-budget-maxunavailable-yaml')" title="Copy policy/zookeeper-pod-disruption-budget-maxunavailable.yaml to clipboard">
</img>
</div>
<div class=includecode id=policy-zookeeper-pod-disruption-budget-maxunavailable-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>policy/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PodDisruptionBudget<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>zk-pdb<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>maxUnavailable</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>zookeeper<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>例如，如果上述 <code>zk-pdb</code> 选择的是一个规格为 3 的 StatefulSet 对应的 Pod，
那么上面两种规范的含义完全相同。
推荐使用 <code>maxUnavailable</code> ，因为它自动响应控制器副本数量的变化。</p>
<h2 id=创建-pdb-对象>创建 PDB 对象</h2>
<p>你可以使用 kubectl 创建或更新 PDB 对象。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f mypdb.yaml
</code></pre></div>
<p>PDB 对象无法更新，必须删除后重新创建。</p>
<h2 id=检查-pdb-的状态>检查 PDB 的状态</h2>
<p>使用 kubectl 来确认 PDB 被创建。</p>
<p>假设用户的名字空间下没有匹配 <code>app: zookeeper</code> 的 Pod，用户会看到类似下面的信息：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get poddisruptionbudgets
</code></pre></div><pre><code>NAME     MIN AVAILABLE   MAX UNAVAILABLE   ALLOWED DISRUPTIONS   AGE
zk-pdb   2               N/A               0                     7s
</code></pre>
<p>假设有匹配的 Pod (比如说 3 个), 那么用户会看到类似下面的信息：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get poddisruptionbudgets
</code></pre></div><pre><code>NAME     MIN AVAILABLE   MAX UNAVAILABLE   ALLOWED DISRUPTIONS   AGE
zk-pdb   2               N/A               1                     7s

</code></pre>
<p><code>ALLOWED-DISRUPTIONS</code> 值非 0 意味着干扰控制器已经感知到相应的 Pod，对匹配的 Pod 进行统计，
并更新了 PDB 的状态。</p>
<p>用户可以通过以下命令获取更多 PDB 状态相关信息：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get poddisruptionbudgets zk-pdb -o yaml
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>policy/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PodDisruptionBudget<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>anntation</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>creationTimestamp</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2020-03-04T04:22:56Z&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>generation</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>zk-pdb<span style=color:#bbb>
</span><span style=color:#bbb></span>…<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>currentHealthy</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>desiredHealthy</span>:<span style=color:#bbb> </span><span style=color:#666>2</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>disruptionsAllowed</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>expectedPods</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>observedGeneration</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></code></pre></div>
<h2 id=arbitrary-controllers-and-selectors>任意控制器和选择算符 </h2>
<p>如果你只使用与内置的应用控制器（Deployment、ReplicationController、ReplicaSet 和 StatefulSet）
对应的 PDB，也就是 PDB 的选择算符与 控制器的选择算符相匹配，那么可以跳过这一节。</p>
<p>你可以使用这样的 PDB：它对应的 Pod 可能由其他类型的控制器控制，可能由 "operator" 控制，
也可能为“裸的（不受控制器控制）” Pod，但该类 PDB 存在以下限制：</p>
<ul>
<li>只能够使用 <code>.spec.minAvailable</code> ，而不能够使用 <code>.spec.maxUnavailable。</code></li>
<li>只能够使用整数作为 <code>.spec.minAvailable</code> 的值，而不能使用百分比。</li>
</ul>
<p>你可以令选择算符选择一个内置控制器所控制 Pod 的子集或父集。
然而，当名字空间下存在多个 PDB 时，用户必须小心，保证 PDB 的选择算符之间不重叠。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-52cd10ee3fc7c74a6c31043a2d489878>9.9 - 从 Pod 中访问 Kubernetes API</h1>
<p>本指南演示了如何从 Pod 中访问 Kubernetes API。</p>
<h2 id=before-you-begin>Before you begin</h2>
<p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li>
</ul>
<h3 id=accessing-the-api-from-within-a-pod>从 Pod 中访问 API </h3>
<p>从 Pod 内部访问 API 时，定位 API 服务器和向服务器认证身份的操作
与外部客户端场景不同。</p>
<p>从 Pod 使用 Kubernetes API 的最简单的方法就是使用官方的
<a href=/zh/docs/reference/using-api/client-libraries/>客户端库</a>。
这些库可以自动发现 API 服务器并进行身份验证。</p>
<h4 id=using-official-client-libraries>使用官方客户端库 </h4>
<p>从一个 Pod 内部连接到 Kubernetes API 的推荐方式为：</p>
<ul>
<li>
<p>对于 Go 语言客户端，使用官方的 <a href=https://github.com/kubernetes/client-go/>Go 客户端库</a>。
函数 <code>rest.InClusterConfig()</code> 自动处理 API 主机发现和身份认证。
参见<a href=https://git.k8s.io/client-go/examples/in-cluster-client-configuration/main.go>这里的一个例子</a>。</p>
</li>
<li>
<p>对于 Python 客户端，使用官方的 <a href=https://github.com/kubernetes-client/python/>Python 客户端库</a>。
函数 <code>config.load_incluster_config()</code> 自动处理 API 主机的发现和身份认证。
参见<a href=https://github.com/kubernetes-client/python/blob/master/examples/in_cluster_config.py>这里的一个例子</a>。</p>
</li>
<li>
<p>还有一些其他可用的客户端库，请参阅<a href=/zh/docs/reference/using-api/client-libraries/>客户端库</a>页面。</p>
</li>
</ul>
<p>在以上场景中，客户端库都使用 Pod 的服务账号凭据来与 API 服务器安全地通信。</p>
<h4 id=directly-accessing-the-rest-api>直接访问 REST API </h4>
<p>在运行在 Pod 中时，可以通过 <code>default</code> 命名空间中的名为 <code>kubernetes</code> 的服务访问
Kubernetes API 服务器。也就是说，Pod 可以使用 <code>kubernetes.default.svc</code> 主机名
来查询 API 服务器。官方客户端库自动完成这个工作。</p>
<p>向 API 服务器进行身份认证的推荐做法是使用
<a href=/zh/docs/tasks/configure-pod-container/configure-service-account/>服务账号</a>凭据。
默认情况下，每个 Pod 与一个服务账号关联，该服务账户的凭证（令牌）放置在此 Pod 中
每个容器的文件系统树中的 <code>/var/run/secrets/kubernetes.io/serviceaccount/token</code> 处。</p>
<p>如果证书包可用，则凭证包被放入每个容器的文件系统树中的
<code>/var/run/secrets/kubernetes.io/serviceaccount/ca.crt</code> 处，
且将被用于验证 API 服务器的服务证书。</p>
<p>最后，用于命名空间域 API 操作的默认命名空间放置在每个容器中的
<code>/var/run/secrets/kubernetes.io/serviceaccount/namespace</code> 文件中。</p>
<h4 id=use-kubectl-proxy>使用 kubectl proxy </h4>
<p>如果你希望不使用官方客户端库就完成 API 查询，可以将 <code>kubectl proxy</code> 作为
<a href=/zh/docs/tasks/inject-data-application/define-command-argument-container/>command</a>
在 Pod 中启动一个边车（Sidecar）容器。这样，<code>kubectl proxy</code> 自动完成对 API
的身份认证，并将其暴露到 Pod 的 <code>localhost</code> 接口，从而 Pod 中的其他容器可以
直接使用 API。</p>
<h3 id=without-using-a-proxy>不使用代理 </h3>
<p>通过将认证令牌直接发送到 API 服务器，也可以避免运行 kubectl proxy 命令。
内部的证书机制能够为链接提供保护。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># 指向内部 API 服务器的主机名</span>
<span style=color:#b8860b>APISERVER</span><span style=color:#666>=</span>https://kubernetes.default.svc

<span style=color:#080;font-style:italic># 服务账号令牌的路径</span>
<span style=color:#b8860b>SERVICEACCOUNT</span><span style=color:#666>=</span>/var/run/secrets/kubernetes.io/serviceaccount

<span style=color:#080;font-style:italic># 读取 Pod 的名字空间</span>
<span style=color:#b8860b>NAMESPACE</span><span style=color:#666>=</span><span style=color:#a2f;font-weight:700>$(</span>cat <span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>SERVICEACCOUNT</span><span style=color:#b68;font-weight:700>}</span>/namespace<span style=color:#a2f;font-weight:700>)</span>

<span style=color:#080;font-style:italic># 读取服务账号的持有者令牌</span>
<span style=color:#b8860b>TOKEN</span><span style=color:#666>=</span><span style=color:#a2f;font-weight:700>$(</span>cat <span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>SERVICEACCOUNT</span><span style=color:#b68;font-weight:700>}</span>/token<span style=color:#a2f;font-weight:700>)</span>

<span style=color:#080;font-style:italic># 引用内部证书机构（CA）</span>
<span style=color:#b8860b>CACERT</span><span style=color:#666>=</span><span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>SERVICEACCOUNT</span><span style=color:#b68;font-weight:700>}</span>/ca.crt

<span style=color:#080;font-style:italic># 使用令牌访问 API</span>
curl --cacert <span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>CACERT</span><span style=color:#b68;font-weight:700>}</span> --header <span style=color:#b44>&#34;Authorization: Bearer </span><span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>TOKEN</span><span style=color:#b68;font-weight:700>}</span><span style=color:#b44>&#34;</span> -X GET <span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>APISERVER</span><span style=color:#b68;font-weight:700>}</span>/api
</code></pre></div>
<p>输出类似于：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;APIVersions&#34;</span>,
  <span style=color:green;font-weight:700>&#34;versions&#34;</span>: [
    <span style=color:#b44>&#34;v1&#34;</span>
  ],
  <span style=color:green;font-weight:700>&#34;serverAddressByClientCIDRs&#34;</span>: [
    {
      <span style=color:green;font-weight:700>&#34;clientCIDR&#34;</span>: <span style=color:#b44>&#34;0.0.0.0/0&#34;</span>,
      <span style=color:green;font-weight:700>&#34;serverAddress&#34;</span>: <span style=color:#b44>&#34;10.0.1.149:443&#34;</span>
    }
  ]
}
</code></pre></div>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-7a9b5779e228083ba3fdeaf414fe704e>9.10 - 扩缩 StatefulSet</h1>
<p>本文介绍如何扩缩StatefulSet。StatefulSet 的扩缩指的是增加或者减少副本个数。</p>
<h2 id=before-you-begin>Before you begin</h2>
<ul>
<li>
<p>StatefulSets 仅适用于 Kubernetes 1.5 及以上版本。</p>
</li>
<li>
<p>不是所有 Stateful 应用都能很好地执行扩缩操作。
如果你不是很确定是否要扩缩你的 StatefulSet，可先参阅
<a href=/zh/docs/concepts/workloads/controllers/statefulset/>StatefulSet 概念</a>
或者 <a href=/zh/docs/tutorials/stateful-application/basic-stateful-set/>StatefulSet 教程</a>。</p>
</li>
<li>
<p>仅当你确定你的有状态应用的集群是完全健康的，才可执行扩缩操作.</p>
</li>
</ul>
<h2 id=scaling-statefulset>扩缩 StatefulSet </h2>
<h2 id=使用-kubectl-扩缩-statefulset>使用 <code>kubectl</code> 扩缩 StatefulSet</h2>
<p>首先，找到你要扩缩的 StatefulSet。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get statefulsets &lt;statefulset 名称&gt;
</code></pre></div>
<p>更改 StatefulSet 中副本个数：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl scale statefulsets &lt;statefulset 名称&gt; --replicas<span style=color:#666>=</span>&lt;新的副本数&gt;
</code></pre></div>
<h3 id=对-statefulset-执行就地更新>对 StatefulSet 执行就地更新</h3>
<p>另外, 你可以<a href=/zh/docs/concepts/cluster-administration/manage-deployment/#in-place-updates-of-resources>就地更新</a> StatefulSet。</p>
<p>如果你的 StatefulSet 最初通过 <code>kubectl apply</code> 或 <code>kubectl create --save-config</code> 创建,
你可以更新 StatefulSet 清单中的 <code>.spec.replicas</code>, 然后执行命令 <code>kubectl apply</code>:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f &lt;更新后的 statefulset 文件&gt;
</code></pre></div><p>否则，可以使用 <code>kubectl edit</code> 编辑副本字段：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl edit statefulsets &lt;statefulset 名称&gt;
</code></pre></div><p>或者使用 <code>kubectl patch</code>：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl patch statefulsets &lt;statefulset 名称&gt; -p <span style=color:#b44>&#39;{&#34;spec&#34;:{&#34;replicas&#34;:&lt;new-replicas&gt;}}&#39;</span>
</code></pre></div>
<h2 id=troubleshooting>故障排查 </h2>
<h3 id=缩容操作无法正常工作>缩容操作无法正常工作</h3>
<p>当 Stateful 所管理的任何 Pod 不健康时，你不能对该 StatefulSet 执行缩容操作。
仅当 StatefulSet 的所有 Pod 都处于运行状态和 Ready 状况后才可缩容.</p>
<p>如果 <code>spec.replicas</code> 大于 1，Kubernetes 无法判定 Pod 不健康的原因。
Pod 不健康可能是由于永久性故障造成也可能是瞬态故障。
瞬态故障可能是节点升级或维护而引起的节点重启造成的。</p>
<p>如果该 Pod 不健康是由于永久性故障导致, 则在不纠正该故障的情况下进行缩容可能会导致
StatefulSet 进入一种状态，其成员 Pod 数量低于应正常运行的副本数。
这种状态也许会导致 StatefulSet 不可用。</p>
<p>如果由于瞬态故障而导致 Pod 不健康并且 Pod 可能再次变为可用，那么瞬态错误可能会干扰
你对 StatefulSet 的扩容/缩容操作。 一些分布式数据库在同时有节点加入和离开时
会遇到问题。在这些情况下，最好是在应用级别进行分析扩缩操作的状态, 并且只有在确保
Stateful 应用的集群是完全健康时才执行扩缩操作。</p>
<h2 id=what-s-next>What's next</h2>
<ul>
<li>进一步了解<a href=/zh/docs/tasks/run-application/delete-stateful-set/>删除 StatefulSet</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-ca3bc4e31dfe46d5044a3b93eb804ee9>10 - 运行 Jobs</h1>
<div class=lead>使用并行处理运行 Jobs。</div>
</div>
<div class=td-content>
<h1 id=pg-964bdff888520740e5e221695245678d>10.1 - 使用 CronJob 运行自动化任务</h1>
<p>在Kubernetes v1.21 版本中，CronJob 被提升为通用版本。如果你使用的是旧版本的 Kubernetes，请参考你正在使用的 Kubernetes 版本的文档，这样你就能看到准确的信息。旧的 Kubernetes 版本不支持<code>batch/v1</code> CronJob API。</p>
<p>你可以利用 <a href=/zh/docs/concepts/workloads/controllers/cron-jobs>CronJobs</a> 执行基于时间调度的任务。这些自动化任务和 Linux 或者 Unix 系统的 <a href=https://en.wikipedia.org/wiki/Cron>Cron</a> 任务类似。</p>
<p>CronJobs 在创建周期性以及重复性的任务时很有帮助，例如执行备份操作或者发送邮件。CronJobs 也可以在特定时间调度单个任务，例如你想调度低活跃周期的任务。</p>
<p>CronJobs 有一些限制和特点。
例如，在特定状况下，同一个 CronJob 可以创建多个任务。
因此，任务应该是幂等的。</p>
<p>查看更多限制，请参考 <a href=/zh/docs/concepts/workloads/controllers/cron-jobs>CronJobs</a>。</p>
<h2 id=before-you-begin>Before you begin</h2>
<ul>
<li><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li>
</ul>
Your Kubernetes server must be at or later than version v1.21.
To check the version, enter <code>kubectl version</code>.
</li>
</ul>
<h2 id=创建-cronjob>创建 CronJob</h2>
<p>CronJob 需要一个配置文件。
本例中 CronJob 的<code>.spec</code> 配置文件每分钟打印出当前时间和一个问好信息：</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/application/job/cronjob.yaml download=application/job/cronjob.yaml><code>application/job/cronjob.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('application-job-cronjob-yaml')" title="Copy application/job/cronjob.yaml to clipboard">
</img>
</div>
<div class=includecode id=application-job-cronjob-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>batch/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>CronJob<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>hello<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>schedule</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;* * * * *&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>jobTemplate</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>hello<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox:1.28<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>imagePullPolicy</span>:<span style=color:#bbb> </span>IfNotPresent<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span>- /bin/sh<span style=color:#bbb>
</span><span style=color:#bbb>            </span>- -c<span style=color:#bbb>
</span><span style=color:#bbb>            </span>- date; echo Hello from the Kubernetes cluster<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>OnFailure<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>想要运行示例的 CronJob，可以下载示例文件并执行命令：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create -f https://k8s.io/examples/application/job/cronjob.yaml
</code></pre></div><pre><code>cronjob.batch/hello created
</code></pre>
<p>创建好 CronJob 后，使用下面的命令来获取其状态：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get cronjob hello
</code></pre></div>
<p>输出类似于：</p>
<pre><code>NAME    SCHEDULE      SUSPEND   ACTIVE   LAST SCHEDULE   AGE
hello   */1 * * * *   False     0        50s             75s
</code></pre>
<p>就像你从命令返回结果看到的那样，CronJob 还没有调度或执行任何任务。大约需要一分钟任务才能创建好。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get <span style=color:#a2f>jobs</span> --watch
</code></pre></div><pre><code>NAME               COMPLETIONS   DURATION   AGE
hello-4111706356   0/1                      0s
hello-4111706356   0/1           0s         0s
hello-4111706356   1/1           5s         5s
</code></pre>
<p>现在你已经看到了一个运行中的任务被 “hello” CronJob 调度。
你可以停止监视这个任务，然后再次查看 CronJob 就能看到它调度任务：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get cronjob hello
</code></pre></div>
<p>输出类似于：</p>
<pre><code>NAME    SCHEDULE      SUSPEND   ACTIVE   LAST SCHEDULE   AGE
hello   */1 * * * *   False     0        50s             75s
</code></pre>
<p>你应该能看到 <code>hello</code> CronJob 在 <code>LAST SCHEDULE</code> 声明的时间点成功的调度了一次任务。
有 0 个活跃的任务意味着任务执行完毕或者执行失败。</p>
<p>现在，找到最后一次调度任务创建的 Pod 并查看一个 Pod 的标准输出。</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> Job 名称和 Pod 名称不同。
</div>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># 在你的系统上将 &#34;hello-4111706356&#34; 替换为 Job 名称</span>
<span style=color:#b8860b>pods</span><span style=color:#666>=</span><span style=color:#a2f;font-weight:700>$(</span>kubectl get pods --selector<span style=color:#666>=</span>job-name<span style=color:#666>=</span>hello-4111706356 --output<span style=color:#666>=</span><span style=color:#b8860b>jsonpath</span><span style=color:#666>={</span>.items..metadata.name<span style=color:#666>}</span><span style=color:#a2f;font-weight:700>)</span>
</code></pre></div>
<p>查看 Pod 日志：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl logs <span style=color:#b8860b>$pods</span>
</code></pre></div>
<p>输出与此类似：</p>
<pre><code>Fri Feb 22 11:02:09 UTC 2019
Hello from the Kubernetes cluster
</code></pre>
<h2 id=删除-cronjob>删除 CronJob</h2>
<p>当你不再需要 CronJob 时，可以用 <code>kubectl delete cronjob &lt;cronjob name></code> 删掉它：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete cronjob hello
</code></pre></div>
<p>删除 CronJob 会清除它创建的所有任务和 Pod，并阻止它创建额外的任务。你可以查阅
<a href=/zh/docs/concepts/workloads/controllers/garbage-collection/>垃圾收集</a>。</p>
<h2 id=编写-cronjob-声明信息>编写 CronJob 声明信息</h2>
<p>像 Kubernetes 的其他配置一样，CronJob 需要 <code>apiVersion</code>、<code>kind</code>、和 <code>metadata</code> 域。
配置文件的一般信息，请参考
<a href=/zh/docs/tasks/run-application/run-stateless-application-deployment/>部署应用</a> 和
<a href=/zh/docs/concepts/overview/working-with-objects/object-management/>使用 kubectl 管理资源</a>.</p>
<p>CronJob 配置也需要包括
<a href=https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status><code>.spec</code></a>.</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 对 CronJob 的所有改动，特别是它的 <code>.spec</code>，只会影响将来的运行实例。
</div>
<h3 id=时间安排>时间安排</h3>
<p><code>.spec.schedule</code> 是 <code>.spec</code> 需要的域。它使用了 <a href=https://en.wikipedia.org/wiki/Cron>Cron</a>
格式串，例如 <code>0 * * * *</code> or <code>@hourly</code> ，作为它的任务被创建和执行的调度时间。</p>
<p>该格式也包含了扩展的 "Vixie cron" 步长值。
<a href=https://www.freebsd.org/cgi/man.cgi?crontab%285%29>FreeBSD 手册</a>中解释如下:</p>
<blockquote>
<p>步长可被用于范围组合。范围后面带有 <code>/&lt;数字></code> 可以声明范围内的步幅数值。
例如，<code>0-23/2</code> 可被用在小时域来声明命令在其他数值的小时数执行
（ V7 标准中对应的方法是<code>0,2,4,6,8,10,12,14,16,18,20,22</code>）。
步长也可以放在通配符后面，因此如果你想表达 "每两小时"，就用 <code>*/2</code> 。</p>
</blockquote>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 调度中的问号 (<code>?</code>) 和星号 <code>*</code> 含义相同，表示给定域的任何可用值。
</div>
<h3 id=任务模版>任务模版</h3>
<p><code>.spec.jobTemplate</code>是任务的模版，它是必须的。它和
<a href=/zh/docs/concepts/workloads/controllers/job/>Job</a>的语法完全一样，
除了它是嵌套的没有 <code>apiVersion</code> 和 <code>kind</code>。
编写任务的 <code>.spec</code> ，请参考
<a href=/zh/docs/concepts/workloads/controllers/job/#writing-a-job-spec>编写 Job 的Spec</a>。</p>
<h3 id=starting-deadline>开始的最后期限 </h3>
<p><code>.spec.startingDeadlineSeconds</code> 域是可选的。
它表示任务如果由于某种原因错过了调度时间，开始该任务的截止时间的秒数。过了截止时间，CronJob 就不会开始任务。
不满足这种最后期限的任务会被统计为失败任务。如果该域没有声明，那任务就没有最后期限。</p>
<p>如果<code>.spec.startingDeadlineSeconds</code>字段被设置(非空)，CronJob 控制器会计算从预期创建 Job 到当前时间的时间差。
如果时间差大于该限制，则跳过此次执行。</p>
<p>例如，如果将其设置为 <code>200</code>，则 Job 控制器允许在实际调度之后最多 200 秒内创建 Job。</p>
<h3 id=并发性规则>并发性规则</h3>
<p><code>.spec.concurrencyPolicy</code> 也是可选的。它声明了 CronJob 创建的任务执行时发生重叠如何处理。
spec 仅能声明下列规则中的一种：</p>
<ul>
<li><code>Allow</code> (默认)：CronJob 允许并发任务执行。</li>
<li><code>Forbid</code>： CronJob 不允许并发任务执行；如果新任务的执行时间到了而老任务没有执行完，CronJob 会忽略新任务的执行。</li>
<li><code>Replace</code>：如果新任务的执行时间到了而老任务没有执行完，CronJob 会用新任务替换当前正在运行的任务。</li>
</ul>
<p>请注意，并发性规则仅适用于相同 CronJob 创建的任务。如果有多个 CronJob，它们相应的任务总是允许并发执行的。</p>
<h3 id=挂起>挂起</h3>
<p><code>.spec.suspend</code>域也是可选的。如果设置为 <code>true</code> ，后续发生的执行都会挂起。
这个设置对已经开始的执行不起作用。默认是关闭的。</p>
<div class="alert alert-warning caution callout" role=alert>
<strong>Caution:</strong> 在调度时间内挂起的执行都会被统计为错过的任务。当 <code>.spec.suspend</code> 从 <code>true</code> 改为 <code>false</code> 时，
且没有 <a href=#starting-deadline>开始的最后期限</a>，错过的任务会被立即调度。
</div>
<h3 id=任务历史限制>任务历史限制</h3>
<p><code>.spec.successfulJobsHistoryLimit</code> 和 <code>.spec.failedJobsHistoryLimit</code>是可选的。
这两个字段指定应保留多少已完成和失败的任务。
默认设置为3和1。限制设置为 <code>0</code> 代表相应类型的任务完成后不会保留。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-1058efa4d70f13c015e6a2094ff85068>10.2 - 使用工作队列进行粗粒度并行处理</h1>
<p>本例中，我们会运行包含多个并行工作进程的 Kubernetes Job。</p>
<p>本例中，每个 Pod 一旦被创建，会立即从任务队列中取走一个工作单元并完成它，然后将工作单元从队列中删除后再退出。</p>
<p>下面是本次示例的主要步骤：</p>
<ol>
<li>
<p><strong>启动一个消息队列服务</strong> 本例中，我们使用 RabbitMQ，你也可以用其他的消息队列服务。在实际工作环境中，你可以创建一次消息队列服务然后在多个任务中重复使用。</p>
</li>
<li>
<p><strong>创建一个队列，放上消息数据</strong> 每个消息表示一个要执行的任务。本例中，每个消息是一个整数值。我们将基于这个整数值执行很长的计算操作。</p>
</li>
<li>
<p><strong>启动一个在队列中执行这些任务的 Job</strong>。该 Job 启动多个 Pod。每个 Pod 从消息队列中取走一个任务，处理它，然后重复执行，直到队列的队尾。</p>
</li>
</ol>
<h2 id=before-you-begin>Before you begin</h2>
<p>要熟悉 Job 基本用法（非并行的），请参考
<a href=/zh/docs/concepts/workloads/controllers/job/>Job</a>。</p>
<p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li>
</ul>
Your Kubernetes server must be at or later than version v1.8.
To check the version, enter <code>kubectl version</code>.
</p>
<h2 id=启动消息队列服务>启动消息队列服务</h2>
<p>本例使用了 RabbitMQ，但你可以更改该示例，使用其他 AMQP 类型的消息服务。</p>
<p>在实际工作中，在集群中一次性部署某个消息队列服务，之后在很多 Job 中复用，包括需要长期运行的服务。</p>
<p>按下面的方法启动 RabbitMQ：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create -f https://raw.githubusercontent.com/kubernetes/kubernetes/release-1.3/examples/celery-rabbitmq/rabbitmq-service.yaml
</code></pre></div><pre><code>service &quot;rabbitmq-service&quot; created
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create -f https://raw.githubusercontent.com/kubernetes/kubernetes/release-1.3/examples/celery-rabbitmq/rabbitmq-controller.yaml
</code></pre></div><pre><code>replicationcontroller &quot;rabbitmq-controller&quot; created
</code></pre>
<p>我们仅用到 <a href=https://github.com/kubernetes/kubernetes/tree/release-1.3/examples/celery-rabbitmq>celery-rabbitmq 示例</a> 中描述的部分功能。</p>
<h2 id=测试消息队列服务>测试消息队列服务</h2>
<p>现在，我们可以试着访问消息队列。我们将会创建一个临时的可交互的 Pod，在它上面安装一些工具，然后用队列做实验。</p>
<p>首先创建一个临时的可交互的 Pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># 创建一个临时的可交互的 Pod</span>
kubectl run -i --tty temp --image ubuntu:14.04
</code></pre></div><pre><code>Waiting for pod default/temp-loe07 to be running, status is Pending, pod ready: false
... [ previous line repeats several times .. hit return when it stops ] ...
</code></pre>
<p>请注意你的 Pod 名称和命令提示符将会不同。</p>
<p>接下来安装 <code>amqp-tools</code> ，这样我们就能用消息队列了。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># 安装一些工具</span>
root@temp-loe07:/# apt-get update
.... <span style=color:#666>[</span> lots of output <span style=color:#666>]</span> ....
root@temp-loe07:/# apt-get install -y curl ca-certificates amqp-tools python dnsutils
.... <span style=color:#666>[</span> lots of output <span style=color:#666>]</span> ....
</code></pre></div>
<p>后续，我们将制作一个包含这些包的 Docker 镜像。</p>
<p>接着，我们将要验证我们发现 RabbitMQ 服务：</p>
<pre><code># 请注意 rabbitmq-service 有Kubernetes 提供的 DNS 名称，

root@temp-loe07:/# nslookup rabbitmq-service
Server:        10.0.0.10
Address:    10.0.0.10#53

Name:    rabbitmq-service.default.svc.cluster.local
Address: 10.0.147.152

# 你的 IP 地址会不同
</code></pre>
<p>如果 Kube-DNS 没有正确安装，上一步可能会出错。
你也可以在环境变量中找到服务 IP。</p>
<pre><code># env | grep RABBIT | grep HOST
RABBITMQ_SERVICE_SERVICE_HOST=10.0.147.152

# 你的 IP 地址会有所不同
</code></pre>
<p>接着我们将要确认可以创建队列，并能发布消息和消费消息。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># 下一行，rabbitmq-service 是访问 rabbitmq-service 的主机名。5672是 rabbitmq 的标准端口。</span>

root@temp-loe07:/# <span style=color:#a2f>export</span> <span style=color:#b8860b>BROKER_URL</span><span style=color:#666>=</span>amqp://guest:guest@rabbitmq-service:5672

<span style=color:#080;font-style:italic># 如果上一步中你不能解析 &#34;rabbitmq-service&#34;，可以用下面的命令替换：</span>
<span style=color:#080;font-style:italic># root@temp-loe07:/# BROKER_URL=amqp://guest:guest@$RABBITMQ_SERVICE_SERVICE_HOST:5672</span>

<span style=color:#080;font-style:italic># 现在创建队列：</span>

root@temp-loe07:/# /usr/bin/amqp-declare-queue --url<span style=color:#666>=</span><span style=color:#b8860b>$BROKER_URL</span> -q foo -d foo

<span style=color:#080;font-style:italic># 向它推送一条消息:</span>

root@temp-loe07:/# /usr/bin/amqp-publish --url<span style=color:#666>=</span><span style=color:#b8860b>$BROKER_URL</span> -r foo -p -b Hello

<span style=color:#080;font-style:italic># 然后取回它.</span>

root@temp-loe07:/# /usr/bin/amqp-consume --url<span style=color:#666>=</span><span style=color:#b8860b>$BROKER_URL</span> -q foo -c <span style=color:#666>1</span> cat <span style=color:#666>&amp;&amp;</span> <span style=color:#a2f>echo</span>
Hello
root@temp-loe07:/#
</code></pre></div>
<p>最后一个命令中， <code>amqp-consume</code> 工具从队列中取走了一个消息，并把该消息传递给了随机命令的标准输出。
在这种情况下，<code>cat</code> 会打印它从标准输入中读取的字符，echo 会添加回车符以便示例可读。</p>
<h2 id=为队列增加任务>为队列增加任务</h2>
<p>现在让我们给队列增加一些任务。在我们的示例中，任务是多个待打印的字符串。</p>
<p>实践中，消息的内容可以是：</p>
<ul>
<li>待处理的文件名</li>
<li>程序额外的参数</li>
<li>数据库表的关键字范围</li>
<li>模拟任务的配置参数</li>
<li>待渲染的场景的帧序列号</li>
</ul>
<p>本例中，如果有大量的数据需要被 Job 的所有 Pod 读取，典型的做法是把它们放在一个共享文件系统中，如NFS，并以只读的方式挂载到所有 Pod，或者 Pod 中的程序从类似 HDFS 的集群文件系统中读取。</p>
<p>例如，我们创建队列并使用 amqp 命令行工具向队列中填充消息。实践中，你可以写个程序来利用 amqp 客户端库来填充这些队列。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>/usr/bin/amqp-declare-queue --url<span style=color:#666>=</span><span style=color:#b8860b>$BROKER_URL</span> -q job1  -d job1

<span style=color:#a2f;font-weight:700>for</span> f in apple banana cherry date fig grape lemon melon 
<span style=color:#a2f;font-weight:700>do</span>
  /usr/bin/amqp-publish --url<span style=color:#666>=</span><span style=color:#b8860b>$BROKER_URL</span> -r job1 -p -b <span style=color:#b8860b>$f</span>
<span style=color:#a2f;font-weight:700>done</span>
</code></pre></div>
<p>这样，我们给队列中填充了8个消息。</p>
<h2 id=创建镜像>创建镜像</h2>
<p>现在我们可以创建一个做为 Job 来运行的镜像。</p>
<p>我们将用 <code>amqp-consume</code> 来从队列中读取消息并实际运行我们的程序。这里给出一个非常简单的示例程序：</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/application/job/rabbitmq/worker.py download=application/job/rabbitmq/worker.py><code>application/job/rabbitmq/worker.py</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('application-job-rabbitmq-worker-py')" title="Copy application/job/rabbitmq/worker.py to clipboard">
</img>
</div>
<div class=includecode id=application-job-rabbitmq-worker-py>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#080;font-style:italic>#!/usr/bin/env python</span>

<span style=color:#080;font-style:italic># Just prints standard out and sleeps for 10 seconds.</span>
<span style=color:#a2f;font-weight:700>import</span> <span style=color:#00f;font-weight:700>sys</span>
<span style=color:#a2f;font-weight:700>import</span> <span style=color:#00f;font-weight:700>time</span>
<span style=color:#a2f>print</span>(<span style=color:#b44>&#34;Processing &#34;</span> <span style=color:#666>+</span> sys<span style=color:#666>.</span>stdin<span style=color:#666>.</span>readlines()[<span style=color:#666>0</span>])
time<span style=color:#666>.</span>sleep(<span style=color:#666>10</span>)
</code></pre></div>
</div>
</div>
<p>现在，编译镜像。如果你在用源代码树，那么切换到目录 <code>examples/job/work-queue-1</code>。
否则的话，创建一个临时目录，切换到这个目录。下载
<a href=/examples/application/job/rabbitmq/Dockerfile>Dockerfile</a>，和
<a href=/examples/application/job/rabbitmq/worker.py>worker.py</a>。
无论哪种情况，都可以用下面的命令编译镜像</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>docker build -t job-wq-1 .
</code></pre></div>
<p>对于 <a href=https://hub.docker.com/>Docker Hub</a>, 给你的应用镜像打上标签，
标签为你的用户名，然后用下面的命令推送到 Hub。用你的 Hub 用户名替换 <code>&lt;username></code>。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>docker tag job-wq-1 &lt;username&gt;/job-wq-1
docker push &lt;username&gt;/job-wq-1
</code></pre></div>
<p>如果你在用<a href=https://cloud.google.com/tools/container-registry/>谷歌容器仓库</a>，
用你的项目 ID 作为标签打到你的应用镜像上，然后推送到 GCR。
用你的项目 ID 替换 <code>&lt;project></code>。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>docker tag job-wq-1 gcr.io/&lt;project&gt;/job-wq-1
gcloud docker -- push gcr.io/&lt;project&gt;/job-wq-1
</code></pre></div>
<h2 id=定义-job>定义 Job</h2>
<p>这里给出一个 Job 定义 yaml文件。你需要拷贝一份并编辑镜像以匹配你使用的名称，保存为 <code>./job.yaml</code>。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/application/job/rabbitmq/job.yaml download=application/job/rabbitmq/job.yaml><code>application/job/rabbitmq/job.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('application-job-rabbitmq-job-yaml')" title="Copy application/job/rabbitmq/job.yaml to clipboard">
</img>
</div>
<div class=includecode id=application-job-rabbitmq-job-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>batch/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Job<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>job-wq-1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>completions</span>:<span style=color:#bbb> </span><span style=color:#666>8</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>parallelism</span>:<span style=color:#bbb> </span><span style=color:#666>2</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>job-wq-1<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>c<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>gcr.io/&lt;project&gt;/job-wq-1<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>BROKER_URL<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span>amqp://guest:guest@rabbitmq-service:5672<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>QUEUE<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span>job1<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>OnFailure<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>本例中，每个 Pod 使用队列中的一个消息然后退出。这样，Job 的完成计数就代表了完成的工作项的数量。本例中我们设置 <code>.spec.completions: 8</code>，因为我们放了8项内容在队列中。</p>
<h2 id=运行-job>运行 Job</h2>
<p>现在我们运行 Job：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create -f ./job.yaml
</code></pre></div>
<p>稍等片刻，然后检查 Job。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe jobs/job-wq-1
</code></pre></div><pre><code>Name:             job-wq-1
Namespace:        default
Selector:         controller-uid=41d75705-92df-11e7-b85e-fa163ee3c11f
Labels:           controller-uid=41d75705-92df-11e7-b85e-fa163ee3c11f
                  job-name=job-wq-1
Annotations:      &lt;none&gt;
Parallelism:      2
Completions:      8
Start Time:       Wed, 06 Sep 2017 16:42:02 +0800
Pods Statuses:    0 Running / 8 Succeeded / 0 Failed
Pod Template:
  Labels:       controller-uid=41d75705-92df-11e7-b85e-fa163ee3c11f
                job-name=job-wq-1
  Containers:
   c:
    Image:      gcr.io/causal-jigsaw-637/job-wq-1
    Port:
    Environment:
      BROKER_URL:       amqp://guest:guest@rabbitmq-service:5672
      QUEUE:            job1
    Mounts:             &lt;none&gt;
  Volumes:              &lt;none&gt;
Events:
  FirstSeen  LastSeen   Count    From    SubobjectPath    Type      Reason              Message
  ─────────  ────────   ─────    ────    ─────────────    ──────    ──────              ───────
  27s        27s        1        {job }                   Normal    SuccessfulCreate    Created pod: job-wq-1-hcobb
  27s        27s        1        {job }                   Normal    SuccessfulCreate    Created pod: job-wq-1-weytj
  27s        27s        1        {job }                   Normal    SuccessfulCreate    Created pod: job-wq-1-qaam5
  27s        27s        1        {job }                   Normal    SuccessfulCreate    Created pod: job-wq-1-b67sr
  26s        26s        1        {job }                   Normal    SuccessfulCreate    Created pod: job-wq-1-xe5hj
  15s        15s        1        {job }                   Normal    SuccessfulCreate    Created pod: job-wq-1-w2zqe
  14s        14s        1        {job }                   Normal    SuccessfulCreate    Created pod: job-wq-1-d6ppa
  14s        14s        1        {job }                   Normal    SuccessfulCreate    Created pod: job-wq-1-p17e0
</code></pre>
<p>我们所有的 Pod 都成功了。耶！</p>
<h2 id=替代方案>替代方案</h2>
<p>本文所讲述的处理方法的好处是你不需要修改你的 "worker" 程序使其知道工作队列的存在。</p>
<p>本文所描述的方法需要你运行一个消息队列服务。如果不方便运行消息队列服务，你也许会考虑另外一种
<a href=/zh/docs/concepts/workloads/controllers/job/#job-patterns>任务模式</a>。</p>
<p>本文所述的方法为每个工作项创建了一个 Pod。
如果你的工作项仅需数秒钟，为每个工作项创建 Pod会增加很多的常规消耗。
可以考虑另外的方案请参考<a href=/zh/docs/tasks/job/fine-parallel-processing-work-queue/>示例</a>，
这种方案可以实现每个 Pod 执行多个工作项。</p>
<p>示例中，我们使用 <code>amqp-consume</code> 从消息队列读取消息并执行我们真正的程序。
这样的好处是你不需要修改你的程序使其知道队列的存在。
要了解怎样使用客户端库和工作队列通信，请参考
<a href=/zh/docs/tasks/job/fine-parallel-processing-work-queue/>不同的示例</a>。</p>
<h2 id=友情提醒>友情提醒</h2>
<p>如果设置的完成数量小于队列中的消息数量，会导致一部分消息项不会被执行。</p>
<p>如果设置的完成数量大于队列中的消息数量，当队列中所有的消息都处理完成后，
Job 也会显示为未完成。Job 将创建 Pod 并阻塞等待消息输入。</p>
<p>当发生下面两种情况时，即使队列中所有的消息都处理完了，Job 也不会显示为完成状态：</p>
<ul>
<li>在 amqp-consume 命令拿到消息和容器成功退出之间的时间段内，执行杀死容器操作；</li>
<li>在 kubelet 向 api-server 传回 Pod 成功运行之前，发生节点崩溃。</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-457c9dd93aed2b05615ed28dc38075d3>10.3 - 使用工作队列进行精细的并行处理</h1>
<p>在这个例子中，我们会运行一个Kubernetes Job，其中的 Pod 会运行多个并行工作进程。</p>
<p>在这个例子中，当每个pod被创建时，它会从一个任务队列中获取一个工作单元，处理它，然后重复，直到到达队列的尾部。</p>
<p>下面是这个示例的步骤概述：</p>
<ol>
<li><strong>启动存储服务用于保存工作队列。</strong> 在这个例子中，我们使用 Redis 来存储工作项。
在上一个例子中，我们使用了 RabbitMQ。
在这个例子中，由于 AMQP 不能为客户端提供一个良好的方法来检测一个有限长度的工作队列是否为空，
我们使用了 Redis 和一个自定义的工作队列客户端库。
在实践中，你可能会设置一个类似于 Redis 的存储库，并将其同时用于多项任务或其他事务的工作队列。</li>
</ol>
<ol start=2>
<li><strong>创建一个队列，然后向其中填充消息。</strong> 每个消息表示一个将要被处理的工作任务。
在这个例子中，消息是一个我们将用于进行长度计算的整数。</li>
</ol>
<ol start=3>
<li><strong>启动一个 Job 对队列中的任务进行处理</strong>。这个 Job 启动了若干个 Pod 。
每个 Pod 从消息队列中取出一个工作任务，处理它，然后重复，直到到达队列的尾部。</li>
</ol>
<h2 id=before-you-begin>Before you begin</h2>
<p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li>
</ul>
Your Kubernetes server must be at or later than version v1.8.
To check the version, enter <code>kubectl version</code>.
</p>
<p>熟悉基本的、非并行的 <a href=/zh/docs/concepts/workloads/controllers/job/>Job</a>。</p>
<h2 id=启动-redis>启动 Redis</h2>
<p>对于这个例子，为了简单起见，我们将启动一个单实例的 Redis。
了解如何部署一个可伸缩、高可用的 Redis 例子，请查看
<a href=https://github.com/kubernetes/examples/tree/master/guestbook>Redis 示例</a></p>
<p>你也可以直接下载如下文件：</p>
<ul>
<li><a href=/examples/application/job/redis/redis-pod.yaml><code>redis-pod.yaml</code></a></li>
<li><a href=/examples/application/job/redis/redis-service.yaml><code>redis-service.yaml</code></a></li>
<li><a href=/examples/application/job/redis/Dockerfile><code>Dockerfile</code></a></li>
<li><a href=/examples/application/job/redis/job.yaml><code>job.yaml</code></a></li>
<li><a href=/examples/application/job/redis/rediswq.py><code>rediswq.py</code></a></li>
<li><a href=/examples/application/job/redis/worker.py><code>worker.py</code></a></li>
</ul>
<h2 id=使用任务填充队列>使用任务填充队列</h2>
<p>现在，让我们往队列里添加一些“任务”。在这个例子中，我们的任务是一些将被打印出来的字符串。</p>
<p>启动一个临时的可交互的 pod 用于运行 Redis 命令行界面。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl run -i --tty temp --image redis --command <span style=color:#b44>&#34;/bin/sh&#34;</span>
</code></pre></div><pre><code>Waiting for pod default/redis2-c7h78 to be running, status is Pending, pod ready: false
Hit enter for command prompt
</code></pre>
<p>现在按回车键，启动 redis 命令行界面，然后创建一个存在若干个工作项的列表。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># redis-cli -h redis</span>
redis:6379&gt; rpush job2 <span style=color:#b44>&#34;apple&#34;</span>
<span style=color:#666>(</span>integer<span style=color:#666>)</span> <span style=color:#666>1</span>
redis:6379&gt; rpush job2 <span style=color:#b44>&#34;banana&#34;</span>
<span style=color:#666>(</span>integer<span style=color:#666>)</span> <span style=color:#666>2</span>
redis:6379&gt; rpush job2 <span style=color:#b44>&#34;cherry&#34;</span>
<span style=color:#666>(</span>integer<span style=color:#666>)</span> <span style=color:#666>3</span>
redis:6379&gt; rpush job2 <span style=color:#b44>&#34;date&#34;</span>
<span style=color:#666>(</span>integer<span style=color:#666>)</span> <span style=color:#666>4</span>
redis:6379&gt; rpush job2 <span style=color:#b44>&#34;fig&#34;</span>
<span style=color:#666>(</span>integer<span style=color:#666>)</span> <span style=color:#666>5</span>
redis:6379&gt; rpush job2 <span style=color:#b44>&#34;grape&#34;</span>
<span style=color:#666>(</span>integer<span style=color:#666>)</span> <span style=color:#666>6</span>
redis:6379&gt; rpush job2 <span style=color:#b44>&#34;lemon&#34;</span>
<span style=color:#666>(</span>integer<span style=color:#666>)</span> <span style=color:#666>7</span>
redis:6379&gt; rpush job2 <span style=color:#b44>&#34;melon&#34;</span>
<span style=color:#666>(</span>integer<span style=color:#666>)</span> <span style=color:#666>8</span>
redis:6379&gt; rpush job2 <span style=color:#b44>&#34;orange&#34;</span>
<span style=color:#666>(</span>integer<span style=color:#666>)</span> <span style=color:#666>9</span>
redis:6379&gt; lrange job2 <span style=color:#666>0</span> -1
1<span style=color:#666>)</span> <span style=color:#b44>&#34;apple&#34;</span>
2<span style=color:#666>)</span> <span style=color:#b44>&#34;banana&#34;</span>
3<span style=color:#666>)</span> <span style=color:#b44>&#34;cherry&#34;</span>
4<span style=color:#666>)</span> <span style=color:#b44>&#34;date&#34;</span>
5<span style=color:#666>)</span> <span style=color:#b44>&#34;fig&#34;</span>
6<span style=color:#666>)</span> <span style=color:#b44>&#34;grape&#34;</span>
7<span style=color:#666>)</span> <span style=color:#b44>&#34;lemon&#34;</span>
8<span style=color:#666>)</span> <span style=color:#b44>&#34;melon&#34;</span>
9<span style=color:#666>)</span> <span style=color:#b44>&#34;orange&#34;</span>
</code></pre></div>
<p>因此，这个键为 <code>job2</code> 的列表就是我们的工作队列。</p>
<p>注意：如果你还没有正确地配置 Kube DNS，你可能需要将上面的第一步改为
<code>redis-cli -h $REDIS_SERVICE_HOST</code>。</p>
<h2 id=创建镜像>创建镜像</h2>
<p>现在我们已经准备好创建一个我们要运行的镜像</p>
<p>我们会使用一个带有 redis 客户端的 python 工作程序从消息队列中读出消息。</p>
<p>这里提供了一个简单的 Redis 工作队列客户端库，叫 rediswq.py (<a href=/examples/application/job/redis/rediswq.py>下载</a>)。</p>
<p>Job 中每个 Pod 内的 “工作程序” 使用工作队列客户端库获取工作。如下：</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/application/job/redis/worker.py download=application/job/redis/worker.py><code>application/job/redis/worker.py</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('application-job-redis-worker-py')" title="Copy application/job/redis/worker.py to clipboard">
</img>
</div>
<div class=includecode id=application-job-redis-worker-py>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#080;font-style:italic>#!/usr/bin/env python</span>

<span style=color:#a2f;font-weight:700>import</span> <span style=color:#00f;font-weight:700>time</span>
<span style=color:#a2f;font-weight:700>import</span> <span style=color:#00f;font-weight:700>rediswq</span>

host<span style=color:#666>=</span><span style=color:#b44>&#34;redis&#34;</span>
<span style=color:#080;font-style:italic># Uncomment next two lines if you do not have Kube-DNS working.</span>
<span style=color:#080;font-style:italic># import os</span>
<span style=color:#080;font-style:italic># host = os.getenv(&#34;REDIS_SERVICE_HOST&#34;)</span>

q <span style=color:#666>=</span> rediswq<span style=color:#666>.</span>RedisWQ(name<span style=color:#666>=</span><span style=color:#b44>&#34;job2&#34;</span>, host<span style=color:#666>=</span>host)
<span style=color:#a2f>print</span>(<span style=color:#b44>&#34;Worker with sessionID: &#34;</span> <span style=color:#666>+</span>  q<span style=color:#666>.</span>sessionID())
<span style=color:#a2f>print</span>(<span style=color:#b44>&#34;Initial queue state: empty=&#34;</span> <span style=color:#666>+</span> <span style=color:#a2f>str</span>(q<span style=color:#666>.</span>empty()))
<span style=color:#a2f;font-weight:700>while</span> <span style=color:#a2f;font-weight:700>not</span> q<span style=color:#666>.</span>empty():
  item <span style=color:#666>=</span> q<span style=color:#666>.</span>lease(lease_secs<span style=color:#666>=</span><span style=color:#666>10</span>, block<span style=color:#666>=</span><span style=color:#a2f;font-weight:700>True</span>, timeout<span style=color:#666>=</span><span style=color:#666>2</span>)
  <span style=color:#a2f;font-weight:700>if</span> item <span style=color:#a2f;font-weight:700>is</span> <span style=color:#a2f;font-weight:700>not</span> <span style=color:#a2f;font-weight:700>None</span>:
    itemstr <span style=color:#666>=</span> item<span style=color:#666>.</span>decode(<span style=color:#b44>&#34;utf-8&#34;</span>)
    <span style=color:#a2f>print</span>(<span style=color:#b44>&#34;Working on &#34;</span> <span style=color:#666>+</span> itemstr)
    time<span style=color:#666>.</span>sleep(<span style=color:#666>10</span>) <span style=color:#080;font-style:italic># Put your actual work here instead of sleep.</span>
    q<span style=color:#666>.</span>complete(item)
  <span style=color:#a2f;font-weight:700>else</span>:
    <span style=color:#a2f>print</span>(<span style=color:#b44>&#34;Waiting for work&#34;</span>)
<span style=color:#a2f>print</span>(<span style=color:#b44>&#34;Queue empty, exiting&#34;</span>)
</code></pre></div>
</div>
</div>
<p>你也可以下载 <a href=/examples/application/job/redis/worker.py><code>worker.py</code></a>、
<a href=/examples/application/job/redis/rediswq.py><code>rediswq.py</code></a> 和
<a href=/examples/application/job/redis/Dockerfile><code>Dockerfile</code></a>。然后构建镜像：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>docker build -t job-wq-2 .
</code></pre></div>
<h3 id=push-镜像>Push 镜像</h3>
<p>对于 <a href=https://hub.docker.com/>Docker Hub</a>，请先用你的用户名给镜像打上标签，
然后使用下面的命令 push 你的镜像到仓库。请将 <code>&lt;username></code> 替换为你自己的 Hub 用户名。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>docker tag job-wq-2 &lt;username&gt;/job-wq-2
docker push &lt;username&gt;/job-wq-2
</code></pre></div>
<p>你需要将镜像 push 到一个公共仓库或者
<a href=/zh/docs/concepts/containers/images/>配置集群访问你的私有仓库</a>。</p>
<p>如果你使用的是 <a href=https://cloud.google.com/tools/container-registry/>Google Container Registry</a>，
请先用你的 project ID 给你的镜像打上标签，然后 push 到 GCR 。请将 <code>&lt;project></code> 替换为你自己的 project ID</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>docker tag job-wq-2 gcr.io/&lt;project&gt;/job-wq-2
gcloud docker -- push gcr.io/&lt;project&gt;/job-wq-2
</code></pre></div>
<h2 id=定义一个-job>定义一个 Job</h2>
<p>这是 job 定义：</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/application/job/redis/job.yaml download=application/job/redis/job.yaml><code>application/job/redis/job.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('application-job-redis-job-yaml')" title="Copy application/job/redis/job.yaml to clipboard">
</img>
</div>
<div class=includecode id=application-job-redis-job-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>batch/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Job<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>job-wq-2<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>parallelism</span>:<span style=color:#bbb> </span><span style=color:#666>2</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>job-wq-2<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>c<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>gcr.io/myproject/job-wq-2<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>OnFailure<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>请确保将 job 模板中的 <code>gcr.io/myproject</code> 更改为你自己的路径。</p>
<p>在这个例子中，每个 pod 处理了队列中的多个项目，直到队列中没有项目时便退出。
因为是由工作程序自行检测工作队列是否为空，并且 Job 控制器不知道工作队列的存在，
这依赖于工作程序在完成工作时发出信号。
工作程序以成功退出的形式发出信号表示工作队列已经为空。
所以，只要有任意一个工作程序成功退出，控制器就知道工作已经完成了，所有的 Pod 将很快会退出。
因此，我们将 Job 的完成计数（Completion Count）设置为 1 。
尽管如此，Job 控制器还是会等待其它 Pod 完成。</p>
<h2 id=运行-job>运行 Job</h2>
<p>现在运行这个 Job ：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f ./job.yaml
</code></pre></div>
<p>稍等片刻，然后检查这个 Job。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe jobs/job-wq-2
</code></pre></div><pre><code>Name:             job-wq-2
Namespace:        default
Selector:         controller-uid=b1c7e4e3-92e1-11e7-b85e-fa163ee3c11f
Labels:           controller-uid=b1c7e4e3-92e1-11e7-b85e-fa163ee3c11f
                  job-name=job-wq-2
Annotations:      &lt;none&gt;
Parallelism:      2
Completions:      &lt;unset&gt;
Start Time:       Mon, 11 Jan 2016 17:07:59 -0800
Pods Statuses:    1 Running / 0 Succeeded / 0 Failed
Pod Template:
  Labels:       controller-uid=b1c7e4e3-92e1-11e7-b85e-fa163ee3c11f
                job-name=job-wq-2
  Containers:
   c:
    Image:              gcr.io/exampleproject/job-wq-2
    Port:
    Environment:        &lt;none&gt;
    Mounts:             &lt;none&gt;
  Volumes:              &lt;none&gt;
Events:
  FirstSeen    LastSeen    Count    From            SubobjectPath    Type        Reason            Message
  ---------    --------    -----    ----            -------------    --------    ------            -------
  33s          33s         1        {job-controller }                Normal      SuccessfulCreate  Created pod: job-wq-2-lglf8
</code></pre><p>查看日志：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl logs pods/job-wq-2-7r7b2
</code></pre></div><pre><code>Worker with sessionID: bbd72d0a-9e5c-4dd6-abf6-416cc267991f
Initial queue state: empty=False
Working on banana
Working on date
Working on lemon
</code></pre>
<p>你可以看到，其中的一个 pod 处理了若干个工作单元。</p>
<h2 id=替代方案>替代方案</h2>
<p>如果你不方便运行一个队列服务或者修改你的容器用于运行一个工作队列，你可以考虑其它的
<a href=/zh/docs/concepts/workloads/controllers/job/#job-patterns>Job 模式</a>。</p>
<p>如果你有持续的后台处理业务，那么可以考虑使用 <code>ReplicaSet</code> 来运行你的后台业务，
和运行一个类似 <a href=https://github.com/resque/resque>https://github.com/resque/resque</a>
的后台处理库。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-9e63850014876afaebd1561f70bb8f6b>10.4 - 使用索引作业完成静态工作分配下的并行处理</h1>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.22 [beta]</code>
</div>
<p>在此示例中，你将运行一个使用多个并行工作进程的 Kubernetes Job。
每个 worker 都是在自己的 Pod 中运行的不同容器。
Pod 具有控制平面自动设置的 <em>索引编号（index number）</em>，
这些编号使得每个 Pod 能识别出要处理整个任务的哪个部分。</p>
<p>Pod 索引在<a class=glossary-tooltip title=注解是以键值对的形式给资源对象附加随机的无法标识的元数据。 data-toggle=tooltip data-placement=top href=/zh/docs/concepts/overview/working-with-objects/annotations/ target=_blank aria-label=注解>注解</a>
<code>batch.kubernetes.io/job-completion-index</code> 中呈现，具体表示为一个十进制值字符串。
为了让容器化的任务进程获得此索引，你可以使用
<a href=/zh/docs/tasks/inject-data-application/downward-api-volume-expose-pod-information/#the-downward-api>downward API</a>
机制发布注解的值。为方便起见，
控制平面自动设置 downward API 以在 <code>JOB_COMPLETION_INDEX</code> 环境变量中公开索引。</p>
<p>以下是此示例中步骤的概述：</p>
<ol>
<li><strong>定义使用带索引完成信息的 Job 清单</strong>。
Downward API 使你可以将 Pod 索引注释作为环境变量或文件传递给容器。</li>
<li><strong>根据该清单启动一个带索引（<code>Indexed</code>）的 Job</strong>。</li>
</ol>
<h2 id=before-you-begin>Before you begin</h2>
<p>你应该已经熟悉 <a href=/zh/docs/concepts/workloads/controllers/job/>Job</a> 的基本的、非并行的用法。</p>
<p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li>
</ul>
Your Kubernetes server must be at or later than version v1.21.
To check the version, enter <code>kubectl version</code>.
</p>
<h2 id=选择一种方法>选择一种方法</h2>
<p>要从工作程序访问工作项，你有几个选择：</p>
<ol>
<li>读取 <code>JOB_COMPLETION_INDEX</code> 环境变量。Job
<a class=glossary-tooltip title="控制器通过 apiserver 监控集群的公共状态，并致力于将当前状态转变为期望的状态。" data-toggle=tooltip data-placement=top href=/zh/docs/concepts/architecture/controller/ target=_blank aria-label=控制器>控制器</a>
自动将此变量链接到包含完成索引的注解。</li>
<li>读取包含完整索引的文件。</li>
<li>假设你无法修改程序，你可以使用脚本包装它，
该脚本使用上述任意方法读取索引并将其转换为程序可以用作输入的内容。</li>
</ol>
<p>对于此示例，假设你选择了方法 3 并且想要运行
<a href=https://man7.org/linux/man-pages/man1/rev.1.html>rev</a> 实用程序。
这个程序接受一个文件作为参数并按逆序打印其内容。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>rev data.txt
</code></pre></div>
<p>你将使用 <a href=https://hub.docker.com/_/busybox><code>busybox</code></a> 容器映像中的 <code>rev</code> 工具。</p>
<p>由于这只是一个例子，每个 Pod 只做一小部分工作（反转一个短字符串）。
例如，在实际工作负载中，你可能会创建一个表示基于场景数据制作 60 秒视频的任务的 Job 。
视频渲染 Job 中的每个工作项都将渲染该视频剪辑的特定帧。
索引完成意味着 Job 中的每个 Pod 都知道通过从剪辑开始计算帧数，来确定渲染和发布哪一帧，。</p>
<h2 id=定义索引作业>定义索引作业</h2>
<p>这是一个使用 <code>Indexed</code> 完成模式的示例 Job 清单：</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/application/job/indexed-job.yaml download=application/job/indexed-job.yaml><code>application/job/indexed-job.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('application-job-indexed-job-yaml')" title="Copy application/job/indexed-job.yaml to clipboard">
</img>
</div>
<div class=includecode id=application-job-indexed-job-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>batch/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Job<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;indexed-job&#39;</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>completions</span>:<span style=color:#bbb> </span><span style=color:#666>5</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>parallelism</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>completionMode</span>:<span style=color:#bbb> </span>Indexed<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>initContainers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;input&#39;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;docker.io/library/bash&#39;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:#b44>&#34;bash&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:#b44>&#34;-c&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span>- |<span style=color:#b44;font-style:italic>
</span><span style=color:#b44;font-style:italic>          items=(foo bar baz qux xyz)
</span><span style=color:#b44;font-style:italic>          echo ${items[$JOB_COMPLETION_INDEX]} &gt; /input/data.txt</span><span style=color:#bbb>          
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/input<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>input<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;worker&#39;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;docker.io/library/busybox&#39;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:#b44>&#34;rev&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:#b44>&#34;/input/data.txt&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/input<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>input<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>input<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>emptyDir</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>在上面的示例中，你使用 Job 控制器为所有容器设置的内置 <code>JOB_COMPLETION_INDEX</code> 环境变量。
<a href=/zh/docs/concepts/workloads/pods/init-containers/>Init 容器</a>
将索引映射到一个静态值，并将其写入一个文件，该文件通过
<a href=/zh/docs/concepts/storage/volumes/#emptydir>emptyDir 卷</a>
与运行 worker 的容器共享。或者，你可以
<a href=/zh/docs/tasks/inject-data-application/environment-variable-expose-pod-information/>通过 Downward API 定义自己的环境变量</a>
将索引发布到容器。你还可以选择从
<a href=/zh/docs/tasks/configure-pod-container/configure-pod-configmap/>包含 ConfigMap 的环境变量或文件</a>
加载值列表。</p>
<p>或者也可以直接
<a href=/zh/docs/tasks/inject-data-application/downward-api-volume-expose-pod-information/#store-pod-fields>使用 Downward API 将注解值作为卷文件传递</a>，
如下例所示：</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/application/job/indexed-job-vol.yaml download=application/job/indexed-job-vol.yaml><code>application/job/indexed-job-vol.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('application-job-indexed-job-vol-yaml')" title="Copy application/job/indexed-job-vol.yaml to clipboard">
</img>
</div>
<div class=includecode id=application-job-indexed-job-vol-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>batch/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Job<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;indexed-job&#39;</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>completions</span>:<span style=color:#bbb> </span><span style=color:#666>5</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>parallelism</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>completionMode</span>:<span style=color:#bbb> </span>Indexed<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;worker&#39;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;docker.io/library/busybox&#39;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:#b44>&#34;rev&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:#b44>&#34;/input/data.txt&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/input<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>input<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>input<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>downwardAPI</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>items</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span>- <span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;data.txt&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>fieldRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>fieldPath</span>:<span style=color:#bbb> </span>metadata.annotations[&#39;batch.kubernetes.io/job-completion-index&#39;]</code></pre></div>
</div>
</div>
<h2 id=执行-job>执行 Job</h2>
<p>现在执行 Job：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># 使用第一种方法（依赖于 $JOB_COMPLETION_INDEX）</span>
kubectl apply -f https://kubernetes.io/examples/application/job/indexed-job.yaml
</code></pre></div>
<p>当你创建此 Job 时，控制平面会创建一系列 Pod，每个索引都由你指定。
<code>.spec.parallelism</code> 的值决定了一次可以运行多少个，
而 <code>.spec.completions</code> 决定了 Job 总共创建了多少个 Pod。</p>
<p>因为 <code>.spec.parallelism</code> 小于 <code>.spec.completions</code>，
控制平面在启动更多 Pod 之前，等待部分第一批 Pod 完成。</p>
<p>创建 Job 后，稍等片刻，然后检查进度：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe jobs/indexed-job
</code></pre></div>
<p>输出类似于：</p>
<pre><code>Name:              indexed-job
Namespace:         default
Selector:          controller-uid=bf865e04-0b67-483b-9a90-74cfc4c3e756
Labels:            controller-uid=bf865e04-0b67-483b-9a90-74cfc4c3e756
                   job-name=indexed-job
Annotations:       &lt;none&gt;
Parallelism:       3
Completions:       5
Start Time:        Thu, 11 Mar 2021 15:47:34 +0000
Pods Statuses:     2 Running / 3 Succeeded / 0 Failed
Completed Indexes: 0-2
Pod Template:
  Labels:  controller-uid=bf865e04-0b67-483b-9a90-74cfc4c3e756
           job-name=indexed-job
  Init Containers:
   input:
    Image:      docker.io/library/bash
    Port:       &lt;none&gt;
    Host Port:  &lt;none&gt;
    Command:
      bash
      -c
      items=(foo bar baz qux xyz)
      echo ${items[$JOB_COMPLETION_INDEX]} &gt; /input/data.txt

    Environment:  &lt;none&gt;
    Mounts:
      /input from input (rw)
  Containers:
   worker:
    Image:      docker.io/library/busybox
    Port:       &lt;none&gt;
    Host Port:  &lt;none&gt;
    Command:
      rev
      /input/data.txt
    Environment:  &lt;none&gt;
    Mounts:
      /input from input (rw)
  Volumes:
   input:
    Type:       EmptyDir (a temporary directory that shares a pod's lifetime)
    Medium:
    SizeLimit:  &lt;unset&gt;
Events:
  Type    Reason            Age   From            Message
  ----    ------            ----  ----            -------
  Normal  SuccessfulCreate  4s    job-controller  Created pod: indexed-job-njkjj
  Normal  SuccessfulCreate  4s    job-controller  Created pod: indexed-job-9kd4h
  Normal  SuccessfulCreate  4s    job-controller  Created pod: indexed-job-qjwsz
  Normal  SuccessfulCreate  1s    job-controller  Created pod: indexed-job-fdhq5
  Normal  SuccessfulCreate  1s    job-controller  Created pod: indexed-job-ncslj
</code></pre>
<p>在此示例中，你使用每个索引的自定义值运行 Job。
你可以检查其中一个 Pod 的输出：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl logs indexed-job-fdhq5 <span style=color:#080;font-style:italic># 更改它以匹配来自该 Job 的 Pod 的名称</span>
</code></pre></div>
<p>输出类似于：</p>
<pre><code>xuq
</code></pre>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-da7c2b067953d239eb4457e8978ad8f6>10.5 - 使用展开的方式进行并行处理</h1>
<p>本任务展示基于一个公共的模板运行多个<a class=glossary-tooltip title="Job 是需要运行完成的确定性的或批量的任务。" data-toggle=tooltip data-placement=top href=/zh/docs/concepts/workloads/controllers/job/ target=_blank aria-label=Jobs>Jobs</a>。
你可以用这种方法来并行执行批处理任务。</p>
<p>在本任务示例中，只有三个工作条目：<em>apple</em>、<em>banana</em> 和 <em>cherry</em>。
示例任务处理每个条目时打印一个字符串之后结束。</p>
<p>参考<a href=#using-jobs-in-real-workloads>在真实负载中使用 Job</a>了解更适用于真实使用场景的模式。</p>
<h2 id=before-you-begin>Before you begin</h2>
<p>你应先熟悉基本的、非并行的 <a href=/zh/docs/concepts/workloads/controllers/job/>Job</a>
的用法。</p>
<p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li>
</ul>
<p>任务中的基本模板示例要求安装命令行工具 <code>sed</code>。
要使用较高级的模板示例，你需要安装 <a href=https://www.python.org/>Python</a>，
并且要安装 Jinja2 模板库。</p>
<p>一旦 Python 已经安装好，你可以运行下面的命令安装 Jinja2：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>pip install --user jinja2
</code></pre></div>
<h2 id=create-jobs-based-on-a-template>基于模板创建 Job </h2>
<p>首先，将以下作业模板下载到名为 <code>job-tmpl.yaml</code> 的文件中。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/application/job/job-tmpl.yaml download=application/job/job-tmpl.yaml><code>application/job/job-tmpl.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('application-job-job-tmpl-yaml')" title="Copy application/job/job-tmpl.yaml to clipboard">
</img>
</div>
<div class=includecode id=application-job-job-tmpl-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>batch/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Job<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>process-item-$ITEM<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>jobgroup</span>:<span style=color:#bbb> </span>jobexample<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>jobexample<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>jobgroup</span>:<span style=color:#bbb> </span>jobexample<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>c<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox:1.28<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;sh&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;-c&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;echo Processing item $ITEM &amp;&amp; sleep 5&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell> <span style=color:#080;font-style:italic># 使用 curl 下载 job-tmpl.yaml</span>
curl -L -s -O https://k8s.io/examples/application/job/job-tmpl.yaml
</code></pre></div>
<p>你所下载的文件不是一个合法的 Kubernetes <a class=glossary-tooltip title="一个或多个 Kubernetes API 对象的序列化规范。" data-toggle=tooltip data-placement=top href="/zh/docs/reference/glossary/?all=true#term-manifest" target=_blank aria-label=清单>清单</a>。
这里的模板只是 Job 对象的 yaml 表示，其中包含一些占位符，在使用它之前需要被填充。
<code>$ITEM</code> 语法对 Kubernetes 没有意义。</p>
<h3 id=基于模板创建清单>基于模板创建清单</h3>
<p>下面的 Shell 代码片段使用 <code>sed</code> 将字符串 <code>$ITEM</code> 替换为循环变量，并将结果
写入到一个名为 <code>jobs</code> 的临时目录。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># 展开模板文件到多个文件中，每个文件对应一个要处理的条目</span>
mkdir ./jobs
<span style=color:#a2f;font-weight:700>for</span> i in apple banana cherry
<span style=color:#a2f;font-weight:700>do</span>
  cat job-tmpl.yaml | sed <span style=color:#b44>&#34;s/\$ITEM/</span><span style=color:#b8860b>$i</span><span style=color:#b44>/&#34;</span> &gt; ./jobs/job-<span style=color:#b8860b>$i</span>.yaml
<span style=color:#a2f;font-weight:700>done</span>
</code></pre></div>
<p>检查上述脚本的输出：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>ls jobs/
</code></pre></div>
<p>输出类似于：</p>
<pre><code>job-apple.yaml
job-banana.yaml
job-cherry.yaml
</code></pre>
<p>你可以使用任何一种模板语言（例如：Jinja2、ERB），或者编写一个程序来
生成 Job 清单。</p>
<h3 id=基于清单创建-job>基于清单创建 Job</h3>
<p>接下来用一个 kubectl 命令创建所有的 Job：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create -f ./jobs
</code></pre></div>
<p>输出类似于：</p>
<pre><code>job.batch/process-item-apple created
job.batch/process-item-banana created
job.batch/process-item-cherry created
</code></pre>
<p>现在检查 Job：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get <span style=color:#a2f>jobs</span> -l <span style=color:#b8860b>jobgroup</span><span style=color:#666>=</span>jobexample
</code></pre></div>
<p>输出类似于：</p>
<pre><code>NAME                  COMPLETIONS   DURATION   AGE
process-item-apple    1/1           14s        22s
process-item-banana   1/1           12s        21s
process-item-cherry   1/1           12s        20s
</code></pre>
<p>使用 kubectl 的 <code>-l</code> 选项可以仅选择属于当前 Job 组的对象
（系统中可能存在其他不相关的 Job）。</p>
<p>你可以使用相同的 <a class=glossary-tooltip title=选择算符允许用户通过标签对一组资源对象进行筛选过滤。 data-toggle=tooltip data-placement=top href=/zh/docs/concepts/overview/working-with-objects/labels/ target=_blank aria-label=标签选择算符>标签选择算符</a>
来过滤 Pods：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods -l <span style=color:#b8860b>jobgroup</span><span style=color:#666>=</span>jobexample
</code></pre></div>
<p>输出类似于：</p>
<pre><code>NAME                        READY     STATUS      RESTARTS   AGE
process-item-apple-kixwv    0/1       Completed   0          4m
process-item-banana-wrsf7   0/1       Completed   0          4m
process-item-cherry-dnfu9   0/1       Completed   0          4m
</code></pre>
<p>我们可以用下面的命令查看所有 Job 的输出：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl logs -f -l <span style=color:#b8860b>jobgroup</span><span style=color:#666>=</span>jobexample
</code></pre></div>
<p>输出类似于：</p>
<pre><code>Processing item apple
Processing item banana
Processing item cherry
</code></pre>
<h3 id=cleanup-1>清理</h3>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># 删除所创建的 Job</span>
<span style=color:#080;font-style:italic># 集群会自动清理 Job 对应的 Pod</span>
kubectl delete job -l <span style=color:#b8860b>jobgroup</span><span style=color:#666>=</span>jobexample
</code></pre></div>
<h2 id=使用高级模板参数>使用高级模板参数</h2>
<p>在<a href=#create-jobs-based-on-a-template>第一个例子</a>中，模板的每个示例都有一个参数
而该参数也用在 Job 名称中。不过，对象
<a href=/zh/docs/concepts/overview/working-with-objects/names/#names>名称</a>
被限制只能使用某些字符。</p>
<p>这里的略微复杂的例子使用 <a href=https://palletsprojects.com/p/jinja/>Jinja 模板语言</a>
来生成清单，并基于清单来生成对象，每个 Job 都有多个参数。</p>
<p>在本任务中，你将会使用一个一行的 Python 脚本，将模板转换为一组清单文件。</p>
<p>首先，复制下面的 Job 对象模板到一个名为 <code>job.yaml.jinja2</code> 的文件。</p>
<pre><code class=language-liquid data-lang=liquid>{% set params = [{ &quot;name&quot;: &quot;apple&quot;, &quot;url&quot;: &quot;http://dbpedia.org/resource/Apple&quot;, },
                  { &quot;name&quot;: &quot;banana&quot;, &quot;url&quot;: &quot;http://dbpedia.org/resource/Banana&quot;, },
                  { &quot;name&quot;: &quot;cherry&quot;, &quot;url&quot;: &quot;http://dbpedia.org/resource/Cherry&quot; }]
%}
{% for p in params %}
{% set name = p[&quot;name&quot;] %}
{% set url = p[&quot;url&quot;] %}
---
apiVersion: batch/v1
kind: Job
metadata:
  name: jobexample-{{ name }}
  labels:
    jobgroup: jobexample
spec:
  template:
    metadata:
      name: jobexample
      labels:
        jobgroup: jobexample
    spec:
      containers:
      - name: c
        image: busybox:1.28
        command: [&quot;sh&quot;, &quot;-c&quot;, &quot;echo Processing URL {{ url }} &amp;&amp; sleep 5&quot;]
      restartPolicy: Never
{% endfor %}
</code></pre>
<p>上面的模板使用 python 字典列表（第 1-4 行）定义每个作业对象的参数。
然后使用 for 循环为每组参数（剩余行）生成一个作业 yaml 对象。
我们利用了多个 YAML 文档（这里的 Kubernetes 清单）可以用 <code>---</code> 分隔符连接的事实。
我们可以将输出直接传递给 kubectl 来创建对象。</p>
<p>接下来我们用单行的 Python 程序将模板展开。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#a2f>alias</span> <span style=color:#b8860b>render_template</span><span style=color:#666>=</span><span style=color:#b44>&#39;python -c &#34;from jinja2 import Template; import sys; print(Template(sys.stdin.read()).render());&#34;&#39;</span>
</code></pre></div>
<p>使用 <code>render_template</code> 将参数和模板转换成一个 YAML 文件，其中包含 Kubernetes
资源清单：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># 此命令需要之前定义的别名</span>
cat job.yaml.jinja2 | render_template &gt; jobs.yaml
</code></pre></div>
<p>你可以查看 <code>jobs.yaml</code> 以验证 <code>render_template</code> 脚本是否正常工作。</p>
<p>当你对输出结果比较满意时，可以用管道将其输出发送给 kubectl，如下所示：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>cat job.yaml.jinja2 | render_template | kubectl apply -f -
</code></pre></div>
<p>Kubernetes 接收清单文件并执行你所创建的 Job。</p>
<h3 id=cleanup-2>清理</h3>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># 删除所创建的 Job</span>
<span style=color:#080;font-style:italic># 集群会自动清理 Job 对应的 Pod</span>
kubectl delete job -l <span style=color:#b8860b>jobgroup</span><span style=color:#666>=</span>jobexample
</code></pre></div>
<h2 id=using-jobs-in-real-workloads>在真实负载中使用 Job</h2>
<p>在真实的负载中，每个 Job 都会执行一些重要的计算，例如渲染电影的一帧，
或者处理数据库中的若干行。这时，<code>$ITEM</code> 参数将指定帧号或行范围。</p>
<p>在此任务中，你运行一个命令通过取回 Pod 的日志来收集其输出。
在真实应用场景中，Job 的每个 Pod 都会在结束之前将其输出写入到某持久性存储中。
你可以为每个 Job 指定 PersistentVolume 卷，或者使用其他外部存储服务。
例如，如果你在渲染视频帧，你可能会使用 HTTP 协议将渲染完的帧数据
用 'PUT' 请求发送到某 URL，每个帧使用不同的 URl。</p>
<h2 id=job-和-pod-上的标签>Job 和 Pod 上的标签</h2>
<p>你创建了 Job 之后，Kubernetes 自动为 Job 的 Pod 添加
<a class=glossary-tooltip title=用来为对象设置可标识的属性标记；这些标记对用户而言是有意义且重要的。 data-toggle=tooltip data-placement=top href=/zh/docs/concepts/overview/working-with-objects/labels/ target=_blank aria-label=标签>标签</a>，以便能够将一个 Job
的 Pod 与另一个 Job 的 Pod 区分开来。</p>
<p>在本例中，每个 Job 及其 Pod 模板有一个标签: <code>jobgroup=jobexample</code>。</p>
<p>Kubernetes 自身对标签名 <code>jobgroup</code> 没有什么要求。
为创建自同一模板的所有 Job 使用同一标签使得我们可以方便地同时操作组中的所有作业。
在<a href=#create-jobs-based-on-a-template>第一个例子</a>中，你使用模板来创建了若干 Job。
模板确保每个 Pod 都能够获得相同的标签，这样你可以用一条命令检查这些模板化
Job 所生成的全部 Pod。</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 标签键 <code>jobgroup</code> 没什么特殊的，也不是保留字。 你可以选择你自己的标签方案。
如果愿意，有一些<a href=/zh/docs/concepts/overview/working-with-objects/common-labels/#labels>建议的标签</a>
可供使用。
</div>
<h2 id=替代方案>替代方案</h2>
<p>如果你有计划创建大量 Job 对象，你可能会发现：</p>
<ul>
<li>即使使用标签，管理这么多 Job 对象也很麻烦。</li>
<li>如果你一次性创建很多 Job，很可能会给 Kubernetes 控制面带来很大压力。
一种替代方案是，Kubernetes API 可能对请求施加速率限制，通过 429 返回
状态值临时拒绝你的请求。</li>
<li>你可能会受到 Job 相关的<a class=glossary-tooltip title=资源配额提供了限制每个命名空间的资源消耗总和的约束。 data-toggle=tooltip data-placement=top href=/zh/docs/concepts/policy/resource-quotas/ target=_blank aria-label=资源配额>资源配额</a>
限制：如果你在一个批量请求中触发了太多的任务，API 服务器会永久性地拒绝你的某些请求。</li>
</ul>
<p>还有一些其他<a href=/zh/docs/concepts/workloads/controllers/job/#job-patterns>作业模式</a>
可供选择，这些模式都能用来处理大量任务而又不会创建过多的 Job 对象。</p>
<p>你也可以考虑编写自己的<a href=/zh/docs/concepts/architecture/controller/>控制器</a>
来自动管理 Job 对象。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-b74b959f5a531003dd0653dfbfc2e88b>11 - 访问集群中的应用程序</h1>
<div class=lead>配置负载平衡、端口转发或设置防火墙或 DNS 配置，以访问集群中的应用程序。</div>
</div>
<div class=td-content>
<h1 id=pg-777447042cd4e81df3fa5beb3357a485>11.1 - 部署和访问 Kubernetes 仪表板（Dashboard）</h1>
<p>Dashboard 是基于网页的 Kubernetes 用户界面。
你可以使用 Dashboard 将容器应用部署到 Kubernetes 集群中，也可以对容器应用排错，还能管理集群资源。
你可以使用 Dashboard 获取运行在集群中的应用的概览信息，也可以创建或者修改 Kubernetes 资源
（如 Deployment，Job，DaemonSet 等等）。
例如，你可以对 Deployment 实现弹性伸缩、发起滚动升级、重启 Pod 或者使用向导创建新的应用。</p>
<p>Dashboard 同时展示了 Kubernetes 集群中的资源状态信息和所有报错信息。</p>
<p><img src=/images/docs/ui-dashboard.png alt="Kubernetes Dashboard UI"></p>
<h2 id=部署-dashboard-ui>部署 Dashboard UI</h2>
<p>默认情况下不会部署 Dashboard。可以通过以下命令部署：</p>
<pre><code>kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v2.5.0/aio/deploy/recommended.yaml
</code></pre>
<h2 id=访问-dashboard-用户界面>访问 Dashboard 用户界面</h2>
<p>为了保护你的集群数据，默认情况下，Dashboard 会使用最少的 RBAC 配置进行部署。
当前，Dashboard 仅支持使用 Bearer 令牌登录。
要为此样本演示创建令牌，你可以按照
<a href=https://github.com/kubernetes/dashboard/wiki/Creating-sample-user>创建示例用户</a>
上的指南进行操作。</p>
<div class="alert alert-danger warning callout" role=alert>
<strong>Warning:</strong> 在教程中创建的样本用户将具有管理特权，并且仅用于教育目的。
</div>
<h3 id=命令行代理>命令行代理</h3>
<p>你可以使用 <code>kubectl</code> 命令行工具来启用 Dashboard 访问，命令如下：</p>
<pre><code>kubectl proxy
</code></pre>
<p>kubectl 会使得 Dashboard 可以通过 <a href=http://localhost:8001/api/v1/namespaces/kubernetes-dashboard/services/https:kubernetes-dashboard:/proxy/>http://localhost:8001/api/v1/namespaces/kubernetes-dashboard/services/https:kubernetes-dashboard:/proxy/</a> 访问。</p>
<p>UI <em>只能</em> 通过执行这条命令的机器进行访问。更多选项参见 <code>kubectl proxy --help</code>。</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> Kubeconfig 身份验证方法<strong>不</strong>支持外部身份提供程序或基于 x509 证书的身份验证。
</div>
<h2 id=欢迎界面>欢迎界面</h2>
<p>当访问空集群的 Dashboard 时，你会看到欢迎界面。
页面包含一个指向此文档的链接，以及一个用于部署第一个应用程序的按钮。
此外，你可以看到在默认情况下有哪些默认系统应用运行在 <code>kube-system</code>
<a href=/zh/docs/tasks/administer-cluster/namespaces/>名字空间</a> 中，比如 Dashboard 自己。</p>
<p><img src=/images/docs/ui-dashboard-zerostate.png alt="Kubernetes Dashboard 欢迎页面"></p>
<h2 id=部署容器化应用>部署容器化应用</h2>
<p>通过一个简单的部署向导，你可以使用 Dashboard 将容器化应用作为一个 Deployment 和可选的
Service 进行创建和部署。你可以手工指定应用的详细配置，或者上传一个包含应用配置的 YAML
或 JSON _清单_文件。</p>
<p>点击任何页面右上角的 <strong>CREATE</strong> 按钮以开始。</p>
<h3 id=指定应用的详细配置>指定应用的详细配置</h3>
<p>部署向导需要你提供以下信息：</p>
<ul>
<li>
<p><strong>应用名称</strong>（必填）：应用的名称。内容为<code>应用名称</code>的
<a href=/zh/docs/concepts/overview/working-with-objects/labels/>标签</a>
会被添加到任何将被部署的 Deployment 和 Service。</p>
<p>在选定的 Kubernetes <a href=/zh/docs/tasks/administer-cluster/namespaces/>名字空间</a> 中，
应用名称必须唯一。必须由小写字母开头，以数字或者小写字母结尾，
并且只含有小写字母、数字和中划线（-）。小于等于24个字符。开头和结尾的空格会被忽略。</p>
</li>
</ul>
<ul>
<li><strong>容器镜像</strong>（必填）：公共镜像仓库上的 Docker
<a href=/zh/docs/concepts/containers/images/>容器镜像</a> 或者私有镜像仓库
（通常是 Google Container Registry 或者 Docker Hub）的 URL。容器镜像参数说明必须以冒号结尾。</li>
</ul>
<ul>
<li>
<p><strong>Pod 的数量</strong>（必填）：你希望应用程序部署的 Pod 的数量。值必须为正整数。</p>
<p>系统会创建一个 <a href=/zh/docs/concepts/workloads/controllers/deployment/>Deployment</a>
以保证集群中运行期望的 Pod 数量。</p>
</li>
</ul>
<ul>
<li>
<p><strong>服务</strong>（可选）：对于部分应用（比如前端），你可能想对外暴露一个
<a href=/zh/docs/concepts/services-networking/service/>Service</a> ，这个 Service
可能用的是集群之外的公网 IP 地址（外部 Service）。</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 对于外部服务，你可能需要开放一个或多个端口才行。
</div>
<p>其它只能对集群内部可见的 Service 称为内部 Service。</p>
<p>不管哪种 Service 类型，如果你选择创建一个 Service，而且容器在一个端口上开启了监听（入向的），
那么你需要定义两个端口。创建的 Service 会把（入向的）端口映射到容器可见的目标端口。
该 Service 会把流量路由到你部署的 Pod。支持 TCP 协议和 UDP 协议。
这个 Service 的内部 DNS 解析名就是之前你定义的应用名称的值。</p>
</li>
</ul>
<p>如果需要，你可以打开 <strong>Advanced Options</strong> 部分，这里你可以定义更多设置：</p>
<ul>
<li><strong>描述</strong>：这里你输入的文本会作为一个
<a href=/zh/docs/concepts/overview/working-with-objects/annotations/>注解</a>
添加到 Deployment，并显示在应用的详细信息中。</li>
</ul>
<ul>
<li>
<p><strong>标签</strong>：应用默认使用的
<a href=/zh/docs/concepts/overview/working-with-objects/labels/>标签</a> 是应用名称和版本。
你可以为 Deployment、Service（如果有）定义额外的标签，比如 release（版本）、
environment（环境）、tier（层级）、partition（分区） 和 release track（版本跟踪）。</p>
<p>例子：</p>
<pre><code class=language-conf data-lang=conf>release=1.0
tier=frontend
environment=pod
track=stable
</code></pre></li>
</ul>
<ul>
<li>
<p><strong>名字空间</strong>：Kubernetes 支持多个虚拟集群依附于同一个物理集群。
这些虚拟集群被称为
<a href=/zh/docs/tasks/administer-cluster/namespaces/>名字空间</a>，
可以让你将资源划分为逻辑命名的组。</p>
<p>Dashboard 通过下拉菜单提供所有可用的名字空间，并允许你创建新的名字空间。
名字空间的名称最长可以包含 63 个字母或数字和中横线（-），但是不能包含大写字母。</p>
<p>名字空间的名称不能只包含数字。如果名字被设置成一个数字，比如 10，pod 就</p>
<p>在名字空间创建成功的情况下，默认会使用新创建的名字空间。如果创建失败，那么第一个名字空间会被选中。</p>
</li>
</ul>
<ul>
<li>
<p><strong>镜像拉取 Secret</strong>：如果要使用私有的 Docker 容器镜像，需要拉取
<a href=/zh/docs/concepts/configuration/secret/>Secret</a> 凭证。</p>
<p>Dashboard 通过下拉菜单提供所有可用的 Secret，并允许你创建新的 Secret。
Secret 名称必须遵循 DNS 域名语法，比如 <code>new.image-pull.secret</code>。
Secret 的内容必须是 base64 编码的，并且在一个
<a href=/zh/docs/concepts/containers/images/#specifying-imagepullsecrets-on-a-pod><code>.dockercfg</code></a>
文件中声明。Secret 名称最大可以包含 253 个字符。</p>
<p>在镜像拉取 Secret 创建成功的情况下，默认会使用新创建的 Secret。
如果创建失败，则不会使用任何 Secret。</p>
</li>
</ul>
<ul>
<li><strong>CPU 需求（核数）<strong>和</strong>内存需求（MiB）</strong>：你可以为容器定义最小的
<a href=/zh/docs/tasks/administer-cluster/manage-resources/memory-default-namespace/>资源限制</a>。
默认情况下，Pod 没有 CPU 和内存限制。</li>
</ul>
<ul>
<li><strong>运行命令</strong>和<strong>运行命令参数</strong>：默认情况下，你的容器会运行 Docker 镜像的默认
<a href=/zh/docs/tasks/inject-data-application/define-command-argument-container/>入口命令</a>。
你可以使用 command 选项覆盖默认值。</li>
</ul>
<ul>
<li><strong>以特权模式运行</strong>：这个设置决定了在
<a href=/zh/docs/concepts/workloads/pods/#privileged-mode-for-containers>特权容器</a>
中运行的进程是否像主机中使用 root 运行的进程一样。
特权容器可以使用诸如操纵网络堆栈和访问设备的功能。</li>
</ul>
<ul>
<li><strong>环境变量</strong>：Kubernetes 通过
<a href=/zh/docs/tasks/inject-data-application/environment-variable-expose-pod-information/>环境变量</a>
暴露 Service。你可以构建环境变量，或者将环境变量的值作为参数传递给你的命令。
它们可以被应用用于查找 Service。值可以通过 <code>$(VAR_NAME)</code> 语法关联其他变量。</li>
</ul>
<h3 id=上传-yaml-或者-json-文件>上传 YAML 或者 JSON 文件</h3>
<p>Kubernetes 支持声明式配置。所有的配置都存储在清单文件
（YAML 或者 JSON 配置文件）中。这些
清单使用 Kubernetes <a href=/zh/docs/concepts/overview/kubernetes-api/>API</a> 定义的资源模式。</p>
<p>作为一种替代在部署向导中指定应用详情的方式，你可以在一个或多个清单文件中定义应用，并且使用
Dashboard 上传文件。</p>
<h2 id=使用-dashboard>使用 Dashboard</h2>
<p>以下各节描述了 Kubernetes Dashboard UI 视图；包括它们提供的内容，以及怎么使用它们。</p>
<h3 id=导航>导航</h3>
<p>当在集群中定义 Kubernetes 对象时，Dashboard 会在初始视图中显示它们。
默认情况下只会显示 <em>默认</em> 名字空间中的对象，可以通过更改导航栏菜单中的名字空间筛选器进行改变。</p>
<p>Dashboard 展示大部分 Kubernetes 对象，并将它们分组放在几个菜单类别中。</p>
<h4 id=管理概述>管理概述</h4>
<p>集群和名字空间管理的视图, Dashboard 会列出节点、名字空间和持久卷，并且有它们的详细视图。
节点列表视图包含从所有节点聚合的 CPU 和内存使用的度量值。
详细信息视图显示了一个节点的度量值，它的规格、状态、分配的资源、事件和这个节点上运行的 Pod。</p>
<h4 id=负载>负载</h4>
<p>显示选中的名字空间中所有运行的应用。
视图按照负载类型（如 Deployment、ReplicaSet、StatefulSet 等）罗列应用，并且每种负载都可以单独查看。
列表总结了关于负载的可执行信息，比如一个 ReplicaSet 的就绪状态的 Pod 数量，或者目前一个 Pod 的内存用量。</p>
<p>工作负载的详情视图展示了对象的状态、详细信息和相互关系。
例如，ReplicaSet 所控制的 Pod，或者 Deployment 所关联的新 ReplicaSet 和
HorizontalPodAutoscalers。</p>
<h4 id=服务>服务</h4>
<p>展示允许暴露给外网服务和允许集群内部发现的 Kubernetes 资源。
因此，Service 和 Ingress 视图展示他们关联的 Pod、给集群连接使用的内部端点和给外部用户使用的外部端点。</p>
<h4 id=存储>存储</h4>
<p>存储视图展示持久卷申领（PVC）资源，这些资源被应用程序用来存储数据。</p>
<h4 id=configmap-和-secret>ConfigMap 和 Secret</h4>
<p>展示的所有 Kubernetes 资源是在集群中运行的应用程序的实时配置。
通过这个视图可以编辑和管理配置对象，并显示那些默认隐藏的 Secret。</p>
<h4 id=日志查看器>日志查看器</h4>
<p>Pod 列表和详细信息页面可以链接到 Dashboard 内置的日志查看器。
查看器可以深入查看属于同一个 Pod 的不同容器的日志。</p>
<p><img src=/images/docs/ui-dashboard-logs-view.png alt=日志浏览></p>
<h2 id=what-s-next>What's next</h2>
<p>更多信息，参见 <a href=https://github.com/kubernetes/dashboard>Kubernetes Dashboard 项目页面</a>.</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-6a8d9e9e05f2b6825afbb8889c957370>11.2 - 访问集群</h1>
<p>本文阐述多种与集群交互的方法。</p>
<nav id=TableOfContents>
<ul>
<li><a href=#使用-kubectl-完成集群的第一次访问>使用 kubectl 完成集群的第一次访问</a></li>
<li><a href=#直接访问-rest-api>直接访问 REST API</a>
<ul>
<li><a href=#使用-kubectl-proxy>使用 kubectl proxy</a></li>
<li><a href=#不使用-kubectl-proxy>不使用 kubectl proxy</a></li>
</ul>
</li>
<li><a href=#以编程方式访问-api>以编程方式访问 API</a>
<ul>
<li><a href=#go-客户端>Go 客户端</a></li>
<li><a href=#python-客户端>Python 客户端</a></li>
<li><a href=#其它语言>其它语言</a></li>
<li><a href=#accessing-the-api-from-a-pod>从 Pod 中访问 API </a></li>
</ul>
</li>
<li><a href=#accessing-services-running-on-the-cluster>访问集群上运行的服务 </a></li>
<li><a href=#请求重定向>请求重定向</a></li>
<li><a href=#多种代理>多种代理</a></li>
</ul>
</nav>
<h2 id=使用-kubectl-完成集群的第一次访问>使用 kubectl 完成集群的第一次访问</h2>
<p>当你第一次访问 Kubernetes API 的时候，我们建议你使用 Kubernetes CLI，<code>kubectl</code>。</p>
<p>访问集群时，你需要知道集群的地址并且拥有访问的凭证。通常，这些在你通过
<a href=/zh/docs/setup/>启动安装</a>安装集群时都是自动安装好的，或者其他人安装时
也应该提供了凭证和集群地址。</p>
<p>通过以下命令检查 kubectl 是否知道集群地址及凭证：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl config view
</code></pre></div>
<p>有许多 <a href=/zh/docs/reference/kubectl/cheatsheet/>例子</a> 介绍了如何使用 kubectl，
可以在 <a href=/zh/docs/reference/kubectl/overview/>kubectl 参考</a> 中找到更完整的文档。</p>
<h2 id=直接访问-rest-api>直接访问 REST API</h2>
<p>Kubectl 处理 apiserver 的定位和身份验证。
如果要使用 curl 或 wget 等 http 客户端或浏览器直接访问 REST API，可以通过
多种方式查找和验证：</p>
<ul>
<li>以代理模式运行 kubectl。
<ul>
<li>推荐此方式。</li>
<li>使用已存储的 apiserver 地址。</li>
<li>使用自签名的证书来验证 apiserver 的身份。杜绝 MITM 攻击。</li>
<li>对 apiserver 进行身份验证。</li>
<li>未来可能会实现智能化的客户端负载均衡和故障恢复。</li>
</ul>
</li>
<li>直接向 http 客户端提供位置和凭据。
<ul>
<li>可选的方案。</li>
<li>适用于代理可能引起混淆的某些客户端类型。</li>
<li>需要引入根证书到你的浏览器以防止 MITM 攻击。</li>
</ul>
</li>
</ul>
<h3 id=使用-kubectl-proxy>使用 kubectl proxy</h3>
<p>以下命令以反向代理的模式运行 kubectl。它处理 apiserver 的定位和验证。
像这样运行：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl proxy --port<span style=color:#666>=</span><span style=color:#666>8080</span> &amp;
</code></pre></div>
<p>参阅 <a href=/docs/reference/generated/kubectl/kubectl-commands/#proxy>kubectl proxy</a>
获取更多详细信息。</p>
<p>然后，你可以使用 curl、wget 或浏览器访问 API，如果是 IPv6 则用 [::1] 替换 localhost，
如下所示：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>curl http://localhost:8080/api/
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;APIVersions&#34;</span>,
  <span style=color:green;font-weight:700>&#34;versions&#34;</span>: [
    <span style=color:#b44>&#34;v1&#34;</span>
  ],
  <span style=color:green;font-weight:700>&#34;serverAddressByClientCIDRs&#34;</span>: [
    {
      <span style=color:green;font-weight:700>&#34;clientCIDR&#34;</span>: <span style=color:#b44>&#34;0.0.0.0/0&#34;</span>,
      <span style=color:green;font-weight:700>&#34;serverAddress&#34;</span>: <span style=color:#b44>&#34;10.0.1.149:443&#34;</span>
    }
  ]
}
</code></pre></div>
<h3 id=不使用-kubectl-proxy>不使用 kubectl proxy</h3>
<p>在 Kubernetes 1.3 或更高版本中，<code>kubectl config view</code> 不再显示 token。
使用 <code>kubectl apply</code> 和 <code>kubectl describe secret ...</code> 及 grep 和剪切操作来为 default 服务帐户创建令牌，如下所示：
<code>grep/cut</code> 方法实现：
首先，创建 Secret，请求默认 ServiceAccount 的令牌：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f - <span style=color:#b44>&lt;&lt;EOF
</span><span style=color:#b44>apiVersion: v1
</span><span style=color:#b44>kind: Secret
</span><span style=color:#b44>metadata:
</span><span style=color:#b44>  name: default-token
</span><span style=color:#b44>  annotations:
</span><span style=color:#b44>    kubernetes.io/service-account.name: default
</span><span style=color:#b44>type: kubernetes.io/service-account-token
</span><span style=color:#b44>EOF</span>
</code></pre></div>
<p>接下来，等待令牌控制器使用令牌填充 Secret：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#a2f;font-weight:700>while</span> ! kubectl describe secret default-token | grep -E <span style=color:#b44>&#39;^token&#39;</span> &gt;/dev/null; <span style=color:#a2f;font-weight:700>do</span>
  <span style=color:#a2f>echo</span> <span style=color:#b44>&#34;waiting for token...&#34;</span> &gt;&amp;<span style=color:#666>2</span>
  sleep <span style=color:#666>1</span>
<span style=color:#a2f;font-weight:700>done</span>
</code></pre></div><p>捕获并使用生成的令牌：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#b8860b>APISERVER</span><span style=color:#666>=</span><span style=color:#a2f;font-weight:700>$(</span>kubectl config view | grep server | cut -f 2- -d <span style=color:#b44>&#34;:&#34;</span> | tr -d <span style=color:#b44>&#34; &#34;</span><span style=color:#a2f;font-weight:700>)</span>
<span style=color:#b8860b>TOKEN</span><span style=color:#666>=</span><span style=color:#a2f;font-weight:700>$(</span>kubectl describe secret default-token | grep -E <span style=color:#b44>&#39;^token&#39;</span> | cut -f2 -d<span style=color:#b44>&#39;:&#39;</span> | tr -d <span style=color:#b44>&#39; &#39;</span><span style=color:#a2f;font-weight:700>)</span>
curl <span style=color:#b8860b>$APISERVER</span>/api --header <span style=color:#b44>&#34;Authorization: Bearer </span><span style=color:#b8860b>$TOKEN</span><span style=color:#b44>&#34;</span> --insecure
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;APIVersions&#34;</span>,
  <span style=color:green;font-weight:700>&#34;versions&#34;</span>: [
    <span style=color:#b44>&#34;v1&#34;</span>
  ],
  <span style=color:green;font-weight:700>&#34;serverAddressByClientCIDRs&#34;</span>: [
    {
      <span style=color:green;font-weight:700>&#34;clientCIDR&#34;</span>: <span style=color:#b44>&#34;0.0.0.0/0&#34;</span>,
      <span style=color:green;font-weight:700>&#34;serverAddress&#34;</span>: <span style=color:#b44>&#34;10.0.1.149:443&#34;</span>
    }
  ]
}
</code></pre></div><p><code>jsonpath</code> 方法实现：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#b8860b>APISERVER</span><span style=color:#666>=</span><span style=color:#a2f;font-weight:700>$(</span>kubectl config view --minify -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.clusters[0].cluster.server}&#39;</span><span style=color:#a2f;font-weight:700>)</span>
<span style=color:#b8860b>TOKEN</span><span style=color:#666>=</span><span style=color:#a2f;font-weight:700>$(</span>kubectl get secret default-token -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.data.token}&#39;</span> | base64 --decode <span style=color:#a2f;font-weight:700>)</span>
curl <span style=color:#b8860b>$APISERVER</span>/api --header <span style=color:#b44>&#34;Authorization: Bearer </span><span style=color:#b8860b>$TOKEN</span><span style=color:#b44>&#34;</span> --insecure
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;APIVersions&#34;</span>,
  <span style=color:green;font-weight:700>&#34;versions&#34;</span>: [
    <span style=color:#b44>&#34;v1&#34;</span>
  ],
  <span style=color:green;font-weight:700>&#34;serverAddressByClientCIDRs&#34;</span>: [
    {
      <span style=color:green;font-weight:700>&#34;clientCIDR&#34;</span>: <span style=color:#b44>&#34;0.0.0.0/0&#34;</span>,
      <span style=color:green;font-weight:700>&#34;serverAddress&#34;</span>: <span style=color:#b44>&#34;10.0.1.149:443&#34;</span>
    }
  ]
}
</code></pre></div>
<p>上面的例子使用了 <code>--insecure</code> 参数，这使得它很容易受到 MITM 攻击。
当 kubectl 访问集群时，它使用存储的根证书和客户端证书来访问服务器
（它们安装在 <code>~/.kube</code> 目录中）。
由于集群证书通常是自签名的，因此可能需要特殊配置才能让你的 http 客户端使用根证书。</p>
<p>在一些集群中，apiserver 不需要身份验证；它可能只服务于 localhost，或者被防火墙保护，
这个没有一定的标准。
<a href=/zh/docs/concepts/security/controlling-access/>配置对 API 的访问</a>
描述了集群管理员如何进行配置。此类方法可能与未来的高可用性支持相冲突。</p>
<h2 id=以编程方式访问-api>以编程方式访问 API</h2>
<p>Kubernetes 官方提供对 <a href=#go-client>Go</a> 和 <a href=#python-client>Python</a> 的客户端库支持。</p>
<h3 id=go-客户端>Go 客户端</h3>
<ul>
<li>想要获得这个库，请运行命令：<code>go get k8s.io/client-go/&lt;version number>/kubernetes</code>。
参阅 <a href=https://github.com/kubernetes/client-go>https://github.com/kubernetes/client-go</a>
来查看目前支持哪些版本。</li>
<li>基于这个 client-go 客户端库编写应用程序。
请注意，client-go 定义了自己的 API 对象，因此如果需要，请从 client-go 而不是从主存储库
导入 API 定义，例如，<code>import "k8s.io/client-go/1.4/pkg/api/v1"</code> 才是对的。</li>
</ul>
<p>Go 客户端可以像 kubectl CLI 一样使用相同的
<a href=/zh/docs/concepts/configuration/organize-cluster-access-kubeconfig/>kubeconfig 文件</a>
来定位和验证 apiserver。可参阅
<a href=https://git.k8s.io/client-go/examples/out-of-cluster-client-configuration/main.go>示例</a>。</p>
<p>如果应用程序以 Pod 的形式部署在集群中，那么请参阅
<a href=#accessing-the-api-from-a-pod>下一章</a>。</p>
<h3 id=python-客户端>Python 客户端</h3>
<p>如果想要使用 <a href=https://github.com/kubernetes-client/python>Python 客户端</a>，
请运行命令：<code>pip install kubernetes</code>。参阅
<a href=https://github.com/kubernetes-client/python>Python Client Library page</a>
以获得更详细的安装参数。</p>
<p>Python 客户端可以像 kubectl CLI 一样使用相同的
<a href=/zh/docs/concepts/configuration/organize-cluster-access-kubeconfig/>kubeconfig 文件</a>
来定位和验证 apiserver，可参阅
<a href=https://github.com/kubernetes-client/python/tree/master/examples>示例</a>。</p>
<h3 id=其它语言>其它语言</h3>
<p>目前有多个<a href=/zh/docs/reference/using-api/client-libraries/>客户端库</a>
为其它语言提供访问 API 的方法。
参阅其它库的相关文档以获取他们是如何验证的。</p>
<h3 id=accessing-the-api-from-a-pod>从 Pod 中访问 API </h3>
<p>当你从 Pod 中访问 API 时，定位和验证 API 服务器会有些许不同。</p>
<p>请参阅<a href=/zh/docs/tasks/run-application/access-api-from-pod/>从 Pod 中访问 API</a>
了解更多详情。</p>
<h2 id=accessing-services-running-on-the-cluster>访问集群上运行的服务 </h2>
<p>上一节介绍了如何连接到 Kubernetes API 服务器。
有关连接到 Kubernetes 集群上运行的其他服务的信息，请参阅
<a href=/zh/docs/tasks/administer-cluster/access-cluster-services/>访问集群服务</a>。</p>
<h2 id=请求重定向>请求重定向</h2>
<p>重定向功能已弃用并被删除。请改用代理（见下文）。</p>
<h2 id=多种代理>多种代理</h2>
<p>使用 Kubernetes 时可能会遇到几种不同的代理：</p>
<ol>
<li>
<p><a href=#directly-accessing-the-rest-api>kubectl 代理</a>：</p>
<ul>
<li>在用户的桌面或 Pod 中运行</li>
<li>代理从本地主机地址到 Kubernetes apiserver</li>
<li>客户端到代理将使用 HTTP</li>
<li>代理到 apiserver 使用 HTTPS</li>
<li>定位 apiserver</li>
<li>添加身份验证头部</li>
</ul>
</li>
</ol>
<ol start=2>
<li>
<p><a href=#discovering-builtin-services>apiserver 代理</a>：</p>
<ul>
<li>内置于 apiserver 中</li>
<li>将集群外部的用户连接到集群 IP，否则这些 IP 可能无法访问</li>
<li>运行在 apiserver 进程中</li>
<li>客户端代理使用 HTTPS（也可配置为 http）</li>
<li>代理将根据可用的信息决定使用 HTTP 或者 HTTPS 代理到目标</li>
<li>可用于访问节点、Pod 或服务</li>
<li>在访问服务时进行负载平衡</li>
</ul>
</li>
</ol>
<ol start=3>
<li>
<p><a href=/zh/docs/concepts/services-networking/service/#ips-and-vips>kube proxy</a>：</p>
<ul>
<li>运行在每个节点上</li>
<li>代理 UDP 和 TCP</li>
<li>不能代理 HTTP</li>
<li>提供负载均衡</li>
<li>只能用来访问服务</li>
</ul>
</li>
</ol>
<ol start=4>
<li>
<p>位于 apiserver 之前的 Proxy/Load-balancer：</p>
<ul>
<li>存在和实现因集群而异（例如 nginx）</li>
<li>位于所有客户和一个或多个 apiserver 之间</li>
<li>如果有多个 apiserver，则充当负载均衡器</li>
</ul>
</li>
</ol>
<ol start=5>
<li>
<p>外部服务上的云负载均衡器：</p>
<ul>
<li>由一些云提供商提供（例如 AWS ELB，Google Cloud Load Balancer）</li>
<li>当 Kubernetes 服务类型为 <code>LoadBalancer</code> 时自动创建</li>
<li>只使用 UDP/TCP</li>
<li>具体实现因云提供商而异。</li>
</ul>
</li>
</ol>
<p>除了前两种类型之外，Kubernetes 用户通常不需要担心任何其他问题。
集群管理员通常会确保后者的正确配置。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-72d3dddbc0c166c9a364e753d2b31ff0>11.3 - 使用端口转发来访问集群中的应用</h1>
<p>本文展示如何使用 <code>kubectl port-forward</code> 连接到在 Kubernetes 集群中
运行的 MongoDB 服务。这种类型的连接对数据库调试很有用。</p>
<h2 id=before-you-begin>Before you begin</h2>
<ul>
<li><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li>
</ul>
To check the version, enter <code>kubectl version</code>.
</li>
</ul>
<ul>
<li>安装 <a href=https://www.mongodb.com/try/download/shell>MongoDB Shell</a>。</li>
</ul>
<h2 id=创建-mongodb-deployment-和服务>创建 MongoDB deployment 和服务</h2>
<ol>
<li>
<p>创建一个运行 MongoDB 的 deployment：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/application/mongodb/mongo-deployment.yaml
</code></pre></div>
<p>查看输出是否成功，以验证是否成功创建 deployment：</p>
<pre><code>deployment.apps/mongo created
</code></pre>
<p>查看 pod 状态，检查其是否准备就绪：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods
</code></pre></div>
<p>输出显示创建的 pod：</p>
<pre><code>NAME                     READY   STATUS    RESTARTS   AGE
mongo-75f59d57f4-4nd6q   1/1     Running   0          2m4s
</code></pre>
<p>查看 Deployment 状态：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get deployment
</code></pre></div>
<p>输出显示创建的 Deployment：</p>
<pre><code>NAME    READY   UP-TO-DATE   AVAILABLE   AGE
mongo   1/1     1            1           2m21s
</code></pre>
<p>Deployment 自动管理 ReplicaSet。
查看 ReplicaSet 状态：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get replicaset
</code></pre></div>
<p>输出显示创建的 ReplicaSet：</p>
<pre><code>NAME               DESIRED   CURRENT   READY   AGE
mongo-75f59d57f4   1         1         1       3m12s
</code></pre></li>
</ol>
<ol start=2>
<li>
<p>创建一个在网络上公开的 MongoDB 服务：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/application/mongodb/mongo-service.yaml
</code></pre></div>
<p>查看输出是否成功，以验证是否成功创建 Service：</p>
<pre><code>service/mongo created
</code></pre>
<p>检查 Service 是否创建：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get service mongo
</code></pre></div>
<p>输出显示创建的 Service：</p>
<pre><code>NAME    TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)     AGE
mongo   ClusterIP   10.96.41.183   &lt;none&gt;        27017/TCP   11s
</code></pre></li>
</ol>
<ol start=3>
<li>
<p>验证 MongoDB 服务是否运行在 Pod 中并且监听 27017 端口：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># Change mongo-75f59d57f4-4nd6q to the name of the Pod</span>
kubectl get pod mongo-75f59d57f4-4nd6q --template<span style=color:#666>=</span><span style=color:#b44>&#39;{{(index (index .spec.containers 0).ports 0).containerPort}}{{&#34;\n&#34;}}&#39;</span>
</code></pre></div>
<p>输出应该显示 Pod 中 MongoDB 的端口：</p>
<pre><code>27017
</code></pre>
<p>（这是 Internet 分配给 MongoDB 的 TCP 端口）。</p>
</li>
</ol>
<h2 id=转发一个本地端口到-pod-端口>转发一个本地端口到 Pod 端口</h2>
<ol>
<li>
<p><code>kubectl port-forward</code> 允许使用资源名称
（例如 pod 名称）来选择匹配的 pod 来进行端口转发。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># Change mongo-75f59d57f4-4nd6q to the name of the Pod</span>
kubectl port-forward mongo-75f59d57f4-4nd6q 28015:27017
</code></pre></div>
<p>这相当于</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl port-forward pods/mongo-75f59d57f4-4nd6q 28015:27017
</code></pre></div>
<p>或者</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl port-forward deployment/mongo 28015:27017
</code></pre></div>
<p>或者</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl port-forward replicaset/mongo-75f59d57f4 28015:27017
</code></pre></div>
<p>或者</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl port-forward service/mongo 28015:27017
</code></pre></div>
<p>以上所有命令都应该有效。输出应该类似于：</p>
<pre><code>Forwarding from 127.0.0.1:28015 -&gt; 27017
Forwarding from [::1]:28015 -&gt; 27017
</code></pre></li>
</ol>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> <code>kubectl port-forward</code> 不会返回。你需要打开另一个终端来继续这个练习。
</div>
<ol start=2>
<li>启动 MongoDB 命令行接口：</li>
</ol>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>mongosh --port <span style=color:#666>28015</span>
</code></pre></div>
<ol start=3>
<li>
<p>在 MongoDB 命令行提示符下，输入 <code>ping</code> 命令：</p>
<pre><code>db.runCommand( { ping: 1 } )
</code></pre>
<p>成功的 ping 请求应该返回：</p>
<pre><code>{ ok: 1 }
</code></pre></li>
</ol>
<h3 id=let-kubectl-choose-local-port>（可选操作）让 <em>kubectl</em> 来选择本地端口</h3>
<p>如果你不需要指定特定的本地端口，你可以让 <code>kubectl</code> 来选择和分配本地端口，
以便你不需要管理本地端口冲突。该命令使用稍微不同的语法：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl port-forward deployment/mongo :27017
</code></pre></div>
<p><code>kubectl</code> 工具会找到一个未被使用的本地端口号（避免使用低段位的端口号，因为他们可能会被其他应用程序使用）。
输出应该类似于：</p>
<pre><code>Forwarding from 127.0.0.1:63753 -&gt; 27017
Forwarding from [::1]:63753 -&gt; 27017
</code></pre>
<h2 id=discussion>讨论 </h2>
<p>与本地 28015 端口建立的连接将转发到运行 MongoDB 服务器的 Pod 的 27017 端口。
通过此连接，您可以使用本地工作站来调试在 Pod 中运行的数据库。</p>
<div class="alert alert-danger warning callout" role=alert>
<strong>Warning:</strong> <code>kubectl port-forward</code> 仅适用于 TCP 端口。
在 <a href=https://github.com/kubernetes/kubernetes/issues/47862>issue 47862</a>
中跟踪了对 UDP 协议的支持。
</div>
<h2 id=what-s-next>What's next</h2>
<p>进一步了解 <a href=/docs/reference/generated/kubectl/kubectl-commands/#port-forward>kubectl port-forward</a>。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-312f29f850826b74618634cd877aa065>11.4 - 使用服务来访问集群中的应用</h1>
<p>本文展示如何创建一个 Kubernetes 服务对象，能让外部客户端访问在集群中运行的应用。
该服务为一个应用的两个运行实例提供负载均衡。</p>
<h2 id=before-you-begin>Before you begin</h2>
<p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li>
</ul>
To check the version, enter <code>kubectl version</code>.
</p>
<h2 id=objectives>Objectives</h2>
<ul>
<li>运行 Hello World 应用的两个实例。</li>
<li>创建一个服务对象来暴露 node port。</li>
<li>使用服务对象来访问正在运行的应用。</li>
</ul>
<h2 id=为运行在两个-pod-中的应用创建一个服务>为运行在两个 pod 中的应用创建一个服务</h2>
<p>这是应用程序部署的配置文件：</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/service/access/hello-application.yaml download=service/access/hello-application.yaml><code>service/access/hello-application.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('service-access-hello-application-yaml')" title="Copy service/access/hello-application.yaml to clipboard">
</img>
</div>
<div class=includecode id=service-access-hello-application-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>hello-world<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>run</span>:<span style=color:#bbb> </span>load-balancer-example<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>2</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>run</span>:<span style=color:#bbb> </span>load-balancer-example<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>hello-world<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>gcr.io/google-samples/node-hello:1.0<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>8080</span><span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<ol>
<li>
<p>在你的集群中运行一个 Hello World 应用：
使用上面的文件创建应用程序 Deployment：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/service/access/hello-application.yaml
</code></pre></div><p>上面的命令创建一个 <a href=/zh/docs/concepts/workloads/controllers/deployment/>Deployment</a> 对象
和一个关联的 <a href=/zh/docs/concepts/workloads/controllers/replicaset/>ReplicaSet</a> 对象。
这个 ReplicaSet 有两个 <a href=/zh/docs/concepts/workloads/pods/>Pod</a>，
每个 Pod 都运行着 Hello World 应用。</p>
</li>
</ol>
<ol start=2>
<li>
<p>展示 Deployment 的信息：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get deployments hello-world
kubectl describe deployments hello-world
</code></pre></div></li>
</ol>
<ol start=3>
<li>
<p>展示你的 ReplicaSet 对象信息：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get replicasets
kubectl describe replicasets
</code></pre></div></li>
</ol>
<ol start=4>
<li>
<p>创建一个服务对象来暴露 Deployment：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl expose deployment hello-world --type<span style=color:#666>=</span>NodePort --name<span style=color:#666>=</span>example-service
</code></pre></div></li>
</ol>
<ol start=5>
<li>
<p>展示 Service 信息：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe services example-service
</code></pre></div>
<p>输出类似于：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>Name:                   example-service
Namespace:              default
Labels:                 <span style=color:#b8860b>run</span><span style=color:#666>=</span>load-balancer-example
Annotations:            &lt;none&gt;
Selector:               <span style=color:#b8860b>run</span><span style=color:#666>=</span>load-balancer-example
Type:                   NodePort
IP:                     10.32.0.16
Port:                   &lt;unset&gt; 8080/TCP
TargetPort:             8080/TCP
NodePort:               &lt;unset&gt; 31496/TCP
Endpoints:              10.200.1.4:8080,10.200.2.5:8080
Session Affinity:       None
Events:                 &lt;none&gt;
</code></pre></div>
<p>注意服务中的 NodePort 值。例如在上面的输出中，NodePort 是 31496。</p>
</li>
</ol>
<ol start=7>
<li>
<p>列出运行 Hello World 应用的 Pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods --selector<span style=color:#666>=</span><span style=color:#b44>&#34;run=load-balancer-example&#34;</span> --output<span style=color:#666>=</span>wide
</code></pre></div>
<p>输出类似于：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>NAME                           READY   STATUS    ...  IP           NODE
hello-world-2895499144-bsbk5   1/1     Running   ...  10.200.1.4   worker1
hello-world-2895499144-m1pwt   1/1     Running   ...  10.200.2.5   worker2
</code></pre></div></li>
</ol>
<ol start=8>
<li>
<p>获取运行 Hello World 的 pod 的其中一个节点的公共 IP 地址。如何获得此地址取决于你设置集群的方式。
例如，如果你使用的是 Minikube，则可以通过运行 <code>kubectl cluster-info</code> 来查看节点地址。
如果你使用的是 Google Compute Engine 实例，则可以使用 <code>gcloud compute instances list</code> 命令查看节点的公共地址。</p>
</li>
<li>
<p>在你选择的节点上，创建一个防火墙规则以开放节点端口上的 TCP 流量。
例如，如果你的服务的 NodePort 值为 31568，请创建一个防火墙规则以允许 31568 端口上的 TCP 流量。
不同的云提供商提供了不同方法来配置防火墙规则。</p>
</li>
<li>
<p>使用节点地址和 node port 来访问 Hello World 应用：</p>
</li>
</ol>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>curl http://&lt;public-node-ip&gt;:&lt;node-port&gt;
</code></pre></div>
<p>这里的 <code>&lt;public-node-ip></code> 是你节点的公共 IP 地址，<code>&lt;node-port></code> 是你服务的 NodePort 值。
对于请求成功的响应是一个 hello 消息：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>Hello Kubernetes!
</code></pre></div>
<h2 id=使用服务配置文件>使用服务配置文件</h2>
<p>作为 <code>kubectl expose</code> 的替代方法，你可以使用
<a href=/zh/docs/concepts/services-networking/service/>服务配置文件</a> 来创建服务。</p>
<h2 id=cleaning-up>Cleaning up</h2>
<p>想要删除服务，输入以下命令：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete services example-service
</code></pre></div>
<p>想要删除运行 Hello World 应用的 Deployment、ReplicaSet 和 Pod，输入以下命令：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete deployment hello-world
</code></pre></div><h2 id=what-s-next>What's next</h2>
<ul>
<li>进一步了解<a href=/zh/docs/concepts/services-networking/connect-applications-service/>通过服务连接应用</a>。</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-f3dac629bea950fc026d920306f09fb4>11.5 - 使用 Service 把前端连接到后端</h1>
<p>本任务会描述如何创建前端（Frontend）微服务和后端（Backend）微服务。后端微服务是一个 hello 欢迎程序。
前端通过 nginx 和一个 Kubernetes <a class=glossary-tooltip title="将运行在一组 Pods 上的应用程序公开为网络服务的抽象方法。" data-toggle=tooltip data-placement=top href=/zh/docs/concepts/services-networking/service/ target=_blank aria-label=服务>服务</a>
暴露后端所提供的服务。</p>
<h2 id=objectives>Objectives</h2>
<ul>
<li>使用部署对象（Deployment object）创建并运行一个 <code>hello</code> 后端微服务</li>
<li>使用一个 Service 对象将请求流量发送到后端微服务的多个副本</li>
<li>同样使用一个 Deployment 对象创建并运行一个 <code>nginx</code> 前端微服务</li>
<li>配置前端微服务将请求流量发送到后端微服务</li>
<li>使用 <code>type=LoadBalancer</code> 的 Service 对象将全段微服务暴露到集群外部</li>
</ul>
<h2 id=before-you-begin>Before you begin</h2>
<p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li>
</ul>
To check the version, enter <code>kubectl version</code>.
</p>
<p>本任务使用<a href=/zh/docs/tasks/access-application-cluster/create-external-load-balancer/>外部负载均衡服务</a>，
所以需要对应的可支持此功能的环境。如果你的环境不能支持，你可以使用
<a href=/zh/docs/concepts/services-networking/service/#type-nodeport>NodePort</a>
类型的服务代替。</p>
<h3 id=使用部署对象-deployment-创建后端>使用部署对象（Deployment）创建后端</h3>
<p>后端是一个简单的 hello 欢迎微服务应用。这是后端应用的 Deployment 配置文件：</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/service/access/backend-deployment.yaml download=service/access/backend-deployment.yaml><code>service/access/backend-deployment.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('service-access-backend-deployment-yaml')" title="Copy service/access/backend-deployment.yaml to clipboard">
</img>
</div>
<div class=includecode id=service-access-backend-deployment-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>backend<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>hello<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>tier</span>:<span style=color:#bbb> </span>backend<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>track</span>:<span style=color:#bbb> </span>stable<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>hello<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>tier</span>:<span style=color:#bbb> </span>backend<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>track</span>:<span style=color:#bbb> </span>stable<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>hello<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;gcr.io/google-samples/hello-go-gke:1.0&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>http<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span></code></pre></div>
</div>
</div>
<p>创建后端 Deployment：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/service/access/backend-deployment.yaml
</code></pre></div>
<p>查看后端的 Deployment 信息：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe deployment backend
</code></pre></div>
<p>输出类似于：</p>
<pre><code>Name:                           backend
Namespace:                      default
CreationTimestamp:              Mon, 24 Oct 2016 14:21:02 -0700
Labels:                         app=hello
                                tier=backend
                                track=stable
Annotations:                    deployment.kubernetes.io/revision=1
Selector:                       app=hello,tier=backend,track=stable
Replicas:                       3 desired | 3 updated | 3 total | 3 available | 0 unavailable
StrategyType:                   RollingUpdate
MinReadySeconds:                0
RollingUpdateStrategy:          1 max unavailable, 1 max surge
Pod Template:
  Labels:       app=hello
                tier=backend
                track=stable
  Containers:
   hello:
    Image:              &quot;gcr.io/google-samples/hello-go-gke:1.0&quot;
    Port:               80/TCP
    Environment:        &lt;none&gt;
    Mounts:             &lt;none&gt;
  Volumes:              &lt;none&gt;
Conditions:
  Type          Status  Reason
  ----          ------  ------
  Available     True    MinimumReplicasAvailable
  Progressing   True    NewReplicaSetAvailable
OldReplicaSets:                 &lt;none&gt;
NewReplicaSet:                  hello-3621623197 (3/3 replicas created)
Events:
...
</code></pre>
<h3 id=创建-hello-service-对象>创建 <code>hello</code> Service 对象</h3>
<p>将请求从前端发送到到后端的关键是后端 Service。Service 创建一个固定 IP 和 DNS 解析名入口，
使得后端微服务总是可达。Service 使用
<a class=glossary-tooltip title=选择算符允许用户通过标签对一组资源对象进行筛选过滤。 data-toggle=tooltip data-placement=top href=/zh/docs/concepts/overview/working-with-objects/labels/ target=_blank aria-label=选择算符>选择算符</a>
来寻找目标 Pod。</p>
<p>首先，浏览 Service 的配置文件：</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/service/access/backend-service.yaml download=service/access/backend-service.yaml><code>service/access/backend-service.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('service-access-backend-service-yaml')" title="Copy service/access/backend-service.yaml to clipboard">
</img>
</div>
<div class=includecode id=service-access-backend-service-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>hello<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>hello<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>tier</span>:<span style=color:#bbb> </span>backend<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span>http<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span></code></pre></div>
</div>
</div>
<p>配置文件中，你可以看到名为 <code>hello</code> 的 Service 将流量路由到包含 <code>app: hello</code>
和 <code>tier: backend</code> 标签的 Pod。</p>
<p>创建后端 Service：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/service/access/backend-service.yaml
</code></pre></div>
<p>此时，你已经有了一个运行着 <code>hello</code> 应用的三个副本的 <code>backend</code> Deployment，你也有了
一个 Service 用于路由网络流量。不过，这个服务在集群外部无法访问也无法解析。</p>
<h3 id=创建前端应用>创建前端应用</h3>
<p>现在你已经有了运行中的后端应用，你可以创建一个可在集群外部访问的前端，并通过代理
前端的请求连接到后端。</p>
<p>前端使用被赋予后端 Service 的 DNS 名称将请求发送到后端工作 Pods。这一 DNS
名称为 <code>hello</code>，也就是 <code>examples/service/access/backend-service.yaml</code> 配置
文件中 <code>name</code> 字段的取值。</p>
<p>前端 Deployment 中的 Pods 运行一个 nginx 镜像，这个已经配置好的镜像会将请求转发
给后端的 hello Service。下面是 nginx 的配置文件：</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/service/access/frontend-nginx.conf download=service/access/frontend-nginx.conf><code>service/access/frontend-nginx.conf</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('service-access-frontend-nginx-conf')" title="Copy service/access/frontend-nginx.conf to clipboard">
</img>
</div>
<div class=includecode id=service-access-frontend-nginx-conf>
<pre tabindex=0><code class=language-conf data-lang=conf># The identifier Backend is internal to nginx, and used to name this specific upstream
upstream Backend {
    # hello is the internal DNS name used by the backend Service inside Kubernetes
    server hello;
}

server {
    listen 80;

    location / {
        # The following statement will proxy traffic to the upstream named Backend
        proxy_pass http://Backend;
    }
}
</code></pre>
</div>
</div>
<p>与后端类似，前端用包含一个 Deployment 和一个 Service。后端与前端服务之间的一个
重要区别是前端 Service 的配置文件包含了 <code>type: LoadBalancer</code>，也就是说，Service
会使用你的云服务商的默认负载均衡设备，从而实现从集群外访问的目的。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/service/access/frontend-service.yaml download=service/access/frontend-service.yaml><code>service/access/frontend-service.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('service-access-frontend-service-yaml')" title="Copy service/access/frontend-service.yaml to clipboard">
</img>
</div>
<div class=includecode id=service-access-frontend-service-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>hello<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>tier</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;TCP&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>LoadBalancer<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span></code></pre></div>
</div>
</div>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/service/access/frontend-deployment.yaml download=service/access/frontend-deployment.yaml><code>service/access/frontend-deployment.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('service-access-frontend-deployment-yaml')" title="Copy service/access/frontend-deployment.yaml to clipboard">
</img>
</div>
<div class=includecode id=service-access-frontend-deployment-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>hello<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>tier</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>track</span>:<span style=color:#bbb> </span>stable<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>hello<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>tier</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>track</span>:<span style=color:#bbb> </span>stable<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;gcr.io/google-samples/hello-frontend:1.0&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>lifecycle</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>preStop</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>exec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>                </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;/usr/sbin/nginx&#34;</span>,<span style=color:#b44>&#34;-s&#34;</span>,<span style=color:#b44>&#34;quit&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span></code></pre></div>
</div>
</div>
<p>创建前端 Deployment 和 Service：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/service/access/frontend-deployment.yaml
kubectl apply -f https://k8s.io/examples/service/access/frontend-service.yaml
</code></pre></div>
<p>通过输出确认两个资源都已经被创建：</p>
<pre><code>deployment.apps/frontend created
service/frontend created
</code></pre>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 这个 nginx 配置文件是被打包在
<a href=/examples/service/access/Dockerfile>容器镜像</a> 里的。
更好的方法是使用
<a href=/zh/docs/tasks/configure-pod-container/configure-pod-configmap/>ConfigMap</a>，
这样的话你可以更轻易地更改配置。
</div>
<h3 id=interact-with-the-frontend-service>与前端 Service 交互 </h3>
<p>一旦你创建了 LoadBalancer 类型的 Service，你可以使用这条命令查看外部 IP：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get service frontend
</code></pre></div>
<p>外部 IP 字段的生成可能需要一些时间。如果是这种情况，外部 IP 会显示为 <code>&lt;pending></code>。</p>
<pre><code>NAME       CLUSTER-IP      EXTERNAL-IP   PORT(S)  AGE
frontend   10.51.252.116   &lt;pending&gt;     80/TCP   10s
</code></pre>
<p>当外部 IP 地址被分配可用时，配置会更新，在 <code>EXTERNAL-IP</code> 头部下显示新的 IP：</p>
<pre><code>NAME       CLUSTER-IP      EXTERNAL-IP        PORT(S)  AGE
frontend   10.51.252.116   XXX.XXX.XXX.XXX    80/TCP   1m
</code></pre>
<p>这一新的 IP 地址就可以用来从集群外与 <code>frontend</code> 服务交互了。</p>
<h3 id=通过前端发送流量>通过前端发送流量</h3>
<p>前端和后端已经完成连接了。你可以使用 curl 命令通过你的前端 Service 的外部
IP 访问服务端点。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>curl http://<span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>EXTERNAL_IP</span><span style=color:#b68;font-weight:700>}</span> <span style=color:#080;font-style:italic># 将 EXTERNAL_P 替换为你之前看到的外部 IP</span>
</code></pre></div>
<p>输出显示后端生成的消息：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{<span style=color:green;font-weight:700>&#34;message&#34;</span>:<span style=color:#b44>&#34;Hello&#34;</span>}
</code></pre></div><h2 id=cleaning-up>Cleaning up</h2>
<p>要删除服务，输入下面的命令：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete services frontend backend
</code></pre></div>
<p>要删除在前端和后端应用中运行的 Deployment、ReplicaSet 和 Pod，输入下面的命令：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete deployment frontend backend
</code></pre></div><h2 id=what-s-next>What's next</h2>
<ul>
<li>进一步了解 <a href=/zh/docs/concepts/services-networking/service/>Service</a></li>
<li>进一步了解 <a href=/zh/docs/tasks/configure-pod-container/configure-pod-configmap/>ConfigMap</a></li>
<li>进一步了解 <a href=/zh/docs/concepts/services-networking/dns-pod-service/>Service 和 Pods 的 DNS</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-21cd8f87563675fb0278d3694ba9ecb0>11.6 - 创建外部负载均衡器</h1>
<p>本文展示如何创建一个外部负载均衡器。</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 此功能仅适用于支持外部负载均衡器的云提供商或环境。
</div>
<p>创建服务时，你可以选择自动创建云网络负载均衡器。这提供了一个外部可访问的 IP 地址，
可将流量分配到集群节点上的正确端口上
（ <em>假设集群在支持的环境中运行，并配置了正确的云负载平衡器提供商包</em>）。</p>
<p>有关如何配置和使用 Ingress 资源为服务提供外部可访问的 URL、负载均衡流量、终止 SSL 等功能，
请查看 <a href=/zh/docs/concepts/services-networking/ingress/>Ingress</a> 文档。</p>
<h2 id=before-you-begin>Before you begin</h2>
<ul>
<li><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li>
</ul>
To check the version, enter <code>kubectl version</code>.
</li>
</ul>
<h2 id=配置文件>配置文件</h2>
<p>要创建外部负载均衡器，请将以下内容添加到
<a href=/zh/docs/concepts/services-networking/service/#loadbalancer>服务配置文件</a>：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#bbb>    </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>LoadBalancer<span style=color:#bbb>
</span></code></pre></div>
<p>你的配置文件可能会如下所示：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>example-service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>example<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>8765</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>9376</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>LoadBalancer<span style=color:#bbb>
</span></code></pre></div>
<h2 id=使用-kubectl>使用 kubectl</h2>
<p>你也可以使用 <code>kubectl expose</code> 命令及其 <code>--type=LoadBalancer</code> 参数创建服务：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl expose rc example --port<span style=color:#666>=</span><span style=color:#666>8765</span> --target-port<span style=color:#666>=</span><span style=color:#666>9376</span> <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>        --name<span style=color:#666>=</span>example-service --type<span style=color:#666>=</span>LoadBalancer
</code></pre></div>
<p>此命令通过使用与引用资源（在上面的示例的情况下，名为 <code>example</code> 的 replication controller）相同的选择器来创建一个新的服务。</p>
<p>更多信息（包括更多的可选参数），请参阅
<a href=/docs/reference/generated/kubectl/kubectl-commands/#expose><code>kubectl expose</code> 指南</a>。</p>
<h2 id=找到你的-ip-地址>找到你的 IP 地址</h2>
<p>你可以通过 <code>kubectl</code> 获取服务信息，找到为你的服务创建的 IP 地址：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl describe services example-service
</code></pre></div>
<p>这将获得如下输出：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>    Name:                   example-service
    Namespace:              default
    Labels:                 &lt;none&gt;
    Annotations:            &lt;none&gt;
    Selector:               <span style=color:#b8860b>app</span><span style=color:#666>=</span>example
    Type:                   LoadBalancer
    IP:                     10.67.252.103
    LoadBalancer Ingress:   192.0.2.89
    Port:                   &lt;unnamed&gt; 80/TCP
    NodePort:               &lt;unnamed&gt; 32445/TCP
    Endpoints:              10.64.0.4:80,10.64.1.5:80,10.64.2.4:80
    Session Affinity:       None
    Events:                 &lt;none&gt;
</code></pre></div>
<p>IP 地址列在 <code>LoadBalancer Ingress</code> 旁边。</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> <p>如果你在 Minikube 上运行服务，你可以通过以下命令找到分配的 IP 地址和端口：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>minikube service example-service --url
</code></pre></div>
</div>
<h2 id=保留客户端源-ip>保留客户端源 IP</h2>
<p>由于此功能的实现，目标容器中看到的源 IP 将 <em>不是客户端的原始源 IP</em>。
要启用保留客户端 IP，可以在服务的 spec 中配置以下字段（支持 GCE/Google Kubernetes Engine 环境）：</p>
<ul>
<li><code>service.spec.externalTrafficPolicy</code> - 表示此服务是否希望将外部流量路由到节点本地或集群范围的端点。
有两个可用选项：Cluster（默认）和 Local。
Cluster 隐藏了客户端源 IP，可能导致第二跳到另一个节点，但具有良好的整体负载分布。
Local 保留客户端源 IP 并避免 LoadBalancer 和 NodePort 类型服务的第二跳，
但存在潜在的不均衡流量传播风险。</li>
</ul>
<ul>
<li><code>service.spec.healthCheckNodePort</code> - 指定服务的 healthcheck nodePort（数字端口号）。
如果未指定 <code>healthCheckNodePort</code>，服务控制器从集群的 NodePort 范围内分配一个端口。
你可以通过设置 API 服务器的命令行选项 <code>--service-node-port-range</code> 来配置上述范围。
它将会使用用户指定的 <code>healthCheckNodePort</code> 值（如果被客户端指定）。
仅当 <code>type</code> 设置为 LoadBalancer 并且 <code>externalTrafficPolicy</code> 设置为 Local 时才生效。</li>
</ul>
<p>可以通过在服务的配置文件中将 <code>externalTrafficPolicy</code> 设置为 Local 来激活此功能。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>example-service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>example<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>8765</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>9376</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>externalTrafficPolicy</span>:<span style=color:#bbb> </span>Local<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>LoadBalancer<span style=color:#bbb>
</span></code></pre></div>
<h2 id=回收负载均衡器>回收负载均衡器</h2>
<p>在通常情况下，应在删除 LoadBalancer 类型服务后立即清除云提供商中的相关负载均衡器资源。
但是，众所周知，在删除关联的服务后，云资源被孤立的情况很多。
引入了针对服务负载均衡器的终结器保护，以防止这种情况发生。
通过使用终结器，在删除相关的负载均衡器资源之前，也不会删除服务资源。</p>
<p>具体来说，如果服务具有 <code>type</code> LoadBalancer，则服务控制器将附加一个名为
<code>service.kubernetes.io/load-balancer-cleanup</code> 的终结器。
仅在清除负载均衡器资源后才能删除终结器。
即使在诸如服务控制器崩溃之类的极端情况下，这也可以防止负载均衡器资源悬空。</p>
<h2 id=外部负载均衡器提供商>外部负载均衡器提供商</h2>
<p>请务必注意，此功能的数据路径由 Kubernetes 集群外部的负载均衡器提供。</p>
<p>当服务 <code>type</code> 设置为 LoadBalancer 时，Kubernetes 向集群中的 Pod 提供的功能等同于
<code>type</code> 等于 ClusterIP，并通过使用 Kubernetes pod 的条目对负载均衡器（从外部到 Kubernetes）
进行编程来扩展它。
Kubernetes 服务控制器自动创建外部负载均衡器、健康检查（如果需要）、防火墙规则（如果需要），
并获取云提供商分配的外部 IP 并将其填充到服务对象中。</p>
<h2 id=保留源-ip-时的注意事项和限制>保留源 IP 时的注意事项和限制</h2>
<p>GCE/AWS 负载均衡器不为其目标池提供权重。
对于旧的 LB kube-proxy 规则来说，这不是一个问题，它可以在所有端点之间正确平衡。</p>
<p>使用新功能，外部流量不会在 pod 之间平均负载，而是在节点级别平均负载
（因为 GCE/AWS 和其他外部 LB 实现无法指定每个节点的权重，
因此它们的平衡跨所有目标节点，并忽略每个节点上的 Pod 数量）。</p>
<p>但是，我们可以声明，对于 <code>NumServicePods &lt;&lt; NumNodes</code> 或 <code>NumServicePods >> NumNodes</code> 时，
即使没有权重，也会看到接近相等的分布。</p>
<p>一旦外部负载平衡器提供权重，就可以将此功能添加到 LB 编程路径中。
<em>未来工作：1.4 版本不提供权重支持，但可能会在将来版本中添加</em></p>
<p>内部 Pod 到 Pod 的流量应该与 ClusterIP 服务类似，所有 Pod 的概率相同。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-48e8f306f919c5b81265e265a2b76ab4>11.7 - 列出集群中所有运行容器的镜像</h1>
<p>本文展示如何使用 kubectl 来列出集群中所有运行 Pod 的容器的镜像</p>
<h2 id=before-you-begin>Before you begin</h2>
<p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li>
</ul>
To check the version, enter <code>kubectl version</code>.
</p>
<p>在本练习中，你将使用 kubectl 来获取集群中运行的所有 Pod，并格式化输出来提取每个 Pod 中的容器列表。</p>
<h2 id=列出所有命名空间下的所有容器>列出所有命名空间下的所有容器</h2>
<ul>
<li>使用 <code>kubectl get pods --all-namespaces</code> 获取所有命名空间下的所有 Pod</li>
<li>使用 <code>-o jsonpath={.items[*].spec.containers[*].image}</code> 来格式化输出，以仅包含容器镜像名称。
这将以递归方式从返回的 json 中解析出 <code>image</code> 字段。
<ul>
<li>参阅 <a href=/zh/docs/reference/kubectl/jsonpath/>jsonpath 说明</a>
获取更多关于如何使用 jsonpath 的信息。</li>
</ul>
</li>
<li>使用标准化工具来格式化输出：<code>tr</code>, <code>sort</code>, <code>uniq</code>
<ul>
<li>使用 <code>tr</code> 以用换行符替换空格</li>
<li>使用 <code>sort</code> 来对结果进行排序</li>
<li>使用 <code>uniq</code> 来聚合镜像计数</li>
</ul>
</li>
</ul>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods --all-namespaces -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#34;{.items[*].spec.containers[*].image}&#34;</span> |<span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>tr -s <span style=color:#b44>&#39;[[:space:]]&#39;</span> <span style=color:#b44>&#39;\n&#39;</span> |<span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>sort |<span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>uniq -c
</code></pre></div>
<p>上面的命令将递归获取所有返回项目的名为 <code>image</code> 的字段。</p>
<p>作为替代方案，可以使用 Pod 的镜像字段的绝对路径。这确保即使字段名称重复的情况下也能检索到正确的字段，例如，特定项目中的许多字段都称为 <code>name</code>：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods --all-namespaces -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#34;{.items[*].spec.containers[*].image}&#34;</span>
</code></pre></div>
<p>jsonpath 解释如下：</p>
<ul>
<li><code>.items[*]</code>: 对于每个返回的值</li>
<li><code>.spec</code>: 获取 spec</li>
<li><code>.containers[*]</code>: 对于每个容器</li>
<li><code>.image</code>: 获取镜像</li>
</ul>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 按名字获取单个 Pod 时，例如 <code>kubectl get pod nginx</code>，路径的 <code>.items[*]</code> 部分应该省略，
因为返回的是一个 Pod 而不是一个项目列表。
</div>
<h2 id=按-pod-列出容器镜像>按 Pod 列出容器镜像</h2>
<p>可以使用 <code>range</code> 操作进一步控制格式化，以单独操作每个元素。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods --all-namespaces -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{range .items[*]}{&#34;\n&#34;}{.metadata.name}{&#34;:\t&#34;}{range .spec.containers[*]}{.image}{&#34;, &#34;}{end}{end}&#39;</span> |<span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>sort
</code></pre></div>
<h2 id=列出以标签过滤后的-pod-的所有容器>列出以标签过滤后的 Pod 的所有容器</h2>
<p>要获取匹配特定标签的 Pod，请使用 -l 参数。以下匹配仅与标签 <code>app=nginx</code> 相符的 Pod。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods --all-namespaces -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#34;{.items[*].spec.containers[*].image}&#34;</span> -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>nginx
</code></pre></div>
<h2 id=列出以命名空间过滤后的-pod-的所有容器>列出以命名空间过滤后的 Pod 的所有容器</h2>
<p>要获取匹配特定命名空间的 Pod，请使用 namespace 参数。以下仅匹配 <code>kube-system</code> 命名空间下的 Pod。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods --namespace kube-system -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#34;{.items[*].spec.containers[*].image}&#34;</span>
</code></pre></div>
<h2 id=使用-go-template-代替-jsonpath-来获取容器>使用 go-template 代替 jsonpath 来获取容器</h2>
<p>作为 jsonpath 的替代，Kubectl 支持使用 <a href=https://golang.org/pkg/text/template/>go-templates</a> 来格式化输出：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods --all-namespaces -o go-template --template<span style=color:#666>=</span><span style=color:#b44>&#34;{{range .items}}{{range .spec.containers}}{{.image}} {{end}}{{end}}&#34;</span>
</code></pre></div><h2 id=what-s-next>What's next</h2>
<h3 id=参考>参考</h3>
<ul>
<li><a href=/zh/docs/reference/kubectl/jsonpath/>Jsonpath</a> 参考指南</li>
<li><a href=https://golang.org/pkg/text/template/>Go template</a> 参考指南</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-1839d8468a083839ed1cc8d18fe1142e>11.8 - 在 Minikube 环境中使用 NGINX Ingress 控制器配置 Ingress</h1>
<p><a href=/zh/docs/concepts/services-networking/ingress/>Ingress</a>是一种 API 对象，其中定义了一些规则使得集群中的
服务可以从集群外访问。
<a href=/zh/docs/concepts/services-networking/ingress-controllers/>Ingress 控制器</a>
负责满足 Ingress 中所设置的规则。</p>
<p>本节为你展示如何配置一个简单的 Ingress，根据 HTTP URI 将服务请求路由到
服务 <code>web</code> 或 <code>web2</code>。</p>
<h2 id=before-you-begin>Before you begin</h2>
<p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li>
</ul>
Your Kubernetes server must be at or later than version 1.19.
To check the version, enter <code>kubectl version</code>.
如果你使用的是较早的 Kubernetes 版本，请切换到该版本的文档。</p>
<h3 id=创建一个-minikube-集群>创建一个 Minikube 集群</h3>
<dl>
<dt>使用 Katacoda</dt>
<dd><script defer src=https://katacoda.com/embed.js></script>
<button class=button onclick=window.katacoda.init()>Launch Terminal</button>
</dd>
<dt>本地</dt>
<dd>如果已经在本地<a href=/zh/docs/tasks/tools/#minikube>安装Minikube</a>，
请运行 <code>minikube start</code> 创建一个集群。</dd>
</dl>
<h2 id=启用-ingress-控制器>启用 Ingress 控制器</h2>
<ol>
<li>
<p>为了启用 NGINIX Ingress 控制器，可以运行下面的命令：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>minikube addons <span style=color:#a2f>enable</span> ingress
</code></pre></div></li>
</ol>
<ol start=2>
<li>
<p>检查验证 NGINX Ingress 控制器处于运行状态：</p>
<ul class="nav nav-tabs" id=tab-with-md role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tab-with-md-0 role=tab aria-controls=tab-with-md-0 aria-selected=true>minikube v1.19 或更高版本</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tab-with-md-1 role=tab aria-controls=tab-with-md-1>minikube v1.18.1 或更早版本</a></li></ul>
<div class=tab-content id=tab-with-md><div id=tab-with-md-0 class="tab-pane show active" role=tabpanel aria-labelledby=tab-with-md-0>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods -n ingress-nginx
</code></pre></div>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 最多可能需要等待一分钟才能看到这些 Pod 运行正常。
</div>
<p>输出类似于：</p>
<pre><code>NAME                                        READY   STATUS      RESTARTS    AGE
ingress-nginx-admission-create-g9g49        0/1     Completed   0          11m
ingress-nginx-admission-patch-rqp78         0/1     Completed   1          11m
ingress-nginx-controller-59b45fb494-26npt   1/1     Running     0          11m
</code></pre></div>
<div id=tab-with-md-1 class=tab-pane role=tabpanel aria-labelledby=tab-with-md-1>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods -n kube-system
</code></pre></div>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 最多可能需要等待一分钟才能看到这些 Pod 运行正常。
</div>
<p>输出类似于：</p>
<pre><code>NAME                                        READY     STATUS    RESTARTS   AGE
default-http-backend-59868b7dd6-xb8tq       1/1       Running   0          1m
kube-addon-manager-minikube                 1/1       Running   0          3m
kube-dns-6dcb57bcc8-n4xd4                   3/3       Running   0          2m
kubernetes-dashboard-5498ccf677-b8p5h       1/1       Running   0          2m
nginx-ingress-controller-5984b97644-rnkrg   1/1       Running   0          1m
storage-provisioner                         1/1       Running   0          2m
</code></pre>
<p>请确保可以在输出中看到一个名称以 <code>nginx-ingress-controller-</code> 为前缀的 Pod。</p>
</div></div>
</li>
</ol>
<h2 id=部署一个-hello-world-应用>部署一个 Hello World 应用</h2>
<ol>
<li>
<p>使用下面的命令创建一个 Deployment：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create deployment web --image<span style=color:#666>=</span>gcr.io/google-samples/hello-app:1.0
</code></pre></div>
<p>输出：</p>
<pre><code>deployment.apps/web created
</code></pre></li>
</ol>
<ol start=2>
<li>
<p>将 Deployment 暴露出来：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl expose deployment web --type<span style=color:#666>=</span>NodePort --port<span style=color:#666>=</span><span style=color:#666>8080</span>
</code></pre></div>
<p>输出：</p>
<pre><code>service/web exposed
</code></pre></li>
</ol>
<ol start=3>
<li>
<p>验证 Service 已经创建，并且可能从节点端口访问：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get service web
</code></pre></div>
<p>输出类似于：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>NAME      TYPE       CLUSTER-IP       EXTERNAL-IP   PORT<span style=color:#666>(</span>S<span style=color:#666>)</span>          AGE
web       NodePort   10.104.133.249   &lt;none&gt;        8080:31637/TCP   12m
</code></pre></div></li>
</ol>
<ol start=4>
<li>
<p>使用节点端口信息访问服务：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>minikube service web --url
</code></pre></div>
<p>输出类似于：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>http://172.17.0.15:31637
</code></pre></div>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 如果使用的是 Katacoda 环境，在终端面板顶端，请点击加号标志。
然后点击 <strong>Select port to view on Host 1</strong>。
输入节点和端口号（这里是<code>31637</code>），之后点击 <strong>Display Port</strong>。
</div>
<p>输出类似于：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>Hello, world!
Version: 1.0.0
Hostname: web-55b8c6998d-8k564
</code></pre></div>
<p>你现在应该可以通过 Minikube 的 IP 地址和节点端口来访问示例应用了。
下一步是让自己能够通过 Ingress 资源来访问应用。</p>
</li>
</ol>
<h2 id=创建一个-ingress>创建一个 Ingress</h2>
<p>下面是一个定义 Ingress 的配置文件，负责通过 <code>hello-world.info</code> 将请求
转发到你的服务。</p>
<ol>
<li>
<p>根据下面的 YAML 创建文件 <code>example-ingress.yaml</code>：</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/service/networking/example-ingress.yaml download=service/networking/example-ingress.yaml><code>service/networking/example-ingress.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('service-networking-example-ingress-yaml')" title="Copy service/networking/example-ingress.yaml to clipboard">
</img>
</div>
<div class=includecode id=service-networking-example-ingress-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>networking.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Ingress<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>example-ingress<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>nginx.ingress.kubernetes.io/rewrite-target</span>:<span style=color:#bbb> </span>/$1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>host</span>:<span style=color:#bbb> </span>hello-world.info<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>http</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>paths</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span>- <span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>pathType</span>:<span style=color:#bbb> </span>Prefix<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>backend</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>service</span>:<span style=color:#bbb>
</span><span style=color:#bbb>                </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>web<span style=color:#bbb>
</span><span style=color:#bbb>                </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb>
</span><span style=color:#bbb>                  </span><span style=color:green;font-weight:700>number</span>:<span style=color:#bbb> </span><span style=color:#666>8080</span></code></pre></div>
</div>
</div>
</li>
</ol>
<ol start=2>
<li>
<p>通过运行下面的命令创建 Ingress 对象：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/service/networking/example-ingress.yaml
</code></pre></div>
<p>输出：</p>
<pre><code>ingress.networking.k8s.io/example-ingress created
</code></pre></li>
</ol>
<ol start=3>
<li>
<p>验证 IP 地址已被设置：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get ingress
</code></pre></div>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 此操作可能需要几分钟时间。
</div>
<p>接下来你将会在ADDRESS列中看到IPv4地址，例如：</p>
<pre><code>NAME              CLASS    HOSTS              ADDRESS        PORTS   AGE
example-ingress   &lt;none&gt;   hello-world.info   172.17.0.15    80      38s
</code></pre></li>
</ol>
<ol start=4>
<li>
<p>在 <code>/etc/hosts</code> 文件的末尾添加以下内容（需要管理员访问权限）：</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 如果你在本地运行 Minikube 环境，需要使用 <code>minikube ip</code> 获得外部 IP 地址。
Ingress 列表中显示的 IP 地址会是内部 IP 地址。
</div>
<pre><code>172.17.0.15 hello-world.info
</code></pre>
<p>添加完成后，在浏览器中访问URL <code>hello-world.info</code>，请求将被发送到 Minikube。</p>
</li>
</ol>
<ol start=5>
<li>
<p>验证 Ingress 控制器能够转发请求流量：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>curl hello-world.info
</code></pre></div>
<p>你应该看到类似输出：</p>
<pre><code>Hello, world!
Version: 1.0.0
Hostname: web-55b8c6998d-8k564
</code></pre>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 如果你在使用本地 Minikube 环境，你可以从浏览器中访问 hello-world.info。
</div>
</li>
</ol>
<h2 id=创建第二个-deployment>创建第二个 Deployment</h2>
<ol>
<li>
<p>使用下面的命令创建第二个 Deployment：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create deployment web2 --image<span style=color:#666>=</span>gcr.io/google-samples/hello-app:2.0
</code></pre></div>
<p>输出：</p>
<pre><code>deployment.apps/web2 created
</code></pre></li>
</ol>
<ol start=2>
<li>
<p>将第二个 Deployment 暴露出来：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl expose deployment web2 --port<span style=color:#666>=</span><span style=color:#666>8080</span> --type<span style=color:#666>=</span>NodePort
</code></pre></div>
<p>输出：</p>
<pre><code>service/web2 exposed
</code></pre></li>
</ol>
<h2 id=edit-ingress>编辑现有的 Ingress</h2>
<ol>
<li>
<p>编辑现有的 <code>example-ingress.yaml</code>，在文件最后添加以下行：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#bbb>           </span>- <span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/v2<span style=color:#bbb>
</span><span style=color:#bbb>             </span><span style=color:green;font-weight:700>pathType</span>:<span style=color:#bbb> </span>Prefix<span style=color:#bbb>
</span><span style=color:#bbb>             </span><span style=color:green;font-weight:700>backend</span>:<span style=color:#bbb>
</span><span style=color:#bbb>               </span><span style=color:green;font-weight:700>service</span>:<span style=color:#bbb>
</span><span style=color:#bbb>                 </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>web2<span style=color:#bbb>
</span><span style=color:#bbb>                 </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb>
</span><span style=color:#bbb>                   </span><span style=color:green;font-weight:700>number</span>:<span style=color:#bbb> </span><span style=color:#666>8080</span><span style=color:#bbb>
</span></code></pre></div></li>
</ol>
<ol start=2>
<li>
<p>应用变更：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f example-ingress.yaml
</code></pre></div>
<p>输出：</p>
<pre><code>ingress.networking/example-ingress configured
</code></pre></li>
</ol>
<h2 id=测试你的-ingress>测试你的 Ingress</h2>
<ol>
<li>
<p>访问 HelloWorld 应用的第一个版本：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>curl hello-world.info
</code></pre></div>
<p>输出类似于：</p>
<pre><code>Hello, world!
Version: 1.0.0
Hostname: web-55b8c6998d-8k564
</code></pre></li>
</ol>
<ol start=2>
<li>
<p>访问 HelloWorld 应用的第二个版本：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>curl hello-world.info/v2
</code></pre></div>
<p>输出类似于：</p>
<pre><code>Hello, world!
Version: 2.0.0
Hostname: web2-75cd47646f-t8cjk
</code></pre>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 如果你在本地运行 Minikube 环境，你可以使用浏览器来访问
hello-world.info 和 hello-world.info/v2。
</div>
</li>
</ol>
<h2 id=what-s-next>What's next</h2>
<ul>
<li>进一步了解 <a href=/zh/docs/concepts/services-networking/ingress/>Ingress</a>。</li>
<li>进一步了解 <a href=/zh/docs/concepts/services-networking/ingress-controllers/>Ingress 控制器</a></li>
<li>进一步了解 <a href=/zh/docs/concepts/services-networking/service/>服务</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-322786b38586b210fab68f785259c5f6>11.9 - 为集群配置 DNS</h1>
<p>Kubernetes 提供 DNS 集群插件，大多数支持的环境默认情况下都会启用。
在 Kubernetes 1.11 及其以后版本中，推荐使用 CoreDNS，
kubeadm 默认会安装 CoreDNS。</p>
<p>要了解关于如何为 Kubernetes 集群配置 CoreDNS 的更多信息，参阅
<a href=/zh/docs/tasks/administer-cluster/dns-custom-nameservers/>定制 DNS 服务</a>。
关于如何利用 kube-dns 配置 kubernetes DNS 的演示例子，参阅
<a href=https://github.com/kubernetes/examples/tree/master/staging/cluster-dns>Kubernetes DNS 插件示例</a>。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-7c319a9981586e5fbcfa21b392720650>11.10 - 同 Pod 内的容器使用共享卷通信</h1>
<p>本文旨在说明如何让一个 Pod 内的两个容器使用一个卷（Volume）进行通信。
参阅如何让两个进程跨容器通过
<a href=/zh/docs/tasks/configure-pod-container/share-process-namespace/>共享进程名字空间</a>。</p>
<h2 id=before-you-begin>Before you begin</h2>
<p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li>
</ul>
To check the version, enter <code>kubectl version</code>.
</p>
<h2 id=创建一个包含两个容器的-pod>创建一个包含两个容器的 Pod</h2>
<p>在这个练习中，你会创建一个包含两个容器的 Pod。两个容器共享一个卷用于他们之间的通信。
Pod 的配置文件如下：</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/pods/two-container-pod.yaml download=pods/two-container-pod.yaml><code>pods/two-container-pod.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-two-container-pod-yaml')" title="Copy pods/two-container-pod.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-two-container-pod-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>two-containers<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>shared-data<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>emptyDir</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-container<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>shared-data<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/usr/share/nginx/html<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>debian-container<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>debian<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>shared-data<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/pod-data<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;/bin/sh&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;-c&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;echo Hello from the debian container &gt; /pod-data/index.html&#34;</span>]<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>在配置文件中，你可以看到 Pod 有一个共享卷，名为 <code>shared-data</code>。</p>
<p>配置文件中的第一个容器运行了一个 nginx 服务器。共享卷的挂载路径是 <code>/usr/share/nginx/html</code>。
第二个容器是基于 debian 镜像的，有一个 <code>/pod-data</code> 的挂载路径。第二个容器运行了下面的命令然后终止。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#a2f>echo</span> Hello from the debian container &gt; /pod-data/index.html
</code></pre></div>
<p>注意，第二个容器在 nginx 服务器的根目录下写了 <code>index.html</code> 文件。</p>
<p>创建一个包含两个容器的 Pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/pods/two-container-pod.yaml
</code></pre></div>
<p>查看 Pod 和容器的信息：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod two-containers --output<span style=color:#666>=</span>yaml
</code></pre></div>
<p>这是输出的一部分：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>two-containers<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containerStatuses</span>:<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>containerID</span>:<span style=color:#bbb> </span>docker://c1d8abd1 ...<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>debian<span style=color:#bbb>
</span><span style=color:#bbb>    </span>...<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>lastState</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>terminated</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>...<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>debian-container<span style=color:#bbb>
</span><span style=color:#bbb>    </span>...<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>containerID</span>:<span style=color:#bbb> </span>docker://96c1ff2c5bb ...<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span>...<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-container<span style=color:#bbb>
</span><span style=color:#bbb>    </span>...<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>state</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>running</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>...<span style=color:#bbb>
</span></code></pre></div>
<p>你可以看到 debian 容器已经被终止了，而 nginx 服务器依然在运行。</p>
<p>进入 nginx 容器的 shell：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#a2f>exec</span> -it two-containers -c nginx-container -- /bin/bash
</code></pre></div>
<p>在 shell 中，确认 nginx 还在运行。</p>
<pre><code>root@two-containers:/# ps aux
</code></pre>
<p>输出类似于这样：</p>
<pre><code>USER       PID  ...  STAT START   TIME COMMAND
root         1  ...  Ss   21:12   0:00 nginx: master process nginx -g daemon off;
</code></pre>
<p>回忆一下，debian 容器在 nginx 的根目录下创建了 <code>index.html</code> 文件。
使用 <code>curl</code> 向 nginx 服务器发送一个 GET 请求：</p>
<pre><code>root@two-containers:/# curl localhost
</code></pre><p>输出表示 nginx 提供了 debian 容器写的页面：</p>
<pre><code>Hello from the debian container
</code></pre>
<h2 id=讨论>讨论</h2>
<p>Pod 能有多个容器的主要原因是为了支持辅助应用（helper applications），以协助主应用（primary application）。
辅助应用的典型例子是数据抽取，数据推送和代理。辅助应用和主应用经常需要相互通信。
就如这个练习所示，通信通常是通过共享文件系统完成的，或者，也通过回环网络接口 localhost 完成。
举个网络接口的例子，web 服务器带有一个协助程序用于拉取 Git 仓库的更新。</p>
<p>在本练习中的卷为 Pod 生命周期中的容器相互通信提供了一种方法。如果 Pod 被删除或者重建了，
任何共享卷中的数据都会丢失。</p>
<h2 id=what-s-next>What's next</h2>
<ul>
<li>进一步了解<a href=https://kubernetes.io/blog/2015/06/the-distributed-system-toolkit-patterns.html>复合容器的模式</a></li>
<li>学习<a href=https://www.slideshare.net/Docker/slideshare-burns>模块化架构中的复合容器</a></li>
<li>参见<a href=/zh/docs/tasks/configure-pod-container/configure-volume-storage/>配置 Pod 使用卷来存储数据</a></li>
<li>参考<a href=/zh/docs/tasks/configure-pod-container/share-process-namespace/>在 Pod 中的容器之间共享进程命名空间</a></li>
<li>参考 <a href=/docs/reference/generated/kubernetes-api/v1.23/#volume-v1-core>Volume</a></li>
<li>参考 <a href=/docs/reference/generated/kubernetes-api/v1.23/#pod-v1-core>Pod</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-43591bb11cc02c39e278cf07f6546810>11.11 - 访问集群上运行的服务</h1>
<p>本文展示了如何连接 Kubernetes 集群上运行的服务。</p>
<h2 id=before-you-begin>Before you begin</h2>
<p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li>
</ul>
To check the version, enter <code>kubectl version</code>.
</p>
<h2 id=访问集群上运行的服务>访问集群上运行的服务</h2>
<p>在 Kubernetes 里，<a href=/zh/docs/concepts/architecture/nodes/>节点</a>、
<a href=/zh/docs/concepts/workloads/pods/>Pod</a> 和
<a href=/zh/docs/concepts/services-networking/service/>服务</a> 都有自己的 IP。
许多情况下，集群上的节点 IP、Pod IP 和某些服务 IP 是路由不可达的，
所以不能从集群之外访问它们，例如从你自己的台式机。</p>
<h3 id=ways-to-connect>连接方式 </h3>
<p>你有多种可选方式从集群外连接节点、Pod 和服务：</p>
<ul>
<li>通过公网 IP 访问服务
<ul>
<li>使用类型为 <code>NodePort</code> 或 <code>LoadBalancer</code> 的服务，可以从外部访问它们。
请查阅<a href=/zh/docs/concepts/services-networking/service/>服务</a> 和
<a href=/docs/reference/generated/kubectl/kubectl-commands/#expose>kubectl expose</a> 文档。</li>
<li>取决于你的集群环境，你可以仅把服务暴露在你的企业网络环境中，也可以将其暴露在
因特网上。需要考虑暴露的服务是否安全，它是否有自己的用户认证？</li>
<li>将 Pod 放置于服务背后。如果要访问一个副本集合中特定的 Pod，例如用于调试目的，
请给 Pod 指定一个独特的标签并创建一个新服务选择该标签。</li>
<li>大部分情况下，都不需要应用开发者通过节点 IP 直接访问节点。</li>
</ul>
</li>
</ul>
<ul>
<li>通过 Proxy 动词访问服务、节点或者 Pod
<ul>
<li>在访问远程服务之前，利用 API 服务器执行身份认证和鉴权。
如果你的服务不够安全，无法暴露到因特网中，或者需要访问节点 IP 上的端口，
又或者出于调试目的，可使用这种方式。</li>
<li>代理可能给某些应用带来麻烦</li>
<li>此方式仅适用于 HTTP/HTTPS</li>
<li>进一步的描述在<a href=#manually-constructing-apiserver-proxy-urls>这里</a></li>
<li>从集群中的 node 或者 pod 访问。</li>
</ul>
</li>
</ul>
<ul>
<li>从集群中的一个节点或 Pod 访问
<ul>
<li>运行一个 Pod，然后使用
<a href=/docs/reference/generated/kubectl/kubectl-commands/#exec>kubectl exec</a>
连接到它的 Shell。从那个 Shell 连接其他的节点、Pod 和 服务</li>
<li>某些集群可能允许你 SSH 到集群中的节点。你可能可以从那儿访问集群服务。
这是一个非标准的方式，可能在一些集群上能工作，但在另一些上却不能。
浏览器和其他工具可能已经安装也可能没有安装。集群 DNS 可能不会正常工作。</li>
</ul>
</li>
</ul>
<h3 id=discovering-builtin-services>发现内置服务 </h3>
<p>典型情况下，kube-system 名字空间中会启动集群的几个服务。
使用 <code>kubectl cluster-info</code> 命令获取这些服务的列表：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl cluster-info
</code></pre></div>
<p>输出类似于：</p>
<pre><code>Kubernetes master is running at https://104.197.5.247
elasticsearch-logging is running at https://104.197.5.247/api/v1/namespaces/kube-system/services/elasticsearch-logging/proxy
kibana-logging is running at https://104.197.5.247/api/v1/namespaces/kube-system/services/kibana-logging/proxy
kube-dns is running at https://104.197.5.247/api/v1/namespaces/kube-system/services/kube-dns/proxy
grafana is running at https://104.197.5.247/api/v1/namespaces/kube-system/services/monitoring-grafana/proxy
heapster is running at https://104.197.5.247/api/v1/namespaces/kube-system/services/monitoring-heapster/proxy
</code></pre>
<p>这一输出显示了用 proxy 动词访问每个服务时可用的 URL。例如，此集群
（使用 Elasticsearch）启用了集群层面的日志。如果提供合适的凭据，可以通过
<code>https://104.197.5.247/api/v1/namespaces/kube-system/services/elasticsearch-logging/proxy/</code>
访问，或通过一个 <code>kubectl proxy</code> 来访问：
<code>http://localhost:8080/api/v1/namespaces/kube-system/services/elasticsearch-logging/proxy/</code>。</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 请参阅<a href=/zh/docs/tasks/administer-cluster/access-cluster-api/#accessing-the-cluster-api>使用 Kubernets API 访问集群</a>
了解如何传递凭据或如何使用 <code>kubectl proxy</code>。
</div>
<h4 id=manually-constructing-apiserver-proxy-urls>手动构建 API 服务器代理 URLs </h4>
<p>如前所述，你可以使用 <code>kubectl cluster-info</code> 命令取得服务的代理 URL。
为了创建包含服务末端、后缀和参数的代理 URLs，你可以在服务的代理 URL 中添加：
<code>http://</code><em><code>kubernetes_master_address</code></em><code>/api/v1/namespaces/</code><em><code>namespace_name</code></em><code>/services/</code><em><code>service_name[:port_name]</code></em><code>/proxy</code></p>
<p>如果还没有为你的端口指定名称，你可以不用在 URL 中指定 <em>port_name</em>。
对于命名和未命名端口，你还可以使用端口号代替 <em>port_name</em>。</p>
<p>默认情况下，API 服务器使用 HTTP 为你的服务提供代理。 要使用 HTTPS，请在服务名称前加上 <code>https:</code>：
<code>http://&lt;kubernetes_master_address>/api/v1/namespaces/&lt;namespace_name>/services/&lt;service_name>/proxy</code>
URL 的 <code>&lt;service_name></code> 段支持的格式为：</p>
<ul>
<li><code>&lt;service_name></code> - 使用 http 代理到默认或未命名端口</li>
<li><code>&lt;service_name>:&lt;port_name></code> - 使用 http 代理到指定的端口名称或端口号</li>
<li><code>https:&lt;service_name>:</code> - 使用 https 代理到默认或未命名端口（注意尾随冒号）</li>
<li><code>https:&lt;service_name>:&lt;port_name></code> - 使用 https 代理到指定的端口名称或端口号</li>
</ul>
<h5 id=示例>示例</h5>
<ul>
<li>
<p>如要访问 Elasticsearch 服务末端 <code>_search?q=user:kimchy</code>，你可以使用：</p>
<pre><code>http://104.197.5.247/api/v1/namespaces/kube-system/services/elasticsearch-logging/proxy/_search?q=user:kimchy
</code></pre></li>
</ul>
<ul>
<li>
<p>如要访问 Elasticsearch 集群健康信息<code>_cluster/health?pretty=true</code>，你会使用：</p>
<pre><code>https://104.197.5.247/api/v1/namespaces/kube-system/services/elasticsearch-logging/proxy/_cluster/health?pretty=true`
</code></pre>
<p>健康信息与下面的例子类似：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
  <span style=color:green;font-weight:700>&#34;cluster_name&#34;</span> : <span style=color:#b44>&#34;kubernetes_logging&#34;</span>,
  <span style=color:green;font-weight:700>&#34;status&#34;</span> : <span style=color:#b44>&#34;yellow&#34;</span>,
  <span style=color:green;font-weight:700>&#34;timed_out&#34;</span> : <span style=color:#a2f;font-weight:700>false</span>,
  <span style=color:green;font-weight:700>&#34;number_of_nodes&#34;</span> : <span style=color:#666>1</span>,
  <span style=color:green;font-weight:700>&#34;number_of_data_nodes&#34;</span> : <span style=color:#666>1</span>,
  <span style=color:green;font-weight:700>&#34;active_primary_shards&#34;</span> : <span style=color:#666>5</span>,
  <span style=color:green;font-weight:700>&#34;active_shards&#34;</span> : <span style=color:#666>5</span>,
  <span style=color:green;font-weight:700>&#34;relocating_shards&#34;</span> : <span style=color:#666>0</span>,
  <span style=color:green;font-weight:700>&#34;initializing_shards&#34;</span> : <span style=color:#666>0</span>,
  <span style=color:green;font-weight:700>&#34;unassigned_shards&#34;</span> : <span style=color:#666>5</span>
}
</code></pre></div></li>
</ul>
<ul>
<li>
<p>要访问 <em>https</em> Elasticsearch 服务健康信息 <code>_cluster/health?pretty=true</code>，你会使用：</p>
<pre><code>https://104.197.5.247/api/v1/namespaces/kube-system/services/https:elasticsearch-logging/proxy/_cluster/health?pretty=true
</code></pre></li>
</ul>
<h4 id=通过-web-浏览器访问集群中运行的服务>通过 Web 浏览器访问集群中运行的服务</h4>
<p>你或许能够将 API 服务器代理的 URL 放入浏览器的地址栏，然而：</p>
<ul>
<li>Web 服务器通常不能传递令牌，所以你可能需要使用基本（密码）认证。
API 服务器可以配置为接受基本认证，但你的集群可能并没有这样配置。</li>
<li>某些 Web 应用可能无法工作，特别是那些使用客户端 Javascript 构造 URL 的
应用，所构造的 URL 可能并不支持代理路径前缀。</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-5a233e14205d77fe1294917d2da6f876>11.12 - 配置对多集群的访问</h1>
<p>本文展示如何使用配置文件来配置对多个集群的访问。 在将集群、用户和上下文定义在一个或多个配置文件中之后，用户可以使用 <code>kubectl config use-context</code> 命令快速地在集群之间进行切换。</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 用于配置集群访问的文件有时被称为 <em>kubeconfig 文件</em>。
这是一种引用配置文件的通用方式，并不意味着存在一个名为 <code>kubeconfig</code> 的文件。
</div>
<div class="alert alert-danger warning callout" role=alert>
<strong>Warning:</strong> 只使用来源可靠的 kubeconfig 文件。使用特制的 kubeconfig 文件可能会导致恶意代码执行或文件暴露。
如果必须使用不受信任的 kubeconfig 文件，请首先像检查 shell 脚本一样仔细检查它。
</div>
<h2 id=before-you-begin>Before you begin</h2>
<p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li>
</ul>
<p>要检查 <a class=glossary-tooltip title="kubectl 是用来和 Kubernetes 集群进行通信的命令行工具。" data-toggle=tooltip data-placement=top href=/docs/user-guide/kubectl-overview/ target=_blank aria-label=kubectl>kubectl</a> 是否安装，
执行 <code>kubectl version --client</code> 命令。
kubectl 的版本应该与集群的 API 服务器
<a href=/zh/releases/version-skew-policy/#kubectl>使用同一次版本号</a>。</p>
<h2 id=定义集群-用户和上下文>定义集群、用户和上下文</h2>
<p>假设用户有两个集群，一个用于正式开发工作，一个用于其它临时用途（scratch）。
在 <code>development</code> 集群中，前端开发者在名为 <code>frontend</code> 的名字空间下工作，
存储开发者在名为 <code>storage</code> 的名字空间下工作。 在 <code>scratch</code> 集群中，
开发人员可能在默认名字空间下工作，也可能视情况创建附加的名字空间。
访问开发集群需要通过证书进行认证。
访问其它临时用途的集群需要通过用户名和密码进行认证。</p>
<p>创建名为 <code>config-exercise</code> 的目录。 在
<code>config-exercise</code> 目录中，创建名为 <code>config-demo</code> 的文件，其内容为：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Config<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>preferences</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>clusters</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>cluster</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>development<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>cluster</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>scratch<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>users</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>developer<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>experimenter<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>contexts</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>context</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>dev-frontend<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>context</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>dev-storage<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>context</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>exp-scratch<span style=color:#bbb>
</span></code></pre></div>
<p>配置文件描述了集群、用户名和上下文。<code>config-demo</code> 文件中含有描述两个集群、
两个用户和三个上下文的框架。</p>
<p>进入 <code>config-exercise</code> 目录。输入以下命令，将群集详细信息添加到配置文件中：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl config --kubeconfig<span style=color:#666>=</span>config-demo set-cluster development --server<span style=color:#666>=</span>https://1.2.3.4 --certificate-authority<span style=color:#666>=</span>fake-ca-file
kubectl config --kubeconfig<span style=color:#666>=</span>config-demo set-cluster scratch --server<span style=color:#666>=</span>https://5.6.7.8 --insecure-skip-tls-verify
</code></pre></div>
<p>将用户详细信息添加到配置文件中：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl config --kubeconfig<span style=color:#666>=</span>config-demo set-credentials developer --client-certificate<span style=color:#666>=</span>fake-cert-file --client-key<span style=color:#666>=</span>fake-key-seefile
kubectl config --kubeconfig<span style=color:#666>=</span>config-demo set-credentials experimenter --username<span style=color:#666>=</span>exp --password<span style=color:#666>=</span>some-password
</code></pre></div>
<p>注意：</p>
<ul>
<li>要删除用户，可以运行 <code>kubectl --kubeconfig=config-demo config unset users.&lt;name></code></li>
<li>要删除集群，可以运行 <code>kubectl --kubeconfig=config-demo config unset clusters.&lt;name></code></li>
<li>要删除上下文，可以运行 <code>kubectl --kubeconfig=config-demo config unset contexts.&lt;name></code></li>
</ul>
<p>将上下文详细信息添加到配置文件中：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl config --kubeconfig<span style=color:#666>=</span>config-demo set-context dev-frontend --cluster<span style=color:#666>=</span>development --namespace<span style=color:#666>=</span>frontend --user<span style=color:#666>=</span>developer
kubectl config --kubeconfig<span style=color:#666>=</span>config-demo set-context dev-storage --cluster<span style=color:#666>=</span>development --namespace<span style=color:#666>=</span>storage --user<span style=color:#666>=</span>developer
kubectl config --kubeconfig<span style=color:#666>=</span>config-demo set-context exp-scratch --cluster<span style=color:#666>=</span>scratch --namespace<span style=color:#666>=</span>default --user<span style=color:#666>=</span>experimenter
</code></pre></div>
<p>打开 <code>config-demo</code> 文件查看添加的详细信息。 也可以使用 <code>config view</code>
命令进行查看：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl config --kubeconfig<span style=color:#666>=</span>config-demo view
</code></pre></div>
<p>输出展示了两个集群、两个用户和三个上下文：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>clusters</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>cluster</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>certificate-authority</span>:<span style=color:#bbb> </span>fake-ca-file<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>server</span>:<span style=color:#bbb> </span>https://1.2.3.4<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>development<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>cluster</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>insecure-skip-tls-verify</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>server</span>:<span style=color:#bbb> </span>https://5.6.7.8<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>scratch<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>contexts</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>context</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>cluster</span>:<span style=color:#bbb> </span>development<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>user</span>:<span style=color:#bbb> </span>developer<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>dev-frontend<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>context</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>cluster</span>:<span style=color:#bbb> </span>development<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>storage<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>user</span>:<span style=color:#bbb> </span>developer<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>dev-storage<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>context</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>cluster</span>:<span style=color:#bbb> </span>scratch<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>user</span>:<span style=color:#bbb> </span>experimenter<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>exp-scratch<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>current-context</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Config<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>preferences</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>users</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>developer<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>user</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>client-certificate</span>:<span style=color:#bbb> </span>fake-cert-file<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>client-key</span>:<span style=color:#bbb> </span>fake-key-file<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>experimenter<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>user</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>password</span>:<span style=color:#bbb> </span>some-password<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>username</span>:<span style=color:#bbb> </span>exp<span style=color:#bbb>
</span></code></pre></div>
<p>其中的 <code>fake-ca-file</code>、<code>fake-cert-file</code> 和 <code>fake-key-file</code> 是证书文件路径名的占位符。
你需要更改这些值，使之对应你的环境中证书文件的实际路径名。</p>
<p>有时你可能希望在这里使用 BASE64 编码的数据而不是一个个独立的证书文件。
如果是这样，你需要在键名上添加 <code>-data</code> 后缀。例如，
<code>certificate-authority-data</code>、<code>client-certificate-data</code> 和 <code>client-key-data</code>。</p>
<p>每个上下文包含三部分（集群、用户和名字空间），例如，
<code>dev-frontend</code> 上下文表明：使用 <code>developer</code> 用户的凭证来访问 <code>development</code> 集群的
<code>frontend</code> 名字空间。</p>
<p>设置当前上下文：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl config --kubeconfig<span style=color:#666>=</span>config-demo use-context dev-frontend
</code></pre></div>
<p>现在当输入 <code>kubectl</code> 命令时，相应动作会应用于 <code>dev-frontend</code> 上下文中所列的集群和名字空间，
同时，命令会使用 <code>dev-frontend</code> 上下文中所列用户的凭证。</p>
<p>使用 <code>--minify</code> 参数，来查看与当前上下文相关联的配置信息。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl config --kubeconfig<span style=color:#666>=</span>config-demo view --minify
</code></pre></div>
<p>输出结果展示了 <code>dev-frontend</code> 上下文相关的配置信息：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>clusters</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>cluster</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>certificate-authority</span>:<span style=color:#bbb> </span>fake-ca-file<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>server</span>:<span style=color:#bbb> </span>https://1.2.3.4<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>development<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>contexts</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>context</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>cluster</span>:<span style=color:#bbb> </span>development<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>user</span>:<span style=color:#bbb> </span>developer<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>dev-frontend<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>current-context</span>:<span style=color:#bbb> </span>dev-frontend<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Config<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>preferences</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>users</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>developer<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>user</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>client-certificate</span>:<span style=color:#bbb> </span>fake-cert-file<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>client-key</span>:<span style=color:#bbb> </span>fake-key-file<span style=color:#bbb>
</span></code></pre></div>
<p>现在假设用户希望在其它临时用途集群中工作一段时间。</p>
<p>将当前上下文更改为 <code>exp-scratch</code>：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl config --kubeconfig<span style=color:#666>=</span>config-demo use-context exp-scratch
</code></pre></div>
<p>现在你发出的所有 <code>kubectl</code> 命令都将应用于 <code>scratch</code> 集群的默认名字空间。
同时，命令会使用 <code>exp-scratch</code> 上下文中所列用户的凭证。</p>
<p>查看更新后的当前上下文 <code>exp-scratch</code> 相关的配置：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl config --kubeconfig<span style=color:#666>=</span>config-demo view --minify
</code></pre></div>
<p>最后，假设用户希望在 <code>development</code> 集群中的 <code>storage</code> 名字空间下工作一段时间。</p>
<p>将当前上下文更改为 <code>dev-storage</code>：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl config --kubeconfig<span style=color:#666>=</span>config-demo use-context dev-storage
</code></pre></div>
<p>查看更新后的当前上下文 <code>dev-storage</code> 相关的配置：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl config --kubeconfig<span style=color:#666>=</span>config-demo view --minify
</code></pre></div>
<h2 id=创建第二个配置文件>创建第二个配置文件</h2>
<p>在 <code>config-exercise</code> 目录中，创建名为 <code>config-demo-2</code> 的文件，其中包含以下内容：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Config<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>preferences</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>contexts</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>context</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>cluster</span>:<span style=color:#bbb> </span>development<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>ramp<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>user</span>:<span style=color:#bbb> </span>developer<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>dev-ramp-up<span style=color:#bbb>
</span></code></pre></div>
<p>上述配置文件定义了一个新的上下文，名为 <code>dev-ramp-up</code>。</p>
<h2 id=设置-kubeconfig-环境变量>设置 KUBECONFIG 环境变量</h2>
<p>查看是否有名为 <code>KUBECONFIG</code> 的环境变量。
如有，保存 <code>KUBECONFIG</code> 环境变量当前的值，以便稍后恢复。
例如：</p>
<h3 id=linux>Linux</h3>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#a2f>export</span> <span style=color:#b8860b>KUBECONFIG_SAVED</span><span style=color:#666>=</span><span style=color:#b8860b>$KUBECONFIG</span>
</code></pre></div><h3 id=windows-powershell>Windows PowerShell</h3>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=color:#b8860b>$Env:KUBECONFIG_SAVED</span>=<span style=color:#b8860b>$ENV:KUBECONFIG</span>
</code></pre></div>
<p><code>KUBECONFIG</code> 环境变量是配置文件路径的列表，该列表在 Linux 和 Mac 中以冒号分隔，
在 Windows 中以分号分隔。
如果有 <code>KUBECONFIG</code> 环境变量，请熟悉列表中的配置文件。</p>
<p>临时添加两条路径到 <code>KUBECONFIG</code> 环境变量中。 例如：</p>
<h3 id=linux-1>Linux</h3>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#a2f>export</span>  <span style=color:#b8860b>KUBECONFIG</span><span style=color:#666>=</span><span style=color:#b8860b>$KUBECONFIG</span>:config-demo:config-demo-2
</code></pre></div><h3 id=windows-powershell-1>Windows PowerShell</h3>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=color:#b8860b>$Env:KUBECONFIG</span>=(<span style=color:#b44>&#34;config-demo;config-demo-2&#34;</span>)
</code></pre></div>
<p>在 <code>config-exercise</code> 目录中输入以下命令：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl config view
</code></pre></div>
<p>输出展示了 <code>KUBECONFIG</code> 环境变量中所列举的所有文件合并后的信息。
特别地，注意合并信息中包含来自 <code>config-demo-2</code> 文件的 <code>dev-ramp-up</code> 上下文和来自
<code>config-demo</code> 文件的三个上下文：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>contexts</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>context</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>cluster</span>:<span style=color:#bbb> </span>development<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>user</span>:<span style=color:#bbb> </span>developer<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>dev-frontend<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>context</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>cluster</span>:<span style=color:#bbb> </span>development<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>ramp<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>user</span>:<span style=color:#bbb> </span>developer<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>dev-ramp-up<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>context</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>cluster</span>:<span style=color:#bbb> </span>development<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>storage<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>user</span>:<span style=color:#bbb> </span>developer<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>dev-storage<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>context</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>cluster</span>:<span style=color:#bbb> </span>scratch<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>user</span>:<span style=color:#bbb> </span>experimenter<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>exp-scratch<span style=color:#bbb>
</span></code></pre></div>
<p>关于 kubeconfig 文件如何合并的更多信息，请参考
<a href=/zh/docs/concepts/configuration/organize-cluster-access-kubeconfig/>使用 kubeconfig 文件组织集群访问</a></p>
<h2 id=探索-home-kube-目录>探索 $HOME/.kube 目录</h2>
<p>如果用户已经拥有一个集群，可以使用 <code>kubectl</code> 与集群进行交互，
那么很可能在 <code>$HOME/.kube</code> 目录下有一个名为 <code>config</code> 的文件。</p>
<p>进入 <code>$HOME/.kube</code> 目录，看看那里有什么文件。通常会有一个名为
<code>config</code> 的文件，目录中可能还有其他配置文件。请简单地熟悉这些文件的内容。</p>
<h2 id=将-home-kube-config-追加到-kubeconfig-环境变量中>将 $HOME/.kube/config 追加到 KUBECONFIG 环境变量中</h2>
<p>如果有 <code>$HOME/.kube/config</code> 文件，并且还未列在 <code>KUBECONFIG</code> 环境变量中，
那么现在将它追加到 <code>KUBECONFIG</code> 环境变量中。
例如：</p>
<h3 id=linux-2>Linux</h3>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#a2f>export</span> <span style=color:#b8860b>KUBECONFIG</span><span style=color:#666>=</span><span style=color:#b8860b>$KUBECONFIG</span>:<span style=color:#b8860b>$HOME</span>/.kube/config
</code></pre></div><h3 id=windows-powershell-2>Windows Powershell</h3>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=color:#b8860b>$Env:KUBECONFIG</span>=<span style=color:#b44>&#34;$Env:KUBECONFIG;$HOME\.kube\config&#34;</span>
</code></pre></div>
<p>在配置练习目录中输入以下命令，查看当前 <code>KUBECONFIG</code> 环境变量中列举的所有文件合并后的配置信息：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl config view
</code></pre></div>
<h2 id=清理>清理</h2>
<p>将 <code>KUBECONFIG</code> 环境变量还原为原始值。 例如：</p>
<h3 id=linux-3>Linux</h3>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#a2f>export</span> <span style=color:#b8860b>KUBECONFIG</span><span style=color:#666>=</span><span style=color:#b8860b>$KUBECONFIG_SAVED</span>
</code></pre></div><h3 id=windows-powershell-3>Windows PowerShell</h3>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=color:#b8860b>$Env:KUBECONFIG</span>=<span style=color:#b8860b>$ENV:KUBECONFIG_SAVED</span>
</code></pre></div><h2 id=what-s-next>What's next</h2>
<ul>
<li><a href=/zh/docs/concepts/configuration/organize-cluster-access-kubeconfig/>使用 kubeconfig 文件组织集群访问</a></li>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands#config>kubectl config</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-f6a755efe831d24956501e4bcd49ff96>12 - 监控、日志和排错</h1>
<div class=lead>设置监视和日志记录以对集群进行故障排除或调试容器化应用。</div>
</div>
<div class=td-content>
<h1 id=pg-731bb8b338c16aebfb9590ba2bd3fdd1>12.1 - </h1>
<p>:---
reviewers:</p>
<ul>
<li>janetkuo</li>
<li>thockin
content_type: concept
title: 应用自测与调试</li>
</ul>
<hr>
<p>运行应用时，不可避免的需要定位问题。
前面我们介绍了如何使用 <code>kubectl get pods</code> 来查询 pod 的简单信息。
除此之外，还有一系列的方法来获取应用的更详细信息。</p>
<h2 id=使用-kubectl-describe-pod-命令获取-pod-详情>使用 <code>kubectl describe pod</code> 命令获取 Pod 详情</h2>
<p>与之前的例子类似，我们使用一个 Deployment 来创建两个 Pod。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/application/nginx-with-request.yaml download=application/nginx-with-request.yaml><code>application/nginx-with-request.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('application-nginx-with-request-yaml')" title="Copy application/nginx-with-request.yaml to clipboard">
</img>
</div>
<div class=includecode id=application-nginx-with-request-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-deployment<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>2</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;128Mi&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;500m&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>使用如下命令创建 Deployment：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/application/nginx-with-request.yaml
</code></pre></div><pre><code>deployment.apps/nginx-deployment created
</code></pre>
<p>使用如下命令查看 Pod 状态：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods
</code></pre></div><pre><code>NAME                                READY     STATUS    RESTARTS   AGE
nginx-deployment-1006230814-6winp   1/1       Running   0          11s
nginx-deployment-1006230814-fmgu3   1/1       Running   0          11s
</code></pre>
<p>我们可以使用 <code>kubectl describe pod</code> 命令来查询每个 Pod 的更多信息，比如：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe pod nginx-deployment-1006230814-6winp
</code></pre></div><pre><code>Name:		nginx-deployment-1006230814-6winp
Namespace:	default
Node:		kubernetes-node-wul5/10.240.0.9
Start Time:	Thu, 24 Mar 2016 01:39:49 +0000
Labels:		app=nginx,pod-template-hash=1006230814
Annotations:    kubernetes.io/created-by={&quot;kind&quot;:&quot;SerializedReference&quot;,&quot;apiVersion&quot;:&quot;v1&quot;,&quot;reference&quot;:{&quot;kind&quot;:&quot;ReplicaSet&quot;,&quot;namespace&quot;:&quot;default&quot;,&quot;name&quot;:&quot;nginx-deployment-1956810328&quot;,&quot;uid&quot;:&quot;14e607e7-8ba1-11e7-b5cb-fa16&quot; ...
Status:		Running
IP:		10.244.0.6
Controllers:	ReplicaSet/nginx-deployment-1006230814
Containers:
  nginx:
    Container ID:	docker://90315cc9f513c724e9957a4788d3e625a078de84750f244a40f97ae355eb1149
    Image:		nginx
    Image ID:		docker://6f62f48c4e55d700cf3eb1b5e33fa051802986b77b874cc351cce539e5163707
    Port:		80/TCP
    QoS Tier:
      cpu:	Guaranteed
      memory:	Guaranteed
    Limits:
      cpu:	500m
      memory:	128Mi
    Requests:
      memory:		128Mi
      cpu:		500m
    State:		Running
      Started:		Thu, 24 Mar 2016 01:39:51 +0000
    Ready:		True
    Restart Count:	0
    Environment:        &lt;none&gt;
    Mounts:
      /var/run/secrets/kubernetes.io/serviceaccount from default-token-5kdvl (ro)
Conditions:
  Type          Status
  Initialized   True
  Ready         True
  PodScheduled  True
Volumes:
  default-token-4bcbi:
    Type:	Secret (a volume populated by a Secret)
    SecretName:	default-token-4bcbi
    Optional:   false
QoS Class:      Guaranteed
Node-Selectors: &lt;none&gt;
Tolerations:    &lt;none&gt;
Events:
  FirstSeen	LastSeen	Count	From					SubobjectPath		Type		Reason		Message
  ---------	--------	-----	----					-------------		--------	------		-------
  54s		54s		1	{default-scheduler }						Normal		Scheduled	Successfully assigned nginx-deployment-1006230814-6winp to kubernetes-node-wul5
  54s		54s		1	{kubelet kubernetes-node-wul5}	spec.containers{nginx}	Normal		Pulling		pulling image &quot;nginx&quot;
  53s		53s		1	{kubelet kubernetes-node-wul5}	spec.containers{nginx}	Normal		Pulled		Successfully pulled image &quot;nginx&quot;
  53s		53s		1	{kubelet kubernetes-node-wul5}	spec.containers{nginx}	Normal		Created		Created container with docker id 90315cc9f513
  53s		53s		1	{kubelet kubernetes-node-wul5}	spec.containers{nginx}	Normal		Started		Started container with docker id 90315cc9f513
</code></pre>
<p>这里可以看到容器和 Pod 的标签、资源需求等配置信息，还可以看到状态、就绪态、
重启次数、事件等状态信息。</p>
<p>容器状态是 Waiting、Running 和 Terminated 之一。
根据状态的不同，还有对应的额外的信息 —— 在这里你可以看到，
对于处于运行状态的容器，系统会告诉你容器的启动时间。</p>
<p>Ready 指示是否通过了最后一个就绪态探测。
(在本例中，容器没有配置就绪态探测；如果没有配置就绪态探测，则假定容器已经就绪。)</p>
<p>Restart Count 告诉你容器已重启的次数；
这些信息对于定位配置了 “Always” 重启策略的容器持续崩溃问题非常有用。</p>
<p>目前，唯一与 Pod 有关的状态是 Ready 状况，该状况表明 Pod 能够为请求提供服务，
并且应该添加到相应服务的负载均衡池中。</p>
<p>最后，你还可以看到与 Pod 相关的近期事件。
系统通过指示第一次和最后一次看到事件以及看到该事件的次数来压缩多个相同的事件。
“From” 标明记录事件的组件，
“SubobjectPath” 告诉你引用了哪个对象（例如 Pod 中的容器），
“Reason” 和 “Message” 告诉你发生了什么。</p>
<h2 id=例子-调试-pending-状态的-pod>例子: 调试 Pending 状态的 Pod</h2>
<p>可以使用事件来调试的一个常见的场景是，你创建 Pod 无法被调度到任何节点。
比如，Pod 请求的资源比较多，没有任何一个节点能够满足，或者它指定了一个标签，没有节点可匹配。
假定我们创建之前的 Deployment 时指定副本数是 5（不再是 2），并且请求 600 毫核（不再是 500），
对于一个 4 个节点的集群，若每个节点只有 1 个 CPU，这时至少有一个 Pod 不能被调度。
（需要注意的是，其他集群插件 Pod，比如 fluentd、skydns 等等会在每个节点上运行，
如果我们需求 1000 毫核，将不会有 Pod 会被调度。）</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods
</code></pre></div><pre><code>NAME                                READY     STATUS    RESTARTS   AGE
nginx-deployment-1006230814-6winp   1/1       Running   0          7m
nginx-deployment-1006230814-fmgu3   1/1       Running   0          7m
nginx-deployment-1370807587-6ekbw   1/1       Running   0          1m
nginx-deployment-1370807587-fg172   0/1       Pending   0          1m
nginx-deployment-1370807587-fz9sd   0/1       Pending   0          1m
</code></pre>
<p>为了查找 Pod nginx-deployment-1370807587-fz9sd 没有运行的原因，我们可以使用
<code>kubectl describe pod</code> 命令描述 Pod，查看其事件：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe pod nginx-deployment-1370807587-fz9sd
</code></pre></div><pre><code>  Name:		nginx-deployment-1370807587-fz9sd
  Namespace:	default
  Node:		/
  Labels:		app=nginx,pod-template-hash=1370807587
  Status:		Pending
  IP:
  Controllers:	ReplicaSet/nginx-deployment-1370807587
  Containers:
    nginx:
      Image:	nginx
      Port:	80/TCP
      QoS Tier:
        memory:	Guaranteed
        cpu:	Guaranteed
      Limits:
        cpu:	1
        memory:	128Mi
      Requests:
        cpu:	1
        memory:	128Mi
      Environment Variables:
  Volumes:
    default-token-4bcbi:
      Type:	Secret (a volume populated by a Secret)
      SecretName:	default-token-4bcbi
  Events:
    FirstSeen	LastSeen	Count	From			        SubobjectPath	Type		Reason			    Message
    ---------	--------	-----	----			        -------------	--------	------			    -------
    1m		    48s		    7	    {default-scheduler }			        Warning		FailedScheduling	pod (nginx-deployment-1370807587-fz9sd) failed to fit in any node
  fit failure on node (kubernetes-node-6ta5): Node didn't have enough resource: CPU, requested: 1000, used: 1420, capacity: 2000
  fit failure on node (kubernetes-node-wul5): Node didn't have enough resource: CPU, requested: 1000, used: 1100, capacity: 2000
</code></pre>
<p>这里你可以看到由调度器记录的事件，它表明了 Pod 不能被调度的原因是 <code>FailedScheduling</code>（也可能是其他值）。
其 message 部分表明没有任何节点拥有足够多的资源。</p>
<p>要纠正这种情况，可以使用 <code>kubectl scale</code> 更新 Deployment，以指定 4 个或更少的副本。
(或者你可以让 Pod 继续保持这个状态，这是无害的。)</p>
<p>你在 <code>kubectl describe pod</code> 结尾处看到的事件都保存在 etcd 中，
并提供关于集群中正在发生的事情的高级信息。
如果需要列出所有事件，可使用命令：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get events
</code></pre></div>
<p>但是，需要注意的是，事件是区分名字空间的。
如果你对某些名字空间域的对象（比如 <code>my-namespace</code> 名字下的 Pod）的事件感兴趣,
你需要显式地在命令行中指定名字空间：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get events --namespace<span style=color:#666>=</span>my-namespace
</code></pre></div>
<p>查看所有 namespace 的事件，可使用 <code>--all-namespaces</code> 参数。</p>
<p>除了 <code>kubectl describe pod</code> 以外，另一种获取 Pod 额外信息（除了 <code>kubectl get pod</code>）的方法
是给 <code>kubectl get pod</code> 增加 <code>-o yaml</code> 输出格式参数。
该命令将以 YAML 格式为你提供比 <code>kubectl describe pod</code> 更多的信息 —— 实际上是系统拥有的关于 Pod 的所有信息。
在这里，你将看到注解（没有标签限制的键值元数据，由 Kubernetes 系统组件在内部使用）、
重启策略、端口和卷等。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod nginx-deployment-1006230814-6winp -o yaml
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubernetes.io/created-by</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span><span style=color:#b44;font-style:italic>      </span><span style=color:#bbb>      </span>{<span style=color:#b44>&#34;kind&#34;</span>:<span style=color:#b44>&#34;SerializedReference&#34;</span>,<span style=color:#b44>&#34;apiVersion&#34;</span>:<span style=color:#b44>&#34;v1&#34;</span>,<span style=color:#b44>&#34;reference&#34;</span>:{<span style=color:#b44>&#34;kind&#34;</span>:<span style=color:#b44>&#34;ReplicaSet&#34;</span>,<span style=color:#b44>&#34;namespace&#34;</span>:<span style=color:#b44>&#34;default&#34;</span>,<span style=color:#b44>&#34;name&#34;</span>:<span style=color:#b44>&#34;nginx-deployment-1006230814&#34;</span>,<span style=color:#b44>&#34;uid&#34;</span>:<span style=color:#b44>&#34;4c84c175-f161-11e5-9a78-42010af00005&#34;</span>,<span style=color:#b44>&#34;apiVersion&#34;</span>:<span style=color:#b44>&#34;extensions&#34;</span>,<span style=color:#b44>&#34;resourceVersion&#34;</span>:<span style=color:#b44>&#34;133434&#34;</span>}}<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>creationTimestamp</span>:<span style=color:#bbb> </span>2016-03-24T01:39:50Z<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>generateName</span>:<span style=color:#bbb> </span>nginx-deployment-1006230814-<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>pod-template-hash</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;1006230814&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-deployment-1006230814-6winp<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resourceVersion</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;133447&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>uid</span>:<span style=color:#bbb> </span>4c879808-f161-11e5-9a78-42010af00005<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>imagePullPolicy</span>:<span style=color:#bbb> </span>Always<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span>500m<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>128Mi<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span>500m<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>128Mi<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>terminationMessagePath</span>:<span style=color:#bbb> </span>/dev/termination-log<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/var/run/secrets/kubernetes.io/serviceaccount<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>default-token-4bcbi<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>dnsPolicy</span>:<span style=color:#bbb> </span>ClusterFirst<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>nodeName</span>:<span style=color:#bbb> </span>kubernetes-node-wul5<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Always<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>securityContext</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>serviceAccount</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>serviceAccountName</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>terminationGracePeriodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>30</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>default-token-4bcbi<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>secret</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>secretName</span>:<span style=color:#bbb> </span>default-token-4bcbi<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>conditions</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>lastProbeTime</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>null</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>lastTransitionTime</span>:<span style=color:#bbb> </span>2016-03-24T01:39:51Z<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;True&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Ready<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containerStatuses</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>containerID</span>:<span style=color:#bbb> </span>docker://90315cc9f513c724e9957a4788d3e625a078de84750f244a40f97ae355eb1149<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>imageID</span>:<span style=color:#bbb> </span>docker://6f62f48c4e55d700cf3eb1b5e33fa051802986b77b874cc351cce539e5163707<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>lastState</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>ready</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>restartCount</span>:<span style=color:#bbb> </span><span style=color:#666>0</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>state</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>running</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>startedAt</span>:<span style=color:#bbb> </span>2016-03-24T01:39:51Z<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>hostIP</span>:<span style=color:#bbb> </span><span style=color:#666>10.240.0.9</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>phase</span>:<span style=color:#bbb> </span>Running<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>podIP</span>:<span style=color:#bbb> </span><span style=color:#666>10.244.0.6</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>startTime</span>:<span style=color:#bbb> </span>2016-03-24T01:39:49Z<span style=color:#bbb>
</span></code></pre></div>
<h2 id=示例-调试宕机或无法联系的节点>示例：调试宕机或无法联系的节点</h2>
<p>有时候，在调试时，查看节点的状态是很有用的 —— 例如，因为你已经注意到节点上运行的 Pod 的奇怪行为，
或者想了解为什么 Pod 不会调度到节点上。
与 Pod 一样，你可以使用 <code>kubectl describe node</code> 和 <code>kubectl get node -o yaml</code> 来查询节点的详细信息。
例如，如果某个节点宕机（与网络断开连接，或者 kubelet 挂掉无法重新启动等等），你将看到以下情况。
请注意显示节点未就绪的事件，也请注意 Pod 不再运行(它们在5分钟未就绪状态后被驱逐)。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get nodes
</code></pre></div><pre><code>NAME                     STATUS       ROLES     AGE     VERSION
kubernetes-node-861h     NotReady     &lt;none&gt;    1h      v1.13.0
kubernetes-node-bols     Ready        &lt;none&gt;    1h      v1.13.0
kubernetes-node-st6x     Ready        &lt;none&gt;    1h      v1.13.0
kubernetes-node-unaj     Ready        &lt;none&gt;    1h      v1.13.0
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe node kubernetes-node-861h
</code></pre></div><pre><code class=language-none data-lang=none>Name:			kubernetes-node-861h
Role
Labels:		 kubernetes.io/arch=amd64
           kubernetes.io/os=linux
           kubernetes.io/hostname=kubernetes-node-861h
Annotations:        node.alpha.kubernetes.io/ttl=0
                    volumes.kubernetes.io/controller-managed-attach-detach=true
Taints:             &lt;none&gt;
CreationTimestamp:	Mon, 04 Sep 2017 17:13:23 +0800
Phase:
Conditions:
  Type		Status		LastHeartbeatTime			LastTransitionTime			Reason					Message
  ----    ------    -----------------     ------------------      ------          -------
  OutOfDisk             Unknown         Fri, 08 Sep 2017 16:04:28 +0800         Fri, 08 Sep 2017 16:20:58 +0800         NodeStatusUnknown       Kubelet stopped posting node status.
  MemoryPressure        Unknown         Fri, 08 Sep 2017 16:04:28 +0800         Fri, 08 Sep 2017 16:20:58 +0800         NodeStatusUnknown       Kubelet stopped posting node status.
  DiskPressure          Unknown         Fri, 08 Sep 2017 16:04:28 +0800         Fri, 08 Sep 2017 16:20:58 +0800         NodeStatusUnknown       Kubelet stopped posting node status.
  Ready                 Unknown         Fri, 08 Sep 2017 16:04:28 +0800         Fri, 08 Sep 2017 16:20:58 +0800         NodeStatusUnknown       Kubelet stopped posting node status.
Addresses:	10.240.115.55,104.197.0.26
Capacity:
 cpu:           2
 hugePages:     0
 memory:        4046788Ki
 pods:          110
Allocatable:
 cpu:           1500m
 hugePages:     0
 memory:        1479263Ki
 pods:          110
System Info:
 Machine ID:                    8e025a21a4254e11b028584d9d8b12c4
 System UUID:                   349075D1-D169-4F25-9F2A-E886850C47E3
 Boot ID:                       5cd18b37-c5bd-4658-94e0-e436d3f110e0
 Kernel Version:                4.4.0-31-generic
 OS Image:                      Debian GNU/Linux 8 (jessie)
 Operating System:              linux
 Architecture:                  amd64
 Container Runtime Version:     docker://1.12.5
 Kubelet Version:               v1.6.9+a3d1dfa6f4335
 Kube-Proxy Version:            v1.6.9+a3d1dfa6f4335
ExternalID:                     15233045891481496305
Non-terminated Pods:            (9 in total)
  Namespace                     Name                                            CPU Requests    CPU Limits      Memory Requests Memory Limits
  ---------                     ----                                            ------------    ----------      --------------- -------------
......
Allocated resources:
  (Total limits may be over 100 percent, i.e., overcommitted.)
  CPU Requests  CPU Limits      Memory Requests         Memory Limits
  ------------  ----------      ---------------         -------------
  900m (60%)    2200m (146%)    1009286400 (66%)        5681286400 (375%)
Events:         &lt;none&gt;
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get node kubernetes-node-861h -o yaml
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Node<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>creationTimestamp</span>:<span style=color:#bbb> </span>2015-07-10T21:32:29Z<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubernetes.io/hostname</span>:<span style=color:#bbb> </span>kubernetes-node-861h<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>kubernetes-node-861h<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resourceVersion</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;757&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selfLink</span>:<span style=color:#bbb> </span>/api/v1/nodes/kubernetes-node-861h<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>uid</span>:<span style=color:#bbb> </span>2a69374e-274b-11e5-a234-42010af0d969<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>externalID</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;15233045891481496305&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>podCIDR</span>:<span style=color:#bbb> </span><span style=color:#666>10.244.0.0</span>/24<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>providerID</span>:<span style=color:#bbb> </span>gce://striped-torus-760/us-central1-b/kubernetes-node-861h<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>addresses</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>address</span>:<span style=color:#bbb> </span><span style=color:#666>10.240.115.55</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>InternalIP<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>address</span>:<span style=color:#bbb> </span><span style=color:#666>104.197.0.26</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>ExternalIP<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>capacity</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;1&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>3800808Ki<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>pods</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;100&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>conditions</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>lastHeartbeatTime</span>:<span style=color:#bbb> </span>2015-07-10T21:34:32Z<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>lastTransitionTime</span>:<span style=color:#bbb> </span>2015-07-10T21:35:15Z<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>reason</span>:<span style=color:#bbb> </span>Kubelet stopped posting node status.<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb> </span>Unknown<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Ready<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>nodeInfo</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>bootID</span>:<span style=color:#bbb> </span><span style=color:#666>4e316776</span>-b40d-4f78-a4ea-ab0d73390897<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>containerRuntimeVersion</span>:<span style=color:#bbb> </span>docker://Unknown<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kernelVersion</span>:<span style=color:#bbb> </span><span style=color:#666>3.16.0-0.</span>bpo.4-amd64<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubeProxyVersion</span>:<span style=color:#bbb> </span>v0.21.1-185-gffc5a86098dc01<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubeletVersion</span>:<span style=color:#bbb> </span>v0.21.1-185-gffc5a86098dc01<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>machineID</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>osImage</span>:<span style=color:#bbb> </span>Debian GNU/Linux 7 (wheezy)<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>systemUUID</span>:<span style=color:#bbb> </span>ABE5F6B4-D44B-108B-C46A-24CCE16C8B6E<span style=color:#bbb>
</span></code></pre></div><h2 id=what-s-next>What's next</h2>
<p>了解更多的调试工具：</p>
<ul>
<li><a href=/zh/docs/concepts/cluster-administration/logging/>日志</a></li>
<li><a href=/zh/docs/tasks/debug-application-cluster/resource-usage-monitoring/>监控</a></li>
<li><a href=/zh/docs/tasks/debug-application-cluster/get-shell-running-container/>使用 <code>exec</code> 进入容器</a></li>
<li><a href=/zh/docs/tasks/extend-kubernetes/http-proxy-access-api/>使用代理连接容器</a></li>
<li><a href=/zh/docs/tasks/access-application-cluster/port-forward-access-application-cluster/>使用端口转发连接容器</a></li>
<li><a href=/zh/docs/tasks/debug-application-cluster/crictl/>使用 crictl 检查节点</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-5e4a82f171ec2c11da7360a67efb4abf>12.2 - 使用 crictl 对 Kubernetes 节点进行调试</h1>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.11 [stable]</code>
</div>
<p><code>crictl</code> 是 CRI 兼容的容器运行时命令行接口。
你可以使用它来检查和调试 Kubernetes 节点上的容器运行时和应用程序。
<code>crictl</code> 和它的源代码在
<a href=https://github.com/kubernetes-sigs/cri-tools>cri-tools</a> 代码库。</p>
<h2 id=before-you-begin>Before you begin</h2>
<p><code>crictl</code> 需要带有 CRI 运行时的 Linux 操作系统。</p>
<h2 id=安装-crictl>安装 crictl</h2>
<p>你可以从 cri-tools <a href=https://github.com/kubernetes-sigs/cri-tools/releases>发布页面</a>
下载一个压缩的 <code>crictl</code> 归档文件，用于几种不同的架构。
下载与你的 kubernetes 版本相对应的版本。
提取它并将其移动到系统路径上的某个位置，例如<code>/usr/local/bin/</code>。</p>
<h2 id=一般用法>一般用法</h2>
<p><code>crictl</code> 命令有几个子命令和运行时参数。
有关详细信息，请使用 <code>crictl help</code> 或 <code>crictl &lt;subcommand> help</code> 获取帮助信息。</p>
<p>你可以用以下方法之一来为 <code>crictl</code> 设置端点：</p>
<ul>
<li>设置参数 <code>--runtime-endpoint</code> 和 <code>--image-endpoint</code>。</li>
<li>设置环境变量 <code>CONTAINER_RUNTIME_ENDPOINT</code> 和 <code>IMAGE_SERVICE_ENDPOINT</code>。</li>
<li>在配置文件 <code>--config=/etc/crictl.yaml</code> 中设置端点。
要设置不同的文件，可以在运行 <code>crictl</code> 时使用 <code>--config=PATH_TO_FILE</code> 标志。</li>
</ul>
<p>你还可以在连接到服务器并启用或禁用调试时指定超时值，方法是在配置文件中指定
<code>timeout</code> 或 <code>debug</code> 值，或者使用 <code>--timeout</code> 和 <code>--debug</code> 命令行参数。</p>
<p>要查看或编辑当前配置，请查看或编辑 <code>/etc/crictl.yaml</code> 的内容。
例如，使用 <code>containerd</code> 容器运行时的配置会类似于这样：</p>
<pre><code>runtime-endpoint: unix:///var/run/containerd/containerd.sock
image-endpoint: unix:///var/run/containerd/containerd.sock
timeout: 10
debug: true
</code></pre>
<p>要进一步了解 <code>crictl</code>，参阅
<a href=https://github.com/kubernetes-sigs/cri-tools/blob/master/docs/crictl.md><code>crictl</code> 文档</a>。</p>
<h2 id=crictl-命令示例>crictl 命令示例</h2>
<div class="alert alert-danger warning callout" role=alert>
<strong>Warning:</strong>
<p>如果使用 <code>crictl</code> 在正在运行的 Kubernetes 集群上创建 Pod 沙盒或容器，
kubelet 最终将删除它们。
<code>crictl</code> 不是一个通用的工作流工具，而是一个对调试有用的工具。
</div>
<h3 id=打印-pod-清单>打印 Pod 清单</h3>
<p>打印所有 Pod 的清单：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>crictl pods
</code></pre></div>
<p>输出类似于：</p>
<pre><code>POD ID              CREATED              STATE               NAME                         NAMESPACE           ATTEMPT
926f1b5a1d33a       About a minute ago   Ready               sh-84d7dcf559-4r2gq          default             0
4dccb216c4adb       About a minute ago   Ready               nginx-65899c769f-wv2gp       default             0
a86316e96fa89       17 hours ago         Ready               kube-proxy-gblk4             kube-system         0
919630b8f81f1       17 hours ago         Ready               nvidia-device-plugin-zgbbv   kube-system         0
</code></pre>
<p>根据名称打印 Pod 清单：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>crictl pods --name nginx-65899c769f-wv2gp
</code></pre></div>
<p>输出类似于这样：</p>
<pre><code>POD ID              CREATED             STATE               NAME                     NAMESPACE           ATTEMPT
4dccb216c4adb       2 minutes ago       Ready               nginx-65899c769f-wv2gp   default             0
</code></pre>
<p>根据标签打印 Pod 清单：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>crictl pods --label <span style=color:#b8860b>run</span><span style=color:#666>=</span>nginx
</code></pre></div>
<p>输出类似于这样：</p>
<pre><code class=language-none data-lang=none>POD ID              CREATED             STATE               NAME                     NAMESPACE           ATTEMPT
4dccb216c4adb       2 minutes ago       Ready               nginx-65899c769f-wv2gp   default             0
</code></pre>
<h3 id=打印镜像清单>打印镜像清单</h3>
<p>打印所有镜像清单：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>crictl images
</code></pre></div>
<p>输出类似于这样：</p>
<pre><code class=language-none data-lang=none>IMAGE                                     TAG                 IMAGE ID            SIZE
busybox                                   latest              8c811b4aec35f       1.15MB
k8s-gcrio.azureedge.net/hyperkube-amd64   v1.10.3             e179bbfe5d238       665MB
k8s-gcrio.azureedge.net/pause-amd64       3.1                 da86e6ba6ca19       742kB
nginx                                     latest              cd5239a0906a6       109MB
</code></pre>
<p>根据仓库打印镜像清单：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>crictl images nginx
</code></pre></div>
<p>输出类似于这样：</p>
<pre><code class=language-none data-lang=none>IMAGE               TAG                 IMAGE ID            SIZE
nginx               latest              cd5239a0906a6       109MB
</code></pre>
<p>只打印镜像 ID：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>crictl images -q
</code></pre></div>
<p>输出类似于这样：</p>
<pre><code class=language-none data-lang=none>sha256:8c811b4aec35f259572d0f79207bc0678df4c736eeec50bc9fec37ed936a472a
sha256:e179bbfe5d238de6069f3b03fccbecc3fb4f2019af741bfff1233c4d7b2970c5
sha256:da86e6ba6ca197bf6bc5e9d900febd906b133eaa4750e6bed647b0fbe50ed43e
sha256:cd5239a0906a6ccf0562354852fae04bc5b52d72a2aff9a871ddb6bd57553569
</code></pre>
<h3 id=打印容器清单>打印容器清单</h3>
<p>打印所有容器清单：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>crictl ps -a
</code></pre></div>
<p>输出类似于这样：</p>
<pre><code class=language-none data-lang=none>CONTAINER ID        IMAGE                                                                                                             CREATED             STATE               NAME                       ATTEMPT
1f73f2d81bf98       busybox@sha256:141c253bc4c3fd0a201d32dc1f493bcf3fff003b6df416dea4f41046e0f37d47                                   7 minutes ago       Running             sh                         1
9c5951df22c78       busybox@sha256:141c253bc4c3fd0a201d32dc1f493bcf3fff003b6df416dea4f41046e0f37d47                                   8 minutes ago       Exited              sh                         0
87d3992f84f74       nginx@sha256:d0a8828cccb73397acb0073bf34f4d7d8aa315263f1e7806bf8c55d8ac139d5f                                     8 minutes ago       Running             nginx                      0
1941fb4da154f       k8s-gcrio.azureedge.net/hyperkube-amd64@sha256:00d814b1f7763f4ab5be80c58e98140dfc69df107f253d7fdd714b30a714260a   18 hours ago        Running             kube-proxy                 0
</code></pre>
<p>打印正在运行的容器清单：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>crictl ps
</code></pre></div>
<p>输出类似于这样：</p>
<pre><code class=language-none data-lang=none>CONTAINER ID        IMAGE                                                                                                             CREATED             STATE               NAME                       ATTEMPT
1f73f2d81bf98       busybox@sha256:141c253bc4c3fd0a201d32dc1f493bcf3fff003b6df416dea4f41046e0f37d47                                   6 minutes ago       Running             sh                         1
87d3992f84f74       nginx@sha256:d0a8828cccb73397acb0073bf34f4d7d8aa315263f1e7806bf8c55d8ac139d5f                                     7 minutes ago       Running             nginx                      0
1941fb4da154f       k8s-gcrio.azureedge.net/hyperkube-amd64@sha256:00d814b1f7763f4ab5be80c58e98140dfc69df107f253d7fdd714b30a714260a   17 hours ago        Running             kube-proxy                 0
</code></pre>
<h3 id=在正在运行的容器上执行命令>在正在运行的容器上执行命令</h3>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>crictl <span style=color:#a2f>exec</span> -i -t 1f73f2d81bf98 ls
</code></pre></div>
<p>输出类似于这样：</p>
<pre><code class=language-none data-lang=none>bin   dev   etc   home  proc  root  sys   tmp   usr   var
</code></pre>
<h3 id=获取容器日志>获取容器日志</h3>
<p>获取容器的所有日志：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>crictl logs 87d3992f84f74
</code></pre></div>
<p>输出类似于这样：</p>
<pre><code class=language-none data-lang=none>10.240.0.96 - - [06/Jun/2018:02:45:49 +0000] &quot;GET / HTTP/1.1&quot; 200 612 &quot;-&quot; &quot;curl/7.47.0&quot; &quot;-&quot;
10.240.0.96 - - [06/Jun/2018:02:45:50 +0000] &quot;GET / HTTP/1.1&quot; 200 612 &quot;-&quot; &quot;curl/7.47.0&quot; &quot;-&quot;
10.240.0.96 - - [06/Jun/2018:02:45:51 +0000] &quot;GET / HTTP/1.1&quot; 200 612 &quot;-&quot; &quot;curl/7.47.0&quot; &quot;-&quot;
</code></pre>
<p>获取最近的 <code>N</code> 行日志：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>crictl logs --tail<span style=color:#666>=</span><span style=color:#666>1</span> 87d3992f84f74
</code></pre></div>
<p>输出类似于这样：</p>
<pre><code class=language-none data-lang=none>10.240.0.96 - - [06/Jun/2018:02:45:51 +0000] &quot;GET / HTTP/1.1&quot; 200 612 &quot;-&quot; &quot;curl/7.47.0&quot; &quot;-&quot;
</code></pre>
<h3 id=运行-pod-沙盒>运行 Pod 沙盒</h3>
<p>用 <code>crictl</code> 运行 Pod 沙盒对容器运行时排错很有帮助。
在运行的 Kubernetes 集群中，沙盒会随机地被 kubelet 停止和删除。</p>
<ol>
<li>
<p>编写下面的 JSON 文件：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
    <span style=color:green;font-weight:700>&#34;metadata&#34;</span>: {
        <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;nginx-sandbox&#34;</span>,
        <span style=color:green;font-weight:700>&#34;namespace&#34;</span>: <span style=color:#b44>&#34;default&#34;</span>,
        <span style=color:green;font-weight:700>&#34;attempt&#34;</span>: <span style=color:#666>1</span>,
        <span style=color:green;font-weight:700>&#34;uid&#34;</span>: <span style=color:#b44>&#34;hdishd83djaidwnduwk28bcsb&#34;</span>
    },
    <span style=color:green;font-weight:700>&#34;logDirectory&#34;</span>: <span style=color:#b44>&#34;/tmp&#34;</span>,
    <span style=color:green;font-weight:700>&#34;linux&#34;</span>: {
    }
}
</code></pre></div></li>
</ol>
<ol start=2>
<li>
<p>使用 <code>crictl runp</code> 命令应用 JSON 文件并运行沙盒。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>crictl runp pod-config.json
</code></pre></div>
<p>返回了沙盒的 ID。</p>
</li>
</ol>
<h3 id=创建容器>创建容器</h3>
<p>用 <code>crictl</code> 创建容器对容器运行时排错很有帮助。
在运行的 Kubernetes 集群中，沙盒会随机的被 kubelet 停止和删除。</p>
<ol>
<li>
<p>拉取 busybox 镜像</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>crictl pull busybox
</code></pre></div><pre><code class=language-none data-lang=none>Image is up to date for busybox@sha256:141c253bc4c3fd0a201d32dc1f493bcf3fff003b6df416dea4f41046e0f37d47
</code></pre></li>
</ol>
<ol start=2>
<li>
<p>创建 Pod 和容器的配置：</p>
<p><strong>Pod 配置</strong>：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
    <span style=color:green;font-weight:700>&#34;metadata&#34;</span>: {
        <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;nginx-sandbox&#34;</span>,
        <span style=color:green;font-weight:700>&#34;namespace&#34;</span>: <span style=color:#b44>&#34;default&#34;</span>,
        <span style=color:green;font-weight:700>&#34;attempt&#34;</span>: <span style=color:#666>1</span>,
        <span style=color:green;font-weight:700>&#34;uid&#34;</span>: <span style=color:#b44>&#34;hdishd83djaidwnduwk28bcsb&#34;</span>
    },
    <span style=color:green;font-weight:700>&#34;log_directory&#34;</span>: <span style=color:#b44>&#34;/tmp&#34;</span>,
    <span style=color:green;font-weight:700>&#34;linux&#34;</span>: {
    }
}
</code></pre></div>
<p><strong>容器配置</strong>：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
  <span style=color:green;font-weight:700>&#34;metadata&#34;</span>: {
      <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;busybox&#34;</span>
  },
  <span style=color:green;font-weight:700>&#34;image&#34;</span>:{
      <span style=color:green;font-weight:700>&#34;image&#34;</span>: <span style=color:#b44>&#34;busybox&#34;</span>
  },
  <span style=color:green;font-weight:700>&#34;command&#34;</span>: [
      <span style=color:#b44>&#34;top&#34;</span>
  ],
  <span style=color:green;font-weight:700>&#34;log_path&#34;</span>:<span style=color:#b44>&#34;busybox.log&#34;</span>,
  <span style=color:green;font-weight:700>&#34;linux&#34;</span>: {
  }
}
</code></pre></div></li>
</ol>
<ol start=3>
<li>
<p>创建容器，传递先前创建的 Pod 的 ID、容器配置文件和 Pod 配置文件。返回容器的 ID。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>crictl create f84dd361f8dc51518ed291fbadd6db537b0496536c1d2d6c05ff943ce8c9a54f container-config.json pod-config.json
</code></pre></div></li>
</ol>
<ol start=4>
<li>
<p>查询所有容器并确认新创建的容器状态为 <code>Created</code>。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>crictl ps -a
</code></pre></div>
<p>输出类似于这样：</p>
<pre><code class=language-none data-lang=none>CONTAINER ID        IMAGE               CREATED             STATE               NAME                ATTEMPT
3e025dd50a72d       busybox             32 seconds ago      Created             busybox             0
</code></pre></li>
</ol>
<h3 id=启动容器>启动容器</h3>
<p>要启动容器，要将容器 ID 传给 <code>crictl start</code>：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>crictl start 3e025dd50a72d956c4f14881fbb5b1080c9275674e95fb67f965f6478a957d60
</code></pre></div>
<p>输出类似于这样：</p>
<pre><code>3e025dd50a72d956c4f14881fbb5b1080c9275674e95fb67f965f6478a957d60
</code></pre>
<p>确认容器的状态为 <code>Running</code>。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>crictl ps
</code></pre></div>
<p>输出类似于这样：</p>
<pre><code>CONTAINER ID   IMAGE    CREATED              STATE    NAME     ATTEMPT
3e025dd50a72d  busybox  About a minute ago   Running  busybox  0
</code></pre><h2 id=what-s-next>What's next</h2>
<ul>
<li><a href=https://github.com/kubernetes-sigs/cri-tools>进一步了解 <code>crictl</code></a>.</li>
<li><a href=/zh/docs/reference/tools/map-crictl-dockercli/>将 <code>docker</code> CLI 命令映射到 <code>crictl</code></a>.</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-cbd33a50cc4779f855318a0dd00d7b06>12.3 - 审计</h1>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.23 [beta]</code>
</div>
<p>Kubernetes <em>审计（Auditing）</em> 功能提供了与安全相关的、按时间顺序排列的记录集，
记录每个用户、使用 Kubernetes API 的应用以及控制面自身引发的活动。</p>
<p>审计功能使得集群管理员能够回答以下问题：</p>
<ul>
<li>发生了什么？</li>
<li>什么时候发生的？</li>
<li>谁触发的？</li>
<li>活动发生在哪个（些）对象上？</li>
<li>在哪观察到的？</li>
<li>它从哪触发的？</li>
<li>活动的后续处理行为是什么？</li>
</ul>
<p>审计记录最初产生于
<a href=/zh/docs/reference/command-line-tools-reference/kube-apiserver/>kube-apiserver</a>
内部。每个请求在不同执行阶段都会生成审计事件；这些审计事件会根据特定策略
被预处理并写入后端。策略确定要记录的内容和用来存储记录的后端。
当前的后端支持日志文件和 webhook。</p>
<p>每个请求都可被记录其相关的 <em>阶段（stage）</em>。已定义的阶段有：</p>
<ul>
<li><code>RequestReceived</code> - 此阶段对应审计处理器接收到请求后，并且在委托给
其余处理器之前生成的事件。</li>
<li><code>ResponseStarted</code> - 在响应消息的头部发送后，响应消息体发送前生成的事件。
只有长时间运行的请求（例如 watch）才会生成这个阶段。</li>
<li><code>ResponseComplete</code> - 当响应消息体完成并且没有更多数据需要传输的时候。</li>
<li><code>Panic</code> - 当 panic 发生时生成。</li>
</ul>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> <a href=/zh/docs/reference/config-api/apiserver-audit.v1/#audit-k8s-io-v1-Event>审计事件配置</a>
的配置与 <a href=/zh/docs/reference/generated/kubernetes-api/v1.23/#event-v1-core>Event</a>
API 对象不同。
</div>
<p>审计日志记录功能会增加 API server 的内存消耗，因为需要为每个请求存储审计所需的某些上下文。
此外，内存消耗取决于审计日志记录的配置。</p>
<h2 id=audit-policy>审计策略 </h2>
<p>审计政策定义了关于应记录哪些事件以及应包含哪些数据的规则。
审计策略对象结构定义在
<a href=/zh/docs/reference/config-api/apiserver-audit.v1/#audit-k8s-io-v1-Policy><code>audit.k8s.io</code> API 组</a>
处理事件时，将按顺序与规则列表进行比较。第一个匹配规则设置事件的
<em>审计级别（Audit Level）</em>。已定义的审计级别有：</p>
<ul>
<li><code>None</code> - 符合这条规则的日志将不会记录。</li>
<li><code>Metadata</code> - 记录请求的元数据（请求的用户、时间戳、资源、动词等等），
但是不记录请求或者响应的消息体。</li>
<li><code>Request</code> - 记录事件的元数据和请求的消息体，但是不记录响应的消息体。
这不适用于非资源类型的请求。</li>
<li><code>RequestResponse</code> - 记录事件的元数据，请求和响应的消息体。这不适用于非资源类型的请求。</li>
</ul>
<p>你可以使用 <code>--audit-policy-file</code> 标志将包含策略的文件传递给 <code>kube-apiserver</code>。
如果不设置该标志，则不记录事件。
注意 <code>rules</code> 字段 <strong>必须</strong> 在审计策略文件中提供。没有（0）规则的策略将被视为非法配置。</p>
<p>以下是一个审计策略文件的示例：</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/audit/audit-policy.yaml download=audit/audit-policy.yaml><code>audit/audit-policy.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('audit-audit-policy-yaml')" title="Copy audit/audit-policy.yaml to clipboard">
</img>
</div>
<div class=includecode id=audit-audit-policy-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>audit.k8s.io/v1<span style=color:#bbb> </span><span style=color:#080;font-style:italic># This is required.</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Policy<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># Don&#39;t generate audit events for all requests in RequestReceived stage.</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>omitStages</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;RequestReceived&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># Log pod changes at RequestResponse level</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>level</span>:<span style=color:#bbb> </span>RequestResponse<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>group</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># Resource &#34;pods&#34; doesn&#39;t match requests to any subresource of pods,</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># which is consistent with the RBAC policy.</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;pods&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># Log &#34;pods/log&#34;, &#34;pods/status&#34; at Metadata level</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>level</span>:<span style=color:#bbb> </span>Metadata<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>group</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;pods/log&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;pods/status&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># Don&#39;t log requests to a configmap called &#34;controller-leader&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>level</span>:<span style=color:#bbb> </span>None<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>group</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;configmaps&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>resourceNames</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;controller-leader&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># Don&#39;t log watch requests by the &#34;system:kube-proxy&#34; on endpoints or services</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>level</span>:<span style=color:#bbb> </span>None<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>users</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;system:kube-proxy&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;watch&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>group</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&#34;</span><span style=color:#bbb> </span><span style=color:#080;font-style:italic># core API group</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;endpoints&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;services&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># Don&#39;t log authenticated requests to certain non-resource URL paths.</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>level</span>:<span style=color:#bbb> </span>None<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>userGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;system:authenticated&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>nonResourceURLs</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;/api*&#34;</span><span style=color:#bbb> </span><span style=color:#080;font-style:italic># Wildcard matching.</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;/version&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># Log the request body of configmap changes in kube-system.</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>level</span>:<span style=color:#bbb> </span>Request<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>group</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&#34;</span><span style=color:#bbb> </span><span style=color:#080;font-style:italic># core API group</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;configmaps&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># This rule only applies to resources in the &#34;kube-system&#34; namespace.</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># The empty string &#34;&#34; can be used to select non-namespaced resources.</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>namespaces</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;kube-system&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># Log configmap and secret changes in all other namespaces at the Metadata level.</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>level</span>:<span style=color:#bbb> </span>Metadata<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>group</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&#34;</span><span style=color:#bbb> </span><span style=color:#080;font-style:italic># core API group</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;secrets&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;configmaps&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># Log all other resources in core and extensions at the Request level.</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>level</span>:<span style=color:#bbb> </span>Request<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>group</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&#34;</span><span style=color:#bbb> </span><span style=color:#080;font-style:italic># core API group</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>group</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;extensions&#34;</span><span style=color:#bbb> </span><span style=color:#080;font-style:italic># Version of group should NOT be included.</span><span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># A catch-all rule to log all other requests at the Metadata level.</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>level</span>:<span style=color:#bbb> </span>Metadata<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># Long-running requests like watches that fall under this rule will not</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># generate an audit event in RequestReceived.</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>omitStages</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:#b44>&#34;RequestReceived&#34;</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>你可以使用最低限度的审计策略文件在 <code>Metadata</code> 级别记录所有请求：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#080;font-style:italic># 在 Metadata 级别为所有请求生成日志</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>audit.k8s.io/v1beta1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Policy<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>level</span>:<span style=color:#bbb> </span>Metadata<span style=color:#bbb>
</span></code></pre></div>
<p>如果你在打磨自己的审计配置文件，你可以使用为 Google Container-Optimized OS
设计的审计配置作为出发点。你可以参考
<a href=https://github.com/kubernetes/kubernetes/blob/master/cluster/gce/gci/configure-helper.sh>configure-helper.sh</a>
脚本，该脚本能够生成审计策略文件。你可以直接在脚本中看到审计策略的绝大部份内容。</p>
<p>你也可以参考 <a href=/zh/docs/reference/config-api/apiserver-audit.v1/#audit-k8s-io-v1-Policy><code>Policy</code> 配置参考</a>
以获取有关已定义字段的详细信息。</p>
<h2 id=audit-backends>审计后端 </h2>
<p>审计后端实现将审计事件导出到外部存储。<code>Kube-apiserver</code> 默认提供两个后端：</p>
<ul>
<li>Log 后端，将事件写入到文件系统</li>
<li>Webhook 后端，将事件发送到外部 HTTP API</li>
</ul>
<p>在这所有情况下，审计事件均遵循 Kubernetes API 在
<a href=/zh/docs/reference/config-api/apiserver-audit.v1/#audit-k8s-io-v1-Event><code>audit.k8s.io</code> API 组</a>
中定义的结构。</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> <p>对于 patch 请求，请求的消息体需要是设定 patch 操作的 JSON 所构成的一个串，
而不是一个完整的 Kubernetes API 对象 JSON 串。
例如，以下的示例是一个合法的 patch 请求消息体，该请求对应
<code>/apis/batch/v1/namespaces/some-namespace/jobs/some-job-name</code>。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>[
  {
    <span style=color:green;font-weight:700>&#34;op&#34;</span>: <span style=color:#b44>&#34;replace&#34;</span>,
    <span style=color:green;font-weight:700>&#34;path&#34;</span>: <span style=color:#b44>&#34;/spec/parallelism&#34;</span>,
    <span style=color:green;font-weight:700>&#34;value&#34;</span>: <span style=color:#666>0</span>
  },
  {
    <span style=color:green;font-weight:700>&#34;op&#34;</span>: <span style=color:#b44>&#34;remove&#34;</span>,
    <span style=color:green;font-weight:700>&#34;path&#34;</span>: <span style=color:#b44>&#34;/spec/template/spec/containers/0/terminationMessagePolicy&#34;</span>
  }
]
</code></pre></div>
</div>
<h3 id=log-后端>Log 后端</h3>
<p>Log 后端将审计事件写入 <a href=https://jsonlines.org/>JSONlines</a> 格式的文件。
你可以使用以下 <code>kube-apiserver</code> 标志配置 Log 审计后端：</p>
<ul>
<li><code>--audit-log-path</code> 指定用来写入审计事件的日志文件路径。不指定此标志会禁用日志后端。<code>-</code> 意味着标准化</li>
<li><code>--audit-log-maxage</code> 定义保留旧审计日志文件的最大天数</li>
<li><code>--audit-log-maxbackup</code> 定义要保留的审计日志文件的最大数量</li>
<li><code>--audit-log-maxsize</code> 定义审计日志文件的最大大小（兆字节）</li>
</ul>
<p>如果你的集群控制面以 Pod 的形式运行 kube-apiserver，记得要通过 <code>hostPath</code>
卷来访问策略文件和日志文件所在的目录，这样审计记录才会持久保存下来。例如：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>  --audit-policy-file<span style=color:#666>=</span>/etc/kubernetes/audit-policy.yaml
  --audit-log-path<span style=color:#666>=</span>/var/log/kubernetes/audit/audit.log
</code></pre></div><p>接下来挂载数据卷：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/etc/kubernetes/audit-policy.yaml<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>audit<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/var/log/kubernetes/audit/<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>audit-log<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>false</span><span style=color:#bbb>
</span></code></pre></div>
<p>最后配置 <code>hostPath</code>：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>audit<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>hostPath</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/etc/kubernetes/audit-policy.yaml<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>File<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>audit-log<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>hostPath</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/var/log/kubernetes/audit/<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>DirectoryOrCreate<span style=color:#bbb>
</span></code></pre></div>
<h3 id=webhook-backend>Webhook 后端 </h3>
<p>Webhook 后端将审计事件发送到远程 Web API，该远程 API 应该暴露与 <code>kube-apiserver</code>
形式相同的 API，包括其身份认证机制。你可以使用如下 kube-apiserver 标志来配置
Webhook 审计后端：</p>
<ul>
<li><code>--audit-webhook-config-file</code> 设置 Webhook 配置文件的路径。Webhook 配置文件实际上是一个
<a href=/zh/docs/concepts/configuration/organize-cluster-access-kubeconfig/>kubeconfig 文件</a>。</li>
<li><code>--audit-webhook-initial-backoff</code> 指定在第一次失败后重发请求等待的时间。随后的请求将以指数退避重试。</li>
</ul>
<p>Webhook 配置文件使用 kubeconfig 格式指定服务的远程地址和用于连接它的凭据。</p>
<h2 id=batching>事件批处理 </h2>
<p>日志和 Webhook 后端都支持批处理。以 Webhook 为例，以下是可用参数列表。要获取日志
后端的同样参数，请在参数名称中将 <code>webhook</code> 替换为 <code>log</code>。
默认情况下，在 <code>webhook</code> 中批处理是被启用的，在 <code>log</code> 中批处理是被禁用的。
同样，默认情况下，在 <code>webhook</code> 中启用带宽限制，在 <code>log</code> 中禁用带宽限制。</p>
<ul>
<li><code>--audit-webhook-mode</code> 定义缓存策略，可选值如下：
<ul>
<li><code>batch</code> - 以批处理缓存事件和异步的过程。这是默认值。</li>
<li><code>blocking</code> - 在 API 服务器处理每个单独事件时，阻塞其响应。</li>
<li><code>blocking-strict</code> - 与 <code>blocking</code> 相同，不过当审计日志在 RequestReceived 阶段
失败时，整个 API 服务请求会失效。</li>
</ul>
</li>
</ul>
<p>以下参数仅用于 <code>batch</code> 模式。</p>
<ul>
<li><code>--audit-webhook-batch-buffer-size</code> 定义 batch 之前要缓存的事件数。
如果传入事件的速率溢出缓存区，则会丢弃事件。</li>
<li><code>--audit-webhook-batch-max-size</code> 定义一个 batch 中的最大事件数。</li>
<li><code>--audit-webhook-batch-max-wait</code> 无条件 batch 队列中的事件前等待的最大事件。</li>
<li><code>--audit-webhook-batch-throttle-qps</code> 每秒生成的最大批次数。</li>
<li><code>--audit-webhook-batch-throttle-burst</code> 在达到允许的 QPS 前，同一时刻允许存在的最大 batch 生成数。</li>
</ul>
<h2 id=parameter-tuning>参数调整 </h2>
<p>需要设置参数以适应 API 服务器上的负载。</p>
<p>例如，如果 kube-apiserver 每秒收到 100 个请求，并且每个请求仅在 <code>ResponseStarted</code>
和 <code>ResponseComplete</code> 阶段进行审计，则应该考虑每秒生成约 200 个审计事件。
假设批处理中最多有 100 个事件，则应将限制级别设置为每秒至少 2 个查询。
假设后端最多需要 5 秒钟来写入事件，你应该设置缓冲区大小以容纳最多 5 秒的事件，
即 10 个 batch，即 1000 个事件。</p>
<p>但是，在大多数情况下，默认参数应该足够了，你不必手动设置它们。
你可以查看 kube-apiserver 公开的以下 Prometheus 指标，并在日志中监控审计子系统的状态。</p>
<ul>
<li><code>apiserver_audit_event_total</code> 包含所有暴露的审计事件数量的指标。</li>
<li><code>apiserver_audit_error_total</code> 在暴露时由于发生错误而被丢弃的事件的数量。</li>
</ul>
<h3 id=truncate>日志条目截断 </h3>
<p>日志后端和 Webhook 后端都支持限制所输出的事件的尺寸。
例如，下面是可以为日志后端配置的标志列表：</p>
<ul>
<li><code>audit-log-truncate-enabled</code>：是否弃用事件和批次的截断处理。</li>
<li><code>audit-log-truncate-max-batch-size</code>：向下层后端发送的各批次的最大尺寸字节数。</li>
<li><code>audit-log-truncate-max-event-size</code>：向下层后端发送的审计事件的最大尺寸字节数。</li>
</ul>
<p>默认情况下，截断操作在 <code>webhook</code> 和 <code>log</code> 后端都是被禁用的，集群管理员需要设置
<code>audit-log-truncate-enabled</code> 或 <code>audit-webhook-truncate-enabled</code> 标志来启用此操作。</p>
<h2 id=what-s-next>What's next</h2>
<ul>
<li>了解 <a href=/zh/docs/reference/access-authn-authz/extensible-admission-controllers/#mutating-webhook-auditing-annotations>Mutating webhook 审计注解</a>。</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-3556c4dbd027b9e90a5b3d72649003fb>12.4 - 应用故障排查</h1>
<p>本指南帮助用户调试那些部署到 Kubernetes 上后没有正常运行的应用。
本指南 <em>并非</em> 指导用户如何调试集群。
如果想调试集群的话，请参阅<a href=/zh/docs/tasks/debug-application-cluster/debug-cluster/>这里</a>。</p>
<h2 id=diagnosing-the-problem>诊断问题 </h2>
<p>故障排查的第一步是先给问题分类。问题是什么？是关于 Pods、Replication Controller 还是 Service？</p>
<ul>
<li><a href=#debugging-pods>调试 Pods</a></li>
<li><a href=#debugging-replication-controllers>调试副本控制器</a></li>
<li><a href=#debugging-services>调试服务</a></li>
</ul>
<h3 id=debugging-pods>调试 Pods </h3>
<p>调试 Pod 的第一步是查看 Pod 信息。用如下命令查看 Pod 的当前状态和最近的事件：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe pods <span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>POD_NAME</span><span style=color:#b68;font-weight:700>}</span>
</code></pre></div>
<p>查看一下 Pod 中的容器所处的状态。这些容器的状态都是 <code>Running</code> 吗？最近有没有重启过？</p>
<p>后面的调试都是要依靠 Pod 的状态的。</p>
<h4 id=pod-停滞在-pending-状态>Pod 停滞在 Pending 状态</h4>
<p>如果一个 Pod 停滞在 <code>Pending</code> 状态，表示 Pod 没有被调度到节点上。通常这是因为
某种类型的资源不足导致无法调度。
查看上面的 <code>kubectl describe ...</code> 命令的输出，其中应该显示了为什么没被调度的原因。
常见原因如下：</p>
<ul>
<li>
<p><strong>资源不足</strong>:
你可能耗尽了集群上所有的 CPU 或内存。此时，你需要删除 Pod、调整资源请求或者为集群添加节点。
更多信息请参阅<a href=/zh/docs/concepts/configuration/manage-resources-containers/>计算资源文档</a></p>
</li>
<li>
<p><strong>使用了 <code>hostPort</code></strong>:
如果绑定 Pod 到 <code>hostPort</code>，那么能够运行该 Pod 的节点就有限了。
多数情况下，<code>hostPort</code> 是非必要的，而应该采用 Service 对象来暴露 Pod。
如果确实需要使用 <code>hostPort</code>，那么集群中节点的个数就是所能创建的 Pod
的数量上限。</p>
</li>
</ul>
<h4 id=pod-停滞在-waiting-状态>Pod 停滞在 Waiting 状态</h4>
<p>如果 Pod 停滞在 <code>Waiting</code> 状态，则表示 Pod 已经被调度到某工作节点，但是无法在该节点上运行。
同样，<code>kubectl describe ...</code> 命令的输出可能很有用。
<code>Waiting</code> 状态的最常见原因是拉取镜像失败。要检查的有三个方面：</p>
<ul>
<li>确保镜像名字拼写正确</li>
<li>确保镜像已被推送到镜像仓库</li>
<li>尝试手动是否能拉取镜像。例如，如果你在你的 PC 上使用 Docker，请运行 <code>docker pull &lt;镜像></code>。</li>
</ul>
<h4 id=pod-处于-crashing-或别的不健康状态>Pod 处于 Crashing 或别的不健康状态</h4>
<p>一旦 Pod 被调度，就可以采用
<a href=/zh/docs/tasks/debug/debug-application/debug-running-pod/>调试运行中的 Pod</a>
中的方法来进一步调试。</p>
<h4 id=pod-处于-running-态但是没有正常工作>Pod 处于 Running 态但是没有正常工作</h4>
<p>如果 Pod 行为不符合预期，很可能 Pod 描述（例如你本地机器上的 <code>mypod.yaml</code>）中有问题，
并且该错误在创建 Pod 时被忽略掉，没有报错。
通常，Pod 的定义中节区嵌套关系错误、字段名字拼错的情况都会引起对应内容被忽略掉。
例如，如果你误将 <code>command</code> 写成 <code>commnd</code>，Pod 虽然可以创建，但它不会执行
你期望它执行的命令行。</p>
<p>可以做的第一件事是删除你的 Pod，并尝试带有 <code>--validate</code> 选项重新创建。
例如，运行 <code>kubectl apply --validate -f mypod.yaml</code>。
如果 <code>command</code> 被误拼成 <code>commnd</code>，你将会看到下面的错误信息：</p>
<pre><code>I0805 10:43:25.129850   46757 schema.go:126] unknown field: commnd
I0805 10:43:25.129973   46757 schema.go:129] this may be a false alarm, see https://github.com/kubernetes/kubernetes/issues/6842
pods/mypod
</code></pre>
<p>接下来就要检查的是 API 服务器上的 Pod 与你所期望创建的是否匹配
（例如，你原本使用本机上的一个 YAML 文件来创建 Pod）。
例如，运行 <code>kubectl get pods/mypod -o yaml > mypod-on-apiserver.yaml</code>，之后
手动比较 <code>mypod.yaml</code> 与从 API 服务器取回的 Pod 描述。
从 API 服务器处获得的 YAML 通常包含一些创建 Pod 所用的 YAML 中不存在的行，这是正常的。
不过，如果如果源文件中有些行在 API 服务器版本中不存在，则意味着
Pod 规约是有问题的。</p>
<h3 id=debugging-replication-controllers>调试副本控制器 </h3>
<p>副本控制器相对比较简单直接。它们要么能创建 Pod，要么不能。
如果不能创建 Pod，请参阅<a href=#debugging-pods>上述说明</a>调试 Pod。</p>
<p>你也可以使用 <code>kubectl describe rc ${CONTROLLER_NAME}</code> 命令来检视副本控制器相关的事件。</p>
<h3 id=debugging-services>调试服务 </h3>
<p>服务支持在多个 Pod 间负载均衡。
有一些常见的问题可以造成服务无法正常工作。
以下说明将有助于调试服务的问题。</p>
<p>首先，验证服务是否有端点。对于每一个 Service 对象，API 服务器为其提供
对应的 <code>endpoints</code> 资源。</p>
<p>通过如下命令可以查看 endpoints 资源：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get endpoints <span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>SERVICE_NAME</span><span style=color:#b68;font-weight:700>}</span>
</code></pre></div>
<p>确保 Endpoints 与服务成员 Pod 个数一致。
例如，如果你的 Service 用来运行 3 个副本的 nginx 容器，你应该会在服务的 Endpoints
中看到 3 个不同的 IP 地址。</p>
<h4 id=服务缺少-endpoints>服务缺少 Endpoints</h4>
<p>如果没有 Endpoints，请尝试使用 Service 所使用的标签列出 Pod。
假定你的服务包含如下标签选择算符：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span></code></pre></div>
<p>你可以使用如下命令列出与选择算符相匹配的 Pod，并验证这些 Pod 是否归属于创建的服务：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods --selector<span style=color:#666>=</span><span style=color:#b8860b>name</span><span style=color:#666>=</span>nginx,type<span style=color:#666>=</span>frontend
</code></pre></div>
<p>验证 Pod 的 <code>containerPort</code> 与服务的 <code>targetPort</code> 是否匹配。</p>
<h4 id=网络流量未被转发>网络流量未被转发</h4>
<p>请参阅<a href=/zh/docs/tasks/debug-application-cluster/debug-service/>调试 service</a> 了解更多信息。</p>
<h2 id=what-s-next>What's next</h2>
<p>如果上述方法都不能解决你的问题，请按照
<a href=/zh/docs/tasks/debug-application-cluster/debug-service/>调试服务文档</a>中的介绍，
确保你的 <code>Service</code> 处于 Running 态，有 <code>Endpoints</code> 被创建，<code>Pod</code> 真的在提供服务；
DNS 服务已配置并正常工作，iptables 规则也以安装并且 <code>kube-proxy</code> 也没有异常行为。</p>
<p>你也可以访问<a href=/zh/docs/tasks/debug-application-cluster/troubleshooting/>故障排查文档</a>来获取更多信息。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-434e0133d71583a27478b10fc1d3d105>12.5 - 故障诊断</h1>
<p>有时候事情会出错。本指南旨在解决这些问题。它包含两个部分：</p>
<ul>
<li><a href=/zh/docs/tasks/debug-application-cluster/debug-application/>应用排错</a> -
针对部署代码到 Kubernetes 并想知道代码为什么不能正常运行的用户。</li>
<li><a href=/zh/docs/tasks/debug-application-cluster/debug-cluster/>集群排错</a> -
针对集群管理员以及 Kubernetes 集群表现异常的用户。</li>
</ul>
<p>你也应该查看所用<a href=https://github.com/kubernetes/kubernetes/releases>发行版本</a>的已知问题。</p>
<h2 id=getting-help>获取帮助 </h2>
<p>如果你的问题在上述指南中没有得到答案，你还有另外几种方式从 Kubernetes 团队获得帮助。</p>
<h3 id=questions>问题 </h3>
<p>本网站上的文档针对回答各类问题进行了结构化组织和分类。
<a href=/zh/docs/concepts/>概念</a>部分解释 Kubernetes 体系结构以及每个组件的工作方式，
<a href=/zh/docs/setup/>安装</a>部分提供了安装的实用说明。
<a href=/zh/docs/tasks/>任务</a>部分展示了如何完成常用任务，
<a href=/zh/docs/tutorials/>教程</a>部分则提供对现实世界、特定行业或端到端开发场景的更全面的演练。
<a href=/zh/docs/reference/>参考</a>部分提供了详细的
<a href=/docs/reference/generated/kubernetes-api/v1.23/>Kubernetes API</a> 文档
和命令行 (CLI) 接口的文档，例如<a href=/zh/docs/reference/kubectl/><code>kubectl</code></a>。</p>
<h2 id=求救-我的问题还没有解决-我现在需要帮助>求救！我的问题还没有解决！我现在需要帮助！</h2>
<h3 id=stack-overflow>Stack Overflow </h3>
<p>社区中的其他人可能已经问过和你类似的问题，也可能能够帮助解决你的问题。
Kubernetes 团队还会监视<a href=https://stackoverflow.com/questions/tagged/kubernetes>带有 Kubernetes 标签的帖子</a>。
如果现有的问题对你没有帮助，在<a href="https://stackoverflow.com/questions/ask?tags=kubernetes">问一个新问题</a>
之前，<strong>请<a href=https://stackoverflow.com/help/on-topic>确保你的问题是关于 Stack Overflow 的主题</a>
并且你需要阅读关于<a href=https://stackoverflow.com/help/how-to-ask>如何提出新问题</a>
的指南。</strong></p>
<h3 id=slack>Slack</h3>
<p>Kubernetes 社区中有很多人在 <code>#kubernetes-users</code> 这一 Slack 频道聚集。
Slack 需要注册；你可以<a href=https://slack.kubernetes.io>请求一份邀请</a>，
并且注册是对所有人开放的。欢迎你随时来问任何问题。
一旦注册了，就可以访问通过 Web 浏览器或者 Slack 专用的应用访问
<a href=https://kubernetes.slack.com>Slack 上的 Kubernetes 组织</a>。</p>
<p>一旦你完成了注册，就可以浏览各种感兴趣主题的频道列表（一直在增长）。
例如，Kubernetes 新人可能还想加入
<a href=https://kubernetes.slack.com/messages/kubernetes-novice><code>#kubernetes-novice</code></a>
频道。又比如，开发人员应该加入
<a href=https://kubernetes.slack.com/messages/kubernetes-dev><code>#kubernetes-dev</code></a>
频道。</p>
<p>还有许多国家/地区语言频道。请随时加入这些频道以获得本地化支持和信息：</p>
<table><caption style=display:none>Country / language specific Slack channels</caption>
<thead>
<tr>
<th style=text-align:left>国家</th>
<th style=text-align:left>频道</th>
</tr>
</thead>
<tbody>
<tr>
<td style=text-align:left>中国</td>
<td style=text-align:left><a href=https://kubernetes.slack.com/messages/cn-users><code>#cn-users</code></a>, <a href=https://kubernetes.slack.com/messages/cn-events><code>#cn-events</code></a></td>
</tr>
<tr>
<td style=text-align:left>芬兰</td>
<td style=text-align:left><a href=https://kubernetes.slack.com/messages/fi-users><code>#fi-users</code></a></td>
</tr>
<tr>
<td style=text-align:left>法国</td>
<td style=text-align:left><a href=https://kubernetes.slack.com/messages/fr-users><code>#fr-users</code></a>, <a href=https://kubernetes.slack.com/messages/fr-events><code>#fr-events</code></a></td>
</tr>
<tr>
<td style=text-align:left>德国</td>
<td style=text-align:left><a href=https://kubernetes.slack.com/messages/de-users><code>#de-users</code></a>, <a href=https://kubernetes.slack.com/messages/de-events><code>#de-events</code></a></td>
</tr>
<tr>
<td style=text-align:left>印度</td>
<td style=text-align:left><a href=https://kubernetes.slack.com/messages/in-users><code>#in-users</code></a>, <a href=https://kubernetes.slack.com/messages/in-events><code>#in-events</code></a></td>
</tr>
<tr>
<td style=text-align:left>意大利</td>
<td style=text-align:left><a href=https://kubernetes.slack.com/messages/it-users><code>#it-users</code></a>, <a href=https://kubernetes.slack.com/messages/it-events><code>#it-events</code></a></td>
</tr>
<tr>
<td style=text-align:left>日本</td>
<td style=text-align:left><a href=https://kubernetes.slack.com/messages/jp-users><code>#jp-users</code></a>, <a href=https://kubernetes.slack.com/messages/jp-events><code>#jp-events</code></a></td>
</tr>
<tr>
<td style=text-align:left>韩国</td>
<td style=text-align:left><a href=https://kubernetes.slack.com/messages/kr-users><code>#kr-users</code></a></td>
</tr>
<tr>
<td style=text-align:left>荷兰</td>
<td style=text-align:left><a href=https://kubernetes.slack.com/messages/nl-users><code>#nl-users</code></a></td>
</tr>
<tr>
<td style=text-align:left>挪威</td>
<td style=text-align:left><a href=https://kubernetes.slack.com/messages/norw-users><code>#norw-users</code></a></td>
</tr>
<tr>
<td style=text-align:left>波兰</td>
<td style=text-align:left><a href=https://kubernetes.slack.com/messages/pl-users><code>#pl-users</code></a></td>
</tr>
<tr>
<td style=text-align:left>俄罗斯</td>
<td style=text-align:left><a href=https://kubernetes.slack.com/messages/ru-users><code>#ru-users</code></a></td>
</tr>
<tr>
<td style=text-align:left>西班牙</td>
<td style=text-align:left><a href=https://kubernetes.slack.com/messages/es-users><code>#es-users</code></a></td>
</tr>
<tr>
<td style=text-align:left>瑞典</td>
<td style=text-align:left><a href=https://kubernetes.slack.com/messages/se-users><code>#se-users</code></a></td>
</tr>
<tr>
<td style=text-align:left>土耳其</td>
<td style=text-align:left><a href=https://kubernetes.slack.com/messages/tr-users><code>#tr-users</code></a>, <a href=https://kubernetes.slack.com/messages/tr-events><code>#tr-events</code></a></td>
</tr>
</tbody>
</table>
<h3 id=forum>论坛 </h3>
<p>欢迎你加入 Kubernetes 官方论坛
<a href=https://discuss.kubernetes.io>discuss.kubernetes.io</a>。</p>
<h3 id=bugs-and-feature-requests>Bugs 和功能请求 </h3>
<p>如果你发现一个看起来像 Bug 的问题，或者你想提出一个功能请求，请使用
<a href=https://github.com/kubernetes/kubernetes/issues>Github 问题跟踪系统</a>。</p>
<p>在提交问题之前，请搜索现有问题列表以查看是否其中已涵盖你的问题。</p>
<p>如果提交 Bug，请提供如何重现问题的详细信息，例如：</p>
<ul>
<li>Kubernetes 版本：<code>kubectl version</code></li>
<li>云平台、OS 发行版、网络配置和 Docker 版本</li>
<li>重现问题的步骤</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-ef360b1f8e65236251826db478cfcab3>12.6 - 确定 Pod 失败的原因</h1>
<p>本文介绍如何编写和读取容器的终止消息。</p>
<p>终止消息为容器提供了一种方法，可以将有关致命事件的信息写入某个位置，
在该位置可以通过仪表板和监控软件等工具轻松检索和显示致命事件。
在大多数情况下，您放入终止消息中的信息也应该写入
<a href=/zh/docs/concepts/cluster-administration/logging/>常规 Kubernetes 日志</a>。</p>
<h2 id=before-you-begin>Before you begin</h2>
<p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li>
</ul>
To check the version, enter <code>kubectl version</code>.
</p>
<h2 id=读写终止消息>读写终止消息</h2>
<p>在本练习中，您将创建运行一个容器的 Pod。
配置文件指定在容器启动时要运行的命令。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/debug/termination.yaml download=debug/termination.yaml><code>debug/termination.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('debug-termination-yaml')" title="Copy debug/termination.yaml to clipboard">
</img>
</div>
<div class=includecode id=debug-termination-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>termination-demo<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>termination-demo-container<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>debian<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;/bin/sh&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;-c&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;sleep 10 &amp;&amp; echo Sleep expired &gt; /dev/termination-log&#34;</span>]<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<ol>
<li>
基于 YAML 配置文件创建 Pod：
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create -f https://k8s.io/examples/debug/termination.yaml
</code></pre></div>
<p>YAML 文件中，在 <code>command</code> 和 <code>args</code> 字段，你可以看到容器休眠 10 秒然后将 "Sleep expired"
写入 <code>/dev/termination-log</code> 文件。
容器写完 "Sleep expired" 消息后就终止了。</p>
</li>
<li>
显示 Pod 的信息：
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod termination-demo
</code></pre></div>
<p>重复前面的命令直到 Pod 不再运行。</p>
</li>
<li>
<p>显示 Pod 的详细信息：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod --output<span style=color:#666>=</span>yaml
</code></pre></div>输出结果包含 "Sleep expired" 消息：
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>lastState</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>terminated</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>containerID</span>:<span style=color:#bbb> </span>...<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>exitCode</span>:<span style=color:#bbb> </span><span style=color:#666>0</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>finishedAt</span>:<span style=color:#bbb> </span>...<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>message</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span><span style=color:#b44;font-style:italic>          </span><span style=color:#bbb>          </span>Sleep expired<span style=color:#bbb>
</span><span style=color:#bbb>        </span>...<span style=color:#bbb>
</span></code></pre></div></li>
<li>
<p>使用 Go 模板过滤输出结果，使其只含有终止消息：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod termination-demo -o go-template<span style=color:#666>=</span><span style=color:#b44>&#34;{{range .status.containerStatuses}}{{.lastState.terminated.message}}{{end}}&#34;</span>
</code></pre></div></li>
</ol>
<p>&lt;!
If you are running a multi-container pod, you can use a Go template to include the container's name. By doing so, you can discover which of the containers is failing:
-->
如果你正在运行多容器 Pod，则可以使用 Go 模板来包含容器的名称。这样，你可以发现哪些容器出现故障:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod multi-container-pod -o go-template<span style=color:#666>=</span><span style=color:#b44>&#39;{{range .status.containerStatuses}}{{printf &#34;%s:\n%s\n\n&#34; .name .lastState.terminated.message}}{{end}}&#39;</span>
</code></pre></div>
<h2 id=定制终止消息>定制终止消息</h2>
<p>Kubernetes 从容器的 <code>terminationMessagePath</code> 字段中指定的终止消息文件中检索终止消息，
默认值为 <code>/dev/termination-log</code>。
通过定制这个字段，您可以告诉 Kubernetes 使用不同的文件。
Kubernetes 使用指定文件中的内容在成功和失败时填充容器的状态消息。</p>
<p>在下例中，容器将终止消息写入 <code>/tmp/my-log</code> 给 Kubernetes 来接收：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>msg-path-demo<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>msg-path-demo-container<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>debian<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>terminationMessagePath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/tmp/my-log&#34;</span><span style=color:#bbb>
</span></code></pre></div>
<p>此外，用户可以设置容器的 <code>terminationMessagePolicy</code> 字段，以便进一步自定义。
此字段默认为 "<code>File</code>"，这意味着仅从终止消息文件中检索终止消息。
通过将 <code>terminationMessagePolicy</code> 设置为 "<code>FallbackToLogsOnError</code>"，你就可以告诉 Kubernetes，在容器因错误退出时，如果终止消息文件为空，则使用容器日志输出的最后一块作为终止消息。
日志输出限制为 2048 字节或 80 行，以较小者为准。</p>
<h2 id=what-s-next>What's next</h2>
<ul>
<li>参考 <a href=/docs/reference/generated/kubernetes-api/v1.23/#container-v1-core>Container</a>
资源的 <code>terminationMessagePath</code> 字段。</li>
<li>了解<a href=/zh/docs/concepts/cluster-administration/logging/>接收日志</a>。</li>
<li>了解 <a href=https://golang.org/pkg/text/template/>Go 模版</a>。</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-9713ac27b6d9e3034033200d968221f2>12.7 - 获取正在运行容器的 Shell</h1>
<p>本文介绍怎样使用 <code>kubectl exec</code> 命令获取正在运行容器的 Shell。</p>
<h2 id=before-you-begin>Before you begin</h2>
<p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li>
</ul>
To check the version, enter <code>kubectl version</code>.
</p>
<h2 id=获取容器的-shell>获取容器的 Shell</h2>
<p>在本练习中，你将创建包含一个容器的 Pod。容器运行 nginx 镜像。下面是 Pod 的配置文件：</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/application/shell-demo.yaml download=application/shell-demo.yaml><code>application/shell-demo.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('application-shell-demo-yaml')" title="Copy application/shell-demo.yaml to clipboard">
</img>
</div>
<div class=includecode id=application-shell-demo-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>shell-demo<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>shared-data<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>emptyDir</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>shared-data<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/usr/share/nginx/html<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>hostNetwork</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>dnsPolicy</span>:<span style=color:#bbb> </span>Default<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>创建 Pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create -f https://k8s.io/examples/application/shell-demo.yaml
</code></pre></div>
<p>检查容器是否运行正常：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod shell-demo
</code></pre></div>
<p>获取正在运行容器的 Shell：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#a2f>exec</span> -it shell-demo -- /bin/bash
</code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>Note:</strong>
<p>双破折号 "--" 用于将要传递给命令的参数与 kubectl 的参数分开。
</div>
<p>在 shell 中，打印根目录：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>root@shell-demo:/# ls /
</code></pre></div>
<p>在 shell 中，实验其他命令。下面是一些示例：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>root@shell-demo:/# ls /
root@shell-demo:/# cat /proc/mounts
root@shell-demo:/# cat /proc/1/maps
root@shell-demo:/# apt-get update
root@shell-demo:/# apt-get install -y tcpdump
root@shell-demo:/# tcpdump
root@shell-demo:/# apt-get install -y lsof
root@shell-demo:/# lsof
root@shell-demo:/# apt-get install -y procps
root@shell-demo:/# ps aux
root@shell-demo:/# ps aux | grep nginx
</code></pre></div>
<h2 id=编写-nginx-的根页面>编写 nginx 的根页面</h2>
<p>在看一下 Pod 的配置文件。该 Pod 有个 <code>emptyDir</code> 卷，容器将该卷挂载到了 <code>/usr/share/nginx/html</code>。</p>
<p>在 shell 中，在 <code>/usr/share/nginx/html</code> 目录创建一个 <code>index.html</code> 文件：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>root@shell-demo:/# <span style=color:#a2f>echo</span> Hello shell demo &gt; /usr/share/nginx/html/index.html
</code></pre></div>
<p>在 shell 中，向 nginx 服务器发送 GET 请求：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>root@shell-demo:/# apt-get update
root@shell-demo:/# apt-get install curl
root@shell-demo:/# curl localhost
</code></pre></div>
<p>输出结果显示了你在 <code>index.html</code> 中写入的文本。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>Hello shell demo
</code></pre></div>
<p>当用完 shell 后，输入 <code>exit</code> 退出。</p>
<h2 id=在容器中运行单个命令>在容器中运行单个命令</h2>
<p>在普通的命令窗口（而不是 shell）中，打印环境运行容器中的变量：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#a2f>exec</span> shell-demo env
</code></pre></div>
<p>实验运行其他命令。下面是一些示例：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#a2f>exec</span> shell-demo ps aux
kubectl <span style=color:#a2f>exec</span> shell-demo ls /
kubectl <span style=color:#a2f>exec</span> shell-demo cat /proc/1/mounts
</code></pre></div>
<h2 id=当-pod-包含多个容器时打开-shell>当 Pod 包含多个容器时打开 shell</h2>
<p>如果 Pod 有多个容器，<code>--container</code> 或者 <code>-c</code> 可以在 <code>kubectl exec</code> 命令中指定容器。
例如，您有个名为 my-pod 的容器，该 Pod 有两个容器分别为 main-app 和 healper-app。
下面的命令将会打开一个 shell 访问 main-app 容器。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#a2f>exec</span> -it my-pod --container main-app -- /bin/bash
</code></pre></div><h2 id=what-s-next>What's next</h2>
<ul>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands/#exec>kubectl exec</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-06bb252f25983de12f635c806d180d30>12.8 - 调试 Init 容器</h1>
<p>此页显示如何核查与 Init 容器执行相关的问题。
下面的示例命令行将 Pod 称为 <code>&lt;pod-name></code>，而 Init 容器称为 <code>&lt;init-container-1></code> 和
<code>&lt;init-container-2></code>。</p>
<h2 id=before-you-begin>Before you begin</h2>
<p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li>
</ul>
To check the version, enter <code>kubectl version</code>.
</p>
<ul>
<li>你应该熟悉 <a href=/zh/docs/concepts/workloads/pods/init-containers/>Init 容器</a>的基础知识。</li>
<li>你应该已经<a href=/zh/docs/tasks/configure-pod-container/configure-pod-initialization/#creating-a-pod-that-has-an-init-container/>配置好一个 Init 容器</a>。</li>
</ul>
<h2 id=检查-init-容器的状态>检查 Init 容器的状态</h2>
<p>显示你的 Pod 的状态：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod &lt;pod-name&gt;
</code></pre></div>
<p>例如，状态 <code>Init:1/2</code> 表明两个 Init 容器中的一个已经成功完成：</p>
<pre><code>NAME         READY     STATUS     RESTARTS   AGE
&lt;pod-name&gt;   0/1       Init:1/2   0          7s
</code></pre>
<p>更多状态值及其含义请参考<a href=#understanding-pod-status>理解 Pod 的状态</a>。</p>
<h2 id=getting-details-about-init-containers>获取 Init 容器详情 </h2>
<p>查看 Init 容器运行的更多详情：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe pod &lt;pod-name&gt;
</code></pre></div>
<p>例如，对于包含两个 Init 容器的 Pod 可能显示如下信息：</p>
<pre><code>Init Containers:
  &lt;init-container-1&gt;:
    Container ID:    ...
    ...
    State:           Terminated
      Reason:        Completed
      Exit Code:     0
      Started:       ...
      Finished:      ...
    Ready:           True
    Restart Count:   0
    ...
  &lt;init-container-2&gt;:
    Container ID:    ...
    ...
    State:           Waiting
      Reason:        CrashLoopBackOff
    Last State:      Terminated
      Reason:        Error
      Exit Code:     1
      Started:       ...
      Finished:      ...
    Ready:           False
    Restart Count:   3
    ...
</code></pre>
<p>你还可以通过编程方式读取 Pod Spec 上的 <code>status.initContainerStatuses</code> 字段，了解 Init 容器的状态：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod nginx --template <span style=color:#b44>&#39;{{.status.initContainerStatuses}}&#39;</span>
</code></pre></div>
<p>此命令将返回与原始 JSON 中相同的信息.</p>
<h2 id=accessing-logs-from-init-containers>通过 Init 容器访问日志 </h2>
<p>与 Pod 名称一起传递 Init 容器名称，以访问容器的日志。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl logs &lt;pod-name&gt; -c &lt;init-container-2&gt;
</code></pre></div>
<p>运行 Shell 脚本的 Init 容器在执行 Shell 脚本时输出命令本身。
例如，你可以在 Bash 中通过在脚本的开头运行 <code>set -x</code> 来实现。</p>
<h2 id=understanding-pod-status>理解 Pod 的状态 </h2>
<p>以 <code>Init:</code> 开头的 Pod 状态汇总了 Init 容器执行的状态。
下表介绍调试 Init 容器时可能看到的一些状态值示例。</p>
<table>
<thead>
<tr>
<th>状态</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Init:N/M</code></td>
<td>Pod 包含 <code>M</code> 个 Init 容器，其中 <code>N</code> 个已经运行完成。</td>
</tr>
<tr>
<td><code>Init:Error</code></td>
<td>Init 容器已执行失败。</td>
</tr>
<tr>
<td><code>Init:CrashLoopBackOff</code></td>
<td>Init 容器执行总是失败。</td>
</tr>
<tr>
<td><code>Pending</code></td>
<td>Pod 还没有开始执行 Init 容器。</td>
</tr>
<tr>
<td><code>PodInitializing</code> or <code>Running</code></td>
<td>Pod 已经完成执行 Init 容器。</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-858517cd46a1b5a1fd2e650edd785cea>12.9 - 调试 Pods 和 ReplicationControllers</h1>
<p>此页面展示如何调试 Pod 和 ReplicationController。</p>
<h2 id=before-you-begin>Before you begin</h2>
<p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li>
</ul>
To check the version, enter <code>kubectl version</code>.
</p>
<ul>
<li>你应该先熟悉 <a href=/zh/docs/concepts/workloads/pods/>Pods</a> 和
<a href=/zh/docs/concepts/workloads/pods/pod-lifecycle/>Pod 生命周期</a> 的基础概念。</li>
</ul>
<h2 id=debugging-pods>调试 Pod </h2>
<p>调试一个 pod 的第一步是观察它。使用下面的命令检查 Pod 的当前状态和最近事件：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe pods <span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>POD_NAME</span><span style=color:#b68;font-weight:700>}</span>
</code></pre></div>
<p>看看 Pod 中的容器的状态。它们都是 <code>Running</code> 吗？最近有重启吗？</p>
<p>根据 Pod 的状态继续调试。</p>
<h3 id=我的-pod-停滞在-pending-状态>我的 Pod 停滞在 Pending 状态</h3>
<p>如果 Pod 被卡在 <code>Pending</code> 状态，就意味着它不能调度在某个节点上。一般来说，这是因为某种类型的资源不足而
导致无法调度。 查看上面的命令 <code>kubectl describe ...</code> 的输出。调度器的消息中应该会包含无法调度 Pod 的原因。
原因包括：</p>
<h4 id=资源不足>资源不足</h4>
<p>你可能已经耗尽了集群中供应的 CPU 或内存。在这个情况下你可以尝试几件事情：</p>
<ul>
<li>
<p>向集群中添加节点。</p>
</li>
<li>
<p><a href=/zh/docs/concepts/workloads/pods/pod-lifecycle/#pod-termination>终止不需要的 Pod</a>
为 Pending 状态的 Pod 提供空间。</p>
</li>
<li>
<p>检查该 Pod 是否不大于你的节点。例如，如果全部节点具有 <code>cpu:1</code> 容量，那么具有
请求为 <code>cpu: 1.1</code> 的 Pod 永远不会被调度。</p>
<p>你可以使用 <code>kubectl get nodes -o &lt;format></code> 命令来检查节点容量。
下面是一些能够提取必要信息的命令示例：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get nodes -o yaml | egrep <span style=color:#b44>&#39;\sname:|cpu:|memory:&#39;</span>
kubectl get nodes -o json | jq <span style=color:#b44>&#39;.items[] | {name: .metadata.name, cap: .status.capacity}&#39;</span>
</code></pre></div></li>
</ul>
<p>可以考虑配置<a href=/zh/docs/concepts/policy/resource-quotas/>资源配额</a> 来限制可耗用的资源总量。
如果与命名空间一起使用，它可以防止一个团队吞噬所有的资源。</p>
<h4 id=使用-hostport>使用 hostPort</h4>
<p>当你将一个 Pod 绑定到某 <code>hostPort</code> 时，这个 Pod 能被调度的位置数量有限。
在大多数情况下，<code>hostPort</code> 是不必要的; 尝试使用服务对象来暴露你的 Pod。
如果你需要 <code>hostPort</code>，那么你可以调度的 Pod 数量不能超过集群的节点个数。</p>
<h3 id=我的-pod-一直在-waiting>我的 Pod 一直在 Waiting</h3>
<p>如果 Pod 一直停滞在 <code>Waiting</code> 状态，那么它已被调度在某个工作节点，但它不能在该机器上运行。
再次，来自 <code>kubectl describe ...</code> 的内容应该是可以是很有用的。
最常见的原因 <code>Waiting</code> 的 Pod 是无法拉取镜像。有三件事要检查：</p>
<ul>
<li>确保你的镜像的名称正确。</li>
<li>你是否将镜像推送到存储库？</li>
<li>尝试手动拉取镜像，看能否拉取。例如，如果你在 PC 上使用 Docker，运行 <code>docker pull &lt;image></code>。</li>
</ul>
<h3 id=我的-pod-一直-crashing-或者其他不健康状态>我的 Pod 一直 Crashing 或者其他不健康状态</h3>
<p>一旦 Pod 已经被调度，就可以依据
<a href=/zh/docs/tasks/debug/debug-application/debug-running-pod/>调试运行中的 Pod</a>
展开进一步的调试工作。</p>
<h2 id=调试-replication-controller>调试 Replication Controller</h2>
<p>Replication Controller 相当简单。它们或者能或者不能创建 Pod。如果它们无法创建 Pod，
请参考<a href=#debugging_pods>上面的说明</a> 来调试你的 Pod。</p>
<p>你也可以使用 <code>kubectl describe rc ${CONTROLLER_NAME}</code> 来检查和副本控制器有关的事件。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-f79645981e310858111bd5673614cab6>12.10 - 调试 Service</h1>
<p>对于新安装的 Kubernetes，经常出现的问题是 Service 无法正常运行。 你已经通过
Deployment（或其他工作负载控制器）运行了 Pod，并创建 Service ，但是
当你尝试访问它时，没有任何响应。此文档有望对你有所帮助并找出问题所在。</p>
<h2 id=在-pod-中运行命令>在 Pod 中运行命令</h2>
<p>对于这里的许多步骤，你可能希望知道运行在集群中的 Pod 看起来是什么样的。
最简单的方法是运行一个交互式的 busybox Pod：</p>
<pre><code class=language-none data-lang=none>kubectl run -it --rm --restart=Never busybox --image=gcr.io/google-containers/busybox sh
</code></pre>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 如果没有看到命令提示符，请按回车。
</div>
<p>如果你已经有了你想使用的正在运行的 Pod，则可以运行以下命令去进入：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#a2f>exec</span> &lt;POD-NAME&gt; -c &lt;CONTAINER-NAME&gt; -- &lt;COMMAND&gt;
</code></pre></div>
<h2 id=setup>设置 </h2>
<p>为了完成本次实践的任务，我们先运行几个 Pod。
由于你可能正在调试自己的 Service，所以，你可以使用自己的信息进行替换，
或者你也可以跟着教程并开始下面的步骤来获得第二个数据点。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl  create deployment hostnames --image<span style=color:#666>=</span>k8s.gcr.io/serve_hostname 
</code></pre></div><pre><code class=language-none data-lang=none>deployment.apps/hostnames created
</code></pre>
<p><code>kubectl</code> 命令将打印创建或变更的资源的类型和名称，它们可以在后续命令中使用。
让我们将这个 deployment 的副本数扩至 3。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl scale deployment hostnames --replicas<span style=color:#666>=</span><span style=color:#666>3</span>
</code></pre></div><pre><code class=language-none data-lang=none>deployment.apps/hostnames scaled
</code></pre>
<p>请注意这与你使用以下 YAML 方式启动 Deployment 类似：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>hostnames<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>hostnames<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>hostnames<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>hostnames<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>hostnames<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/serve_hostname<span style=color:#bbb>
</span></code></pre></div>
<p>"app" 标签是 <code>kubectl create deployment</code> 根据 Deployment 名称自动设置的。</p>
<p>确认你的 Pods 是运行状态:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>hostnames
</code></pre></div><pre><code class=language-none data-lang=none>NAME                        READY     STATUS    RESTARTS   AGE
hostnames-632524106-bbpiw   1/1       Running   0          2m
hostnames-632524106-ly40y   1/1       Running   0          2m
hostnames-632524106-tlaok   1/1       Running   0          2m
</code></pre>
<p>你还可以确认你的 Pod 是否正在提供服务。你可以获取 Pod IP 地址列表并直接对其进行测试。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>hostnames <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>    -o go-template<span style=color:#666>=</span><span style=color:#b44>&#39;{{range .items}}{{.status.podIP}}{{&#34;\n&#34;}}{{end}}&#39;</span>
</code></pre></div><pre><code class=language-none data-lang=none>10.244.0.5
10.244.0.6
10.244.0.7
</code></pre>
<p>用于本教程的示例容器通过 HTTP 在端口 9376 上提供其自己的主机名，
但是如果要调试自己的应用程序，则需要使用你的 Pod 正在侦听的端口号。</p>
<p>在 Pod 内运行：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#a2f;font-weight:700>for</span> ep in 10.244.0.5:9376 10.244.0.6:9376 10.244.0.7:9376; <span style=color:#a2f;font-weight:700>do</span>
    wget -qO- <span style=color:#b8860b>$ep</span>
<span style=color:#a2f;font-weight:700>done</span>
</code></pre></div>
<p>输出类似这样：</p>
<pre><code>hostnames-632524106-bbpiw
hostnames-632524106-ly40y
hostnames-632524106-tlaok
</code></pre>
<p>如果此时你没有收到期望的响应，则你的 Pod 状态可能不健康，或者可能没有在你认为正确的端口上进行监听。
你可能会发现 <code>kubectl logs</code> 命令对于查看正在发生的事情很有用，
或者你可能需要通过<code>kubectl exec</code> 直接进入 Pod 中并从那里进行调试。</p>
<p>假设到目前为止一切都已按计划进行，那么你可以开始调查为何你的 Service 无法正常工作。</p>
<h2 id=service-是否存在>Service 是否存在？</h2>
<p>细心的读者会注意到我们实际上尚未创建 Service -这是有意而为之。 这一步有时会被遗忘，这是首先要检查的步骤。</p>
<p>那么，如果我尝试访问不存在的 Service 会怎样？ 假设你有另一个 Pod 通过名称匹配到 Service ，你将得到类似结果：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>wget -O- hostnames
</code></pre></div><pre><code class=language-none data-lang=none>Resolving hostnames (hostnames)... failed: Name or service not known.
wget: unable to resolve host address 'hostnames'
</code></pre>
<p>首先要检查的是该 Service 是否真实存在：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get svc hostnames
</code></pre></div><pre><code class=language-none data-lang=none>No resources found.
Error from server (NotFound): services &quot;hostnames&quot; not found
</code></pre>
<p>让我们创建 Service。 和以前一样，在这次实践中 - 你可以在此处使用自己的 Service 的内容。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl expose deployment hostnames --port<span style=color:#666>=</span><span style=color:#666>80</span> --target-port<span style=color:#666>=</span><span style=color:#666>9376</span>
</code></pre></div><pre><code class=language-none data-lang=none>service/hostnames exposed
</code></pre>
<p>重新运行查询命令：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get svc hostnames
</code></pre></div><pre><code class=language-none data-lang=none>NAME        TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)   AGE
hostnames   ClusterIP   10.0.1.175   &lt;none&gt;        80/TCP    5s
</code></pre>
<p>现在你知道了 Service 确实存在。</p>
<p>同前，此步骤效果与通过 YAML 方式启动 'Service' 一样：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>hostnames<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>hostnames<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>9376</span><span style=color:#bbb>
</span></code></pre></div>
<p>为了突出配置范围的完整性，你在此处创建的 Service 使用的端口号与 Pods 不同。
对于许多真实的 Service，这些值可以是相同的。</p>
<h2 id=是否存在影响目标-pod-的网络策略入站规则>是否存在影响目标 Pod 的网络策略入站规则？</h2>
<p>如果你部署了任何可能影响到 <code>hostnames-*</code> Pod 的传入流量的网络策略入站规则，
则需要对其进行检查。</p>
<p>详细信息，请参阅<a href=/zh/docs/concepts/services-networking/network-policies/>网络策略</a>。</p>
<h2 id=service-是否可通过-dns-名字访问>Service 是否可通过 DNS 名字访问？</h2>
<p>通常客户端通过 DNS 名称来匹配到 Service。</p>
<p>从相同命名空间下的 Pod 中运行以下命令：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>nslookup hostnames
</code></pre></div><pre><code class=language-none data-lang=none>Address 1: 10.0.0.10 kube-dns.kube-system.svc.cluster.local

Name:      hostnames
Address 1: 10.0.1.175 hostnames.default.svc.cluster.local
</code></pre>
<p>如果失败，那么你的 Pod 和 Service 可能位于不同的命名空间中，
请尝试使用限定命名空间的名称（同样在 Pod 内运行）：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>nslookup hostnames.default
</code></pre></div><pre><code class=language-none data-lang=none>Address 1: 10.0.0.10 kube-dns.kube-system.svc.cluster.local

Name:      hostnames.default
Address 1: 10.0.1.175 hostnames.default.svc.cluster.local
</code></pre>
<p>如果成功，那么需要调整你的应用，使用跨命名空间的名称去访问它，
或者在相同的命名空间中运行应用和 Service。如果仍然失败，请尝试一个完全限定的名称：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>nslookup hostnames.default.svc.cluster.local
</code></pre></div><pre><code class=language-none data-lang=none>Address 1: 10.0.0.10 kube-dns.kube-system.svc.cluster.local

Name:      hostnames.default.svc.cluster.local
Address 1: 10.0.1.175 hostnames.default.svc.cluster.local
</code></pre>
<p>注意这里的后缀："default.svc.cluster.local"。"default" 是我们正在操作的命名空间。
"svc" 表示这是一个 Service。"cluster.local" 是你的集群域，在你自己的集群中可能会有所不同。</p>
<p>你也可以在集群中的节点上尝试此操作：</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 10.0.0.10 是集群的 DNS 服务 IP，你的可能有所不同。
</div>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>nslookup hostnames.default.svc.cluster.local 10.0.0.10
</code></pre></div><pre><code class=language-none data-lang=none>Server:         10.0.0.10
Address:        10.0.0.10#53

Name:   hostnames.default.svc.cluster.local
Address: 10.0.1.175
</code></pre>
<p>如果你能够使用完全限定的名称查找，但不能使用相对名称，则需要检查你 Pod 中的
<code>/etc/resolv.conf</code> 文件是否正确。在 Pod 中运行以下命令：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>cat /etc/resolv.conf
</code></pre></div>
<p>你应该可以看到类似这样的输出：</p>
<pre><code>nameserver 10.0.0.10
search default.svc.cluster.local svc.cluster.local cluster.local example.com
options ndots:5
</code></pre>
<p><code>nameserver</code> 行必须指示你的集群的 DNS Service，
它是通过 <code>--cluster-dns</code> 标志传递到 kubelet 的。</p>
<p><code>search</code> 行必须包含一个适当的后缀，以便查找 Service 名称。
在本例中，它查找本地命名空间（<code>default.svc.cluster.local</code>）中的服务和
所有命名空间（<code>svc.cluster.local</code>）中的服务，最后在集群（<code>cluster.local</code>）中查找
服务的名称。根据你自己的安装情况，可能会有额外的记录（最多 6 条）。
集群后缀是通过 <code>--cluster-domain</code> 标志传递给 <code>kubelet</code> 的。
本文中，我们假定后缀是 “cluster.local”。
你的集群配置可能不同，这种情况下，你应该在上面的所有命令中更改它。</p>
<p><code>options</code> 行必须设置足够高的 <code>ndots</code>，以便 DNS 客户端库考虑搜索路径。
在默认情况下，Kubernetes 将这个值设置为 5，这个值足够高，足以覆盖它生成的所有 DNS 名称。</p>
<h3 id=does-any-service-exist-in-dns>是否存在 Service 能通过 DNS 名称访问？</h3>
<p>如果上面的方式仍然失败，DNS 查找不到你需要的 Service ，你可以后退一步，
看看还有什么其它东西没有正常工作。
Kubernetes 主 Service 应该一直是工作的。在 Pod 中运行如下命令：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>nslookup kubernetes.default
</code></pre></div><pre><code class=language-none data-lang=none>Server:    10.0.0.10
Address 1: 10.0.0.10 kube-dns.kube-system.svc.cluster.local

Name:      kubernetes.default
Address 1: 10.0.0.1 kubernetes.default.svc.cluster.local
</code></pre>
<p>如果失败，你可能需要转到本文的 <a href=#is-the-kube-proxy-working>kube-proxy</a> 节，
或者甚至回到文档的顶部重新开始，但不是调试你自己的 Service ，而是调试 DNS Service。</p>
<h3 id=service-能够通过-ip-访问么>Service 能够通过 IP 访问么？</h3>
<p>假设你已经确认 DNS 工作正常，那么接下来要测试的是你的 Service 能否通过它的 IP 正常访问。
从集群中的一个 Pod，尝试访问 Service 的 IP（从上面的 <code>kubectl get</code> 命令获取）。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#a2f;font-weight:700>for</span> i in <span style=color:#a2f;font-weight:700>$(</span>seq <span style=color:#666>1</span> 3<span style=color:#a2f;font-weight:700>)</span>; <span style=color:#a2f;font-weight:700>do</span> 
    wget -qO- 10.0.1.175:80
<span style=color:#a2f;font-weight:700>done</span>
</code></pre></div>
<p>输出应该类似这样：</p>
<pre><code>hostnames-632524106-bbpiw
hostnames-632524106-ly40y
hostnames-632524106-tlaok
</code></pre>
<p>如果 Service 状态是正常的，你应该得到正确的响应。如果没有，有很多可能出错的地方，请继续阅读。</p>
<h2 id=service-的配置是否正确>Service 的配置是否正确？</h2>
<p>这听起来可能很愚蠢，但你应该两次甚至三次检查你的 Service 配置是否正确，并且与你的 Pod 匹配。
查看你的 Service 配置并验证它：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get service hostnames -o json
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
    <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;Service&#34;</span>,
    <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;v1&#34;</span>,
    <span style=color:green;font-weight:700>&#34;metadata&#34;</span>: {
        <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;hostnames&#34;</span>,
        <span style=color:green;font-weight:700>&#34;namespace&#34;</span>: <span style=color:#b44>&#34;default&#34;</span>,
        <span style=color:green;font-weight:700>&#34;uid&#34;</span>: <span style=color:#b44>&#34;428c8b6c-24bc-11e5-936d-42010af0a9bc&#34;</span>,
        <span style=color:green;font-weight:700>&#34;resourceVersion&#34;</span>: <span style=color:#b44>&#34;347189&#34;</span>,
        <span style=color:green;font-weight:700>&#34;creationTimestamp&#34;</span>: <span style=color:#b44>&#34;2015-07-07T15:24:29Z&#34;</span>,
        <span style=color:green;font-weight:700>&#34;labels&#34;</span>: {
            <span style=color:green;font-weight:700>&#34;app&#34;</span>: <span style=color:#b44>&#34;hostnames&#34;</span>
        }
    },
    <span style=color:green;font-weight:700>&#34;spec&#34;</span>: {
        <span style=color:green;font-weight:700>&#34;ports&#34;</span>: [
            {
                <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;default&#34;</span>,
                <span style=color:green;font-weight:700>&#34;protocol&#34;</span>: <span style=color:#b44>&#34;TCP&#34;</span>,
                <span style=color:green;font-weight:700>&#34;port&#34;</span>: <span style=color:#666>80</span>,
                <span style=color:green;font-weight:700>&#34;targetPort&#34;</span>: <span style=color:#666>9376</span>,
                <span style=color:green;font-weight:700>&#34;nodePort&#34;</span>: <span style=color:#666>0</span>
            }
        ],
        <span style=color:green;font-weight:700>&#34;selector&#34;</span>: {
            <span style=color:green;font-weight:700>&#34;app&#34;</span>: <span style=color:#b44>&#34;hostnames&#34;</span>
        },
        <span style=color:green;font-weight:700>&#34;clusterIP&#34;</span>: <span style=color:#b44>&#34;10.0.1.175&#34;</span>,
        <span style=color:green;font-weight:700>&#34;type&#34;</span>: <span style=color:#b44>&#34;ClusterIP&#34;</span>,
        <span style=color:green;font-weight:700>&#34;sessionAffinity&#34;</span>: <span style=color:#b44>&#34;None&#34;</span>
    },
    <span style=color:green;font-weight:700>&#34;status&#34;</span>: {
        <span style=color:green;font-weight:700>&#34;loadBalancer&#34;</span>: {}
    }
}
</code></pre></div>
<ul>
<li>你想要访问的 Service 端口是否在 <code>spec.ports[]</code> 中列出？</li>
<li><code>targetPort</code> 对你的 Pod 来说正确吗（许多 Pod 使用与 Service 不同的端口）？</li>
<li>如果你想使用数值型端口，那么它的类型是一个数值（9376）还是字符串 “9376”？</li>
<li>如果你想使用名称型端口，那么你的 Pod 是否暴露了一个同名端口？</li>
<li>端口的 <code>protocol</code> 和 Pod 的是否对应？</li>
</ul>
<h2 id=service-有-endpoints-吗>Service 有 Endpoints 吗？</h2>
<p>如果你已经走到了这一步，你已经确认你的 Service 被正确定义，并能通过 DNS 解析。
现在，让我们检查一下，你运行的 Pod 确实是被 Service 选中的。</p>
<p>早些时候，我们已经看到 Pod 是运行状态。我们可以再检查一下：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>hostnames
</code></pre></div><pre><code class=language-none data-lang=none>NAME                        READY     STATUS    RESTARTS   AGE
hostnames-632524106-bbpiw   1/1       Running   0          1h
hostnames-632524106-ly40y   1/1       Running   0          1h
hostnames-632524106-tlaok   1/1       Running   0          1h
</code></pre>
<p><code>-l app=hostnames</code> 参数是在 Service 上配置的标签选择器。</p>
<p>"AGE" 列表明这些 Pod 已经启动一个小时了，这意味着它们运行良好，而未崩溃。</p>
<p>"RESTARTS" 列表明 Pod 没有经常崩溃或重启。经常性崩溃可能导致间歇性连接问题。
如果重启次数过大，通过<a href=/zh/docs/tasks/debug-application-cluster/debug-application/#debugging-pods>调试 pod</a>
了解相关技术。</p>
<p>在 Kubernetes 系统中有一个控制回路，它评估每个 Service 的选择算符，并将结果保存到 Endpoints 对象中。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get endpoints hostnames
</code></pre></div><pre><code>NAME        ENDPOINTS
hostnames   10.244.0.5:9376,10.244.0.6:9376,10.244.0.7:9376
</code></pre>
<p>这证实 Endpoints 控制器已经为你的 Service 找到了正确的 Pods。
如果 <code>ENDPOINTS</code> 列的值为 <code>&lt;none></code>，则应检查 Service 的 <code>spec.selector</code> 字段，
以及你实际想选择的 Pod 的 <code>metadata.labels</code> 的值。
常见的错误是输入错误或其他错误，例如 Service 想选择 <code>app=hostnames</code>，但是
Deployment 指定的是 <code>run=hostnames</code>。在 1.18之前的版本中 <code>kubectl run</code>
也可以被用来创建 Deployment。</p>
<h2 id=pod-正常工作吗>Pod 正常工作吗？</h2>
<p>至此，你知道你的 Service 已存在，并且已匹配到你的Pod。在本实验的开始，你已经检查了 Pod 本身。
让我们再次检查 Pod 是否确实在工作 - 你可以绕过 Service 机制并直接转到 Pod，如上面的 Endpoint 所示。</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 这些命令使用的是 Pod 端口（9376），而不是 Service 端口（80）。
</div>
<p>在 Pod 中运行：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#a2f;font-weight:700>for</span> ep in 10.244.0.5:9376 10.244.0.6:9376 10.244.0.7:9376; <span style=color:#a2f;font-weight:700>do</span>
    wget -qO- <span style=color:#b8860b>$ep</span>
<span style=color:#a2f;font-weight:700>done</span>
</code></pre></div>
<p>输出应该类似这样：</p>
<pre><code>hostnames-632524106-bbpiw
hostnames-632524106-ly40y
hostnames-632524106-tlaok
</code></pre>
<p>你希望 Endpoint 列表中的每个 Pod 都返回自己的主机名。
如果情况并非如此（或你自己的 Pod 的正确行为是什么），你应调查发生了什么事情。</p>
<h2 id=kube-proxy-正常工作吗>kube-proxy 正常工作吗？</h2>
<p>如果你到达这里，则说明你的 Service 正在运行，拥有 Endpoints，Pod 真正在提供服务。
此时，整个 Service 代理机制是可疑的。让我们一步一步地确认它没问题。</p>
<p>Service 的默认实现（在大多数集群上应用的）是 kube-proxy。
这是一个在每个节点上运行的程序，负责配置用于提供 Service 抽象的机制之一。
如果你的集群不使用 kube-proxy，则以下各节将不适用，你将必须检查你正在使用的 Service 的实现方式。</p>
<h3 id=kube-proxy-正常运行吗>kube-proxy 正常运行吗？</h3>
<p>确认 <code>kube-proxy</code> 正在节点上运行。 在节点上直接运行，你将会得到类似以下的输出：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>ps auxw | grep kube-proxy
</code></pre></div><pre><code class=language-none data-lang=none>root  4194  0.4  0.1 101864 17696 ?    Sl Jul04  25:43 /usr/local/bin/kube-proxy --master=https://kubernetes-master --kubeconfig=/var/lib/kube-proxy/kubeconfig --v=2
</code></pre>
<p>下一步，确认它并没有出现明显的失败，比如连接主节点失败。要做到这一点，你必须查看日志。
访问日志的方式取决于你节点的操作系统。
在某些操作系统上日志是一个文件，如 /var/log/messages kube-proxy.log，
而其他操作系统使用 <code>journalctl</code> 访问日志。你应该看到输出类似于：</p>
<pre><code class=language-none data-lang=none>I1027 22:14:53.995134    5063 server.go:200] Running in resource-only container &quot;/kube-proxy&quot;
I1027 22:14:53.998163    5063 server.go:247] Using iptables Proxier.
I1027 22:14:53.999055    5063 server.go:255] Tearing down userspace rules. Errors here are acceptable.
I1027 22:14:54.038140    5063 proxier.go:352] Setting endpoints for &quot;kube-system/kube-dns:dns-tcp&quot; to [10.244.1.3:53]
I1027 22:14:54.038164    5063 proxier.go:352] Setting endpoints for &quot;kube-system/kube-dns:dns&quot; to [10.244.1.3:53]
I1027 22:14:54.038209    5063 proxier.go:352] Setting endpoints for &quot;default/kubernetes:https&quot; to [10.240.0.2:443]
I1027 22:14:54.038238    5063 proxier.go:429] Not syncing iptables until Services and Endpoints have been received from master
I1027 22:14:54.040048    5063 proxier.go:294] Adding new service &quot;default/kubernetes:https&quot; at 10.0.0.1:443/TCP
I1027 22:14:54.040154    5063 proxier.go:294] Adding new service &quot;kube-system/kube-dns:dns&quot; at 10.0.0.10:53/UDP
I1027 22:14:54.040223    5063 proxier.go:294] Adding new service &quot;kube-system/kube-dns:dns-tcp&quot; at 10.0.0.10:53/TCP
</code></pre>
<p>如果你看到有关无法连接主节点的错误消息，则应再次检查节点配置和安装步骤。</p>
<p><code>kube-proxy</code> 无法正确运行的可能原因之一是找不到所需的 <code>conntrack</code> 二进制文件。
在一些 Linux 系统上，这也是可能发生的，这取决于你如何安装集群，
例如，你是手动开始一步步安装 Kubernetes。如果是这样的话，你需要手动安装
<code>conntrack</code> 包（例如，在 Ubuntu 上使用 <code>sudo apt install conntrack</code>），然后重试。</p>
<p>Kube-proxy 可以以若干模式之一运行。在上述日志中，<code>Using iptables Proxier</code>
行表示 kube-proxy 在 "iptables" 模式下运行。
最常见的另一种模式是 "ipvs"。先前的 "userspace" 模式已经被这些所代替。</p>
<h4 id=iptables-模式>Iptables 模式</h4>
<p>在 "iptables" 模式中, 你应该可以在节点上看到如下输出:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>iptables-save | grep hostnames
</code></pre></div><pre><code class=language-none data-lang=none>-A KUBE-SEP-57KPRZ3JQVENLNBR -s 10.244.3.6/32 -m comment --comment &quot;default/hostnames:&quot; -j MARK --set-xmark 0x00004000/0x00004000
-A KUBE-SEP-57KPRZ3JQVENLNBR -p tcp -m comment --comment &quot;default/hostnames:&quot; -m tcp -j DNAT --to-destination 10.244.3.6:9376
-A KUBE-SEP-WNBA2IHDGP2BOBGZ -s 10.244.1.7/32 -m comment --comment &quot;default/hostnames:&quot; -j MARK --set-xmark 0x00004000/0x00004000
-A KUBE-SEP-WNBA2IHDGP2BOBGZ -p tcp -m comment --comment &quot;default/hostnames:&quot; -m tcp -j DNAT --to-destination 10.244.1.7:9376
-A KUBE-SEP-X3P2623AGDH6CDF3 -s 10.244.2.3/32 -m comment --comment &quot;default/hostnames:&quot; -j MARK --set-xmark 0x00004000/0x00004000
-A KUBE-SEP-X3P2623AGDH6CDF3 -p tcp -m comment --comment &quot;default/hostnames:&quot; -m tcp -j DNAT --to-destination 10.244.2.3:9376
-A KUBE-SERVICES -d 10.0.1.175/32 -p tcp -m comment --comment &quot;default/hostnames: cluster IP&quot; -m tcp --dport 80 -j KUBE-SVC-NWV5X2332I4OT4T3
-A KUBE-SVC-NWV5X2332I4OT4T3 -m comment --comment &quot;default/hostnames:&quot; -m statistic --mode random --probability 0.33332999982 -j KUBE-SEP-WNBA2IHDGP2BOBGZ
-A KUBE-SVC-NWV5X2332I4OT4T3 -m comment --comment &quot;default/hostnames:&quot; -m statistic --mode random --probability 0.50000000000 -j KUBE-SEP-X3P2623AGDH6CDF3
-A KUBE-SVC-NWV5X2332I4OT4T3 -m comment --comment &quot;default/hostnames:&quot; -j KUBE-SEP-57KPRZ3JQVENLNBR
</code></pre>
<p>对于每个 Service 的每个端口，应有 1 条 <code>KUBE-SERVICES</code> 规则、一个 <code>KUBE-SVC-&lt;hash></code> 链。
对于每个 Pod 末端，在那个 <code>KUBE-SVC-&lt;hash></code> 链中应该有一些规则与之对应，还应该
有一个 <code>KUBE-SEP-&lt;hash></code> 链与之对应，其中包含为数不多的几条规则。
实际的规则数量可能会根据你实际的配置（包括 NodePort 和 LoadBalancer 服务）有所不同。</p>
<h4 id=ipvs-模式>IPVS 模式</h4>
<p>在 "ipvs" 模式中, 你应该在节点下看到如下输出：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>ipvsadm -ln
</code></pre></div><pre><code class=language-none data-lang=none>Prot LocalAddress:Port Scheduler Flags
  -&gt; RemoteAddress:Port           Forward Weight ActiveConn InActConn
...
TCP  10.0.1.175:80 rr
  -&gt; 10.244.0.5:9376               Masq    1      0          0
  -&gt; 10.244.0.6:9376               Masq    1      0          0
  -&gt; 10.244.0.7:9376               Masq    1      0          0
...
</code></pre>
<p>对于每个 Service 的每个端口，还有 NodePort，External IP 和 LoadBalancer 类型服务
的 IP，kube-proxy 将创建一个虚拟服务器。
对于每个 Pod 末端，它将创建相应的真实服务器。
在此示例中，服务主机名（<code>10.0.1.175:80</code>）拥有 3 个末端（<code>10.244.0.5:9376</code>、
<code>10.244.0.6:9376</code> 和 <code>10.244.0.7:9376</code>）。</p>
<h4 id=userspace-模式>Userspace 模式</h4>
<p>在极少数情况下，你可能会用到 "userspace" 模式。在你的节点上运行：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>iptables-save | grep hostnames
</code></pre></div><pre><code class=language-none data-lang=none>-A KUBE-PORTALS-CONTAINER -d 10.0.1.175/32 -p tcp -m comment --comment &quot;default/hostnames:default&quot; -m tcp --dport 80 -j REDIRECT --to-ports 48577
-A KUBE-PORTALS-HOST -d 10.0.1.175/32 -p tcp -m comment --comment &quot;default/hostnames:default&quot; -m tcp --dport 80 -j DNAT --to-destination 10.240.115.247:48577
</code></pre>
<p>对于 Service （本例中只有一个）的每个端口，应当有 2 条规则：
一条 "KUBE-PORTALS-CONTAINER" 和一条 "KUBE-PORTALS-HOST" 规则。</p>
<p>几乎没有人应该再使用 "userspace" 模式，因此你在这里不会花更多的时间。</p>
<h3 id=kube-proxy-是否在运行>kube-proxy 是否在运行?</h3>
<p>假设你确实遇到上述情况之一，请重试从节点上通过 IP 访问你的 Service ：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>curl 10.0.1.175:80
</code></pre></div><pre><code class=language-none data-lang=none>hostnames-632524106-bbpiw
</code></pre>
<p>如果失败，并且你正在使用用户空间代理，则可以尝试直接访问代理。
如果你使用的是 iptables 代理，请跳过本节。</p>
<p>回顾上面的 <code>iptables-save</code> 输出，并提取 <code>kube-proxy</code> 为你的 Service 所使用的端口号。
在上面的例子中，端口号是 “48577”。现在试着连接它：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>curl localhost:48577
</code></pre></div><pre><code class=language-none data-lang=none>hostnames-632524106-tlaok
</code></pre>
<p>如果这步操作仍然失败，请查看 <code>kube-proxy</code> 日志中的特定行，如：</p>
<pre><code class=language-none data-lang=none>Setting endpoints for default/hostnames:default to [10.244.0.5:9376 10.244.0.6:9376 10.244.0.7:9376]
</code></pre>
<p>如果你没有看到这些，请尝试将 <code>-V</code> 标志设置为 4 并重新启动 <code>kube-proxy</code>，然后再查看日志。</p>
<h3 id=a-pod-fails-to-reach-itself-via-the-service-ip>边缘案例: Pod 无法通过 Service IP 连接到它本身 </h3>
<p>这听起来似乎不太可能，但是确实可能发生，并且应该可行。</p>
<p>如果网络没有为“发夹模式（Hairpin）”流量生成正确配置，
通常当 <code>kube-proxy</code> 以 <code>iptables</code> 模式运行，并且 Pod 与桥接网络连接时，就会发生这种情况。
<code>kubelet</code> 提供了 <code>hairpin-mode</code>
<a href=/zh/docs/reference/command-line-tools-reference/kubelet/>标志</a>。
如果 Service 的末端尝试访问自己的 Service VIP，则该端点可以把流量负载均衡回来到它们自身。
<code>hairpin-mode</code> 标志必须被设置为 <code>hairpin-veth</code> 或者 <code>promiscuous-bridge</code>。</p>
<p>诊断此类问题的常见步骤如下：</p>
<ul>
<li>
<p>确认 <code>hairpin-mode</code> 被设置为 <code>hairpin-veth</code> 或 <code>promiscuous-bridge</code>。
你应该可以看到下面这样。本例中 <code>hairpin-mode</code> 被设置为 <code>promiscuous-bridge</code>。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>ps auxw | grep kubelet
</code></pre></div><pre><code class=language-none data-lang=none>root      3392  1.1  0.8 186804 65208 ?        Sl   00:51  11:11 /usr/local/bin/kubelet --enable-debugging-handlers=true --config=/etc/kubernetes/manifests --allow-privileged=True --v=4 --cluster-dns=10.0.0.10 --cluster-domain=cluster.local --configure-cbr0=true --cgroup-root=/ --system-cgroups=/system --hairpin-mode=promiscuous-bridge --runtime-cgroups=/docker-daemon --kubelet-cgroups=/kubelet --babysit-daemons=true --max-pods=110 --serialize-image-pulls=false --outofdisk-transition-frequency=0
</code></pre></li>
</ul>
<ul>
<li>
<p>确认有效的 <code>hairpin-mode</code>。要做到这一点，你必须查看 kubelet 日志。
访问日志取决于节点的操作系统。在一些操作系统上，它是一个文件，如 /var/log/kubelet.log，
而其他操作系统则使用 <code>journalctl</code> 访问日志。请注意，由于兼容性，
有效的 <code>hairpin-mode</code> 可能不匹配 <code>--hairpin-mode</code> 标志。在 kubelet.log
中检查是否有带有关键字 <code>hairpin</code> 的日志行。应该有日志行指示有效的
<code>hairpin-mode</code>，就像下面这样。</p>
<pre><code class=language-none data-lang=none>I0629 00:51:43.648698    3252 kubelet.go:380] Hairpin mode set to &quot;promiscuous-bridge&quot;
</code></pre></li>
</ul>
<ul>
<li>
<p>如果有效的发夹模式是 <code>hairpin-veth</code>, 要保证 <code>Kubelet</code> 有操作节点上 <code>/sys</code> 的权限。
如果一切正常，你将会看到如下输出:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#a2f;font-weight:700>for</span> intf in /sys/devices/virtual/net/cbr0/brif/*; <span style=color:#a2f;font-weight:700>do</span> cat <span style=color:#b8860b>$intf</span>/hairpin_mode; <span style=color:#a2f;font-weight:700>done</span>
</code></pre></div><pre><code class=language-none data-lang=none>1
1
1
1
</code></pre></li>
</ul>
<ul>
<li>
<p>如果有效的发卡模式是 <code>promiscuous-bridge</code>, 要保证 <code>Kubelet</code> 有操作节点上
Linux 网桥的权限。如果 <code>cbr0</code> 桥正在被使用且被正确设置，你将会看到如下输出:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>ifconfig cbr0 |grep PROMISC
</code></pre></div><pre><code class=language-none data-lang=none>UP BROADCAST RUNNING PROMISC MULTICAST  MTU:1460  Metric:1
</code></pre></li>
</ul>
<ul>
<li>如果以上步骤都不能解决问题，请寻求帮助。</li>
</ul>
<h2 id=寻求帮助>寻求帮助</h2>
<p>如果你走到这一步，那么就真的是奇怪的事情发生了。你的 Service 正在运行，有 Endpoints 存在，
你的 Pods 也确实在提供服务。你的 DNS 正常，<code>iptables</code> 规则已经安装，<code>kube-proxy</code> 看起来也正常。
然而 Service 还是没有正常工作。这种情况下，请告诉我们，以便我们可以帮助调查！</p>
<p>通过
<a href=/zh/docs/tasks/debug-application-cluster/troubleshooting/#slack>Slack</a> 或者
<a href=https://discuss.kubernetes.io>Forum</a> 或者
<a href=https://github.com/kubernetes/kubernetes>GitHub</a>
联系我们。</p>
<h2 id=what-s-next>What's next</h2>
<p>访问<a href=/zh/docs/tasks/debug-application-cluster/troubleshooting/>故障排查文档</a> 获取更多信息。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-a070b1250ee142402d492b505a56ca83>12.11 - 调试StatefulSet</h1>
<p>此任务展示如何调试 StatefulSet。</p>
<h2 id=before-you-begin>Before you begin</h2>
<ul>
<li>你需要有一个 Kubernetes 集群，已配置好的 kubectl 命令行工具与你的集群进行通信。</li>
<li>你应该有一个运行中的 StatefulSet，以便用于调试。</li>
</ul>
<h2 id=debuggin-a-statefulset>调试 StatefulSet </h2>
<p>StatefulSet 在创建 Pod 时为其设置了 <code>app=myapp</code> 标签，列出仅属于某 StatefulSet
的所有 Pod 时，可以使用以下命令：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>myapp
</code></pre></div>
<p>如果你发现列出的任何 Pod 长时间处于 <code>Unknown</code> 或 <code>Terminating</code> 状态，请参阅
<a href=/zh/docs/tasks/run-application/delete-stateful-set/>删除 StatefulSet Pods</a>
了解如何处理它们的说明。
你可以参考<a href=/zh/docs/tasks/debug-application-cluster/debug-pod-replication-controller/>调试 Pods</a>
来调试 StatefulSet 中的各个 Pod。</p>
<h2 id=what-s-next>What's next</h2>
<ul>
<li>进一步了解如何<a href=/zh/docs/tasks/debug-application-cluster/debug-init-containers/>调试 Init 容器</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-c0ec963f381296ca26b839cdf0a6f242>12.12 - 调试运行中的 Pod</h1>
<p>本页解释如何在节点上调试运行中（或崩溃）的 Pod。</p>
<h2 id=before-you-begin>Before you begin</h2>
<ul>
<li>
<p>你的 <a class=glossary-tooltip title="Pod 表示您的集群上一组正在运行的容器。" data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a> 应该已经被调度并正在运行中，
如果你的 Pod 还没有运行，请参阅
<a href=/zh/docs/tasks/debug-application-cluster/debug-application/>应用问题排查</a>。</p>
</li>
<li>
<p>对于一些高级调试步骤，你应该知道 Pod 具体运行在哪个节点上，在该节点上有权限去运行一些命令。
你不需要任何访问权限就可以使用 <code>kubectl</code> 去运行一些标准调试步骤。</p>
</li>
</ul>
<h2 id=examine-pod-logs>检查 Pod 的日志</h2>
<p>首先，查看受到影响的容器的日志：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl logs <span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>POD_NAME</span><span style=color:#b68;font-weight:700>}</span> <span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>CONTAINER_NAME</span><span style=color:#b68;font-weight:700>}</span>
</code></pre></div><p>如果你的容器之前崩溃过，你可以通过下面命令访问之前容器的崩溃日志：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl logs --previous <span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>POD_NAME</span><span style=color:#b68;font-weight:700>}</span> <span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>CONTAINER_NAME</span><span style=color:#b68;font-weight:700>}</span>
</code></pre></div>
<h2 id=container-exec>使用容器 exec 进行调试</h2>
<p>如果 <a class=glossary-tooltip title=镜像是保存的容器实例，它打包了应用运行所需的一组软件。 data-toggle=tooltip data-placement=top href="/zh/docs/reference/glossary/?all=true#term-image" target=_blank aria-label=容器镜像>容器镜像</a> 包含调试程序，
比如从 Linux 和 Windows 操作系统基础镜像构建的镜像，你可以使用 <code>kubectl exec</code> 命令
在特定的容器中运行一些命令：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#a2f>exec</span> <span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>POD_NAME</span><span style=color:#b68;font-weight:700>}</span> -c <span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>CONTAINER_NAME</span><span style=color:#b68;font-weight:700>}</span> -- <span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>CMD</span><span style=color:#b68;font-weight:700>}</span> <span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>ARG1</span><span style=color:#b68;font-weight:700>}</span> <span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>ARG2</span><span style=color:#b68;font-weight:700>}</span> ... <span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>ARGN</span><span style=color:#b68;font-weight:700>}</span>
</code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> <code>-c ${CONTAINER_NAME}</code> 是可选择的。如果Pod中仅包含一个容器，就可以忽略它。
</div>
<p>例如，要查看正在运行的 Cassandra pod中的日志，可以运行：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#a2f>exec</span> cassandra -- cat /var/log/cassandra/system.log
</code></pre></div><p>你可以在 <code>kubectl exec</code> 命令后面加上 <code>-i</code> 和 <code>-t</code> 来运行一个连接到你的终端的 Shell，比如：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#a2f>exec</span> -it cassandra -- sh
</code></pre></div><p>若要了解更多内容，可查看<a href=/zh/docs/tasks/debug-application-cluster/get-shell-running-container/>获取正在运行容器的 Shell</a>。</p>
<h2 id=ephemeral-container>使用临时调试容器来进行调试</h2>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.23 [beta]</code>
</div>
<p>当由于容器崩溃或容器镜像不包含调试程序（例如<a href=https://github.com/GoogleContainerTools/distroless>无发行版镜像</a>等）
而导致 <code>kubectl exec</code> 无法运行时，<a class=glossary-tooltip title="您可以在 Pod 中临时运行的一种容器类型" data-toggle=tooltip data-placement=top href=/zh/docs/concepts/workloads/pods/ephemeral-containers/ target=_blank aria-label=临时容器>临时容器</a>对于排除交互式故障很有用。</p>
<h2 id=ephemeral-container-example>使用临时容器来调试的例子</h2>
<p>你可以使用 <code>kubectl debug</code> 命令来给正在运行中的 Pod 增加一个临时容器。
首先，像示例一样创建一个 pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl run ephemeral-demo --image<span style=color:#666>=</span>k8s.gcr.io/pause:3.1 --restart<span style=color:#666>=</span>Never
</code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 本节示例中使用 <code>pause</code> 容器镜像，因为它不包含调试程序，但是这个方法适用于所有容器镜像。
</div>
<p>如果你尝试使用 <code>kubectl exec</code> 来创建一个 shell，你将会看到一个错误，因为这个容器镜像中没有 shell。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#a2f>exec</span> -it ephemeral-demo -- sh
</code></pre></div><pre><code>OCI runtime exec failed: exec failed: container_linux.go:346: starting container process caused &quot;exec: \&quot;sh\&quot;: executable file not found in $PATH&quot;: unknown
</code></pre><p>你可以改为使用 <code>kubectl debug</code> 添加调试容器。
如果你指定 <code>-i</code> 或者 <code>--interactive</code> 参数，<code>kubectl</code> 将自动挂接到临时容器的控制台。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl debug -it ephemeral-demo --image<span style=color:#666>=</span>busybox:1.28 --target<span style=color:#666>=</span>ephemeral-demo
</code></pre></div><pre><code>Defaulting debug container name to debugger-8xzrl.
If you don't see a command prompt, try pressing enter.
/ #
</code></pre>
<p>此命令添加一个新的 busybox 容器并将其挂接到该容器。<code>--target</code> 参数指定另一个容器的进程命名空间。
这是必需的，因为 <code>kubectl run</code> 不能在它创建的pod中启用
<a href=/zh/docs/tasks/configure-pod-container/share-process-namespace/>共享进程命名空间</a>。</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> <a class=glossary-tooltip title=容器运行时是负责运行容器的软件。 data-toggle=tooltip data-placement=top href=/zh/docs/setup/production-environment/container-runtimes target=_blank aria-label=容器运行时>容器运行时</a>必须支持<code>--target</code>参数。
如果不支持，则临时容器可能不会启动，或者可能使用隔离的进程命名空间启动，
以便 <code>ps</code> 不显示其他容器内的进程。
</div>
<p>你可以使用 <code>kubectl describe</code> 查看新创建的临时容器的状态：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe pod ephemeral-demo
</code></pre></div><pre><code>...
Ephemeral Containers:
  debugger-8xzrl:
    Container ID:   docker://b888f9adfd15bd5739fefaa39e1df4dd3c617b9902082b1cfdc29c4028ffb2eb
    Image:          busybox
    Image ID:       docker-pullable://busybox@sha256:1828edd60c5efd34b2bf5dd3282ec0cc04d47b2ff9caa0b6d4f07a21d1c08084
    Port:           &lt;none&gt;
    Host Port:      &lt;none&gt;
    State:          Running
      Started:      Wed, 12 Feb 2020 14:25:42 +0100
    Ready:          False
    Restart Count:  0
    Environment:    &lt;none&gt;
    Mounts:         &lt;none&gt;
...
</code></pre>
<p>使用 <code>kubectl delete</code> 来移除已经结束掉的 Pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete pod ephemeral-demo
</code></pre></div>
<h2 id=通过-pod-副本调试>通过 Pod 副本调试</h2>
<p>有些时候 Pod 的配置参数使得在某些情况下很难执行故障排查。
例如，在容器镜像中不包含 shell 或者你的应用程序在启动时崩溃的情况下，
就不能通过运行 <code>kubectl exec</code> 来排查容器故障。
在这些情况下，你可以使用 <code>kubectl debug</code> 来创建 Pod 的副本，通过更改配置帮助调试。</p>
<h3 id=在添加新的容器时创建-pod-副本>在添加新的容器时创建 Pod 副本</h3>
<p>当应用程序正在运行但其表现不符合预期时，你会希望在 Pod 中添加额外的调试工具，
这时添加新容器是很有用的。</p>
<p>例如，应用的容器镜像是建立在 <code>busybox</code> 的基础上，
但是你需要 <code>busybox</code> 中并不包含的调试工具。
你可以使用 <code>kubectl run</code> 模拟这个场景:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl run myapp --image<span style=color:#666>=</span>busybox:1.28 --restart<span style=color:#666>=</span>Never -- sleep 1d
</code></pre></div>
<p>通过运行以下命令，建立 <code>myapp</code> 的一个名为 <code>myapp-debug</code> 的副本，
新增了一个用于调试的 Ubuntu 容器，</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl debug myapp -it --image<span style=color:#666>=</span>ubuntu --share-processes --copy-to<span style=color:#666>=</span>myapp-debug
</code></pre></div><pre><code>Defaulting debug container name to debugger-w7xmf.
If you don't see a command prompt, try pressing enter.
root@myapp-debug:/#
</code></pre>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> <ul>
<li>如果你没有使用 <code>--container</code> 指定新的容器名，<code>kubectl debug</code> 会自动生成的。</li>
<li>默认情况下，<code>-i</code> 标志使 <code>kubectl debug</code> 附加到新容器上。
你可以通过指定 <code>--attach=false</code> 来防止这种情况。
如果你的会话断开连接，你可以使用 <code>kubectl attach</code> 重新连接。</li>
<li><code>--share-processes</code> 允许在此 Pod 中的其他容器中查看该容器的进程。
参阅<a href=/zh/docs/tasks/configure-pod-container/share-process-namespace/>在 Pod 中的容器之间共享进程命名空间</a>
获取更多信息。</li>
</ul>
</div>
<p>不要忘了清理调试 Pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete pod myapp myapp-debug
</code></pre></div>
<h3 id=在改变-pod-命令时创建-pod-副本>在改变 Pod 命令时创建 Pod 副本</h3>
<p>有时更改容器的命令很有用，例如添加调试标志或因为应用崩溃。</p>
<p>为了模拟应用崩溃的场景，使用 <code>kubectl run</code> 命令创建一个立即退出的容器：</p>
<pre><code>kubectl run --image=busybox:1.28 myapp -- false
</code></pre>
<p>使用 <code>kubectl describe pod myapp</code> 命令，你可以看到容器崩溃了：</p>
<pre><code>Containers:
  myapp:
    Image:         busybox
    ...
    Args:
      false
    State:          Waiting
      Reason:       CrashLoopBackOff
    Last State:     Terminated
      Reason:       Error
      Exit Code:    1
</code></pre>
<p>你可以使用 <code>kubectl debug</code> 命令创建该 Pod 的一个副本，
在该副本中命令改变为交互式 shell：</p>
<pre><code>kubectl debug myapp -it --copy-to=myapp-debug --container=myapp -- sh
</code></pre><pre><code>If you don't see a command prompt, try pressing enter.
/ #
</code></pre>
<p>现在你有了一个可以执行类似检查文件系统路径或者手动运行容器命令的交互式 shell。</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> <ul>
<li>要更改指定容器的命令，你必须用 <code>--container</code> 命令指定容器的名字，
否则 <code>kubectl debug</code> 将建立一个新的容器运行你指定的命令。</li>
<li>默认情况下，标志 <code>-i</code> 使 <code>kubectl debug</code> 附加到容器。
你可通过指定 <code>--attach=false</code> 来防止这种情况。
如果你的断开连接，可以使用 <code>kubectl attach</code> 重新连接。</li>
</ul>
</div>
<p>不要忘了清理调试 Pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete pod myapp myapp-debug
</code></pre></div>
<h3 id=在更改容器镜像时创建-pod-副本>在更改容器镜像时创建 Pod 副本</h3>
<p>在某些情况下，你可能想从正常生产容器镜像中
把行为异常的 Pod 改变为包含调试版本或者附加应用的镜像。</p>
<p>下面的例子，用 <code>kubectl run</code>创建一个 Pod：</p>
<pre><code>kubectl run myapp --image=busybox:1.28 --restart=Never -- sleep 1d
</code></pre>
<p>现在可以使用 <code>kubectl debug</code> 创建一个副本
并改变容器镜像为 <code>ubuntu</code>：</p>
<pre><code>kubectl debug myapp --copy-to=myapp-debug --set-image=*=ubuntu
</code></pre>
<p><code>--set-image</code> 与 <code>container_name=image</code> 使用相同的 <code>kubectl set image</code> 语法。
<code>*=ubuntu</code> 表示把所有容器的镜像改为 <code>ubuntu</code>。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete pod myapp myapp-debug
</code></pre></div>
<h2 id=node-shell-session>在节点上通过 shell 来进行调试</h2>
<p>如果这些方法都不起作用，你可以找到运行 Pod 的节点，然后在节点上部署一个运行在宿主名字空间的特权 Pod。</p>
<p>你可以通过<code>kubectl debug</code> 在节点上创建一个交互式 shell：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl debug node/mynode -it --image<span style=color:#666>=</span>ubuntu
</code></pre></div><pre><code>Creating debugging pod node-debugger-mynode-pdx84 with container debugger on node mynode.
If you don't see a command prompt, try pressing enter.
root@ek8s:/#
</code></pre>
<p>当在节点上创建调试会话，注意以下要点：</p>
<ul>
<li><code>kubectl debug</code> 基于节点的名字自动生成新的 Pod 的名字。</li>
<li>新的调试容器运行在宿主命名空间里（IPC, 网络 还有PID命名空间）。</li>
<li>节点的根文件系统会被挂载在 <code>/host</code>。</li>
</ul>
<p>当你完成节点调试时，不要忘记清理调试 Pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete pod node-debugger-mynode-pdx84
</code></pre></div>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-9e6e1b706f11386fe2c4b4ffda1409e4>12.13 - 资源监控工具</h1>
<p>要扩展应用程序并提供可靠的服务，你需要了解应用程序在部署时的行为。
你可以通过检测容器检查 Kubernetes 集群中的应用程序性能，
<a href=/zh/docs/concepts/workloads/pods>Pods</a>,
<a href=/zh/docs/concepts/services-networking/service/>服务</a>
和整个集群的特征。
Kubernetes 在每个级别上提供有关应用程序资源使用情况的详细信息。
此信息使你可以评估应用程序的性能，以及在何处可以消除瓶颈以提高整体性能。</p>
<p>在 Kubernetes 中，应用程序监控不依赖单个监控解决方案。
在新集群上，你可以使用<a href=#resource-metrics-pipeline>资源度量</a>或
<a href=#full-metrics-pipeline>完整度量</a>管道来收集监视统计信息。</p>
<h2 id=resource-metrics-pipeline>资源度量管道 </h2>
<p>资源指标管道提供了一组与集群组件，例如
<a href=/zh/docs/tasks/run-application/horizontal-pod-autoscale/>Horizontal Pod Autoscaler</a>
控制器以及 <code>kubectl top</code> 实用程序相关的有限度量。
这些指标是由轻量级的、短期、内存存储的
<a href=https://github.com/kubernetes-sigs/metrics-server>metrics-server</a> 收集的，
通过 <code>metrics.k8s.io</code> 公开。</p>
<p>度量服务器发现集群中的所有节点，并且查询每个节点的
<a href=/zh/docs/reference/command-line-tools-reference/kubelet/>kubelet</a>
以获取 CPU 和内存使用情况。
Kubelet 充当 Kubernetes 主节点与节点之间的桥梁，管理机器上运行的 Pod 和容器。
kubelet 将每个 Pod 转换为其组成的容器，并在容器运行时通过容器运行时接口
获取各个容器使用情况统计信息。
kubelet 从集成的 cAdvisor 获取此信息，以进行旧式 Docker 集成。
然后，它通过 metrics-server Resource Metrics API 公开聚合的 pod 资源使用情况统计信息。
该 API 在 kubelet 的经过身份验证和只读的端口上的 <code>/metrics/resource/v1beta1</code> 中提供。</p>
<h2 id=full-metrics-pipeline>完整度量管道 </h2>
<p>一个完整度量管道可以让你访问更丰富的度量。
Kubernetes 还可以根据集群的当前状态，使用 Pod 水平自动扩缩器等机制，
通过自动调用扩展或调整集群来响应这些度量。
监控管道从 kubelet 获取度量值，然后通过适配器将它们公开给 Kubernetes，
方法是实现 <code>custom.metrics.k8s.io</code> 或 <code>external.metrics.k8s.io</code> API。</p>
<p><a href=https://prometheus.io>Prometheus</a> 是一个 CNCF 项目，可以原生监控 Kubernetes、
节点和 Prometheus 本身。
完整度量管道项目不属于 CNCF 的一部分，不在 Kubernetes 文档的范围之内。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-47290c80fb8b00accec6729f3da49734>12.14 - 集群故障排查</h1>
<p>本篇文档是介绍集群故障排查的；我们假设对于你碰到的问题，你已经排除了是由应用程序造成的。
对于应用的调试，请参阅
<a href=/zh/docs/tasks/debug-application-cluster/debug-application/>应用故障排查指南</a>。
你也可以访问<a href=/zh/docs/tasks/debug-application-cluster/troubleshooting/>故障排查</a>
来获取更多的信息。</p>
<h2 id=列举集群节点>列举集群节点</h2>
<p>调试的第一步是查看所有的节点是否都已正确注册。</p>
<p>运行</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get nodes
</code></pre></div>
<p>验证你所希望看见的所有节点都能够显示出来，并且都处于 <code>Ready</code> 状态。</p>
<p>为了了解你的集群的总体健康状况详情，你可以运行：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl cluster-info dump
</code></pre></div>
<h2 id=查看日志>查看日志</h2>
<p>到这里，挖掘出集群更深层的信息就需要登录到相关的机器上。下面是相关日志文件所在的位置。
（注意，对于基于 systemd 的系统，你可能需要使用<code>journalctl</code>）。</p>
<h3 id=主控节点>主控节点</h3>
<ul>
<li><code>/var/log/kube-apiserver.log</code> - API 服务器, 提供API服务</li>
<li><code>/var/log/kube-scheduler.log</code> - 调度器, 负责产生调度决策</li>
<li><code>/var/log/kube-controller-manager.log</code> - 管理副本控制器的控制器</li>
</ul>
<h3 id=工作节点>工作节点</h3>
<ul>
<li><code>/var/log/kubelet.log</code> - <code>kubelet</code>，负责在节点运行容器</li>
<li><code>/var/log/kube-proxy.log</code> - <code>kube-proxy</code>, 负责服务的负载均衡</li>
</ul>
<h2 id=集群故障模式的一般性概述>集群故障模式的一般性概述</h2>
<p>下面是一个不完整的列表，列举了一些可能的出错场景，以及通过调整集群配置来解决相关问题的方法。</p>
<h3 id=根本原因>根本原因</h3>
<ul>
<li>VM(s) 关机</li>
<li>集群之间，或者集群和用户之间网络分裂</li>
<li>Kubernetes 软件本身崩溃</li>
<li>数据丢失或者持久化存储不可用（如：GCE PD 或 AWS EBS 卷）</li>
<li>操作错误，如：Kubernetes 或者应用程序配置错误</li>
</ul>
<h3 id=具体情况>具体情况</h3>
<ul>
<li>API 服务器所在的 VM 关机或者 API 服务器崩溃
<ul>
<li>结果
<ul>
<li>不能停止、更新或者启动新的 Pod、服务或副本控制器</li>
<li>现有的 Pod 和服务在不依赖 Kubernetes API 的情况下应该能继续正常工作</li>
</ul>
</li>
</ul>
</li>
<li>API 服务器的后端存储丢失
<ul>
<li>结果
<ul>
<li>API 服务器应该不能启动</li>
<li>kubelet 将不能访问 API 服务器，但是能够继续运行之前的 Pod 和提供相同的服务代理</li>
<li>在 API 服务器重启之前，需要手动恢复或者重建 API 服务器的状态</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>Kubernetes 服务组件（节点控制器、副本控制器管理器、调度器等）所在的 VM 关机或者崩溃
<ul>
<li>当前，这些控制器是和 API 服务器在一起运行的，它们不可用的现象是与 API 服务器类似的</li>
<li>将来，这些控制器也会复制为多份，并且可能不在运行于同一节点上</li>
<li>它们没有自己的持久状态</li>
</ul>
</li>
<li>单个节点（VM 或者物理机）关机
<ul>
<li>结果
<ul>
<li>此节点上的所有 Pod 都停止运行</li>
</ul>
</li>
</ul>
</li>
<li>网络分裂
<ul>
<li>结果
<ul>
<li>分区 A 认为分区 B 中所有的节点都已宕机；分区 B 认为 API 服务器宕机
（假定主控节点所在的 VM 位于分区 A 内)。</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>kubelet 软件故障
<ul>
<li>结果
<ul>
<li>崩溃的 kubelet 就不能在其所在的节点上启动新的 Pod</li>
<li>kubelet 可能删掉 Pod 或者不删</li>
<li>节点被标识为非健康态</li>
<li>副本控制器会在其它的节点上启动新的 Pod</li>
</ul>
</li>
</ul>
</li>
<li>集群操作错误
<ul>
<li>结果
<ul>
<li>丢失 Pod 或服务等等</li>
<li>丢失 API 服务器的后端存储</li>
<li>用户无法读取API</li>
<li>等等</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id=缓解措施>缓解措施</h3>
<ul>
<li>
<p>措施：对于 IaaS 上的 VMs，使用 IaaS 的自动 VM 重启功能</p>
<ul>
<li>缓解：API 服务器 VM 关机或 API 服务器崩溃</li>
<li>缓解：Kubernetes 服务组件所在的 VM 关机或崩溃</li>
</ul>
</li>
<li>
<p>措施: 对于运行 API 服务器和 etcd 的 VM，使用 IaaS 提供的可靠的存储（例如 GCE PD 或者 AWS EBS 卷）</p>
<ul>
<li>缓解：API 服务器后端存储的丢失</li>
</ul>
</li>
<li>
<p>措施：使用<a href=/zh/docs/setup/production-environment/tools/kubeadm/high-availability/>高可用性</a>的配置</p>
<ul>
<li>缓解：主控节点 VM 关机或者主控节点组件（调度器、API 服务器、控制器管理器）崩馈
<ul>
<li>将容许一个或多个节点或组件同时出现故障</li>
</ul>
</li>
<li>缓解：API 服务器后端存储（例如 etcd 的数据目录）丢失
<ul>
<li>假定你使用了高可用的 etcd 配置</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>
<p>措施：定期对 API 服务器的 PDs/EBS 卷执行快照操作</p>
<ul>
<li>缓解：API 服务器后端存储丢失</li>
<li>缓解：一些操作错误的场景</li>
<li>缓解：一些 Kubernetes 软件本身故障的场景</li>
</ul>
</li>
<li>
<p>措施：在 Pod 的前面使用副本控制器或服务</p>
<ul>
<li>缓解：节点关机</li>
<li>缓解：kubelet 软件故障</li>
</ul>
</li>
<li>
<p>措施：应用（容器）设计成容许异常重启</p>
<ul>
<li>缓解：节点关机</li>
<li>缓解：kubelet 软件故障</li>
</ul>
</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-11a6d16334428909c99e7208ab8fa5e9>13 - 扩展 Kubernetes</h1>
<div class=lead>了解针对工作环境需要来调整 Kubernetes 集群的进阶方法。</div>
</div>
<div class=td-content>
<h1 id=pg-8f1f7f0d3a1cc21537506bd4f9103a29>13.1 - 使用自定义资源</h1>
</div>
<div class=td-content>
<h1 id=pg-dc64883f1fd119402b112d3ff6733452>13.1.1 - 使用 CustomResourceDefinition 扩展 Kubernetes API</h1>
<p>本页展示如何使用
<a href=/docs/reference/generated/kubernetes-api/v1.23/#customresourcedefinition-v1-apiextensions-k8s-io>CustomResourceDefinition</a>
将
<a href=/zh/docs/concepts/extend-kubernetes/api-extension/custom-resources/>定制资源（Custom Resource）</a>
安装到 Kubernetes API 上。</p>
<h2 id=before-you-begin>Before you begin</h2>
<p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li>
</ul>
Your Kubernetes server must be at or later than version 1.16.
To check the version, enter <code>kubectl version</code>.
</p>
<p>如果你在使用较老的、仍处于被支持范围的 Kubernetes 版本，请切换到该版本的
文档查看对于的集群而言有用的建议。</p>
<h2 id=create-a-customresourcedefinition>创建 CustomResourceDefinition </h2>
<p>当你创建新的 CustomResourceDefinition（CRD）时，Kubernetes API 服务器会为你所
指定的每一个版本生成一个 RESTful 的 资源路径。CRD 可以是名字空间作用域的，也可以
是集群作用域的，取决于 CRD 的 <code>scope</code> 字段设置。和其他现有的内置对象一样，删除
一个名字空间时，该名字空间下的所有定制对象也会被删除。CustomResourceDefinition
本身是不受名字空间限制的，对所有名字空间可用。</p>
<p>例如，如果你将下面的 CustomResourceDefinition 保存到 <code>resourcedefinition.yaml</code>
文件：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apiextensions.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>CustomResourceDefinition<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 名字必需与下面的 spec 字段匹配，并且格式为 &#39;&lt;名称的复数形式&gt;.&lt;组名&gt;&#39;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>crontabs.stable.example.com<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 组名称，用于 REST API: /apis/&lt;组&gt;/&lt;版本&gt;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>group</span>:<span style=color:#bbb> </span>stable.example.com<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 列举此 CustomResourceDefinition 所支持的版本</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>versions</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 每个版本都可以通过 served 标志来独立启用或禁止</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>served</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 其中一个且只有一个版本必需被标记为存储版本</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>schema</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>openAPIV3Schema</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>object<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>properties</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>object<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>properties</span>:<span style=color:#bbb>
</span><span style=color:#bbb>                </span><span style=color:green;font-weight:700>cronSpec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>                  </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>string<span style=color:#bbb>
</span><span style=color:#bbb>                </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb>
</span><span style=color:#bbb>                  </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>string<span style=color:#bbb>
</span><span style=color:#bbb>                </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb>
</span><span style=color:#bbb>                  </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>integer<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 可以是 Namespaced 或 Cluster</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>scope</span>:<span style=color:#bbb> </span>Namespaced<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>names</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 名称的复数形式，用于 URL：/apis/&lt;组&gt;/&lt;版本&gt;/&lt;名称的复数形式&gt;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>plural</span>:<span style=color:#bbb> </span>crontabs<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 名称的单数形式，作为命令行使用时和显示时的别名</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>singular</span>:<span style=color:#bbb> </span>crontab<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># kind 通常是单数形式的帕斯卡编码（PascalCased）形式。你的资源清单会使用这一形式。</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>CronTab<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># shortNames 允许你在命令行使用较短的字符串来匹配资源</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>shortNames</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- ct<span style=color:#bbb>
</span></code></pre></div>
<p>之后创建它：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f resourcedefinition.yaml
</code></pre></div>
<p>这样一个新的受名字空间约束的 RESTful API 端点会被创建在：</p>
<pre><code>/apis/stable.example.com/v1/namespaces/*/crontabs/...
</code></pre>
<p>此端点 URL 自此可以用来创建和管理定制对象。对象的 <code>kind</code> 将是来自你上面创建时
所用的 spec 中指定的 <code>CronTab</code>。</p>
<p>创建端点的操作可能需要几秒钟。你可以监测你的 CustomResourceDefinition 的
<code>Established</code> 状况变为 true，或者监测 API 服务器的发现信息等待你的资源出现在
那里。</p>
<h2 id=create-custom-objects>创建定制对象 </h2>
<p>在创建了 CustomResourceDefinition 对象之后，你可以创建定制对象（Custom
Objects）。定制对象可以包含定制字段。这些字段可以包含任意的 JSON 数据。
在下面的例子中，在类别为 <code>CrontTab</code> 的定制对象中，设置了<code>cronSpec</code> 和 <code>image</code>
定制字段。类别 <code>CronTab</code> 来自你在上面所创建的 CRD 的规约。</p>
<p>如果你将下面的 YAML 保存到 <code>my-crontab.yaml</code>：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;stable.example.com/v1&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>CronTab<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-new-cron-object<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>cronSpec</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;* * * * */5&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>my-awesome-cron-image<span style=color:#bbb>
</span></code></pre></div>
<p>并执行创建命令：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f my-crontab.yaml
</code></pre></div>
<p>你就可以使用 kubectl 来管理你的 CronTab 对象了。例如：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get crontab
</code></pre></div>
<p>应该会输出如下列表：</p>
<pre><code class=language-none data-lang=none>NAME                 AGE
my-new-cron-object   6s
</code></pre>
<p>使用 kubectl 时，资源名称是大小写不敏感的，而且你既可以使用 CRD 中所定义的单数
形式或复数形式，也可以使用其短名称：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get ct -o yaml
</code></pre></div>
<p>你可以看到输出中包含了你创建定制对象时在 YAML 文件中指定的定制字段 <code>cronSpec</code>
和 <code>image</code>：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>items</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>stable.example.com/v1<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>CronTab<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>kubectl.kubernetes.io/last-applied-configuration</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span><span style=color:#b44;font-style:italic>        </span><span style=color:#bbb>        </span>{<span style=color:#b44>&#34;apiVersion&#34;</span>:<span style=color:#b44>&#34;stable.example.com/v1&#34;</span>,<span style=color:#b44>&#34;kind&#34;</span>:<span style=color:#b44>&#34;CronTab&#34;</span>,<span style=color:#b44>&#34;metadata&#34;</span>:{<span style=color:#b44>&#34;annotations&#34;</span>:{},<span style=color:#b44>&#34;name&#34;</span>:<span style=color:#b44>&#34;my-new-cron-object&#34;</span>,<span style=color:#b44>&#34;namespace&#34;</span>:<span style=color:#b44>&#34;default&#34;</span>},<span style=color:#b44>&#34;spec&#34;</span>:{<span style=color:#b44>&#34;cronSpec&#34;</span>:<span style=color:#b44>&#34;* * * * */5&#34;</span>,<span style=color:#b44>&#34;image&#34;</span>:<span style=color:#b44>&#34;my-awesome-cron-image&#34;</span>}}<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>creationTimestamp</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2021-06-20T07:35:27Z&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>generation</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-new-cron-object<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resourceVersion</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;1326&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>uid</span>:<span style=color:#bbb> </span>9aab1d66-628e-41bb-a422-57b8b3b1f5a9<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>cronSpec</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;* * * * */5&#39;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>my-awesome-cron-image<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>List<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resourceVersion</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selfLink</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></code></pre></div>
<h2 id=delete-a-customresourcedefinition>删除 CustomResourceDefinition </h2>
<p>当你删除某 CustomResourceDefinition 时，服务器会卸载其 RESTful API
端点，并删除服务器上存储的所有定制对象。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete -f resourcedefinition.yaml
kubectl get crontabs
</code></pre></div><pre><code class=language-none data-lang=none>Error from server (NotFound): Unable to list {&quot;stable.example.com&quot; &quot;v1&quot; &quot;crontabs&quot;}: the server could not find the requested resource (get crontabs.stable.example.com)
</code></pre>
<p>如果你在以后创建相同的 CustomResourceDefinition 时，该 CRD 会是一个空的结构。</p>
<h2 id=specifying-a-structural-schema>设置结构化的模式 </h2>
<p>CustomResource 对象在定制字段中保存结构化的数据，这些字段和内置的字段
<code>apiVersion</code>、<code>kind</code> 和 <code>metadata</code> 等一起存储，不过内置的字段都会被 API
服务器隐式完成合法性检查。有了 <a href=#validation>OpenAPI v3.0 检查</a>
能力之后，你可以设置一个模式（Schema），在创建和更新定制对象时，这一模式会被用来
对对象内容进行合法性检查。参阅下文了解这类模式的细节和局限性。</p>
<p>在 <code>apiextensions.k8s.io/v1</code> 版本中，CustomResourceDefinition 的这一结构化模式
定义是必需的。
在 CustomResourceDefinition 的 beta 版本中，结构化模式定义是可选的。</p>
<p>结构化模式本身是一个 <a href=#validation>OpenAPI v3.0 验证模式</a>，其中：</p>
<ol>
<li>为对象根（root）设置一个非空的 type 值（藉由 OpenAPI 中的 <code>type</code>），对每个
object 节点的每个字段（藉由 OpenAPI 中的 <code>properties</code> 或 <code>additionalProperties</code>）以及
array 节点的每个条目（藉由 OpenAPI 中的 <code>items</code>）也要设置非空的 type 值，
除非：
<ul>
<li>节点包含属性 <code>x-kubernetes-int-or-string: true</code></li>
<li>节点包含属性 <code>x-kubernetes-preserve-unknown-fields: true</code></li>
</ul>
</li>
<li>对于 object 的每个字段或 array 中的每个条目，如果其定义中包含 <code>allOf</code>、<code>anyOf</code>、<code>oneOf</code>
或 <code>not</code>，则模式也要指定这些逻辑组合之外的字段或条目（试比较例 1 和例 2)。</li>
<li>在 <code>allOf</code>、<code>anyOf</code>、<code>oneOf</code> 或 <code>not</code> 上下文内不设置 <code>description</code>、<code>type</code>、<code>default</code>、
<code>additionalProperties</code> 或者 <code>nullable</code>。此规则的例外是
<code>x-kubernetes-int-or-string</code> 的两种模式（见下文）。</li>
<li>如果 <code>metadata</code> 被设置，则只允许对 <code>metadata.name</code> 和 <code>metadata.generateName</code> 设置约束。</li>
</ol>
<p>非结构化的例 1:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>allOf</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>properties</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>foo</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>...<span style=color:#bbb>
</span></code></pre></div>
<p>违反了第 2 条规则。下面的是正确的：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>properties</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>foo</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>...<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>allOf</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>properties</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>foo</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>...<span style=color:#bbb>
</span></code></pre></div>
<p>非结构化的例 2：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>allOf</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>items</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>properties</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>foo</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>...<span style=color:#bbb>
</span></code></pre></div>
<p>违反了第 2 条规则。下面的是正确的：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>items</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>properties</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>foo</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>...<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>allOf</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>items</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>properties</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>foo</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>...<span style=color:#bbb>
</span></code></pre></div>
<p>非结构化的例 3：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>properties</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>foo</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>pattern</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;abc&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>object<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>properties</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>string<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>pattern</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;^a&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>finalizers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>array<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>items</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>string<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>pattern</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;my-finalizer&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>anyOf</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>properties</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>bar</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>integer<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>minimum</span>:<span style=color:#bbb> </span><span style=color:#666>42</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>required</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;bar&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>description</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;foo bar object&#34;</span><span style=color:#bbb>
</span></code></pre></div>
<p>不是一个结构化的模式，因为其中存在以下违例：</p>
<ul>
<li>根节点缺失 type 设置（规则 1）</li>
<li><code>foo</code> 的 type 缺失（规则 1）</li>
<li><code>anyOf</code> 中的 <code>bar</code> 未在外部指定（规则 2）</li>
<li><code>bar</code> 的 <code>type</code> 位于 <code>anyOf</code> 中（规则 3）</li>
<li><code>anyOf</code> 中设置了 <code>description</code> （规则 3）</li>
<li><code>metadata.finalizers</code> 不可以被限制 (规则 4）</li>
</ul>
<p>作为对比，下面的 YAML 所对应的模式则是结构化的：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>object<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>description</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;foo bar object&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>properties</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>foo</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>string<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>pattern</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;abc&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>bar</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>integer<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>object<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>properties</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>string<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>pattern</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;^a&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>anyOf</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>properties</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>bar</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>minimum</span>:<span style=color:#bbb> </span><span style=color:#666>42</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>required</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;bar&#34;</span>]<span style=color:#bbb>
</span></code></pre></div>
<p>如果违反了结构化模式规则，CustomResourceDefinition 的 <code>NonStructural</code> 状况中
会包含报告信息。</p>
<h3 id=field-pruning>字段剪裁 </h3>
<p>CustomResourceDefinition 在集群的持久性存储
<a class=glossary-tooltip title="etcd 是兼具一致性和高可用性的键值数据库，用作保存 Kubernetes 所有集群数据的后台数据库。" data-toggle=tooltip data-placement=top href=/zh/docs/tasks/administer-cluster/configure-upgrade-etcd/ target=_blank aria-label=etcd>etcd</a>
中保存经过合法性检查的资源数据。
就像原生的 Kubernetes 资源，例如 <a class=glossary-tooltip title="ConfigMap 是一种 API 对象，用来将非机密性的数据保存到键值对中。使用时可以用作环境变量、命令行参数或者存储卷中的配置文件。" data-toggle=tooltip data-placement=top href=/zh/docs/tasks/configure-pod-container/configure-pod-configmap/ target=_blank aria-label=ConfigMap>ConfigMap</a>，
如果你指定了 API 服务器所无法识别的字段，则该未知字段会在保存资源之前
被 <em>剪裁（Pruned）</em> 掉（删除）。</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> <p>从 <code>apiextensions.k8s.io/v1beta1</code> 转换到 <code>apiextensions.k8s.io/v1</code> 的 CRD
可能没有结构化的模式定义，因此其 <code>spec.preserveUnknownFields</code> 可能为 <code>true</code>。</p>
<p>对于使用 <code>apiextensions.k8s.io/v1beta1</code> 且将 <code>spec.preserveUnknownFields</code> 设置为 <code>true</code>
创建的旧 CustomResourceDefinition 对象，有以下表现：</p>
<ul>
<li>裁剪未启用。</li>
<li>可以存储任意数据。</li>
</ul>
<p>为了与 <code>apiextensions.k8s.io/v1</code> 兼容，将你的自定义资源定义更新为：</p>
<ol>
<li>使用结构化的 OpenAPI 模式。</li>
<li><code>spec.preserveUnknownFields</code> 设置为 <code>false</code>。</li>
</ol>
</div>
<p>如果你将下面的 YAML 保存到 <code>my-crontab.yaml</code> 文件：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;stable.example.com/v1&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>CronTab<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-new-cron-object<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>cronSpec</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;* * * * */5&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>my-awesome-cron-image<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>someRandomField</span>:<span style=color:#bbb> </span><span style=color:#666>42</span><span style=color:#bbb>
</span></code></pre></div>
<p>并创建之：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create --validate<span style=color:#666>=</span><span style=color:#a2f>false</span> -f my-crontab.yaml -o yaml
</code></pre></div>
<p>输出类似于：</p>
<pre><code class=language-console data-lang=console>apiVersion: stable.example.com/v1
kind: CronTab
metadata:
  creationTimestamp: 2017-05-31T12:56:35Z
  generation: 1
  name: my-new-cron-object
  namespace: default
  resourceVersion: &quot;285&quot;
  uid: 9423255b-4600-11e7-af6a-28d2447dc82b
spec:
  cronSpec: '* * * * */5'
  image: my-awesome-cron-image
</code></pre>
<p>注意其中的字段 <code>someRandomField</code> 已经被剪裁掉。</p>
<p>本例中通过 <code>--validate=false</code> 命令行选项 关闭了客户端的合法性检查以展示 API 服务器的行为，
因为 <a href=#publish-validation-schema-in-openapi-v2>OpenAPI 合法性检查模式也会发布到</a>
客户端，<code>kubectl</code> 也会检查未知的字段并在对象被发送到 API
服务器之前就拒绝它们。</p>
<h4 id=controlling-pruning>控制剪裁 </h4>
<p>默认情况下，定制资源的所有版本中的所有未规定的字段都会被剪裁掉。
通过在结构化的 OpenAPI v3 <a href=#specifying-a-structural-schema>检查模式定义</a>
中为特定字段的子树添加 <code>x-kubernetes-preserve-unknown-fields: true</code> 属性，可以
选择不对其执行剪裁操作。
例如：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>object<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>properties</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>json</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>x-kubernetes-preserve-unknown-fields</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></code></pre></div>
<p>字段 <code>json</code> 可以保存任何 JSON 值，其中内容不会被剪裁掉。</p>
<p>你也可以部分地指定允许的 JSON 数据格式；例如：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>object<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>properties</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>json</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>x-kubernetes-preserve-unknown-fields</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>object<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>description</span>:<span style=color:#bbb> </span>this is arbitrary JSON<span style=color:#bbb>
</span></code></pre></div>
<p>通过这样设置，JSON 中只能设置 <code>object</code> 类型的值。</p>
<p>对于所指定的每个属性（或 <code>additionalProperties</code>），剪裁会再次被启用。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>object<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>properties</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>json</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>x-kubernetes-preserve-unknown-fields</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>object<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>properties</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>object<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>properties</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>foo</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>string<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>bar</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>string<span style=color:#bbb>
</span></code></pre></div>
<p>对于上述定义，如果提供的数值如下：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>json</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>foo</span>:<span style=color:#bbb> </span>abc<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>bar</span>:<span style=color:#bbb> </span>def<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>something</span>:<span style=color:#bbb> </span>x<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>something</span>:<span style=color:#bbb> </span>x<span style=color:#bbb>
</span></code></pre></div>
<p>则该值会被剪裁为：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>json</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>foo</span>:<span style=color:#bbb> </span>abc<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>bar</span>:<span style=color:#bbb> </span>def<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>something</span>:<span style=color:#bbb> </span>x<span style=color:#bbb>
</span></code></pre></div>
<p>这意味着所指定的 <code>spec</code> 对象中的 <code>something</code> 字段被剪裁掉，而其外部的内容都被保留。</p>
<h3 id=intorstring>IntOrString</h3>
<p>模式定义中标记了 <code>x-kubernetes-int-or-string: true</code> 的节点不受前述规则 1
约束，因此下面的定义是结构化的模式：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>object<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>properties</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>foo</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>x-kubernetes-int-or-string</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></code></pre></div>
<p>此外，所有这类节点也不再受规则 3 约束，也就是说，下面两种模式是被允许的
（注意，仅限于这两种模式，不支持添加新字段的任何其他变种）：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>x-kubernetes-int-or-string</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>anyOf</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>integer<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>string<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></code></pre></div><p>和</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>x-kubernetes-int-or-string</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>allOf</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>anyOf</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>integer<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>string<span style=color:#bbb>
</span><span style=color:#bbb></span>- ...<span style=color:#bbb> </span><span style=color:#080;font-style:italic># zero or more</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></code></pre></div>
<p>在以上两种规约中，整数值和字符串值都会被认为是合法的。</p>
<p>在<a href=#publish-validation-schema-in-openapi-v2>合法性检查模式定义的发布时</a>，
<code>x-kubernetes-int-or-string: true</code> 会被展开为上述两种模式之一。</p>
<h3 id=rawextension>RawExtension</h3>
<p>RawExtensions（就像在
<a href=https://github.com/kubernetes/apimachinery/blob/03ac7a9ade429d715a1a46ceaa3724c18ebae54f/pkg/runtime/types.go#L94>k8s.io/apimachinery</a>
项目中 <code>runtime.RawExtension</code> 所定义的那样）
可以保存完整的 Kubernetes 对象，也就是，其中会包含 <code>apiVersion</code> 和 <code>kind</code>
字段。</p>
<p>通过 <code>x-kubernetes-embedded-resource: true</code> 来设定这些嵌套对象的规约（无论是
完全无限制还是部分指定都可以）是可能的。例如：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>object<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>properties</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>foo</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>x-kubernetes-embedded-resource</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>x-kubernetes-preserve-unknown-fields</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></code></pre></div>
<p>这里，字段 <code>foo</code> 包含一个完整的对象，例如：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>foo</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>...<span style=color:#bbb>
</span></code></pre></div>
<p>由于字段上设置了 <code>x-kubernetes-preserve-unknown-fields: true</code>，其中的内容不会
被剪裁。不过，在这个语境中，<code>x-kubernetes-preserve-unknown-fields: true</code> 的
使用是可选的。</p>
<p>设置了 <code>x-kubernetes-embedded-resource: true</code> 之后，<code>apiVersion</code>、<code>kind</code> 和
<code>metadata</code> 都是隐式设定并隐式完成合法性验证。</p>
<h2 id=serving-multiple-versions-of-a-crd>提供 CRD 的多个版本 </h2>
<p>关于如何为你的 CustomResourceDefinition 提供多个版本的支持，以及如何将你的对象
从一个版本迁移到另一个版本， 详细信息可参阅
<a href=/zh/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definition-versioning/>定制资源定义的版本</a>。</p>
<h2 id=advanced-topics>高级主题 </h2>
<h3 id=finalizers>Finalizers</h3>
<p><em>Finalizer</em> 能够让控制器实现异步的删除前（Pre-delete）回调。
与内置对象类似，定制对象也支持 Finalizer。</p>
<p>你可以像下面一样为定制对象添加 Finalizer：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;stable.example.com/v1&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>CronTab<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>finalizers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- stable.example.com/finalizer<span style=color:#bbb>
</span></code></pre></div>
<p>自定义 Finalizer 的标识符包含一个域名、一个正向斜线和 finalizer 的名称。
任何控制器都可以在任何对象的 finalizer 列表中添加新的 finalizer。</p>
<p>对带有 Finalizer 的对象的第一个删除请求会为其 <code>metadata.deletionTimestamp</code>
设置一个值，但不会真的删除对象。一旦此值被设置，<code>finalizers</code> 列表中的表项
只能被移除。在列表中仍然包含 finalizer 时，无法强制删除对应的对象。</p>
<p>当 <code>metadata.deletionTimestamp</code> 字段被设置时，监视该对象的各个控制器会
执行它们所能处理的 finalizer，并在完成处理之后将其从列表中移除。
每个控制器负责将其 finalizer 从列表中删除。</p>
<p><code>metadata.deletionGracePeriodSeconds</code> 的取值控制对更新的轮询周期。</p>
<p>一旦 finalizers 列表为空时，就意味着所有 finalizer 都被执行过，
Kubernetes 会最终删除该资源，</p>
<h3 id=validation>合法性检查 </h3>
<p>定制资源是通过
<a href=https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.0.md#schemaObject>OpenAPI v3 模式定义</a>
来执行合法性检查的，
你可以通过使用<a href=/zh/docs/reference/access-authn-authz/admission-controllers/#validatingadmissionwebhook>准入控制 Webhook</a>
来添加额外的合法性检查逻辑。</p>
<p>此外，对模式定义存在以下限制：</p>
<ul>
<li>以下字段不可设置：
<ul>
<li><code>definitions</code></li>
<li><code>dependencies</code></li>
<li><code>deprecated</code></li>
<li><code>discriminator</code></li>
<li><code>id</code></li>
<li><code>patternProperties</code></li>
<li><code>readOnly</code></li>
<li><code>writeOnly</code></li>
<li><code>xml</code></li>
<li><code>$ref</code></li>
</ul>
</li>
<li>字段 <code>uniqueItems</code> 不可设置为 <code>true</code></li>
<li>字段 <code>additionalProperties</code> 不可设置为 <code>false</code></li>
<li>字段 <code>additionalProperties</code> 与 <code>properties</code> 互斥，不可同时使用</li>
</ul>
<p>当<a href=#defaulting>设置默认值特性</a>被启用时，可以设置字段 <code>default</code>。
就 <code>apiextensions.k8s.io/v1</code> 组的 CustomResourceDefinitions，这一条件是满足的。
设置默认值的功能特性从 1.17 开始正式发布。该特性在 1.16 版本中处于
Beta 状态，要求 <code>CustomResourceDefaulting</code>
<a href=/zh/docs/reference/command-line-tools-reference/feature-gates/>特性门控</a>
被启用。对于大多数集群而言，Beta 状态的特性门控默认都是自动启用的。</p>
<p>关于对某些 CustomResourceDefinition 特性所必需的限制，可参见
<a href=#specifying-a-structural-schema>结构化的模式定义</a>小节。</p>
<p>模式定义是在 CustomResourceDefinition 中设置的。在下面的例子中，
CustomResourceDefinition 对定制对象执行以下合法性检查：</p>
<ul>
<li><code>spec.cronSpec</code> 必须是一个字符串，必须是正则表达式所描述的形式；</li>
<li><code>spec.replicas</code> 必须是一个整数，且其最小值为 1、最大值为 10。</li>
</ul>
<p>将此 CustomResourceDefinition 保存到 <code>resourcedefinition.yaml</code> 文件中：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apiextensions.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>CustomResourceDefinition<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>crontabs.stable.example.com<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>group</span>:<span style=color:#bbb> </span>stable.example.com<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>versions</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>served</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>schema</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># openAPIV3Schema is the schema for validating custom objects.</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>openAPIV3Schema</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>object<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>properties</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>object<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>properties</span>:<span style=color:#bbb>
</span><span style=color:#bbb>                </span><span style=color:green;font-weight:700>cronSpec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>                  </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>string<span style=color:#bbb>
</span><span style=color:#bbb>                  </span><span style=color:green;font-weight:700>pattern</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;^(\d+|\*)(/\d+)?(\s+(\d+|\*)(/\d+)?){4}$&#39;</span><span style=color:#bbb>
</span><span style=color:#bbb>                </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb>
</span><span style=color:#bbb>                  </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>string<span style=color:#bbb>
</span><span style=color:#bbb>                </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb>
</span><span style=color:#bbb>                  </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>integer<span style=color:#bbb>
</span><span style=color:#bbb>                  </span><span style=color:green;font-weight:700>minimum</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span><span style=color:#bbb>                  </span><span style=color:green;font-weight:700>maximum</span>:<span style=color:#bbb> </span><span style=color:#666>10</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>scope</span>:<span style=color:#bbb> </span>Namespaced<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>names</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>plural</span>:<span style=color:#bbb> </span>crontabs<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>singular</span>:<span style=color:#bbb> </span>crontab<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>CronTab<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>shortNames</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- ct<span style=color:#bbb>
</span></code></pre></div>
<p>并创建 CustomResourceDefinition：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f resourcedefinition.yaml
</code></pre></div>
<p>对于一个创建 CronTab 类别对象的定制对象的请求而言，如果其字段中包含非法值，则
该请求会被拒绝。
在下面的例子中，定制对象中包含带非法值的字段：</p>
<ul>
<li><code>spec.cronSpec</code> 与正则表达式不匹配</li>
<li><code>spec.replicas</code> 数值大于 10。</li>
</ul>
<p>如果你将下面的 YAML 保存到 <code>my-crontab.yaml</code>：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;stable.example.com/v1&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>CronTab<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-new-cron-object<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>cronSpec</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;* * * *&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>my-awesome-cron-image<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>15</span><span style=color:#bbb>
</span></code></pre></div>
<p>并尝试创建定制对象：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f my-crontab.yaml
</code></pre></div>
<p>你会看到下面的错误信息：</p>
<pre><code class=language-console data-lang=console>The CronTab &quot;my-new-cron-object&quot; is invalid: []: Invalid value: map[string]interface {}{&quot;apiVersion&quot;:&quot;stable.example.com/v1&quot;, &quot;kind&quot;:&quot;CronTab&quot;, &quot;metadata&quot;:map[string]interface {}{&quot;name&quot;:&quot;my-new-cron-object&quot;, &quot;namespace&quot;:&quot;default&quot;, &quot;deletionTimestamp&quot;:interface {}(nil), &quot;deletionGracePeriodSeconds&quot;:(*int64)(nil), &quot;creationTimestamp&quot;:&quot;2017-09-05T05:20:07Z&quot;, &quot;uid&quot;:&quot;e14d79e7-91f9-11e7-a598-f0761cb232d1&quot;, &quot;clusterName&quot;:&quot;&quot;}, &quot;spec&quot;:map[string]interface {}{&quot;cronSpec&quot;:&quot;* * * *&quot;, &quot;image&quot;:&quot;my-awesome-cron-image&quot;, &quot;replicas&quot;:15}}:
validation failure list:
spec.cronSpec in body should match '^(\d+|\*)(/\d+)?(\s+(\d+|\*)(/\d+)?){4}$'
spec.replicas in body should be less than or equal to 10
</code></pre>
<p>如果所有字段都包含合法值，则对象创建的请求会被接受。</p>
<p>将下面的 YAML 保存到 <code>my-crontab.yaml</code> 文件：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;stable.example.com/v1&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>CronTab<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-new-cron-object<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>cronSpec</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;* * * * */5&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>my-awesome-cron-image<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>5</span><span style=color:#bbb>
</span></code></pre></div>
<p>并创建定制对象：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f my-crontab.yaml
crontab <span style=color:#b44>&#34;my-new-cron-object&#34;</span> created
</code></pre></div>
<h3 id=efaulting>设置默认值 </h3>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 要使用设置默认值功能，你的 CustomResourceDefinition 必须使用 API 版本 <code>apiextensions.k8s.io/v1</code>。
</div>
<p>设置默认值的功能允许在 <a href=#validation>OpenAPI v3 合法性检查模式定义</a>中设置默认值：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apiextensions.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>CustomResourceDefinition<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>crontabs.stable.example.com<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>group</span>:<span style=color:#bbb> </span>stable.example.com<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>versions</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>served</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>schema</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># openAPIV3Schema 是用来检查定制对象的模式定义</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>openAPIV3Schema</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>object<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>properties</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>object<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>properties</span>:<span style=color:#bbb>
</span><span style=color:#bbb>                </span><span style=color:green;font-weight:700>cronSpec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>                  </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>string<span style=color:#bbb>
</span><span style=color:#bbb>                  </span><span style=color:green;font-weight:700>pattern</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;^(\d+|\*)(/\d+)?(\s+(\d+|\*)(/\d+)?){4}$&#39;</span><span style=color:#bbb>
</span><span style=color:#bbb>                  </span><span style=color:green;font-weight:700>default</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;5 0 * * *&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>                </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb>
</span><span style=color:#bbb>                  </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>string<span style=color:#bbb>
</span><span style=color:#bbb>                </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb>
</span><span style=color:#bbb>                  </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>integer<span style=color:#bbb>
</span><span style=color:#bbb>                  </span><span style=color:green;font-weight:700>minimum</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span><span style=color:#bbb>                  </span><span style=color:green;font-weight:700>maximum</span>:<span style=color:#bbb> </span><span style=color:#666>10</span><span style=color:#bbb>
</span><span style=color:#bbb>                  </span><span style=color:green;font-weight:700>default</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>scope</span>:<span style=color:#bbb> </span>Namespaced<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>names</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>plural</span>:<span style=color:#bbb> </span>crontabs<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>singular</span>:<span style=color:#bbb> </span>crontab<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>CronTab<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>shortNames</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- ct<span style=color:#bbb>
</span></code></pre></div>
<p>使用此 CRD 定义时，<code>cronSpec</code> 和 <code>replicas</code> 都会被设置默认值：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;stable.example.com/v1&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>CronTab<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-new-cron-object<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>my-awesome-cron-image<span style=color:#bbb>
</span></code></pre></div>
<p>会生成：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;stable.example.com/v1&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>CronTab<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-new-cron-object<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>cronSpec</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;5 0 * * *&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>my-awesome-cron-image<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></code></pre></div>
<p>默认值设定的行为发生在定制对象上：</p>
<ul>
<li>在向 API 服务器发送的请求中，基于请求版本的设定设置默认值；</li>
<li>在从 etcd 读取对象时，使用存储版本来设置默认值；</li>
<li>在 Mutating 准入控制插件执行非空的补丁操作时，基于准入 Webhook 对象
版本设置默认值。</li>
</ul>
<p>从 etcd 中读取数据时所应用的默认值设置不会被写回到 etcd 中。
需要通过 API 执行更新请求才能将这种方式设置的默认值写回到 etcd。</p>
<p>默认值一定会被剪裁（除了 <code>metadata</code> 字段的默认值设置），且必须通过所提供
的模式定义的检查。</p>
<p>针对 <code>x-kubernetes-embedded-resource: true</code> 节点（或者包含 <code>metadata</code> 字段的结构的默认值）
的 <code>metadata</code> 字段的默认值设置不会在 CustomResourceDefinition 创建时被剪裁，
而是在处理请求的字段剪裁阶段被删除。</p>
<h4 id=defaulting-and-nullable>设置默认值和字段是否可为空（Nullable） </h4>
<p><strong>1.20 版本新增:</strong> 对于未设置其 nullable 标志的字段或者将该标志设置为
<code>false</code> 的字段，其空值（Null）会在设置默认值之前被剪裁掉。如果对应字段
存在默认值，则默认值会被赋予该字段。当 <code>nullable</code> 被设置为 <code>true</code> 时，
字段的空值会被保留，且不会在设置默认值时被覆盖。</p>
<p>例如，给定下面的 OpenAPI 模式定义：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>object<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>properties</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>object<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>properties</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>foo</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>string<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>nullable</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>false</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>default</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;default&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>bar</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>string<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>nullable</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>baz</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>string<span style=color:#bbb>
</span></code></pre></div>
<p>像下面这样创建一个为 <code>foo</code>、<code>bar</code> 和 <code>baz</code> 设置空值的对象时：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>foo</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>null</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>bar</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>null</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>baz</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>null</span><span style=color:#bbb>
</span></code></pre></div>
<p>其结果会是这样：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>foo</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;default&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>bar</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>null</span><span style=color:#bbb>
</span></code></pre></div>
<p>其中的 <code>foo</code> 字段被剪裁掉并重新设置默认值，因为该字段是不可为空的。
<code>bar</code> 字段的 <code>nullable: true</code> 使得其能够保有其空值。
<code>baz</code> 字段则被完全剪裁掉，因为该字段是不可为空的，并且没有默认值设置。</p>
<h3 id=publish-validation-schema-in-openapi-v2>以 OpenAPI v2 形式发布合法性检查模式 </h3>
<p>CustomResourceDefinition 的<a href=#specifying-a-structural-schema>结构化的</a>、
<a href=#preserving-unknown-fields>启用了剪裁的</a> <a href=#validation>OpenAPI v3 合法性检查模式</a>
会在 Kubernetes API 服务器上作为
<a href=/zh/docs/concepts/overview/kubernetes-api/#openapi-and-swagger-definitions>OpenAPI v2 规约</a>
的一部分发布出来。</p>
<p><a href=/zh/docs/reference/kubectl/overview>kubectl</a> 命令行工具会基于所发布的模式定义来执行
客户端的合法性检查（<code>kubectl create</code> 和 <code>kubectl apply</code>），为定制资源的模式定义
提供解释（<code>kubectl explain</code>）。
所发布的模式还可被用于其他目的，例如生成客户端或者生成文档。</p>
<p>OpenAPI v3 合法性检查模式定义会被转换为 OpenAPI v2 模式定义，并出现在
<a href=/zh/docs/concepts/overview/kubernetes-api/#openapi-and-swagger-definitions>OpenAPI v2 规范</a>
的 <code>definitions</code> 和 <code>paths</code> 字段中。</p>
<p>在转换过程中会发生以下修改，目的是保持与 1.13 版本以前的 kubectl 工具兼容。
这些修改可以避免 kubectl 过于严格，以至于拒绝它无法理解的 OpenAPI 模式定义。
转换过程不会更改 CRD 中定义的合法性检查模式定义，因此不会影响到 API 服务器中
的<a href=#validation>合法性检查</a>。</p>
<ol>
<li>以下字段会被移除，因为它们在 OpenAPI v2 中不支持（在将来版本中将使用 OpenAPI v3，
因而不会有这些限制）
<ul>
<li>字段 <code>allOf</code>、<code>anyOf</code>、<code>oneOf</code> 和 <code>not</code> 会被删除</li>
</ul>
</li>
<li>如果设置了 <code>nullable: true</code>，我们会丢弃 <code>type</code>、<code>nullable</code>、<code>items</code> 和 <code>properties</code>
OpenAPI v2 无法表达 Nullable。为了避免 kubectl 拒绝正常的对象，这一转换是必要的。</li>
</ol>
<h3 id=additional-printer-columns>额外的打印列 </h3>
<p><code>kubectl</code> 工具依赖服务器端的输出格式化。你的集群的 API 服务器决定 <code>kubectl get</code> 命令要显示的列有哪些。
你可以为 CustomResourceDefinition 定制这些要打印的列。
下面的例子添加了 <code>Spec</code>、<code>Replicas</code> 和 <code>Age</code> 列：</p>
<p>将此 CustomResourceDefinition 保存到 <code>resourcedefinition.yaml</code> 文件：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apiextensions.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>CustomResourceDefinition<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>crontabs.stable.example.com<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>group</span>:<span style=color:#bbb> </span>stable.example.com<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>scope</span>:<span style=color:#bbb> </span>Namespaced<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>names</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>plural</span>:<span style=color:#bbb> </span>crontabs<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>singular</span>:<span style=color:#bbb> </span>crontab<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>CronTab<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>shortNames</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- ct<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>versions</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>served</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>schema</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>openAPIV3Schema</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>object<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>properties</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>object<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>properties</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>cronSpec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>                </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>string<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb>
</span><span style=color:#bbb>                </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>string<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb>
</span><span style=color:#bbb>                </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>integer<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>additionalPrinterColumns</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>Spec<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>string<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>description</span>:<span style=color:#bbb> </span>The cron spec defining the interval a CronJob is run<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>jsonPath</span>:<span style=color:#bbb> </span>.spec.cronSpec<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>Replicas<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>integer<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>description</span>:<span style=color:#bbb> </span>The number of jobs launched by the CronJob<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>jsonPath</span>:<span style=color:#bbb> </span>.spec.replicas<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>Age<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>date<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>jsonPath</span>:<span style=color:#bbb> </span>.metadata.creationTimestamp<span style=color:#bbb>
</span></code></pre></div>
<p>创建 CustomResourceDefinition：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f resourcedefinition.yaml
</code></pre></div>
<p>使用前文中的 <code>my-crontab.yaml</code> 创建一个实例。</p>
<p>启用服务器端打印输出：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get crontab my-new-cron-object
</code></pre></div>
<p>注意输出中的 <code>NAME</code>、<code>SPEC</code>、<code>REPLICAS</code> 和 <code>AGE</code> 列：</p>
<pre><code>NAME                 SPEC        REPLICAS   AGE
my-new-cron-object   * * * * *   1          7s
</code></pre>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> <code>NAME</code> 列是隐含的，不需要在 CustomResourceDefinition 中定义。
</div>
<h4 id=priority>优先级 </h4>
<p>每个列都包含一个 <code>priority</code>（优先级）字段。当前，优先级用来区分标准视图（Standard
View）和宽视图（Wide View）（使用 <code>-o wide</code> 标志）中显示的列：</p>
<ul>
<li>优先级为 <code>0</code> 的列会在标准视图中显示。</li>
<li>优先级大于 <code>0</code> 的列只会在宽视图中显示。</li>
</ul>
<h4 id=type>类型 </h4>
<p>列的 <code>type</code> 字段可以是以下值之一
（比较 <a href=https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.0.md#dataTypes>OpenAPI v3 数据类型</a>）：</p>
<ul>
<li><code>integer</code> – 非浮点数字</li>
<li><code>number</code> – 浮点数字</li>
<li><code>string</code> – 字符串</li>
<li><code>boolean</code> – <code>true</code> 或 <code>false</code></li>
<li><code>date</code> – 显示为以自此时间戳以来经过的时长</li>
</ul>
<p>如果定制资源中的值与列中指定的类型不匹配，该值会被忽略。
你可以通过定制资源的合法性检查来确保取值类型是正确的。</p>
<h4 id=format>格式 </h4>
<p>列的 <code>format</code> 字段可以是以下值之一：</p>
<ul>
<li><code>int32</code></li>
<li><code>int64</code></li>
<li><code>float</code></li>
<li><code>double</code></li>
<li><code>byte</code></li>
<li><code>date</code></li>
<li><code>date-time</code></li>
<li><code>password</code></li>
</ul>
<p>列的 <code>format</code> 字段控制 <code>kubectl</code> 打印对应取值时采用的风格。</p>
<h3 id=subresources>子资源 </h3>
<p>定制资源支持 <code>/status</code> 和 <code>/scale</code> 子资源。</p>
<p>通过在 CustomResourceDefinition 中定义 <code>status</code> 和 <code>scale</code>，
可以有选择地启用这些子资源。</p>
<h4 id=status-subresource>Status 子资源 </h4>
<p>当启用了 status 子资源时，对应定制资源的 <code>/status</code> 子资源会被暴露出来。</p>
<ul>
<li>status 和 spec 内容分别用定制资源内的 <code>.status</code> 和 <code>.spec</code> JSON 路径来表达；</li>
<li>对 <code>/status</code> 子资源的 <code>PUT</code> 请求要求使用定制资源对象作为其输入，但会忽略
status 之外的所有内容。</li>
<li>对 <code>/status</code> 子资源的 <code>PUT</code> 请求仅对定制资源的 status 内容进行合法性检查。</li>
<li>对定制资源的 <code>PUT</code>、<code>POST</code>、<code>PATCH</code> 请求会忽略 status 内容的改变。</li>
<li>对所有变更请求，除非改变是针对 <code>.metadata</code> 或 <code>.status</code>，<code>.metadata.generation</code>
的取值都会增加。</li>
</ul>
<ul>
<li>
<p>在 CRD OpenAPI 合法性检查模式定义的根节点，只允许存在以下结构：</p>
<ul>
<li><code>description</code></li>
<li><code>example</code></li>
<li><code>exclusiveMaximum</code></li>
<li><code>exclusiveMinimum</code></li>
<li><code>externalDocs</code></li>
<li><code>format</code></li>
<li><code>items</code></li>
<li><code>maximum</code></li>
<li><code>maxItems</code></li>
<li><code>maxLength</code></li>
<li><code>minimum</code></li>
<li><code>minItems</code></li>
<li><code>minLength</code></li>
<li><code>multipleOf</code></li>
<li><code>pattern</code></li>
<li><code>properties</code></li>
<li><code>required</code></li>
<li><code>title</code></li>
<li><code>type</code></li>
<li><code>uniqueItems</code></li>
</ul>
</li>
</ul>
<h4 id=scale-subresource>Scale 子资源 </h4>
<p>当启用了 scale 子资源时，定制资源的 <code>/scale</code> 子资源就被暴露出来。
针对 <code>/scale</code> 所发送的对象是 <code>autoscaling/v1.Scale</code>。</p>
<p>为了启用 scale 子资源，CustomResourceDefinition 定义了以下字段：</p>
<ul>
<li>
<p><code>specReplicasPath</code> 指定定制资源内与 <code>scale.spec.replicas</code> 对应的 JSON 路径。</p>
<ul>
<li>此字段为必需值。</li>
<li>只可以使用 <code>.spec</code> 下的 JSON 路径，只可使用带句点的路径。</li>
<li>如果定制资源的 <code>specReplicasPath</code> 下没有取值，则针对 <code>/scale</code> 子资源执行 GET
操作时会返回错误。</li>
</ul>
</li>
</ul>
<ul>
<li>
<p><code>statusReplicasPath</code> 指定定制资源内与 <code>scale.status.replicas</code> 对应的 JSON 路径。</p>
<ul>
<li>此字段为必需值。</li>
<li>只可以使用 <code>.status</code> 下的 JSON 路径，只可使用带句点的路径。</li>
<li>如果定制资源的 <code>statusReplicasPath</code> 下没有取值，则针对 <code>/scale</code> 子资源的
副本个数状态值默认为 0。</li>
</ul>
</li>
</ul>
<ul>
<li>
<p><code>labelSelectorPath</code> 指定定制资源内与 <code>scale.status.selector</code> 对应的 JSON 路径。</p>
<ul>
<li>此字段为可选值。</li>
<li>此字段必须设置才能使用 HPA。</li>
<li>只可以使用 <code>.status</code> 或 <code>.spec</code> 下的 JSON 路径，只可使用带句点的路径。</li>
<li>如果定制资源的 <code>labelSelectorPath</code> 下没有取值，则针对 <code>/scale</code> 子资源的
选择算符状态值默认为空字符串。</li>
<li>此 JSON 路径所指向的字段必须是一个字符串字段（而不是复合的选择算符结构），
其中包含标签选择算符串行化的字符串形式。</li>
</ul>
</li>
</ul>
<p>在下面的例子中，<code>status</code> 和 <code>scale</code> 子资源都被启用。</p>
<p>将此 CustomResourceDefinition 保存到 <code>resourcedefinition.yaml</code> 文件：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apiextensions.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>CustomResourceDefinition<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>crontabs.stable.example.com<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>group</span>:<span style=color:#bbb> </span>stable.example.com<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>versions</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>served</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>schema</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>openAPIV3Schema</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>object<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>properties</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>object<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>properties</span>:<span style=color:#bbb>
</span><span style=color:#bbb>                </span><span style=color:green;font-weight:700>cronSpec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>                  </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>string<span style=color:#bbb>
</span><span style=color:#bbb>                </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb>
</span><span style=color:#bbb>                  </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>string<span style=color:#bbb>
</span><span style=color:#bbb>                </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb>
</span><span style=color:#bbb>                  </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>integer<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>object<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>properties</span>:<span style=color:#bbb>
</span><span style=color:#bbb>                </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb>
</span><span style=color:#bbb>                  </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>integer<span style=color:#bbb>
</span><span style=color:#bbb>                </span><span style=color:green;font-weight:700>labelSelector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>                  </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>string<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># subresources 描述定制资源的子资源</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>subresources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># status 启用 status 子资源</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># scale 启用 scale 子资源</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>scale</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:#080;font-style:italic># specReplicasPath 定义定制资源中对应 scale.spec.replicas 的 JSON 路径</span><span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>specReplicasPath</span>:<span style=color:#bbb> </span>.spec.replicas<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:#080;font-style:italic># statusReplicasPath 定义定制资源中对应 scale.status.replicas 的 JSON 路径 </span><span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>statusReplicasPath</span>:<span style=color:#bbb> </span>.status.replicas<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:#080;font-style:italic># labelSelectorPath  定义定制资源中对应 scale.status.selector 的 JSON 路径 </span><span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>labelSelectorPath</span>:<span style=color:#bbb> </span>.status.labelSelector<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>scope</span>:<span style=color:#bbb> </span>Namespaced<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>names</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>plural</span>:<span style=color:#bbb> </span>crontabs<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>singular</span>:<span style=color:#bbb> </span>crontab<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>CronTab<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>shortNames</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- ct<span style=color:#bbb>
</span></code></pre></div>
<p>之后创建此 CustomResourceDefinition：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f resourcedefinition.yaml
</code></pre></div>
<p>CustomResourceDefinition 对象创建完毕之后，你可以创建定制对象，。</p>
<p>如果你将下面的 YAML 保存到 <code>my-crontab.yaml</code> 文件：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;stable.example.com/v1&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>CronTab<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-new-cron-object<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>cronSpec</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;* * * * */5&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>my-awesome-cron-image<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span></code></pre></div>
<p>并创建定制对象：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f my-crontab.yaml
</code></pre></div>
<p>那么会创建新的、命名空间作用域的 RESTful API 端点：</p>
<pre><code>/apis/stable.example.com/v1/namespaces/*/crontabs/status
</code></pre>
<p>和</p>
<pre><code>/apis/stable.example.com/v1/namespaces/*/crontabs/scale
</code></pre>
<p>定制资源可以使用 <code>kubectl scale</code> 命令来扩缩其规模。
例如下面的命令将前面创建的定制资源的 <code>.spec.replicas</code> 设置为 5：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl scale --replicas<span style=color:#666>=</span><span style=color:#666>5</span> crontabs/my-new-cron-object
</code></pre></div><pre><code>crontabs &quot;my-new-cron-object&quot; scaled
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get crontabs my-new-cron-object -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.spec.replicas}&#39;</span>
</code></pre></div><pre><code>5
</code></pre>
<p>你可以使用 <a href=/zh/docs/tasks/run-application/configure-pdb/>PodDisruptionBudget</a>
来保护启用了 scale 子资源的定制资源。</p>
<h3 id=categories>分类 </h3>
<p>分类（Categories）是定制资源所归属的分组资源列表（例如，<code>all</code>）。
你可以使用 <code>kubectl get &lt;分类名称></code> 来列举属于某分类的所有资源。</p>
<p>下面的示例在 CustomResourceDefinition 中将 <code>all</code> 添加到分类列表中，
并展示了如何使用 <code>kubectl get all</code> 来输出定制资源：</p>
<p>将下面的 CustomResourceDefinition 保存到 <code>resourcedefinition.yaml</code> 文件中：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apiextensions.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>CustomResourceDefinition<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>crontabs.stable.example.com<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>group</span>:<span style=color:#bbb> </span>stable.example.com<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>versions</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>served</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>schema</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>openAPIV3Schema</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>object<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>properties</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>object<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>properties</span>:<span style=color:#bbb>
</span><span style=color:#bbb>                </span><span style=color:green;font-weight:700>cronSpec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>                  </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>string<span style=color:#bbb>
</span><span style=color:#bbb>                </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb>
</span><span style=color:#bbb>                  </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>string<span style=color:#bbb>
</span><span style=color:#bbb>                </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb>
</span><span style=color:#bbb>                  </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>integer<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>scope</span>:<span style=color:#bbb> </span>Namespaced<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>names</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>plural</span>:<span style=color:#bbb> </span>crontabs<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>singular</span>:<span style=color:#bbb> </span>crontab<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>CronTab<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>shortNames</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- ct<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># categories 是定制资源所归属的分类资源列表</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>categories</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- all<span style=color:#bbb>
</span></code></pre></div>
<p>之后创建此 CRD：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f resourcedefinition.yaml
</code></pre></div>
<p>创建了 CustomResourceDefinition 对象之后，你可以创建定制对象。</p>
<p>将下面的 YAML 保存到 <code>my-crontab.yaml</code> 中：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;stable.example.com/v1&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>CronTab<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-new-cron-object<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>cronSpec</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;* * * * */5&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>my-awesome-cron-image<span style=color:#bbb>
</span></code></pre></div>
<p>并创建定制对象：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f my-crontab.yaml
</code></pre></div>
<p>你可以在使用 <code>kubectl get</code> 时指定分类：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get all
</code></pre></div>
<p>输出中会包含类别为 <code>CronTab</code> 的定制资源：</p>
<pre><code class=language-console data-lang=console>NAME                          AGE
crontabs/my-new-cron-object   3s
</code></pre><h2 id=what-s-next>What's next</h2>
<ul>
<li>阅读了解<a href=/zh/docs/concepts/extend-kubernetes/api-extension/custom-resources/>定制资源</a></li>
<li>参阅 <a href=/docs/reference/generated/kubernetes-api/v1.23/#customresourcedefinition-v1-apiextensions-k8s-io>CustomResourceDefinition</a></li>
<li>参阅支持 CustomResourceDefinition 的<a href=/zh/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definition-versioning/>多个版本</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-7d2e2400f208b1637530752794e5a3bd>13.1.2 - CustomResourceDefinition 的版本</h1>
<p>本页介绍如何添加版本信息到
<a href=/docs/reference/generated/kubernetes-api/v1.23/#customresourcedefinition-v1beta1-apiextensions>CustomResourceDefinitions</a>。
目的是标明 CustomResourceDefinitions 的稳定级别或者服务于 API 升级。
API 升级时需要在不同 API 表示形式之间进行转换。
本页还描述如何将对象从一个版本升级到另一个版本。</p>
<h2 id=before-you-begin>Before you begin</h2>
<p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li>
</ul>
<p>你应该对<a href=/zh/docs/concepts/extend-kubernetes/api-extension/custom-resources/>定制资源</a>
有一些初步了解。</p>
Your Kubernetes server must be at or later than version v1.16.
To check the version, enter <code>kubectl version</code>.
<h2 id=概览>概览</h2>
<p>CustomResourceDefinition API 提供了用于引入和升级的工作流程到 CustomResourceDefinition
的新版本。</p>
<p>创建 CustomResourceDefinition 时，会在 CustomResourceDefinition <code>spec.versions</code>
列表设置适当的稳定级别和版本号。例如，<code>v1beta1</code> 表示第一个版本尚未稳定。
所有定制资源对象将首先用这个版本保存。</p>
<p>创建 CustomResourceDefinition 后，客户端可以开始使用 <code>v1beta1</code> API。</p>
<p>稍后可能需要添加新版本，例如 <code>v1</code>。</p>
<p>添加新版本：</p>
<ol>
<li>选择一种转化策略。由于定制资源对象需要能够两种版本都可用，
这意味着它们有时会以与存储版本不同的版本来提供服务。为了能够做到这一点，
有时必须在它们存储的版本和提供的版本之间进行转换。如果转换涉及模式变更，
并且需要自定义逻辑，则应该使用 Webhook 来完成。如果没有模式变更，
则可使用默认的 <code>None</code> 转换策略，为不同版本提供服务时只有 <code>apiVersion</code> 字段
会被改变。</li>
<li>如果使用转换 Webhook，请创建并部署转换 Webhook。更多详细信息请参见
<a href=#webhook-conversion>Webhook conversion</a>。</li>
<li>更新 CustomResourceDefinition，将新版本设置为 <code>served：true</code>，加入到
<code>spec.versions</code> 列表。另外，还要设置 <code>spec.conversion</code> 字段
为所选的转换策略。如果使用转换 Webhook，请配置
<code>spec.conversion.webhookClientConfig</code> 来调用 Webhook。</li>
</ol>
<p>添加新版本后，客户端可以逐步迁移到新版本。让某些客户使用旧版本的同时
支持其他人使用新版本是相当安全的。</p>
<p>将存储的对象迁移到新版本：</p>
<ol>
<li>请参阅<a href=#upgrade-existing-objects-to-a-new-stored-version>将现有对象升级到新的存储版本</a>节。</li>
</ol>
<p>对于客户来说，在将对象升级到新的存储版本之前、期间和之后使用旧版本和新版本都是安全的。</p>
<p>删除旧版本：</p>
<ol>
<li>确保所有客户端都已完全迁移到新版本。
可以查看 kube-apiserver 的日志以识别仍通过旧版本进行访问的所有客户端。</li>
<li>在 <code>spec.versions</code> 列表中将旧版本的 <code>served</code> 设置为 <code>false</code>。
如果仍有客户端意外地使用旧版本，他们可能开始会报告采用旧版本尝试访
定制资源的错误消息。
如果发生这种情况，请将旧版本的<code>served：true</code> 恢复，然后迁移余下的客户端
使用新版本，然后重复此步骤。</li>
<li>确保已完成<a href=#upgrade-existing-objects-to-a-new-stored-version>将现有对象升级到新存储版本</a>
的步骤。
<ol>
<li>在 CustomResourceDefinition 的 <code>spec.versions</code> 列表中，确认新版本的
<code>storage</code> 已被设置为 <code>true</code>。</li>
<li>确认旧版本不在 CustomResourceDefinition <code>status.storedVersions</code> 中。</li>
</ol>
</li>
<li>从 CustomResourceDefinition <code>spec.versions</code> 列表中删除旧版本。</li>
<li>在转换 Webhooks 中放弃对旧版本的转换支持。</li>
</ol>
<h2 id=specify-multiple-versions>指定多个版本 </h2>
<p>CustomResourceDefinition API 的 <code>versions</code> 字段可用于支持你所开发的
定制资源的多个版本。版本可以具有不同的模式，并且转换 Webhooks
可以在多个版本之间转换定制资源。
在适当的情况下，Webhook 转换应遵循
<a href=https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md>Kubernetes API 约定</a>。
尤其是，请查阅
<a href=https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api_changes.md>API 变更文档</a>
以了解一些有用的常见错误和建议。</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 在 <code>apiextensions.k8s.io/v1beta1</code> 版本中曾经有一个 <code>version</code> 字段，
名字不叫做 <code>versions</code>。该 <code>version</code> 字段已经被废弃，成为可选项。
不过如果该字段不是空，则必须与 <code>versions</code> 字段中的第一个条目匹配。
</div>
<p>下面的示例显示了两个版本的 CustomResourceDefinition。
第一个例子中假设所有的版本使用相同的模式而它们之间没有转换。
YAML 中的注释提供了更多背景信息。</p>
<ul class="nav nav-tabs" id=customresourcedefinition-versioning-example-1 role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#customresourcedefinition-versioning-example-1-0 role=tab aria-controls=customresourcedefinition-versioning-example-1-0 aria-selected=true>apiextensions.k8s.io/v1</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#customresourcedefinition-versioning-example-1-1 role=tab aria-controls=customresourcedefinition-versioning-example-1-1>apiextensions.k8s.io/v1beta1</a></li></ul>
<div class=tab-content id=customresourcedefinition-versioning-example-1><div id=customresourcedefinition-versioning-example-1-0 class="tab-pane show active" role=tabpanel aria-labelledby=customresourcedefinition-versioning-example-1-0>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apiextensions.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>CustomResourceDefinition<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># name 必须匹配后面 spec 中的字段，且使用格式 &lt;plural&gt;.&lt;group&gt;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>crontabs.example.com<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 组名，用于 REST API: /apis/&lt;group&gt;/&lt;version&gt;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>group</span>:<span style=color:#bbb> </span>example.com<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 此 CustomResourceDefinition 所支持的版本列表</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>versions</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>v1beta1<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 每个 version 可以通过 served 标志启用或禁止</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>served</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 有且只能有一个 version 必须被标记为存储版本</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># schema 是必需字段</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>schema</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>openAPIV3Schema</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>object<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>properties</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>host</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>string<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>string<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>served</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>false</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>schema</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>openAPIV3Schema</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>object<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>properties</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>host</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>string<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>string<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># conversion 节是 Kubernetes 1.13+ 版本引入的，其默认值为无转换，即</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># strategy 子字段设置为 None。</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>conversion</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># None 转换假定所有版本采用相同的模式定义，仅仅将定制资源的 apiVersion</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 设置为合适的值.</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>strategy</span>:<span style=color:#bbb> </span>None<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 可以是 Namespaced 或 Cluster</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>scope</span>:<span style=color:#bbb> </span>Namespaced<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>names</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 名称的复数形式，用于 URL: /apis/&lt;group&gt;/&lt;version&gt;/&lt;plural&gt;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>plural</span>:<span style=color:#bbb> </span>crontabs<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 名称的单数形式，用于在命令行接口和显示时作为其别名</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>singular</span>:<span style=color:#bbb> </span>crontab<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># kind 通常是驼峰编码（CamelCased）的单数形式，用于资源清单中</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>CronTab<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># shortNames 允许你在命令行接口中使用更短的字符串来匹配你的资源</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>shortNames</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- ct<span style=color:#bbb>
</span></code></pre></div></div>
<div id=customresourcedefinition-versioning-example-1-1 class=tab-pane role=tabpanel aria-labelledby=customresourcedefinition-versioning-example-1-1>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#080;font-style:italic># 在 v1.16 中被弃用以推荐使用 apiextensions.k8s.io/v1</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apiextensions.k8s.io/v1beta1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>CustomResourceDefinition<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># name 必须匹配后面 spec 中的字段，且使用格式 &lt;plural&gt;.&lt;group&gt;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>crontabs.example.com<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 组名，用于 REST API: /apis/&lt;group&gt;/&lt;version&gt;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>group</span>:<span style=color:#bbb> </span>example.com<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 此 CustomResourceDefinition 所支持的版本列表</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>versions</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>v1beta1<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 每个 version 可以通过 served 标志启用或禁止</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>served</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 有且只能有一个 version 必须被标记为存储版本</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>served</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>false</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>validation</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>openAPIV3Schema</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>object<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>properties</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>host</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>string<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>string<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># conversion 节是 Kubernetes 1.13+ 版本引入的，其默认值为无转换，即</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># strategy 子字段设置为 None。</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>conversion</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># None 转换假定所有版本采用相同的模式定义，仅仅将定制资源的 apiVersion</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 设置为合适的值.</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>strategy</span>:<span style=color:#bbb> </span>None<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 可以是 Namespaced 或 Cluster</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>scope</span>:<span style=color:#bbb> </span>Namespaced<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>names</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 名称的复数形式，用于 URL: /apis/&lt;group&gt;/&lt;version&gt;/&lt;plural&gt;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>plural</span>:<span style=color:#bbb> </span>crontabs<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 名称的单数形式，用于在命令行接口和显示时作为其别名</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>singular</span>:<span style=color:#bbb> </span>crontab<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># kind 通常是大驼峰编码（PascalCased）的单数形式，用于资源清单中</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>CronTab<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># shortNames 允许你在命令行接口中使用更短的字符串来匹配你的资源</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>shortNames</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- ct<span style=color:#bbb>
</span></code></pre></div></div></div>
<p>你可以将 CustomResourceDefinition 存储在 YAML 文件中，然后使用
<code>kubectl apply</code> 来创建它。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f my-versioned-crontab.yaml
</code></pre></div>
<p>在创建之后，API 服务器开始在 HTTP REST 端点上为每个已启用的版本提供服务。
在上面的示例中，API 版本可以在 <code>/apis/example.com/v1beta1</code> 和
<code>/apis/example.com/v1</code> 处获得。</p>
<h3 id=版本优先级>版本优先级</h3>
<p>不考虑 CustomResourceDefinition 中版本被定义的顺序，kubectl 使用
具有最高优先级的版本作为访问对象的默认版本。
通过解析 <em>name</em> 字段确定优先级来决定版本号，稳定性（GA、Beta 或 Alpha）
级别及该稳定性级别内的序列。</p>
<p>用于对版本进行排序的算法在设计上与 Kubernetes 项目对 Kubernetes 版本进行排序的方式相同。
版本以 <code>v</code> 开头跟一个数字，一个可选的 <code>beta</code> 或者 <code>alpha</code> 和一个可选的附加数字
作为版本信息。
从广义上讲，版本字符串可能看起来像 <code>v2</code> 或者 <code>v2beta1</code>。
使用以下算法对版本进行排序：</p>
<ul>
<li>遵循 Kubernetes 版本模式的条目在不符合条件的条目之前进行排序。</li>
<li>对于遵循 Kubernetes 版本模式的条目，版本字符串的数字部分从最大到最小排序。</li>
<li>如果第一个数字后面有字符串 <code>beta</code> 或 <code>alpha</code>，它们首先按去掉 <code>beta</code> 或
<code>alpha</code> 之后的版本号排序（相当于 GA 版本），之后按 <code>beta</code> 先、<code>alpha</code> 后的顺序排序，</li>
<li>如果 <code>beta</code> 或 <code>alpha</code> 之后还有另一个数字，那么也会针对这些数字
从大到小排序。</li>
<li>不符合上述格式的字符串按字母顺序排序，数字部分不经过特殊处理。
请注意，在下面的示例中，<code>foo1</code> 排在 <code>foo10</code> 之前。
这与遵循 Kubernetes 版本模式的条目的数字部分排序不同。</li>
</ul>
<p>如果查看以下版本排序列表，这些规则就容易懂了：</p>
<pre><code class=language-none data-lang=none>- v10
- v2
- v1
- v11beta2
- v10beta3
- v3beta1
- v12alpha1
- v11alpha2
- foo1
- foo10
</code></pre>
<p>对于<a href=#specify-multiple-versions>指定多个版本</a>中的示例，版本排序顺序为
<code>v1</code>，后跟着 <code>v1beta1</code>。
这导致了 kubectl 命令使用 <code>v1</code> 作为默认版本，除非所提供的对象指定了版本。</p>
<h3 id=版本废弃>版本废弃</h3>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.19 [stable]</code>
</div>
<p>从 v1.19 开始，CustomResourceDefinition 可用来标明所定义的资源的特定版本
被废弃。当发起对已废弃的版本的 API 请求时，会在 API 响应中以 HTTP 头部
的形式返回警告消息。
如果需要，可以对资源的每个废弃版本定制该警告消息。</p>
<p>定制的警告消息应该标明废弃的 API 组、版本和类别（kind），并且应该标明
应该使用（如果有的话）哪个 API 组、版本和类别作为替代。</p>
<ul class="nav nav-tabs" id=customresourcedefinition-versioning-deprecated role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#customresourcedefinition-versioning-deprecated-0 role=tab aria-controls=customresourcedefinition-versioning-deprecated-0 aria-selected=true>apiextensions.k8s.io/v1</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#customresourcedefinition-versioning-deprecated-1 role=tab aria-controls=customresourcedefinition-versioning-deprecated-1>apiextensions.k8s.io/v1beta1</a></li></ul>
<div class=tab-content id=customresourcedefinition-versioning-deprecated><div id=customresourcedefinition-versioning-deprecated-0 class="tab-pane show active" role=tabpanel aria-labelledby=customresourcedefinition-versioning-deprecated-0>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apiextensions.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>CustomResourceDefinition<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>crontabs.example.com<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>group</span>:<span style=color:#bbb> </span>example.com<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>names</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>plural</span>:<span style=color:#bbb> </span>crontabs<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>singular</span>:<span style=color:#bbb> </span>crontab<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>CronTab<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>scope</span>:<span style=color:#bbb> </span>Namespaced<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>versions</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>v1alpha1<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>served</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 此属性标明此定制资源的 v1alpha1 版本已被弃用。</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 发给此版本的 API 请求会在服务器响应中收到警告消息头。</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>deprecated</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 此属性设置用来覆盖返回给发送 v1alpha1 API 请求的客户端的默认警告信息。</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>deprecationWarning</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;example.com/v1alpha1 CronTab is deprecated; see http://example.com/v1alpha1-v1 for instructions to migrate to example.com/v1 CronTab&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>schema</span>:<span style=color:#bbb> </span>...<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>v1beta1<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>served</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 此属性标明该定制资源的 v1beta1 版本已被弃用。</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 发给此版本的 API 请求会在服务器响应中收到警告消息头。</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 针对此版本的请求所返回的是默认的警告消息。</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>deprecated</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>schema</span>:<span style=color:#bbb> </span>...<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>served</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>schema</span>:<span style=color:#bbb> </span>...<span style=color:#bbb>
</span></code></pre></div></div>
<div id=customresourcedefinition-versioning-deprecated-1 class=tab-pane role=tabpanel aria-labelledby=customresourcedefinition-versioning-deprecated-1>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#080;font-style:italic># 在 v1.16 中弃用以推荐使用  apiextensions.k8s.io/v1</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apiextensions.k8s.io/v1beta1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>CustomResourceDefinition<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>crontabs.example.com<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>group</span>:<span style=color:#bbb> </span>example.com<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>names</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>plural</span>:<span style=color:#bbb> </span>crontabs<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>singular</span>:<span style=color:#bbb> </span>crontab<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>CronTab<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>scope</span>:<span style=color:#bbb> </span>Namespaced<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>validation</span>:<span style=color:#bbb> </span>...<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>versions</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>v1alpha1<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>served</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 此属性标明此定制资源的 v1alpha1 版本已被弃用。</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 发给此版本的 API 请求会在服务器响应中收到警告消息头。</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>deprecated</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 此属性设置用来覆盖返回给发送 v1alpha1 API 请求的客户端的默认警告信息。</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>deprecationWarning</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;example.com/v1alpha1 CronTab is deprecated; see http://example.com/v1alpha1-v1 for instructions to migrate to example.com/v1 CronTab&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>v1beta1<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>served</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 此属性标明该定制资源的 v1beta1 版本已被弃用。</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 发给此版本的 API 请求会在服务器响应中收到警告消息头。</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 针对此版本的请求所返回的是默认的警告消息。</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>deprecated</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>served</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></code></pre></div></div></div>
<h2 id=webhook-conversion>Webhook 转换 </h2>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.16 [stable]</code>
</div>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> Webhook 转换在 Kubernetes 1.13 版本引入，在 Kubernetes 1.15 中成为 Beta 功能。
要使用此功能，应启用 <code>CustomResourceWebhookConversion</code> 特性。
在大多数集群上，这类 Beta 特性应该是自动启用的。
请参阅<a href=/zh/docs/reference/command-line-tools-reference/feature-gates/>特性门控</a>
文档以获得更多信息。
</div>
<p>上面的例子在版本之间有一个 None 转换，它只在转换时设置 <code>apiVersion</code> 字段
而不改变对象的其余部分。API 服务器还支持在需要转换时调用外部服务的 webhook 转换。
例如：</p>
<ul>
<li>定制资源的请求版本与其存储版本不同。</li>
<li>使用某版本创建了 Watch 请求，但所更改对象以另一版本存储。</li>
<li>定制资源的 PUT 请求所针对版本与存储版本不同。</li>
</ul>
<p>为了涵盖所有这些情况并优化 API 服务器所作的转换，转换请求可以包含多个对象，
以便减少外部调用。Webhook 应该独立执行各个转换。</p>
<h3 id=编写一个转换-webhook-服务器>编写一个转换 Webhook 服务器</h3>
<p>请参考<a href=https://github.com/kubernetes/kubernetes/tree/v1.15.0/test/images/crd-conversion-webhook/main.go>定制资源转换 Webhook 服务器</a>
的实现；该实现在 Kubernetes e2e 测试中得到验证。
Webhook 处理由 API 服务器发送的 <code>ConversionReview</code> 请求，并在
<code>ConversionResponse</code> 中封装发回转换结果。
请注意，请求包含需要独立转换的定制资源列表，这些对象在被转换之后不能改变其
在列表中的顺序。该示例服务器的组织方式使其可以复用于其他转换。
大多数常见代码都位于
<a href=https://github.com/kubernetes/kubernetes/tree/v1.15.0/test/images/crd-conversion-webhook/converter/framework.go>framework 文件</a>
中，只留下
<a href=https://github.com/kubernetes/kubernetes/blob/v1.13.0/test/images/crd-conversion-webhook/converter/example_converter.go#L29-L80>一个函数</a>
用于实现不同的转换。</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 转换 Webhook 服务器示例中将 <code>ClientAuth</code> 字段设置为
<a href=https://github.com/kubernetes/kubernetes/tree/v1.13.0/test/images/crd-conversion-webhook/config.go#L47-L48>空</a>，
默认为 <code>NoClientCert</code>。
这意味着 webhook 服务器没有验证客户端（也就是 API 服务器）的身份。
如果你需要双向 TLS 或者其他方式来验证客户端，请参阅如何
<a href=/zh/docs/reference/access-authn-authz/extensible-admission-controllers/#authenticate-apiservers>验证 API 服务</a>。
</div>
<h4 id=被允许的变更>被允许的变更</h4>
<p>转换 Webhook 不可以更改被转换对象的 <code>metadata</code> 中除 <code>labels</code> 和 <code>annotations</code>
之外的任何属性。
尝试更改 <code>name</code>、<code>UID</code> 和 <code>namespace</code> 时都会导致引起转换的请求失败。
所有其他变更都被忽略。</p>
<h3 id=部署转换-webhook-服务>部署转换 Webhook 服务</h3>
<p>用于部署转换 webhook 的文档与
<a href=/zh/docs/reference/access-authn-authz/extensible-admission-controllers/#deploy_the_admission_webhook_service>准入 Webhook 服务示例</a>相同。
这里的假设是转换 Webhook 服务器被部署为 <code>default</code> 名字空间中名为
<code>example-conversion-webhook-server</code> 的服务，并在路径 <code>/crdconvert</code>
上处理请求。</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 当 Webhook 服务器作为一个服务被部署到 Kubernetes 集群中时，它必须
通过端口 443 公开其服务（服务器本身可以使用任意端口，但是服务对象
应该将它映射到端口 443）。
如果为服务器使用不同的端口，则 API 服务器和 Webhook 服务器之间的通信
可能会失败。
</div>
<h3 id=配置-customresourcedefinition-以使用转换-webhook>配置 CustomResourceDefinition 以使用转换 Webhook</h3>
<p>通过修改 <code>spec</code> 中的 <code>conversion</code> 部分，可以扩展 <code>None</code> 转换示例来
使用转换 Webhook。</p>
<ul class="nav nav-tabs" id=customresourcedefinition-versioning-example-2 role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#customresourcedefinition-versioning-example-2-0 role=tab aria-controls=customresourcedefinition-versioning-example-2-0 aria-selected=true>apiextensions.k8s.io/v1</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#customresourcedefinition-versioning-example-2-1 role=tab aria-controls=customresourcedefinition-versioning-example-2-1>apiextensions.k8s.io/v1beta1</a></li></ul>
<div class=tab-content id=customresourcedefinition-versioning-example-2><div id=customresourcedefinition-versioning-example-2-0 class="tab-pane show active" role=tabpanel aria-labelledby=customresourcedefinition-versioning-example-2-0>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apiextensions.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>CustomResourceDefinition<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># name 必须匹配后面 spec 中的字段，且使用格式 &lt;plural&gt;.&lt;group&gt;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>crontabs.example.com<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 组名，用于 REST API: /apis/&lt;group&gt;/&lt;version&gt;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>group</span>:<span style=color:#bbb> </span>example.com<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 此 CustomResourceDefinition 所支持的版本列表</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>versions</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>v1beta1<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 每个 version 可以通过 served 标志启用或禁止</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>served</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 有且只能有一个 version 必须被标记为存储版本</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 当不存在顶级模式定义时，每个版本（version）可以定义其自身的模式</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>schema</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>openAPIV3Schema</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>object<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>properties</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>hostPort</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>string<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>served</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>false</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>schema</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>openAPIV3Schema</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>object<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>properties</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>host</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>string<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>string<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>conversion</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># Webhook strategy 告诉 API 服务器调用外部 Webhook 来完成定制资源</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 之间的转换</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>strategy</span>:<span style=color:#bbb> </span>Webhook<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 当 strategy 为 &#34;Webhook&#34; 时，webhook 属性是必需的</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 该属性配置将被 API 服务器调用的 Webhook 端点</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>webhook</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># conversionReviewVersions 标明 Webhook 所能理解或偏好使用的</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># ConversionReview 对象版本。</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># API 服务器所能理解的列表中的第一个版本会被发送到 Webhook</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># Webhook 必须按所接收到的版本响应一个 ConversionReview 对象</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>conversionReviewVersions</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;v1&#34;</span>,<span style=color:#b44>&#34;v1beta1&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>clientConfig</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>example-conversion-webhook-server<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/crdconvert<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>caBundle</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;Ci0tLS0tQk...&lt;base64-encoded PEM bundle&gt;...tLS0K&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 可以是 Namespaced 或 Cluster</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>scope</span>:<span style=color:#bbb> </span>Namespaced<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>names</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 名称的复数形式，用于 URL: /apis/&lt;group&gt;/&lt;version&gt;/&lt;plural&gt;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>plural</span>:<span style=color:#bbb> </span>crontabs<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 名称的单数形式，用于在命令行接口和显示时作为其别名</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>singular</span>:<span style=color:#bbb> </span>crontab<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># kind 通常是驼峰编码（CamelCased）的单数形式，用于资源清单中</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>CronTab<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># shortNames 允许你在命令行接口中使用更短的字符串来匹配你的资源</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>shortNames</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- ct<span style=color:#bbb>
</span></code></pre></div></div>
<div id=customresourcedefinition-versioning-example-2-1 class=tab-pane role=tabpanel aria-labelledby=customresourcedefinition-versioning-example-2-1>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#080;font-style:italic># 在 v1.16 中被弃用以推荐使用 apiextensions.k8s.io/v1</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apiextensions.k8s.io/v1beta1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>CustomResourceDefinition<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># name 必须匹配后面 spec 中的字段，且使用格式 &lt;plural&gt;.&lt;group&gt;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>crontabs.example.com<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 组名，用于 REST API: /apis/&lt;group&gt;/&lt;version&gt;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>group</span>:<span style=color:#bbb> </span>example.com<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 裁剪掉下面的 OpenAPI 模式中未曾定义的对象字段</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>preserveUnknownFields</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>false</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 此 CustomResourceDefinition 所支持的版本列表</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>versions</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>v1beta1<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 每个 version 可以通过 served 标志启用或禁止</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>served</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 有且只能有一个 version 必须被标记为存储版本</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 当不存在顶级模式定义时，每个版本（version）可以定义其自身的模式</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>schema</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>openAPIV3Schema</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>object<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>properties</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>hostPort</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>string<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>served</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>false</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>schema</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>openAPIV3Schema</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>object<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>properties</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>host</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>string<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>string<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>conversion</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># Webhook strategy 告诉 API 服务器调用外部 Webhook 来完成定制资源</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>strategy</span>:<span style=color:#bbb> </span>Webhook<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 当 strategy 为 &#34;Webhook&#34; 时，webhookClientConfig 属性是必需的</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 该属性配置将被 API 服务器调用的 Webhook 端点</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>webhookClientConfig</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>service</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>example-conversion-webhook-server<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/crdconvert<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>caBundle</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;Ci0tLS0tQk...&lt;base64-encoded PEM bundle&gt;...tLS0K&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 可以是 Namespaced 或 Cluster</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>scope</span>:<span style=color:#bbb> </span>Namespaced<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>names</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 名称的复数形式，用于 URL: /apis/&lt;group&gt;/&lt;version&gt;/&lt;plural&gt;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>plural</span>:<span style=color:#bbb> </span>crontabs<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 名称的单数形式，用于在命令行接口和显示时作为其别名</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>singular</span>:<span style=color:#bbb> </span>crontab<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># kind 通常是驼峰编码（CamelCased）的单数形式，用于资源清单中</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>CronTab<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># shortNames 允许你在命令行接口中使用更短的字符串来匹配你的资源</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>shortNames</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- ct<span style=color:#bbb>
</span></code></pre></div></div></div>
<p>你可以将 CustomResourceDefinition 保存在 YAML 文件中，然后使用
<code>kubectl apply</code> 来应用它。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f my-versioned-crontab-with-conversion.yaml
</code></pre></div>
<p>在应用新更改之前，请确保转换服务器已启动并正在运行。</p>
<h3 id=调用-webhook>调用 Webhook</h3>
<p>API 服务器一旦确定请求应发送到转换 Webhook，它需要知道如何调用 Webhook。
这是在 <code>webhookClientConfig</code> 中指定的 Webhook 配置。</p>
<p>转换 Webhook 可以通过 URL 或服务引用来调用，并且可以选择包含自定义 CA 包，
以用于验证 TLS 连接。</p>
<h3 id=url>URL</h3>
<p>url 以标准 URL 形式给出 Webhook 的位置（<code>scheme://host:port/path</code>）。
<code>host</code> 不应引用集群中运行的服务，而应通过指定 <code>service</code> 字段来提供
服务引用。
在某些 API 服务器中，<code>host</code> 可以通过外部 DNS 进行解析（即
<code>kube-apiserver</code> 无法解析集群内 DNS，那样会违反分层规则）。
<code>host</code> 也可以是 IP 地址。</p>
<p>请注意，除非你非常小心地在所有运行着可能调用 Webhook 的 API 服务器的
主机上运行此 Webhook，否则将 <code>localhost</code> 或 <code>127.0.0.1</code> 用作 <code>host</code>
是风险很大的。这样的安装可能是不可移植的，或者不容易在一个新的集群中运行。</p>
<p>HTTP 协议必须为 <code>https</code>；URL 必须以 <code>https://</code> 开头。</p>
<p>尝试使用用户或基本身份验证（例如，使用<code>user:password@</code>）是不允许的。
URL 片段（<code>#...</code>）和查询参数（<code>?...</code>）也是不允许的。</p>
<p>下面是为调用 URL 来执行转换 Webhook 的示例，其中期望使用系统信任根
来验证 TLS 证书，因此未指定 caBundle：</p>
<ul class="nav nav-tabs" id=customresourcedefinition-versioning-example-3 role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#customresourcedefinition-versioning-example-3-0 role=tab aria-controls=customresourcedefinition-versioning-example-3-0 aria-selected=true>apiextensions.k8s.io/v1</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#customresourcedefinition-versioning-example-3-1 role=tab aria-controls=customresourcedefinition-versioning-example-3-1>apiextensions.k8s.io/v1beta1</a></li></ul>
<div class=tab-content id=customresourcedefinition-versioning-example-3><div id=customresourcedefinition-versioning-example-3-0 class="tab-pane show active" role=tabpanel aria-labelledby=customresourcedefinition-versioning-example-3-0>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apiextensions.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>CustomResourceDefinition<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>conversion</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>strategy</span>:<span style=color:#bbb> </span>Webhook<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>webhook</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>clientConfig</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>url</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;https://my-webhook.example.com:9443/my-webhook-path&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></code></pre></div></div>
<div id=customresourcedefinition-versioning-example-3-1 class=tab-pane role=tabpanel aria-labelledby=customresourcedefinition-versioning-example-3-1>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#080;font-style:italic># 在 v1.16 中已弃用以推荐使用 apiextensions.k8s.io/v1</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apiextensions.k8s.io/v1beta1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>CustomResourceDefinition<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>conversion</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>strategy</span>:<span style=color:#bbb> </span>Webhook<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>webhookClientConfig</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>url</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;https://my-webhook.example.com:9443/my-webhook-path&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></code></pre></div></div></div>
<h3 id=服务引用>服务引用</h3>
<p><code>webhookClientConfig</code> 内部的 <code>service</code> 段是对转换 Webhook 服务的引用。
如果 Webhook 在集群中运行，则应使用 <code>service</code> 而不是 <code>url</code>。
服务的名字空间和名称是必需的。端口是可选的，默认为 443。
路径是可选的，默认为<code>/</code>。</p>
<p>下面配置中，服务配置为在端口 <code>1234</code>、子路径 <code>/my-path</code> 上被调用。
例子中针对 ServerName <code>my-service-name.my-service-namespace.svc</code>，
使用自定义 CA 包验证 TLS 连接。</p>
<ul class="nav nav-tabs" id=customresourcedefinition-versioning-example-4 role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#customresourcedefinition-versioning-example-4-0 role=tab aria-controls=customresourcedefinition-versioning-example-4-0 aria-selected=true>apiextensions.k8s.io/v1</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#customresourcedefinition-versioning-example-4-1 role=tab aria-controls=customresourcedefinition-versioning-example-4-1>apiextensions.k8s.io/v1beta1</a></li></ul>
<div class=tab-content id=customresourcedefinition-versioning-example-4><div id=customresourcedefinition-versioning-example-4-0 class="tab-pane show active" role=tabpanel aria-labelledby=customresourcedefinition-versioning-example-4-0>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apiextensions.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>CustomResourceDefinition<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>conversion</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>strategy</span>:<span style=color:#bbb> </span>Webhook<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>webhook</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>clientConfig</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>my-service-namespace<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service-name<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/my-path<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>1234</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>caBundle</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;Ci0tLS0tQk...&lt;base64-encoded PEM bundle&gt;...tLS0K&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></code></pre></div></div>
<div id=customresourcedefinition-versioning-example-4-1 class=tab-pane role=tabpanel aria-labelledby=customresourcedefinition-versioning-example-4-1>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#080;font-style:italic>#  v1.16 中被弃用以推荐使用 apiextensions.k8s.io/v1</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apiextensions.k8s.io/v1beta1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>CustomResourceDefinition<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>conversion</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>strategy</span>:<span style=color:#bbb> </span>Webhook<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>webhookClientConfig</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>service</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>my-service-namespace<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service-name<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/my-path<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>1234</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>caBundle</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;Ci0tLS0tQk...&lt;base64-encoded PEM bundle&gt;...tLS0K&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></code></pre></div></div></div>
<h2 id=webhook-请求和响应>Webhook 请求和响应</h2>
<h3 id=请求>请求</h3>
<p>向 Webhooks 发起请求的动词是 POST，请求的 <code>Content-Type</code> 为 <code>application/json</code>。
请求的主题为 JSON 序列化形式的
apiextensions.k8s.io API 组的 ConversionReview API 对象。</p>
<p>Webhooks 可以在其 CustomResourceDefinition 中使用<code>conversionReviewVersions</code> 字段
设置它们接受的 <code>ConversionReview</code> 对象的版本：</p>
<ul class="nav nav-tabs" id=conversionreviewversions role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#conversionreviewversions-0 role=tab aria-controls=conversionreviewversions-0 aria-selected=true>apiextensions.k8s.io/v1</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#conversionreviewversions-1 role=tab aria-controls=conversionreviewversions-1>apiextensions.k8s.io/v1beta1</a></li></ul>
<div class=tab-content id=conversionreviewversions><div id=conversionreviewversions-0 class="tab-pane show active" role=tabpanel aria-labelledby=conversionreviewversions-0>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apiextensions.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>CustomResourceDefinition<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>conversion</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>strategy</span>:<span style=color:#bbb> </span>Webhook<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>webhook</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>conversionReviewVersions</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;v1&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;v1beta1&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>      </span>...<span style=color:#bbb>
</span></code></pre></div>
<p>创建 <code>apiextensions.k8s.io/v1</code> 版本的自定义资源定义时，
<code>conversionReviewVersions</code>是必填字段。
Webhooks 要求支持至少一个 <code>ConversionReview</code> 当前和以前的 API 服务器
可以理解的版本。</p>
</div>
<div id=conversionreviewversions-1 class=tab-pane role=tabpanel aria-labelledby=conversionreviewversions-1>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#080;font-style:italic># v1.16 已弃用以推荐使用 apiextensions.k8s.io/v1</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apiextensions.k8s.io/v1beta1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>CustomResourceDefinition<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>conversion</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>strategy</span>:<span style=color:#bbb> </span>Webhook<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>conversionReviewVersions</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;v1&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;v1beta1&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span>...<span style=color:#bbb>
</span></code></pre></div>
<p>创建 apiextensions.k8s.io/v1beta1 定制资源定义时若未指定
<code>conversionReviewVersions</code>，则默认值为 v1beta1。</p>
</div></div>
<p>API 服务器将 <code>conversionReviewVersions</code> 列表中他们所支持的第一个
<code>ConversionReview</code> 资源版本发送给 Webhook。
如果列表中的版本都不被 API 服务器支持，则无法创建自定义资源定义。
如果某 API 服务器遇到之前创建的转换 Webhook 配置，并且该配置不支持
API 服务器知道如何发送的任何 <code>ConversionReview</code> 版本，调用 Webhook
的尝试会失败。</p>
<p>下面的示例显示了包含在 <code>ConversionReview</code> 对象中的数据，
该请求意在将 <code>CronTab</code> 对象转换为 <code>example.com/v1</code>：</p>
<ul class="nav nav-tabs" id=conversionreview-request role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#conversionreview-request-0 role=tab aria-controls=conversionreview-request-0 aria-selected=true>apiextensions.k8s.io/v1</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#conversionreview-request-1 role=tab aria-controls=conversionreview-request-1>apiextensions.k8s.io/v1beta1</a></li></ul>
<div class=tab-content id=conversionreview-request><div id=conversionreview-request-0 class="tab-pane show active" role=tabpanel aria-labelledby=conversionreview-request-0>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apiextensions.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConversionReview<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>request</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 用来唯一标识此转换调用的随机 UID</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>uid</span>:<span style=color:#bbb> </span>705ab4f5-6393-11e8-b7cc-42010a800002<span style=color:#bbb>
</span><span style=color:#bbb>  
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 对象要转换到的目标 API 组和版本</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>desiredAPIVersion</span>:<span style=color:#bbb> </span>example.com/v1<span style=color:#bbb>
</span><span style=color:#bbb>  
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 要转换的对象列表</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 其中可能包含一个或多个对象，版本可能相同也可能不同</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>objects</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>CronTab<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>example.com/v1beta1<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>creationTimestamp</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2019-09-04T14:03:02Z&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>local-crontab<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>resourceVersion</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;143&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>uid</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;3415a7fc-162b-4300-b5da-fd6083580d66&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>hostPort</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;localhost:1234&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>CronTab<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>example.com/v1beta1<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>creationTimestamp</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2019-09-03T13:02:01Z&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>remote-crontab<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>resourceVersion</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;12893&#34;</span>,<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>uid</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;359a83ec-b575-460d-b553-d859cedde8a0&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>hostPort</span>:<span style=color:#bbb> </span>example.com:2345<span style=color:#bbb>
</span></code></pre></div></div>
<div id=conversionreview-request-1 class=tab-pane role=tabpanel aria-labelledby=conversionreview-request-1>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#080;font-style:italic># v1.16 中已废弃以推荐使用 apiextensions.k8s.io/v1</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apiextensions.k8s.io/v1beta1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConversionReview<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>request</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 用来唯一标识此转换调用的随机 UID</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>uid</span>:<span style=color:#bbb> </span>705ab4f5-6393-11e8-b7cc-42010a800002<span style=color:#bbb>
</span><span style=color:#bbb>  
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 对象要转换到的目标 API 组和版本</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>desiredAPIVersion</span>:<span style=color:#bbb> </span>example.com/v1<span style=color:#bbb>
</span><span style=color:#bbb>  
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 要转换的对象列表</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 其中可能包含一个或多个对象，版本可能相同也可能不同</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>objects</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>CronTab<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>example.com/v1beta1<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>creationTimestamp</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2019-09-04T14:03:02Z&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>local-crontab<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>resourceVersion</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;143&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>uid</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;3415a7fc-162b-4300-b5da-fd6083580d66&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>hostPort</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;localhost:1234&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>CronTab<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>example.com/v1beta1<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>creationTimestamp</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2019-09-03T13:02:01Z&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>remote-crontab<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>resourceVersion</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;12893&#34;</span>,<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>uid</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;359a83ec-b575-460d-b553-d859cedde8a0&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>hostPort</span>:<span style=color:#bbb> </span>example.com:2345<span style=color:#bbb>
</span></code></pre></div></div></div>
<h3 id=响应>响应</h3>
<p>Webhooks 响应包含 200 HTTP 状态代码、<code>Content-Type: application/json</code>，
在主体中包含 JSON 序列化形式的数据，在 <code>response</code> 节中给出
ConversionReview 对象（与发送的版本相同）。</p>
<p>如果转换成功，则 Webhook 应该返回包含以下字段的 <code>response</code> 节：</p>
<ul>
<li><code>uid</code>，从发送到 webhook 的 <code>request.uid</code> 复制而来</li>
<li><code>result</code>，设置为 <code>{"status":"Success"}}</code></li>
<li><code>convertedObjects</code>，包含来自 <code>request.objects</code> 的所有对象，均已转换为
<code>request.desiredVersion</code></li>
</ul>
<p>Webhook 的最简单成功响应示例：</p>
<ul class="nav nav-tabs" id=conversionreview-response-success role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#conversionreview-response-success-0 role=tab aria-controls=conversionreview-response-success-0 aria-selected=true>apiextensions.k8s.io/v1</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#conversionreview-response-success-1 role=tab aria-controls=conversionreview-response-success-1>apiextensions.k8s.io/v1beta1</a></li></ul>
<div class=tab-content id=conversionreview-response-success><div id=conversionreview-response-success-0 class="tab-pane show active" role=tabpanel aria-labelledby=conversionreview-response-success-0>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apiextensions.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConversionReview<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>response</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 必须与 &lt;request.uid&gt; 匹配</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>uid</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;705ab4f5-6393-11e8-b7cc-42010a800002&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>result</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb> </span>Success<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 这里的对象必须与 request.objects 中的对象顺序相同并且其 apiVersion</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 被设置为 &lt;request.desiredAPIVersion&gt;。</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># kind、metadata.uid、metadata.name 和 metadata.namespace 等字段都不可</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 被 Webhook 修改。</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># Webhook 可以更改 metadata.labels 和 metadata.annotations 字段值</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># Webhook 对 metadata 中其他字段的更改都会被忽略</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>convertedObjects</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>CronTab<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>example.com/v1<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>creationTimestamp</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2019-09-04T14:03:02Z&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>local-crontab<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>resourceVersion</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;143&#34;</span>,<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>uid</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;3415a7fc-162b-4300-b5da-fd6083580d66&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>host</span>:<span style=color:#bbb> </span>localhost<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;1234&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>CronTab<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>example.com/v1<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>creationTimestamp</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2019-09-03T13:02:01Z&#34;</span>,<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>remote-crontab<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>resourceVersion</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;12893&#34;</span>,<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>uid</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;359a83ec-b575-460d-b553-d859cedde8a0&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>host</span>:<span style=color:#bbb> </span>example.com<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2345&#34;</span><span style=color:#bbb>
</span></code></pre></div></div>
<div id=conversionreview-response-success-1 class=tab-pane role=tabpanel aria-labelledby=conversionreview-response-success-1>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#080;font-style:italic># v1.16 中已弃用以推荐使用  apiextensions.k8s.io/v1</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apiextensions.k8s.io/v1beta1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConversionReview<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>response</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 必须与 &lt;request.uid&gt; 匹配</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>uid</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;705ab4f5-6393-11e8-b7cc-42010a800002&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>result</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb> </span>Failed<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 这里的对象必须与 request.objects 中的对象顺序相同并且其 apiVersion</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 被设置为 &lt;request.desiredAPIVersion&gt;。</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># kind、metadata.uid、metadata.name 和 metadata.namespace 等字段都不可</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 被 Webhook 修改。</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># Webhook 可以更改 metadata.labels 和 metadata.annotations 字段值</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># Webhook 对 metadata 中其他字段的更改都会被忽略</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>convertedObjects</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>CronTab<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>example.com/v1<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>creationTimestamp</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2019-09-04T14:03:02Z&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>local-crontab<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>resourceVersion</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;143&#34;</span>,<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>uid</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;3415a7fc-162b-4300-b5da-fd6083580d66&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>host</span>:<span style=color:#bbb> </span>localhost<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;1234&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>CronTab<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>example.com/v1<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>creationTimestamp</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2019-09-03T13:02:01Z&#34;</span>,<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>remote-crontab<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>resourceVersion</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;12893&#34;</span>,<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>uid</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;359a83ec-b575-460d-b553-d859cedde8a0&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>host</span>:<span style=color:#bbb> </span>example.com<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2345&#34;</span><span style=color:#bbb>
</span></code></pre></div></div></div>
<p>如果转换失败，则 Webhook 应该返回包含以下字段的 <code>response</code> 节：</p>
<ul>
<li><code>uid</code>，从发送到 Webhook 的 <code>request.uid</code> 复制而来</li>
<li><code>result</code>，设置为 <code>{"status": "Failed"}</code></li>
</ul>
<div class="alert alert-danger warning callout" role=alert>
<strong>Warning:</strong>
<p>转换失败会破坏对定制资源的读写访问，包括更新或删除资源的能力。
转换失败应尽可能避免，并且不可用于实施合法性检查约束
（应改用验证模式或 Webhook 准入插件）。
</div>
<p>来自 Webhook 的响应示例，指示转换请求失败，并带有可选消息：</p>
<ul class="nav nav-tabs" id=conversionreview-response-failure role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#conversionreview-response-failure-0 role=tab aria-controls=conversionreview-response-failure-0 aria-selected=true>apiextensions.k8s.io/v1</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#conversionreview-response-failure-1 role=tab aria-controls=conversionreview-response-failure-1>apiextensions.k8s.io/v1beta1</a></li></ul>
<div class=tab-content id=conversionreview-response-failure><div id=conversionreview-response-failure-0 class="tab-pane show active" role=tabpanel aria-labelledby=conversionreview-response-failure-0>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apiextensions.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConversionReview<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>response</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>uid</span>:<span style=color:#bbb> </span>&lt;value from request.uid&gt;<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>result</span>:<span style=color:#bbb> </span>{<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb> </span>Failed<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>message</span>:<span style=color:#bbb> </span>hostPort could not be parsed into a separate host and port<span style=color:#bbb>
</span></code></pre></div></div>
<div id=conversionreview-response-failure-1 class=tab-pane role=tabpanel aria-labelledby=conversionreview-response-failure-1>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># v1.16 中弃用以推荐使用 apiextensions.k8s.io/v1</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apiextensions.k8s.io/v1beta1<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConversionReview<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>response</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>uid</span>:<span style=color:#bbb> </span>&lt;value from request.uid&gt;<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>result</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb> </span>Failed<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>message</span>:<span style=color:#bbb> </span>hostPort could not be parsed into a separate host and port<span style=color:#bbb>
</span></code></pre></div></div></div>
<h2 id=编写-读取和更新版本化的-customresourcedefinition-对象>编写、读取和更新版本化的 CustomResourceDefinition 对象</h2>
<p>写入对象时，将使用写入时指定的存储版本来存储。如果存储版本发生变化，
现有对象永远不会被自动转换。然而，新创建或被更新的对象将以新的存储版本写入。
对象写入的版本不再被支持是有可能的。</p>
<p>当读取对象时，作为路径的一部分，你需要指定版本。
如果所指定的版本与对象的持久版本不同，Kubernetes 会按所请求的版本将对象返回，
但是在满足服务请求时，被持久化的对象既不会在磁盘上更改，也不会以任何方式进行
转换（除了 <code>apiVersion</code> 字符串被更改之外）。你可以以当前提供的任何版本
来请求对象。</p>
<p>如果你更新一个现有对象，它将以当前的存储版本被重写。
这是可以将对象从一个版本改到另一个版本的唯一办法。</p>
<p>为了说明这一点，请考虑以下假设的一系列事件：</p>
<ol>
<li>存储版本是 <code>v1beta1</code>。你创建一个对象。该对象以版本 <code>v1beta1</code> 存储。</li>
<li>你将为 CustomResourceDefinition 添加版本 <code>v1</code>，并将其指定为存储版本。</li>
<li>你使用版本 <code>v1beta1</code> 来读取你的对象，然后你再次用版本 <code>v1</code> 读取对象。
除了 apiVersion 字段之外，返回的两个对象是完全相同的。</li>
<li>你创建一个新对象。对象以版本 <code>v1</code> 保存在存储中。
你现在有两个对象，其中一个是 <code>v1beta1</code>，另一个是 <code>v1</code>。</li>
<li>你更新第一个对象。该对象现在以版本 <code>v1</code> 保存，因为 <code>v1</code> 是当前的存储版本。</li>
</ol>
<h3 id=以前的存储版本>以前的存储版本</h3>
<p>API 服务器在状态字段 <code>storedVersions</code> 中记录曾被标记为存储版本的每个版本。
对象可能以任何曾被指定为存储版本的版本保存。
存储中不会出现从未成为存储版本的版本的对象。</p>
<h2 id=upgrade-existing-objects-to-a-new-stored-version>将现有对象升级到新的存储版本 </h2>
<p>弃用版本并删除其支持时，请设计存储升级过程。</p>
<p><em>选项 1：</em> 使用存储版本迁移程序（Storage Version Migrator）</p>
<ol>
<li>运行<a href=https://github.com/kubernetes-sigs/kube-storage-version-migrator>存储版本迁移程序</a></li>
<li>从 CustomResourceDefinition 的 <code>status.storedVersions</code> 字段中去掉
老的版本。</li>
</ol>
<p><em>选项 2：</em> 手动将现有对象升级到新的存储版本</p>
<p>以下是从 <code>v1beta1</code> 升级到 <code>v1</code> 的示例过程。</p>
<ol>
<li>在 CustomResourceDefinition 文件中将 <code>v1</code> 设置为存储版本，并使用 kubectl 应用它。
<code>storedVersions</code>现在是<code>v1beta1, v1</code>。</li>
<li>编写升级过程以列出所有现有对象并使用相同内容将其写回存储。
这会强制后端使用当前存储版本（即 <code>v1</code>）写入对象。</li>
<li>从 CustomResourceDefinition 的 <code>status.storedVersions</code> 字段中删除 <code>v1beta1</code>。</li>
</ol>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> <p><code>kubectl</code> 工具目前不能用于编辑或修补 CRD 上的 <code>status</code> 子资源：请参阅
<a href=https://github.com/kubernetes/enhancements/tree/master/keps/sig-cli/2590-kubectl-subresource>kubectl Subresource Support KEP</a>
了解更多细节。</p>
<p>从 CLI 给 <code>status</code> 子资源打补丁的更简单的方法是使用 <code>curl</code> 工具直接与 API 服务器交互，示例:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl proxy &amp;
curl --header <span style=color:#b44>&#34;Content-Type: application/json-patch+json&#34;</span> <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --request PATCH http://localhost:8001/apis/apiextensions.k8s.io/v1/customresourcedefinitions/&lt;your CRD name here&gt;/status <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --data <span style=color:#b44>&#39;[{&#34;op&#34;: &#34;replace&#34;, &#34;path&#34;: &#34;/status/storedVersions&#34;, &#34;value&#34;:[&#34;v1&#34;]}]&#39;</span>
</code></pre></div>
</div>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-2bd28753e62a14a597073fa8ea18a5d8>13.2 - 配置聚合层</h1>
<p>配置<a href=/zh/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/>聚合层</a>
可以允许 Kubernetes apiserver 使用其它 API 扩展，这些 API 不是核心
Kubernetes API 的一部分。</p>
<h2 id=before-you-begin>Before you begin</h2>
<p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li>
</ul>
To check the version, enter <code>kubectl version</code>.
</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 要使聚合层在你的环境中正常工作以支持代理服务器和扩展 apiserver 之间的相互 TLS 身份验证，
需要满足一些设置要求。Kubernetes 和 kube-apiserver 具有多个 CA，
因此请确保代理是由聚合层 CA 签名的，而不是由 Kubernetes 通用 CA 签名的。
</div>
<div class="alert alert-warning caution callout" role=alert>
<strong>Caution:</strong> 对不同的客户端类型重复使用相同的 CA 会对群集的功能产生负面影响。
有关更多信息，请参见 <a href=#ca-reusage-and-conflicts>CA 重用和冲突</a>。
</div>
<h2 id=身份认证流程>身份认证流程</h2>
<p>与自定义资源定义（CRD）不同，除标准的 Kubernetes apiserver 外，Aggregation API
还涉及另一个服务器：扩展 apiserver。
Kubernetes apiserver 将需要与你的扩展 apiserver 通信，并且你的扩展 apiserver
也需要与 Kubernetes apiserver 通信。
为了确保此通信的安全，Kubernetes apiserver 使用 x509 证书向扩展 apiserver 认证。</p>
<p>本节介绍身份认证和鉴权流程的工作方式以及如何配置它们。</p>
<p>大致流程如下：</p>
<ol>
<li>Kubernetes apiserver：对发出请求的用户身份认证，并对请求的 API 路径执行鉴权。</li>
<li>Kubernetes apiserver：将请求转发到扩展 apiserver</li>
<li>扩展 apiserver：认证来自 Kubernetes apiserver 的请求</li>
<li>扩展 apiserver：对来自原始用户的请求鉴权</li>
<li>扩展 apiserver：执行</li>
</ol>
<p>本节的其余部分详细描述了这些步骤。</p>
<p>该流程可以在下图中看到。</p>
<p><img src=/images/docs/aggregation-api-auth-flow.png alt=聚合层认证流程>.</p>
<p>以上泳道的来源可以在本文档的源码中找到。</p>
<h3 id=kubernetes-apiserver-认证和授权>Kubernetes Apiserver 认证和授权</h3>
<p>由扩展 apiserver 服务的对 API 路径的请求以与所有 API 请求相同的方式开始：
与 Kubernetes apiserver 的通信。该路径已通过扩展 apiserver 在
Kubernetes apiserver 中注册。</p>
<p>用户与 Kubernetes apiserver 通信，请求访问路径。
Kubernetes apiserver 使用它的标准认证和授权配置来对用户认证，以及对特定路径的鉴权。</p>
<p>有关对 Kubernetes 集群认证的概述，请参见
<a href=/zh/docs/reference/access-authn-authz/authentication/>对集群认证</a>。
有关对Kubernetes群集资源的访问鉴权的概述，请参见
<a href=/zh/docs/reference/access-authn-authz/authorization/>鉴权概述</a>。</p>
<p>到目前为止，所有内容都是标准的 Kubernetes API 请求，认证与鉴权。</p>
<p>Kubernetes apiserver 现在准备将请求发送到扩展 apiserver。</p>
<h3 id=kubernetes-apiserver-代理请求>Kubernetes Apiserver 代理请求</h3>
<p>Kubernetes apiserver 现在将请求发送或代理到注册以处理该请求的扩展 apiserver。
为此，它需要了解几件事：</p>
<ol>
<li>
<p>Kubernetes apiserver 应该如何向扩展 apiserver 认证，以通知扩展
apiserver 通过网络发出的请求来自有效的 Kubernetes apiserver？</p>
</li>
<li>
<p>Kubernetes apiserver 应该如何通知扩展 apiserver 原始请求
已通过认证的用户名和组？</p>
</li>
</ol>
<p>为提供这两条信息，你必须使用若干标志来配置 Kubernetes apiserver。</p>
<h4 id=kubernetes-apiserver-客户端认证>Kubernetes Apiserver 客户端认证</h4>
<p>Kubernetes apiserver 通过 TLS 连接到扩展 apiserver，并使用客户端证书认证。
你必须在启动时使用提供的标志向 Kubernetes apiserver 提供以下内容：</p>
<ul>
<li>通过 <code>--proxy-client-key-file</code> 指定私钥文件</li>
<li>通过 <code>--proxy-client-cert-file</code> 签名的客户端证书文件</li>
<li>通过 <code>--requestheader-client-ca-file</code> 签署客户端证书文件的 CA 证书</li>
<li>通过 <code>--requestheader-allowed-names</code> 在签署的客户证书中有效的公用名（CN）</li>
</ul>
<p>Kubernetes apiserver 将使用由 <code>--proxy-client-*-file</code> 指示的文件来验证扩展 apiserver。
为了使合规的扩展 apiserver 能够将该请求视为有效，必须满足以下条件：</p>
<ol>
<li>连接必须使用由 CA 签署的客户端证书，该证书的证书位于 <code>--requestheader-client-ca-file</code> 中。</li>
<li>连接必须使用客户端证书，该客户端证书的 CN 是 <code>--requestheader-allowed-names</code> 中列出的证书之一。</li>
</ol>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 你可以将此选项设置为空白，即为<code>--requestheader-allowed-names</code>。
这将向扩展 apiserver 指示任何 CN 是可接受的。
</div>
<p>使用这些选项启动时，Kubernetes apiserver 将：</p>
<ol>
<li>使用它们向扩展 apiserver 认证。</li>
<li>在 <code>kube-system</code> 命名空间中
创建一个名为 <code>extension-apiserver-authentication</code> 的 ConfigMap，
它将在其中放置 CA 证书和允许的 CN。
反过来，扩展 apiserver 可以检索这些内容以验证请求。</li>
</ol>
<p>请注意，Kubernetes apiserver 使用相同的客户端证书对所有扩展 apiserver 认证。
它不会为每个扩展 apiserver 创建一个客户端证书，而是创建一个证书作为
Kubernetes apiserver 认证。所有扩展 apiserver 请求都重复使用相同的请求。</p>
<h4 id=原始请求用户名和组>原始请求用户名和组</h4>
<p>当 Kubernetes apiserver 将请求代理到扩展 apiserver 时，
它将向扩展 apiserver 通知原始请求已成功通过其验证的用户名和组。
它在其代理请求的 HTTP 头部中提供这些。你必须将要使用的标头名称告知
Kubernetes apiserver。</p>
<ul>
<li>通过<code>--requestheader-username-headers</code> 标明用来保存用户名的头部</li>
<li>通过<code>--requestheader-group-headers</code> 标明用来保存 group 的头部</li>
<li>通过<code>--requestheader-extra-headers-prefix</code> 标明用来保存拓展信息前缀的头部</li>
</ul>
<p>这些头部名称也放置在 <code>extension-apiserver-authentication</code> ConfigMap 中，
因此扩展 apiserver 可以检索和使用它们。</p>
<h3 id=扩展-apiserver-认证>扩展 Apiserver 认证</h3>
<p>扩展 apiserver 在收到来自 Kubernetes apiserver 的代理请求后，
必须验证该请求确实确实来自有效的身份验证代理，
该认证代理由 Kubernetes apiserver 履行。扩展 apiserver 通过以下方式对其认证：</p>
<ol>
<li>
<p>如上所述，从<code>kube-system</code>中的 configmap 中检索以下内容：</p>
<ul>
<li>客户端 CA 证书</li>
<li>允许名称（CN）列表</li>
<li>用户名，组和其他信息的头部</li>
</ul>
</li>
<li>
<p>使用以下证书检查 TLS 连接是否已通过认证：</p>
<ul>
<li>由其证书与检索到的 CA 证书匹配的 CA 签名。</li>
<li>在允许的 CN 列表中有一个 CN，除非列表为空，在这种情况下允许所有 CN。</li>
<li>从适当的头部中提取用户名和组</li>
</ul>
</li>
</ol>
<p>如果以上均通过，则该请求是来自合法认证代理（在本例中为 Kubernetes apiserver）
的有效代理请求。</p>
<p>请注意，扩展 apiserver 实现负责提供上述内容。
默认情况下，许多扩展 apiserver 实现利用 <code>k8s.io/apiserver/</code> 软件包来做到这一点。
也有一些实现可能支持使用命令行选项来覆盖这些配置。</p>
<p>为了具有检索 configmap 的权限，扩展 apiserver 需要适当的角色。
在 <code>kube-system</code> 名字空间中有一个默认角色
<code>extension-apiserver-authentication-reader</code> 可用于设置。</p>
<h3 id=扩展-apiserver-对请求鉴权>扩展 Apiserver 对请求鉴权</h3>
<p>扩展 apiserver 现在可以验证从标头检索的<code>user/group</code>是否有权执行给定请求。
通过向 Kubernetes apiserver 发送标准
<a href=/zh/docs/reference/access-authn-authz/authorization/>SubjectAccessReview</a> 请求来实现。</p>
<p>为了使扩展 apiserver 本身被鉴权可以向 Kubernetes apiserver 提交 SubjectAccessReview 请求，
它需要正确的权限。
Kubernetes 包含一个具有相应权限的名为 <code>system:auth-delegator</code> 的默认 <code>ClusterRole</code>，
可以将其授予扩展 apiserver 的服务帐户。</p>
<h3 id=扩展-apiserver-执行>扩展 Apiserver 执行</h3>
<p>如果 <code>SubjectAccessReview</code> 通过，则扩展 apiserver 执行请求。</p>
<h2 id=启用-kubernetes-apiserver-标志>启用 Kubernetes Apiserver 标志</h2>
<p>通过以下 kube-apiserver 标志启用聚合层。
你的服务提供商可能已经为你完成了这些工作：</p>
<pre><code>    --requestheader-client-ca-file=&lt;path to aggregator CA cert&gt;
    --requestheader-allowed-names=front-proxy-client
    --requestheader-extra-headers-prefix=X-Remote-Extra-
    --requestheader-group-headers=X-Remote-Group
    --requestheader-username-headers=X-Remote-User
    --proxy-client-cert-file=&lt;path to aggregator proxy cert&gt;
    --proxy-client-key-file=&lt;path to aggregator proxy key&gt;
</code></pre>
<h3 id=ca-reusage-and-conflicts>CA-重用和冲突 </h3>
<p>Kubernetes apiserver 有两个客户端 CA 选项：</p>
<ul>
<li><code>--client-ca-file</code></li>
<li><code>--requestheader-client-ca-file</code></li>
</ul>
<p>这些功能中的每个功能都是独立的；如果使用不正确，可能彼此冲突。</p>
<ul>
<li>
<p><code>--client-ca-file</code>：当请求到达 Kubernetes apiserver 时，如果启用了此选项，
则 Kubernetes apiserver 会检查请求的证书。
如果它是由 <code>--client-ca-file</code> 引用的文件中的 CA 证书之一签名的，
并且用户是公用名<code>CN=</code>的值，而组是组织<code>O=</code> 的取值，则该请求被视为合法请求。
请参阅<a href=/zh/docs/reference/access-authn-authz/authentication/#x509-client-certs>关于 TLS 身份验证的文档</a>。</p>
</li>
<li>
<p><code>--requestheader-client-ca-file</code>：当请求到达 Kubernetes apiserver 时，
如果启用此选项，则 Kubernetes apiserver 会检查请求的证书。
如果它是由文件引用中的 --requestheader-client-ca-file 所签署的 CA 证书之一签名的，
则该请求将被视为潜在的合法请求。
然后，Kubernetes apiserver 检查通用名称 <code>CN=</code> 是否是
<code>--requestheader-allowed-names</code> 提供的列表中的名称之一。
如果名称允许，则请求被批准；如果不是，则请求被拒绝。</p>
</li>
</ul>
<p>如果同时提供了 <code>--client-ca-file</code> 和 <code>--requestheader-client-ca-file</code>，
则首先检查 <code>--requestheader-client-ca-file</code> CA，然后再检查<code>--client-ca-file</code>。
通常，这些选项中的每一个都使用不同的 CA（根 CA 或中间 CA）。
常规客户端请求与 <code>--client-ca-file</code> 相匹配，而聚合请求要与
<code>--requestheader-client-ca-file</code> 相匹配。
但是，如果两者都使用同一个 CA，则通常会通过 <code>--client-ca-file</code>
传递的客户端请求将失败，因为 CA 将与 <code>--requestheader-client-ca-file</code>
中的 CA 匹配，但是通用名称 <code>CN=</code> 将不匹配 <code>--requestheader-allowed-names</code>
中可接受的通用名称之一。
这可能导致你的 kubelet 和其他控制平面组件以及最终用户无法向 Kubernetes
apiserver 认证。</p>
<p>因此，请对用于控制平面组件和最终用户鉴权的 <code>--client-ca-file</code> 选项和
用于聚合 apiserver 鉴权的 <code>--requestheader-client-ca-file</code> 选项使用
不同的 CA 证书。</p>
<div class="alert alert-danger warning callout" role=alert>
<strong>Warning:</strong> 除非你了解风险和保护 CA 用法的机制，否则 <em>不要</em> 重用在不同上下文中使用的 CA。
</div>
<p>如果你未在运行 API 服务器的主机上运行 kube-proxy，则必须确保使用以下
<code>kube-apiserver</code> 标志启用系统：</p>
<pre><code>--enable-aggregator-routing=true
</code></pre>
<h3 id=注册-apiservice-对象>注册 APIService 对象</h3>
<p>你可以动态配置将哪些客户端请求代理到扩展 apiserver。以下是注册示例：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apiregistration.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>APIService<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>&lt;注释对象名称&gt;<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>group</span>:<span style=color:#bbb> </span>&lt;扩展 Apiserver 的 API 组名&gt;<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>version</span>:<span style=color:#bbb> </span>&lt;扩展 Apiserver 的 API 版本&gt;<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>groupPriorityMinimum</span>:<span style=color:#bbb> </span>&lt;APIService 对应组的优先级, 参考 API 文档&gt;<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>versionPriority</span>:<span style=color:#bbb> </span>&lt;版本在组中的优先排序, 参考 API 文档&gt;<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>service</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>&lt;拓展 Apiserver 服务的名字空间&gt;<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>&lt;拓展 Apiserver 服务的名称&gt;<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>caBundle</span>:<span style=color:#bbb> </span>&lt;PEM 编码的 CA 证书，用于对 Webhook 服务器的证书签名&gt;<span style=color:#bbb>
</span></code></pre></div>
<p>APIService 对象的名称必须是合法的
<a href=/zh/docs/concepts/overview/working-with-objects/names#path-segment-names>路径片段名称</a>。</p>
<h4 id=调用扩展-apiserver>调用扩展 apiserver</h4>
<p>一旦 Kubernetes apiserver 确定应将请求发送到扩展 apiserver，
它需要知道如何调用它。</p>
<p><code>service</code> 部分是对扩展 apiserver 的服务的引用。
服务的名字空间和名字是必需的。端口是可选的，默认为 443。
路径配置是可选的，默认为 <code>/</code>。</p>
<p>下面是为可在端口 <code>1234</code> 上调用的扩展 apiserver 的配置示例
服务位于子路径 <code>/my-path</code> 下，并针对 ServerName
<code>my-service-name.my-service-namespace.svc</code>
使用自定义的 CA 包来验证 TLS 连接
使用自定义 CA 捆绑包的<code>my-service-name.my-service-namespace.svc</code>。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apiregistration.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>APIService<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>service</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>my-service-namespace<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service-name<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>1234</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>caBundle</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;Ci0tLS0tQk...&lt;base64-encoded PEM bundle&gt;...tLS0K&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></code></pre></div><h2 id=what-s-next>What's next</h2>
<ul>
<li>使用聚合层<a href=/zh/docs/tasks/extend-kubernetes/setup-extension-api-server/>安装扩展 API 服务器</a>。</li>
<li>有关高级概述，请参阅<a href=/zh/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/>使用聚合层扩展 Kubernetes API</a>。</li>
<li>了解如何<a href=/zh/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/>使用自定义资源扩展 Kubernetes API</a>。</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-c4798e42eaccc051e396542befb3c57b>13.3 - 安装一个扩展的 API server</h1>
<p>安装扩展的 API 服务器来使用聚合层以让 Kubernetes API 服务器使用
其它 API 进行扩展，
这些 API 不是核心 Kubernetes API 的一部分。</p>
<h2 id=before-you-begin>Before you begin</h2>
<p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li>
</ul>
To check the version, enter <code>kubectl version</code>.
</p>
<ul>
<li>你必须<a href=/zh/docs/tasks/extend-kubernetes/configure-aggregation-layer/>配置聚合层</a>
并且启用 API 服务器的相关参数。</li>
</ul>
<h2 id=安装一个扩展的-api-服务器来使用聚合层>安装一个扩展的 API 服务器来使用聚合层</h2>
<p>以下步骤描述如何 <em>在一个高层次</em> 设置一个扩展的 apiserver。无论你使用的是 YAML 配置还是使用 API，这些步骤都适用。
目前我们正在尝试区分出两者的区别。有关使用 YAML 配置的具体示例，你可以在 Kubernetes 库中查看
<a href=https://github.com/kubernetes/sample-apiserver/blob/master/README.md>sample-apiserver</a>。</p>
<p>或者，你可以使用现有的第三方解决方案，例如
<a href=https://github.com/Kubernetes-incubator/apiserver-builder/blob/master/README.md>apiserver-builder</a>，
它将生成框架并自动执行以下所有步骤。</p>
<ol>
<li>确保启用了 APIService API（检查 <code>--runtime-config</code>）。默认应该是启用的，除非被特意关闭了。</li>
<li>你可能需要制定一个 RBAC 规则，以允许你添加 APIService 对象，或让你的集群管理员创建一个。
（由于 API 扩展会影响整个集群，因此不建议在实时集群中对 API 扩展进行测试/开发/调试）</li>
<li>创建 Kubernetes 命名空间，扩展的 api-service 将运行在该命名空间中。</li>
<li>创建（或获取）用来签署服务器证书的 CA 证书，扩展 api-server 中将使用该证书做 HTTPS 连接。</li>
<li>为 api-server 创建一个服务端的证书（或秘钥）以使用 HTTPS。这个证书应该由上述的 CA 签署。
同时应该还要有一个 Kube DNS 名称的 CN，这是从 Kubernetes 服务派生而来的，
格式为 <code>&lt;service name>.&lt;service name namespace>.svc</code>。</li>
<li>使用命名空间中的证书（或秘钥）创建一个 Kubernetes secret。</li>
<li>为扩展 api-server 创建一个 Kubernetes Deployment，并确保以卷的方式挂载了 Secret。
它应该包含对扩展 api-server 镜像的引用。Deployment 也应该在同一个命名空间中。</li>
</ol>
<ol start=8>
<li>确保你的扩展 apiserver 从该卷中加载了那些证书，并在 HTTPS 握手过程中使用它们。</li>
<li>在你的命名空间中创建一个 Kubernetes 服务账号。</li>
<li>为资源允许的操作创建 Kubernetes 集群角色。</li>
<li>用你命名空间中的服务账号创建一个 Kubernetes 集群角色绑定，绑定到你创建的角色上。</li>
<li>用你命名空间中的服务账号创建一个 Kubernetes 集群角色绑定，绑定到 <code>system:auth-delegator</code>
集群角色，以将 auth 决策委派给 Kubernetes 核心 API 服务器。</li>
<li>以你命名空间中的服务账号创建一个 Kubernetes 集群角色绑定，绑定到
<code>extension-apiserver-authentication-reader</code> 角色。
这将让你的扩展 api-server 能够访问 <code>extension-apiserver-authentication</code> configmap。</li>
</ol>
<ol start=14>
<li>创建一个 Kubernetes apiservice。
上述的 CA 证书应该使用 base64 编码，剥离新行并用作 apiservice 中的 spec.caBundle。
该资源不应放到任何名字空间。如果使用了
<a href=https://github.com/kubernetes/kube-aggregator/>kube-aggregator API</a>，那么只需要传入
PEM 编码的 CA 绑定，因为 base 64 编码已经完成了。</li>
<li>使用 kubectl 来获得你的资源。
它应该返回 "找不到资源"。此消息表示一切正常，但你目前还没有创建该资源类型的对象。</li>
</ol>
<h2 id=what-s-next>What's next</h2>
<ul>
<li>如果你还未配置，请<a href=/zh/docs/tasks/extend-kubernetes/configure-aggregation-layer/>配置聚合层</a>
并启用 apiserver 的相关参数。</li>
<li>高级概述，请参阅<a href=/zh/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation>使用聚合层扩展 Kubernetes API</a>。</li>
<li>了解如何<a href=/zh/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/>使用 Custom Resource Definition 扩展 Kubernetes API</a>。</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-c00a2767fac9dbfafce583cf489cc423>13.4 - 配置多个调度器</h1>
<p>Kubernetes 自带了一个默认调度器，其详细描述请查阅
<a href=/zh/docs/reference/command-line-tools-reference/kube-scheduler/>这里</a>。
如果默认调度器不适合你的需求，你可以实现自己的调度器。
而且，你甚至可以和默认调度器一起同时运行多个调度器，并告诉 Kubernetes 为每个
Pod 使用哪个调度器。
让我们通过一个例子讲述如何在 Kubernetes 中运行多个调度器。</p>
<p>关于实现调度器的具体细节描述超出了本文范围。
请参考 kube-scheduler 的实现，规范示例代码位于
<a href=https://github.com/kubernetes/kubernetes/tree/master/pkg/scheduler>pkg/scheduler</a>。</p>
<h2 id=before-you-begin>Before you begin</h2>
<p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li>
</ul>
To check the version, enter <code>kubectl version</code>.
</p>
<h2 id=打包调度器>打包调度器</h2>
<p>将调度器可执行文件打包到容器镜像中。出于示例目的，可以使用默认调度器
（kube-scheduler）作为第二个调度器。
克隆 <a href=https://github.com/kubernetes/kubernetes>GitHub 上 Kubernetes 源代码</a>，
并编译构建源代码。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>git clone https://github.com/kubernetes/kubernetes.git
<span style=color:#a2f>cd</span> kubernetes
make
</code></pre></div>
<p>创建一个包含 kube-scheduler 二进制文件的容器镜像。用于构建镜像的 <code>Dockerfile</code> 内容如下：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-docker data-lang=docker><span style=color:#a2f;font-weight:700>FROM</span><span style=color:#b44> busybox</span><span>
</span><span></span><span style=color:#a2f;font-weight:700>ADD</span> ./_output/local/bin/linux/amd64/kube-scheduler /usr/local/bin/kube-scheduler<span>
</span></code></pre></div>
<p>将文件保存为 <code>Dockerfile</code>，构建镜像并将其推送到镜像仓库。
此示例将镜像推送到 <a href=https://cloud.google.com/container-registry/>Google 容器镜像仓库（GCR）</a>。
有关详细信息，请阅读 GCR <a href=https://cloud.google.com/container-registry/docs/>文档</a>。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>docker build -t gcr.io/my-gcp-project/my-kube-scheduler:1.0 .
gcloud docker -- push gcr.io/my-gcp-project/my-kube-scheduler:1.0
</code></pre></div>
<h2 id=为调度器定义-kubernetes-deployment>为调度器定义 Kubernetes Deployment</h2>
<p>现在将调度器放在容器镜像中，为它创建一个 Pod 配置，并在 Kubernetes 集群中
运行它。但是与其在集群中直接创建一个 Pod，不如使用
<a href=/zh/docs/concepts/workloads/controllers/deployment/>Deployment</a>。
Deployment 管理一个 <a href=/zh/docs/concepts/workloads/controllers/replicaset/>ReplicaSet</a>，
ReplicaSet 再管理 Pod，从而使调度器能够免受一些故障的影响。
以下是 Deployment 配置，将其保存为 <code>my-scheduler.yaml</code>：</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/admin/sched/my-scheduler.yaml download=admin/sched/my-scheduler.yaml><code>admin/sched/my-scheduler.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('admin-sched-my-scheduler-yaml')" title="Copy admin/sched/my-scheduler.yaml to clipboard">
</img>
</div>
<div class=includecode id=admin-sched-my-scheduler-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ServiceAccount<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-scheduler<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>kube-system<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRoleBinding<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-scheduler-as-kube-scheduler<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>subjects</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ServiceAccount<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-scheduler<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>kube-system<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>roleRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>system:kube-scheduler<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-scheduler-config<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>kube-system<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>my-scheduler-config.yaml</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span><span style=color:#b44;font-style:italic>    apiVersion: kubescheduler.config.k8s.io/v1beta2
</span><span style=color:#b44;font-style:italic>    kind: KubeSchedulerConfiguration
</span><span style=color:#b44;font-style:italic>    profiles:
</span><span style=color:#b44;font-style:italic>      - schedulerName: my-scheduler
</span><span style=color:#b44;font-style:italic>    leaderElection:
</span><span style=color:#b44;font-style:italic>      leaderElect: false</span><span style=color:#bbb>    
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRoleBinding<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-scheduler-as-volume-scheduler<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>subjects</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ServiceAccount<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-scheduler<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>kube-system<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>roleRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>system:volume-scheduler<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>component</span>:<span style=color:#bbb> </span>scheduler<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>tier</span>:<span style=color:#bbb> </span>control-plane<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-scheduler<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>kube-system<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>component</span>:<span style=color:#bbb> </span>scheduler<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>tier</span>:<span style=color:#bbb> </span>control-plane<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>component</span>:<span style=color:#bbb> </span>scheduler<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>tier</span>:<span style=color:#bbb> </span>control-plane<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>version</span>:<span style=color:#bbb> </span>second<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>serviceAccountName</span>:<span style=color:#bbb> </span>my-scheduler<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>command</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- /usr/local/bin/kube-scheduler<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- --config=/etc/kubernetes/my-scheduler/my-scheduler-config.yaml<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>gcr.io/my-gcp-project/my-kube-scheduler:1.0<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>livenessProbe</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>httpGet</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/healthz<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>10259</span><span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>scheme</span>:<span style=color:#bbb> </span>HTTPS<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>initialDelaySeconds</span>:<span style=color:#bbb> </span><span style=color:#666>15</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>kube-second-scheduler<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>readinessProbe</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>httpGet</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/healthz<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>10259</span><span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>scheme</span>:<span style=color:#bbb> </span>HTTPS<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;0.1&#39;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>securityContext</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>privileged</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>false</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>config-volume<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/etc/kubernetes/my-scheduler<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>hostNetwork</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>false</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>hostPID</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>false</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>config-volume<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>configMap</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-scheduler-config<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>在以上的清单中，你使用 <a href=/zh/docs/reference/scheduling/config/>KubeSchedulerConfiguration</a>
来自定义调度器实现的行为。当使用 <code>--config</code> 选项进行初始化时，该配置被传递到 <code>kube-scheduler</code>。
<code>my-scheduler-config</code> ConfigMap 存储配置数据。
<code>my-scheduler</code> Deployment 的 Pod 将 <code>my-scheduler-config</code> ConfigMap 挂载为一个卷。</p>
<p>在前面提到的调度器配置中，你的调度器通过 <a href=/docs/reference/config-api/kube-scheduler-config.v1beta3/#kubescheduler-config-k8s-io-v1beta3-KubeSchedulerProfile>KubeSchedulerProfile</a> 进行实现。
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 要确定一个调度器是否可以调度特定的 Pod，PodTemplate 或 Pod 清单中的 <code>spec.schedulerName</code>
字段必须匹配 <code>KubeSchedulerProfile</code> 中的 <code>schedulerName</code> 字段。
所有运行在集群中的调度器必须拥有唯一的名称。
</div></p>
<p>还要注意，我们创建了一个专用服务账号 <code>my-scheduler</code> 并将集群角色 <code>system:kube-scheduler</code>
绑定到它，以便它可以获得与 <code>kube-scheduler</code> 相同的权限。</p>
<p>请参阅 <a href=/docs/reference/command-line-tools-reference/kube-scheduler/>kube-scheduler 文档</a>
获取其他命令行参数以及 <a href=/docs/reference/config-api/kube-scheduler-config.v1beta3/>Scheduler 配置参考</a>
获取自定义 <code>kube-scheduler</code> 配置的详细说明。</p>
<h2 id=在集群中运行第二个调度器>在集群中运行第二个调度器</h2>
<p>为了在 Kubernetes 集群中运行我们的第二个调度器，在 Kubernetes 集群中创建上面配置中指定的 Deployment：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create -f my-scheduler.yaml
</code></pre></div>
<p>验证调度器 Pod 正在运行：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods --namespace<span style=color:#666>=</span>kube-system
</code></pre></div><p>输出类似于：</p>
<pre><code>NAME                                           READY     STATUS    RESTARTS   AGE
....
my-scheduler-lnf4s-4744f                       1/1       Running   0          2m
...
</code></pre>
<p>此列表中，除了默认的 <code>kube-scheduler</code> Pod 之外，你应该还能看到处于 “Running” 状态的
<code>my-scheduler</code> Pod。</p>
<h3 id=启用领导者选举>启用领导者选举</h3>
<p>要在启用了 leader 选举的情况下运行多调度器，你必须执行以下操作：</p>
<p>更新你的 YAML 文件中的 <code>my-scheduler-config</code> ConfigMap 里的 KubeSchedulerConfiguration 相关字段如下：</p>
<ul>
<li><code>leaderElection.leaderElect</code> to <code>true</code></li>
<li><code>leaderElection.resourceNamespace</code> to <code>&lt;lock-object-namespace></code></li>
<li><code>leaderElection.resourceName</code> to <code>&lt;lock-object-name></code></li>
</ul>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong>
<p>控制平面会为你创建锁对象，但是命名空间必须已经存在。
你可以使用 <code>kube-system</code> 命名空间。
</div>
<p>如果在集群上启用了 RBAC，则必须更新 <code>system：kube-scheduler</code> 集群角色。
将调度器名称添加到应用了 <code>endpoints</code> 和 <code>leases</code> 资源的规则的 resourceNames 中，如以下示例所示：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl edit clusterrole system:kube-scheduler
</code></pre></div>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/admin/sched/clusterrole.yaml download=admin/sched/clusterrole.yaml><code>admin/sched/clusterrole.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('admin-sched-clusterrole-yaml')" title="Copy admin/sched/clusterrole.yaml to clipboard">
</img>
</div>
<div class=includecode id=admin-sched-clusterrole-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>rbac.authorization.kubernetes.io/autoupdate</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubernetes.io/bootstrapping</span>:<span style=color:#bbb> </span>rbac-defaults<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>system:kube-scheduler<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- coordination.k8s.io<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- leases<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- create<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- coordination.k8s.io<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resourceNames</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- kube-scheduler<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- my-scheduler<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- leases<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- get<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- update<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resourceNames</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- kube-scheduler<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- my-scheduler<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- endpoints<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- delete<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- get<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- patch<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- update<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<h2 id=为-pod-指定调度器>为 Pod 指定调度器</h2>
<p>现在第二个调度器正在运行，创建一些 Pod，并指定它们由默认调度器或部署的调度器进行调度。
为了使用特定的调度器调度给定的 Pod，在那个 Pod 的 spec 中指定调度器的名称。让我们看看三个例子。</p>
<ul>
<li>
<p>Pod spec 没有任何调度器名称</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/admin/sched/pod1.yaml download=admin/sched/pod1.yaml><code>admin/sched/pod1.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('admin-sched-pod1-yaml')" title="Copy admin/sched/pod1.yaml to clipboard">
</img>
</div>
<div class=includecode id=admin-sched-pod1-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>no</span>-annotation<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>multischeduler-example<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pod-with-no-annotation-container<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/pause:2.0</code></pre></div>
</div>
</div>
<p>如果未提供调度器名称，则会使用 default-scheduler 自动调度 pod。</p>
<p>将此文件另存为 <code>pod1.yaml</code>，并将其提交给 Kubernetes 集群。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create -f pod1.yaml
</code></pre></div></li>
</ul>
<ul>
<li>
<p>Pod spec 设置为 <code>default-scheduler</code></p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/admin/sched/pod2.yaml download=admin/sched/pod2.yaml><code>admin/sched/pod2.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('admin-sched-pod2-yaml')" title="Copy admin/sched/pod2.yaml to clipboard">
</img>
</div>
<div class=includecode id=admin-sched-pod2-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>annotation-default-scheduler<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>multischeduler-example<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>schedulerName</span>:<span style=color:#bbb> </span>default-scheduler<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pod-with-default-annotation-container<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/pause:2.0<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>通过将调度器名称作为 <code>spec.schedulerName</code> 参数的值来指定调度器。
在这种情况下，我们提供默认调度器的名称，即 <code>default-scheduler</code>。</p>
<p>将此文件另存为 <code>pod2.yaml</code>，并将其提交给 Kubernetes 集群。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create -f pod2.yaml
</code></pre></div></li>
</ul>
<ul>
<li>
<p>Pod spec 设置为 <code>my-scheduler</code></p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/admin/sched/pod3.yaml download=admin/sched/pod3.yaml><code>admin/sched/pod3.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('admin-sched-pod3-yaml')" title="Copy admin/sched/pod3.yaml to clipboard">
</img>
</div>
<div class=includecode id=admin-sched-pod3-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>annotation-second-scheduler<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>multischeduler-example<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>schedulerName</span>:<span style=color:#bbb> </span>my-scheduler<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pod-with-second-annotation-container<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/pause:2.0<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>在这种情况下，我们指定此 Pod 使用我们部署的 <code>my-scheduler</code> 来调度。
请注意，<code>spec.schedulerName</code> 参数的值应该与调度器提供的 <code>KubeSchedulerProfile</code> 中的 <code>schedulerName</code> 字段相匹配。</p>
<p>将此文件另存为 <code>pod3.yaml</code>，并将其提交给 Kubernetes 集群。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create -f pod3.yaml
</code></pre></div></li>
</ul>
<p>确认所有三个 pod 都在运行。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods
</code></pre></div>
<h3 id=验证是否使用所需的调度器调度了-pod>验证是否使用所需的调度器调度了 pod</h3>
<p>为了更容易地完成这些示例，我们没有验证 Pod 实际上是使用所需的调度程序调度的。
我们可以通过更改 Pod 的顺序和上面的部署配置提交来验证这一点。
如果我们在提交调度器部署配置之前将所有 Pod 配置提交给 Kubernetes 集群，
我们将看到注解了 <code>annotation-second-scheduler</code> 的 Pod 始终处于 “Pending” 状态，
而其他两个 Pod 被调度。
一旦我们提交调度器部署配置并且我们的新调度器开始运行，注解了
<code>annotation-second-scheduler</code> 的 pod 就能被调度。</p>
<p>或者，可以查看事件日志中的 “Scheduled” 条目，以验证是否由所需的调度器调度了 Pod。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get events
</code></pre></div>
<p>你也可以使用<a href=/zh/docs/reference/scheduling/config/#multiple-profiles>自定义调度器配置</a>
或自定义容器镜像，用于集群的主调度器，方法是在相关控制平面节点上修改其静态 pod 清单。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-1707517970dd390995f760308c2e2de6>13.5 - 使用 HTTP 代理访问 Kubernetes API</h1>
<p>本文说明如何使用 HTTP 代理访问 Kubernetes API。</p>
<h2 id=before-you-begin>Before you begin</h2>
<ul>
<li><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li>
</ul>
To check the version, enter <code>kubectl version</code>.
</li>
</ul>
<ul>
<li>如果您的集群中还没有任何应用，使用如下命令启动一个 Hello World 应用：</li>
</ul>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create deployment node-hello --image<span style=color:#666>=</span>gcr.io/google-samples/node-hello:1.0 --port<span style=color:#666>=</span><span style=color:#666>8080</span>
</code></pre></div>
<h2 id=使用-kubectl-启动代理服务器>使用 kubectl 启动代理服务器</h2>
<p>使用如下命令启动 Kubernetes API 服务器的代理：</p>
<pre><code>kubectl proxy --port=8080
</code></pre>
<h2 id=探究-kubernetes-api>探究 Kubernetes API</h2>
<p>当代理服务器在运行时，你可以通过 <code>curl</code>、<code>wget</code> 或者浏览器访问 API。</p>
<p>获取 API 版本：</p>
<pre><code>curl http://localhost:8080/api/
</code></pre>
<p>输出应该类似这样：</p>
<pre><code>{
  &quot;kind&quot;: &quot;APIVersions&quot;,
  &quot;versions&quot;: [
    &quot;v1&quot;
  ],
  &quot;serverAddressByClientCIDRs&quot;: [
    {
      &quot;clientCIDR&quot;: &quot;0.0.0.0/0&quot;,
      &quot;serverAddress&quot;: &quot;10.0.2.15:8443&quot;
    }
  ]
}
</code></pre>
<p>获取 Pod 列表：</p>
<pre><code>curl http://localhost:8080/api/v1/namespaces/default/pods

{
  &quot;kind&quot;: &quot;PodList&quot;,
  &quot;apiVersion&quot;: &quot;v1&quot;,
  &quot;metadata&quot;: {
    &quot;resourceVersion&quot;: &quot;33074&quot;
  },
  &quot;items&quot;: [
    {
      &quot;metadata&quot;: {
        &quot;name&quot;: &quot;kubernetes-bootcamp-2321272333-ix8pt&quot;,
        &quot;generateName&quot;: &quot;kubernetes-bootcamp-2321272333-&quot;,
        &quot;namespace&quot;: &quot;default&quot;,
        &quot;uid&quot;: &quot;ba21457c-6b1d-11e6-85f7-1ef9f1dab92b&quot;,
        &quot;resourceVersion&quot;: &quot;33003&quot;,
        &quot;creationTimestamp&quot;: &quot;2016-08-25T23:43:30Z&quot;,
        &quot;labels&quot;: {
          &quot;pod-template-hash&quot;: &quot;2321272333&quot;,
          &quot;run&quot;: &quot;kubernetes-bootcamp&quot;
        },
        ...
}
</code></pre>
<h2 id=what-s-next>What's next</h2>
<p>想了解更多信息，请参阅 <a href=/docs/reference/generated/kubectl/kubectl-commands#proxy>kubectl 代理</a>。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-61cf1f2f0fbe98e7635fce65f04a775f>13.6 - 设置 Konnectivity 服务</h1>
<p>Konnectivity 服务为控制平面提供集群通信的 TCP 级别代理。</p>
<h2 id=before-you-begin>Before you begin</h2>
<p>你需要有一个 Kubernetes 集群，并且 kubectl 命令可以与集群通信。
建议在至少有两个不充当控制平面主机的节点的集群上运行本教程。
如果你还没有集群，可以使用
<a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>minikube</a> 创建一个集群。</p>
<h2 id=配置-konnectivity-服务>配置 Konnectivity 服务</h2>
<p>接下来的步骤需要出口配置，比如：</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/admin/konnectivity/egress-selector-configuration.yaml download=admin/konnectivity/egress-selector-configuration.yaml><code>admin/konnectivity/egress-selector-configuration.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('admin-konnectivity-egress-selector-configuration-yaml')" title="Copy admin/konnectivity/egress-selector-configuration.yaml to clipboard">
</img>
</div>
<div class=includecode id=admin-konnectivity-egress-selector-configuration-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apiserver.k8s.io/v1beta1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>EgressSelectorConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>egressSelections</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># Since we want to control the egress traffic to the cluster, we use the</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># &#34;cluster&#34; as the name. Other supported values are &#34;etcd&#34;, and &#34;master&#34;.</span><span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cluster<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>connection</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># This controls the protocol between the API Server and the Konnectivity</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># server. Supported values are &#34;GRPC&#34; and &#34;HTTPConnect&#34;. There is no</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># end user visible difference between the two modes. You need to set the</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># Konnectivity server to work in the same mode.</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>proxyProtocol</span>:<span style=color:#bbb> </span>GRPC<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>transport</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># This controls what transport the API Server uses to communicate with the</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># Konnectivity server. UDS is recommended if the Konnectivity server</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># locates on the same machine as the API Server. You need to configure the</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># Konnectivity server to listen on the same UDS socket.</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># The other supported transport is &#34;tcp&#34;. You will need to set up TLS </span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># config to secure the TCP transport.</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>uds</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>udsName</span>:<span style=color:#bbb> </span>/etc/kubernetes/konnectivity-server/konnectivity-server.socket<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>你需要配置 API 服务器来使用 Konnectivity 服务，并将网络流量定向到集群节点：</p>
<p>确保<a href=/zh/docs/tasks/configure-pod-container/configure-service-account/#service-account-token-volume-projection>服务账号令牌卷投射</a>
特性被启用。该特性自 Kubernetes v1.20 起默认已被启用。</p>
<ol>
<li>创建一个出站流量配置文件，比如 <code>admin/konnectivity/egress-selector-configuration.yaml</code>。</li>
<li>将 API 服务器的 <code>--egress-selector-config-file</code> 参数设置为你的 API 服务器的
离站流量配置文件路径。</li>
<li>如果你在使用 UDS 连接，须将卷配置添加到 kube-apiserver：
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>konnectivity-uds<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/etc/kubernetes/konnectivity-server<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>false</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>konnectivity-uds<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>hostPath</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/etc/kubernetes/konnectivity-server<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>DirectoryOrCreate<span style=color:#bbb>
</span></code></pre></div></li>
</ol>
<p>为 konnectivity-server 生成或者取得证书和 kubeconfig 文件。
例如，你可以使用 OpenSSL 命令行工具，基于存放在某控制面主机上
<code>/etc/kubernetes/pki/ca.crt</code> 文件中的集群 CA 证书来
发放一个 X.509 证书，</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>openssl req -subj <span style=color:#b44>&#34;/CN=system:konnectivity-server&#34;</span> -new -newkey rsa:2048 -nodes -out konnectivity.csr -keyout konnectivity.key -out konnectivity.csr
openssl x509 -req -in konnectivity.csr -CA /etc/kubernetes/pki/ca.crt -CAkey /etc/kubernetes/pki/ca.key -CAcreateserial -out konnectivity.crt -days <span style=color:#666>375</span> -sha256
<span style=color:#b8860b>SERVER</span><span style=color:#666>=</span><span style=color:#a2f;font-weight:700>$(</span>kubectl config view -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.clusters..server}&#39;</span><span style=color:#a2f;font-weight:700>)</span>
kubectl --kubeconfig /etc/kubernetes/konnectivity-server.conf config set-credentials system:konnectivity-server --client-certificate konnectivity.crt --client-key konnectivity.key --embed-certs<span style=color:#666>=</span><span style=color:#a2f>true</span>
kubectl --kubeconfig /etc/kubernetes/konnectivity-server.conf config set-cluster kubernetes --server <span style=color:#b44>&#34;</span><span style=color:#b8860b>$SERVER</span><span style=color:#b44>&#34;</span> --certificate-authority /etc/kubernetes/pki/ca.crt --embed-certs<span style=color:#666>=</span><span style=color:#a2f>true</span>
kubectl --kubeconfig /etc/kubernetes/konnectivity-server.conf config set-context system:konnectivity-server@kubernetes --cluster kubernetes --user system:konnectivity-server
kubectl --kubeconfig /etc/kubernetes/konnectivity-server.conf config use-context system:konnectivity-server@kubernetes
rm -f konnectivity.crt konnectivity.key konnectivity.csr
</code></pre></div>
<p>接下来，你需要部署 Konnectivity 服务器和代理。
<a href=https://github.com/kubernetes-sigs/apiserver-network-proxy>kubernetes-sigs/apiserver-network-proxy</a>
是一个参考实现。</p>
<p>在控制面节点上部署 Konnectivity 服务。
下面提供的 <code>konnectivity-server.yaml</code> 配置清单假定在你的集群中
Kubernetes 组件都是部署为<a class=glossary-tooltip title="静态Pod（Static Pod）是指由特定节点上的 kubelet 守护进程直接管理的 Pod。" data-toggle=tooltip data-placement=top href=/zh/docs/tasks/configure-pod-container/static-pod/ target=_blank aria-label="静态 Pod">静态 Pod</a> 的。
如果不是，你可以将 Konnectivity 服务部署为 DaemonSet。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/admin/konnectivity/konnectivity-server.yaml download=admin/konnectivity/konnectivity-server.yaml><code>admin/konnectivity/konnectivity-server.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('admin-konnectivity-konnectivity-server-yaml')" title="Copy admin/konnectivity/konnectivity-server.yaml to clipboard">
</img>
</div>
<div class=includecode id=admin-konnectivity-konnectivity-server-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>konnectivity-server<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>kube-system<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>priorityClassName</span>:<span style=color:#bbb> </span>system-cluster-critical<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>hostNetwork</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>konnectivity-server-container<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>us.gcr.io/k8s-artifacts-prod/kas-network-proxy/proxy-server:v0.0.16<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;/proxy-server&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb> </span>[<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:#b44>&#34;--logtostderr=true&#34;</span>,<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:#080;font-style:italic># This needs to be consistent with the value set in egressSelectorConfiguration.</span><span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:#b44>&#34;--uds-name=/etc/kubernetes/konnectivity-server/konnectivity-server.socket&#34;</span>,<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:#080;font-style:italic># The following two lines assume the Konnectivity server is</span><span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:#080;font-style:italic># deployed on the same machine as the apiserver, and the certs and</span><span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:#080;font-style:italic># key of the API Server are at the specified location.</span><span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:#b44>&#34;--cluster-cert=/etc/kubernetes/pki/apiserver.crt&#34;</span>,<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:#b44>&#34;--cluster-key=/etc/kubernetes/pki/apiserver.key&#34;</span>,<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:#080;font-style:italic># This needs to be consistent with the value set in egressSelectorConfiguration.</span><span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:#b44>&#34;--mode=grpc&#34;</span>,<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:#b44>&#34;--server-port=0&#34;</span>,<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:#b44>&#34;--agent-port=8132&#34;</span>,<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:#b44>&#34;--admin-port=8133&#34;</span>,<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:#b44>&#34;--health-port=8134&#34;</span>,<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:#b44>&#34;--agent-namespace=kube-system&#34;</span>,<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:#b44>&#34;--agent-service-account=konnectivity-agent&#34;</span>,<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:#b44>&#34;--kubeconfig=/etc/kubernetes/konnectivity-server.conf&#34;</span>,<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:#b44>&#34;--authentication-audience=system:konnectivity-server&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>            </span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>livenessProbe</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>httpGet</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>scheme</span>:<span style=color:#bbb> </span>HTTP<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>host</span>:<span style=color:#bbb> </span><span style=color:#666>127.0.0.1</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>8134</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/healthz<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>initialDelaySeconds</span>:<span style=color:#bbb> </span><span style=color:#666>30</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>timeoutSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>60</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>agentport<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>8132</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>hostPort</span>:<span style=color:#bbb> </span><span style=color:#666>8132</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>adminport<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>8133</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>hostPort</span>:<span style=color:#bbb> </span><span style=color:#666>8133</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>healthport<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>8134</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>hostPort</span>:<span style=color:#bbb> </span><span style=color:#666>8134</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>k8s-certs<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/etc/kubernetes/pki<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>kubeconfig<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/etc/kubernetes/konnectivity-server.conf<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>konnectivity-uds<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/etc/kubernetes/konnectivity-server<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>false</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>k8s-certs<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>hostPath</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/etc/kubernetes/pki<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>kubeconfig<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>hostPath</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/etc/kubernetes/konnectivity-server.conf<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>FileOrCreate<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>konnectivity-uds<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>hostPath</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/etc/kubernetes/konnectivity-server<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>DirectoryOrCreate<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>在你的集群中部署 Konnectivity 代理：</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/admin/konnectivity/konnectivity-agent.yaml download=admin/konnectivity/konnectivity-agent.yaml><code>admin/konnectivity/konnectivity-agent.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('admin-konnectivity-konnectivity-agent-yaml')" title="Copy admin/konnectivity/konnectivity-agent.yaml to clipboard">
</img>
</div>
<div class=includecode id=admin-konnectivity-konnectivity-agent-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># Alternatively, you can deploy the agents as Deployments. It is not necessary</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># to have an agent on each node.</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>DaemonSet<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>addonmanager.kubernetes.io/mode</span>:<span style=color:#bbb> </span>Reconcile<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>k8s-app</span>:<span style=color:#bbb> </span>konnectivity-agent<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>kube-system<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>konnectivity-agent<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>k8s-app</span>:<span style=color:#bbb> </span>konnectivity-agent<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>k8s-app</span>:<span style=color:#bbb> </span>konnectivity-agent<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>priorityClassName</span>:<span style=color:#bbb> </span>system-cluster-critical<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>tolerations</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;CriticalAddonsOnly&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;Exists&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>us.gcr.io/k8s-artifacts-prod/kas-network-proxy/proxy-agent:v0.0.16<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>konnectivity-agent<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;/proxy-agent&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb> </span>[<span style=color:#bbb>
</span><span style=color:#bbb>                  </span><span style=color:#b44>&#34;--logtostderr=true&#34;</span>,<span style=color:#bbb>
</span><span style=color:#bbb>                  </span><span style=color:#b44>&#34;--ca-cert=/var/run/secrets/kubernetes.io/serviceaccount/ca.crt&#34;</span>,<span style=color:#bbb>
</span><span style=color:#bbb>                  </span><span style=color:#080;font-style:italic># Since the konnectivity server runs with hostNetwork=true,</span><span style=color:#bbb>
</span><span style=color:#bbb>                  </span><span style=color:#080;font-style:italic># this is the IP address of the master machine.</span><span style=color:#bbb>
</span><span style=color:#bbb>                  </span><span style=color:#b44>&#34;--proxy-server-host=35.225.206.7&#34;</span>,<span style=color:#bbb>
</span><span style=color:#bbb>                  </span><span style=color:#b44>&#34;--proxy-server-port=8132&#34;</span>,<span style=color:#bbb>
</span><span style=color:#bbb>                  </span><span style=color:#b44>&#34;--admin-server-port=8133&#34;</span>,<span style=color:#bbb>
</span><span style=color:#bbb>                  </span><span style=color:#b44>&#34;--health-server-port=8134&#34;</span>,<span style=color:#bbb>
</span><span style=color:#bbb>                  </span><span style=color:#b44>&#34;--service-account-token-path=/var/run/secrets/tokens/konnectivity-agent-token&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>                  </span>]<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/var/run/secrets/tokens<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>konnectivity-agent-token<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>livenessProbe</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>httpGet</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>8134</span><span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/healthz<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>initialDelaySeconds</span>:<span style=color:#bbb> </span><span style=color:#666>15</span><span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>timeoutSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>15</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>serviceAccountName</span>:<span style=color:#bbb> </span>konnectivity-agent<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>konnectivity-agent-token<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>projected</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>sources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span>- <span style=color:green;font-weight:700>serviceAccountToken</span>:<span style=color:#bbb>
</span><span style=color:#bbb>                  </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>konnectivity-agent-token<span style=color:#bbb>
</span><span style=color:#bbb>                  </span><span style=color:green;font-weight:700>audience</span>:<span style=color:#bbb> </span>system:konnectivity-server<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>最后，如果你的集群启用了 RBAC，请创建相关的 RBAC 规则：</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/admin/konnectivity/konnectivity-rbac.yaml download=admin/konnectivity/konnectivity-rbac.yaml><code>admin/konnectivity/konnectivity-rbac.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('admin-konnectivity-konnectivity-rbac-yaml')" title="Copy admin/konnectivity/konnectivity-rbac.yaml to clipboard">
</img>
</div>
<div class=includecode id=admin-konnectivity-konnectivity-rbac-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRoleBinding<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>system:konnectivity-server<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubernetes.io/cluster-service</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>addonmanager.kubernetes.io/mode</span>:<span style=color:#bbb> </span>Reconcile<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>roleRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>system:auth-delegator<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>subjects</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>User<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>system:konnectivity-server<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ServiceAccount<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>konnectivity-agent<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>kube-system<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubernetes.io/cluster-service</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>addonmanager.kubernetes.io/mode</span>:<span style=color:#bbb> </span>Reconcile<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-d3c88a8663f58e9ec0bed73faff5b670>14 - TLS</h1>
<div class=lead>了解如何使用传输层安全性（ TLS ）保护集群中的流量。</div>
</div>
<div class=td-content>
<h1 id=pg-1272b18ac0c008f6ffc2c62a29fa929f>14.1 - 为 kubelet 配置证书轮换</h1>
<p>本文展示如何在 kubelet 中启用并配置证书轮换。</p>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.19 [stable]</code>
</div>
<h2 id=before-you-begin>Before you begin</h2>
<ul>
<li>要求 Kubernetes 1.8.0 或更高的版本</li>
</ul>
<h2 id=概述>概述</h2>
<p>Kubelet 使用证书进行 Kubernetes API 的认证。
默认情况下，这些证书的签发期限为一年，所以不需要太频繁地进行更新。</p>
<p>Kubernetes 包含特性
<a href=/zh/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/>kubelet 证书轮换</a>，
在当前证书即将过期时，
将自动生成新的秘钥，并从 Kubernetes API 申请新的证书。 一旦新的证书可用，它将被用于与
Kubernetes API 间的连接认证。</p>
<h2 id=启用客户端证书轮换>启用客户端证书轮换</h2>
<p><code>kubelet</code> 进程接收 <code>--rotate-certificates</code> 参数，该参数决定 kubelet 在当前使用的
证书即将到期时，是否会自动申请新的证书。</p>
<p><code>kube-controller-manager</code> 进程接收 <code>--cluster-signing-duration</code> 参数
（在 1.19 版本之前为 <code>--experimental-cluster-signing-duration</code>），用来
控制签发证书的有效期限。</p>
<h2 id=理解证书轮换配置>理解证书轮换配置</h2>
<p>当 kubelet 启动时，如被配置为自举（使用<code>--bootstrap-kubeconfig</code> 参数），kubelet
会使用其初始证书连接到 Kubernetes API ，并发送证书签名的请求。
可以通过以下方式查看证书签名请求的状态：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get csr
</code></pre></div>
<p>最初，来自节点上 kubelet 的证书签名请求处于 <code>Pending</code> 状态。 如果证书签名请求满足特定条件，
控制器管理器会自动批准，此时请求会处于 <code>Approved</code> 状态。 接下来，控制器管理器会签署证书，
证书的有效期限由 <code>--cluster-signing-duration</code> 参数指定，签署的证书会被附加到证书签名请求中。</p>
<p>Kubelet 会从 Kubernetes API 取回签署的证书，并将其写入磁盘，存储位置通过 <code>--cert-dir</code>
参数指定。
然后 kubelet 会使用新的证书连接到 Kubernetes API。</p>
<p>当签署的证书即将到期时，kubelet 会使用 Kubernetes API，自动发起新的证书签名请求。
该请求会发生在证书的有效时间剩下 30% 到 10% 之间的任意时间点。
同样地，控制器管理器会自动批准证书请求，并将签署的证书附加到证书签名请求中。 Kubelet
会从 Kubernetes API 取回签署的证书，并将其写入磁盘。 然后它会更新与 Kubernetes API
的连接，使用新的证书重新连接到 Kubernetes API。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-43d5e2b1fc2a7e104e66d481d08578dc>14.2 - 手动轮换 CA 证书</h1>
<p>本页展示如何手动轮换证书机构（CA）证书。</p>
<h2 id=before-you-begin>Before you begin</h2>
<p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li>
</ul>
Your Kubernetes server must be at or later than version v1.13.
To check the version, enter <code>kubectl version</code>.
</p>
<ul>
<li>要了解 Kubernetes 中用户认证的更多信息，参阅
<a href=/zh/docs/reference/access-authn-authz/authentication>认证</a>；</li>
<li>要了解与 CA 证书最佳实践有关的更多信息，参阅<a href=/zh/docs/setup/best-practices/certificates/#single-root-ca>单根 CA</a>。</li>
</ul>
<h2 id=rotate-the-ca-certificates-manually>手动轮换 CA 证书 </h2>
<div class="alert alert-warning caution callout" role=alert>
<strong>Caution:</strong> <p>确保备份你的证书目录、配置文件以及其他必要文件。</p>
<p>这里的方法假定 Kubernetes 的控制面通过运行多个 API 服务器以高可用配置模式运行。
另一假定是 API 服务器可体面地终止，因而客户端可以彻底地与一个 API 服务器断开
连接并连接到另一个 API 服务器。</p>
<p>如果集群中只有一个 API 服务器，则在 API 服务器重启期间会经历服务中断期。</p>
</div>
<ol>
<li>将新的 CA 证书和私钥（例如：<code>ca.crt</code>、<code>ca.key</code>、<code>front-proxy-ca.crt</code> 和
<code>front-proxy-client.key</code>）分发到所有控制面节点，放在其 Kubernetes 证书目录下。</li>
</ol>
<ol start=2>
<li>
<p>更新 <a class=glossary-tooltip title=主节点上运行控制器的组件。 data-toggle=tooltip data-placement=top href=/docs/reference/generated/kube-controller-manager/ target=_blank aria-label=kube-controller-manager>kube-controller-manager</a> 的
<code>--root-ca-file</code> 标志，使之同时包含老的和新的 CA，之后重启组件。</p>
<p>自此刻起，所创建的所有服务账号都会获得同时包含老的 CA 和新的 CA 的 Secret。</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> kube-controller-manager 标志 <code>--client-ca-file</code> 和 <code>--cluster-signing-cert-file</code> 所引用的文件
不能是 CA 证书包。如果这些标志和 <code>--root-ca-file</code> 指向同一个 <code>ca.crt</code> 包文件（包含老的和新的 CA 证书），
你将会收到出错信息。
要解决这个问题，可以将新的 CA 证书复制到单独的文件中，并将 <code>--client-ca-file</code> 和 <code>--cluster-signing-cert-file</code>
标志指向该副本。一旦 <code>ca.crt</code> 不再是证书包文件，就可以恢复有问题的标志指向 <code>ca.crt</code> 并删除该副本。
</div>
</li>
</ol>
<ol start=3>
<li>
<p>更新所有服务账号令牌，使之同时包含老的和新的 CA 证书。</p>
<p>如果在 API 服务器使用新的 CA 之前启动了新的 Pod，这些 Pod
也会获得此更新并且同时信任老的和新的 CA 证书。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#b8860b>base64_encoded_ca</span><span style=color:#666>=</span><span style=color:#b44>&#34;</span><span style=color:#a2f;font-weight:700>$(</span>base64 -w0 &lt;path to file containing both old and new CAs&gt;<span style=color:#a2f;font-weight:700>)</span><span style=color:#b44>&#34;</span>

<span style=color:#a2f;font-weight:700>for</span> namespace in <span style=color:#a2f;font-weight:700>$(</span>kubectl get ns --no-headers | awk <span style=color:#b44>&#39;{print $1}&#39;</span><span style=color:#a2f;font-weight:700>)</span>; <span style=color:#a2f;font-weight:700>do</span>
    <span style=color:#a2f;font-weight:700>for</span> token in <span style=color:#a2f;font-weight:700>$(</span>kubectl get secrets --namespace <span style=color:#b44>&#34;</span><span style=color:#b8860b>$namespace</span><span style=color:#b44>&#34;</span> --field-selector <span style=color:#b8860b>type</span><span style=color:#666>=</span>kubernetes.io/service-account-token -o name<span style=color:#a2f;font-weight:700>)</span>; <span style=color:#a2f;font-weight:700>do</span>
        kubectl get <span style=color:#b8860b>$token</span> --namespace <span style=color:#b44>&#34;</span><span style=color:#b8860b>$namespace</span><span style=color:#b44>&#34;</span> -o yaml | <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>          /bin/sed <span style=color:#b44>&#34;s/\(ca.crt:\).*/\1 </span><span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>base64_encoded_ca</span><span style=color:#b68;font-weight:700>}</span><span style=color:#b44>/&#34;</span> | <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>          kubectl apply -f -
    <span style=color:#a2f;font-weight:700>done</span>
<span style=color:#a2f;font-weight:700>done</span>
</code></pre></div></li>
</ol>
<ol start=4>
<li>
<p>重启所有使用集群内配置的 Pods（例如：<code>kube-proxy</code>、<code>coredns</code> 等），以便这些 Pod 能够使用
来自 <em>ServiceAccount</em> Secret 中的、已更新的证书机构数据。</p>
<ul>
<li>确保 <code>coredns</code>、<code>kube-proxy</code> 和其他使用集群内配置的 Pod 都正按预期方式工作。</li>
</ul>
</li>
<li>
<p>将老的和新的 CA 都追加到 <code>kube-apiserver</code> 配置的 <code>--client-ca-file</code> 和 <code>--kubelet-certificate-authority</code> 标志所指的文件。</p>
</li>
<li>
<p>将老的和新的 CA 都追加到 <code>kube-scheduler</code> 配置的 <code>--client-ca-file</code> 标志所指的文件。</p>
</li>
</ol>
<ol start=7>
<li>
<p>通过替换 <code>client-certificate-data</code> 和 <code>client-key-data</code>
中的内容，更新用户账号的证书。</p>
<p>有关为独立用户账号创建证书的更多信息，可参阅
<a href=/zh/docs/setup/best-practices/certificates/#configure-certificates-for-user-accounts>为用户帐号配置证书</a>。</p>
<p>另外，还要更新 kubeconfig 文件中的 <code>certificate-authority-data</code>
节，使之包含 Base64 编码的老的和新的证书机构数据。</p>
</li>
</ol>
<ol start=8>
<li>
<p>遵循下列步骤执行滚动更新</p>
<ol>
<li>
<p>重新启动所有其他 <em><a href=/zh/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/>被聚合的 API 服务器</a></em>
或者 <em>Webhook 处理程序</em>，使之信任新的 CA 证书。</p>
</li>
<li>
<p>在所有节点上更新 kubelet 配置中的 <code>clientCAFile</code> 所指文件以及 kubelet.conf 中的
<code>certificate-authority-data</code> 并重启 kubelet 以同时使用老的和新的 CA 证书。</p>
<p>如果你的 kubelet 并未使用客户端证书轮换，则在所有节点上更新 kubelet.conf 中
<code>client-certificate-data</code> 和 <code>client-key-data</code> 以及 kubelet
客户端证书文件（通常位于 <code>/var/lib/kubelet/pki</code> 目录下）</p>
</li>
</ol>
<ol start=3>
<li>
<p>使用用新的 CA 签名的证书
（<code>apiserver.crt</code>、<code>apiserver-kubelet-client.crt</code> 和 <code>front-proxy-client.crt</code>）
来重启 API 服务器。
你可以使用现有的私钥，也可以使用新的私钥。
如果你改变了私钥，则要将更新的私钥也放到 Kubernetes 证书目录下。</p>
<p>由于 Pod 既信任老的 CA 也信任新的 CA，Pod 中的客户端会经历短暂的连接断开状态，
之后再连接到使用新的 CA 所签名的证书的新的 API 服务器。</p>
<ul>
<li>重启调度器以使用新的 CA 证书。</li>
<li>确保控制面组件的日志中没有 TLS 相关的错误信息。</li>
</ul>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 要使用 <code>openssl</code> 命令行为集群生成新的证书和私钥，可参阅
<a href=/zh/docs/tasks/administer-cluster/certificates/#openssl>证书（<code>openssl</code>）</a>。
你也可以使用<a href=/zh/docs/tasks/administer-cluster/certificates/#cfssl><code>cfssl</code></a>.
</div>
</li>
</ol>
<ol start=4>
<li>
<p>为 Daemonset 和 Deployment 添加注解，从而触发较安全的滚动更新，替换 Pod。</p>
<p>示例：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#a2f;font-weight:700>for</span> namespace in <span style=color:#a2f;font-weight:700>$(</span>kubectl get namespace -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.items[*].metadata.name}&#39;</span><span style=color:#a2f;font-weight:700>)</span>; <span style=color:#a2f;font-weight:700>do</span>
    <span style=color:#a2f;font-weight:700>for</span> name in <span style=color:#a2f;font-weight:700>$(</span>kubectl get deployments -n <span style=color:#b8860b>$namespace</span> -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.items[*].metadata.name}&#39;</span><span style=color:#a2f;font-weight:700>)</span>; <span style=color:#a2f;font-weight:700>do</span>
        kubectl patch deployment -n <span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>namespace</span><span style=color:#b68;font-weight:700>}</span> <span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>name</span><span style=color:#b68;font-weight:700>}</span> -p <span style=color:#b44>&#39;{&#34;spec&#34;:{&#34;template&#34;:{&#34;metadata&#34;:{&#34;annotations&#34;:{&#34;ca-rotation&#34;: &#34;1&#34;}}}}}&#39;</span>;
    <span style=color:#a2f;font-weight:700>done</span>
    <span style=color:#a2f;font-weight:700>for</span> name in <span style=color:#a2f;font-weight:700>$(</span>kubectl get daemonset -n <span style=color:#b8860b>$namespace</span> -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.items[*].metadata.name}&#39;</span><span style=color:#a2f;font-weight:700>)</span>; <span style=color:#a2f;font-weight:700>do</span>
        kubectl patch daemonset -n <span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>namespace</span><span style=color:#b68;font-weight:700>}</span> <span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>name</span><span style=color:#b68;font-weight:700>}</span> -p <span style=color:#b44>&#39;{&#34;spec&#34;:{&#34;template&#34;:{&#34;metadata&#34;:{&#34;annotations&#34;:{&#34;ca-rotation&#34;: &#34;1&#34;}}}}}&#39;</span>;
    <span style=color:#a2f;font-weight:700>done</span>
<span style=color:#a2f;font-weight:700>done</span>
</code></pre></div>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 要限制应用可能受到的并发干扰数量，可以参阅
<a href=/zh/docs/tasks/run-application/configure-pdb/>配置 Pod 干扰预算</a>.
</div>
</li>
</ol>
</li>
</ol>
<ol start=9>
<li>
<p>如果你的集群使用启动引导令牌来添加节点，则需要更新 <code>kube-public</code> 名字空间下的
ConfigMap <code>cluster-info</code>，使之包含新的 CA 证书。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#b8860b>base64_encoded_ca</span><span style=color:#666>=</span><span style=color:#b44>&#34;</span><span style=color:#a2f;font-weight:700>$(</span>base64 -w0 /etc/kubernetes/pki/ca.crt<span style=color:#a2f;font-weight:700>)</span><span style=color:#b44>&#34;</span>

kubectl get cm/cluster-info --namespace kube-public -o yaml | <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>    /bin/sed <span style=color:#b44>&#34;s/\(certificate-authority-data:\).*/\1 </span><span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>base64_encoded_ca</span><span style=color:#b68;font-weight:700>}</span><span style=color:#b44>/&#34;</span> | <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>    kubectl apply -f -
</code></pre></div></li>
</ol>
<ol start=10>
<li>
<p>验证集群的功能正常</p>
<ol>
<li>
<p>验证控制面组件的日志，以及 <code>kubelet</code> 和 <code>kube-proxy</code> 的日志，确保其中没有
抛出 TLS 错误，参阅
<a href=/zh/docs/tasks/debug-application-cluster/debug-cluster/#looking-at-logs>查看日志</a>.</p>
</li>
<li>
<p>验证被聚合的 API 服务器的日志，以及所有使用集群内配置的 Pod 的日志。</p>
</li>
</ol>
</li>
</ol>
<ol start=11>
<li>
<p>完成集群功能的检查之后：</p>
<ol>
<li>
<p>更新所有的服务账号令牌，使之仅包含新的 CA 证书。</p>
<ul>
<li>使用集群内 kubeconfig 的 Pod 最终也需要被重启，以获得新的服务账号 Secret
数据，进而不再信任老的 CA 证书。</li>
</ul>
</li>
<li>
<p>从 kubeconfig 文件和 <code>--client-ca-file</code> 以及 <code>--root-ca-file</code> 标志所指向的文件
中去除老的 CA 数据，之后重启控制面组件。</p>
</li>
<li>
<p>重启 kubelet，移除 <code>clientCAFile</code> 标志所指向的文件以及 kubelet kubeconfig 文件中
的老的 CA 数据。</p>
</li>
</ol>
</li>
</ol>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-9a87de8ee8332cb487f34a05debb1125>14.3 - 管理集群中的 TLS 认证</h1>
<p>Kubernetes 提供 <code>certificates.k8s.io</code> API，可让你配置由你控制的证书颁发机构（CA）
签名的 TLS 证书。 你的工作负载可以使用这些 CA 和证书来建立信任。</p>
<p><code>certificates.k8s.io</code> API使用的协议类似于
<a href=https://github.com/ietf-wg-acme/acme/>ACME 草案</a>。</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong>
<p>使用 <code>certificates.k8s.io</code> API 创建的证书由指定 <a href=#a-note-to-cluster-administrators>CA</a> 颁发。
将集群配置为使用集群根目录 CA 可以达到这个目的，但是你永远不要依赖这一假定。
不要以为这些证书将针对群根目录 CA 进行验证。
</div>
<h2 id=before-you-begin>Before you begin</h2>
<p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li>
</ul>
<p>你需要 <code>cfssl</code> 工具。
你可以从 <a href=https://github.com/cloudflare/cfssl/releases>https://github.com/cloudflare/cfssl/releases</a>
下载 <code>cfssl</code>。</p>
<p>本文中某些步骤使用 <code>jq</code> 工具。如果你没有 <code>jq</code>，你可以通过操作系统的软件源安装，
或者从 <a href=https://stedolan.github.io/jq/>https://stedolan.github.io/jq/</a> 获取。</p>
<h2 id=集群中的-tls-信任>集群中的 TLS 信任</h2>
<p>信任 Pod 中运行的应用程序所提供的<a href=#a-note-to-cluster-administrators>自定义 CA</a> 通常需要一些额外的应用程序配置。
你需要将 CA 证书包添加到 TLS 客户端或服务器信任的 CA 证书列表中。
例如，你可以使用 Golang TLS 配置通过解析证书链并将解析的证书添加到
<a href=https://pkg.go.dev/crypto/tls#Config><code>tls.Config</code></a> 结构中的 <code>RootCAs</code>
字段中。</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong>
<p>即使自定义 CA 证书可能包含在文件系统中（在 ConfigMap <code>kube-root-ca.crt</code> 中），
除了验证内部 Kubernetes 端点之外，你不应将该证书颁发机构用于任何目的。
内部 Kubernetes 端点的一个示例是默认命名空间中名为 <code>kubernetes</code> 的服务。</p>
<p>如果你想为你的工作负载使用自定义证书颁发机构，你应该单独生成该 CA，
并使用你的 Pod 有读权限的 <a href=/zh/docs/tasks/configure-pod-container/configure-pod-configmap>ConfigMap</a>
分发该 CA 证书。</p>
</div>
<h2 id=请求证书>请求证书</h2>
<p>以下部分演示如何为通过 DNS 访问的 Kubernetes 服务创建 TLS 证书。</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 本教程使用 CFSSL：Cloudflare's PKI 和 TLS 工具包
<a href=https://blog.cloudflare.com/introducing-cfssl/>点击此处</a>了解更多信息。
</div>
<h2 id=创建证书签名请求>创建证书签名请求</h2>
<p>通过运行以下命令生成私钥和证书签名请求（或 CSR）:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>cat <span style=color:#b44>&lt;&lt;EOF | cfssl genkey - | cfssljson -bare server
</span><span style=color:#b44>{
</span><span style=color:#b44>  &#34;hosts&#34;: [
</span><span style=color:#b44>    &#34;my-svc.my-namespace.svc.cluster.local&#34;,
</span><span style=color:#b44>    &#34;my-pod.my-namespace.pod.cluster.local&#34;,
</span><span style=color:#b44>    &#34;192.0.2.24&#34;,
</span><span style=color:#b44>    &#34;10.0.34.2&#34;
</span><span style=color:#b44>  ],
</span><span style=color:#b44>  &#34;CN&#34;: &#34;my-pod.my-namespace.pod.cluster.local&#34;,
</span><span style=color:#b44>  &#34;key&#34;: {
</span><span style=color:#b44>    &#34;algo&#34;: &#34;ecdsa&#34;,
</span><span style=color:#b44>    &#34;size&#34;: 256
</span><span style=color:#b44>  }
</span><span style=color:#b44>}
</span><span style=color:#b44>EOF</span>
</code></pre></div>
<p>其中 <code>192.0.2.24</code> 是服务的集群 IP，<code>my-svc.my-namespace.svc.cluster.local</code>
是服务的 DNS 名称，<code>10.0.34.2</code> 是 Pod 的 IP，而
<code>my-pod.my-namespace.pod.cluster.local</code> 是 Pod 的 DNS 名称。
你能看到的输出类似于：</p>
<pre><code>2022/02/01 11:45:32 [INFO] generate received request
2022/02/01 11:45:32 [INFO] received CSR
2022/02/01 11:45:32 [INFO] generating key: ecdsa-256
2022/02/01 11:45:32 [INFO] encoded CSR
</code></pre>
<p>此命令生成两个文件；它生成包含 PEM 编码
<a href=https://tools.ietf.org/html/rfc2986>PKCS#10</a> 证书请求的 <code>server.csr</code>，
以及 PEM 编码密钥的 <code>server-key.pem</code>，用于待生成的证书。</p>
<h2 id=创建证书签名请求-csr-对象发送到-kubernetes-api>创建证书签名请求（CSR）对象发送到 Kubernetes API</h2>
<p>使用以下命令创建 CSR YAML 文件，并发送到 API 服务器：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>cat <span style=color:#b44>&lt;&lt;EOF | kubectl apply -f -
</span><span style=color:#b44>apiVersion: certificates.k8s.io/v1
</span><span style=color:#b44>kind: CertificateSigningRequest
</span><span style=color:#b44>metadata:
</span><span style=color:#b44>  name: my-svc.my-namespace
</span><span style=color:#b44>spec:
</span><span style=color:#b44>  request: $(cat server.csr | base64 | tr -d &#39;\n&#39;)
</span><span style=color:#b44>  signerName: example.com/serving
</span><span style=color:#b44>  usages:
</span><span style=color:#b44>  - digital signature
</span><span style=color:#b44>  - key encipherment
</span><span style=color:#b44>  - server auth
</span><span style=color:#b44>EOF</span>
</code></pre></div>
<p>请注意，在步骤 1 中创建的 <code>server.csr</code> 文件是 base64 编码并存储在
<code>.spec.request</code> 字段中的。你还要求提供 “digital signature（数字签名）”，
“密钥加密（key encipherment）” 和 “服务器身份验证（server auth）” 密钥用途，
由 <code>example.com/serving</code> 示例签名程序签名的证书。
你也可以要求使用特定的 <code>signerName</code>。更多信息可参阅
<a href=/zh/docs/reference/access-authn-authz/certificate-signing-requests/#signers>支持的签署者名称</a>。</p>
<p>在 API server 中可以看到这些 CSR 处于 Pending 状态。执行下面的命令你将可以看到：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe csr my-svc.my-namespace
</code></pre></div><pre><code class=language-none data-lang=none>Name:                   my-svc.my-namespace
Labels:                 &lt;none&gt;
Annotations:            &lt;none&gt;
CreationTimestamp:      Tue, 01 Feb 2022 11:49:15 -0500
Requesting User:        yourname@example.com
Signer:                 example.com/serving
Status:                 Pending
Subject:
        Common Name:    my-pod.my-namespace.pod.cluster.local
        Serial Number:
Subject Alternative Names:
        DNS Names:      my-pod.my-namespace.pod.cluster.local
                        my-svc.my-namespace.svc.cluster.local
        IP Addresses:   192.0.2.24
                        10.0.34.2
Events: &lt;none&gt;
</code></pre>
<h2 id=get-the-certificate-signing-request-approved>批准证书签名请求（CSR） </h2>
<p><a href=/zh/docs/reference/access-authn-authz/certificate-signing-requests/>证书签名请求</a>
的批准或者是通过自动批准过程完成的，或由集群管理员一次性完成。
如果你被授权批准证书请求，你可以使用 <code>kubectl</code> 来手动完成此操作；例如：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl certificate approve my-svc.my-namespace
</code></pre></div><pre><code class=language-none data-lang=none>certificatesigningrequest.certificates.k8s.io/my-svc.my-namespace approved
</code></pre>
<p>你现在应该能看到如下输出：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get csr
</code></pre></div><pre><code class=language-none data-lang=none>NAME                  AGE   SIGNERNAME            REQUESTOR              REQUESTEDDURATION   CONDITION
my-svc.my-namespace   10m   example.com/serving   yourname@example.com   &lt;none&gt;              Approved
</code></pre>
<p>这意味着证书请求已被批准，并正在等待请求的签名者对其签名。</p>
<h2 id=sign-the-certificate-signing-request>签名证书签名请求（CSR）</h2>
<p>接下来，你将扮演证书签署者的角色，颁发证书并将其上传到 API 服务器。</p>
<p>签名者通常会使用其 <code>signerName</code> 查看对象的 CertificateSigningRequest API，
检查它们是否已被批准，为这些请求签署证书，并使用已颁发的证书更新 API 对象状态。</p>
<h3 id=创建证书颁发机构>创建证书颁发机构</h3>
<p>你需要授权在新证书上提供数字签名。</p>
<p>首先，通过运行以下命令创建签名证书：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>cat <span style=color:#b44>&lt;&lt;EOF | cfssl gencert -initca - | cfssljson -bare ca
</span><span style=color:#b44>{
</span><span style=color:#b44>  &#34;CN&#34;: &#34;My Example Signer&#34;,
</span><span style=color:#b44>  &#34;key&#34;: {
</span><span style=color:#b44>    &#34;algo&#34;: &#34;rsa&#34;,
</span><span style=color:#b44>    &#34;size&#34;: 2048
</span><span style=color:#b44>  }
</span><span style=color:#b44>}
</span><span style=color:#b44>EOF</span>
</code></pre></div>
<p>你应该看到类似于以下的输出：</p>
<pre><code class=language-none data-lang=none>2022/02/01 11:50:39 [INFO] generating a new CA key and certificate from CSR
2022/02/01 11:50:39 [INFO] generate received request
2022/02/01 11:50:39 [INFO] received CSR
2022/02/01 11:50:39 [INFO] generating key: rsa-2048
2022/02/01 11:50:39 [INFO] encoded CSR
2022/02/01 11:50:39 [INFO] signed certificate with serial number 263983151013686720899716354349605500797834580472
</code></pre>
<p>这会产生一个证书颁发机构密钥文件（<code>ca-key.pem</code>）和证书（<code>ca.pem</code>）。</p>
<h3 id=颁发证书>颁发证书</h3>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/tls/server-signing-config.json download=tls/server-signing-config.json><code>tls/server-signing-config.json</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('tls-server-signing-config-json')" title="Copy tls/server-signing-config.json to clipboard">
</img>
</div>
<div class=includecode id=tls-server-signing-config-json>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
    <span style=color:green;font-weight:700>&#34;signing&#34;</span>: {
        <span style=color:green;font-weight:700>&#34;default&#34;</span>: {
            <span style=color:green;font-weight:700>&#34;usages&#34;</span>: [
                <span style=color:#b44>&#34;digital signature&#34;</span>,
                <span style=color:#b44>&#34;key encipherment&#34;</span>,
                <span style=color:#b44>&#34;server auth&#34;</span>
            ],
            <span style=color:green;font-weight:700>&#34;expiry&#34;</span>: <span style=color:#b44>&#34;876000h&#34;</span>,
            <span style=color:green;font-weight:700>&#34;ca_constraint&#34;</span>: {
                <span style=color:green;font-weight:700>&#34;is_ca&#34;</span>: <span style=color:#a2f;font-weight:700>false</span>
            }
        }
    }
}</code></pre></div>
</div>
</div>
<p>使用 <code>server-signing-config.json</code> 签名配置、证书颁发机构密钥文件和证书来签署证书请求：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get csr my-svc.my-namespace -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.spec.request}&#39;</span> | <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  base64 --decode | <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  cfssl sign -ca ca.pem -ca-key ca-key.pem -config server-signing-config.json - | <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  cfssljson -bare ca-signed-server
</code></pre></div>
<p>你应该看到类似于以下的输出：</p>
<pre><code>2022/02/01 11:52:26 [INFO] signed certificate with serial number 576048928624926584381415936700914530534472870337
</code></pre>
<p>这会生成一个签名的服务证书文件，<code>ca-signed-server.pem</code>。</p>
<h3 id=上传签名证书>上传签名证书</h3>
<p>最后，在 API 对象的状态中填充签名证书：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get csr my-svc.my-namespace -o json | <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  jq <span style=color:#b44>&#39;.status.certificate = &#34;&#39;</span><span style=color:#a2f;font-weight:700>$(</span>base64 ca-signed-server.pem | tr -d <span style=color:#b44>&#39;\n&#39;</span><span style=color:#a2f;font-weight:700>)</span><span style=color:#b44>&#39;&#34;&#39;</span> | <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  kubectl replace --raw /apis/certificates.k8s.io/v1/certificatesigningrequests/my-svc.my-namespace/status -f -
</code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>Note:</strong>
<p>这使用命令行工具 <a href=https://stedolan.github.io/jq/><code>jq</code></a>
在 <code>.status.certificate</code> 字段中填充 base64 编码的内容。
如果你没有 <code>jq</code> 工具，你还可以将 JSON 输出保存到文件中，手动填充此字段，然后上传结果文件。
</div>
<p>批准 CSR 并上传签名证书后，运行：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get csr
</code></pre></div>
<p>输入类似于：</p>
<pre><code class=language-none data-lang=none>NAME                  AGE   SIGNERNAME            REQUESTOR              REQUESTEDDURATION   CONDITION
my-svc.my-namespace   20m   example.com/serving   yourname@example.com   &lt;none&gt;              Approved,Issued
</code></pre>
<h2 id=下载证书并使用它>下载证书并使用它</h2>
<p>现在，作为请求用户，你可以通过运行以下命令下载颁发的证书并将其保存到 <code>server.crt</code> 文件中：</p>
<p>CSR 被签署并获得批准后，你应该看到以下内容：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get csr my-svc.my-namespace -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.status.certificate}&#39;</span> <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>    | base64 --decode &gt; server.crt
</code></pre></div>
<p>现在你可以将 <code>server.crt</code> 和 <code>server-key.pem</code> 填充到
<a class=glossary-tooltip title="Secret 用于存储敏感信息，如密码、 OAuth 令牌和 SSH 密钥。" data-toggle=tooltip data-placement=top href=/zh/docs/concepts/configuration/secret/ target=_blank aria-label=Secret>Secret</a> 中，
稍后你可以将其挂载到 Pod 中（例如，用于提供 HTTPS 的网络服务器）。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create secret tls server --cert server.crt --key server-key.pem
</code></pre></div><pre><code class=language-none data-lang=none>secret/server created
</code></pre>
<p>最后，你可以将 <code>ca.pem</code> 填充到
<a class=glossary-tooltip title="ConfigMap 是一种 API 对象，用来将非机密性的数据保存到键值对中。使用时可以用作环境变量、命令行参数或者存储卷中的配置文件。" data-toggle=tooltip data-placement=top href=/zh/docs/tasks/configure-pod-container/configure-pod-configmap/ target=_blank aria-label=ConfigMap>ConfigMap</a>
并将其用作信任根来验证服务证书：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create configmap example-serving-ca --from-file ca.crt<span style=color:#666>=</span>ca.pem
</code></pre></div><pre><code class=language-none data-lang=none>configmap/example-serving-ca created
</code></pre>
<h2 id=approving-certificate-signing-requests>批准证书签名请求（CSR） </h2>
<p>Kubernetes 管理员（具有适当权限）可以使用 <code>kubectl certificate approve</code> 和
<code>kubectl certificate deny</code> 命令手动批准（或拒绝）证书签名请求（CSR）。
但是，如果你打算大量使用此 API，则可以考虑编写自动化的证书控制器。</p>
<div class="alert alert-warning caution callout" role=alert>
<strong>Caution:</strong>
<p>批准证书 CSR 的能力决定了在你的环境中谁信任谁。
不应广泛或轻率地授予批准 CSR 的能力。</p>
<p>在授予 <code>approve</code> 权限之前，你应该确保自己充分了解批准人的验证要求<strong>和</strong>颁发特定证书的后果。</p>
</div>
<p>无论上述机器或人使用 kubectl，“批准者”的作用是验证 CSR 满足如下两个要求：</p>
<ol>
<li>CSR 的 subject 控制用于签署 CSR 的私钥。这解决了伪装成授权主体的第三方的威胁。
在上述示例中，此步骤将验证该 Pod 控制了用于生成 CSR 的私钥。</li>
<li>CSR 的 subject 被授权在请求的上下文中执行。
这点用于处理不期望的主体被加入集群的威胁。
在上述示例中，此步骤将是验证该 Pod 是否被允许加入到所请求的服务中。</li>
</ol>
<p>当且仅当满足这两个要求时，审批者应该批准 CSR，否则拒绝 CSR。</p>
<p>有关证书批准和访问控制的更多信息，
请阅读<a href=/zh/docs/reference/access-authn-authz/certificate-signing-requests/>证书签名请求</a>参考页。</p>
<h2 id=给集群管理员的一个建议>给集群管理员的一个建议</h2>
<p>本页面假设已经为 certificates API 配置了签名者。
Kubernetes 控制器管理器提供了一个签名者的默认实现。要启用它，请为控制器管理器设置
<code>--cluster-signing-cert-file</code> 和 <code>--cluster-signing-key-file</code> 参数，
使之取值为你的证书机构的密钥对的路径。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-ba58efa15c6d46f10e34d799be220965>15 - 管理集群守护进程</h1>
<div class=lead>执行 DaemonSet 管理的常见任务，例如执行滚动更新。</div>
</div>
<div class=td-content>
<h1 id=pg-bcfd795e4b59420f7db275a0482af37c>15.1 - 对 DaemonSet 执行滚动更新</h1>
<p>本文介绍了如何对 DaemonSet 执行滚动更新。</p>
<h2 id=before-you-begin>Before you begin</h2>
<p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li>
</ul>
<h2 id=daemonset-更新策略>DaemonSet 更新策略</h2>
<p>DaemonSet 有两种更新策略：</p>
<ul>
<li><code>OnDelete</code>: 使用 <code>OnDelete</code> 更新策略时，在更新 DaemonSet 模板后，只有当你手动删除老的
DaemonSet pods 之后，新的 DaemonSet Pod <em>才会</em>被自动创建。跟 Kubernetes 1.6 以前的版本类似。</li>
<li><code>RollingUpdate</code>: 这是默认的更新策略。使用 <code>RollingUpdate</code> 更新策略时，在更新 DaemonSet 模板后，
老的 DaemonSet pods 将被终止，并且将以受控方式自动创建新的 DaemonSet pods。
更新期间，最多只能有 DaemonSet 的一个 Pod 运行于每个节点上。</li>
</ul>
<h2 id=执行滚动更新>执行滚动更新</h2>
<p>要启用 DaemonSet 的滚动更新功能，必须设置 <code>.spec.updateStrategy.type</code> 为 <code>RollingUpdate</code>。</p>
<p>你可能想设置
<a href=/zh/docs/reference/kubernetes-api/workload-resources/daemon-set-v1/#DaemonSetSpec><code>.spec.updateStrategy.rollingUpdate.maxUnavailable</code></a> (默认为 1)，
<a href=/zh/docs/reference/kubernetes-api/workload-resources/daemon-set-v1/#DaemonSetSpec><code>.spec.minReadySeconds</code></a> (默认为 0) 和
<a href=/zh/docs/reference/kubernetes-api/workload-resources/daemon-set-v1/#DaemonSetSpec><code>.spec.updateStrategy.rollingUpdate.maxSurge</code></a>
（一种 Beta 阶段的特性，默认为 0）。</p>
<h3 id=创建带有-rollingupdate-更新策略的-daemonset>创建带有 <code>RollingUpdate</code> 更新策略的 DaemonSet</h3>
<p>下面的 YAML 包含一个 DaemonSet，其更新策略为 'RollingUpdate'：</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/controllers/fluentd-daemonset.yaml download=controllers/fluentd-daemonset.yaml><code>controllers/fluentd-daemonset.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('controllers-fluentd-daemonset-yaml')" title="Copy controllers/fluentd-daemonset.yaml to clipboard">
</img>
</div>
<div class=includecode id=controllers-fluentd-daemonset-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>DaemonSet<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>fluentd-elasticsearch<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>kube-system<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>k8s-app</span>:<span style=color:#bbb> </span>fluentd-logging<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>fluentd-elasticsearch<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>updateStrategy</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>RollingUpdate<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>rollingUpdate</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>maxUnavailable</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>fluentd-elasticsearch<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>tolerations</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># this toleration is to have the daemonset runnable on master nodes</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># remove it if your masters can&#39;t run pods</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>node-role.kubernetes.io/master<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>effect</span>:<span style=color:#bbb> </span>NoSchedule<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>fluentd-elasticsearch<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>quay.io/fluentd_elasticsearch/fluentd:v2.5.2<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>varlog<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/var/log<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>varlibdockercontainers<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/var/lib/docker/containers<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>terminationGracePeriodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>30</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>varlog<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>hostPath</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/var/log<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>varlibdockercontainers<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>hostPath</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/var/lib/docker/containers<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>检查了 DaemonSet 清单中更新策略的设置之后，创建 DaemonSet：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create -f https://k8s.io/examples/controllers/fluentd-daemonset.yaml
</code></pre></div>
<p>另一种方式是如果你希望使用 <code>kubectl apply</code> 来更新 DaemonSet 的话，也可以
使用 <code>kubectl apply</code> 来创建 DaemonSet：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/controllers/fluentd-daemonset.yaml
</code></pre></div>
<h3 id=检查-daemonset-的滚动更新策略>检查 DaemonSet 的滚动更新策略</h3>
<p>首先，检查 DaemonSet 的更新策略，确保已经将其设置为 <code>RollingUpdate</code>:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get ds/fluentd-elasticsearch -o go-template<span style=color:#666>=</span><span style=color:#b44>&#39;{{.spec.updateStrategy.type}}{{&#34;\n&#34;}}&#39;</span> -n kube-system
</code></pre></div>
<p>如果还没在系统中创建 DaemonSet，请使用以下命令检查 DaemonSet 的清单：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/controllers/fluentd-daemonset.yaml --dry-run<span style=color:#666>=</span>client -o go-template<span style=color:#666>=</span><span style=color:#b44>&#39;{{.spec.updateStrategy.type}}{{&#34;\n&#34;}}&#39;</span>
</code></pre></div>
<p>两个命令的输出都应该为：</p>
<pre><code>RollingUpdate
</code></pre>
<p>如果输出不是 <code>RollingUpdate</code>，请返回并相应地修改 DaemonSet 对象或者清单。</p>
<h3 id=更新-daemonset-模板>更新 DaemonSet 模板</h3>
<p>对 <code>RollingUpdate</code> DaemonSet 的 <code>.spec.template</code> 的任何更新都将触发滚动更新。
这可以通过几个不同的 <code>kubectl</code> 命令来完成。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/controllers/fluentd-daemonset-update.yaml download=controllers/fluentd-daemonset-update.yaml><code>controllers/fluentd-daemonset-update.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('controllers-fluentd-daemonset-update-yaml')" title="Copy controllers/fluentd-daemonset-update.yaml to clipboard">
</img>
</div>
<div class=includecode id=controllers-fluentd-daemonset-update-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>DaemonSet<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>fluentd-elasticsearch<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>kube-system<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>k8s-app</span>:<span style=color:#bbb> </span>fluentd-logging<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>fluentd-elasticsearch<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>updateStrategy</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>RollingUpdate<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>rollingUpdate</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>maxUnavailable</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>fluentd-elasticsearch<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>tolerations</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># this toleration is to have the daemonset runnable on master nodes</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># remove it if your masters can&#39;t run pods</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>node-role.kubernetes.io/master<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>effect</span>:<span style=color:#bbb> </span>NoSchedule<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>fluentd-elasticsearch<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>quay.io/fluentd_elasticsearch/fluentd:v2.5.2<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>200Mi<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span>100m<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>200Mi<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>varlog<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/var/log<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>varlibdockercontainers<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/var/lib/docker/containers<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>terminationGracePeriodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>30</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>varlog<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>hostPath</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/var/log<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>varlibdockercontainers<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>hostPath</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/var/lib/docker/containers<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<h4 id=声明式命令>声明式命令</h4>
<p>如果你使用
<a href=/zh/docs/tasks/manage-kubernetes-objects/declarative-config/>配置文件</a>
来更新 DaemonSet，请使用 <code>kubectl apply</code>:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/controllers/fluentd-daemonset-update.yaml
</code></pre></div>
<h4 id=指令式命令>指令式命令</h4>
<p>如果你使用
<a href=/zh/docs/tasks/manage-kubernetes-objects/imperative-command/>指令式命令</a>
来更新 DaemonSets，请使用<code>kubectl edit</code>：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl edit ds/fluentd-elasticsearch -n kube-system
</code></pre></div>
<h5 id=只更新容器镜像>只更新容器镜像</h5>
<p>如果你只需要更新 DaemonSet 模板里的容器镜像，比如，<code>.spec.template.spec.containers[*].image</code>,
请使用 <code>kubectl set image</code>:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#a2f>set</span> image ds/fluentd-elasticsearch fluentd-elasticsearch<span style=color:#666>=</span>quay.io/fluentd_elasticsearch/fluentd:v2.6.0 -n kube-system
</code></pre></div>
<h3 id=监视滚动更新状态>监视滚动更新状态</h3>
<p>最后，观察 DaemonSet 最新滚动更新的进度：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl rollout status ds/fluentd-elasticsearch -n kube-system
</code></pre></div>
<p>当滚动更新完成时，输出结果如下：</p>
<pre><code>daemonset &quot;fluentd-elasticsearch&quot; successfully rolled out
</code></pre>
<h2 id=故障排查>故障排查</h2>
<h3 id=daemonset-滚动更新卡住>DaemonSet 滚动更新卡住</h3>
<p>有时，DaemonSet 滚动更新可能卡住，以下是一些可能的原因：</p>
<h4 id=一些节点可用资源耗尽>一些节点可用资源耗尽</h4>
<p>DaemonSet 滚动更新可能会卡住，其 Pod 至少在某个节点上无法调度运行。
当节点上<a href=/zh/docs/concepts/scheduling-eviction/node-pressure-eviction/>可用资源耗尽</a>时，
这是可能的。</p>
<p>发生这种情况时，通过对 <code>kubectl get nodes</code> 和下面命令行的输出作比较，
找出没有调度部署 DaemonSet Pods 的节点：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods -l <span style=color:#b8860b>name</span><span style=color:#666>=</span>fluentd-elasticsearch -o wide -n kube-system
</code></pre></div>
<p>一旦找到这些节点，从节点上删除一些非 DaemonSet Pod，为新的 DaemonSet Pod 腾出空间。</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 当所删除的 Pod 不受任何控制器管理，也不是多副本的 Pod时，上述操作将导致服务中断。
同时，上述操作也不会考虑
<a href=/zh/docs/tasks/run-application/configure-pdb/>PodDisruptionBudget</a>
所施加的约束。
</div>
<h4 id=不完整的滚动更新>不完整的滚动更新</h4>
<p>如果最近的 DaemonSet 模板更新被破坏了，比如，容器处于崩溃循环状态或者容器镜像不存在
（通常由于拼写错误），就会发生 DaemonSet 滚动更新中断。</p>
<p>要解决此问题，需再次更新 DaemonSet 模板。新的滚动更新不会被以前的不健康的滚动更新阻止。</p>
<h4 id=时钟偏差>时钟偏差</h4>
<p>如果在 DaemonSet 中指定了 <code>.spec.minReadySeconds</code>，主控节点和工作节点之间的时钟偏差会使
DaemonSet 无法检测到正确的滚动更新进度。</p>
<h2 id=清理>清理</h2>
<p>从名字空间中删除 DaemonSet：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete ds fluentd-elasticsearch -n kube-system
</code></pre></div><h2 id=what-s-next>What's next</h2>
<ul>
<li>查看<a href=/zh/docs/tasks/manage-daemon/rollback-daemon-set/>在 DaemonSet 上执行回滚</a></li>
<li>查看<a href=/zh/docs/concepts/workloads/controllers/daemonset/>创建 DaemonSet 以收养现有 DaemonSet Pod</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-f1bf7e426f482a85e1a417d1fd9ea7b7>15.2 - 对 DaemonSet 执行回滚</h1>
<p>本文展示了如何对 <a class=glossary-tooltip title="确保 Pod 的副本在集群中的一组节点上运行。" data-toggle=tooltip data-placement=top href=/zh/docs/concepts/workloads/controllers/daemonset/ target=_blank aria-label=DaemonSet>DaemonSet</a> 执行回滚。</p>
<h2 id=before-you-begin>Before you begin</h2>
<p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li>
</ul>
Your Kubernetes server must be at or later than version 1.7.
To check the version, enter <code>kubectl version</code>.
</p>
<p>你应该已经了解如何<a href=/zh/docs/tasks/manage-daemon/update-daemon-set/>为 DaemonSet 执行滚东更新</a>。</p>
<h2 id=对-daemonset-执行回滚>对 DaemonSet 执行回滚</h2>
<h3 id=步骤-1-找到想要-daemonset-回滚到的历史修订版本-revision>步骤 1：找到想要 DaemonSet 回滚到的历史修订版本（revision）</h3>
<p>如果只想回滚到最后一个版本，可以跳过这一步。</p>
<p>列出 DaemonSet 的所有版本：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl rollout <span style=color:#a2f>history</span> daemonset &lt;daemonset-name&gt;
</code></pre></div>
<p>此命令返回 DaemonSet 版本列表：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>daemonsets <span style=color:#b44>&#34;&lt;daemonset-name&gt;&#34;</span>
REVISION        CHANGE-CAUSE
<span style=color:#666>1</span>               ...
<span style=color:#666>2</span>               ...
...
</code></pre></div>
<ul>
<li>在创建时，DaemonSet 的变化原因从 <code>kubernetes.io/change-cause</code> 注解（annotation）
复制到其修订版本中。用户可以在 <code>kubectl</code> 命令中设置 <code>--record=true</code>，
将执行的命令记录在变化原因注解中。</li>
</ul>
<p>执行以下命令，来查看指定版本的详细信息：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl rollout <span style=color:#a2f>history</span> daemonset &lt;daemonset-name&gt; --revision<span style=color:#666>=</span><span style=color:#666>1</span>
</code></pre></div>
<p>该命令返回相应修订版本的详细信息：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>daemonsets <span style=color:#b44>&#34;&lt;daemonset-name&gt;&#34;</span> with revision <span style=color:#080;font-style:italic>#1</span>
Pod Template:
Labels:       <span style=color:#b8860b>foo</span><span style=color:#666>=</span>bar
Containers:
app:
 Image:       ...
 Port:        ...
 Environment: ...
 Mounts:      ...
Volumes:       ...
</code></pre></div>
<h3 id=步骤-2-回滚到指定版本>步骤 2：回滚到指定版本</h3>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># 在 --to-revision 中指定你从步骤 1 中获取的修订版本</span>
kubectl rollout undo daemonset &lt;daemonset-name&gt; --to-revision<span style=color:#666>=</span>&lt;revision&gt;
</code></pre></div>
<p>如果成功，命令会返回：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>daemonset <span style=color:#b44>&#34;&lt;daemonset-name&gt;&#34;</span> rolled back
</code></pre></div>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 如果 <code>--to-revision</code> 参数未指定，将选中最近的版本。
</div>
<h3 id=步骤-3-监视-daemonset-回滚进度>步骤 3：监视 DaemonSet 回滚进度</h3>
<p><code>kubectl rollout undo daemonset</code> 向服务器表明启动 DaemonSet 回滚。
真正的回滚是在集群的
<a class=glossary-tooltip title="控制平面是指容器编排层，它暴露 API 和接口来定义、部署容器和管理容器的生命周期。" data-toggle=tooltip data-placement=top href="/zh/docs/reference/glossary/?all=true#term-control-plane" target=_blank aria-label=控制面>控制面</a>
异步完成的。</p>
<p>执行以下命令，来监视 DaemonSet 回滚进度：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl rollout status ds/&lt;daemonset-name&gt;
</code></pre></div>
<p>回滚完成时，输出形如：</p>
<pre><code>daemonset &quot;&lt;daemonset-name&gt;&quot; successfully rolled out
</code></pre>
<h2 id=理解-daemonset-修订版本>理解 DaemonSet 修订版本</h2>
<p>在前面的 <code>kubectl rollout history</code> 步骤中，你获得了一个修订版本列表，每个修订版本都存储在名为
<code>ControllerRevision</code> 的资源中。</p>
<p>要查看每个修订版本中保存的内容，可以找到 DaemonSet 修订版本的原生资源：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get controllerrevision -l &lt;daemonset-selector-key&gt;<span style=color:#666>=</span>&lt;daemonset-selector-value&gt;
</code></pre></div>
<p>该命令返回 <code>ControllerRevisions</code> 列表：</p>
<pre><code>NAME                               CONTROLLER                     REVISION   AGE
&lt;daemonset-name&gt;-&lt;revision-hash&gt;   DaemonSet/&lt;daemonset-name&gt;     1          1h
&lt;daemonset-name&gt;-&lt;revision-hash&gt;   DaemonSet/&lt;daemonset-name&gt;     2          1h
</code></pre>
<p>每个 <code>ControllerRevision</code> 中存储了相应 DaemonSet 版本的注解和模板。</p>
<p><code>kubectl rollout undo</code> 选择特定的 <code>ControllerRevision</code>，并用
<code>ControllerRevision</code> 中存储的模板代替 DaemonSet 的模板。
<code>kubectl rollout undo</code> 相当于通过其他命令（如 <code>kubectl edit</code> 或 <code>kubectl apply</code>）
将 DaemonSet 模板更新至先前的版本。</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 注意 DaemonSet 修订版本只会正向变化。也就是说，回滚完成后，所回滚到的
<code>ControllerRevision</code> 版本号 (<code>.revision</code> 字段) 会增加。
例如，如果用户在系统中有版本 1 和版本 2，并从版本 2 回滚到版本 1，
带有 <code>.revision: 1</code> 的<code>ControllerRevision</code> 将变为 <code>.revision: 3</code>。
</div>
<h2 id=故障排查>故障排查</h2>
<ul>
<li>参阅 <a href=/zh/docs/tasks/manage-daemon/update-daemon-set/#troubleshooting>DaemonSet 滚动升级故障排除</a>。</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-5266308e17490aeee8b018316bf47e03>16 - 安装服务目录</h1>
<div class=lead>安装服务目录扩展 API。</div>
</div>
<div class=td-content>
<h1 id=pg-f741b6fc36e27a6f79c1c3d02a40d8f9>16.1 - 使用 Helm 安装 Service Catalog</h1>
<p><p>服务目录（Service Catalog）是 服务目录是一种扩展 API，它能让 Kubernetes 集群中运行的应用易于使用外部托管的的软件服务，例如云供应商提供的数据仓库服务。</p></p>
<p>服务目录可以检索、供应、和绑定由 <a class=glossary-tooltip title=由第三方提供并维护的一组托管服务的访问端点。 data-toggle=tooltip data-placement=top href="/zh/docs/reference/glossary/?all=true#term-service-broker" target=_blank aria-label="服务代理人（Service Brokers）">服务代理人（Service Brokers）</a>
提供的外部<a class=glossary-tooltip title=由第三方供应商负责维护的一种软件产品。 data-toggle=tooltip data-placement=top href="/zh/docs/reference/glossary/?all=true#term-managed-service" target=_blank aria-label="托管服务（Managed Services）">托管服务（Managed Services）</a>，
而无需知道那些服务具体是怎样创建和托管的。</p>
<p>使用 <a href=https://helm.sh/>Helm</a> 在 Kubernetes 集群上安装 Service Catalog。
要获取有关此过程的最新信息，请浏览 <a href=https://github.com/kubernetes-incubator/service-catalog/blob/master/docs/install.md>kubernetes-incubator/service-catalog</a> 仓库。</p>
<h2 id=before-you-begin>Before you begin</h2>
<ul>
<li>理解<a href=/zh/docs/concepts/extend-kubernetes/service-catalog/>服务目录</a> 的关键概念。</li>
<li>Service Catalog 需要 Kubernetes 集群版本在 1.7 或更高版本。</li>
<li>你必须启用 Kubernetes 集群的 DNS 功能。
<ul>
<li>如果使用基于云的 Kubernetes 集群或 <a class=glossary-tooltip title="Minikube 是用来在本地运行 Kubernetes 的一种工具。" data-toggle=tooltip data-placement=top href=/docs/getting-started-guides/minikube/ target=_blank aria-label=Minikube>Minikube</a>，则可能已经启用了集群 DNS。</li>
<li>如果你正在使用 <code>hack/local-up-cluster.sh</code>，请确保设置了 <code>KUBE_ENABLE_CLUSTER_DNS</code> 环境变量，然后运行安装脚本。</li>
</ul>
</li>
<li><a href=/zh/docs/tasks/tools/>安装和设置 v1.7 或更高版本的 kubectl</a>，确保将其配置为连接到 Kubernetes 集群。</li>
<li>安装 v2.7.0 或更高版本的 <a href=https://helm.sh/>Helm</a>。
<ul>
<li>遵照 <a href=https://helm.sh/docs/intro/install/>Helm 安装说明</a>。</li>
<li>如果已经安装了适当版本的 Helm，请执行 <code>helm init</code> 来安装 Helm 的服务器端组件 Tiller。</li>
</ul>
</li>
</ul>
<h2 id=添加-service-catalog-helm-仓库>添加 service-catalog Helm 仓库</h2>
<p>安装 Helm 后，通过执行以下命令将 <em>service-catalog</em> Helm 存储库添加到本地计算机：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>helm repo add svc-cat https://kubernetes-sigs.github.io/service-catalog
</code></pre></div>
<p>通过执行以下命令进行检查，以确保安装成功：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>helm search service-catalog
</code></pre></div>
<p>如果安装成功，该命令应输出以下内容：</p>
<pre><code>NAME            VERSION DESCRIPTION
svc-cat/catalog 0.0.1   service-catalog API server and controller-manag...
</code></pre>
<h2 id=启用-rbac>启用 RBAC</h2>
<p>你的 Kubernetes 集群必须启用 RBAC，这需要你的 Tiller Pod 具有 <code>cluster-admin</code> 访问权限。</p>
<p>如果你使用的是 Minikube，请使用以下参数运行 <code>minikube start</code> 命令：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>minikube start --extra-config<span style=color:#666>=</span>apiserver.Authorization.Mode<span style=color:#666>=</span>RBAC
</code></pre></div>
<p>如果你使用 <code>hack/local-up-cluster.sh</code>，请使用以下值设置 <code>AUTHORIZATION_MODE</code> 环境变量：</p>
<pre><code>AUTHORIZATION_MODE=Node,RBAC hack/local-up-cluster.sh -O
</code></pre>
<p>默认情况下，<code>helm init</code> 将 Tiller Pod 安装到 <code>kube-system</code> 命名空间，Tiller 配置为使用 <code>default</code> 服务帐户。</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 如果在运行 <code>helm init</code> 时使用了 <code>--tiller-namespace</code> 或 <code>--service-account</code> 参数，
则需要调整以下命令中的 <code>--serviceaccount</code> 参数以引用相应的名字空间和服务账号名称。
</div>
<p>配置 Tiller 以获得 <code>cluster-admin</code> 访问权限：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create clusterrolebinding tiller-cluster-admin <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>    --clusterrole<span style=color:#666>=</span>cluster-admin <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>    --serviceaccount<span style=color:#666>=</span>kube-system:default
</code></pre></div>
<h2 id=在-kubernetes-集群中安装-service-catalog>在 Kubernetes 集群中安装 Service Catalog</h2>
<p>使用以下命令从 Helm 存储库的根目录安装 Service Catalog：</p>
<ul class="nav nav-tabs" id=helm-versions role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#helm-versions-0 role=tab aria-controls=helm-versions-0 aria-selected=true>Helm version 3</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#helm-versions-1 role=tab aria-controls=helm-versions-1>Helm version 2</a></li></ul>
<div class=tab-content id=helm-versions><div id=helm-versions-0 class="tab-pane show active" role=tabpanel aria-labelledby=helm-versions-0>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>helm install catalog svc-cat/catalog --namespace catalog
</code></pre></div></div>
<div id=helm-versions-1 class=tab-pane role=tabpanel aria-labelledby=helm-versions-1>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>helm install svc-cat/catalog --name catalog --namespace catalog
</code></pre></div></div></div>
<h2 id=what-s-next>What's next</h2>
<ul>
<li>查看<a href=https://github.com/openservicebrokerapi/servicebroker/blob/mastergettingStarted.md#sample-service-brokers>示例服务代理</a>。</li>
<li>探索 <a href=https://github.com/kubernetes-incubator/service-catalog>kubernetes-incubator/service-catalog</a> 项目。</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-d85a30635b5c3578487b9f6f214c07ea>16.2 - 使用 SC 安装服务目录</h1>
<p><p>服务目录（Service Catalog）是 服务目录是一种扩展 API，它能让 Kubernetes 集群中运行的应用易于使用外部托管的的软件服务，例如云供应商提供的数据仓库服务。</p></p>
<p>服务目录可以检索、供应、和绑定由 <a class=glossary-tooltip title=由第三方提供并维护的一组托管服务的访问端点。 data-toggle=tooltip data-placement=top href="/zh/docs/reference/glossary/?all=true#term-service-broker" target=_blank aria-label="服务代理人（Service Brokers）">服务代理人（Service Brokers）</a>
提供的外部<a class=glossary-tooltip title=由第三方供应商负责维护的一种软件产品。 data-toggle=tooltip data-placement=top href="/zh/docs/reference/glossary/?all=true#term-managed-service" target=_blank aria-label="托管服务（Managed Services）">托管服务（Managed Services）</a>，
而无需知道那些服务具体是怎样创建和托管的。</p>
<p>使用 GCP <a href=https://github.com/GoogleCloudPlatform/k8s-service-catalog#installation>服务目录安装程序</a>
工具可以轻松地在 Kubernetes 集群上安装或卸载服务目录，并将其链接到 Google Cloud 项目。</p>
<p>服务目录不仅可以与 Google Cloud 一起使用，还可以与任何类型的托管服务一起使用。</p>
<h2 id=before-you-begin>Before you begin</h2>
<ul>
<li>
<p>了解<a href=/zh/docs/concepts/extend-kubernetes/service-catalog/>服务目录</a>
的主要概念。</p>
</li>
<li>
<p>安装 <a href=https://golang.org/dl/>Go 1.6+</a> 以及设置 <code>GOPATH</code>。</p>
</li>
<li>
<p>安装生成 SSL 工件所需的 <a href=https://github.com/cloudflare/cfssl>cfssl</a> 工具。</p>
</li>
<li>
<p>服务目录需要 Kubernetes 1.7+ 版本。</p>
</li>
<li>
<p><a href=/zh/docs/tasks/tools/>安装和设置 kubectl</a>，
以便将其配置为连接到 Kubernetes v1.7+ 集群。</p>
</li>
<li>
<p>要安装服务目录，kubectl 用户必须绑定到 <em>cluster-admin</em> 角色。
为了确保这是正确的，请运行以下命令：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create clusterrolebinding cluster-admin-binding --clusterrole<span style=color:#666>=</span>cluster-admin --user<span style=color:#666>=</span>&lt;user-name&gt;
</code></pre></div></li>
</ul>
<h2 id=在本地环境中安装-sc>在本地环境中安装 <code>sc</code></h2>
<p>安装程序在你的本地计算机上以 CLI 工具的形式运行，名为 <code>sc</code>。</p>
<p>使用 <code>go get</code> 安装：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>go get github.com/GoogleCloudPlatform/k8s-service-catalog/installer/cmd/sc
</code></pre></div>
<p>现在，<code>sc</code> 应该已经被安装在 <code>GOPATH/bin</code> 目录中了。</p>
<h2 id=在-kubernetes-集群中安装服务目录>在 Kubernetes 集群中安装服务目录</h2>
<p>首先，检查是否已经安装了所有依赖项。运行：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>sc check
</code></pre></div>
<p>如检查通过，应输出：</p>
<pre><code>Dependency check passed. You are good to go.
</code></pre>
<p>接下来，运行安装命令并指定要用于备份的 <code>storageclass</code>：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>sc install --etcd-backup-storageclass <span style=color:#b44>&#34;standard&#34;</span>
</code></pre></div>
<h2 id=卸载服务目录>卸载服务目录</h2>
<p>如果您想使用 <code>sc</code> 工具从 Kubernetes 集群卸载服务目录，请运行：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>sc uninstall
</code></pre></div><h2 id=what-s-next>What's next</h2>
<ul>
<li>查看<a href=https://github.com/openservicebrokerapi/servicebroker/blob/master/gettingStarted.md#sample-service-brokers>服务代理示例</a>。</li>
<li>探索 <a href=https://github.com/kubernetes-sigs/service-catalog>kubernetes-sigs/service-catalog</a> 项目。</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-a701e71f3b32dae474c63ae4c596c856>17 - 网络</h1>
<div class=lead>了解如何为你的集群配置网络。</div>
</div>
<div class=td-content>
<h1 id=pg-2edb5b02ea1e646c333c9fe4d5f02ff1>17.1 - 使用 HostAliases 向 Pod /etc/hosts 文件添加条目</h1>
<p>当 DNS 配置以及其它选项不合理的时候，通过向 Pod 的 /etc/hosts 文件中添加条目，
可以在 Pod 级别覆盖对主机名的解析。你可以通过 PodSpec 的 HostAliases
字段来添加这些自定义条目。</p>
<p>建议通过使用 HostAliases 来进行修改，因为该文件由 Kubelet 管理，并且
可以在 Pod 创建/重启过程中被重写。</p>
<h2 id=默认-hosts-文件内容>默认 hosts 文件内容</h2>
<p>让我们从一个 Nginx Pod 开始，该 Pod 被分配一个 IP：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl run nginx --image nginx
</code></pre></div><pre><code>pod/nginx created
</code></pre>
<p>检查 Pod IP：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods --output<span style=color:#666>=</span>wide
</code></pre></div><pre><code>NAME     READY     STATUS    RESTARTS   AGE    IP           NODE
nginx    1/1       Running   0          13s    10.200.0.4   worker0
</code></pre>
<p>主机文件的内容如下所示：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#a2f>exec</span> nginx -- cat /etc/hosts
</code></pre></div><pre><code># Kubernetes-managed hosts file.
127.0.0.1	localhost
::1	localhost ip6-localhost ip6-loopback
fe00::0	ip6-localnet
fe00::0	ip6-mcastprefix
fe00::1	ip6-allnodes
fe00::2	ip6-allrouters
10.200.0.4	nginx
</code></pre>
<p>默认情况下，hosts 文件只包含 IPv4 和 IPv6 的样板内容，像 <code>localhost</code> 和主机名称。</p>
<h2 id=通过-hostaliases-增加额外条目>通过 HostAliases 增加额外条目</h2>
<p>除了默认的样板内容，我们可以向 hosts 文件添加额外的条目。
例如，要将 <code>foo.local</code>、<code>bar.local</code> 解析为 <code>127.0.0.1</code>，
将 <code>foo.remote</code>、 <code>bar.remote</code> 解析为 <code>10.1.2.3</code>，我们可以在
<code>.spec.hostAliases</code> 下为 Pod 配置 HostAliases。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/service/networking/hostaliases-pod.yaml download=service/networking/hostaliases-pod.yaml><code>service/networking/hostaliases-pod.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('service-networking-hostaliases-pod-yaml')" title="Copy service/networking/hostaliases-pod.yaml to clipboard">
</img>
</div>
<div class=includecode id=service-networking-hostaliases-pod-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>hostaliases-pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>hostAliases</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>ip</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;127.0.0.1&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>hostnames</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;foo.local&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;bar.local&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>ip</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;10.1.2.3&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>hostnames</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;foo.remote&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;bar.remote&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cat-hosts<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox:1.28<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- cat<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;/etc/hosts&#34;</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>你可以使用以下命令用此配置启动 Pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/service/networking/hostaliases-pod.yaml
</code></pre></div><pre><code>pod/hostaliases-pod created
</code></pre>
<p>检查 Pod 详情，查看其 IPv4 地址和状态：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod --output<span style=color:#666>=</span>wide
</code></pre></div><pre><code>NAME                READY     STATUS      RESTARTS   AGE       IP              NODE
hostaliases-pod     0/1       Completed   0          6s        10.200.0.5      worker0
</code></pre>
<p>hosts 文件的内容看起来类似如下这样：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl logs hostaliases-pod
</code></pre></div><pre><code># Kubernetes-managed hosts file.
127.0.0.1	localhost
::1	localhost ip6-localhost ip6-loopback
fe00::0	ip6-localnet
fe00::0	ip6-mcastprefix
fe00::1	ip6-allnodes
fe00::2	ip6-allrouters
10.200.0.5	hostaliases-pod

# Entries added by HostAliases.
127.0.0.1	foo.local	bar.local
10.1.2.3	foo.remote	bar.remote
</code></pre>
<p>在最下面额外添加了一些条目。</p>
<h2 id=why-does-kubelet-manage-the-hosts-file>为什么 kubelet 管理 hosts 文件？</h2>
<p>kubelet 管理每个Pod 容器的 <code>hosts</code> 文件，以防止容器运行时在容器已经启动后修改文件。
由于历史原因，Kubernetes 总是使用 Docker Engine 作为其容器运行时，而 Docker Engine
将在容器启动后修改 <code>/etc/hosts</code> 文件。</p>
<p>当前的 Kubernetes 可以使用多种容器运行时；即便如此，kubelet 管理在每个容器中创建 hosts文件，
以便你使用任何容器运行时运行容器时，结果都符合预期。</p>
<div class="alert alert-warning caution callout" role=alert>
<strong>Caution:</strong>
<p>请避免手工更改容器内的 hosts 文件内容。</p>
<p>如果你对 hosts 文件做了手工修改，这些修改都会在容器退出时丢失。</p>
</div>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-eebac062766222247063d6513f95c7b2>17.2 - 验证 IPv4/IPv6 双协议栈</h1>
<p>本文分享了如何验证 IPv4/IPv6 双协议栈的 Kubernetes 集群。</p>
<h2 id=before-you-begin>Before you begin</h2>
<ul>
<li>提供程序对双协议栈网络的支持 (云供应商或其他方式必须能够为 Kubernetes 节点
提供可路由的 IPv4/IPv6 网络接口)</li>
<li>一个能够支持<a href=/zh/docs/concepts/services-networking/dual-stack/>双协议栈</a>的
<a href=/zh/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/>网络插件</a>，
（如 Calico，Cilium 或 Kubenet）。</li>
<li><a href=/zh/docs/concepts/services-networking/dual-stack/>启用双协议栈</a> 集群</li>
</ul>
Your Kubernetes server must be version v1.23.
To check the version, enter <code>kubectl version</code>.
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 虽然你可以使用较早的版本进行验证，但该功能是从 v1.23 版本进入 GA 状态并正式支持的。
</div>
<h2 id=验证寻址>验证寻址</h2>
<h3 id=验证节点寻址>验证节点寻址</h3>
<p>每个双协议栈节点应分配一个 IPv4 块和一个 IPv6 块。
通过运行以下命令来验证是否配置了 IPv4/IPv6 Pod 地址范围。
将示例节点名称替换为集群中的有效双协议栈节点。
在此示例中，节点的名称为 <code>k8s-linuxpool1-34450317-0</code>：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get nodes k8s-linuxpool1-34450317-0 -o go-template --template<span style=color:#666>=</span><span style=color:#b44>&#39;{{range .spec.podCIDRs}}{{printf &#34;%s\n&#34; .}}{{end}}&#39;</span>
</code></pre></div><pre><code>10.244.1.0/24
a00:100::/24
</code></pre>
<p>应该分配一个 IPv4 块和一个 IPv6 块。</p>
<p>验证节点是否检测到 IPv4 和 IPv6 接口。用集群中的有效节点替换节点名称。
在此示例中，节点名称为 <code>k8s-linuxpool1-34450317-0</code>：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get nodes k8s-linuxpool1-34450317-0 -o go-template --template<span style=color:#666>=</span><span style=color:#b44>&#39;{{range .status.addresses}}{{printf &#34;%s: %s \n&#34; .type .address}}{{end}}&#39;</span>
</code></pre></div><pre><code>Hostname: k8s-linuxpool1-34450317-0
InternalIP: 10.240.0.5
InternalIP: 2001:1234:5678:9abc::5
</code></pre>
<h3 id=验证-pod-寻址>验证 Pod 寻址</h3>
<p>验证 Pod 已分配了 IPv4 和 IPv6 地址。用集群中的有效 Pod 替换 Pod 名称。
在此示例中，Pod 名称为 <code>pod01</code>：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods pod01 -o go-template --template<span style=color:#666>=</span><span style=color:#b44>&#39;{{range .status.podIPs}}{{printf &#34;%s \n&#34; .ip}}{{end}}&#39;</span>
</code></pre></div><pre><code>10.244.1.4
a00:100::4
</code></pre>
<p>你也可以通过 <code>status.podIPs</code> 使用 Downward API 验证 Pod IP。
以下代码段演示了如何通过容器内称为 <code>MY_POD_IPS</code> 的环境变量公开 Pod 的 IP 地址。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>MY_POD_IPS<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>fieldRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>fieldPath</span>:<span style=color:#bbb> </span>status.podIPs<span style=color:#bbb>
</span></code></pre></div>
<p>使用以下命令打印出容器内部 <code>MY_POD_IPS</code> 环境变量的值。
该值是一个逗号分隔的列表，与 Pod 的 IPv4 和 IPv6 地址相对应。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#a2f>exec</span> -it pod01 -- <span style=color:#a2f>set</span> | grep MY_POD_IPS
</code></pre></div><pre><code>MY_POD_IPS=10.244.1.4,a00:100::4
</code></pre>
<p>Pod 的 IP 地址也将被写入容器内的 <code>/etc/hosts</code> 文件中。
在双栈 Pod 上执行 cat <code>/etc/hosts</code> 命令操作。
从输出结果中，你可以验证 Pod 的 IPv4 和 IPv6 地址。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#a2f>exec</span> -it pod01 -- cat /etc/hosts
</code></pre></div><pre><code># Kubernetes-managed hosts file.
127.0.0.1    localhost
::1    localhost ip6-localhost ip6-loopback
fe00::0    ip6-localnet
fe00::0    ip6-mcastprefix
fe00::1    ip6-allnodes
fe00::2    ip6-allrouters
10.244.1.4    pod01
a00:100::4    pod01
</code></pre>
<h2 id=验证服务>验证服务</h2>
<p>创建以下未显式定义 <code>.spec.ipFamilyPolicy</code> 的 Service。
Kubernetes 将从首个配置的 <code>service-cluster-ip-range</code> 给 Service 分配集群 IP，
并将 <code>.spec.ipFamilyPolicy</code> 设置为 <code>SingleStack</code>。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/service/networking/dual-stack-default-svc.yaml download=service/networking/dual-stack-default-svc.yaml><code>service/networking/dual-stack-default-svc.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('service-networking-dual-stack-default-svc-yaml')" title="Copy service/networking/dual-stack-default-svc.yaml to clipboard">
</img>
</div>
<div class=includecode id=service-networking-dual-stack-default-svc-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>MyApp<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>MyApp<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>使用 <code>kubectl</code> 查看 Service 的 YAML 定义。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get svc my-service -o yaml
</code></pre></div>
<p>该 Service 通过在 kube-controller-manager 的 <code>--service-cluster-ip-range</code>
标志设置的第一个配置范围，将 <code>.spec.ipFamilyPolicy</code> 设置为 <code>SingleStack</code>，
将 <code>.spec.clusterIP</code> 设置为 IPv4 地址。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>clusterIP</span>:<span style=color:#bbb> </span><span style=color:#666>10.0.217.164</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>clusterIPs</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:#666>10.0.217.164</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ipFamilies</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- IPv4<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ipFamilyPolicy</span>:<span style=color:#bbb> </span>SingleStack<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>9376</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>MyApp<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>sessionAffinity</span>:<span style=color:#bbb> </span>None<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>ClusterIP<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>loadBalancer</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span></code></pre></div>
<p>创建以下显示定义 <code>.spec.ipFamilies</code> 数组中的第一个元素为 IPv6 的 Service。
Kubernetes 将 <code>service-cluster-ip-range</code> 配置的 IPv6 地址范围给 Service 分配集群 IP，
并将 <code>.spec.ipFamilyPolicy</code> 设置为 <code>SingleStack</code>。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/service/networking/dual-stack-ipfamilies-ipv6.yaml download=service/networking/dual-stack-ipfamilies-ipv6.yaml><code>service/networking/dual-stack-ipfamilies-ipv6.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('service-networking-dual-stack-ipfamilies-ipv6-yaml')" title="Copy service/networking/dual-stack-ipfamilies-ipv6.yaml to clipboard">
</img>
</div>
<div class=includecode id=service-networking-dual-stack-ipfamilies-ipv6-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>MyApp<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ipFamilies</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- IPv6<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>MyApp<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>使用 <code>kubectl</code> 查看 Service 的 YAML 定义。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get svc my-service -o yaml
</code></pre></div>
<p>该 Service 通过在 kube-controller-manager 的 <code>--service-cluster-ip-range</code>
标志设置的 IPv6 地址范围，将 <code>.spec.ipFamilyPolicy</code> 设置为 <code>SingleStack</code>，
将 <code>.spec.clusterIP</code> 设置为 IPv6 地址。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>MyApp<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>clusterIP</span>:<span style=color:#bbb> </span>fd00::5118<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>clusterIPs</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- fd00::5118<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ipFamilies</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- IPv6<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ipFamilyPolicy</span>:<span style=color:#bbb> </span>SingleStack<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>MyApp<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>sessionAffinity</span>:<span style=color:#bbb> </span>None<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>ClusterIP<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>loadBalancer</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span></code></pre></div>
<p>创建以下显式定义 <code>.spec.ipFamilyPolicy</code> 为 <code>PreferDualStack</code> 的 Service。
Kubernetes 将分配 IPv4 和 IPv6 地址（因为该集群启用了双栈），
并根据 <code>.spec.ipFamilies</code> 数组中第一个元素的地址族，
从 <code>.spec.ClusterIPs</code> 列表中选择 <code>.spec.ClusterIP</code>。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/service/networking/dual-stack-preferred-svc.yaml download=service/networking/dual-stack-preferred-svc.yaml><code>service/networking/dual-stack-preferred-svc.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('service-networking-dual-stack-preferred-svc-yaml')" title="Copy service/networking/dual-stack-preferred-svc.yaml to clipboard">
</img>
</div>
<div class=includecode id=service-networking-dual-stack-preferred-svc-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>MyApp<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ipFamilyPolicy</span>:<span style=color:#bbb> </span>PreferDualStack<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>MyApp<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong>
<p><code>kubectl get svc</code> 命令将仅在 <code>CLUSTER-IP</code> 字段中显示主 IP。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get svc -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>MyApp

NAME         TYPE        CLUSTER-IP       EXTERNAL-IP   PORT<span style=color:#666>(</span>S<span style=color:#666>)</span>   AGE
my-service   ClusterIP   fe80:20d::d06b   &lt;none&gt;        80/TCP    9s
</code></pre></div>
</div>
<p>使用 <code>kubectl describe</code> 验证服务是否从 IPv4 和 IPv6 地址块中获取了集群 IP。
然后你就可以通过 IP 和端口，验证对服务的访问。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe svc -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>MyApp
</code></pre></div><pre><code>Name:              my-service
Namespace:         default
Labels:            app=MyApp
Annotations:       &lt;none&gt;
Selector:          app=MyApp
Type:              ClusterIP
IP Family Policy:  PreferDualStack
IP Families:       IPv4,IPv6
IP:                10.0.216.242
IPs:               10.0.216.242,fd00::af55
Port:              &lt;unset&gt;  80/TCP
TargetPort:        9376/TCP
Endpoints:         &lt;none&gt;
Session Affinity:  None
Events:            &lt;none&gt;
</code></pre>
<h3 id=创建双协议栈负载均衡服务>创建双协议栈负载均衡服务</h3>
<p>如果云提供商支持配置启用 IPv6 的外部负载均衡器，则创建如下 Service 时将
<code>.spec.ipFamilyPolicy</code> 设置为 <code>PreferDualStack</code>, 并将 <code>spec.ipFamilies</code> 字段
的第一个元素设置为 <code>IPv6</code>，将 <code>type</code> 字段设置为 <code>LoadBalancer</code>：</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/service/networking/dual-stack-prefer-ipv6-lb-svc.yaml download=service/networking/dual-stack-prefer-ipv6-lb-svc.yaml><code>service/networking/dual-stack-prefer-ipv6-lb-svc.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('service-networking-dual-stack-prefer-ipv6-lb-svc-yaml')" title="Copy service/networking/dual-stack-prefer-ipv6-lb-svc.yaml to clipboard">
</img>
</div>
<div class=includecode id=service-networking-dual-stack-prefer-ipv6-lb-svc-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>MyApp<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ipFamilyPolicy</span>:<span style=color:#bbb> </span>PreferDualStack<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ipFamilies</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- IPv6<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>LoadBalancer<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>MyApp<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>检查服务：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get svc -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>MyApp
</code></pre></div>
<p>验证服务是否从 IPv6 地址块中接收到 <code>CLUSTER-IP</code> 地址以及 <code>EXTERNAL-IP</code>。
然后，你可以通过 IP 和端口验证对服务的访问。</p>
<pre><code>NAME         TYPE           CLUSTER-IP   EXTERNAL-IP        PORT(S)        AGE
my-service   LoadBalancer   fd00::7ebc   2603:1030:805::5   80:30790/TCP   35s
</code></pre>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-6ca4f22ef4d1713577ada4815f0a3b5a>18 - 使用 crictl 对 Kubernetes 节点进行调试</h1>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.11 [stable]</code>
</div>
<p><code>crictl</code> 是 CRI 兼容的容器运行时命令行接口。
你可以使用它来检查和调试 Kubernetes 节点上的容器运行时和应用程序。
<code>crictl</code> 和它的源代码在
<a href=https://github.com/kubernetes-sigs/cri-tools>cri-tools</a> 代码库。</p>
<h2 id=before-you-begin>Before you begin</h2>
<p><code>crictl</code> 需要带有 CRI 运行时的 Linux 操作系统。</p>
<h2 id=安装-crictl>安装 crictl</h2>
<p>你可以从 cri-tools <a href=https://github.com/kubernetes-sigs/cri-tools/releases>发布页面</a>
下载一个压缩的 <code>crictl</code> 归档文件，用于几种不同的架构。
下载与你的 kubernetes 版本相对应的版本。
提取它并将其移动到系统路径上的某个位置，例如<code>/usr/local/bin/</code>。</p>
<h2 id=一般用法>一般用法</h2>
<p><code>crictl</code> 命令有几个子命令和运行时参数。
有关详细信息，请使用 <code>crictl help</code> 或 <code>crictl &lt;subcommand> help</code> 获取帮助信息。</p>
<p>你可以用以下方法之一来为 <code>crictl</code> 设置端点：</p>
<ul>
<li>设置参数 <code>--runtime-endpoint</code> 和 <code>--image-endpoint</code>。</li>
<li>设置环境变量 <code>CONTAINER_RUNTIME_ENDPOINT</code> 和 <code>IMAGE_SERVICE_ENDPOINT</code>。</li>
<li>在配置文件 <code>--config=/etc/crictl.yaml</code> 中设置端点。
要设置不同的文件，可以在运行 <code>crictl</code> 时使用 <code>--config=PATH_TO_FILE</code> 标志。</li>
</ul>
<p>你还可以在连接到服务器并启用或禁用调试时指定超时值，方法是在配置文件中指定
<code>timeout</code> 或 <code>debug</code> 值，或者使用 <code>--timeout</code> 和 <code>--debug</code> 命令行参数。</p>
<p>要查看或编辑当前配置，请查看或编辑 <code>/etc/crictl.yaml</code> 的内容。
例如，使用 <code>containerd</code> 容器运行时的配置会类似于这样：</p>
<pre><code>runtime-endpoint: unix:///var/run/containerd/containerd.sock
image-endpoint: unix:///var/run/containerd/containerd.sock
timeout: 10
debug: true
</code></pre>
<p>要进一步了解 <code>crictl</code>，参阅
<a href=https://github.com/kubernetes-sigs/cri-tools/blob/master/docs/crictl.md><code>crictl</code> 文档</a>。</p>
<h2 id=crictl-命令示例>crictl 命令示例</h2>
<div class="alert alert-danger warning callout" role=alert>
<strong>Warning:</strong>
<p>如果使用 <code>crictl</code> 在正在运行的 Kubernetes 集群上创建 Pod 沙盒或容器，
kubelet 最终将删除它们。
<code>crictl</code> 不是一个通用的工作流工具，而是一个对调试有用的工具。
</div>
<h3 id=打印-pod-清单>打印 Pod 清单</h3>
<p>打印所有 Pod 的清单：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>crictl pods
</code></pre></div>
<p>输出类似于：</p>
<pre><code>POD ID              CREATED              STATE               NAME                         NAMESPACE           ATTEMPT
926f1b5a1d33a       About a minute ago   Ready               sh-84d7dcf559-4r2gq          default             0
4dccb216c4adb       About a minute ago   Ready               nginx-65899c769f-wv2gp       default             0
a86316e96fa89       17 hours ago         Ready               kube-proxy-gblk4             kube-system         0
919630b8f81f1       17 hours ago         Ready               nvidia-device-plugin-zgbbv   kube-system         0
</code></pre>
<p>根据名称打印 Pod 清单：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>crictl pods --name nginx-65899c769f-wv2gp
</code></pre></div>
<p>输出类似于这样：</p>
<pre><code>POD ID              CREATED             STATE               NAME                     NAMESPACE           ATTEMPT
4dccb216c4adb       2 minutes ago       Ready               nginx-65899c769f-wv2gp   default             0
</code></pre>
<p>根据标签打印 Pod 清单：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>crictl pods --label <span style=color:#b8860b>run</span><span style=color:#666>=</span>nginx
</code></pre></div>
<p>输出类似于这样：</p>
<pre><code class=language-none data-lang=none>POD ID              CREATED             STATE               NAME                     NAMESPACE           ATTEMPT
4dccb216c4adb       2 minutes ago       Ready               nginx-65899c769f-wv2gp   default             0
</code></pre>
<h3 id=打印镜像清单>打印镜像清单</h3>
<p>打印所有镜像清单：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>crictl images
</code></pre></div>
<p>输出类似于这样：</p>
<pre><code class=language-none data-lang=none>IMAGE                                     TAG                 IMAGE ID            SIZE
busybox                                   latest              8c811b4aec35f       1.15MB
k8s-gcrio.azureedge.net/hyperkube-amd64   v1.10.3             e179bbfe5d238       665MB
k8s-gcrio.azureedge.net/pause-amd64       3.1                 da86e6ba6ca19       742kB
nginx                                     latest              cd5239a0906a6       109MB
</code></pre>
<p>根据仓库打印镜像清单：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>crictl images nginx
</code></pre></div>
<p>输出类似于这样：</p>
<pre><code class=language-none data-lang=none>IMAGE               TAG                 IMAGE ID            SIZE
nginx               latest              cd5239a0906a6       109MB
</code></pre>
<p>只打印镜像 ID：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>crictl images -q
</code></pre></div>
<p>输出类似于这样：</p>
<pre><code class=language-none data-lang=none>sha256:8c811b4aec35f259572d0f79207bc0678df4c736eeec50bc9fec37ed936a472a
sha256:e179bbfe5d238de6069f3b03fccbecc3fb4f2019af741bfff1233c4d7b2970c5
sha256:da86e6ba6ca197bf6bc5e9d900febd906b133eaa4750e6bed647b0fbe50ed43e
sha256:cd5239a0906a6ccf0562354852fae04bc5b52d72a2aff9a871ddb6bd57553569
</code></pre>
<h3 id=打印容器清单>打印容器清单</h3>
<p>打印所有容器清单：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>crictl ps -a
</code></pre></div>
<p>输出类似于这样：</p>
<pre><code class=language-none data-lang=none>CONTAINER ID        IMAGE                                                                                                             CREATED             STATE               NAME                       ATTEMPT
1f73f2d81bf98       busybox@sha256:141c253bc4c3fd0a201d32dc1f493bcf3fff003b6df416dea4f41046e0f37d47                                   7 minutes ago       Running             sh                         1
9c5951df22c78       busybox@sha256:141c253bc4c3fd0a201d32dc1f493bcf3fff003b6df416dea4f41046e0f37d47                                   8 minutes ago       Exited              sh                         0
87d3992f84f74       nginx@sha256:d0a8828cccb73397acb0073bf34f4d7d8aa315263f1e7806bf8c55d8ac139d5f                                     8 minutes ago       Running             nginx                      0
1941fb4da154f       k8s-gcrio.azureedge.net/hyperkube-amd64@sha256:00d814b1f7763f4ab5be80c58e98140dfc69df107f253d7fdd714b30a714260a   18 hours ago        Running             kube-proxy                 0
</code></pre>
<p>打印正在运行的容器清单：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>crictl ps
</code></pre></div>
<p>输出类似于这样：</p>
<pre><code class=language-none data-lang=none>CONTAINER ID        IMAGE                                                                                                             CREATED             STATE               NAME                       ATTEMPT
1f73f2d81bf98       busybox@sha256:141c253bc4c3fd0a201d32dc1f493bcf3fff003b6df416dea4f41046e0f37d47                                   6 minutes ago       Running             sh                         1
87d3992f84f74       nginx@sha256:d0a8828cccb73397acb0073bf34f4d7d8aa315263f1e7806bf8c55d8ac139d5f                                     7 minutes ago       Running             nginx                      0
1941fb4da154f       k8s-gcrio.azureedge.net/hyperkube-amd64@sha256:00d814b1f7763f4ab5be80c58e98140dfc69df107f253d7fdd714b30a714260a   17 hours ago        Running             kube-proxy                 0
</code></pre>
<h3 id=在正在运行的容器上执行命令>在正在运行的容器上执行命令</h3>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>crictl <span style=color:#a2f>exec</span> -i -t 1f73f2d81bf98 ls
</code></pre></div>
<p>输出类似于这样：</p>
<pre><code class=language-none data-lang=none>bin   dev   etc   home  proc  root  sys   tmp   usr   var
</code></pre>
<h3 id=获取容器日志>获取容器日志</h3>
<p>获取容器的所有日志：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>crictl logs 87d3992f84f74
</code></pre></div>
<p>输出类似于这样：</p>
<pre><code class=language-none data-lang=none>10.240.0.96 - - [06/Jun/2018:02:45:49 +0000] &quot;GET / HTTP/1.1&quot; 200 612 &quot;-&quot; &quot;curl/7.47.0&quot; &quot;-&quot;
10.240.0.96 - - [06/Jun/2018:02:45:50 +0000] &quot;GET / HTTP/1.1&quot; 200 612 &quot;-&quot; &quot;curl/7.47.0&quot; &quot;-&quot;
10.240.0.96 - - [06/Jun/2018:02:45:51 +0000] &quot;GET / HTTP/1.1&quot; 200 612 &quot;-&quot; &quot;curl/7.47.0&quot; &quot;-&quot;
</code></pre>
<p>获取最近的 <code>N</code> 行日志：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>crictl logs --tail<span style=color:#666>=</span><span style=color:#666>1</span> 87d3992f84f74
</code></pre></div>
<p>输出类似于这样：</p>
<pre><code class=language-none data-lang=none>10.240.0.96 - - [06/Jun/2018:02:45:51 +0000] &quot;GET / HTTP/1.1&quot; 200 612 &quot;-&quot; &quot;curl/7.47.0&quot; &quot;-&quot;
</code></pre>
<h3 id=运行-pod-沙盒>运行 Pod 沙盒</h3>
<p>用 <code>crictl</code> 运行 Pod 沙盒对容器运行时排错很有帮助。
在运行的 Kubernetes 集群中，沙盒会随机地被 kubelet 停止和删除。</p>
<ol>
<li>
<p>编写下面的 JSON 文件：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
    <span style=color:green;font-weight:700>&#34;metadata&#34;</span>: {
        <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;nginx-sandbox&#34;</span>,
        <span style=color:green;font-weight:700>&#34;namespace&#34;</span>: <span style=color:#b44>&#34;default&#34;</span>,
        <span style=color:green;font-weight:700>&#34;attempt&#34;</span>: <span style=color:#666>1</span>,
        <span style=color:green;font-weight:700>&#34;uid&#34;</span>: <span style=color:#b44>&#34;hdishd83djaidwnduwk28bcsb&#34;</span>
    },
    <span style=color:green;font-weight:700>&#34;logDirectory&#34;</span>: <span style=color:#b44>&#34;/tmp&#34;</span>,
    <span style=color:green;font-weight:700>&#34;linux&#34;</span>: {
    }
}
</code></pre></div></li>
</ol>
<ol start=2>
<li>
<p>使用 <code>crictl runp</code> 命令应用 JSON 文件并运行沙盒。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>crictl runp pod-config.json
</code></pre></div>
<p>返回了沙盒的 ID。</p>
</li>
</ol>
<h3 id=创建容器>创建容器</h3>
<p>用 <code>crictl</code> 创建容器对容器运行时排错很有帮助。
在运行的 Kubernetes 集群中，沙盒会随机的被 kubelet 停止和删除。</p>
<ol>
<li>
<p>拉取 busybox 镜像</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>crictl pull busybox
</code></pre></div><pre><code class=language-none data-lang=none>Image is up to date for busybox@sha256:141c253bc4c3fd0a201d32dc1f493bcf3fff003b6df416dea4f41046e0f37d47
</code></pre></li>
</ol>
<ol start=2>
<li>
<p>创建 Pod 和容器的配置：</p>
<p><strong>Pod 配置</strong>：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
    <span style=color:green;font-weight:700>&#34;metadata&#34;</span>: {
        <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;nginx-sandbox&#34;</span>,
        <span style=color:green;font-weight:700>&#34;namespace&#34;</span>: <span style=color:#b44>&#34;default&#34;</span>,
        <span style=color:green;font-weight:700>&#34;attempt&#34;</span>: <span style=color:#666>1</span>,
        <span style=color:green;font-weight:700>&#34;uid&#34;</span>: <span style=color:#b44>&#34;hdishd83djaidwnduwk28bcsb&#34;</span>
    },
    <span style=color:green;font-weight:700>&#34;log_directory&#34;</span>: <span style=color:#b44>&#34;/tmp&#34;</span>,
    <span style=color:green;font-weight:700>&#34;linux&#34;</span>: {
    }
}
</code></pre></div>
<p><strong>容器配置</strong>：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
  <span style=color:green;font-weight:700>&#34;metadata&#34;</span>: {
      <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;busybox&#34;</span>
  },
  <span style=color:green;font-weight:700>&#34;image&#34;</span>:{
      <span style=color:green;font-weight:700>&#34;image&#34;</span>: <span style=color:#b44>&#34;busybox&#34;</span>
  },
  <span style=color:green;font-weight:700>&#34;command&#34;</span>: [
      <span style=color:#b44>&#34;top&#34;</span>
  ],
  <span style=color:green;font-weight:700>&#34;log_path&#34;</span>:<span style=color:#b44>&#34;busybox.log&#34;</span>,
  <span style=color:green;font-weight:700>&#34;linux&#34;</span>: {
  }
}
</code></pre></div></li>
</ol>
<ol start=3>
<li>
<p>创建容器，传递先前创建的 Pod 的 ID、容器配置文件和 Pod 配置文件。返回容器的 ID。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>crictl create f84dd361f8dc51518ed291fbadd6db537b0496536c1d2d6c05ff943ce8c9a54f container-config.json pod-config.json
</code></pre></div></li>
</ol>
<ol start=4>
<li>
<p>查询所有容器并确认新创建的容器状态为 <code>Created</code>。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>crictl ps -a
</code></pre></div>
<p>输出类似于这样：</p>
<pre><code class=language-none data-lang=none>CONTAINER ID        IMAGE               CREATED             STATE               NAME                ATTEMPT
3e025dd50a72d       busybox             32 seconds ago      Created             busybox             0
</code></pre></li>
</ol>
<h3 id=启动容器>启动容器</h3>
<p>要启动容器，要将容器 ID 传给 <code>crictl start</code>：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>crictl start 3e025dd50a72d956c4f14881fbb5b1080c9275674e95fb67f965f6478a957d60
</code></pre></div>
<p>输出类似于这样：</p>
<pre><code>3e025dd50a72d956c4f14881fbb5b1080c9275674e95fb67f965f6478a957d60
</code></pre>
<p>确认容器的状态为 <code>Running</code>。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>crictl ps
</code></pre></div>
<p>输出类似于这样：</p>
<pre><code>CONTAINER ID   IMAGE    CREATED              STATE    NAME     ATTEMPT
3e025dd50a72d  busybox  About a minute ago   Running  busybox  0
</code></pre><h2 id=what-s-next>What's next</h2>
<ul>
<li><a href=https://github.com/kubernetes-sigs/cri-tools>进一步了解 <code>crictl</code></a>.</li>
<li><a href=/zh/docs/reference/tools/map-crictl-dockercli/>将 <code>docker</code> CLI 命令映射到 <code>crictl</code></a>.</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-60dca0ec8d41f0045e7d73e1d6bd7bce>19 - 使用 telepresence 在本地开发和调试服务</h1>
<div class="alert alert-secondary callout third-party-content" role=alert><strong>Note:</strong>
This section links to third party projects that provide functionality required by Kubernetes. The Kubernetes project authors aren't responsible for these projects, which are listed alphabetically. To add a project to this list, read the <a href=/docs/contribute/style/content-guide/#third-party-content>content guide</a> before submitting a change. <a href=#third-party-content-disclaimer>More information.</a></div>
<p>Kubernetes 应用程序通常由多个独立的服务组成，每个服务都在自己的容器中运行。
在远端的 Kubernetes 集群上开发和调试这些服务可能很麻烦，需要
<a href=/zh/docs/tasks/debug-application-cluster/get-shell-running-container/>在运行的容器上打开 Shell</a>，
以运行调试工具。</p>
<p><code>telepresence</code> 是一个工具，用于简化本地开发和调试服务的过程，同时可以将服务代理到远程 Kubernetes 集群。
<code>telepresence</code> 允许你使用使用自定义工具（例如：调试器 和 IDE）调式服务，
并提供对 Configmap、Secret 和远程集群上运行的服务的完全访问。</p>
<p>本文档描述如何在本地使用 <code>telepresence</code> 开发和调试远程集群上运行的服务。</p>
<h2 id=before-you-begin>Before you begin</h2>
<ul>
<li>Kubernetes 集群安装完毕</li>
<li>配置好 <code>kubectl</code> 与集群交互</li>
<li><a href=https://www.telepresence.io/docs/latest/install/>Telepresence</a> 安装完毕</li>
</ul>
<h2 id=从本机连接到远程-kubernetes-集群>从本机连接到远程 Kubernetes 集群</h2>
<p>安装 <code>telepresence</code> 后，运行 <code>telepresence connect</code> 来启动它的守护进程并将本地工作站连接到远程 Kubernetes 集群。</p>
<pre><code>$ telepresence connect
 
Launching Telepresence Daemon
...
Connected to context default (https://&lt;cluster public IP&gt;)
</code></pre>
<p>你可以通过 curl 使用 Kubernetes 语法访问服务，例如：<code>curl -ik https://kubernetes.default</code></p>
<h2 id=开发和调试现有的服务>开发和调试现有的服务</h2>
<p>在 Kubernetes 上开发应用程序时，通常对单个服务进行编程或调试。
服务可能需要访问其他服务以进行测试和调试。
一种选择是使用连续部署流水线，但即使最快的部署流水线也会在程序或调试周期中引入延迟。</p>
<p>使用 <code>telepresence intercept $SERVICE_NAME --port $LOCAL_PORT:REMOTE_PORT</code> 命令创建一个 "拦截器" 用于重新路由远程服务流量。</p>
<p>环境变量：</p>
<ul>
<li><code>$SERVICE_NAME</code> 是本地服务名称</li>
<li><code>$LOCAL_PORT</code> 是服务在本地工作站上运行的端口</li>
<li><code>$REMOTE_PORT</code> 是服务在集群中侦听的端口</li>
</ul>
<p>运行此命令会告诉 Telepresence 将远程流量发送到的本地服务，而不是远程 Kubernetes 集群中的服务中。
在本地编辑保存服务源代码，并在访问远程应用时查看相应变更会立即生效。
还可以使用调试器或任何其他本地开发工具运行本地服务。</p>
<h2 id=telepresence-是如何工作的>Telepresence 是如何工作的？</h2>
<p>Telepresence 会在远程集群中运行的现有应用程序容器旁边安装流量代理 sidecar。
当它捕获进入 Pod 的所有流量请求时，不是将其转发到远程集群中的应用程序，
而是路由所有流量（当创建<a href=https://www.getambassador.io/docs/telepresence/latest/concepts/intercepts/#global-intercept>全局拦截器</a>时）
或流量的一个子集（当创建<a href=https://www.getambassador.io/docs/telepresence/latest/concepts/intercepts/#personal-intercept>自定义拦截器</a>时）
到本地开发环境。</p>
<h2 id=what-s-next>What's next</h2>
<p>如果你对实践教程感兴趣，请查看<a href=https://cloud.google.com/community/tutorials/developing-services-with-k8s>本教程</a>，其中介绍了在 Google Kubernetes Engine 上本地开发 Guestbook 应用程序。</p>
<p>如需进一步了解，请访问 <a href=https://www.telepresence.io>Telepresence 官方网站</a>。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-38387ad04dd284933cb502944ea3515b>20 - 审计</h1>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.23 [beta]</code>
</div>
<p>Kubernetes <em>审计（Auditing）</em> 功能提供了与安全相关的、按时间顺序排列的记录集，
记录每个用户、使用 Kubernetes API 的应用以及控制面自身引发的活动。</p>
<p>审计功能使得集群管理员能够回答以下问题：</p>
<ul>
<li>发生了什么？</li>
<li>什么时候发生的？</li>
<li>谁触发的？</li>
<li>活动发生在哪个（些）对象上？</li>
<li>在哪观察到的？</li>
<li>它从哪触发的？</li>
<li>活动的后续处理行为是什么？</li>
</ul>
<p>审计记录最初产生于
<a href=/zh/docs/reference/command-line-tools-reference/kube-apiserver/>kube-apiserver</a>
内部。每个请求在不同执行阶段都会生成审计事件；这些审计事件会根据特定策略
被预处理并写入后端。策略确定要记录的内容和用来存储记录的后端。
当前的后端支持日志文件和 webhook。</p>
<p>每个请求都可被记录其相关的 <em>阶段（stage）</em>。已定义的阶段有：</p>
<ul>
<li><code>RequestReceived</code> - 此阶段对应审计处理器接收到请求后，并且在委托给
其余处理器之前生成的事件。</li>
<li><code>ResponseStarted</code> - 在响应消息的头部发送后，响应消息体发送前生成的事件。
只有长时间运行的请求（例如 watch）才会生成这个阶段。</li>
<li><code>ResponseComplete</code> - 当响应消息体完成并且没有更多数据需要传输的时候。</li>
<li><code>Panic</code> - 当 panic 发生时生成。</li>
</ul>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> <a href=/zh/docs/reference/config-api/apiserver-audit.v1/#audit-k8s-io-v1-Event>审计事件配置</a>
的配置与 <a href=/zh/docs/reference/generated/kubernetes-api/v1.23/#event-v1-core>Event</a>
API 对象不同。
</div>
<p>审计日志记录功能会增加 API server 的内存消耗，因为需要为每个请求存储审计所需的某些上下文。
此外，内存消耗取决于审计日志记录的配置。</p>
<h2 id=audit-policy>审计策略 </h2>
<p>审计政策定义了关于应记录哪些事件以及应包含哪些数据的规则。
审计策略对象结构定义在
<a href=/zh/docs/reference/config-api/apiserver-audit.v1/#audit-k8s-io-v1-Policy><code>audit.k8s.io</code> API 组</a>
处理事件时，将按顺序与规则列表进行比较。第一个匹配规则设置事件的
<em>审计级别（Audit Level）</em>。已定义的审计级别有：</p>
<ul>
<li><code>None</code> - 符合这条规则的日志将不会记录。</li>
<li><code>Metadata</code> - 记录请求的元数据（请求的用户、时间戳、资源、动词等等），
但是不记录请求或者响应的消息体。</li>
<li><code>Request</code> - 记录事件的元数据和请求的消息体，但是不记录响应的消息体。
这不适用于非资源类型的请求。</li>
<li><code>RequestResponse</code> - 记录事件的元数据，请求和响应的消息体。这不适用于非资源类型的请求。</li>
</ul>
<p>你可以使用 <code>--audit-policy-file</code> 标志将包含策略的文件传递给 <code>kube-apiserver</code>。
如果不设置该标志，则不记录事件。
注意 <code>rules</code> 字段 <strong>必须</strong> 在审计策略文件中提供。没有（0）规则的策略将被视为非法配置。</p>
<p>以下是一个审计策略文件的示例：</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/audit/audit-policy.yaml download=audit/audit-policy.yaml><code>audit/audit-policy.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('audit-audit-policy-yaml')" title="Copy audit/audit-policy.yaml to clipboard">
</img>
</div>
<div class=includecode id=audit-audit-policy-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>audit.k8s.io/v1<span style=color:#bbb> </span><span style=color:#080;font-style:italic># This is required.</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Policy<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># Don&#39;t generate audit events for all requests in RequestReceived stage.</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>omitStages</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;RequestReceived&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># Log pod changes at RequestResponse level</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>level</span>:<span style=color:#bbb> </span>RequestResponse<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>group</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># Resource &#34;pods&#34; doesn&#39;t match requests to any subresource of pods,</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># which is consistent with the RBAC policy.</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;pods&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># Log &#34;pods/log&#34;, &#34;pods/status&#34; at Metadata level</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>level</span>:<span style=color:#bbb> </span>Metadata<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>group</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;pods/log&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;pods/status&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># Don&#39;t log requests to a configmap called &#34;controller-leader&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>level</span>:<span style=color:#bbb> </span>None<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>group</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;configmaps&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>resourceNames</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;controller-leader&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># Don&#39;t log watch requests by the &#34;system:kube-proxy&#34; on endpoints or services</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>level</span>:<span style=color:#bbb> </span>None<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>users</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;system:kube-proxy&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;watch&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>group</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&#34;</span><span style=color:#bbb> </span><span style=color:#080;font-style:italic># core API group</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;endpoints&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;services&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># Don&#39;t log authenticated requests to certain non-resource URL paths.</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>level</span>:<span style=color:#bbb> </span>None<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>userGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;system:authenticated&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>nonResourceURLs</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;/api*&#34;</span><span style=color:#bbb> </span><span style=color:#080;font-style:italic># Wildcard matching.</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;/version&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># Log the request body of configmap changes in kube-system.</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>level</span>:<span style=color:#bbb> </span>Request<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>group</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&#34;</span><span style=color:#bbb> </span><span style=color:#080;font-style:italic># core API group</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;configmaps&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># This rule only applies to resources in the &#34;kube-system&#34; namespace.</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># The empty string &#34;&#34; can be used to select non-namespaced resources.</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>namespaces</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;kube-system&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># Log configmap and secret changes in all other namespaces at the Metadata level.</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>level</span>:<span style=color:#bbb> </span>Metadata<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>group</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&#34;</span><span style=color:#bbb> </span><span style=color:#080;font-style:italic># core API group</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;secrets&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;configmaps&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># Log all other resources in core and extensions at the Request level.</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>level</span>:<span style=color:#bbb> </span>Request<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>group</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&#34;</span><span style=color:#bbb> </span><span style=color:#080;font-style:italic># core API group</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>group</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;extensions&#34;</span><span style=color:#bbb> </span><span style=color:#080;font-style:italic># Version of group should NOT be included.</span><span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># A catch-all rule to log all other requests at the Metadata level.</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>level</span>:<span style=color:#bbb> </span>Metadata<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># Long-running requests like watches that fall under this rule will not</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># generate an audit event in RequestReceived.</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>omitStages</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:#b44>&#34;RequestReceived&#34;</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>你可以使用最低限度的审计策略文件在 <code>Metadata</code> 级别记录所有请求：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#080;font-style:italic># 在 Metadata 级别为所有请求生成日志</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>audit.k8s.io/v1beta1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Policy<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>level</span>:<span style=color:#bbb> </span>Metadata<span style=color:#bbb>
</span></code></pre></div>
<p>如果你在打磨自己的审计配置文件，你可以使用为 Google Container-Optimized OS
设计的审计配置作为出发点。你可以参考
<a href=https://github.com/kubernetes/kubernetes/blob/master/cluster/gce/gci/configure-helper.sh>configure-helper.sh</a>
脚本，该脚本能够生成审计策略文件。你可以直接在脚本中看到审计策略的绝大部份内容。</p>
<p>你也可以参考 <a href=/zh/docs/reference/config-api/apiserver-audit.v1/#audit-k8s-io-v1-Policy><code>Policy</code> 配置参考</a>
以获取有关已定义字段的详细信息。</p>
<h2 id=audit-backends>审计后端 </h2>
<p>审计后端实现将审计事件导出到外部存储。<code>Kube-apiserver</code> 默认提供两个后端：</p>
<ul>
<li>Log 后端，将事件写入到文件系统</li>
<li>Webhook 后端，将事件发送到外部 HTTP API</li>
</ul>
<p>在这所有情况下，审计事件均遵循 Kubernetes API 在
<a href=/zh/docs/reference/config-api/apiserver-audit.v1/#audit-k8s-io-v1-Event><code>audit.k8s.io</code> API 组</a>
中定义的结构。</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> <p>对于 patch 请求，请求的消息体需要是设定 patch 操作的 JSON 所构成的一个串，
而不是一个完整的 Kubernetes API 对象 JSON 串。
例如，以下的示例是一个合法的 patch 请求消息体，该请求对应
<code>/apis/batch/v1/namespaces/some-namespace/jobs/some-job-name</code>。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>[
  {
    <span style=color:green;font-weight:700>&#34;op&#34;</span>: <span style=color:#b44>&#34;replace&#34;</span>,
    <span style=color:green;font-weight:700>&#34;path&#34;</span>: <span style=color:#b44>&#34;/spec/parallelism&#34;</span>,
    <span style=color:green;font-weight:700>&#34;value&#34;</span>: <span style=color:#666>0</span>
  },
  {
    <span style=color:green;font-weight:700>&#34;op&#34;</span>: <span style=color:#b44>&#34;remove&#34;</span>,
    <span style=color:green;font-weight:700>&#34;path&#34;</span>: <span style=color:#b44>&#34;/spec/template/spec/containers/0/terminationMessagePolicy&#34;</span>
  }
]
</code></pre></div>
</div>
<h3 id=log-后端>Log 后端</h3>
<p>Log 后端将审计事件写入 <a href=https://jsonlines.org/>JSONlines</a> 格式的文件。
你可以使用以下 <code>kube-apiserver</code> 标志配置 Log 审计后端：</p>
<ul>
<li><code>--audit-log-path</code> 指定用来写入审计事件的日志文件路径。不指定此标志会禁用日志后端。<code>-</code> 意味着标准化</li>
<li><code>--audit-log-maxage</code> 定义保留旧审计日志文件的最大天数</li>
<li><code>--audit-log-maxbackup</code> 定义要保留的审计日志文件的最大数量</li>
<li><code>--audit-log-maxsize</code> 定义审计日志文件的最大大小（兆字节）</li>
</ul>
<p>如果你的集群控制面以 Pod 的形式运行 kube-apiserver，记得要通过 <code>hostPath</code>
卷来访问策略文件和日志文件所在的目录，这样审计记录才会持久保存下来。例如：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>  --audit-policy-file<span style=color:#666>=</span>/etc/kubernetes/audit-policy.yaml
  --audit-log-path<span style=color:#666>=</span>/var/log/kubernetes/audit/audit.log
</code></pre></div><p>接下来挂载数据卷：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/etc/kubernetes/audit-policy.yaml<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>audit<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/var/log/kubernetes/audit/<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>audit-log<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>false</span><span style=color:#bbb>
</span></code></pre></div>
<p>最后配置 <code>hostPath</code>：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>audit<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>hostPath</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/etc/kubernetes/audit-policy.yaml<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>File<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>audit-log<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>hostPath</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/var/log/kubernetes/audit/<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>DirectoryOrCreate<span style=color:#bbb>
</span></code></pre></div>
<h3 id=webhook-backend>Webhook 后端 </h3>
<p>Webhook 后端将审计事件发送到远程 Web API，该远程 API 应该暴露与 <code>kube-apiserver</code>
形式相同的 API，包括其身份认证机制。你可以使用如下 kube-apiserver 标志来配置
Webhook 审计后端：</p>
<ul>
<li><code>--audit-webhook-config-file</code> 设置 Webhook 配置文件的路径。Webhook 配置文件实际上是一个
<a href=/zh/docs/concepts/configuration/organize-cluster-access-kubeconfig/>kubeconfig 文件</a>。</li>
<li><code>--audit-webhook-initial-backoff</code> 指定在第一次失败后重发请求等待的时间。随后的请求将以指数退避重试。</li>
</ul>
<p>Webhook 配置文件使用 kubeconfig 格式指定服务的远程地址和用于连接它的凭据。</p>
<h2 id=batching>事件批处理 </h2>
<p>日志和 Webhook 后端都支持批处理。以 Webhook 为例，以下是可用参数列表。要获取日志
后端的同样参数，请在参数名称中将 <code>webhook</code> 替换为 <code>log</code>。
默认情况下，在 <code>webhook</code> 中批处理是被启用的，在 <code>log</code> 中批处理是被禁用的。
同样，默认情况下，在 <code>webhook</code> 中启用带宽限制，在 <code>log</code> 中禁用带宽限制。</p>
<ul>
<li><code>--audit-webhook-mode</code> 定义缓存策略，可选值如下：
<ul>
<li><code>batch</code> - 以批处理缓存事件和异步的过程。这是默认值。</li>
<li><code>blocking</code> - 在 API 服务器处理每个单独事件时，阻塞其响应。</li>
<li><code>blocking-strict</code> - 与 <code>blocking</code> 相同，不过当审计日志在 RequestReceived 阶段
失败时，整个 API 服务请求会失效。</li>
</ul>
</li>
</ul>
<p>以下参数仅用于 <code>batch</code> 模式。</p>
<ul>
<li><code>--audit-webhook-batch-buffer-size</code> 定义 batch 之前要缓存的事件数。
如果传入事件的速率溢出缓存区，则会丢弃事件。</li>
<li><code>--audit-webhook-batch-max-size</code> 定义一个 batch 中的最大事件数。</li>
<li><code>--audit-webhook-batch-max-wait</code> 无条件 batch 队列中的事件前等待的最大事件。</li>
<li><code>--audit-webhook-batch-throttle-qps</code> 每秒生成的最大批次数。</li>
<li><code>--audit-webhook-batch-throttle-burst</code> 在达到允许的 QPS 前，同一时刻允许存在的最大 batch 生成数。</li>
</ul>
<h2 id=parameter-tuning>参数调整 </h2>
<p>需要设置参数以适应 API 服务器上的负载。</p>
<p>例如，如果 kube-apiserver 每秒收到 100 个请求，并且每个请求仅在 <code>ResponseStarted</code>
和 <code>ResponseComplete</code> 阶段进行审计，则应该考虑每秒生成约 200 个审计事件。
假设批处理中最多有 100 个事件，则应将限制级别设置为每秒至少 2 个查询。
假设后端最多需要 5 秒钟来写入事件，你应该设置缓冲区大小以容纳最多 5 秒的事件，
即 10 个 batch，即 1000 个事件。</p>
<p>但是，在大多数情况下，默认参数应该足够了，你不必手动设置它们。
你可以查看 kube-apiserver 公开的以下 Prometheus 指标，并在日志中监控审计子系统的状态。</p>
<ul>
<li><code>apiserver_audit_event_total</code> 包含所有暴露的审计事件数量的指标。</li>
<li><code>apiserver_audit_error_total</code> 在暴露时由于发生错误而被丢弃的事件的数量。</li>
</ul>
<h3 id=truncate>日志条目截断 </h3>
<p>日志后端和 Webhook 后端都支持限制所输出的事件的尺寸。
例如，下面是可以为日志后端配置的标志列表：</p>
<ul>
<li><code>audit-log-truncate-enabled</code>：是否弃用事件和批次的截断处理。</li>
<li><code>audit-log-truncate-max-batch-size</code>：向下层后端发送的各批次的最大尺寸字节数。</li>
<li><code>audit-log-truncate-max-event-size</code>：向下层后端发送的审计事件的最大尺寸字节数。</li>
</ul>
<p>默认情况下，截断操作在 <code>webhook</code> 和 <code>log</code> 后端都是被禁用的，集群管理员需要设置
<code>audit-log-truncate-enabled</code> 或 <code>audit-webhook-truncate-enabled</code> 标志来启用此操作。</p>
<h2 id=what-s-next>What's next</h2>
<ul>
<li>了解 <a href=/zh/docs/reference/access-authn-authz/extensible-admission-controllers/#mutating-webhook-auditing-annotations>Mutating webhook 审计注解</a>。</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-f34d6e348a8e677d6c6eb155cd1a99aa>21 - 用插件扩展 kubectl</h1>
<div class=lead>通过创建和安装 kubectl 插件扩展 kubectl。</div>
<p>本指南演示了如何为 <a href=/zh/docs/reference/kubectl/kubectl/>kubectl</a> 安装和编写扩展。
通过将核心 <code>kubectl</code> 命令看作与 Kubernetes 集群交互的基本构建块，
集群管理员可以将插件视为一种利用这些构建块创建更复杂行为的方法。
插件用新的子命令扩展了 <code>kubectl</code>，允许新的和自定义的特性不包括在 <code>kubectl</code> 的主要发行版中。</p>
<h2 id=before-you-begin>Before you begin</h2>
<p>你需要安装一个可用的 <code>kubectl</code> 可执行文件。</p>
<h2 id=安装-kubectl-插件>安装 kubectl 插件</h2>
<p>插件是一个独立的可执行文件，名称以 <code>kubectl-</code> 开头。
要安装插件，将其可执行文件移动到 <code>PATH</code> 中的任何位置。</p>
<p>你也可以使用 <a href=https://krew.dev/>Krew</a> 来发现和安装开源的 kubectl 插件。
Krew 是一个由 Kubernetes SIG CLI 社区维护的插件管理器。</p>
<div class="alert alert-warning caution callout" role=alert>
<strong>Caution:</strong> Krew <a href=https://krew.sigs.k8s.io/plugins/>插件索引</a> 所维护的 kubectl 插件并未经过安全性审查。
你要了解安装和运行第三方插件的安全风险，因为它们本质上时是一些在你的机器上
运行的程序。
</div>
<h3 id=发现插件>发现插件</h3>
<p><code>kubectl</code> 提供一个命令 <code>kubectl plugin list</code>，用于搜索路径查找有效的插件可执行文件。
执行此命令将遍历路径中的所有文件。任何以 <code>kubectl-</code> 开头的可执行文件都将在这个命令的输出中以它们在路径中出现的顺序显示。
任何以 <code>kubectl-</code> 开头的文件如果<code>不可执行</code>，都将包含一个警告。
对于任何相同的有效插件文件，都将包含一个警告。</p>
<p>你可以使用 <a href=https://krew.dev/>Krew</a> 从社区策划的<a href=https://krew.sigs.k8s.io/plugins/>插件索引</a>
中发现和安装 <code>kubectl</code> 插件。</p>
<h4 id=限制>限制</h4>
<p>目前无法创建覆盖现有 <code>kubectl</code> 命令的插件。
例如，创建一个插件 <code>kubectl-version</code> 将导致该插件永远不会被执行，
因为现有的 <code>kubectl version</code> 命令总是优先于它执行。
由于这个限制，也不可能使用插件将新的子命令添加到现有的 <code>kubectl</code> 命令中。
例如，通过将插件命名为 <code>kubectl-create-foo</code> 来添加子命令 <code>kubectl create foo</code> 将导致该插件被忽略。</p>
<p>对于任何试图这样做的有效插件 <code>kubectl plugin list</code> 的输出中将显示警告。</p>
<h2 id=编写-kubectl-插件>编写 kubectl 插件</h2>
<p>你可以用任何编程语言或脚本编写插件，允许你编写命令行命令。</p>
<p>不需要安装插件或预加载，插件可执行程序从 <code>kubectl</code> 二进制文件接收继承的环境，
插件根据其名称确定它希望实现的命令路径。
例如，名为 <code>kubectl-foo</code> 的插件提供了命令 <code>kubectl foo</code>。
必须将插件的可执行文件安装在 <code>PATH</code> 中的某个位置。</p>
<h3 id=示例插件>示例插件</h3>
<pre><code>#!/bin/bash

# 可选的参数处理
if [[ &quot;$1&quot; == &quot;version&quot; ]]
then
    echo &quot;1.0.0&quot;
    exit 0
fi

# 可选的参数处理
if [[ &quot;$1&quot; == &quot;config&quot; ]]
then
    echo $KUBECONFIG
    exit 0
fi

echo &quot;I am a plugin named kubectl-foo&quot;
</code></pre>
<h3 id=使用插件>使用插件</h3>
<p>要使用某插件，先要使其可执行：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>sudo chmod +x ./kubectl-foo
</code></pre></div>
<p>并将它放在你的 PATH 中的任何地方：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>sudo mv ./kubectl-foo /usr/local/bin
</code></pre></div>
<p>你现在可以调用你的插件作为 <code>kubectl</code> 命令：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl foo
</code></pre></div><pre><code>I am a plugin named kubectl-foo
</code></pre>
<p>所有参数和标记按原样传递给可执行文件：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl foo version
</code></pre></div><pre><code>1.0.0
</code></pre>
<p>所有环境变量也按原样传递给可执行文件：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#a2f>export</span> <span style=color:#b8860b>KUBECONFIG</span><span style=color:#666>=</span>~/.kube/config
kubectl foo config
</code></pre></div><pre><code>/home/&lt;user&gt;/.kube/config
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#b8860b>KUBECONFIG</span><span style=color:#666>=</span>/etc/kube/config kubectl foo config
</code></pre></div><pre><code>/etc/kube/config
</code></pre>
<p>此外，传递给插件的第一个参数总是调用它的位置的绝对路径（在上面的例子中，<code>$0</code> 将等于 <code>/usr/local/bin/kubectl-foo</code>）。</p>
<h3 id=命名插件>命名插件</h3>
<p>如上面的例子所示，插件根据文件名确定要实现的命令路径，插件所针对的命令路径中的每个子命令都由破折号（<code>-</code>）分隔。
例如，当用户调用命令 <code>kubectl foo bar baz</code> 时，希望调用该命令的插件的文件名为 <code>kubectl-foo-bar-baz</code>。</p>
<h4 id=参数和标记处理>参数和标记处理</h4>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> <p>插件机制不会为插件进程创建任何定制的、特定于插件的值或环境变量。</p>
<p>较老的插件机制会提供环境变量（例如 <code>KUBECTL_PLUGINS_CURRENT_NAMESPACE</code>）；这种机制已被废弃。</p>
</div>
<p>kubectl 插件必须解析并检查传递给它们的所有参数。
参阅<a href=#using-the-command-line-runtime-package>使用命令行运行时包</a>了解针对
插件开发人员的 Go 库的细节。</p>
<p>这里是一些用户调用你的插件的时候提供额外标志和参数的场景。
这些场景时基于上述案例中的 <code>kubectl-foo-bar-baz</code> 插件的。</p>
<p>如果你运行 <code>kubectl foo bar baz arg1 --flag=value arg2</code>，kubectl 的插件机制将首先尝试找到
最长可能名称的插件，在本例中是 <code>kubectl-foo-bar-baz-arg1</code>。
当没有找到这个插件时，kubectl 就会将最后一个以破折号分隔的值视为参数（在本例中为 <code>arg1</code>），
并尝试找到下一个最长的名称 <code>kubectl-foo-bar-baz</code>。
在找到具有此名称的插件后，它将调用该插件，并在其名称之后将所有参数和标志传递给插件进程。</p>
<p>示例：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#080;font-style:italic># 创建一个插件</span>
<span style=color:#a2f>echo</span> -e <span style=color:#b44>&#39;#!/bin/bash\n\necho &#34;My first command-line argument was $1&#34;&#39;</span> &gt; kubectl-foo-bar-baz
sudo chmod +x ./kubectl-foo-bar-baz

<span style=color:#080;font-style:italic># 将插件放到 PATH 下完成&#34;安装&#34;</span>
sudo mv ./kubectl-foo-bar-baz /usr/local/bin

<span style=color:#080;font-style:italic># 确保 kubectl 能够识别我们的插件</span>
kubectl plugin list
</code></pre></div><pre><code>The following kubectl-compatible plugins are available:

/usr/local/bin/kubectl-foo-bar-baz
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># 测试通过 &#34;kubectl&#34; 命令来调用我们的插件时可行的</span>
<span style=color:#080;font-style:italic># 即使我们给插件传递一些额外的参数或标志</span>
kubectl foo bar baz arg1 --meaningless-flag<span style=color:#666>=</span><span style=color:#a2f>true</span>
</code></pre></div><pre><code>My first command-line argument was arg1
</code></pre>
<p>正如你所看到的，我们的插件是基于用户指定的 <code>kubectl</code> 命令找到的，
所有额外的参数和标记都是按原样传递给插件可执行文件的。</p>
<h4 id=带有破折号和下划线的名称>带有破折号和下划线的名称</h4>
<p>虽然 <code>kubectl</code> 插件机制在插件文件名中使用破折号（<code>-</code>）分隔插件处理的子命令序列，
但是仍然可以通过在文件名中使用下划线（<code>_</code>）来创建命令行中包含破折号的插件命令。</p>
<p>例子：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#080;font-style:italic># 创建文件名中包含下划线的插件</span>
<span style=color:#a2f>echo</span> -e <span style=color:#b44>&#39;#!/bin/bash\n\necho &#34;I am a plugin with a dash in my name&#34;&#39;</span> &gt; ./kubectl-foo_bar
sudo chmod +x ./kubectl-foo_bar
  
<span style=color:#080;font-style:italic># 将插件放到 PATH 下</span>
sudo mv ./kubectl-foo_bar /usr/local/bin

<span style=color:#080;font-style:italic># 现在可以通过 kubectl 来调用插件</span>
kubectl foo-bar
</code></pre></div><pre><code>I am a plugin with a dash in my name
</code></pre>
<p>请注意，在插件文件名中引入下划线并不会阻止我们使用 <code>kubectl foo_bar</code> 之类的命令。
可以使用破折号（<code>-</code>）或下划线（<code>_</code>）调用上面示例中的命令:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># 我们的插件也可以用破折号来调用</span>
kubectl foo-bar
</code></pre></div><pre><code>I am a plugin with a dash in my name
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># 你也可以使用下划线来调用我们的定制命令</span>
kubectl foo_bar
</code></pre></div><pre><code>I am a plugin with a dash in my name
</code></pre>
<h4 id=命名冲突和弊端>命名冲突和弊端</h4>
<p>可以在 <code>PATH</code> 的不同位置提供多个文件名相同的插件，
例如，给定一个 <code>PATH</code> 为: <code>PATH=/usr/local/bin/plugins:/usr/local/bin/moreplugins</code>，
在 <code>/usr/local/bin/plugins</code> 和 <code>/usr/local/bin/moreplugins</code> 中可以存在一个插件
<code>kubectl-foo</code> 的副本，这样 <code>kubectl plugin list</code> 命令的输出就是:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#b8860b>PATH</span><span style=color:#666>=</span>/usr/local/bin/plugins:/usr/local/bin/moreplugins kubectl plugin list
</code></pre></div><pre><code>The following kubectl-compatible plugins are available:
  
/usr/local/bin/plugins/kubectl-foo
/usr/local/bin/moreplugins/kubectl-foo
  - warning: /usr/local/bin/moreplugins/kubectl-foo is overshadowed by a similarly named plugin: /usr/local/bin/plugins/kubectl-foo
  
error: one plugin warning was found
</code></pre>
<p>在上面的场景中 <code>/usr/local/bin/moreplugins/kubectl-foo</code> 下的警告告诉我们这个插件永远不会被执行。
相反，首先出现在我们路径中的可执行文件 <code>/usr/local/bin/plugins/kubectl-foo</code>
总是首先被 <code>kubectl</code> 插件机制找到并执行。</p>
<p>解决这个问题的一种方法是你确保你希望与 <code>kubectl</code> 一起使用的插件的位置总是在你的路径中首先出现。
例如，如果我们总是想使用 <code>/usr/local/bin/moreplugins/kubectl foo</code>，
那么在调用 <code>kubectl</code> 命令 <code>kubectl foo</code> 时，我们只需将路径的值更改为 <code>PATH=/usr/local/bin/moreplugins:/usr/local/bin/plugins</code>。</p>
<h4 id=调用最长的可执行文件名>调用最长的可执行文件名</h4>
<p>对于插件文件名而言还有另一种弊端，给定用户路径中的两个插件 <code>kubectl-foo-bar</code> 和 <code>kubectl-foo-bar-baz</code>
<code>kubectl</code> 插件机制总是为给定的用户命令选择尽可能长的插件名称。下面的一些例子进一步的说明了这一点：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#080;font-style:italic># 对于给定的 kubectl 命令，最长可能文件名的插件是被优先选择的</span>
kubectl foo bar baz
</code></pre></div><pre><code>Plugin kubectl-foo-bar-baz is executed
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl foo bar
</code></pre></div><pre><code>Plugin kubectl-foo-bar is executed
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl foo bar baz buz
</code></pre></div><pre><code>Plugin kubectl-foo-bar-baz is executed, with &quot;buz&quot; as its first argument
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl foo bar buz
</code></pre></div><pre><code>Plugin kubectl-foo-bar is executed, with &quot;buz&quot; as its first argument
</code></pre>
<p>这种设计选择确保插件子命令可以跨多个文件实现，如果需要，这些子命令可以嵌套在"父"插件命令下：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>ls ./plugin_command_tree
</code></pre></div><pre><code>kubectl-parent
kubectl-parent-subcommand
kubectl-parent-subcommand-subsubcommand
</code></pre>
<h3 id=检查插件警告>检查插件警告</h3>
<p>你可以使用前面提到的 <code>kubectl plugin list</code> 命令来确保你的插件可以被 <code>kubectl</code> 看到，
并且验证没有警告防止它被称为 <code>kubectl</code> 命令。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl plugin list
</code></pre></div><pre><code>The following kubectl-compatible plugins are available:
  
test/fixtures/pkg/kubectl/plugins/kubectl-foo
/usr/local/bin/kubectl-foo
  - warning: /usr/local/bin/kubectl-foo is overshadowed by a similarly named plugin: test/fixtures/pkg/kubectl/plugins/kubectl-foo
plugins/kubectl-invalid
  - warning: plugins/kubectl-invalid identified as a kubectl plugin, but it is not executable

error: 2 plugin warnings were found
</code></pre>
<h3 id=using-the-command-line-runtime-package>使用命令行运行时包 </h3>
<p>如果你在编写 kubectl 插件，而且你选择使用 Go 语言，你可以利用
<a href=https://github.com/kubernetes/cli-runtime>cli-runtime</a> 工具库。</p>
<p>这些库提供了一些辅助函数，用来解析和更新用户的
<a href=/zh/docs/concepts/configuration/organize-cluster-access-kubeconfig/>kubeconfig</a>
文件，向 API 服务器发起 REST 风格的请求，或者将参数绑定到某配置上，
抑或将其打印输出。</p>
<p>关于 CLI Runtime 仓库所提供的工具的使用实例，可参考
<a href=https://github.com/kubernetes/sample-cli-plugin>CLI 插件示例</a> 项目。</p>
<h2 id=分发-kubectl-插件>分发 kubectl 插件</h2>
<p>如果你开发了一个插件给别人使用，你应该考虑如何为其封装打包、如何分发软件
以及将来的更新到用户。</p>
<h3 id=distributing-krew>Krew</h3>
<p><a href=https://krew.dev/>Krew</a> 提供了一种对插件进行打包和分发的跨平台方式。
基于这种方式，你会在所有的目标平台（Linux、Windows、macOS 等）使用同一
种打包形式，包括为用户提供更新。
Krew 也维护一个<a href=https://krew.sigs.k8s.io/plugins/>插件索引（plugin index）</a>
以便其他人能够发现你的插件并安装之。</p>
<h3 id=distributing-native>原生的与特定平台的包管理 </h3>
<p>另一种方式是，你可以使用传统的包管理器（例如 Linux 上 的 <code>apt</code> 或 <code>yum</code>，
Windows 上的 Chocolatey、macOs 上的 Homebrew）。
只要能够将新的可执行文件放到用户的 <code>PATH</code> 路径上某处，这种包管理器就符合需要。
作为一个插件作者，如果你选择这种方式来分发，你就需要自己来管理和更新
你的 kubectl 插件的分发包，包括所有平台和所有发行版本。</p>
<h3 id=distributing-source-code>源代码 </h3>
<p>你也可以发布你的源代码，例如，发布为某个 Git 仓库。
如果你选择这条路线，希望使用该插件的用户必须取回代码、配置一个构造环境
（如果需要编译的话）并部署该插件。
如果你也提供编译后的软件包，或者使用 Krew，那就会大大简化安装过程了。</p>
<h2 id=what-s-next>What's next</h2>
<ul>
<li>查看 CLI 插件库示例，查看用 Go 编写的插件的<a href=https://github.com/kubernetes/sample-cli-plugin>详细示例</a></li>
<li>如有任何问题，请随时联系 <a href=https://github.com/kubernetes/community/tree/master/sig-cli>SIG CLI </a></li>
<li>了解 <a href=https://krew.dev/>Krew</a>，一个 kubectl 插件管理器。</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-fdfb2a2cba62a1e624897eaebac0168e>22 - 管理巨页（HugePages）</h1>
<div class=lead>将大页配置和管理为集群中的可调度资源。</div>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.23 [stable]</code>
</div>
<p>Kubernetes 支持在 Pod 应用中使用预先分配的巨页。本文描述了用户如何使用巨页，以及当前的限制。</p>
<h2 id=before-you-begin>Before you begin</h2>
<ol>
<li>为了使节点能够上报巨页容量，Kubernetes 节点必须预先分配巨页。每个节点只能预先分配一种特定规格的巨页。</li>
</ol>
<p>节点会自动发现全部巨页资源，并作为可供调度的资源进行上报。</p>
<h2 id=api>API</h2>
<p>用户可以通过在容器级别的资源需求中使用资源名称 <code>hugepages-&lt;size></code> 来使用巨页，其中的 size 是特定节点上支持的以整数值表示的最小二进制单位。 例如，如果一个节点支持 2048KiB 和 1048576KiB 页面大小，它将公开可调度的资源 <code>hugepages-2Mi</code> 和 <code>hugepages-1Gi</code>。与 CPU 或内存不同，巨页不支持过量使用（overcommit）。注意，在请求巨页资源时，还必须请求内存或 CPU 资源。</p>
<p>同一 Pod 的 spec 中可能会消耗不同尺寸的巨页。在这种情况下，它必须对所有挂载卷使用 <code>medium: HugePages-&lt;hugepagesize></code> 标识。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>huge-pages-example<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>example<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>fedora:latest<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- sleep<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- inf<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/hugepages-2Mi<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>hugepage-2mi<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/hugepages-1Gi<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>hugepage-1gi<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>hugepages-2Mi</span>:<span style=color:#bbb> </span>100Mi<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>hugepages-1Gi</span>:<span style=color:#bbb> </span>2Gi<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>100Mi<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>100Mi<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>hugepage-2mi<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>emptyDir</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>medium</span>:<span style=color:#bbb> </span>HugePages-2Mi<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>hugepage-1gi<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>emptyDir</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>medium</span>:<span style=color:#bbb> </span>HugePages-1Gi<span style=color:#bbb>
</span></code></pre></div>
<p>Pod 只有在请求同一大小的巨页时才使用 <code>medium：HugePages</code>。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>huge-pages-example<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>example<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>fedora:latest<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- sleep<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- inf<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/hugepages<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>hugepage<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>hugepages-2Mi</span>:<span style=color:#bbb> </span>100Mi<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>100Mi<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>100Mi<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>hugepage<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>emptyDir</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>medium</span>:<span style=color:#bbb> </span>HugePages<span style=color:#bbb>
</span></code></pre></div>
<ul>
<li>巨页的资源请求值必须等于其限制值。该条件在指定了资源限制，而没有指定请求的情况下默认成立。</li>
<li>巨页是被隔离在 pod 作用域的，因此每个容器在 spec 中都对 cgroup 沙盒有自己的限制。</li>
<li>巨页可用于 EmptyDir 卷，不过 EmptyDir 卷所使用的巨页数量不能够超出 Pod 请求的巨页数量。</li>
<li>通过带有 <code>SHM_HUGETLB</code> 的 <code>shmget()</code> 使用巨页的应用，必须运行在一个与
<code>proc/sys/vm/hugetlb_shm_group</code> 匹配的补充组下。</li>
<li>通过 ResourceQuota 资源，可以使用 <code>hugepages-&lt;size></code> 标记控制每个命名空间下的巨页使用量，
类似于使用 <code>cpu</code> 或 <code>memory</code> 来控制其他计算资源。</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-5ab7bc7f14942c5c4b29d19f4a87271c>23 - 调度 GPUs</h1>
<div class=lead>配置和调度 GPU 成一类资源以供集群中节点使用。</div>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.10 [beta]</code>
</div>
<p>Kubernetes 支持对节点上的 AMD 和 NVIDIA GPU （图形处理单元）进行管理，目前处于<strong>实验</strong>状态。</p>
<p>本页介绍用户如何在不同的 Kubernetes 版本中使用 GPU，以及当前存在的一些限制。</p>
<h2 id=using-device-plugins>使用设备插件 </h2>
<p>Kubernetes 实现了<a class=glossary-tooltip title="一种软件扩展，可以使 Pod 访问由特定厂商初始化或者安装的设备。" data-toggle=tooltip data-placement=top href=/zh/docs/concepts/extend-kubernetes/compute-storage-net/device-plugins/ target=_blank aria-label="设备插件（Device Plugins）">设备插件（Device Plugins）</a>
以允许 Pod 访问类似 GPU 这类特殊的硬件功能特性。</p>
<p>作为集群管理员，你要在节点上安装来自对应硬件厂商的 GPU 驱动程序，并运行
来自 GPU 厂商的对应的设备插件。</p>
<ul>
<li><a href=#deploying-amd-gpu-device-plugin>AMD</a></li>
<li><a href=#deploying-nvidia-gpu-device-plugin>NVIDIA</a></li>
</ul>
<p>当以上条件满足时，Kubernetes 将暴露 <code>amd.com/gpu</code> 或 <code>nvidia.com/gpu</code> 为
可调度的资源。</p>
<p>你可以通过请求 <code>&lt;vendor>.com/gpu</code> 资源来使用 GPU 设备，就像你为 CPU
和内存所做的那样。
不过，使用 GPU 时，在如何指定资源需求这个方面还是有一些限制的：</p>
<ul>
<li>GPUs 只能设置在 <code>limits</code> 部分，这意味着：
<ul>
<li>你可以指定 GPU 的 <code>limits</code> 而不指定其 <code>requests</code>，Kubernetes 将使用限制
值作为默认的请求值；</li>
<li>你可以同时指定 <code>limits</code> 和 <code>requests</code>，不过这两个值必须相等。</li>
<li>你不可以仅指定 <code>requests</code> 而不指定 <code>limits</code>。</li>
</ul>
</li>
<li>容器（以及 Pod）之间是不共享 GPU 的。GPU 也不可以过量分配（Overcommitting）。</li>
<li>每个容器可以请求一个或者多个 GPU，但是用小数值来请求部分 GPU 是不允许的。</li>
</ul>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cuda-vector-add<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>OnFailure<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cuda-vector-add<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># https://github.com/kubernetes/kubernetes/blob/v1.7.11/test/images/nvidia-cuda/Dockerfile</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;k8s.gcr.io/cuda-vector-add:v0.1&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>nvidia.com/gpu</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb> </span><span style=color:#080;font-style:italic># requesting 1 GPU</span><span style=color:#bbb>
</span></code></pre></div>
<h3 id=deploying-amd-gpu-device-plugin>部署 AMD GPU 设备插件 </h3>
<p><a href=https://github.com/RadeonOpenCompute/k8s-device-plugin>官方的 AMD GPU 设备插件</a> 有以下要求：</p>
<ul>
<li>Kubernetes 节点必须预先安装 AMD GPU 的 Linux 驱动。</li>
</ul>
<p>如果你的集群已经启动并且满足上述要求的话，可以这样部署 AMD 设备插件：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create -f https://raw.githubusercontent.com/RadeonOpenCompute/k8s-device-plugin/r1.10/k8s-ds-amdgpu-dp.yaml
</code></pre></div>
<p>你可以到 <a href=https://github.com/RadeonOpenCompute/k8s-device-plugin>RadeonOpenCompute/k8s-device-plugin</a>
项目报告有关此设备插件的问题。</p>
<h3 id=deploying-nvidia-gpu-device-plugin>部署 NVIDIA GPU 设备插件 </h3>
<p>对于 NVIDIA GPUs，目前存在两种设备插件的实现：</p>
<h4 id=官方的-nvidia-gpu-设备插件>官方的 NVIDIA GPU 设备插件</h4>
<p><a href=https://github.com/NVIDIA/k8s-device-plugin>官方的 NVIDIA GPU 设备插件</a> 有以下要求:</p>
<ul>
<li>Kubernetes 的节点必须预先安装了 NVIDIA 驱动</li>
<li>Kubernetes 的节点必须预先安装 <a href=https://github.com/NVIDIA/nvidia-docker>nvidia-docker 2.0</a></li>
<li>Docker 的<a href=https://github.com/NVIDIA/k8s-device-plugin#preparing-your-gpu-nodes>默认运行时</a>必须设置为 nvidia-container-runtime，而不是 runc</li>
<li>NVIDIA 驱动版本 ~= 384.81</li>
</ul>
<p>如果你的集群已经启动并且满足上述要求的话，可以这样部署 NVIDIA 设备插件：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create -f https://raw.githubusercontent.com/NVIDIA/k8s-device-plugin/1.0.0-beta4/nvidia-device-plugin.yml
</code></pre></div><p>请到 <a href=https://github.com/NVIDIA/k8s-device-plugin>NVIDIA/k8s-device-plugin</a>项目报告有关此设备插件的问题。</p>
<h4 id=gce-中使用的-nvidia-gpu-设备插件>GCE 中使用的 NVIDIA GPU 设备插件</h4>
<p><a href=https://github.com/GoogleCloudPlatform/container-engine-accelerators/tree/master/cmd/nvidia_gpu>GCE 使用的 NVIDIA GPU 设备插件</a> 并不要求使用 nvidia-docker，并且对于任何实现了 Kubernetes CRI 的容器运行时，都应该能够使用。这一实现已经在 <a href=https://cloud.google.com/container-optimized-os/>Container-Optimized OS</a> 上进行了测试，并且在 1.9 版本之后会有对于 Ubuntu 的实验性代码。</p>
<p>你可以使用下面的命令来安装 NVIDIA 驱动以及设备插件：</p>
<pre><code># 在 COntainer-Optimized OS 上安装 NVIDIA 驱动:
kubectl create -f https://raw.githubusercontent.com/GoogleCloudPlatform/container-engine-accelerators/stable/daemonset.yaml

# 在 Ubuntu 上安装 NVIDIA 驱动 (实验性质):
kubectl create -f https://raw.githubusercontent.com/GoogleCloudPlatform/container-engine-accelerators/stable/nvidia-driver-installer/ubuntu/daemonset.yaml

# 安装设备插件:
kubectl create -f https://raw.githubusercontent.com/kubernetes/kubernetes/release-1.12/cluster/addons/device-plugins/nvidia-gpu/daemonset.yaml
</code></pre>
<p>请到 <a href=https://github.com/GoogleCloudPlatform/container-engine-accelerators>GoogleCloudPlatform/container-engine-accelerators</a> 报告有关此设备插件以及安装方法的问题。</p>
<p>关于如何在 GKE 上使用 NVIDIA GPUs，Google 也提供自己的<a href=https://cloud.google.com/kubernetes-engine/docs/how-to/gpus>指令</a>。</p>
<h2 id=集群内存在不同类型的-gpu>集群内存在不同类型的 GPU</h2>
<p>如果集群内部的不同节点上有不同类型的 NVIDIA GPU，那么你可以使用
<a href=/zh/docs/tasks/configure-pod-container/assign-pods-nodes/>节点标签和节点选择器</a>
来将 pod 调度到合适的节点上。</p>
<p>例如：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># 为你的节点加上它们所拥有的加速器类型的标签</span>
kubectl label nodes &lt;node-with-k80&gt; <span style=color:#b8860b>accelerator</span><span style=color:#666>=</span>nvidia-tesla-k80
kubectl label nodes &lt;node-with-p100&gt; <span style=color:#b8860b>accelerator</span><span style=color:#666>=</span>nvidia-tesla-p100
</code></pre></div>
<h2 id=node-labeller>自动节点标签 </h2>
<p>如果你在使用 AMD GPUs，你可以部署
<a href=https://github.com/RadeonOpenCompute/k8s-device-plugin/tree/master/cmd/k8s-node-labeller>Node Labeller</a>，
它是一个 <a class=glossary-tooltip title="控制器通过 apiserver 监控集群的公共状态，并致力于将当前状态转变为期望的状态。" data-toggle=tooltip data-placement=top href=/zh/docs/concepts/architecture/controller/ target=_blank aria-label=控制器>控制器</a>，
会自动给节点打上 GPU 属性标签。目前支持的属性：</p>
<ul>
<li>设备 ID (-device-id)</li>
<li>VRAM 大小 (-vram)</li>
<li>SIMD 数量(-simd-count)</li>
<li>计算单位数量(-cu-count)</li>
<li>固件和特性版本 (-firmware)</li>
<li>GPU 系列，两个字母的首字母缩写(-family)
<ul>
<li>SI - Southern Islands</li>
<li>CI - Sea Islands</li>
<li>KV - Kaveri</li>
<li>VI - Volcanic Islands</li>
<li>CZ - Carrizo</li>
<li>AI - Arctic Islands</li>
<li>RV - Raven</li>
</ul>
</li>
</ul>
<p>示例:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe node cluster-node-23
</code></pre></div><pre><code>    Name:               cluster-node-23
    Roles:              &lt;none&gt;
    Labels:             beta.amd.com/gpu.cu-count.64=1
                        beta.amd.com/gpu.device-id.6860=1
                        beta.amd.com/gpu.family.AI=1
                        beta.amd.com/gpu.simd-count.256=1
                        beta.amd.com/gpu.vram.16G=1
                        beta.kubernetes.io/arch=amd64
                        beta.kubernetes.io/os=linux
                        kubernetes.io/hostname=cluster-node-23
    Annotations:        kubeadm.alpha.kubernetes.io/cri-socket: /var/run/dockershim.sock
                        node.alpha.kubernetes.io/ttl: 0
    ......
</code></pre>
<p>使用了 Node Labeller 的时候，你可以在 Pod 的规约中指定 GPU 的类型：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cuda-vector-add<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>OnFailure<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cuda-vector-add<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># https://github.com/kubernetes/kubernetes/blob/v1.7.11/test/images/nvidia-cuda/Dockerfile</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;k8s.gcr.io/cuda-vector-add:v0.1&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>nvidia.com/gpu</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>nodeSelector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>accelerator</span>:<span style=color:#bbb> </span>nvidia-tesla-p100<span style=color:#bbb> </span><span style=color:#080;font-style:italic># or nvidia-tesla-k80 etc.</span><span style=color:#bbb>
</span></code></pre></div>
<p>这能够保证 Pod 能够被调度到你所指定类型的 GPU 的节点上去。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-cb9e28c208c6cfbabdb15ba2e42e9ef0>24 - 资源监控工具</h1>
<p>要扩展应用程序并提供可靠的服务，你需要了解应用程序在部署时的行为。
你可以通过检测容器检查 Kubernetes 集群中的应用程序性能，
<a href=/zh/docs/concepts/workloads/pods>Pods</a>,
<a href=/zh/docs/concepts/services-networking/service/>服务</a>
和整个集群的特征。
Kubernetes 在每个级别上提供有关应用程序资源使用情况的详细信息。
此信息使你可以评估应用程序的性能，以及在何处可以消除瓶颈以提高整体性能。</p>
<p>在 Kubernetes 中，应用程序监控不依赖单个监控解决方案。
在新集群上，你可以使用<a href=#resource-metrics-pipeline>资源度量</a>或
<a href=#full-metrics-pipeline>完整度量</a>管道来收集监视统计信息。</p>
<h2 id=resource-metrics-pipeline>资源度量管道 </h2>
<p>资源指标管道提供了一组与集群组件，例如
<a href=/zh/docs/tasks/run-application/horizontal-pod-autoscale/>Horizontal Pod Autoscaler</a>
控制器以及 <code>kubectl top</code> 实用程序相关的有限度量。
这些指标是由轻量级的、短期、内存存储的
<a href=https://github.com/kubernetes-sigs/metrics-server>metrics-server</a> 收集的，
通过 <code>metrics.k8s.io</code> 公开。</p>
<p>度量服务器发现集群中的所有节点，并且查询每个节点的
<a href=/zh/docs/reference/command-line-tools-reference/kubelet/>kubelet</a>
以获取 CPU 和内存使用情况。
Kubelet 充当 Kubernetes 主节点与节点之间的桥梁，管理机器上运行的 Pod 和容器。
kubelet 将每个 Pod 转换为其组成的容器，并在容器运行时通过容器运行时接口
获取各个容器使用情况统计信息。
kubelet 从集成的 cAdvisor 获取此信息，以进行旧式 Docker 集成。
然后，它通过 metrics-server Resource Metrics API 公开聚合的 pod 资源使用情况统计信息。
该 API 在 kubelet 的经过身份验证和只读的端口上的 <code>/metrics/resource/v1beta1</code> 中提供。</p>
<h2 id=full-metrics-pipeline>完整度量管道 </h2>
<p>一个完整度量管道可以让你访问更丰富的度量。
Kubernetes 还可以根据集群的当前状态，使用 Pod 水平自动扩缩器等机制，
通过自动调用扩展或调整集群来响应这些度量。
监控管道从 kubelet 获取度量值，然后通过适配器将它们公开给 Kubernetes，
方法是实现 <code>custom.metrics.k8s.io</code> 或 <code>external.metrics.k8s.io</code> API。</p>
<p><a href=https://prometheus.io>Prometheus</a> 是一个 CNCF 项目，可以原生监控 Kubernetes、
节点和 Prometheus 本身。
完整度量管道项目不属于 CNCF 的一部分，不在 Kubernetes 文档的范围之内。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-0c4484d31ad3902880897e694bbd306f>25 - 配置 kubelet 镜像凭据提供程序</h1>
<div class=lead>配置 kubelet 的镜像凭据提供程序插件</div>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.20 [alpha]</code>
</div>
<p>从 Kubernetes v1.20 开始，kubelet 可以使用 exec 插件动态检索容器镜像注册中心的凭据。
kubelet 和 exec 插件使用 Kubernetes 版本化 API 通过标准输入输出（标准输入、标准输出和标准错误）通信。
这些插件允许 kubelet 动态请求容器注册中心的凭据，而不是将静态凭据存储在磁盘上。
例如，插件可能会与本地元数据通信，以检索 kubelet 正在拉取的镜像的短期凭据。</p>
<p>如果以下任一情况属实，你可能对此功能感兴趣：</p>
<ul>
<li>需要调用云提供商的 API 来检索注册中心的身份验证信息。</li>
<li>凭据的到期时间很短，需要频繁请求新凭据。</li>
<li>将注册中心凭据存储在磁盘或者 imagePullSecret 是不可接受的。</li>
</ul>
<h2 id=before-you-begin>Before you begin</h2>
<ul>
<li>kubelet 镜像凭证提供程序在 v1.20 版本作为 alpha 功能引入。
与其他 alpha 功能一样，当前仅当在 kubelet 启动 <code>KubeletCredentialProviders</code> 特性门禁才能使该功能正常工作。</li>
<li>凭据提供程序 exec 插件的工作实现。你可以构建自己的插件或使用云提供商提供的插件。</li>
</ul>
<h2 id=installing-plugins-on-nodes>在节点上安装插件 </h2>
<p>凭据提供程序插件是将由 kubelet 运行的可执行二进制文件。
确保插件二进制存在于你的集群的每个节点上，并存储在已知目录中。
稍后配置 kubelet 标志需要该目录。</p>
<h2 id=configuring-the-kubelet>配置 kubelet </h2>
<p>为了使用这个特性，kubelet 需要设置以下两个标志：</p>
<ul>
<li><code>--image-credential-provider-config</code> —— 凭据提供程序插件配置文件的路径。</li>
<li><code>--image-credential-provider-bin-dir</code> —— 凭据提供程序插件二进制文件所在目录的路径。</li>
</ul>
<h3 id=configure-a-kubelet-credential-provider>配置 kubelet 凭据提供程序 </h3>
<p>kubelet 会读取传入 <code>--image-credential-provider-config</code> 的配置文件文件，
以确定应该为哪些容器镜像调用哪些 exec 插件。
如果你正在使用基于 <a href=https://aws.amazon.com/ecr/>ECR</a> 插件，
这里有个样例配置文件你可能最终会使用到：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>CredentialProviderConfig<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>kubelet.config.k8s.io/v1alpha1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># providers 是将由 kubelet 启用的凭证提供程序插件列表。</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># 多个提供程序可能与单个镜像匹配，在这种情况下，来自所有提供程序的凭据将返回到 kubelet。</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># 如果为单个镜像调用多个提供程序，则结果会合并。</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># 如果提供程序返回重叠的身份验证密钥，则使用提供程序列表中较早的值。</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>providers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># name 是凭据提供程序的必需名称。 </span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 它必须与 kubelet 看到的提供程序可执行文件的名称相匹配。</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 可执行文件必须在 kubelet 的 bin 目录中</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># （由 --image-credential-provider-bin-dir 标志设置）。</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>ecr<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># matchImages 是一个必需的字符串列表，用于匹配镜像以确定是否应调用此提供程序。</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 如果其中一个字符串与 kubelet 请求的镜像相匹配，则该插件将被调用并有机会提供凭据。</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 镜像应包含注册域和 URL 路径。</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic>#</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># matchImages 中的每个条目都是一个模式，可以选择包含端口和路径。</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 通配符可以在域中使用，但不能在端口或路径中使用。</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 支持通配符作为子域（例如“*.k8s.io”或“k8s.*.io”）和顶级域（例如“k8s.*”）。</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 还支持匹配部分子域，如“app*.k8s.io”。</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 每个通配符只能匹配一个子域段，因此 *.io 不匹配 *.k8s.io。</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic>#</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 当以下所有条件都为真时，镜像和 matchImage 之间存在匹配：</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># - 两者都包含相同数量的域部分并且每个部分都匹配。</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># - imageMatch 的 URL 路径必须是目标镜像 URL 路径的前缀。</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># - 如果 imageMatch 包含端口，则该端口也必须在图像中匹配。</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic>#</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># matchImages 的示例值：</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># - 123456789.dkr.ecr.us-east-1.amazonaws.com</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># - *.azurecr.io</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># - gcr.io</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># - *.*.registry.io</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># - registry.io:8080/path</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchImages</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;*.dkr.ecr.*.amazonaws.com&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;*.dkr.ecr.*.amazonaws.cn&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;*.dkr.ecr-fips.*.amazonaws.com&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;*.dkr.ecr.us-iso-east-1.c2s.ic.gov&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;*.dkr.ecr.us-isob-east-1.sc2s.sgov.gov&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># defaultCacheDuration 是插件将在内存中缓存凭据的默认持续时间</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 如果插件响应中未提供缓存持续时间。此字段是必需的。</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>defaultCacheDuration</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;12h&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># exec CredentialProviderRequest 的必需输入版本。</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 返回的 CredentialProviderResponse 必须使用与输入相同的编码版本。当前支持的值为：</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># - credentialprovider.kubelet.k8s.io/v1alpha1</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>credentialprovider.kubelet.k8s.io/v1alpha1<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 执行命令时传递给命令的参数。</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># +可选</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- get-credentials<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># env 定义了额外的环境变量以暴露给进程。</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 这些与主机环境以及 client-go 用于将参数传递给插件的变量结合在一起。</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># +可选</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>AWS_PROFILE<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span>example_profile<span style=color:#bbb>
</span></code></pre></div>
<p><code>providers</code> 字段是 kubelet 使用的已启用插件列表。每个条目都有几个必填字段：</p>
<ul>
<li><code>name</code>：插件的名称，必须与传入<code>--image-credential-provider-bin-dir</code>
的目录中存在的可执行二进制文件的名称相匹配。</li>
<li><code>matchImages</code>：用于匹配图像以确定是否应调用此提供程序的字符串列表。更多相关信息如下。</li>
<li><code>defaultCacheDuration</code>：如果插件未指定缓存持续时间，kubelet 将在内存中缓存凭据的默认持续时间。</li>
<li><code>apiVersion</code>：kubelet 和 exec 插件在通信时将使用的 api 版本。</li>
</ul>
<p>每个凭证提供程序也可以被赋予可选的参数和环境变量。
咨询插件实现者以确定给定插件需要哪些参数和环境变量集。</p>
<h4 id=configure-image-matching>配置镜像匹配 </h4>
<p>kubelet 使用每个凭证提供程序的 <code>matchImages</code> 字段来确定是否应该为 Pod 正在使用的给定镜像调用插件。
<code>matchImages</code> 中的每个条目都是一个镜像模式，可以选择包含端口和路径。
通配符可以在域中使用，但不能在端口或路径中使用。
支持通配符作为子域，如 <code>*.k8s.io</code> 或 <code>k8s.*.io</code>，以及顶级域，如 <code>k8s.*</code>。
还支持匹配部分子域，如 <code>app*.k8s.io</code>。每个通配符只能匹配一个子域段，
因此 <code>*.io</code> 不匹配 <code>*.k8s.io</code>。</p>
<p>当以下所有条件都为真时，镜像名称和 <code>matchImage</code> 条目之间存在匹配：</p>
<ul>
<li>两者都包含相同数量的域部分并且每个部分都匹配。</li>
<li>匹配图片的 URL 路径必须是目标图片 URL 路径的前缀。</li>
<li>如果 imageMatch 包含端口，则该端口也必须在镜像中匹配。</li>
</ul>
<p><code>matchImages</code> 模式的一些示例值：</p>
<ul>
<li><code>123456789.dkr.ecr.us-east-1.amazonaws.com</code></li>
<li><code>*.azurecr.io</code></li>
<li><code>gcr.io</code></li>
<li><code>*.*.registry.io</code></li>
<li><code>foo.registry.io:8080/path</code></li>
</ul>
</div>
</main>
</div>
</div>
<footer class=d-print-none>
<div class=footer__links>
<nav>
<a class=text-white href=/zh/docs/home/>主页</a>
<a class=text-white href=/zh/blog/>博客</a>
<a class=text-white href=/zh/training/>培训</a>
<a class=text-white href=/zh/partners/>合作伙伴</a>
<a class=text-white href=/zh/community/>社区</a>
<a class=text-white href=/zh/case-studies/>案例分析</a>
</nav>
</div>
<div class=container-fluid>
<div class=row>
<div class="col-6 col-sm-2 text-xs-center order-sm-2">
<ul class="list-inline mb-0">
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="User mailing list" aria-label="User mailing list">
<a class=text-white target=_blank href=https://discuss.kubernetes.io>
<i class="fa fa-envelope"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Twitter aria-label=Twitter>
<a class=text-white target=_blank href=https://twitter.com/kubernetesio>
<i class="fab fa-twitter"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Calendar aria-label=Calendar>
<a class=text-white target=_blank href="https://calendar.google.com/calendar/embed?src=calendar%40kubernetes.io">
<i class="fas fa-calendar-alt"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Youtube aria-label=Youtube>
<a class=text-white target=_blank href=https://youtube.com/kubernetescommunity>
<i class="fab fa-youtube"></i>
</a>
</li>
</ul>
</div>
<div class="col-6 col-sm-2 text-right text-xs-center order-sm-3">
<ul class="list-inline mb-0">
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub>
<a class=text-white target=_blank href=https://github.com/kubernetes/kubernetes>
<i class="fab fa-github"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Slack aria-label=Slack>
<a class=text-white target=_blank href=https://slack.k8s.io>
<i class="fab fa-slack"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Contribute aria-label=Contribute>
<a class=text-white target=_blank href=https://git.k8s.io/community/contributors/guide>
<i class="fas fa-edit"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Stack Overflow" aria-label="Stack Overflow">
<a class=text-white target=_blank href=https://stackoverflow.com/questions/tagged/kubernetes>
<i class="fab fa-stack-overflow"></i>
</a>
</li>
</ul>
</div>
<div class="col-12 col-sm-8 text-center order-sm-2">
<small class=text-white>&copy; 2023 The Kubernetes Authors | Documentation Distributed under <a href=https://git.k8s.io/website/LICENSE class=light-text>CC BY 4.0</a></small>
<br>
<small class=text-white>Copyright &copy; 2023 The Linux Foundation &reg;. All rights reserved. The Linux Foundation has registered trademarks and uses trademarks. For a list of trademarks of The Linux Foundation, please see our <a href=https://www.linuxfoundation.org/trademark-usage class=light-text>Trademark Usage page</a></small>
<br>
<small class=text-white>ICP license: 京ICP备17074266号-3</small>
</div>
</div>
</div>
</footer>
</div>
<script src=/js/popper-1.14.3.min.js integrity=sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49 crossorigin=anonymous></script>
<script src=/js/bootstrap-4.3.1.min.js integrity=sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM crossorigin=anonymous></script>
<script src=/js/main.min.40616251a9b6e4b689e7769be0340661efa4d7ebb73f957404e963e135b4ed52.js integrity="sha256-QGFiUam25LaJ53ab4DQGYe+k1+u3P5V0BOlj4TW07VI=" crossorigin=anonymous></script>
</body>
</html>