<!doctype html><html lang=zh class=no-js>
<head>
<meta name=ROBOTS content="NOINDEX, NOFOLLOW">
<script async src="https://www.googletagmanager.com/gtag/js?id=G-JPP6RFM2BP"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-JPP6RFM2BP')</script>
<link rel=alternate hreflang=en href=https://kubernetes.io/docs/tutorials/services/>
<link rel=alternate hreflang=ko href=https://kubernetes.io/ko/docs/tutorials/services/>
<link rel=alternate hreflang=ja href=https://kubernetes.io/ja/docs/tutorials/services/>
<link rel=alternate hreflang=fr href=https://kubernetes.io/fr/docs/tutorials/services/>
<link rel=alternate hreflang=es href=https://kubernetes.io/es/docs/tutorials/services/>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=generator content="Hugo 0.87.0">
<link rel=canonical type=text/html href=https://kubernetes.io/zh/docs/tutorials/services/>
<link rel="shortcut icon" type=image/png href=/images/favicon.png>
<link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180>
<link rel=manifest href=/manifest.webmanifest>
<link rel=apple-touch-icon href=/images/kubernetes-192x192.png>
<title>Services | Kubernetes</title><meta property="og:title" content="Services">
<meta property="og:description" content="生产级别的容器编排系统">
<meta property="og:type" content="website">
<meta property="og:url" content="https://kubernetes.io/zh/docs/tutorials/services/"><meta property="og:site_name" content="Kubernetes">
<meta itemprop=name content="Services">
<meta itemprop=description content="生产级别的容器编排系统"><meta name=twitter:card content="summary">
<meta name=twitter:title content="Services">
<meta name=twitter:description content="生产级别的容器编排系统">
<link href=/scss/main.css rel=stylesheet>
<script src=/js/jquery-3.3.1.min.js integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin=anonymous></script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","url":"https://kubernetes.io","logo":"https://kubernetes.io/images/favicon.png"}</script>
<meta name=theme-color content="#326ce5">
<link rel=stylesheet href=/css/feature-states.css>
<meta name=description content>
<meta property="og:description" content>
<meta name=twitter:description content>
<meta property="og:url" content="https://kubernetes.io/zh/docs/tutorials/services/">
<meta property="og:title" content="Services">
<meta name=twitter:title content="Services">
<meta name=twitter:image content="https://kubernetes.io/images/favicon.png">
<meta name=twitter:image:alt content="Kubernetes">
<meta property="og:image" content="/images/kubernetes-horizontal-color.png">
<meta property="og:type" content="article">
<script src=/js/script.js></script>
</head>
<body class=td-section>
<header>
<nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar" data-auto-burger=primary>
<a class=navbar-brand href=/zh/></a>
<div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar>
<ul class="navbar-nav mt-2 mt-lg-0">
<li class="nav-item mr-2 mb-lg-0">
<a class="nav-link active" href=/zh/docs/>文档</a>
</li>
<li class="nav-item mr-2 mb-lg-0">
<a class=nav-link href=/zh/blog/>Kubernetes 博客</a>
</li>
<li class="nav-item mr-2 mb-lg-0">
<a class=nav-link href=/zh/training/>培训</a>
</li>
<li class="nav-item mr-2 mb-lg-0">
<a class=nav-link href=/zh/partners/>合作伙伴</a>
</li>
<li class="nav-item mr-2 mb-lg-0">
<a class=nav-link href=/zh/community/>社区</a>
</li>
<li class="nav-item mr-2 mb-lg-0">
<a class=nav-link href=/zh/case-studies/>案例分析</a>
</li>
<li class="nav-item dropdown">
<a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>
Versions
</a>
<div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink>
<a class=dropdown-item href=/releases>Release Information</a>
<a class=dropdown-item href=https://kubernetes.io/zh/docs/tutorials/services/>v1.27</a>
<a class=dropdown-item href=https://v1-26.docs.kubernetes.io/zh/docs/tutorials/services/>v1.26</a>
<a class=dropdown-item href=https://v1-25.docs.kubernetes.io/zh/docs/tutorials/services/>v1.25</a>
<a class=dropdown-item href=https://v1-24.docs.kubernetes.io/zh/docs/tutorials/services/>v1.24</a>
<a class=dropdown-item href=https://v1-23.docs.kubernetes.io/zh/docs/tutorials/services/>v1.23</a>
</div>
</li>
<li class="nav-item dropdown">
<a class="nav-link dropdown-toggle" href=# id=navbarDropdownMenuLink role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>
中文 Chinese
</a>
<div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink>
<a class=dropdown-item href=/docs/tutorials/services/>English</a>
<a class=dropdown-item href=/ko/docs/tutorials/services/>한국어 Korean</a>
<a class=dropdown-item href=/ja/docs/tutorials/services/>日本語 Japanese</a>
<a class=dropdown-item href=/fr/docs/tutorials/services/>Français</a>
<a class=dropdown-item href=/es/docs/tutorials/services/>Español</a>
</div>
</li>
</ul>
</div>
<button id=hamburger onclick=kub.toggleMenu() data-auto-burger-exclude><div></div></button>
</nav>
</header>
<div class="container-fluid td-outer">
<div class=td-main>
<div class="row flex-xl-nowrap">
<main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main>
<div class=td-content>
<div class="pageinfo pageinfo-primary d-print-none">
<p>
这是本节的多页打印视图。
<a href=# onclick="return print(),!1">点击此处打印</a>.
</p><p>
<a href=/zh/docs/tutorials/services/>返回本页常规视图</a>.
</p>
</div>
<h1 class=title>Services</h1>
<ul>
<li>1: <a href=#pg-5642e8c51749e4fe2e6a2ccc207f1fab>使用 Source IP</a></li>
</ul>
<div class=content>
</div>
</div>
<div class=td-content>
<h1 id=pg-5642e8c51749e4fe2e6a2ccc207f1fab>1 - 使用 Source IP</h1>
<p>Kubernetes 集群中运行的应用通过 Service 抽象来互相查找、通信和与外部世界沟通。本文介绍被发送到不同类型 Services 的数据包源 IP 的变化过程，你可以根据你的需求改变这些行为。</p>
<h2 id=before-you-begin>Before you begin</h2>
<p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li>
</ul>
To check the version, enter <code>kubectl version</code>.
</p>
<h2 id=术语表>术语表</h2>
<p>本文使用了下列术语：</p>
<ul>
<li><a href=https://en.wikipedia.org/wiki/Network_address_translation>NAT</a>: 网络地址转换</li>
<li><a href=https://en.wikipedia.org/wiki/Network_address_translation#SNAT>Source NAT</a>: 替换数据包的源 IP, 通常为节点的 IP</li>
<li><a href=https://en.wikipedia.org/wiki/Network_address_translation#DNAT>Destination NAT</a>: 替换数据包的目的 IP, 通常为 Pod 的 IP</li>
<li><a href=/zh/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies>VIP</a>: 一个虚拟 IP, 例如分配给每个 Kubernetes Service 的 IP</li>
<li><a href=/zh/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies>Kube-proxy</a>: 一个网络守护程序，在每个节点上协调 Service VIP 管理</li>
</ul>
<h2 id=准备工作>准备工作</h2>
<p>你必须拥有一个正常工作的 Kubernetes 1.5 集群来运行此文档中的示例。该示例使用一个简单的 nginx webserver，通过一个HTTP消息头返回它接收到请求的源IP。你可以像下面这样创建它：</p>
<pre><code class=language-console data-lang=console>kubectl create deployment source-ip-app --image=k8s.gcr.io/echoserver:1.4
</code></pre><p>输出结果为</p>
<pre><code>deployment.apps/source-ip-app created
</code></pre><h2 id=objectives>Objectives</h2>
<ul>
<li>通过多种类型的 Services 暴露一个简单应用</li>
<li>理解每种 Service 类型如何处理源 IP NAT</li>
<li>理解保留源IP所涉及的折中</li>
</ul>
<h2 id=type-clusterip-类型-services-的-source-ip>Type=ClusterIP 类型 Services 的 Source IP</h2>
<p>如果你的 kube-proxy 运行在 <a href=/zh/docs/user-guide/services/#proxy-mode-iptables>iptables 模式</a>下，从集群内部发送到 ClusterIP 的包永远不会进行源地址 NAT，这从 Kubernetes 1.2 开始是默认选项。Kube-proxy 通过一个 <code>proxyMode</code> endpoint 暴露它的模式。</p>
<pre><code class=language-console data-lang=console>kubectl get nodes
</code></pre><p>输出结果与以下结果类似:</p>
<pre><code>NAME                           STATUS     ROLES    AGE     VERSION
kubernetes-node-6jst   Ready      &lt;none&gt;   2h      v1.13.0
kubernetes-node-cx31   Ready      &lt;none&gt;   2h      v1.13.0
kubernetes-node-jj1t   Ready      &lt;none&gt;   2h      v1.13.0
</code></pre><p>从其中一个节点中得到代理模式</p>
<pre><code class=language-console data-lang=console>kubernetes-node-6jst $ curl localhost:10249/proxyMode
</code></pre><p>输出结果为：</p>
<pre><code>iptables
</code></pre><p>你可以通过在source IP应用上创建一个Service来测试源IP保留。</p>
<pre><code class=language-console data-lang=console>kubectl expose deployment source-ip-app --name=clusterip --port=80 --target-port=8080
</code></pre><p>输出结果为：</p>
<pre><code>service/clusterip exposed
</code></pre><pre><code class=language-console data-lang=console>kubectl get svc clusterip
</code></pre><p>输出结果与以下结果类似：</p>
<pre><code>NAME         TYPE        CLUSTER-IP    EXTERNAL-IP   PORT(S)   AGE
clusterip    ClusterIP   10.0.170.92   &lt;none&gt;        80/TCP    51s
</code></pre><p>从相同集群中的一个 pod 访问这个 <code>ClusterIP</code>：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl run busybox -it --image<span style=color:#666>=</span>busybox:1.28 --restart<span style=color:#666>=</span>Never --rm
</code></pre></div><p>输出结果与以下结果类似：</p>
<pre><code>Waiting for pod default/busybox to be running, status is Pending, pod ready: false
If you don't see a command prompt, try pressing enter.
</code></pre><p>然后你可以在 Pod 内运行命令：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># 在终端内使用&#34;kubectl run&#34;执行</span>

ip addr
</code></pre></div><pre><code>1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host
       valid_lft forever preferred_lft forever
3: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1460 qdisc noqueue
    link/ether 0a:58:0a:f4:03:08 brd ff:ff:ff:ff:ff:ff
    inet 10.244.3.8/24 scope global eth0
       valid_lft forever preferred_lft forever
    inet6 fe80::188a:84ff:feb0:26a5/64 scope link
       valid_lft forever preferred_lft forever
</code></pre><p>然后使用 <code>wget</code> 去请求本地 Web 服务器</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># 用名为 &#34;clusterip&#34; 的服务的 IPv4 地址替换 &#34;10.0.170.92&#34;</span>

wget -qO - 10.0.170.92
</code></pre></div><pre><code>CLIENT VALUES:
client_address=10.244.3.8
command=GET
...
</code></pre><p>无论客户端 pod 和 服务端 pod 是否在相同的节点上，client_address 始终是客户端 pod 的 IP 地址。</p>
<h2 id=type-nodeport-类型-services-的-source-ip>Type=NodePort 类型 Services 的 Source IP</h2>
<p>从 Kubernetes 1.5 开始，发送给类型为 <a href=/zh/docs/user-guide/services/#nodeport>Type=NodePort</a> Services 的数据包默认进行源地址 NAT。你可以通过创建一个 <code>NodePort</code> Service 来进行测试：</p>
<pre><code class=language-console data-lang=console>kubectl expose deployment source-ip-app --name=nodeport --port=80 --target-port=8080 --type=NodePort
</code></pre><p>输出结果为：</p>
<pre><code>service/nodeport exposed
</code></pre><pre><code class=language-console data-lang=console>NODEPORT=$(kubectl get -o jsonpath=&quot;{.spec.ports[0].nodePort}&quot; services nodeport)
NODES=$(kubectl get nodes -o jsonpath='{ $.items[*].status.addresses[?(@.type==&quot;InternalIP&quot;)].address }')
</code></pre><p>如果你的集群运行在一个云服务上，你可能需要为上面报告的 <code>nodes:nodeport</code> 开启一条防火墙规则。
现在，你可以通过上面分配的节点端口从外部访问这个 Service。</p>
<pre><code class=language-console data-lang=console>for node in $NODES; do curl -s $node:$NODEPORT | grep -i client_address; done
</code></pre><p>输出结果与以下结果类似：</p>
<pre><code>client_address=10.180.1.1
client_address=10.240.0.5
client_address=10.240.0.3
</code></pre><p>请注意，这些并不是正确的客户端 IP，它们是集群的内部 IP。这是所发生的事情：</p>
<ul>
<li>客户端发送数据包到 <code>node2:nodePort</code></li>
<li><code>node2</code> 使用它自己的 IP 地址替换数据包的源 IP 地址（SNAT）</li>
<li><code>node2</code> 使用 pod IP 地址替换数据包的目的 IP 地址</li>
<li>数据包被路由到 node 1，然后交给 endpoint</li>
<li>Pod 的回复被路由回 node2</li>
<li>Pod 的回复被发送回给客户端</li>
</ul>
<p>用图表示：</p>
<figure>
<div class=mermaid>
graph LR;
client(client)-->node2[节点 2];
node2-->client;
node2-. SNAT .->node1[节点 1];
node1-. SNAT .->node2;
node1-->endpoint(端点);
classDef plain fill:#ddd,stroke:#fff,stroke-width:4px,color:#000;
classDef k8s fill:#326ce5,stroke:#fff,stroke-width:4px,color:#fff;
class node1,node2,endpoint k8s;
class client plain;
</div>
</figure>
<noscript>
<div class="alert alert-secondary callout" role=alert>
<em class=javascript-required>JavaScript must be <a href=https://www.enable-javascript.com/>enabled</a> to view this content</em>
</div>
</noscript>
<p>为了防止这种情况发生，Kubernetes 提供了一个特性来保留客户端的源 IP 地址<a href=/zh/docs/tasks/access-application-cluster/create-external-load-balancer/#preserving-the-client-source-ip>(点击此处查看可用特性)</a>。设置 <code>service.spec.externalTrafficPolicy</code> 的值为 <code>Local</code>，请求就只会被代理到本地 endpoints 而不会被转发到其它节点。这样就保留了最初的源 IP 地址。如果没有本地 endpoints，发送到这个节点的数据包将会被丢弃。这样在应用到数据包的任何包处理规则下，你都能依赖这个正确的 source-ip 使数据包通过并到达 endpoint。</p>
<p>设置 <code>service.spec.externalTrafficPolicy</code> 字段如下：</p>
<pre><code class=language-console data-lang=console>kubectl patch svc nodeport -p '{&quot;spec&quot;:{&quot;externalTrafficPolicy&quot;:&quot;Local&quot;}}'
</code></pre><p>输出结果为：</p>
<pre><code>service/nodeport patched
</code></pre><p>现在，重新运行测试：</p>
<pre><code class=language-console data-lang=console>for node in $NODES; do curl --connect-timeout 1 -s $node:$NODEPORT | grep -i client_address; done
</code></pre><p>输出结果为：</p>
<pre><code>client_address=104.132.1.79
</code></pre><p>请注意，你只从 endpoint pod 运行的那个节点得到了一个回复，这个回复有<em>正确的</em>客户端 IP。</p>
<p>这是发生的事情：</p>
<ul>
<li>客户端发送数据包到 <code>node2:nodePort</code>，它没有任何 endpoints</li>
<li>数据包被丢弃</li>
<li>客户端发送数据包到 <code>node1:nodePort</code>，它<em>有</em>endpoints</li>
<li>node1 使用正确的源 IP 地址将数据包路由到 endpoint</li>
</ul>
<p>用图表示：</p>
<figure>
<div class=mermaid>
graph TD;
client --> node1[节点 1];
client(client) --x node2[节点 2];
node1 --> endpoint(端点);
endpoint --> node1;
classDef plain fill:#ddd,stroke:#fff,stroke-width:4px,color:#000;
classDef k8s fill:#326ce5,stroke:#fff,stroke-width:4px,color:#fff;
class node1,node2,endpoint k8s;
class client plain;
</div>
</figure>
<noscript>
<div class="alert alert-secondary callout" role=alert>
<em class=javascript-required>JavaScript must be <a href=https://www.enable-javascript.com/>enabled</a> to view this content</em>
</div>
</noscript>
<h2 id=type-loadbalancer-类型-services-的-source-ip>Type=LoadBalancer 类型 Services 的 Source IP</h2>
<p>从Kubernetes1.5开始，发送给类型为 <a href=/zh/docs/user-guide/services/#type-nodeport>Type=LoadBalancer</a> Services 的数据包默认进行源地址 NAT，这是因为所有处于 <code>Ready</code> 状态的可调度 Kubernetes 节点对于负载均衡的流量都是符合条件的。所以如果数据包到达一个没有 endpoint 的节点，系统将把这个包代理到<em>有</em> endpoint 的节点，并替换数据包的源 IP 为节点的 IP（如前面章节所述）。</p>
<p>你可以通过在一个 loadbalancer 上暴露这个 source-ip-app 来进行测试。</p>
<pre><code class=language-console data-lang=console>kubectl expose deployment source-ip-app --name=loadbalancer --port=80 --target-port=8080 --type=LoadBalancer
</code></pre><p>输出结果为：</p>
<pre><code>service/loadbalancer exposed
</code></pre><p>打印Service的IPs：</p>
<pre><code class=language-console data-lang=console>kubectl get svc loadbalancer
</code></pre><p>输出结果与以下结果类似：</p>
<pre><code>NAME           TYPE           CLUSTER-IP    EXTERNAL-IP       PORT(S)   AGE
loadbalancer   LoadBalancer   10.0.65.118   104.198.149.140   80/TCP    5m
</code></pre><pre><code class=language-console data-lang=console>curl 104.198.149.140
</code></pre><p>输出结果与以下结果类似：</p>
<pre><code>CLIENT VALUES:
client_address=10.240.0.5
...
</code></pre><p>然而，如果你的集群运行在 Google Kubernetes Engine/GCE 上，可以通过设置 service.spec.externalTrafficPolicy 字段值为 Local ，故意导致健康检查失败来强制使没有 endpoints 的节点把自己从负载均衡流量的可选节点列表中删除。</p>
<p>用图表示：</p>
<p><img src=/images/docs/sourceip-externaltrafficpolicy.svg alt="Source IP with externalTrafficPolicy"></p>
<p>你可以设置 annotation 来进行测试：</p>
<pre><code class=language-console data-lang=console>kubectl patch svc loadbalancer -p '{&quot;spec&quot;:{&quot;externalTrafficPolicy&quot;:&quot;Local&quot;}}'
</code></pre><p>你应该能够立即看到 Kubernetes 分配的 <code>service.spec.healthCheckNodePort</code> 字段：</p>
<pre><code class=language-console data-lang=console>kubectl get svc loadbalancer -o yaml | grep -i healthCheckNodePort
</code></pre><p>输出结果与以下结果类似：</p>
<pre><code>  healthCheckNodePort: 32122
</code></pre><p><code>service.spec.healthCheckNodePort</code> 字段指向每个节点在 <code>/healthz</code> 路径上提供的用于健康检查的端口。你可以这样测试：</p>
<pre><code class=language-console data-lang=console>kubectl get pod -o wide -l run=source-ip-app
</code></pre><p>输出结果与以下结果类似：</p>
<pre><code>NAME                            READY     STATUS    RESTARTS   AGE       IP             NODE
source-ip-app-826191075-qehz4   1/1       Running   0          20h       10.180.1.136   kubernetes-node-6jst
</code></pre><p>使用 curl 命令发送请求到每个节点的 <code>/healthz</code> 路径。</p>
<pre><code class=language-console data-lang=console>kubernetes-node-6jst $ curl localhost:32122/healthz
</code></pre><p>输出结果与以下结果类似：</p>
<pre><code>1 Service Endpoints found
</code></pre><pre><code class=language-console data-lang=console>kubernetes-node-jj1t $ curl localhost:32122/healthz
</code></pre><p>输出结果与以下结果类似：</p>
<pre><code>No Service Endpoints Found
</code></pre><p>主节点运行的 service 控制器负责分配 cloud loadbalancer。在这样做的同时，它也会分配指向每个节点的 HTTP 健康检查的 port/path。等待大约 10 秒钟之后，没有 endpoints 的两个节点的健康检查会失败，然后 curl 负载均衡器的 ip：</p>
<pre><code class=language-console data-lang=console>curl 104.198.149.140
</code></pre><p>输出结果与以下结果类似：</p>
<pre><code>CLIENT VALUES:
client_address=104.132.1.79
...
</code></pre><p><strong>跨平台支持</strong></p>
<p>从 Kubernetes 1.5 开始，通过类型为 Type=LoadBalancer 的 Services 进行源 IP 保存的支持仅在一部分 cloudproviders 中实现（GCP and Azure）。你的集群运行的 cloudprovider 可能以某些不同的方式满足 loadbalancer 的要求：</p>
<ol>
<li>
<p>使用一个代理终止客户端连接并打开一个到你的 nodes/endpoints 的新连接。在这种情况下，源 IP 地址将永远是云负载均衡器的地址而不是客户端的。</p>
</li>
<li>
<p>使用一个包转发器，因此从客户端发送到负载均衡器 VIP 的请求在拥有客户端源 IP 地址的节点终止，而不被中间代理。</p>
</li>
</ol>
<p>第一类负载均衡器必须使用一种它和后端之间约定的协议来和真实的客户端 IP 通信，例如 HTTP <a href=https://en.wikipedia.org/wiki/X-Forwarded-For>X-FORWARDED-FOR</a> 头，或者 <a href=https://www.haproxy.org/download/1.8/doc/proxy-protocol.txt>proxy 协议</a>。
第二类负载均衡器可以通过简单的在保存于 Service 的 <code>service.spec.healthCheckNodePort</code> 字段上创建一个 HTTP 健康检查点来使用上面描述的特性。</p>
<h2 id=cleaning-up>Cleaning up</h2>
<p>删除服务：</p>
<pre><code class=language-console data-lang=console>$ kubectl delete svc -l app=source-ip-app
</code></pre><p>删除 Deployment、ReplicaSet 和 Pod：</p>
<pre><code class=language-console data-lang=console>$ kubectl delete deployment source-ip-app
</code></pre><h2 id=what-s-next>What's next</h2>
<ul>
<li>进一步学习 <a href=/zh/docs/concepts/services-networking/connect-applications-service/>通过 services 连接应用</a></li>
</ul>
</div>
</main>
</div>
</div>
<footer class=d-print-none>
<div class=footer__links>
<nav>
<a class=text-white href=/zh/docs/home/>主页</a>
<a class=text-white href=/zh/blog/>博客</a>
<a class=text-white href=/zh/training/>培训</a>
<a class=text-white href=/zh/partners/>合作伙伴</a>
<a class=text-white href=/zh/community/>社区</a>
<a class=text-white href=/zh/case-studies/>案例分析</a>
</nav>
</div>
<div class=container-fluid>
<div class=row>
<div class="col-6 col-sm-2 text-xs-center order-sm-2">
<ul class="list-inline mb-0">
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="User mailing list" aria-label="User mailing list">
<a class=text-white target=_blank href=https://discuss.kubernetes.io>
<i class="fa fa-envelope"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Twitter aria-label=Twitter>
<a class=text-white target=_blank href=https://twitter.com/kubernetesio>
<i class="fab fa-twitter"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Calendar aria-label=Calendar>
<a class=text-white target=_blank href="https://calendar.google.com/calendar/embed?src=calendar%40kubernetes.io">
<i class="fas fa-calendar-alt"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Youtube aria-label=Youtube>
<a class=text-white target=_blank href=https://youtube.com/kubernetescommunity>
<i class="fab fa-youtube"></i>
</a>
</li>
</ul>
</div>
<div class="col-6 col-sm-2 text-right text-xs-center order-sm-3">
<ul class="list-inline mb-0">
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub>
<a class=text-white target=_blank href=https://github.com/kubernetes/kubernetes>
<i class="fab fa-github"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Slack aria-label=Slack>
<a class=text-white target=_blank href=https://slack.k8s.io>
<i class="fab fa-slack"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Contribute aria-label=Contribute>
<a class=text-white target=_blank href=https://git.k8s.io/community/contributors/guide>
<i class="fas fa-edit"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Stack Overflow" aria-label="Stack Overflow">
<a class=text-white target=_blank href=https://stackoverflow.com/questions/tagged/kubernetes>
<i class="fab fa-stack-overflow"></i>
</a>
</li>
</ul>
</div>
<div class="col-12 col-sm-8 text-center order-sm-2">
<small class=text-white>&copy; 2023 The Kubernetes Authors | Documentation Distributed under <a href=https://git.k8s.io/website/LICENSE class=light-text>CC BY 4.0</a></small>
<br>
<small class=text-white>Copyright &copy; 2023 The Linux Foundation &reg;. All rights reserved. The Linux Foundation has registered trademarks and uses trademarks. For a list of trademarks of The Linux Foundation, please see our <a href=https://www.linuxfoundation.org/trademark-usage class=light-text>Trademark Usage page</a></small>
<br>
<small class=text-white>ICP license: 京ICP备17074266号-3</small>
</div>
</div>
</div>
</footer>
</div>
<script src=/js/popper-1.14.3.min.js integrity=sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49 crossorigin=anonymous></script>
<script src=/js/bootstrap-4.3.1.min.js integrity=sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM crossorigin=anonymous></script>
<script src=/js/main.min.40616251a9b6e4b689e7769be0340661efa4d7ebb73f957404e963e135b4ed52.js integrity="sha256-QGFiUam25LaJ53ab4DQGYe+k1+u3P5V0BOlj4TW07VI=" crossorigin=anonymous></script>
</body>
</html>