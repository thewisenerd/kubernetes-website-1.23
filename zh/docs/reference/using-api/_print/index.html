<!doctype html><html lang=zh class=no-js>
<head>
<meta name=ROBOTS content="NOINDEX, NOFOLLOW">
<script async src="https://www.googletagmanager.com/gtag/js?id=G-JPP6RFM2BP"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-JPP6RFM2BP')</script>
<link rel=alternate hreflang=en href=https://kubernetes.io/docs/reference/using-api/>
<link rel=alternate hreflang=ko href=https://kubernetes.io/ko/docs/reference/using-api/>
<link rel=alternate hreflang=ja href=https://kubernetes.io/ja/docs/reference/using-api/>
<link rel=alternate hreflang=fr href=https://kubernetes.io/fr/docs/reference/using-api/>
<link rel=alternate hreflang=de href=https://kubernetes.io/de/docs/reference/using-api/>
<link rel=alternate hreflang=es href=https://kubernetes.io/es/docs/reference/using-api/>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=generator content="Hugo 0.87.0">
<link rel=canonical type=text/html href=https://kubernetes.io/zh/docs/reference/using-api/>
<link rel="shortcut icon" type=image/png href=/images/favicon.png>
<link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180>
<link rel=manifest href=/manifest.webmanifest>
<link rel=apple-touch-icon href=/images/kubernetes-192x192.png>
<title>API 概述 | Kubernetes</title><meta property="og:title" content="API 概述">
<meta property="og:description" content="生产级别的容器编排系统">
<meta property="og:type" content="website">
<meta property="og:url" content="https://kubernetes.io/zh/docs/reference/using-api/"><meta property="og:site_name" content="Kubernetes">
<meta itemprop=name content="API 概述">
<meta itemprop=description content="生产级别的容器编排系统"><meta name=twitter:card content="summary">
<meta name=twitter:title content="API 概述">
<meta name=twitter:description content="生产级别的容器编排系统">
<link href=/scss/main.css rel=stylesheet>
<script src=/js/jquery-3.3.1.min.js integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin=anonymous></script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","url":"https://kubernetes.io","logo":"https://kubernetes.io/images/favicon.png"}</script>
<meta name=theme-color content="#326ce5">
<link rel=stylesheet href=/css/feature-states.css>
<meta name=description content="本文提供了 Kubernetes API 的参考信息。
REST API 是 Kubernetes 的基本结构。 所有操作和组件之间的通信及外部用户命令都是调用 API 服务器处理的 REST API。 因此，Kubernetes 平台视一切皆为 API 对象， 且它们在 API 中有相应的定义。
Kubernetes API 参考列 出了 Kubernetes v1.23 版本的 API。
如需了解一般背景信息，请查阅 Kubernetes API。 Kubernetes API 控制访问描述了客户端如何 向 Kubernetes API 服务器进行身份认证以及他们的请求如何被鉴权。
API 版本控制 JSON 和 Protobuf 序列化模式遵循相同的模式更改原则。 以下描述涵盖了这两种格式。
API 版本控制和软件版本控制是间接相关的。 API 和发布版本控制提案 描述了 API 版本控制和软件版本控制间的关系。
不同的 API 版本代表着不同的稳定性和支持级别。 你可以在 API 变更文档 中查看到更多的不同级别的判定标准。
下面是每个级别的摘要：
 Alpha:  版本名称包含 alpha（例如，v1alpha1）。 软件可能会有 Bug。启用某个特性可能会暴露出 Bug。 某些特性可能默认禁用。 对某个特性的支持可能会随时被删除，恕不另行通知。 API 可能在以后的软件版本中以不兼容的方式更改，恕不另行通知。 由于缺陷风险增加和缺乏长期支持，建议该软件仅用于短期测试集群。      Beta:">
<meta property="og:description" content="本文提供了 Kubernetes API 的参考信息。
REST API 是 Kubernetes 的基本结构。 所有操作和组件之间的通信及外部用户命令都是调用 API 服务器处理的 REST API。 因此，Kubernetes 平台视一切皆为 API 对象， 且它们在 API 中有相应的定义。
Kubernetes API 参考列 出了 Kubernetes v1.23 版本的 API。
如需了解一般背景信息，请查阅 Kubernetes API。 Kubernetes API 控制访问描述了客户端如何 向 Kubernetes API 服务器进行身份认证以及他们的请求如何被鉴权。
API 版本控制 JSON 和 Protobuf 序列化模式遵循相同的模式更改原则。 以下描述涵盖了这两种格式。
API 版本控制和软件版本控制是间接相关的。 API 和发布版本控制提案 描述了 API 版本控制和软件版本控制间的关系。
不同的 API 版本代表着不同的稳定性和支持级别。 你可以在 API 变更文档 中查看到更多的不同级别的判定标准。
下面是每个级别的摘要：
 Alpha:  版本名称包含 alpha（例如，v1alpha1）。 软件可能会有 Bug。启用某个特性可能会暴露出 Bug。 某些特性可能默认禁用。 对某个特性的支持可能会随时被删除，恕不另行通知。 API 可能在以后的软件版本中以不兼容的方式更改，恕不另行通知。 由于缺陷风险增加和缺乏长期支持，建议该软件仅用于短期测试集群。      Beta:">
<meta name=twitter:description content="本文提供了 Kubernetes API 的参考信息。
REST API 是 Kubernetes 的基本结构。 所有操作和组件之间的通信及外部用户命令都是调用 API 服务器处理的 REST API。 因此，Kubernetes 平台视一切皆为 API 对象， 且它们在 API 中有相应的定义。
Kubernetes API 参考列 出了 Kubernetes v1.23 版本的 API。
如需了解一般背景信息，请查阅 Kubernetes API。 Kubernetes API 控制访问描述了客户端如何 向 Kubernetes API 服务器进行身份认证以及他们的请求如何被鉴权。
API 版本控制 JSON 和 Protobuf 序列化模式遵循相同的模式更改原则。 以下描述涵盖了这两种格式。
API 版本控制和软件版本控制是间接相关的。 API 和发布版本控制提案 描述了 API 版本控制和软件版本控制间的关系。
不同的 API 版本代表着不同的稳定性和支持级别。 你可以在 API 变更文档 中查看到更多的不同级别的判定标准。
下面是每个级别的摘要：
 Alpha:  版本名称包含 alpha（例如，v1alpha1）。 软件可能会有 Bug。启用某个特性可能会暴露出 Bug。 某些特性可能默认禁用。 对某个特性的支持可能会随时被删除，恕不另行通知。 API 可能在以后的软件版本中以不兼容的方式更改，恕不另行通知。 由于缺陷风险增加和缺乏长期支持，建议该软件仅用于短期测试集群。      Beta:">
<meta property="og:url" content="https://kubernetes.io/zh/docs/reference/using-api/">
<meta property="og:title" content="API 概述">
<meta name=twitter:title content="API 概述">
<meta name=twitter:image content="https://kubernetes.io/images/favicon.png">
<meta name=twitter:image:alt content="Kubernetes">
<meta property="og:image" content="/images/kubernetes-horizontal-color.png">
<meta property="og:type" content="article">
<script src=/js/script.js></script>
</head>
<body class=td-section>
<header>
<nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar" data-auto-burger=primary>
<a class=navbar-brand href=/zh/></a>
<div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar>
<ul class="navbar-nav mt-2 mt-lg-0">
<li class="nav-item mr-2 mb-lg-0">
<a class="nav-link active" href=/zh/docs/>文档</a>
</li>
<li class="nav-item mr-2 mb-lg-0">
<a class=nav-link href=/zh/blog/>Kubernetes 博客</a>
</li>
<li class="nav-item mr-2 mb-lg-0">
<a class=nav-link href=/zh/training/>培训</a>
</li>
<li class="nav-item mr-2 mb-lg-0">
<a class=nav-link href=/zh/partners/>合作伙伴</a>
</li>
<li class="nav-item mr-2 mb-lg-0">
<a class=nav-link href=/zh/community/>社区</a>
</li>
<li class="nav-item mr-2 mb-lg-0">
<a class=nav-link href=/zh/case-studies/>案例分析</a>
</li>
<li class="nav-item dropdown">
<a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>
Versions
</a>
<div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink>
<a class=dropdown-item href=/releases>Release Information</a>
<a class=dropdown-item href=https://kubernetes.io/zh/docs/reference/using-api/>v1.27</a>
<a class=dropdown-item href=https://v1-26.docs.kubernetes.io/zh/docs/reference/using-api/>v1.26</a>
<a class=dropdown-item href=https://v1-25.docs.kubernetes.io/zh/docs/reference/using-api/>v1.25</a>
<a class=dropdown-item href=https://v1-24.docs.kubernetes.io/zh/docs/reference/using-api/>v1.24</a>
<a class=dropdown-item href=https://v1-23.docs.kubernetes.io/zh/docs/reference/using-api/>v1.23</a>
</div>
</li>
<li class="nav-item dropdown">
<a class="nav-link dropdown-toggle" href=# id=navbarDropdownMenuLink role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>
中文 Chinese
</a>
<div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink>
<a class=dropdown-item href=/docs/reference/using-api/>English</a>
<a class=dropdown-item href=/ko/docs/reference/using-api/>한국어 Korean</a>
<a class=dropdown-item href=/ja/docs/reference/using-api/>日本語 Japanese</a>
<a class=dropdown-item href=/fr/docs/reference/using-api/>Français</a>
<a class=dropdown-item href=/de/docs/reference/using-api/>Deutsch</a>
<a class=dropdown-item href=/es/docs/reference/using-api/>Español</a>
</div>
</li>
</ul>
</div>
<button id=hamburger onclick=kub.toggleMenu() data-auto-burger-exclude><div></div></button>
</nav>
</header>
<div class="container-fluid td-outer">
<div class=td-main>
<div class="row flex-xl-nowrap">
<main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main>
<div class=td-content>
<div class="pageinfo pageinfo-primary d-print-none">
<p>
这是本节的多页打印视图。
<a href=# onclick="return print(),!1">点击此处打印</a>.
</p><p>
<a href=/zh/docs/reference/using-api/>返回本页常规视图</a>.
</p>
</div>
<h1 class=title>API 概述</h1>
<ul>
<li>1: <a href=#pg-2b5428a2ff6f4831fd972ef50e12b3eb>Kubernetes API 概念</a></li>
<li>2: <a href=#pg-040d9484db673074f1b8ba3465be9d91>服务器端应用（Server-Side Apply）</a></li>
<li>3: <a href=#pg-79880efc25dc8cb3b6962ad78a964319>客户端库</a></li>
<li>4: <a href=#pg-8d2ce3e7b2223cda0ccd428f4d5ea24b>Kubernetes 弃用策略</a></li>
<li>5: <a href=#pg-2479c39af50fd55b898a3bcfb5988077>已弃用 API 的迁移指南</a></li>
<li>6: <a href=#pg-e4dbb59f8f23854d7b7d574e169923c4>Kubernetes API 健康端点</a></li>
</ul>
<div class=content>
<p>本文提供了 Kubernetes API 的参考信息。</p>
<p>REST API 是 Kubernetes 的基本结构。
所有操作和组件之间的通信及外部用户命令都是调用 API 服务器处理的 REST API。
因此，Kubernetes 平台视一切皆为 API 对象，
且它们在 <a href=/docs/reference/generated/kubernetes-api/v1.23/>API</a> 中有相应的定义。</p>
<p><a href=/docs/reference/generated/kubernetes-api/v1.23/>Kubernetes API 参考</a>列
出了 Kubernetes v1.23 版本的 API。</p>
<p>如需了解一般背景信息，请查阅 <a href=/zh/docs/concepts/overview/kubernetes-api/>Kubernetes API</a>。
<a href=/zh/docs/concepts/security/controlling-access/>Kubernetes API 控制访问</a>描述了客户端如何
向 Kubernetes API 服务器进行身份认证以及他们的请求如何被鉴权。</p>
<h2 id=api-版本控制>API 版本控制</h2>
<p>JSON 和 Protobuf 序列化模式遵循相同的模式更改原则。
以下描述涵盖了这两种格式。</p>
<p>API 版本控制和软件版本控制是间接相关的。
<a href=https://git.k8s.io/community/contributors/design-proposals/release/versioning.md>API 和发布版本控制提案</a>
描述了 API 版本控制和软件版本控制间的关系。</p>
<p>不同的 API 版本代表着不同的稳定性和支持级别。
你可以在 <a href=https://git.k8s.io/community/contributors/devel/sig-architecture/api_changes.md#alpha-beta-and-stable-versions>API 变更文档</a>
中查看到更多的不同级别的判定标准。</p>
<p>下面是每个级别的摘要：</p>
<ul>
<li>Alpha:
<ul>
<li>版本名称包含 <code>alpha</code>（例如，<code>v1alpha1</code>）。</li>
<li>软件可能会有 Bug。启用某个特性可能会暴露出 Bug。
某些特性可能默认禁用。</li>
<li>对某个特性的支持可能会随时被删除，恕不另行通知。</li>
<li>API 可能在以后的软件版本中以不兼容的方式更改，恕不另行通知。</li>
<li>由于缺陷风险增加和缺乏长期支持，建议该软件仅用于短期测试集群。</li>
</ul>
</li>
</ul>
<ul>
<li>
<p>Beta:</p>
<ul>
<li>版本名称包含 <code>beta</code> （例如， <code>v2beta3</code>）。</li>
<li>软件被很好的测试过。启用某个特性被认为是安全的。
特性默认开启。</li>
<li>尽管一些特性会发生细节上的变化，但它们将会被长期支持。</li>
</ul>
<ul>
<li>在随后的 Beta 版或稳定版中，对象的模式和（或）语义可能以不兼容的方式改变。
当这种情况发生时，将提供迁移说明。
模式更改可能需要删除、编辑和重建 API 对象。
编辑过程可能并不简单。
对于依赖此功能的应用程序，可能需要停机迁移。</li>
<li>该版本的软件不建议生产使用。
后续发布版本可能会有不兼容的变动。
如果你有多个集群可以独立升级，可以放宽这一限制。</li>
</ul>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 请试用测试版特性时并提供反馈。特性完成 Beta 阶段测试后，
就可能不会有太多的变更了。
</div>
</li>
</ul>
<ul>
<li>Stable:
<ul>
<li>版本名称如 <code>vX</code>，其中 <code>X</code> 为整数。</li>
<li>特性的稳定版本会出现在后续很多版本的发布软件中。</li>
</ul>
</li>
</ul><!--## API groups-->
<h2 id=api-组>API 组</h2>
<p><a href=https://git.k8s.io/community/contributors/design-proposals/api-machinery/api-group.md>API 组</a>
能够简化对 Kubernetes API 的扩展。
API 组信息出现在REST 路径中，也出现在序列化对象的 <code>apiVersion</code> 字段中。</p>
<p>以下是 Kubernetes 中的几个组：</p>
<ul>
<li><em>核心</em>（也叫 <em>legacy</em>）组的 REST 路径为 <code>/api/v1</code>。
核心组并不作为 <code>apiVersion</code> 字段的一部分，例如， <code>apiVersion: v1</code>。</li>
<li>指定的组位于 REST 路径 <code>/apis/$GROUP_NAME/$VERSION</code>，
并且使用 <code>apiVersion: $GROUP_NAME/$VERSION</code> （例如， <code>apiVersion: batch/v1</code>）。
你可以在 <a href=/docs/reference/generated/kubernetes-api/v1.23/#-strong-api-groups-strong->Kubernetes API 参考文档</a>
中查看全部的 API 组。</li>
</ul>
<h2 id=enabling-or-disabling>启用或禁用 API 组 </h2>
<p>资源和 API 组是在默认情况下被启用的。
你可以通过在 API 服务器上设置 <code>--runtime-config</code> 参数来启用或禁用它们。
<code>--runtime-config</code> 参数接受逗号分隔的 <code>&lt;key>[=&lt;value>]</code> 对，
来描述 API 服务器的运行时配置。如果省略了 <code>=&lt;value></code> 部分，那么视其指定为 <code>=true</code>。
例如：</p>
<ul>
<li>禁用 <code>batch/v1</code>， 对应参数设置 <code>--runtime-config=batch/v1=false</code></li>
<li>启用 <code>batch/v2alpha1</code>， 对应参数设置 <code>--runtime-config=batch/v2alpha1</code></li>
</ul>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 启用或禁用组或资源时，
你需要重启 API 服务器和控制器管理器来使 <code>--runtime-config</code> 生效。
</div>
<h2 id=持久化>持久化</h2>
<p>Kubernetes 通过 API 资源来将序列化的状态写到 <a class=glossary-tooltip title="etcd 是兼具一致性和高可用性的键值数据库，用作保存 Kubernetes 所有集群数据的后台数据库。" data-toggle=tooltip data-placement=top href=/zh/docs/tasks/administer-cluster/configure-upgrade-etcd/ target=_blank aria-label=etcd>etcd</a> 中存储。</p>
<h2 id=what-s-next>What's next</h2>
<ul>
<li>进一步了解 <a href=https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#api-conventions>API 惯例</a></li>
<li>阅读 <a href=https://github.com/kubernetes/community/blob/master/contributors/design-proposals/api-machinery/aggregated-api-servers.md>聚合器</a></li>
</ul>
</div>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-2b5428a2ff6f4831fd972ef50e12b3eb>1 - Kubernetes API 概念</h1>
<p>本页描述 Kubernetes API 的通用概念。</p>
<p>Kubernetes API 是基于资源的（RESTful）、通过 HTTP 提供的编程接口。
API 支持通过标准的 HTTP 动词（POST、PUT、PATCH、DELETE 和 GET）
检视、创建、更新和删除主要资源，为很多允许细粒度权限控制的对象提供子资源
（如将 Pod 绑定到节点上），并且出于便利性或效率考虑，支持并提供这些资源的
不同表示形式。
Kubernetes API 还通过 "watch" 和一致性的列表支持高效的资源变更通知，
从而允许其他组件对资源的状态进行高效的缓存和同步。</p>
<h2 id=standard-api-terminology>标准 API 术语 </h2>
<p>大多数 Kubernetes API 资源类型都是
<a href=/zh/docs/concepts/overview/working-with-objects/kubernetes-objects/#kubernetes-objects>对象</a>：
它们代表的是集群中某一概念的具体实例，例如一个 Pod 或名字空间。
为数不多的几个 API 资源类型是“虚拟的” - 它们通常代表的是操作而非对象本身，
例如访问权限检查（使用 POST 请求发送一个 JSON 编码的 <code>SubjectAccessReview</code>
负载到 <code>subjectaccessreviews</code> 资源）。
所有对象都有一个唯一的名字，以便支持幂等的创建和检视操作，不过如果虚拟资源类型
不可检视或者不要求幂等，可以不具有唯一的名字。</p>
<p>Kubernetes 一般会利用标准的 RESTful 术语来描述 API 概念：</p>
<ul>
<li><strong>资源类型（Resource Type）</strong> 是在 URL 中使用的名称（<code>pods</code>、<code>namespaces</code>、<code>services</code>）</li>
<li>所有资源类型都有具有一个 JSON 形式（其对象的模式定义）的具体表示，称作<strong>类别（Kind）</strong></li>
<li>某资源类型的实例的列表称作 <strong>集合（Collection）</strong></li>
<li>资源类型的单个实例被称作 <strong>资源（Resource）</strong></li>
</ul>
<p>所有资源类型要么是集群作用域的（<code>/apis/GROUP/VERSION/*</code>），要么是名字空间
作用域的（<code>/apis/GROUP/VERSION/namespaces/NAMESPACE/*</code>）。
名字空间作用域的资源类型会在其名字空间被删除时也被删除，并且对该资源类型的
访问是由定义在名字空间域中的授权检查来控制的。
下列路径用来检视集合和资源：</p>
<ul>
<li>集群作用域的资源：
<ul>
<li><code>GET /apis/GROUP/VERSION/RESOURCETYPE</code> - 返回指定资源类型的资源的集合</li>
<li><code>GET /apis/GROUP/VERSION/RESOURCETYPE/NAME</code> - 返回指定资源类型下名称为 NAME 的资源</li>
</ul>
</li>
<li>名字空间作用域的资源：
<ul>
<li><code>GET /apis/GROUP/VERSION/RESOURCETYPE</code> - 返回所有名字空间中指定资源类型的全部实例的集合</li>
<li><code>GET /apis/GROUP/VERSION/namespaces/NAMESPACE/RESOURCETYPE</code> - 返回名字空间 NAMESPACE 内给定资源类型的全部实例的集合</li>
<li><code>GET /apis/GROUP/VERSION/namespaces/NAMESPACE/RESOURCETYPE/NAME</code> - 返回名字空间 NAMESPACE 中给定资源类型的名称为 NAME 的实例</li>
</ul>
</li>
</ul>
<p>由于名字空间本身是一个集群作用域的资源类型，你可以通过 <code>GET /api/v1/namespaces/</code>
检视所有名字空间的列表，使用 <code>GET /api/v1/namespaces/NAME</code> 查看特定名字空间的
详细信息。</p>
<p>几乎所有对象资源类型都支持标准的 HTTP 动词 - GET、POST、PUT、PATCH 和 DELETE。
Kubernetes 使用术语 <strong>list</strong> 来描述返回资源集合的操作，以便与返回单个资源的、
通常称作 <strong>get</strong> 的操作相区分。</p>
<p>某些资源类型有一个或多个子资源（Sub-resource），表现为对应资源下面的子路径：</p>
<ul>
<li>集群作用域的子资源：<code>GET /apis/GROUP/VERSION/RESOURCETYPE/NAME/SUBRESOURCE</code></li>
<li>名字空间作用域的子资源：<code>GET /apis/GROUP/VERSION/namespaces/NAMESPACE/RESOURCETYPE/NAME/SUBRESOURCE</code></li>
</ul>
<p>取决于对象是什么，每个子资源所支持的动词有所不同 - 参见 API 文档以了解更多信息。
跨多个资源来访问其子资源是不可能的 - 如果需要这一能力，则通常意味着需要一种
新的虚拟资源类型了。</p>
<h2 id=efficient-detection-of-changes>高效检测变更 </h2>
<p>为了使客户端能够构造一个模型来表达集群的当前状态，所有 Kubernetes 对象资源类型
都需要支持一致的列表和一个称作 <strong>watch</strong> 的增量变更通知信源（feed）。
每个 Kubernetes 对象都有一个 <code>resourceVersion</code> 字段，代表该资源在下层数据库中
存储的版本。检视资源集合（名字空间作用域或集群作用域）时，服务器返回的响应
中会包含 <code>resourceVersion</code> 值，可用来向服务器发起 watch 请求。
服务器会返回所提供的 <code>resourceVersion</code> 之后发生的所有变更（创建、删除和更新）。
这使得客户端能够取回当前的状态并监视其变更，且不会错过任何变更事件。
客户端的监视连接被断开时，可以从最后返回的 <code>resourceVersion</code> 重启新的监视连接，
或者执行一个新的集合请求之后从头开始监视操作。
参阅<a href=#resource-versions>资源版本语义</a>以了解更多细节。</p>
<p>例如：</p>
<ol>
<li>
<p>列举给定名字空间中的所有 Pods：</p>
<pre><code class=language-console data-lang=console>GET /api/v1/namespaces/test/pods
---
200 OK
Content-Type: application/json
{
  &quot;kind&quot;: &quot;PodList&quot;,
  &quot;apiVersion&quot;: &quot;v1&quot;,
  &quot;metadata&quot;: {&quot;resourceVersion&quot;:&quot;10245&quot;},
  &quot;items&quot;: [...]
}
</code></pre></li>
</ol>
<ol start=2>
<li>
<p>从资源版本 10245 开始，以 JSON 对象的形式接收所有创建、删除或更新操作的通知：</p>
<pre><code class=language-console data-lang=console>GET /api/v1/namespaces/test/pods?watch=1&amp;resourceVersion=10245
---
200 OK
Transfer-Encoding: chunked
Content-Type: application/json

{
  &quot;type&quot;: &quot;ADDED&quot;,
  &quot;object&quot;: {&quot;kind&quot;: &quot;Pod&quot;, &quot;apiVersion&quot;: &quot;v1&quot;, &quot;metadata&quot;: {&quot;resourceVersion&quot;: &quot;10596&quot;, ...}, ...}
}
{
  &quot;type&quot;: &quot;MODIFIED&quot;,
  &quot;object&quot;: {&quot;kind&quot;: &quot;Pod&quot;, &quot;apiVersion&quot;: &quot;v1&quot;, &quot;metadata&quot;: {&quot;resourceVersion&quot;: &quot;11020&quot;, ...}, ...}
}
...
</code></pre></li>
</ol>
<p>给定的 Kubernetes 服务器只会保留一定的时间内发生的历史变更列表。
使用 etcd3 的集群默认保存过去 5 分钟内发生的变更。
当所请求的 watch 操作因为资源的历史版本不存在而失败，客户端必须能够处理
因此而返回的状态代码 <code>410 Gone</code>，清空其本地的缓存，重新执行 list 操作，
并基于新的 list 操作所返回的 <code>resourceVersion</code> 来开始新的 watch 操作。
大多数客户端库都能够提供某种形式的、包含此逻辑的工具。
（在 Go 语言客户端库中，这一设施称作 <code>Reflector</code>，位于
<code>k8s.io/client-go/cache</code> 包中。)</p>
<h3 id=Watch-bookmark>监视书签 </h3>
<p>为了处理历史窗口过短的问题，我们引入了 <code>bookmark（书签）</code> 监视事件的概念。
该事件是一种特殊事件，用来标示客户端所请求的、指定的 <code>resourceVersion</code> 之前
的所有变更都以被发送。该事件中返回的对象是所请求的资源类型，但其中仅包含
<code>resourceVersion</code> 字段，例如：</p>
<pre><code class=language-console data-lang=console>GET /api/v1/namespaces/test/pods?watch=1&amp;resourceVersion=10245&amp;allowWatchBookmarks=true
---
200 OK
Transfer-Encoding: chunked
Content-Type: application/json

{
  &quot;type&quot;: &quot;ADDED&quot;,
  &quot;object&quot;: {&quot;kind&quot;: &quot;Pod&quot;, &quot;apiVersion&quot;: &quot;v1&quot;, &quot;metadata&quot;: {&quot;resourceVersion&quot;: &quot;10596&quot;, ...}, ...}
}
...
{
  &quot;type&quot;: &quot;BOOKMARK&quot;,
  &quot;object&quot;: {&quot;kind&quot;: &quot;Pod&quot;, &quot;apiVersion&quot;: &quot;v1&quot;, &quot;metadata&quot;: {&quot;resourceVersion&quot;: &quot;12746&quot;} }
}
</code></pre>
<p>通过在 watch 请求中设置 <code>allowWatchBookmarks=true</code> 选项，可以请求 <code>bookmark</code>
事件，但是客户端不能假定服务器端会按某特定时间间隔返回书签事件，甚至也不能
假定服务器一定会发送 <code>bookmark</code> 事件。</p>
<h2 id=retrieving-large-results-sets-in-chunks>分块检视大体量结果 </h2>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.9 [beta]</code>
</div>
<p>在较大规模的集群中，检视某些资源类型的集合时可能会返回较大体量的响应数据，对
服务器和客户端都会造成影响。例如，某集群可能包含数万个 Pod，每个 Pod 的 JSON
编码都有 1-2 KB 的大小。返回所有名字空间的全部 Pod 时，其结果可能体量很大
（10-20 MB）且耗用大量的服务器资源。
从 Kubernetes 1.9 开始，服务器支持将单一的大体量集合请求分解成多个小数据块
同时还保证整个请求的一致性的能力。
各个数据块可以按顺序返回，进而降低请求的尺寸，允许面向用户的客户端以增量形式
呈现返回结果，改进系统响应效果。</p>
<p>为了用分块的形式返回一个列表，集合请求上可以设置两个新的参数 <code>limit</code> 和
<code>continue</code>，并且所有 list 操作的返回结果列表的 <code>metadata</code> 字段中会包含一个
新的 <code>continue</code> 字段。
客户端应该将 <code>limit</code> 设置为希望在每个数据块中收到的结果个数上限，而服务器则
会在结果中至多返回 <code>limit</code> 个资源并在集合中还有更多资源的时候包含一个
<code>continue</code> 值。客户端在下次请求时则可以将此 <code>continue</code> 值传递给服务器，
告知后者要从何处开始返回结果的下一个数据块。
通过重复这一操作直到服务器端返回空的 <code>continue</code> 值，客户端可以受到结果的
全集。</p>
<p>与 watch 操作类似，<code>continue</code> 令牌也会在很短的时间（默认为 5 分钟）内过期，
并在无法返回更多结果时返回 <code>410 Gone</code> 代码。
这时，客户端需要从头开始执行上述检视操作或者忽略 <code>limit</code> 参数。</p>
<p>例如，如果集群上有 1253 个 Pods，客户端希望每次收到包含至多 500 个 Pod 的
数据块，它应按下面的步骤来请求数据块：</p>
<ol>
<li>列举集群中所有 Pod，每次接收至多 500 个 Pods：</li>
</ol>
<pre><code class=language-console data-lang=console>GET /api/v1/pods?limit=500
---
200 OK
Content-Type: application/json

{
  &quot;kind&quot;: &quot;PodList&quot;,
  &quot;apiVersion&quot;: &quot;v1&quot;,
  &quot;metadata&quot;: {
    &quot;resourceVersion&quot;:&quot;10245&quot;,
    &quot;continue&quot;: &quot;ENCODED_CONTINUE_TOKEN&quot;,
    ...
  },
  &quot;items&quot;: [...] // returns pods 1-500
}
</code></pre>
<ol start=2>
<li>继续前面的调用，返回下一组 500 个 Pods：</li>
</ol>
<pre><code class=language-console data-lang=console>GET /api/v1/pods?limit=500&amp;continue=ENCODED_CONTINUE_TOKEN
---
200 OK
Content-Type: application/json

{
  &quot;kind&quot;: &quot;PodList&quot;,
  &quot;apiVersion&quot;: &quot;v1&quot;,
  &quot;metadata&quot;: {
    &quot;resourceVersion&quot;:&quot;10245&quot;,
    &quot;continue&quot;: &quot;ENCODED_CONTINUE_TOKEN_2&quot;,
    ...
  },
  &quot;items&quot;: [...] // returns pods 501-1000
}
</code></pre>
<ol start=3>
<li>继续前面的调用，返回最后 253 个 Pods：</li>
</ol>
<pre><code class=language-console data-lang=console>GET /api/v1/pods?limit=500&amp;continue=ENCODED_CONTINUE_TOKEN_2
---
200 OK
Content-Type: application/json

{
  &quot;kind&quot;: &quot;PodList&quot;,
  &quot;apiVersion&quot;: &quot;v1&quot;,
  &quot;metadata&quot;: {
    &quot;resourceVersion&quot;:&quot;10245&quot;,
    &quot;continue&quot;: &quot;&quot;, // continue token is empty because we have reached the end of the list
    ...
  },
  &quot;items&quot;: [...] // returns pods 1001-1253
}
</code></pre>
<p>注意 list 操作的 <code>resourceVersion</code> 在每个请求中都设置的是同一个数值，
这表明服务器要向我们展示一个一致的 Pods 快照视图。
在版本 <code>10245</code> 之后创建、更新或删除的 Pods 都不会显示出来，除非用户发出
list 请求时不指定 <code>continue</code> 令牌。
这一设计使得客户端能够将较大的响应切分为较小的数据块，且能够对较大的集合
执行监视动作而不会错失任何更新事件。</p>
<h2 id=receiving-resources-as-tables>以表格形式接收资源 </h2>
<p><code>kubectl get</code> 命令的输出是一个包含一个或多个资源的简单表格形式。
过去，客户端需要重复 <code>kubectl</code> 中所实现的表格输出和描述输出逻辑，以执行
简单的对象列表操作。
这一方法在处理某些对象时，需要引入不容忽视的逻辑。
此外，<a href=/zh/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/>API 聚合</a>
和<a href=/zh/docs/concepts/extend-kubernetes/api-extension/custom-resources/>定制资源</a>
所提供的资源类型都是编译时不可预知的。这意味着，客户端必须针对无法
识别的类型提供通用的实现逻辑。</p>
<p>为了避免上述各种潜在的局限性，客户端可以请求服务器端返回对象的表格（Table）
表现形式，从而将打印输出的特定细节委托给服务器。
Kubernetes API 实现标准的 HTTP 内容类型（Content Type）协商：为 <code>GET</code> 调用
传入一个值为 <code>application/json;as=Table;g=meta.k8s.io;v=v1beta1</code> 的 <code>Accept</code>
头部即可请求服务器以 Table 的内容类型返回对象。</p>
<p>例如，以 Table 格式列举集群中所有 Pods：</p>
<pre><code class=language-console data-lang=console>GET /api/v1/pods
Accept: application/json;as=Table;g=meta.k8s.io;v=v1beta1
---
200 OK
Content-Type: application/json

{
    &quot;kind&quot;: &quot;Table&quot;,
    &quot;apiVersion&quot;: &quot;meta.k8s.io/v1beta1&quot;,
    ...
    &quot;columnDefinitions&quot;: [
        ...
    ]
}
</code></pre>
<p>对于在服务器上不存在定制的 Table 定义的 API 资源类型而言，服务器会返回
一个默认的 Table 响应，其中包含资源的 <code>name</code> 和 <code>creationTimestamp</code> 字段。</p>
<pre><code class=language-console data-lang=console>GET /apis/crd.example.com/v1alpha1/namespaces/default/resources
---
200 OK
Content-Type: application/json
...

{
    &quot;kind&quot;: &quot;Table&quot;,
    &quot;apiVersion&quot;: &quot;meta.k8s.io/v1beta1&quot;,
    ...
    &quot;columnDefinitions&quot;: [
        {
            &quot;name&quot;: &quot;Name&quot;,
            &quot;type&quot;: &quot;string&quot;,
            ...
        },
        {
            &quot;name&quot;: &quot;Created At&quot;,
            &quot;type&quot;: &quot;date&quot;,
            ...
        }
    ]
}
</code></pre>
<p><code>kube-apiserver</code> 从 1.10 版本开始提供 Table 响应。
因此，并非所有 API 资源类型都支持 Table 响应，尤其是使用客户端访问较老的集群时。
如果客户端需要能够处理所有资源类型，或者有可能需要与较老的集群交互，
则需要在其 <code>Accept</code> 头部设定多个内容类型值，以便可以回退到非表格形式的 JSON
表示。</p>
<pre><code>Accept: application/json;as=Table;g=meta.k8s.io;v=v1beta1, application/json
</code></pre>
<h2 id=alternate-representations-of-resources>资源的其他表示形式 </h2>
<p>默认情况下，Kubernetes 返回 JSON 序列化的的对象并设定内容类型为
<code>application/json</code>。这是 API 的默认序列化格式。
不过，客户端也可出于大规模环境中更佳性能的需求而请求对象的更为高效的 Protobuf
表现形式。
Kubernetes API 实现了标准的 HTTP 内容类型协商：为 <code>GET</code> 调用传递一个 <code>Accept</code>
头部来请求服务器以所指定的内容类型返回对象，同时在通过 <code>PUT</code> 或 <code>POST</code> 调用
向服务器发送 Protobuf 格式的对象时提供 <code>Content-Type</code> 头部。
服务器会能够支持所请求的格式时返回 <code>Content-Type</code> 头部，并在所提供的内容类型
不合法时返回 <code>406 Not acceptable（无法接受）</code> 错误。</p>
<p>请参阅 API 文档了解每个 API 所支持的内容类型。</p>
<p>例如：</p>
<ol>
<li>以 Protobuf 格式列举集群上的所有 Pods：</li>
</ol>
<pre><code class=language-console data-lang=console>GET /api/v1/pods
Accept: application/vnd.kubernetes.protobuf
---
200 OK
Content-Type: application/vnd.kubernetes.protobuf

... binary encoded PodList object
</code></pre>
<ol start=2>
<li>通过向服务器发送 Protobuf 编码的数据创建 Pod，但请求以 JSON 形式接收响应：</li>
</ol>
<pre><code class=language-console data-lang=console>POST /api/v1/namespaces/test/pods
Content-Type: application/vnd.kubernetes.protobuf
Accept: application/json
... binary encoded Pod object
---
200 OK
Content-Type: application/json

{
  &quot;kind&quot;: &quot;Pod&quot;,
  &quot;apiVersion&quot;: &quot;v1&quot;,
  ...
}
</code></pre>
<p>并非所有 API 资源类型都支持 Protobuf，尤其是那些通过定制资源定义（CRD）或通过
API 扩展而加入的资源。如果客户端必须能够处理所有资源类型，则应在其 <code>Accept</code>
头部指定多种内容类型以便可以回退到 JSON 格式：</p>
<pre><code class=language-console data-lang=console>Accept: application/vnd.kubernetes.protobuf, application/json
</code></pre>
<h3 id=protobuf-encoding>Protobuf encoding</h3>
<p>Kubernetes 使用封套形式来对 Protobuf 响应进行编码。
封套外层由 4 个字节的特殊数字开头，便于从磁盘文件或 etcd 中辩识 Protobuf
格式的（而不是 JSON）数据。
接下来存放的是 Protobuf 编码的封套消息，其中描述下层对象的编码和类型，最后
才是对象本身。</p>
<p>封套格式如下：</p>
<pre><code class=language-console data-lang=console>四个字节的特殊数字前缀：
  字节 0-3: &quot;k8s\x00&quot; [0x6b, 0x38, 0x73, 0x00]

使用下面 IDL 来编码的 Protobuf 消息：
  message Unknown {
    // typeMeta 应该包含 &quot;kind&quot; 和 &quot;apiVersion&quot; 的字符串值，就像
    // 对应的 JSON 对象中所设置的那样
    optional TypeMeta typeMeta = 1;

    // raw 中将保存用 protobuf 序列化的完整对象。
    // 参阅客户端库中为指定 kind 所作的 protobuf 定义
    optional bytes raw = 2;

    // contentEncoding 用于 raw 数据的编码格式。未设置此值意味着没有特殊编码。
    optional string contentEncoding = 3;

    // contentType 包含 raw 数据所采用的序列化方法。
    // 未设置此值意味着  application/vnd.kubernetes.protobuf，且通常被忽略
    optional string contentType = 4;
  }

  message TypeMeta {
    // apiVersion 是 type 对应的组名/版本
    optional string apiVersion = 1;
    // kind 是对象模式定义的名称。此对象应该存在一个 protobuf 定义。
    optional string kind = 2;
  }
</code></pre>
<p>收到 <code>application/vnd.kubernetes.protobuf</code> 格式响应的客户端在响应与预期的前缀
不匹配时应该拒绝响应，因为将来的版本可能需要以某种不兼容的方式更改序列化格式，
并且这种更改是通过变更前缀完成的。</p>
<h2 id=resource-deletion>资源删除 </h2>
<p>资源删除要经过两个阶段：1) 终止（finalization），和 2）去除。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;ConfigMap&#34;</span>,
  <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;v1&#34;</span>,
  <span style=color:green;font-weight:700>&#34;metadata&#34;</span>: {
    <span style=color:green;font-weight:700>&#34;finalizers&#34;</span>: {<span style=color:green;font-weight:700>&#34;url.io/neat-finalization&#34;</span>, <span style=color:green;font-weight:700>&#34;other-url.io/my-finalizer&#34;</span>},
    <span style=color:green;font-weight:700>&#34;deletionTimestamp&#34;</span>: <span>nil</span>,
  }
}
</code></pre></div>
<p>当客户端首先删除某资源时，其 <code>.metadata.deletionTimestamp</code> 会被设置为当前时间。
一旦 <code>.metadata.deletionTimestamp</code> 被设置，则对终结器（finalizers）执行动作
的外部控制器就可以在任何时候、以任何顺序执行其清理工作。
这里不强调顺序是因为很可能带来 <code>.metadata.finalizers</code> 被锁定的风险。
<code>.metadata.finalizers</code> 是一个共享的字段，任何具有相关权限的主体都可以对其
执行重排序的操作。如果终结器列表要按顺序处理，则很可能导致负责列表中第一个
终结器的组件要等待负责列表中排序靠后的终结器的组件的信号（可能是字段值变更、
外部系统或者其他形式），从而导致死锁行为。
在不对终结器顺序作强制要求的情况下，终结器可以自行排序，且不会因为其在列表
中的顺序而引入任何不稳定因素。</p>
<p>当最后一个终结器也被移除时，资源才真正从 etcd 中移除。</p>
<h2 id=single-resource-api>单个资源 API </h2>
<p>API 动词 GET、CREATE、UPDATE、PATCH、DELETE 和 PROXY 仅支持单个资源。
这些支持单一资源的动词不支持以有序或无序列表甚或事务的形式同时提交给
多个资源。
包括 kubectl 在内的客户端将解析资源的列表，并执行单一资源的 API 请求。</p>
<p>API 动词 LIST 和 WATCH 支持获取多个资源，而 DELETECOLLECTION 支持删除多个
资源。</p>
<h2 id=dry-run>试运行 </h2>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.18 [stable]</code>
</div>
<p>修改性质的动词（<code>POST</code>、<code>PUT</code>、<code>PATCH</code> 和 <code>DELETE</code>）可以支持 <em>试运行（dry
run）</em> 模式的请求。试运行模式可帮助通过典型的请求阶段（准入控制链、合法性
检查、合并冲突）来评估请求，只是最终的对象不会写入存储。请求的响应主体与
非试运行模式下的响应尽可能接近。系统会保证试运行模式的请求不会被写入到存储
中，也不会产生其他副作用。</p>
<h3 id=make-a-dry-run-request>发起试运行请求 </h3>
<p>通过设置 <code>dryRun</code> 查询参数可以触发试运行模式。此参数是一个字符串，以枚举值
的形式工作且可接受的值只有：</p>
<ul>
<li>
<p><code>All</code>：每个阶段被会正常运行，除了最后的存储阶段。准入控制器会被运行来检查请求
是否合法，变更性（Mutating）控制器会变更请求，<code>PATCH</code> 请求也会触发合并操作，
对象字段的默认值也会被设置，且基于模式定义的合法性检查也会被执行。
所生成的变更不会被写入到下层的持久性存储中，但本来会写入到数据库中的最终对象
会和正常的状态代码一起被返回给用户。如果请求会触发准入控制器而该准入控制器
带有一定的副作用，则请求会失败而不是冒险产生不希望的副作用。
所有的内置准入控制器插件都支持试运行模式。此外，准入控制 Webhook 也可在其
<a href=/docs/reference/generated/kubernetes-api/v1.23/#webhook-v1beta1-admissionregistration-k8s-io>配置对象</a>
中通过将 <code>sideEffects</code> 字段设置为 "None" 来声明自身不会产生副作用。
如果某 Webhook 确实会产生副作用，那么 <code>sideEffects</code> 字段应该设置为 "NoneOnDryRun"，
并且 Webhook 应该被更改以支持 AdmissionReview 中的 <code>dryRun</code> 字段，从而避免
在试运行时产生副作用。</p>
</li>
<li>
<p>空字符串（也即默认值）：保留默认的修改行为。</p>
</li>
</ul>
<p>例如：</p>
<pre><code class=language-console data-lang=console>POST /api/v1/namespaces/test/pods?dryRun=All
Content-Type: application/json
Accept: application/json
</code></pre>
<p>响应会与非试运行模式请求的响应看起来相同，只是某些生成字段的值可能会不同。</p>
<h3 id=dry-run-authorization>试运行的授权 </h3>
<p>试运行和非试运行请求的鉴权是完全相同的。因此，要发起一个试运行请求，用户必须
被授权执行非试运行请求。</p>
<p>例如，要在 Deployment 对象上试运行 <code>PATCH</code> 操作，你必须具有对 Deployment 执行
<code>PATCH</code> 操作的访问权限，如下面的 RBAC 规则所示：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;extensions&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;apps&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;deployments&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;patch&#34;</span>]<span style=color:#bbb>
</span></code></pre></div>
<p>参阅<a href=/zh/docs/reference/access-authn-authz/authorization/>鉴权概述</a>以了解鉴权细节。</p>
<h3 id=generated-values>生成的值 </h3>
<p>对象的某些值通常是在对象被写入数据库之前生成的。很重要的一点是不要依赖试运行
请求为这些字段所设置的值，因为试运行模式下所得到的这些值与真实请求所获得的
值很可能不同。这类字段有：</p>
<ul>
<li><code>name</code>：如果设置了 <code>generateName</code> 字段，则 <code>name</code> 会获得一个唯一的随机名称</li>
<li><code>creationTimestamp</code>/<code>deletionTimestamp</code>：记录对象的创建/删除时间</li>
<li><code>UID</code>：唯一性标识对象，取值随机生成（非确定性）</li>
<li><code>resourceVersion</code>： 跟踪对象的持久化（存储）版本</li>
<li>变更性准入控制器所设置的字段</li>
<li>对于 <code>Service</code> 资源：<code>kube-apiserver</code> 为 <code>v1.Service</code> 对象分配的端口和 IP</li>
</ul>
<h2 id=server-side-apply>服务器端应用 </h2>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.16 [beta]</code>
</div>
<p>从 Kubernetes v1.18 开始，可以启用<a href=/zh/docs/reference/using-api/server-side-apply/>服务器端应用</a>功能
特性，启用该特性后，控制面会跟踪所有新创建的对象的托管字段。服务器端应用提供了一种简洁的模式来管理字段冲突，提供服务器端的 <code>Apply</code> 和 <code>Update</code> 操作，并取代了
<code>kubectl apply</code> 的客户端功能。有关该特性的详细描述，请参见<a href=/zh/docs/reference/using-api/server-side-apply/>服务器端应用</a>章节</p>
<h2 id=resource-versions>资源版本 </h2>
<p>资源版本采用字符串来表达，用来标示对象的服务器端内部版本。
客户端可以使用资源版本来判定对象是否被更改，或者在读取、列举或监视资源时
用来表达数据一致性需求。
客户端必需将资源版本视为不透明的对象，将其原封不动地传递回服务器端。
例如，客户端一定不能假定资源版本是某种数值标识，也不可以对两个资源版本值
进行比较看其是否相同（也就是不可以比较两个版本值以判断其中一个比另一个
大或小）。</p>
<h3 id=resourceVersion-in-metadata><code>metadata</code> 中的 <code>resourceVersion</code> </h3>
<p>客户端可以在资源中看到资源版本信息，这里的资源包括从服务器返回的 Watch 事件
以及 list 操作响应：</p>
<p><a href=/docs/reference/generated/kubernetes-api/v1.23/#objectmeta-v1-meta>v1.meta/ObjectMeta</a> - 资源
的 <code>metadata.resourceVersion</code> 值标明该实例上次被更改时的资源版本。</p>
<p><a href=/docs/reference/generated/kubernetes-api/v1.23/#listmeta-v1-meta>v1.meta/ListMeta</a> - 资源集合
（即 list 操作的响应）的 <code>metadata.resourceVersion</code> 所标明的是 list 响应被构造
时的资源版本。</p>
<h3 id=the-resourceversion-parameter><code>resourceVersion</code> 参数 </h3>
<p>GET、LIST 和 WATCH 操作都支持 <code>resourceVersion</code> 参数。</p>
<p>参数的具体含义取决于所执行的操作和所给的 <code>resourceVersion</code> 值：</p>
<p>对于 GET 和 LIST 而言，资源版本的语义为：</p>
<p><strong>GET：</strong></p>
<table>
<thead>
<tr>
<th>resourceVersion 未设置</th>
<th>resourceVersion="0"</th>
<th>resourceVersion="&lt;非零值>"</th>
</tr>
</thead>
<tbody>
<tr>
<td>最新版本</td>
<td>任何版本</td>
<td>不老于给定版本</td>
</tr>
</tbody>
</table>
<p><strong>LIST：</strong></p>
<p>v1.19 及以上版本的 API 服务器支持 <code>resourceVersionMatch</code> 参数，用以确定如何对
LIST 调用应用 resourceVersion 值。
强烈建议在为 LIST 调用设置了 <code>resourceVersion</code> 时也设置 <code>resourceVersionMatch</code>。
如果 <code>resourceVersion</code> 未设置，则 <code>resourceVersionMatch</code> 是不允许设置的。
为了向后兼容，客户端必须能够容忍服务器在某些场景下忽略 <code>resourceVersionMatch</code> 的行为：</p>
<ul>
<li>
<p>当设置 <code>resourceVersionMatch=NotOlderThan</code> 且指定了 <code>limit</code> 时，客户端必须能够
处理 HTTP 410 "Gone" 响应。例如，客户端可以使用更新一点的 <code>resourceVersion</code>
来重试，或者回退到 <code>resourceVersion=""</code> （即允许返回任何版本）。</p>
</li>
<li>
<p>当设置了 <code>resourceVersionMatch=Exact</code> 且未指定 <code>limit</code> 时，客户端必须验证
响应数据中 <code>ListMeta</code> 的 <code>resourceVersion</code> 与所请求的 <code>resourceVersion</code> 匹配，
并处理二者可能不匹配的情况。例如，客户端可以重试设置了 <code>limit</code> 的请求。</p>
</li>
</ul>
<p>除非你对一致性有着非常强烈的需求，使用 <code>resourceVersionMatch=NotOlderThan</code>
同时为 <code>resourceVersion</code> 设定一个已知值是优选的交互方式，因为与不设置
<code>resourceVersion</code> 和 <code>resourceVersionMatch</code> 相比，这种配置可以取得更好的
集群性能和可扩缩性。后者需要提供带票选能力的读操作。</p>
<table><caption style=display:none>list 操作的 resourceVersionMatch 与分页参数</caption>
<thead>
<tr>
<th>resourceVersionMatch 参数</th>
<th>分页参数</th>
<th>resourceVersion 未设置</th>
<th>resourceVersion="0"</th>
<th>resourceVersion="&lt;非零值>"</th>
</tr>
</thead>
<tbody>
<tr>
<td>resourceVersionMatch 未设置</td>
<td>limit 未设置</td>
<td>最新版本</td>
<td>任意版本</td>
<td>不老于指定版本</td>
</tr>
<tr>
<td>resourceVersionMatch 未设置</td>
<td>limit=&lt;n>, continue 未设置</td>
<td>最新版本</td>
<td>任意版本</td>
<td>精确匹配</td>
</tr>
<tr>
<td>resourceVersionMatch 未设置</td>
<td>limit=&lt;n>, continue=&lt;token></td>
<td>从 token 开始、精确匹配</td>
<td>非法请求，视为从 token 开始、精确匹配</td>
<td>非法请求，返回 HTTP <code>400 Bad Request</code></td>
</tr>
<tr>
<td>resourceVersionMatch=Exact [1]</td>
<td>limit 未设置</td>
<td>非法请求</td>
<td>非法请求</td>
<td>精确匹配</td>
</tr>
<tr>
<td>resourceVersionMatch=Exact [1]</td>
<td>limit=&lt;n>, continue 未设置</td>
<td>非法请求</td>
<td>非法请求</td>
<td>精确匹配</td>
</tr>
<tr>
<td>resourceVersionMatch=NotOlderThan [1]</td>
<td>limit 未设置</td>
<td>非法请求</td>
<td>任意版本</td>
<td>不老于指定版本</td>
</tr>
<tr>
<td>resourceVersionMatch=NotOlderThan [1]</td>
<td>limit=&lt;n>, continue 未设置</td>
<td>非法请求</td>
<td>任意版本</td>
<td>不老于指定版本</td>
</tr>
</tbody>
</table>
<p><strong>脚注：</strong></p>
<p>[1] 如果服务器无法正确处理 <code>resourceVersionMatch</code> 参数，其行为与未设置该参数相同。
</small></p>
<p>GET 和 LIST 操作的语义含义如下：</p>
<ul>
<li><strong>最新版本：</strong> 返回资源版本为最新的数据。所返回的数据必须一致
（通过票选读操作从 etcd 中取出）。</li>
<li><strong>任意版本：</strong> 返回任意资源版本的数据。优选最新可用的资源版本，不过不能保证
强一致性；返回的数据可能是任何资源版本的。请求返回的数据有可能是客户端以前
看到过的很老的资源版本。尤其在某些高可用配置环境中，网络分区或者高速缓存
未被更新等状态都可能导致这种状况。不能容忍这种不一致性的客户端不应采用此
语义。</li>
</ul>
<ul>
<li>
<p><strong>不老于指定版本：</strong> 返回至少比所提供的 <code>resourceVersion</code> 还要新的数据。
优选最新的可用数据，不过最终提供的可能是不老于所给 <code>resourceVersion</code> 的任何版本。
对于发给能够正确处理 <code>resourceVersionMatch</code> 参数的服务器的 LIST 请求，此语义
保证 <code>ListMeta</code> 中的 <code>resourceVersion</code> 不老于请求的 <code>resourceVersion</code>，不过
不对列表条目之 <code>ObjectMeta</code> 的 <code>resourceVersion</code> 提供任何保证。
这是因为 <code>ObjectMeta.resourceVersion</code> 所跟踪的是列表条目对象上次更新的时间，
而不是对象被返回时是否是最新。</p>
</li>
<li>
<p><strong>确定版本：</strong> 返回精确匹配所给资源版本的数据。如果所指定的 resourceVersion
的数据不可用，服务器会响应 HTTP 410 "Gone"。
对于发送给能够正确处理 <code>resourceVersionMatch</code> 参数的服务器的 LIST 请求而言，
此语义会保证 ListMeta 中的 <code>resourceVersion</code> 与所请求的 <code>resourceVersion</code>
匹配， 不过不对列表条目之 <code>ObjectMeta</code> 的 <code>resourceVersion</code> 提供任何保证。
这是因为 <code>ObjectMeta.resourceVersion</code> 所跟踪的是列表条目对象上次更新的时间，
而不是对象被返回时是否是最新。</p>
</li>
<li>
<p><strong>Continue 令牌、精确匹配：</strong> 返回原先带分页参数的 LIST 调用中指定的资源版本的数据。
在最初的带分页参数的 LIST 调用之后，所有分页式的 LIST 调用都使用所返回的 Continue
令牌来跟踪最初提供的资源版本，</p>
</li>
</ul>
<p>对于 WATCH 操作而言，资源版本的语义如下：</p>
<p><strong>WATCH：</strong></p>
<table><caption style=display:none>watch 操作的 resourceVersion 设置</caption>
<thead>
<tr>
<th>resourceVersion 未设置</th>
<th>resourceVersion="0"</th>
<th>resourceVersion="&lt;非零值>"</th>
</tr>
</thead>
<tbody>
<tr>
<td>读取状态并从最新版本开始</td>
<td>读取状态并从任意版本开始</td>
<td>从指定版本开始</td>
</tr>
</tbody>
</table>
<p>WATCH 操作语义的含义如下：</p>
<ul>
<li><strong>读取状态并从最新版本开始：</strong> 从最新的资源版本开始 WATCH 操作。这里的
最新版本必须是一致的（即通过票选读操作从 etcd 中取出）。为了建立初始状态，
WATCH 首先会处理一组合成的 "Added" 事件，这些事件涵盖在初始资源版本中存在
的所有资源实例。
所有后续的 WATCH 事件都是关于 WATCH 开始时所处资源版本之后发生的变更。</li>
</ul>
<ul>
<li><strong>读取状态并从任意版本开始：</strong> 警告：通过这种方式初始化的 WATCH 操作可能会
返回任何状态的停滞数据。请在使用此语义之前执行复核，并在可能的情况下采用其他
语义。此语义会从任意资源版本开始执行 WATCH 操作，优选最新的可用的资源版本，
不过不是必须的；采用任何资源版本作为起始版本都是被允许的。
WATCH 操作有可能起始于客户端已经观测到的很老的版本。在高可用配置环境中，因为
网络分裂或者高速缓存未及时更新的原因都会造成此现象。
如果客户端不能容忍这种不一致性，就不要使用此语义来启动 WATCH 操作。
为了建立初始状态，WATCH 首先会处理一组合成的 "Added" 事件，这些事件涵盖在
初始资源版本中存在的所有资源实例。
所有后续的 WATCH 事件都是关于 WATCH 开始时所处资源版本之后发生的变更。</li>
</ul>
<ul>
<li><strong>从指定版本开始：</strong> 从某确切资源版本开始执行 WATCH 操作。WATCH 事件都是
关于 WATCH 开始时所处资源版本之后发生的变更。与前面两种语义不同，WATCH 操作
开始的时候不会生成或处理为所提供资源版本合成的 "Added" 事件。
我们假定客户端既然能够提供确切资源版本，就应该已经拥有了起始资源版本对应的初始状态。</li>
</ul>
<h3 id=410-gone-responses>"410 Gone" 响应 </h3>
<p>服务器不需要提供所有老的资源版本，在客户端请求的是早于服务器端所保留版本的
<code>resourceVersion</code> 时，可以返回 HTTP <code>410 (Gone)</code> 状态码。
客户端必须能够容忍 <code>410 (Gone)</code> 响应。
参阅<a href=#efficient-detection-of-changes>高效检测变更</a>以了解如何在监测资源时
处理 <code>410 (Gone)</code> 响应。</p>
<p>如果所请求的 <code>resourceVersion</code> 超出了可应用的 <code>limit</code>，那么取决于请求是否
是通过高速缓存来满足的，API 服务器可能会返回一个 <code>410 Gone</code> HTTP 响应。</p>
<h3 id=unavailable-resource-versions>不可用的资源版本 </h3>
<p>服务器不必未无法识别的资源版本提供服务。针对无法识别的资源版本的 LIST 和 GET 请求
可能会短暂等待，以期资源版本可用。如果所给的资源版本在一定的时间段内仍未变得
可用，服务器应该超时并返回 <code>504 (Gateway Timeout)</code>，且可在响应中添加
<code>Retry-After</code> 响应头部字段，标明客户端在再次尝试之前应该等待多少秒钟。
目前，<code>kube-apiserver</code> 也能使用 <code>Too large resource version（资源版本过高）</code>
消息来标识这类响应。针对某无法识别的资源版本的 WATCH 操作可能会无限期
（直到请求超时）地等待下去，直到资源版本可用。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-040d9484db673074f1b8ba3465be9d91>2 - 服务器端应用（Server-Side Apply）</h1>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.22 [stable]</code>
</div>
<h2 id=introduction>简介</h2>
<p>服务器端应用协助用户、控制器通过声明式配置的方式管理他们的资源。
客户端可以发送完整描述的目标（A fully specified intent），
声明式地创建和/或修改
<a href=/zh/docs/concepts/overview/working-with-objects/kubernetes-objects/>对象</a>。</p>
<p>一个完整描述的目标并不是一个完整的对象，仅包括能体现用户意图的字段和值。
该目标（intent）可以用来创建一个新对象，
也可以通过服务器来实现与现有对象的<a href=#merge-strategy>合并</a>。</p>
<p>系统支持多个应用者（appliers）在同一个对象上开展协作。</p>
<p>“<a href=#field-management>字段管理（field management）</a>”机制追踪对象字段的变化。
当一个字段值改变时，其所有权从当前管理器（manager）转移到施加变更的管理器。
当尝试将新配置应用到一个对象时，如果字段有不同的值，且由其他管理器管理，
将会引发<a href=#conflicts>冲突</a>。
冲突引发警告信号：此操作可能抹掉其他协作者的修改。
冲突可以被刻意忽略，这种情况下，值将会被改写，所有权也会发生转移。</p>
<p>当你从配置文件中删除一个字段，然后应用这个配置文件，
这将触发服务端应用检查此字段是否还被其他字段管理器拥有。
如果没有，那就从活动对象中删除该字段；如果有，那就重置为默认值。
该规则同样适用于 list 或 map 项目。</p>
<p>服务器端应用既是原有 <code>kubectl apply</code> 的替代品，
也是控制器发布自身变化的一个简化机制。</p>
<p>如果你启用了服务器端应用，控制平面就会跟踪被所有新创建对象管理的字段。</p>
<h2 id=field-management>字段管理</h2>
<p>相对于通过 <code>kubectl</code> 管理的注解 <code>last-applied</code>，
服务器端应用使用了一种更具声明式特点的方法：
它持续的跟踪用户的字段管理，而不仅仅是最后一次的执行状态。
这就意味着，作为服务器端应用的一个副作用，
关于用哪一个字段管理器负责管理对象中的哪个字段的这类信息，都要对外界开放了。</p>
<p>用户管理字段这件事，在服务器端应用的场景中，意味着用户依赖并期望字段的值不要改变。
最后一次对字段值做出断言的用户将被记录到当前字段管理器。
这可以通过发送 <code>POST</code>、 <code>PUT</code>、
或非应用（non-apply）方式的 <code>PATCH</code> 等命令来修改字段值的方式实现，
或通过把字段放在配置文件中，然后发送到服务器端应用的服务端点的方式实现。
当使用服务器端应用，尝试着去改变一个被其他人管理的字段，
会导致请求被拒绝（在没有设置强制执行时，参见<a href=#conflicts>冲突</a>）。</p>
<p>如果两个或以上的应用者均把同一个字段设置为相同值，他们将共享此字段的所有权。
后续任何改变共享字段值的尝试，不管由那个应用者发起，都会导致冲突。
共享字段的所有者可以放弃字段的所有权，这只需从配置文件中删除该字段即可。</p>
<p>字段管理的信息存储在 <code>managedFields</code> 字段中，该字段是对象的
<a href=/docs/reference/generated/kubernetes-api/v1.23/#objectmeta-v1-meta><code>metadata</code></a>
中的一部分。</p>
<p>服务器端应用创建对象的简单示例如下：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-cm<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>test-label</span>:<span style=color:#bbb> </span>test<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>managedFields</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>manager</span>:<span style=color:#bbb> </span>kubectl<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>operation</span>:<span style=color:#bbb> </span>Apply<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>time</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2010-10-10T0:00:00Z&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>fieldsType</span>:<span style=color:#bbb> </span>FieldsV1<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>fieldsV1</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>f:metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>f:labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>f:test-label</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>f:data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>f:key</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>some value<span style=color:#bbb>
</span></code></pre></div>
<p>上述对象在 <code>metadata.managedFields</code> 中包含了唯一的管理器。
管理器由管理实体自身的基本信息组成，比如操作类型、API 版本、以及它管理的字段。</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 该字段由 API 服务器管理，用户不应该改动它。
</div>
<p>不过，执行 <code>Update</code> 操作修改 <code>metadata.managedFields</code> 也是可实现的。
强烈不鼓励这么做，但当发生如下情况时，
比如 <code>managedFields</code> 进入不一致的状态（显然不应该发生这种情况），
这么做也是一个合理的尝试。</p>
<p><code>managedFields</code> 的格式在
<a href=/docs/reference/generated/kubernetes-api/v1.23/#fieldsv1-v1-meta>API</a>
文档中描述。</p>
<h2 id=conflicts>冲突</h2>
<p>冲突是一种特定的错误状态，
发生在执行 <code>Apply</code> 改变一个字段，而恰巧该字段被其他用户声明过主权时。
这可以防止一个应用者不小心覆盖掉其他用户设置的值。
冲突发生时，应用者有三种办法来解决它：</p>
<ul>
<li>
<p><strong>覆盖前值，成为唯一的管理器：</strong> 如果打算覆盖该值（或应用者是一个自动化部件，比如控制器），
应用者应该设置查询参数 <code>force</code> 为 true，然后再发送一次请求。
这将强制操作成功，改变字段的值，从所有其他管理器的 managedFields 条目中删除指定字段。</p>
</li>
<li>
<p><strong>不覆盖前值，放弃管理权：</strong> 如果应用者不再关注该字段的值，
可以从配置文件中删掉它，再重新发送请求。
这就保持了原值不变，并从 managedFields 的应用者条目中删除该字段。</p>
</li>
<li>
<p><strong>不覆盖前值，成为共享的管理器：</strong> 如果应用者仍然关注字段值，并不想覆盖它，
他们可以在配置文件中把字段的值改为和服务器对象一样，再重新发送请求。
这样在不改变字段值的前提下，
就实现了字段管理被应用者和所有声明了管理权的其他的字段管理器共享。</p>
</li>
</ul>
<h2 id=managers>管理器</h2>
<p>管理器识别出正在修改对象的工作流程（在冲突时尤其有用）,
管理器可以通过修改请求的参数 <code>fieldManager</code> 指定。
虽然 kubectl 默认发往 <code>kubectl</code> 服务端点，但它则请求到应用的服务端点（apply endpoint）。
对于其他的更新，它默认的是从用户代理计算得来。</p>
<h2 id=apply-and-update>应用和更新</h2>
<p>此特性涉及两类操作，分别是 <code>Apply</code>
（内容类型为 <code>application/apply-patch+yaml</code> 的 <code>PATCH</code> 请求）
和 <code>Update</code> （所有修改对象的其他操作）。
这两类操作都会更新字段 <code>managedFields</code>，但行为表现有一点不同。</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> <p>不管你提交的是 JSON 数据还是 YAML 数据，
都要使用 <code>application/apply-patch+yaml</code> 作为 <code>Content-Type</code> 的值。</p>
<p>所有的 JSON 文档 都是合法的 YAML。</p>
</div>
<p>例如，在冲突发生的时候，只有 <code>apply</code> 操作失败，而 <code>update</code> 则不会。
此外，<code>apply</code> 操作必须通过提供一个 <code>fieldManager</code> 查询参数来标识自身，
而此查询参数对于 <code>update</code> 操作则是可选的。
最后，当使用 <code>apply</code> 命令时，你不能在应用中的对象中持有 <code>managedFields</code>。</p>
<p>一个包含多个管理器的对象，示例如下：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-cm<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>test-label</span>:<span style=color:#bbb> </span>test<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>managedFields</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>manager</span>:<span style=color:#bbb> </span>kubectl<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>operation</span>:<span style=color:#bbb> </span>Apply<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>fields</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>f:metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>f:labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>f:test-label</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>manager</span>:<span style=color:#bbb> </span>kube-controller-manager<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>operation</span>:<span style=color:#bbb> </span>Update<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>time</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;2019-03-30T16:00:00.000Z&#39;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>fields</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>f:data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>f:key</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>new value<span style=color:#bbb>
</span></code></pre></div>
<p>在这个例子中，
第二个操作被管理器 <code>kube-controller-manager</code> 以 <code>Update</code> 的方式运行。
此 <code>update</code> 更改 data 字段的值，
并使得字段管理器被改为 <code>kube-controller-manager</code>。</p>
<p>如果把 <code>update</code> 操作改为 <code>Apply</code>，那就会因为所有权冲突的原因，导致操作失败。</p>
<h2 id=merge-strategy>合并策略</h2>
<p>由服务器端应用实现的合并策略，提供了一个总体更稳定的对象生命周期。
服务器端应用试图依据负责管理它们的主体来合并字段，而不是根据值来否决。
这么做是为了多个主体可以更新同一个对象，且不会引起意外的相互干扰。</p>
<p>当用户发送一个“完整描述的目标”对象到服务器端应用的服务端点，
服务器会将它和活动对象做一次合并，如果两者中有重复定义的值，那就以配置文件的为准。
如果配置文件中的项目集合不是此用户上一次操作项目的超集，
所有缺少的、没有其他应用者管理的项目会被删除。
关于合并时用来做决策的对象规格的更多信息，参见
<a href=https://sigs.k8s.io/structured-merge-diff>sigs.k8s.io/structured-merge-diff</a>.</p>
<p>Kubernetes 1.16 和 1.17 中添加了一些标记，
允许 API 开发人员描述由 list、map、和 structs 支持的合并策略。
这些标记可应用到相应类型的对象，在 Go 文件或在
<a href=/docs/reference/generated/kubernetes-api/v1.23#jsonschemaprops-v1-apiextensions-k8s-io>CRD</a>
的 OpenAPI 的模式中定义：</p>
<table>
<thead>
<tr>
<th>Golang 标记</th>
<th>OpenAPI extension</th>
<th>可接受的值</th>
<th>描述</th>
<th>引入版本</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>//+listType</code></td>
<td><code>x-kubernetes-list-type</code></td>
<td><code>atomic</code>/<code>set</code>/<code>map</code></td>
<td>适用于 list。<code>set</code> 适用于仅包含标量元素的列表。这些元素必须是不重复的。<code>map</code> 仅适用于包含嵌套类型的列表。列表中的键（参见 <code>listMapKey</code>）不可以重复。<code>atomic</code> 适用于任何类型的列表。如果配置为 <code>atomic</code>，则合并时整个列表会被替换掉。任何时候，只有一个管理器负责管理指定列表。如果配置为 <code>set</code> 或 <code>map</code>，不同的管理器也可以分开管理条目。</td>
<td>1.16</td>
</tr>
<tr>
<td><code>//+listMapKey</code></td>
<td><code>x-kubernetes-list-map-keys</code></td>
<td>字段名称的列表，例如，<code>["port", "protocol"]</code></td>
<td>仅当 <code>+listType=map</code> 时适用。取值为字段名称的列表，这些字段值的组合能够唯一标识列表中的条目。尽管可以存在多个键，<code>listMapKey</code> 是单数的，这是因为键名需要在 Go 类型中各自独立指定。键字段必须是标量。</td>
<td>1.16</td>
</tr>
<tr>
<td><code>//+mapType</code></td>
<td><code>x-kubernetes-map-type</code></td>
<td><code>atomic</code>/<code>granular</code></td>
<td>适用于 map。 <code>atomic</code> 指 map 只能被单个的管理器整个的替换。 <code>granular</code> 指 map 支持多个管理器各自更新自己的字段。</td>
<td>1.17</td>
</tr>
<tr>
<td><code>//+structType</code></td>
<td><code>x-kubernetes-map-type</code></td>
<td><code>atomic</code>/<code>granular</code></td>
<td>适用于 structs；否则就像 <code>//+mapType</code> 有相同的用法和 openapi 注释.</td>
<td>1.17</td>
</tr>
</tbody>
</table>
<p>若未指定 <code>listType</code>，API 服务器将 <code>patchMergeStrategy=merge</code> 标记解释为
<code>listType=map</code> 并且视对应的 <code>patchMergeKey</code> 标记为 <code>listMapKey</code> 取值。</p>
<p><code>atomic</code> 列表类型是递归的。</p>
<p>这些标记都是用源代码注释的方式给出的，不必作为字段标签（tag）再重复。</p>
<h3 id=compatibility-across-toplogy-changes>拓扑变化时的兼容性 </h3>
<p>在极少的情况下，CRD 或者内置类型的作者可能希望更改其资源中的某个字段的
拓扑配置，同时又不提升版本号。
通过升级集群或者更新 CRD 来更改类型的拓扑信息与更新现有对象的结果不同。
变更的类型有两种：一种是将字段从 <code>map</code>/<code>set</code>/<code>granular</code> 更改为 <code>atomic</code>，
另一种是做逆向改变。</p>
<p>当 <code>listType</code>、<code>mapType</code> 或 <code>structType</code> 从 <code>map</code>/<code>set</code>/<code>granular</code> 改为
<code>atomic</code> 时，现有对象的整个列表、映射或结构的属主都会变为这些类型的
元素之一的属主。这意味着，对这些对象的进一步变更会引发冲突。</p>
<p>当一个列表、映射或结构从 <code>atomic</code> 改为 <code>map</code>/<code>set</code>/<code>granular</code> 之一
时，API 服务器无法推导这些字段的新的属主。因此，当对象的这些字段
再次被更新时不会引发冲突。出于这一原因，不建议将某类型从 <code>atomic</code> 改为
<code>map</code>/<code>set</code>/<code>granular</code>。</p>
<p>以下面的自定义资源为例：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>example.com/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Foo<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo-sample<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>managedFields</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>manager</span>:<span style=color:#bbb> </span>manager-one<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>operation</span>:<span style=color:#bbb> </span>Apply<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>example.com/v1<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>fields</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>f:spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>f:data</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>key1</span>:<span style=color:#bbb> </span>val1<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>key2</span>:<span style=color:#bbb> </span>val2<span style=color:#bbb>
</span></code></pre></div>
<p>在 <code>spec.data</code> 从 <code>atomic</code> 改为 <code>granular</code> 之前，<code>manager-one</code> 是
<code>spec.data</code> 字段及其所包含字段（<code>key1</code> 和 <code>key2</code>）的属主。
当对应的 CRD 被更改，使得 <code>spec.data</code> 变为 <code>granular</code> 拓扑时，
<code>manager-one</code> 继续拥有顶层字段 <code>spec.data</code>（这意味着其他管理者想
删除名为 <code>data</code> 的映射而不引起冲突是不可能的），但不再拥有
<code>key1</code> 和 <code>key2</code>。因此，其他管理者可以在不引起冲突的情况下更改
或删除这些字段。</p>
<h3 id=custom-resources>自定义资源</h3>
<p>默认情况下，服务器端应用把自定义资源看做非结构化数据。
所有的键值（keys）就像 struct 的字段一样被处理，
所有的 list 被认为是原子性的。</p>
<p>如果自定义资源定义（Custom Resource Definition，CRD）定义了一个
<a href=/docs/reference/generated/kubernetes-api/v1.23#jsonschemaprops-v1-apiextensions-k8s-io>模式</a>，
它包含类似以前“合并策略”章节中定义过的注解，
这些注解将在合并此类型的对象时使用。</p>
<h2 id=using-server-side-apply-in-controller>在控制器中使用服务器端应用</h2>
<p>控制器的开发人员可以把服务器端应用作为简化控制器的更新逻辑的方式。
读-改-写 和/或 patch 的主要区别如下所示：</p>
<ul>
<li>应用的对象必须包含控制器关注的所有字段。</li>
<li>对于在控制器没有执行过应用操作之前就已经存在的字段，不能删除。
（控制器在这种用例环境下，依然可以发送一个 PATCH/UPDATE）</li>
<li>对象不必事先读取，<code>resourceVersion</code> 不必指定。</li>
</ul>
<p>强烈推荐：设置控制器在冲突时强制执行，这是因为冲突发生时，它们没有其他解决方案或措施。</p>
<h2 id=transferring-ownership>转移所有权</h2>
<p>除了通过<a href=#conflicts>冲突解决方案</a>提供的并发控制，
服务器端应用提供了一些协作方式来将字段所有权从用户转移到控制器。</p>
<p>最好通过例子来说明这一点。
让我们来看看，在使用 Horizo​​ntalPodAutoscaler 资源和与之配套的控制器，
且开启了 Deployment 的自动水平扩展功能之后，
怎么安全的将 <code>replicas</code> 字段的所有权从用户转移到控制器。</p>
<p>假设用户定义了 Deployment，且 <code>replicas</code> 字段已经设置为期望的值：</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/application/ssa/nginx-deployment.yaml download=application/ssa/nginx-deployment.yaml><code>application/ssa/nginx-deployment.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('application-ssa-nginx-deployment-yaml')" title="Copy application/ssa/nginx-deployment.yaml to clipboard">
</img>
</div>
<div class=includecode id=application-ssa-nginx-deployment-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-deployment<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.14.2<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>并且，用户使用服务器端应用，像这样创建 Deployment：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/application/ssa/nginx-deployment.yaml --server-side
</code></pre></div>
<p>然后，为 Deployment 启用 HPA，例如：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl autoscale deployment nginx-deployment --cpu-percent<span style=color:#666>=</span><span style=color:#666>50</span> --min<span style=color:#666>=</span><span style=color:#666>1</span> --max<span style=color:#666>=</span><span style=color:#666>10</span>
</code></pre></div>
<p>现在，用户希望从他们的配置中删除 <code>replicas</code>，所以他们总是和 HPA 控制器冲突。
然而，这里存在一个竟态：
在 HPA 需要调整 <code>replicas</code> 之前会有一个时间窗口，
如果在 HPA 写入字段成为所有者之前，用户删除了<code>replicas</code>，
那 API 服务器就会把 <code>replicas</code> 的值设为 1， 也就是默认值。
这不是用户希望发生的事情，即使是暂时的。</p>
<p>这里有两个解决方案：</p>
<ul>
<li>（基本操作）把 <code>replicas</code> 留在配置文件中；当 HPA 最终写入那个字段，
系统基于此事件告诉用户：冲突发生了。在这个时间点，可以安全的删除配置文件。</li>
<li>（高级操作）然而，如果用户不想等待，比如他们想为合作伙伴保持集群清晰，
那他们就可以执行以下步骤，安全的从配置文件中删除 <code>replicas</code>。</li>
</ul>
<p>首先，用户新定义一个只包含 <code>replicas</code> 字段的配置文件：</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/application/ssa/nginx-deployment-replicas-only.yaml download=application/ssa/nginx-deployment-replicas-only.yaml><code>application/ssa/nginx-deployment-replicas-only.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('application-ssa-nginx-deployment-replicas-only-yaml')" title="Copy application/ssa/nginx-deployment-replicas-only.yaml to clipboard">
</img>
</div>
<div class=includecode id=application-ssa-nginx-deployment-replicas-only-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-deployment<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>用户使用名为 <code>handover-to-hpa</code> 的字段管理器，应用此配置文件。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/application/ssa/nginx-deployment-replicas-only.yaml <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --server-side --field-manager<span style=color:#666>=</span>handover-to-hpa <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --validate<span style=color:#666>=</span><span style=color:#a2f>false</span>
</code></pre></div>
<p>如果应用操作和 HPA 控制器产生冲突，那什么都不做。
冲突表明控制器在更早的流程中已经对字段声明过所有权。</p>
<p>在此时间点，用户可以从配置文件中删除 <code>replicas</code> 。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/application/ssa/nginx-deployment-no-replicas.yaml download=application/ssa/nginx-deployment-no-replicas.yaml><code>application/ssa/nginx-deployment-no-replicas.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('application-ssa-nginx-deployment-no-replicas-yaml')" title="Copy application/ssa/nginx-deployment-no-replicas.yaml to clipboard">
</img>
</div>
<div class=includecode id=application-ssa-nginx-deployment-no-replicas-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-deployment<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.14.2<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>注意，只要 HPA 控制器为 <code>replicas</code> 设置了一个新值，
该临时字段管理器将不再拥有任何字段，会被自动删除。
这里不需要执行清理工作。</p>
<h3 id=transferring-ownership-between-users>在用户之间转移所有权</h3>
<p>通过在配置文件中把一个字段设置为相同的值，用户可以在他们之间转移字段的所有权，
从而共享了字段的所有权。
当用户共享了字段的所有权，任何一个用户可以从他的配置文件中删除该字段，
并应用该变更，从而放弃所有权，并实现了所有权向其他用户的转移。</p>
<h2 id=comparison-with-client-side-apply>与客户端应用的对比</h2>
<p>由服务器端应用实现的冲突检测和解决方案的一个结果就是，
应用者总是可以在本地状态中得到最新的字段值。
如果得不到最新值，下次执行应用操作时就会发生冲突。
解决冲突三个选项的任意一个都会保证：此应用过的配置文件是服务器上对象字段的最新子集。</p>
<p>这和客户端应用（Client Side Apply） 不同，如果有其他用户覆盖了此值，
过期的值被留在了应用者本地的配置文件中。
除非用户更新了特定字段，此字段才会准确，
应用者没有途径去了解下一次应用操作是否会覆盖其他用户的修改。</p>
<p>另一个区别是使用客户端应用的应用者不能改变他们正在使用的 API 版本，但服务器端应用支持这个场景。</p>
<h2 id=upgrading-from-client-side-apply-to-server-side-apply>从客户端应用升级到服务器端应用</h2>
<p>客户端应用方式时，用户使用 <code>kubectl apply</code> 管理资源，
可以通过使用下面标记切换为使用服务器端应用。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply --server-side <span style=color:#666>[</span>--dry-run<span style=color:#666>=</span>server<span style=color:#666>]</span>
</code></pre></div>
<p>默认情况下，对象的字段管理从客户端应用方式迁移到 kubectl 触发的服务器端应用时，不会发生冲突。</p>
<div class="alert alert-warning caution callout" role=alert>
<strong>Caution:</strong> <p>保持注解 <code>last-applied-configuration</code> 是最新的。
从注解能推断出字段是由客户端应用管理的。
任何没有被客户端应用管理的字段将引发冲突。</p>
<p>举例说明，比如你在客户端应用之后，
使用 <code>kubectl scale</code> 去更新 <code>replicas</code> 字段，
可是该字段并没有被客户端应用所拥有，
在执行 <code>kubectl apply --server-side</code> 时就会产生冲突。</p>
</div>
<p>此操作以 <code>kubectl</code> 作为字段管理器来应用到服务器端应用。
作为例外，可以指定一个不同的、非默认字段管理器停止的这种行为，如下面的例子所示。
对于 kubectl 触发的服务器端应用，默认的字段管理器是 <code>kubectl</code>。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply --server-side --field-manager<span style=color:#666>=</span>my-manager <span style=color:#666>[</span>--dry-run<span style=color:#666>=</span>server<span style=color:#666>]</span>
</code></pre></div>
<h2 id=downgrading-from-server-side-apply-to-client-side-apply>从服务器端应用降级到客户端应用</h2>
<p>如果你用 <code>kubectl apply --server-side</code> 管理一个资源，
可以直接用 <code>kubectl apply</code> 命令将其降级为客户端应用。</p>
<p>降级之所以可行，这是因为 <code>kubectl server-side apply</code>
会保存最新的 <code>last-applied-configuration</code> 注解。</p>
<p>此操作以 <code>kubectl</code> 作为字段管理器应用到服务器端应用。
作为例外，可以指定一个不同的、非默认字段管理器停止这种行为，如下面的例子所示。
对于 kubectl 触发的服务器端应用，默认的字段管理器是 <code>kubectl</code>。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply --server-side --field-manager<span style=color:#666>=</span>my-manager <span style=color:#666>[</span>--dry-run<span style=color:#666>=</span>server<span style=color:#666>]</span>
</code></pre></div>
<h2 id=api-endpoint>API 端点</h2>
<p>启用了服务器端应用特性之后，
<code>PATCH</code> 服务端点接受额外的内容类型 <code>application/apply-patch+yaml</code>。
服务器端应用的用户就可以把 YAMl 格式的
部分定义对象（partially specified objects）发送到此端点。
当一个配置文件被应用时，它应该包含所有体现你意图的字段。</p>
<h2 id=clearing-managedfields>清除 ManagedFields</h2>
<p>可以从对象中剥离所有 managedField，
实现方法是通过使用 <code>MergePatch</code>、 <code>StrategicMergePatch</code>、
<code>JSONPatch</code>、 <code>Update</code>、以及所有的非应用方式的操作来覆盖它。
这可以通过用空条目覆盖 managedFields 字段的方式实现。以下是两个示例：</p>
<pre><code class=language-console data-lang=console>PATCH /api/v1/namespaces/default/configmaps/example-cm
Content-Type: application/merge-patch+json
Accept: application/json
Data: {&quot;metadata&quot;:{&quot;managedFields&quot;: [{}]}}
</code></pre><pre><code class=language-console data-lang=console>PATCH /api/v1/namespaces/default/configmaps/example-cm
Content-Type: application/json-patch+json
Accept: application/json
Data: [{&quot;op&quot;: &quot;replace&quot;, &quot;path&quot;: &quot;/metadata/managedFields&quot;, &quot;value&quot;: [{}]}]
</code></pre>
<p>这一操作将用只包含一个空条目的列表覆写 managedFields，
来实现从对象中整个的去除 managedFields。
注意，只把 managedFields 设置为空列表并不会重置字段。
这么做是有目的的，所以 managedFields 将永远不会被与该字段无关的客户删除。</p>
<p>在重置操作结合 managedFields 以外其他字段更改的场景中，
将导致 managedFields 首先被重置，其他改变被押后处理。
其结果是，应用者取得了同一个请求中所有字段的所有权。</p>
<div class="alert alert-warning caution callout" role=alert>
<strong>Caution:</strong> 对于不接受资源对象类型的子资源（sub-resources），
服务器端应用不能正确地跟踪其所有权。
如果你对这样的子资源使用服务器端应用，变更的字段将不会被跟踪。
</div>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-79880efc25dc8cb3b6962ad78a964319>3 - 客户端库</h1>
<p>本页面包含基于各种编程语言使用 Kubernetes API 的客户端库概述。</p>
<p>在使用 <a href=/zh/docs/reference/using-api/>Kubernetes REST API</a> 编写应用程序时，
您并不需要自己实现 API 调用和 “请求/响应” 类型。
您可以根据自己的编程语言需要选择使用合适的客户端库。</p>
<p>客户端库通常为您处理诸如身份验证之类的常见任务。
如果 API 客户端在 Kubernetes 集群中运行，大多数客户端库可以发现并使用 Kubernetes 服务帐户进行身份验证，
或者能够理解 <a href=/zh/docs/tasks/access-application-cluster/configure-access-multiple-clusters/>kubeconfig 文件</a>
格式来读取凭据和 API 服务器地址。</p>
<h2 id=officially-supported-kubernetes-client-libraries>官方支持的 Kubernetes 客户端库 </h2>
<p>以下客户端库由 <a href=https://github.com/kubernetes/community/tree/master/sig-api-machinery>Kubernetes SIG API Machinery</a> 正式维护。</p>
<table>
<thead>
<tr>
<th>语言</th>
<th>客户端库</th>
<th>样例程序</th>
</tr>
</thead>
<tbody>
<tr>
<td>dotnet</td>
<td><a href=https://github.com/kubernetes-client/csharp>github.com/kubernetes-client/csharp</a></td>
<td><a href=https://github.com/kubernetes-client/csharp/tree/master/examples/simple>浏览</a></td>
</tr>
<tr>
<td>Go</td>
<td><a href=https://github.com/kubernetes/client-go/>github.com/kubernetes/client-go/</a></td>
<td><a href=https://github.com/kubernetes/client-go/tree/master/examples>浏览</a></td>
</tr>
<tr>
<td>Haskell</td>
<td><a href=https://github.com/kubernetes-client/haskell>github.com/kubernetes-client/haskell</a></td>
<td><a href=https://github.com/kubernetes-client/haskell/tree/master/kubernetes-client/example>浏览</a></td>
</tr>
<tr>
<td>Java</td>
<td><a href=https://github.com/kubernetes-client/java/>github.com/kubernetes-client/java</a></td>
<td><a href=https://github.com/kubernetes-client/java#installation>浏览</a></td>
</tr>
<tr>
<td>JavaScript</td>
<td><a href=https://github.com/kubernetes-client/javascript>github.com/kubernetes-client/javascript</a></td>
<td><a href=https://github.com/kubernetes-client/javascript/tree/master/examples>浏览</a></td>
</tr>
<tr>
<td>Python</td>
<td><a href=https://github.com/kubernetes-client/python/>github.com/kubernetes-client/python/</a></td>
<td><a href=https://github.com/kubernetes-client/python/tree/master/examples>浏览</a></td>
</tr>
</tbody>
</table>
<h2 id=community-maintained-client-libraries>社区维护的客户端库 </h2>
<div class="alert alert-secondary callout third-party-content" role=alert><strong>Note:</strong>
This section links to third party projects that provide functionality required by Kubernetes. The Kubernetes project authors aren't responsible for these projects, which are listed alphabetically. To add a project to this list, read the <a href=/docs/contribute/style/content-guide/#third-party-content>content guide</a> before submitting a change. <a href=#third-party-content-disclaimer>More information.</a></div>
<p>以下 Kubernetes API 客户端库是由社区，而非 Kubernetes 团队支持、维护的。</p>
<table>
<thead>
<tr>
<th>语言</th>
<th>客户端库</th>
</tr>
</thead>
<tbody>
<tr>
<td>Clojure</td>
<td><a href=https://github.com/yanatan16/clj-kubernetes-api>github.com/yanatan16/clj-kubernetes-api</a></td>
</tr>
<tr>
<td>DotNet</td>
<td><a href=https://github.com/tonnyeremin/kubernetes_gen>github.com/tonnyeremin/kubernetes_gen</a></td>
</tr>
<tr>
<td>DotNet (RestSharp)</td>
<td><a href=https://github.com/masroorhasan/Kubernetes.DotNet>github.com/masroorhasan/Kubernetes.DotNet</a></td>
</tr>
<tr>
<td>Elixir</td>
<td><a href=https://github.com/obmarg/kazan/>github.com/obmarg/kazan</a></td>
</tr>
<tr>
<td>Elixir</td>
<td><a href=https://github.com/coryodaniel/k8s>github.com/coryodaniel/k8s</a></td>
</tr>
<tr>
<td>Go</td>
<td><a href=https://github.com/ericchiang/k8s>github.com/ericchiang/k8s</a></td>
</tr>
<tr>
<td>Java (OSGi)</td>
<td><a href=https://bitbucket.org/amdatulabs/amdatu-kubernetes>bitbucket.org/amdatulabs/amdatu-kubernetes</a></td>
</tr>
<tr>
<td>Java (Fabric8, OSGi)</td>
<td><a href=https://github.com/fabric8io/kubernetes-client>github.com/fabric8io/kubernetes-client</a></td>
</tr>
<tr>
<td>Java</td>
<td><a href=https://github.com/manusa/yakc>github.com/manusa/yakc</a></td>
</tr>
<tr>
<td>Lisp</td>
<td><a href=https://github.com/brendandburns/cl-k8s>github.com/brendandburns/cl-k8s</a></td>
</tr>
<tr>
<td>Lisp</td>
<td><a href=https://github.com/xh4/cube>github.com/xh4/cube</a></td>
</tr>
<tr>
<td>Node.js (TypeScript)</td>
<td><a href=https://github.com/Goyoo/node-k8s-client>github.com/Goyoo/node-k8s-client</a></td>
</tr>
<tr>
<td>Node.js</td>
<td><a href=https://github.com/ajpauwels/easy-k8s>github.com/ajpauwels/easy-k8s</a></td>
</tr>
<tr>
<td>Node.js</td>
<td><a href=https://github.com/godaddy/kubernetes-client>github.com/godaddy/kubernetes-client</a></td>
</tr>
<tr>
<td>Node.js</td>
<td><a href=https://github.com/tenxcloud/node-kubernetes-client>github.com/tenxcloud/node-kubernetes-client</a></td>
</tr>
<tr>
<td>Perl</td>
<td><a href=https://metacpan.org/pod/Net::Kubernetes>metacpan.org/pod/Net::Kubernetes</a></td>
</tr>
<tr>
<td>PHP</td>
<td><a href=https://github.com/allansun/kubernetes-php-client>github.com/allansun/kubernetes-php-client</a></td>
</tr>
<tr>
<td>PHP</td>
<td><a href=https://github.com/maclof/kubernetes-client>github.com/maclof/kubernetes-client</a></td>
</tr>
<tr>
<td>PHP</td>
<td><a href=https://github.com/travisghansen/kubernetes-client-php>github.com/travisghansen/kubernetes-client-php</a></td>
</tr>
<tr>
<td>PHP</td>
<td><a href=https://github.com/renoki-co/php-k8s>github.com/renoki-co/php-k8s</a></td>
</tr>
<tr>
<td>Python</td>
<td><a href=https://github.com/fiaas/k8s>github.com/fiaas/k8s</a></td>
</tr>
<tr>
<td>Python</td>
<td><a href=https://github.com/gtsystem/lightkube>github.com/gtsystem/lightkube</a></td>
</tr>
<tr>
<td>Python</td>
<td><a href=https://github.com/mnubo/kubernetes-py>github.com/mnubo/kubernetes-py</a></td>
</tr>
<tr>
<td>Python</td>
<td><a href=https://github.com/tomplus/kubernetes_asyncio>github.com/tomplus/kubernetes_asyncio</a></td>
</tr>
<tr>
<td>Python</td>
<td><a href=https://github.com/Frankkkkk/pykorm>github.com/Frankkkkk/pykorm</a></td>
</tr>
<tr>
<td>Ruby</td>
<td><a href=https://github.com/abonas/kubeclient>github.com/abonas/kubeclient</a></td>
</tr>
<tr>
<td>Ruby</td>
<td><a href=https://github.com/k8s-ruby/k8s-ruby>github.com/k8s-ruby/k8s-ruby</a></td>
</tr>
<tr>
<td>Ruby</td>
<td><a href=https://github.com/kontena/k8s-client>github.com/kontena/k8s-client</a></td>
</tr>
<tr>
<td>Rust</td>
<td><a href=https://github.com/clux/kube-rs>github.com/clux/kube-rs</a></td>
</tr>
<tr>
<td>Rust</td>
<td><a href=https://github.com/ynqa/kubernetes-rust>github.com/ynqa/kubernetes-rust</a></td>
</tr>
<tr>
<td>Scala</td>
<td><a href=https://github.com/hagay3/skuber>github.com/hagay3/skuber</a></td>
</tr>
<tr>
<td>Scala</td>
<td><a href=https://github.com/joan38/kubernetes-client>github.com/joan38/kubernetes-client</a></td>
</tr>
<tr>
<td>Swift</td>
<td><a href=https://github.com/swiftkube/client>github.com/swiftkube/client</a></td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-8d2ce3e7b2223cda0ccd428f4d5ea24b>4 - Kubernetes 弃用策略</h1>
<p>本文档详细解释系统中各个层面的弃用策略（Deprecation Policy）。</p>
<p>Kubernetes 是一个组件众多、贡献者人数众多的大系统。
就像很多类似的软件，所提供的功能特性集合会随着时间推移而自然发生变化，
而且有时候某个功能特性可能需要被去除。被去除的可能是一个 API、一个参数标志或者
甚至某整个功能特性。为了避免影响到现有用户，Kubernetes 对于其中渐次移除
的各个方面规定了一种弃用策略并遵从此策略。</p>
<h2 id=deprecating-parts-of-the-api>弃用 API 的一部分 </h2>
<p>由于 Kubernetes 是一个 API 驱动的系统，API 会随着时间推移而演化，以反映
人们对问题空间的认识的变化。Kubernetes API 实际上是一个 API 集合，其中每个
成员称作“API 组（API Group）”，并且每个 API 组都是独立管理版本的。
<a href=/zh/docs/reference/using-api/#api-versioning>API 版本</a>会有
三类，每类有不同的废弃策略：</p>
<table>
<thead>
<tr>
<th>示例</th>
<th>分类</th>
</tr>
</thead>
<tbody>
<tr>
<td>v1</td>
<td>正式发布（Generally available，GA，稳定版本）</td>
</tr>
<tr>
<td>v1beta1</td>
<td>Beta （预发布）</td>
</tr>
<tr>
<td>v1alpha1</td>
<td>Alpha （试验性）</td>
</tr>
</tbody>
</table>
<p>给定的 Kubernetes 发布版本中可以支持任意数量的 API 组，且每组可以包含
任意个数的版本。</p>
<p>下面的规则负责指导 API 元素的弃用，具体元素包括：</p>
<ul>
<li>REST 资源（也即 API 对象）</li>
<li>REST 资源的字段</li>
<li>REST 资源的注解，包含“beta”类注解但不包含“alpha”类注解</li>
<li>枚举值或者常数值</li>
<li>组件配置结构</li>
</ul>
<p>以下是跨正式发布版本时要实施的规则，不适用于对 master 或发布分支上
不同提交之间的变化。</p>
<p><strong>规则 #1：只能在增加 API 组版本号时删除 API 元素。</strong></p>
<p>一旦在某个特定 API 组版本中添加了 API 元素，则该元素不可从该版本中删除，
且其行为也不能大幅度地变化，无论属于哪一类（GA、Alpha 或 Beta）。</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 由于历史原因，Kubernetes 中存在两个“单体式（Monolithic）”API 组 -
“core”（无组名）和“extensions”。这两个遗留 API 组中的资源会被逐渐迁移到
更为特定领域的 API 组中。
</div>
<p><strong>规则 #2：在给定的发布版本中，API 对象必须能够在不同的 API 版本之间来回
转换且不造成信息丢失，除非整个 REST 资源在某些版本中完全不存在。</strong></p>
<p>例如，一个对象可被用 v1 来写入之后用 v2 来读出并转换为 v1，所得到的 v1 必须
与原来的 v1 对象完全相同。v2 中的表现形式可能与 v1 不同，但系统知道如何
在两个版本之间执行双向转换。
此外，v2 中添加的所有新字段都必须能够转换为 v1 再转换回来。这意味着 v1 必须
添加一个新的等效字段或者将其表现为一个注解。</p>
<p><strong>规则 #3：给定类别的 API 版本不可被弃用以支持稳定性更差的 API 版本。</strong></p>
<ul>
<li>一个正式发布的（GA）API 版本可替换 beta 或 alpha API 版本。</li>
<li>Beta API 版本可以替换早期的 beta 和 alpha API 版本，但 <strong>不可以</strong> 替换正式的 API 版本。</li>
<li>Alpha API 版本可以替换早期的 alpha API 版本，但 <strong>不可以</strong> 替换正式的或 beta API 版本。</li>
</ul>
<p><strong>规则 #4a：最短 API 生命周期由 API 稳定性级别决定</strong></p>
<ul>
<li><strong>GA API 版本可以被标记为已弃用，但不得在 Kubernetes 的主要版本中删除</strong></li>
<li><strong>Beta API 版本必须支持 9 个月或弃用后的 3 个版本（以较长者为准）</strong></li>
<li><strong>Alpha API 版本可能会在任何版本中被删除，不另行通知</strong></li>
</ul>
<p>这确保了 beta API 支持涵盖了<a href=/zh/releases/version-skew-policy/>最多 2 个版本的支持版本偏差</a>。</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong>
<p>目前没有删除正式版本 API 的 Kubernetes 主要版本修订计划。
</div>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 在 <a href=https://github.com/kubernetes/kubernetes/issues/52185>#52185</a> 被解决之前，
已经被保存到持久性存储中的 API 版本都不可以被去除。
你可以禁止这些版本所对应的 REST 末端（在符合本文中弃用时间线的前提下），
但是 API 服务器必须仍能解析和转换存储中以前写入的数据。
</div>
<p><strong>规则 #4b：标记为“preferred（优选的）” API 版本和给定 API 组的
“storage version（存储版本）”在既支持老版本也支持新版本的 Kubernetes 发布
版本出来以前不可以提升其版本号。</strong></p>
<p>用户必须能够升级到 Kubernetes 新的发行版本，之后再回滚到前一个发行版本，且
整个过程中无需针对新的 API 版本做任何转换，也不允许出现功能损坏的情况，
除非用户显式地使用了仅在较新版本中才存在的功能特性。
就对象的存储表示而言，这一点尤其是不言自明的。</p>
<p>以上所有规则最好通过例子来说明。假定现有 Kubernetes 发行版本为 X，其中引入了
新的 API 组。大约每隔 4 个月会有一个新的 Kubernetes 版本被发布（每年 3 个版本）。
下面的表格描述了在一系列后续的发布版本中哪些 API 版本是受支持的。</p>
<table>
<thead>
<tr>
<th>发布版本</th>
<th>API 版本</th>
<th>优选/存储版本</th>
<th>注释</th>
</tr>
</thead>
<tbody>
<tr>
<td>X</td>
<td>v1alpha1</td>
<td>v1alpha1</td>
<td></td>
</tr>
<tr>
<td>X+1</td>
<td>v1alpha2</td>
<td>v1alpha2</td>
<td>
<ul>
<li>v1alpha1 被去除，发布说明中会包含 "action required（采取行动）" 说明</li>
</ul>
</td>
</tr>
<tr>
<td>X+2</td>
<td>v1beta1</td>
<td>v1beta1</td>
<td>
<ul>
<li>v1alpha2 被去除，发布说明中包含对应的 "action required（采取行动）" 说明</li>
</ul>
</td>
</tr>
<tr>
<td>X+3</td>
<td>v1beta2、v1beta1（已弃用）</td>
<td>v1beta1</td>
<td>
<ul>
<li>v1beta1 被弃用，发布说明中包含对应的 "action required（采取行动）" 说明</li>
</ul>
</td>
</tr>
<tr>
<td>X+4</td>
<td>v1beta2、v1beta1（已弃用）</td>
<td>v1beta2</td>
<td></td>
</tr>
<tr>
<td>X+5</td>
<td>v1、v1beta1（已弃用）、v1beta2（已弃用）</td>
<td>v1beta2</td>
<td>
<ul>
<li>v1beta2 被弃用，发布说明中包含对应的 "action required（采取行动）" 说明</li>
</ul>
</td>
</tr>
<tr>
<td>X+6</td>
<td>v1、v1beta2（已弃用）</td>
<td>v1</td>
<td>
<ul>
<li>v1beta1 被去除，发布说明中包含对应的 "action required（采取行动）" 说明</li>
</ul>
</td>
</tr>
<tr>
<td>X+7</td>
<td>v1、v1beta2（已弃用）</td>
<td>v1</td>
<td></td>
</tr>
<tr>
<td>X+8</td>
<td>v2alpha1、v1</td>
<td>v1</td>
<td>
<ul>
<li>v1beta2 被去除，发布说明中包含对应的 "action required（采取行动）" 说明</li>
</ul>
</td>
</tr>
<tr>
<td>X+9</td>
<td>v2alpha2、v1</td>
<td>v1</td>
<td>
<ul>
<li>v2alpha1 被删除，发布说明中包含对应的 "action required（采取行动）" 说明</li>
</ul>
</td>
</tr>
<tr>
<td>X+10</td>
<td>v2beta1、v1</td>
<td>v1</td>
<td>
<ul>
<li>v2alpha2 被删除，发布说明中包含对应的 "action required（采取行动）" 说明</li>
</ul>
</td>
</tr>
<tr>
<td>X+11</td>
<td>v2beta2、v2beta1（已弃用）、v1</td>
<td>v1</td>
<td>
<ul>
<li>v2beta1 被弃用，发布说明中包含对应的 "action required（采取行动）" 说明</li>
</ul>
</td>
</tr>
<tr>
<td>X+12</td>
<td>v2、v2beta2（已弃用）、v2beta1（已弃用）、v1（已弃用）</td>
<td>v1</td>
<td>
<ul>
<li>v2beta2 已被弃用，发布说明中包含对应的 "action required（采取行动）" 说明</li>
<li>v1 已被弃用，取而代之的是 v2，但不会被删除</li>
</ul>
</td>
</tr>
<tr>
<td>X+13</td>
<td>v2、v2beta1（已弃用）、v2beta2（已弃用）、v1（已弃用）</td>
<td>v2</td>
<td></td>
</tr>
<tr>
<td>X+14</td>
<td>v2、v2beta2（已弃用）、v1（已弃用）</td>
<td>v2</td>
<td>
<ul>
<li>v2beta1 被删除，发布说明中包含对应的 "action required（采取行动）" 说明</li>
</ul>
</td>
</tr>
<tr>
<td>X+15</td>
<td>v2、v1（已弃用）</td>
<td>v2</td>
<td>
<ul>
<li>v2beta2 被删除，发布说明中包含对应的 "action required（采取行动）" 说明</li>
</ul>
</td>
</tr>
</tbody>
</table>
<h3 id=rest-resources-aka-api-objects>REST 资源（也即 API 对象） </h3>
<p>考虑一个假想的名为 Widget 的 REST 资源，在上述时间线中位于 API v1，
而现在打算将其弃用。
我们会在文档和
<a href=https://groups.google.com/forum/#!forum/kubernetes-announce>声明</a>
中与 X+1 版本的发布同步记述此弃用决定。
Wdiget 资源仍会在 API 版本 v1（已弃用）中存在，但不会出现在 v2alpha1 中。
Widget 资源会 X+8 发布版本之前（含 X+8）一直存在并可用。
只有在发布版本 X+9 中，API v1 寿终正寝时，Widget
才彻底消失，相应的资源行为也被移除。</p>
<p>从 Kubernetes v1.19 开始，当 API 请求被发送到一个已弃用的 REST API 末端时：</p>
<ol>
<li>
<p>API 响应中会包含一个 <code>Warning</code> 头部字段（如 <a href=https://tools.ietf.org/html/rfc7234#section-5.5>RFC7234 5.5 节</a>所定义）；</p>
</li>
<li>
<p>该请求会导致对应的
<a href=/zh/docs/tasks/debug-application-cluster/audit/>审计事件</a>
中会增加一个注解 <code>"k8s.io/deprecated":"true"</code>。</p>
</li>
<li>
<p><code>kube-apiserver</code> 进程的 <code>apiserver_requested_deprecated_apis</code> 度量值会被
设置为 <code>1</code>。
该度量值还附带 <code>group</code>、<code>version</code>、<code>resource</code> 和 <code>subresource</code> 标签
（可供添加到度量值 <code>apiserver_request_total</code> 上），
和一个 <code>removed_release</code> 标签，标明该 API 将消失的 Kubernetes 发布版本。
下面的 Prometheus 查询会返回对 v1.22 中将移除的、已弃用的 API
的请求的信息：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-promql data-lang=promql><span style=color:#b8860b>apiserver_requested_deprecated_apis</span>{<span style=color:#a0a000>removed_release</span><span style=color:#666>=</span>&#34;<span style=color:#b44>1.22</span>&#34;}<span style=color:#bbb> </span><span style=color:#666>*</span><span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>on</span><span style=color:#666>(</span><span style=color:#a2f;font-weight:700>group</span>,<span style=color:#b8860b>version</span>,<span style=color:#b8860b>resource</span>,<span style=color:#b8860b>subresource</span><span style=color:#666>)</span><span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>group_right</span><span style=color:#666>()</span><span style=color:#bbb> </span><span style=color:#b8860b>apiserver_request_total</span><span style=color:#bbb>
</span></code></pre></div></li>
</ol>
<h3 id=fields-of-rest-resources>REST 资源的字段 </h3>
<p>就像整个 REST 资源一样，在 API v1 中曾经存在的各个字段在 API v1 被移除
之前必须一直存在且起作用。
与整个资源上的规定不同，v2 API 可以选择为字段提供不同的表示方式，
只要对应的资源对象可在不同版本之间来回转换即可。
例如，v1 版本中一个名为 "magnitude" 的已弃用字段可能在 API v2 中被命名
为 "deprecatedMagnitude"。当 v1 最终被移除时，废弃的字段也可以从 v2
中移除。</p>
<h3 id=enumerated-or-constant-values>枚举值或常数值</h3>
<p>就像前文讲述的 REST 资源及其中的单个字段一样，API v1 中所支持的常数值
必须在 API v1 被移除之前一直存在且起作用。</p>
<h3 id=component-config-structures>组件配置结构 </h3>
<p>组件的配置也是有版本的，并且按 REST 资源的方式来管理。</p>
<h3 id=future-work>将来的工作 </h3>
<p>随着时间推移，Kubernetes 会引入粒度更细的 API 版本。
到那时，这里的规则会根据需要进行调整。</p>
<h2 id=弃用一个标志或-cli-命令>弃用一个标志或 CLI 命令</h2>
<p>Kubernetes 系统中包含若干不同的、相互协作的程序。
有时，Kubernetes 可能会删除这些程序的某些标志或 CLI 命令（统称“命令行元素”）。
这些程序可以天然地划分到两个大组中：面向用户的和面向管理员的程序。
二者之间的弃用策略略有不同。
除非某个标志显示地通过前缀或文档来标明其为“alpha”或“beta”，
该标志要被视作正式发布的（GA）。</p>
<p>命令行元素相当于系统的 API 的一部分，不过因为它们并没有采用 REST API
一样的方式来管理版本，其弃用规则规定如下：</p>
<p><strong>规则 #5a：面向用户的命令行元素（例如，kubectl）必须在其宣布被弃用其
在以下时长内仍能使用：</strong></p>
<ul>
<li><strong>GA：12 个月或者 2 个发布版本（取其较长者）</strong></li>
<li><strong>Beta：3 个月或者 1 个发布版本（取其较长者）</strong></li>
<li><strong>Alpha：0 发布版本</strong></li>
</ul>
<p><strong>规则 #5b：面向管理员的命令行元素（例如，kubelet）必须在其被宣布弃用
之后以下时长内保持可用：</strong></p>
<ul>
<li><strong>GA：6 个月或 1 个发行版本（取其较长者）</strong></li>
<li><strong>Beta: 3 个月或 1 个发行版本（取其较长者）</strong></li>
<li><strong>Alpha: 0 个发布版本</strong></li>
</ul>
<p><strong>规则 #6：被弃用的 CLI 元素在被用到时必须能够产生警告，而警告的
产生是可以被禁止的。</strong></p>
<h2 id=deprecating-a-feature-or-behavior>弃用某功能特性或行为 </h2>
<p>在一些较偶然的情形下，某 Kubernetes 发行版本需要弃用系统的某项功能
特性或者行为，而对应的功能特性或行为并不受 API 或 CLI 控制。在这种情况下，
其弃用规则如下：</p>
<p><strong>规则 #7：被弃用的行为必须在被宣布弃用之后至少 1 年时间内必须保持能用。</strong></p>
<p>这并不意味着对系统的所有更改都受此策略约束。
此规则仅适用于重大的、用户可见的行为；这些行为会影响到在 Kubernetes
中运行的应用的正确性，或者影响到 Kubernetes 集群的管理。
此规则也适用于那些被整个移除的功能特性或行为。</p>
<p>上述规则的一个例外是 <em>特性门控（Feature Gates）</em>。特性门控是一些键值偶对，
允许用户启用或禁用一些试验性的功能特性。</p>
<p>特性门控意在覆盖功能特性的整个开发周期，它们无意成为长期的 API。
因此，它们会在某功能特性正式发布或被抛弃之后被弃用和删除。</p>
<p>随着一个功能特性经过不同的成熟阶段，相关的特性门控也会演化。
与功能特性生命周期对应的特性门控状态为：</p>
<ul>
<li>Alpha：特性门控默认被禁用，只能由用户显式启用。</li>
<li>Beta：特性门控默认被弃用，可被用户显式禁用。</li>
<li>GA: 特性门控被弃用（参见<a href=#deprecation>弃用</a>），并且不再起作用。</li>
<li>GA，弃用窗口期结束：特性门控被删除，不再接受调用。</li>
</ul>
<h3 id=deprecation>弃用 </h3>
<p>功能特性在正式发布之前的生命周期内任何时间点都可被移除。
当未正式发布的功能特性被移除时，它们对应的特性门控也被弃用。</p>
<p>当尝试禁用一个不再起作用的特性门控时，该调用会失败，这样可以避免
毫无迹象地执行一些不受支持的场景。</p>
<p>在某些场合，移除一个即将正式发布的功能特性需要很长时间。特性门控
可以保持其功能，直到对应的功能特性被彻底去除，直到那时特性门控
自身才可被弃用。</p>
<p>由于移除一个已经正式发布的功能特性对应的特性门控也需要一定时间，对特性
门控的调用可能一直被允许，前提是特性门控对功能本身无影响且特性门控不会
引发任何错误。</p>
<p>意在允许用户禁用的功能特性应该包含一个在相关联的特性门控中禁用该功能的机制。</p>
<p>特性门控的版本管理与之前讨论的组件版本管理不同，因此其对应的弃用策略如下：</p>
<p><strong>规则 #8：特性门控所对应的功能特性经历下面所列的成熟性阶段转换时，特性门控
必须被弃用。特性门控弃用时必须在以下时长内保持其功能可用：</strong></p>
<ul>
<li><strong>Beta 特性转为 GA：6 个月或者 2 个发布版本（取其较长者）</strong></li>
<li><strong>Beta 特性转为丢弃：3 个月或者 1 个发布版本（取其较长者）</strong></li>
<li><strong>Alpha 特性转为丢弃：0 个发布版本</strong></li>
</ul>
<p><strong>规则 #9：已弃用的特色门控再被使用时必须给出警告回应。当特性门控被
弃用时，必须在发布说明和对应的 CLI 帮助信息中通过文档宣布。
警告信息和文档都要标明是否某特性门控不再起作用。</strong></p>
<h3 id=deprecating-a-metric>弃用度量值 </h3>
<p>Kubernetes 控制平面的每个组件都公开度量值（通常是 <code>/metrics</code> 端点），它们通常由集群管理员使用。
并不是所有的度量值都是同样重要的：一些度量值通常用作 SLIs 或被使用来确定 SLOs，这些往往比较重要。
其他度量值在本质上带有实验性，或者主要用于 Kubernetes 开发过程。</p>
<p>因此，度量值分为两个稳定性类别（<code>ALPHA</code> 和 <code>STABLE</code>）;
此分类会影响在 Kubernetes 发布版本中移除某度量值。
所对应的分类取决于对该度量值重要性的预期。
弃用和移除度量值的规则如下：</p>
<p><strong>规则 #9a: 对于相应的稳定性类别，度量值起作用的周期必须不小于：</strong></p>
<ul>
<li><strong>STABLE: 4 个发布版本或者 12 个月 (取其较长者)</strong></li>
<li><strong>ALPHA: 0 个发布版本</strong></li>
</ul>
<p><strong>规则 #9b: 在度量值被宣布启用之后，它起作用的周期必须不小于：</strong></p>
<ul>
<li><strong>STABLE: 3 个发布版本或者 9 个月 (取其较长者)</strong></li>
<li><strong>ALPHA: 0 个发布版本</strong></li>
</ul>
<p>已弃用的度量值将在其描述文本前加上一个已弃用通知字符串 '(Deprecated from x.y)'，
并将在度量值被记录期间发出警告日志。就像稳定的、未被弃用的度量指标一样，
被弃用的度量值将自动注册到 metrics 端点，因此被弃用的度量值也是可见的。</p>
<p>在随后的版本中（当度量值 <code>deprecatedVersion</code> 等于_当前 Kubernetes 版本 - 3_），
被弃用的度量值将变成 _隐藏（Hidden）_ metric 度量值。
与被弃用的度量值不同，隐藏的度量值将不再被自动注册到 metrics 端点（因此被隐藏）。
但是，它们可以通过可执行文件的命令行标志显式启用
（<code>--show-hidden-metrics-for-version=</code>）。
如果集群管理员不能对早期的弃用警告作出反应，这一设计就为他们提供了抓紧迁移弃用度量值的途径。
隐藏的度量值应该在再过一个发行版本后被删除。</p>
<h2 id=exceptions>例外 </h2>
<p>没有策略可以覆盖所有情况。此策略文档是一个随时被更新的文档，会随着时间
推移演化。在实践中，会有一些情况无法很好地匹配到这里的弃用策略，或者
这里的策略变成了很严重的羁绊。这类情形要与 SIG 和项目牵头人讨论，
寻求对应场景的最佳解决方案。请一直铭记，Kubernetes 承诺要成为一个
稳定的系统，至少会尽力做到不会影响到其用户。此弃用策略的任何例外情况
都会在所有相关的发布说明中公布。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-2479c39af50fd55b898a3bcfb5988077>5 - 已弃用 API 的迁移指南</h1>
<p>随着 Kubernetes API 的演化，APIs 会周期性地被重组或升级。
当 APIs 演化时，老的 API 会被弃用并被最终删除。
本页面包含你在将已弃用 API 版本迁移到新的更稳定的 API 版本时需要了解的知识。</p>
<h2 id=removed-apis-by-release>各发行版本中移除的 API </h2>
<h3 id=v1-26>v1.26</h3>
<p><strong>v1.26</strong> 发行版本中将去除以下已弃用的 API 版本：</p>
<h4 id=flowcontrol-resources-v126>流控制资源 </h4>
<p><strong>flowcontrol.apiserver.k8s.io/v1beta1</strong> API 版本的 FlowSchema
和 PriorityLevelConfiguration 将不会在 v1.26 中提供。</p>
<ul>
<li>迁移清单和 API 客户端使用 <strong>flowcontrol.apiserver.k8s.io/v1beta2</strong> API 版本，
此 API 从 v1.23 版本开始可用；</li>
<li>所有的已保存的对象都可以通过新的 API 来访问；</li>
<li>没有需要额外注意的变更</li>
</ul>
<h4 id=horizontalpodautoscaler-v126>HorizontalPodAutoscaler</h4>
<p><strong>autoscaling/v2beta2</strong> API 版本的 HorizontalPodAutoscaler 将不会在
v1.26 版本中提供。</p>
<ul>
<li>迁移清单和 API 客户端使用 <strong>autoscaling/v2</strong> API 版本，
此 API 从 v1.23 版本开始可用；</li>
<li>所有的已保存的对象都可以通过新的 API 来访问；</li>
</ul>
<h3 id=v1-25>v1.25</h3>
<p><strong>v1.25</strong> 发行版本将停止提供以下已废弃 API 版本：</p>
<h4 id=cronjob-v125>CronJob</h4>
<p><strong>batch/v1beta1</strong> API 版本的 CronJob 将不会在 v1.25 版本中继续提供。</p>
<ul>
<li>迁移清单和 API 客户端使用 <strong>batch/v1</strong> API 版本，此 API 从 v1.21 版本开始可用；</li>
<li>所有的已保存的对象都可以通过新的 API 来访问；</li>
<li>没有需要额外注意的变更</li>
</ul>
<h4 id=endpointslice-v125>EndpointSlice</h4>
<p><strong>discovery.k8s.io/v1beta1</strong> API 版本的 EndpointSlice 将不会在 v1.25 版本中继续提供。</p>
<ul>
<li>迁移清单和 API 客户端使用 <strong>discovery.k8s.io/v1</strong> API 版本，此 API 从 v1.21 版本开始可用；</li>
<li>所有的已保存的对象都可以通过新的 API 来访问；</li>
<li><strong>discovery.k8s.io/v1</strong> 中值得注意的变更有：
<ul>
<li>使用每个 Endpoint 的 <code>nodeName</code> 字段而不是已被弃用的
<code>topology["kubernetes.io/hostname"]</code> 字段；</li>
<li>使用每个 Endpoint 的 <code>zone</code> 字段而不是已被弃用的
<code>topology["kubernetes.io/zone"]</code> 字段；</li>
<li><code>topology</code> 字段被替换为 <code>deprecatedTopology</code>，并且在 v1 版本中不可写入。</li>
</ul>
</li>
</ul>
<h4 id=event-v125>Event</h4>
<p><strong>events.k8s.io/v1beta1</strong> API 版本的 Event 将不会在 v1.25 版本中继续提供。</p>
<ul>
<li>迁移清单和 API 客户端使用 <strong>events.k8s.io/v1</strong> API 版本，此 API 从 v1.19 版本开始可用；</li>
<li>所有的已保存的对象都可以通过新的 API 来访问；</li>
</ul>
<ul>
<li><strong>events.k8s.io/v1</strong> 中值得注意的变更有：
<ul>
<li><code>type</code> 字段只能设置为 <code>Normal</code> 和 <code>Warning</code> 之一；</li>
<li><code>involvedObject</code> 字段被更名为 <code>regarding</code>；</li>
<li><code>action</code>、<code>reason</code>、<code>reportingController</code> 和 <code>reportingInstance</code> 字段
在创建新的 <strong>events.k8s.io/v1</strong> 版本 Event 时都是必需的字段；</li>
<li>使用 <code>eventTime</code> 而不是已被弃用的 <code>firstTimestamp</code> 字段
（该字段已被更名为 <code>deprecatedFirstTimestamp</code>，且不允许出现在新的 <strong>events.k8s.io/v1</strong> Event 对象中）；</li>
<li>使用 <code>series.lastObservedTime</code> 而不是已被弃用的 <code>lastTimestamp</code> 字段
（该字段已被更名为 <code>deprecatedLastTimestamp</code>，且不允许出现在新的 <strong>events.k8s.io/v1</strong> Event 对象中）；</li>
<li>使用 <code>series.count</code> 而不是已被弃用的 <code>count</code> 字段
（该字段已被更名为 <code>deprecatedCount</code>，且不允许出现在新的 <strong>events.k8s.io/v1</strong> Event 对象中）；</li>
<li>使用 <code>reportingController</code> 而不是已被弃用的 <code>source.component</code> 字段
（该字段已被更名为 <code>deprecatedSource.component</code>，且不允许出现在新的 <strong>events.k8s.io/v1</strong> Event 对象中）；</li>
<li>使用 <code>reportingInstance</code> 而不是已被弃用的 <code>source.host</code> 字段
（该字段已被更名为 <code>deprecatedSource.host</code>，且不允许出现在新的 <strong>events.k8s.io/v1</strong> Event 对象中）。</li>
</ul>
</li>
</ul>
<h4 id=horizontalpodautoscaler-v125>HorizontalPodAutoscaler</h4>
<p><strong>autoscaling/v2beta1</strong> API 版本的 HorizontalPodAutoscaler 将不会在 v1.25 版本中继续提供。</p>
<ul>
<li>迁移清单和 API 客户端使用 <strong>autoscaling/v2</strong> API 版本，此 API 从 v1.23 版本开始可用；</li>
<li>所有的已保存的对象都可以通过新的 API 来访问；</li>
</ul>
<h4 id=poddisruptionbudget-v125>PodDisruptionBudget</h4>
<p><strong>policy/v1beta1</strong> API 版本的 PodDisruptionBudget 将不会在 v1.25 版本中继续提供。</p>
<ul>
<li>迁移清单和 API 客户端使用 <strong>policy/v1</strong> API 版本，此 API 从 v1.21 版本开始可用；</li>
<li>所有的已保存的对象都可以通过新的 API 来访问；</li>
<li><strong>policy/v1</strong> 中需要额外注意的变更有：
<ul>
<li>在 <code>policy/v1</code> 版本的 PodDisruptionBudget 中将 <code>spec.selector</code>
设置为空（<code>{}</code>）时会选择名字空间中的所有 Pods（在 <code>policy/v1beta1</code>
版本中，空的 <code>spec.selector</code> 不会选择任何 Pods）。如果 <code>spec.selector</code>
未设置，则在两个 API 版本下都不会选择任何 Pods。</li>
</ul>
</li>
</ul>
<h4 id=psp-v125>PodSecurityPolicy</h4>
<p><strong>policy/v1beta1</strong> API 版本中的 PodSecurityPolicy 将不会在 v1.25 中提供，
并且 PodSecurityPolicy 准入控制器也会被删除。</p>
<p>PodSecurityPolicy 的替换方案仍在讨论过程中，不过当前的用法可以迁移到
<a href=/zh/docs/reference/access-authn-authz/extensible-admission-controllers/>第三方准入性质的 Webhook</a>。</p>
<h4 id=runtimeclass-v125>RuntimeClass</h4>
<p><strong>node.k8s.io/v1beta1</strong> API 版本中的 RuntimeClass 将不会在 v1.25 中提供。</p>
<ul>
<li>迁移清单和 API 客户端使用 <strong>node.k8s.io/v1</strong> API 版本，此 API 从 v1.20 版本开始可用；</li>
<li>所有的已保存的对象都可以通过新的 API 来访问；</li>
<li>没有需要额外注意的变更</li>
</ul>
<h3 id=v1-22>v1.22</h3>
<p><strong>v1.22</strong> 发行版本停止提供以下已废弃 API 版本：</p>
<h4 id=webhook-resources-v122>Webhook 资源 </h4>
<p><strong>admissionregistration.k8s.io/v1beta1</strong> API 版本的 MutatingWebhookConfiguration
和 ValidatingWebhookConfiguration 不在 v1.22 版本中继续提供。</p>
<ul>
<li>迁移清单和 API 客户端使用 <strong>admissionregistration.k8s.io/v1</strong> API 版本，
此 API 从 v1.16 版本开始可用；</li>
<li>所有的已保存的对象都可以通过新的 API 来访问；</li>
</ul>
<ul>
<li>值得注意的变更：
<ul>
<li><code>webhooks[*].failurePolicy</code> 在 v1 版本中默认值从 <code>Ignore</code> 改为 <code>Fail</code></li>
<li><code>webhooks[*].matchPolicy</code> 在 v1 版本中默认值从 <code>Exact</code> 改为 <code>Equivalent</code></li>
<li><code>webhooks[*].timeoutSeconds</code> 在 v1 版本中默认值从 <code>30s</code> 改为 <code>10s</code></li>
<li><code>webhooks[*].sideEffects</code> 的默认值被删除，并且该字段变为必须指定；
在 v1 版本中可选的值只能是 <code>None</code> 和 <code>NoneOnDryRun</code> 之一</li>
<li><code>webhooks[*].admissionReviewVersions</code> 的默认值被删除，在 v1
版本中此字段变为必须指定（AdmissionReview 的被支持版本包括 <code>v1</code> 和 <code>v1beta1</code>）</li>
<li><code>webhooks[*].name</code> 必须在通过 <code>admissionregistration.k8s.io/v1</code>
创建的对象列表中唯一</li>
</ul>
</li>
</ul>
<h4 id=customresourcedefinition-v122>CustomResourceDefinition</h4>
<p><strong>apiextensions.k8s.io/v1beta1</strong> API 版本的 CustomResourceDefinition
不在 v1.22 版本中继续提供。</p>
<ul>
<li>迁移清单和 API 客户端使用 <strong>apiextensions/v1</strong> API 版本，此 API 从 v1.16 版本开始可用；</li>
<li>所有的已保存的对象都可以通过新的 API 来访问；</li>
</ul>
<ul>
<li>值得注意的变更：
<ul>
<li><code>spec.scope</code> 的默认值不再是 <code>Namespaced</code>，该字段必须显式指定</li>
<li><code>spec.version</code> 在 v1 版本中被删除；应改用 <code>spec.versions</code></li>
<li><code>spec.validation</code> 在 v1 版本中被删除；应改用 <code>spec.versions[*].schema</code></li>
<li><code>spec.subresources</code> 在 v1 版本中被删除；应改用 <code>spec.versions[*].subresources</code></li>
<li><code>spec.additionalPrinterColumns</code> 在 v1 版本中被删除；应改用
<code>spec.versions[*].additionalPrinterColumns</code></li>
<li><code>spec.conversion.webhookClientConfig</code> 在 v1 版本中被移动到
<code>spec.conversion.webhook.clientConfig</code> 中</li>
</ul>
<ul>
<li><code>spec.conversion.conversionReviewVersions</code> 在 v1 版本中被移动到
<code>spec.conversion.webhook.conversionReviewVersions</code></li>
<li><code>spec.versions[*].schema.openAPIV3Schema</code> 在创建 v1 版本的
CustomResourceDefinition 对象时变成必需字段，并且其取值必须是一个
<a href=/zh/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/#specifying-a-structural-schema>结构化的 Schema</a></li>
<li><code>spec.preserveUnknownFields: true</code> 在创建 v1 版本的 CustomResourceDefinition
对象时不允许指定；该配置必须在 Schema 定义中使用
<code>x-kubernetes-preserve-unknown-fields: true</code> 来设置</li>
<li>在 v1 版本中，<code>additionalPrinterColumns</code> 的条目中的 <code>JSONPath</code> 字段被更名为
<code>jsonPath</code>（补丁 <a href=https://github.com/kubernetes/kubernetes/issues/66531>#66531</a>）</li>
</ul>
</li>
</ul>
<h4 id=apiservice-v122>APIService</h4>
<p><strong>apiregistration/v1beta1</strong> API 版本的 APIService 不在 v1.22 版本中继续提供。</p>
<ul>
<li>迁移清单和 API 客户端使用 <strong>apiregistration.k8s.io/v1</strong> API 版本，此 API 从
v1.10 版本开始可用；</li>
<li>所有的已保存的对象都可以通过新的 API 来访问；</li>
<li>没有需要额外注意的变更</li>
</ul>
<h4 id=tokenreview-v122>TokenReview</h4>
<p><strong>authentication.k8s.io/v1beta1</strong> API 版本的 TokenReview 不在 v1.22 版本中继续提供。</p>
<ul>
<li>迁移清单和 API 客户端使用 <strong>authentication.k8s.io/v1</strong> API 版本，此 API 从
v1.6 版本开始可用；</li>
<li>所有的已保存的对象都可以通过新的 API 来访问；</li>
<li>没有需要额外注意的变更</li>
</ul>
<h4 id=subjectaccessreview-resources-v122>SubjectAccessReview resources</h4>
<p><strong>authorization.k8s.io/v1beta1</strong> API 版本的 LocalSubjectAccessReview、
SelfSubjectAccessReview、SubjectAccessReview 不在 v1.22 版本中继续提供。</p>
<ul>
<li>迁移清单和 API 客户端使用 <strong>authorization.k8s.io/v1</strong> API 版本，此 API 从
v1.6 版本开始可用；</li>
<li>所有的已保存的对象都可以通过新的 API 来访问；</li>
<li>需要额外注意的变更：
<ul>
<li><code>spec.group</code> 在 v1 版本中被更名为 <code>spec.groups</code>
（补丁 <a href=https://github.com/kubernetes/kubernetes/issues/32709>#32709</a>）</li>
</ul>
</li>
</ul>
<h4 id=certificatesigningrequest-v122>CertificateSigningRequest</h4>
<p><strong>certificates.k8s.io/v1beta1</strong> API 版本的 CertificateSigningRequest 不在
v1.22 版本中继续提供。</p>
<ul>
<li>迁移清单和 API 客户端使用 <strong>certificates.k8s.io/v1</strong> API 版本，此 API 从
v1.19 版本开始可用；</li>
<li>所有的已保存的对象都可以通过新的 API 来访问；</li>
</ul>
<ul>
<li><code>certificates.k8s.io/v1</code> 中需要额外注意的变更：
<ul>
<li>对于请求证书的 API 客户端而言：
<ul>
<li><code>spec.signerName</code> 现在变成必需字段（参阅
<a href=/zh/docs/reference/access-authn-authz/certificate-signing-requests/#kubernetes-signers>已知的 Kubernetes 签署者</a>），
并且通过 <code>certificates.k8s.io/v1</code> API 不可以创建签署者为
<code>kubernetes.io/legacy-unknown</code> 的请求</li>
<li><code>spec.usages</code> 现在变成必需字段，其中不可以包含重复的字符串值，
并且只能包含已知的用法字符串</li>
</ul>
</li>
<li>对于要批准或者签署证书的 API 客户端而言：
<ul>
<li><code>status.conditions</code> 中不可以包含重复的类型</li>
<li><code>status.conditions[*].status</code> 字段现在变为必需字段</li>
<li><code>status.certificate</code> 必须是 PEM 编码的，而且其中只能包含 <code>CERTIFICATE</code>
数据块</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id=lease-v122>Lease</h4>
<p><strong>coordination.k8s.io/v1beta1</strong> API 版本的 Lease 不在 v1.22 版本中继续提供。</p>
<ul>
<li>迁移清单和 API 客户端使用 <strong>coordination.k8s.io/v1</strong> API 版本，此 API 从
v1.14 版本开始可用；</li>
<li>所有的已保存的对象都可以通过新的 API 来访问；</li>
<li>没有需要额外注意的变更</li>
</ul>
<h4 id=ingress-v122>Ingress</h4>
<p><strong>extensions/v1beta1</strong> 和 <strong>networking.k8s.io/v1beta1</strong> API 版本的 Ingress
不在 v1.22 版本中继续提供。</p>
<ul>
<li>迁移清单和 API 客户端使用 <strong>networking.k8s.io/v1</strong> API 版本，此 API 从
v1.19 版本开始可用；</li>
<li>所有的已保存的对象都可以通过新的 API 来访问；</li>
</ul>
<ul>
<li>值得注意的变更：
<ul>
<li><code>spec.backend</code> 字段被更名为 <code>spec.defaultBackend</code></li>
<li>后端的 <code>serviceName</code> 字段被更名为 <code>service.name</code></li>
<li>数值表示的后端 <code>servicePort</code> 字段被更名为 <code>service.port.number</code></li>
<li>字符串表示的后端 <code>servicePort</code> 字段被更名为 <code>service.port.name</code></li>
<li>对所有要指定的路径，<code>pathType</code> 都成为必需字段。
可选项为 <code>Prefix</code>、<code>Exact</code> 和 <code>ImplementationSpecific</code>。
要匹配 <code>v1beta1</code> 版本中未定义路径类型时的行为，可使用 <code>ImplementationSpecific</code></li>
</ul>
</li>
</ul>
<h4 id=ingressclass-v122>IngressClass</h4>
<p><strong>networking.k8s.io/v1beta1</strong> API 版本的 IngressClass 不在 v1.22 版本中继续提供。</p>
<ul>
<li>迁移清单和 API 客户端使用 <strong>networking.k8s.io/v1</strong> API 版本，此 API 从
v1.19 版本开始可用；</li>
<li>所有的已保存的对象都可以通过新的 API 来访问；</li>
<li>没有需要额外注意的变更</li>
</ul>
<h4 id=rbac-resources-v122>RBAC 资源 </h4>
<p><strong>rbac.authorization.k8s.io/v1beta1</strong> API 版本的 ClusterRole、ClusterRoleBinding、
Role 和 RoleBinding 不在 v1.22 版本中继续提供。</p>
<ul>
<li>迁移清单和 API 客户端使用 <strong>rbac.authorization.k8s.io/v1</strong> API 版本，此 API 从
v1.8 版本开始可用；</li>
<li>所有的已保存的对象都可以通过新的 API 来访问；</li>
<li>没有需要额外注意的变更</li>
</ul>
<h4 id=priorityclass-v122>PriorityClass</h4>
<p><strong>scheduling.k8s.io/v1beta1</strong> API 版本的 PriorityClass 不在 v1.22 版本中继续提供。</p>
<ul>
<li>迁移清单和 API 客户端使用 <strong>scheduling.k8s.io/v1</strong> API 版本，此 API 从
v1.14 版本开始可用；</li>
<li>所有的已保存的对象都可以通过新的 API 来访问；</li>
<li>没有需要额外注意的变更</li>
</ul>
<h4 id=storage-resources-v122>存储资源 </h4>
<p><strong>storage.k8s.io/v1beta1</strong> API 版本的 CSIDriver、CSINode、StorageClass
和 VolumeAttachment 不在 v1.22 版本中继续提供。</p>
<ul>
<li>迁移清单和 API 客户端使用 <strong>storage.k8s.io/v1</strong> API 版本
<ul>
<li>CSIDriver 从 v1.19 版本开始在 <strong>storage.k8s.io/v1</strong> 中提供；</li>
<li>CSINode 从 v1.17 版本开始在 <strong>storage.k8s.io/v1</strong> 中提供；</li>
<li>StorageClass 从 v1.6 版本开始在 <strong>storage.k8s.io/v1</strong> 中提供；</li>
<li>VolumeAttachment 从 v1.13 版本开始在 <strong>storage.k8s.io/v1</strong> 中提供；</li>
</ul>
</li>
<li>所有的已保存的对象都可以通过新的 API 来访问；</li>
<li>没有需要额外注意的变更</li>
</ul>
<h3 id=v1-16>v1.16</h3>
<p><strong>v1.16</strong> 发行版本停止提供以下已废弃 API 版本：</p>
<h4 id=networkpolicy-v116>NetworkPolicy</h4>
<p><strong>extensions/v1beta1</strong> API 版本的 NetworkPolicy 不在 v1.16 版本中继续提供。</p>
<ul>
<li>迁移清单和 API 客户端使用 <strong>networking.k8s.io/v1</strong> API 版本，此 API 从
v1.8 版本开始可用；</li>
<li>所有的已保存的对象都可以通过新的 API 来访问；</li>
</ul>
<h4 id=daemonset-v116>DaemonSet</h4>
<p><strong>extensions/v1beta1</strong> 和 <strong>apps/v1beta2</strong> API 版本的 DaemonSet 在
v1.16 版本中不再继续提供。</p>
<ul>
<li>迁移清单和 API 客户端使用 <strong>apps/v1</strong> API 版本，此 API 从 v1.9 版本开始可用；</li>
<li>所有的已保存的对象都可以通过新的 API 来访问；</li>
</ul>
<ul>
<li>值得注意的变更：
<ul>
<li><code>spec.templateGeneration</code> 字段被删除</li>
<li><code>spec.selector</code> 现在变成必需字段，并且在对象创建之后不可变更；
可以将现有模板的标签作为选择算符以实现无缝迁移。</li>
<li><code>spec.updateStrategy.type</code> 的默认值变为 <code>RollingUpdate</code>
（<code>extensions/v1beta1</code> API 版本中的默认值是 <code>OnDelete</code>）。</li>
</ul>
</li>
</ul>
<h4 id=deployment-v116>Deployment</h4>
<p><strong>extensions/v1beta1</strong>、<strong>apps/v1beta1</strong> 和 <strong>apps/v1beta2</strong> API 版本的
Deployment 在 v1.16 版本中不再继续提供。</p>
<ul>
<li>迁移清单和 API 客户端使用 <strong>apps/v1</strong> API 版本，此 API 从 v1.9 版本开始可用；</li>
<li>所有的已保存的对象都可以通过新的 API 来访问；</li>
</ul>
<ul>
<li>值得注意的变更：
<ul>
<li><code>spec.rollbackTo</code> 字段被删除</li>
<li><code>spec.selector</code> 字段现在变为必需字段，并且在 Deployment 创建之后不可变更；
可以使用现有的模板的标签作为选择算符以实现无缝迁移。</li>
<li><code>spec.progressDeadlineSeconds</code> 的默认值变为 <code>600</code> 秒
（<code>extensions/v1beta1</code> 中的默认值是没有期限）</li>
<li><code>spec.revisionHistoryLimit</code> 的默认值变为 <code>10</code>
（<code>apps/v1beta1</code> API 版本中此字段默认值为 <code>2</code>，在<code>extensions/v1beta1</code> API
版本中的默认行为是保留所有历史记录）。</li>
<li><code>maxSurge</code> 和 <code>maxUnavailable</code> 的默认值变为 <code>25%</code>
（在 <code>extensions/v1beta1</code> API 版本中，这些字段的默认值是 <code>1</code>）。</li>
</ul>
</li>
</ul>
<h4 id=statefulset-v116>StatefulSet</h4>
<p><strong>apps/v1beta1</strong> 和 <strong>apps/v1beta2</strong> API 版本的 StatefulSet 在 v1.16 版本中不再继续提供。</p>
<ul>
<li>迁移清单和 API 客户端使用 <strong>apps/v1</strong> API 版本，此 API 从 v1.9 版本开始可用；</li>
<li>所有的已保存的对象都可以通过新的 API 来访问；</li>
</ul>
<ul>
<li>值得注意的变更：
<ul>
<li><code>spec.selector</code> 字段现在变为必需字段，并且在 StatefulSet 创建之后不可变更；
可以使用现有的模板的标签作为选择算符以实现无缝迁移。</li>
<li><code>spec.updateStrategy.type</code> 的默认值变为 <code>RollingUpdate</code>
（<code>apps/v1beta1</code> API 版本中的默认值是 <code>OnDelete</code>）。</li>
</ul>
</li>
</ul>
<h4 id=replicaset-v116>ReplicaSet</h4>
<p><strong>extensions/v1beta1</strong>、<strong>apps/v1beta1</strong> 和 <strong>apps/v1beta2</strong> API 版本的
ReplicaSet 在 v1.16 版本中不再继续提供。</p>
<ul>
<li>迁移清单和 API 客户端使用 <strong>apps/v1</strong> API 版本，此 API 从 v1.9 版本开始可用；</li>
<li>所有的已保存的对象都可以通过新的 API 来访问；</li>
</ul>
<ul>
<li>值得注意的变更：
<ul>
<li><code>spec.selector</code> 现在变成必需字段，并且在对象创建之后不可变更；
可以将现有模板的标签作为选择算符以实现无缝迁移。</li>
</ul>
</li>
</ul>
<h4 id=psp-v116>PodSecurityPolicy</h4>
<p><strong>extensions/v1beta1</strong> API 版本的 PodSecurityPolicy 在 v1.16 版本中不再继续提供。</p>
<ul>
<li>迁移清单和 API 客户端使用 <strong>policy/v1beta1</strong> API 版本，此 API 从 v1.10 版本开始可用；</li>
<li>注意 <strong>policy/v1beta1</strong> API 版本的 PodSecurityPolicy 会在 v1.25 版本中移除。</li>
</ul>
<h2 id=what-to-do>需要做什么 </h2>
<h3 id=在禁用已启用-api-的情况下执行测试>在禁用已启用 API 的情况下执行测试</h3>
<p>你可以通过在启动 API 服务器时禁用特定的 API 版本来模拟即将发生的
API 移除，从而完成测试。在 API 服务器启动参数中添加如下标志：</p>
<p><code>--runtime-config=&lt;group>/&lt;version>=false</code></p>
<p>例如：</p>
<p><code>--runtime-config=admissionregistration.k8s.io/v1beta1=false,apiextensions.k8s.io/v1beta1,...</code></p>
<h3 id=定位何处使用了已弃用的-api>定位何处使用了已弃用的 API</h3>
<p>使用 <a href=https://kubernetes.io/blog/2020/09/03/warnings/#deprecation-warnings>client warnings, metrics, and audit information available in 1.19+</a>
来定位在何处使用了已启用的 API。</p>
<h3 id=迁移到未被弃用的-api>迁移到未被弃用的 API</h3>
<ul>
<li>更新自定义的集成组件和控制器，调用未被弃用的 API</li>
<li>更改 YAML 文件引用未被弃用的 API</li>
</ul>
<p>你可以用 <code>kubectl-convert</code> 命令（在 v1.20 之前是 <code>kubectl convert</code>）
来自动转换现有对象：</p>
<p><code>kubectl-convert -f &lt;file> --output-version &lt;group>/&lt;version></code>.</p>
<p>例如，要将较老的 Deployment 转换为 <code>apps/v1</code> 版本，你可以运行</p>
<p><code>kubectl-convert -f ./my-deployment.yaml --output-version apps/v1</code></p>
<p>注意这种操作生成的结果中可能使用的默认值并不理想。
要进一步了解某个特定资源，可查阅 Kubernetes <a href=/zh/docs/reference/kubernetes-api/>API 参考</a>。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-e4dbb59f8f23854d7b7d574e169923c4>6 - Kubernetes API 健康端点</h1>
<p>Kubernetes <a class=glossary-tooltip title="提供 Kubernetes API 服务的控制面组件。" data-toggle=tooltip data-placement=top href=/zh/docs/reference/command-line-tools-reference/kube-apiserver/ target=_blank aria-label="API 服务器">API 服务器</a> 提供 API 端点以指示 API 服务器的当前状态。
本文描述了这些 API 端点，并说明如何使用。</p>
<h2 id=api-endpoints-for-health>API 健康端点 </h2>
<p>Kubernetes API 服务器提供 3 个 API 端点（<code>healthz</code>、<code>livez</code> 和 <code>readyz</code>）来表明 API 服务器的当前状态。
<code>healthz</code> 端点已被弃用（自 Kubernetes v1.16 起），你应该使用更为明确的 <code>livez</code> 和 <code>readyz</code> 端点。
<code>livez</code> 端点可与 <code>--livez-grace-period</code> <a href=/zh/docs/reference/command-line-tools-reference/kube-apiserver>标志</a>一起使用，来指定启动持续时间。
为了正常关机，你可以使用 <code>/readyz</code> 端点并指定 <code>--shutdown-delay-duration</code> <a href=/zh/docs/reference/command-line-tools-reference/kube-apiserver>标志</a>。
检查 API 服务器的 <code>healthz</code>/<code>livez</code>/<code>readyz</code> 端点的机器应依赖于 HTTP 状态代码。
状态码 <code>200</code> 表示 API 服务器是 <code>healthy</code>、<code>live</code> 还是 <code>ready</code>，具体取决于所调用的端点。
以下更详细的选项供操作人员使用，用来调试其集群或了解 API 服务器的状态。</p>
<p>以下示例将显示如何与运行状况 API 端点进行交互。</p>
<p>对于所有端点，都可以使用 <code>verbose</code> 参数来打印检查项以及检查状态。
这对于操作人员调试 API 服务器的当前状态很有用，这些不打算给机器使用：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>curl -k https://localhost:6443/livez?verbose
</code></pre></div>
<p>或从具有身份验证的远程主机：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get --raw<span style=color:#666>=</span><span style=color:#b44>&#39;/readyz?verbose&#39;</span>
</code></pre></div>
<p>输出将如下所示：</p>
<pre><code>[+]ping ok
[+]log ok
[+]etcd ok
[+]poststarthook/start-kube-apiserver-admission-initializer ok
[+]poststarthook/generic-apiserver-start-informers ok
[+]poststarthook/start-apiextensions-informers ok
[+]poststarthook/start-apiextensions-controllers ok
[+]poststarthook/crd-informer-synced ok
[+]poststarthook/bootstrap-controller ok
[+]poststarthook/rbac/bootstrap-roles ok
[+]poststarthook/scheduling/bootstrap-system-priority-classes ok
[+]poststarthook/start-cluster-authentication-info-controller ok
[+]poststarthook/start-kube-aggregator-informers ok
[+]poststarthook/apiservice-registration-controller ok
[+]poststarthook/apiservice-status-available-controller ok
[+]poststarthook/kube-apiserver-autoregistration ok
[+]autoregister-completion ok
[+]poststarthook/apiservice-openapi-controller ok
healthz check passed
</code></pre>
<p>Kubernetes API 服务器也支持排除特定的检查项。
查询参数也可以像以下示例一样进行组合：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>curl -k <span style=color:#b44>&#39;https://localhost:6443/readyz?verbose&amp;exclude=etcd&#39;</span>
</code></pre></div>
<p>输出显示排除了 <code>etcd</code> 检查：</p>
<pre><code>[+]ping ok
[+]log ok
[+]etcd excluded: ok
[+]poststarthook/start-kube-apiserver-admission-initializer ok
[+]poststarthook/generic-apiserver-start-informers ok
[+]poststarthook/start-apiextensions-informers ok
[+]poststarthook/start-apiextensions-controllers ok
[+]poststarthook/crd-informer-synced ok
[+]poststarthook/bootstrap-controller ok
[+]poststarthook/rbac/bootstrap-roles ok
[+]poststarthook/scheduling/bootstrap-system-priority-classes ok
[+]poststarthook/start-cluster-authentication-info-controller ok
[+]poststarthook/start-kube-aggregator-informers ok
[+]poststarthook/apiservice-registration-controller ok
[+]poststarthook/apiservice-status-available-controller ok
[+]poststarthook/kube-apiserver-autoregistration ok
[+]autoregister-completion ok
[+]poststarthook/apiservice-openapi-controller ok
[+]shutdown ok
healthz check passed
</code></pre>
<h2 id=individual-health-check>独立健康检查 </h2>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.23 [alpha]</code>
</div>
<p>每个单独的健康检查都会公开一个 HTTP 端点，并且可以单独检查。
单个运行状况检查的模式为 <code>/livez/&lt;healthcheck-name></code>，其中 <code>livez</code> 和 <code>readyz</code> 表明你要检查的是 API 服务器是否存活或就绪。
<code>&lt;healthcheck-name></code> 的路径可以通过上面的 <code>verbose</code> 参数发现 ，并采用 <code>[+]</code> 和 <code>ok</code> 之间的路径。
这些单独的健康检查不应由机器使用，但对于操作人员调试系统而言，是有帮助的：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>curl -k https://localhost:6443/livez/etcd
</code></pre></div>
</div>
</main>
</div>
</div>
<footer class=d-print-none>
<div class=footer__links>
<nav>
<a class=text-white href=/zh/docs/home/>主页</a>
<a class=text-white href=/zh/blog/>博客</a>
<a class=text-white href=/zh/training/>培训</a>
<a class=text-white href=/zh/partners/>合作伙伴</a>
<a class=text-white href=/zh/community/>社区</a>
<a class=text-white href=/zh/case-studies/>案例分析</a>
</nav>
</div>
<div class=container-fluid>
<div class=row>
<div class="col-6 col-sm-2 text-xs-center order-sm-2">
<ul class="list-inline mb-0">
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="User mailing list" aria-label="User mailing list">
<a class=text-white target=_blank href=https://discuss.kubernetes.io>
<i class="fa fa-envelope"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Twitter aria-label=Twitter>
<a class=text-white target=_blank href=https://twitter.com/kubernetesio>
<i class="fab fa-twitter"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Calendar aria-label=Calendar>
<a class=text-white target=_blank href="https://calendar.google.com/calendar/embed?src=calendar%40kubernetes.io">
<i class="fas fa-calendar-alt"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Youtube aria-label=Youtube>
<a class=text-white target=_blank href=https://youtube.com/kubernetescommunity>
<i class="fab fa-youtube"></i>
</a>
</li>
</ul>
</div>
<div class="col-6 col-sm-2 text-right text-xs-center order-sm-3">
<ul class="list-inline mb-0">
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub>
<a class=text-white target=_blank href=https://github.com/kubernetes/kubernetes>
<i class="fab fa-github"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Slack aria-label=Slack>
<a class=text-white target=_blank href=https://slack.k8s.io>
<i class="fab fa-slack"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Contribute aria-label=Contribute>
<a class=text-white target=_blank href=https://git.k8s.io/community/contributors/guide>
<i class="fas fa-edit"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Stack Overflow" aria-label="Stack Overflow">
<a class=text-white target=_blank href=https://stackoverflow.com/questions/tagged/kubernetes>
<i class="fab fa-stack-overflow"></i>
</a>
</li>
</ul>
</div>
<div class="col-12 col-sm-8 text-center order-sm-2">
<small class=text-white>&copy; 2023 The Kubernetes Authors | Documentation Distributed under <a href=https://git.k8s.io/website/LICENSE class=light-text>CC BY 4.0</a></small>
<br>
<small class=text-white>Copyright &copy; 2023 The Linux Foundation &reg;. All rights reserved. The Linux Foundation has registered trademarks and uses trademarks. For a list of trademarks of The Linux Foundation, please see our <a href=https://www.linuxfoundation.org/trademark-usage class=light-text>Trademark Usage page</a></small>
<br>
<small class=text-white>ICP license: 京ICP备17074266号-3</small>
</div>
</div>
</div>
</footer>
</div>
<script src=/js/popper-1.14.3.min.js integrity=sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49 crossorigin=anonymous></script>
<script src=/js/bootstrap-4.3.1.min.js integrity=sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM crossorigin=anonymous></script>
<script src=/js/main.min.40616251a9b6e4b689e7769be0340661efa4d7ebb73f957404e963e135b4ed52.js integrity="sha256-QGFiUam25LaJ53ab4DQGYe+k1+u3P5V0BOlj4TW07VI=" crossorigin=anonymous></script>
</body>
</html>