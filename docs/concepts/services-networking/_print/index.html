<!doctype html><html lang=en class=no-js>
<head>
<meta name=ROBOTS content="NOINDEX, NOFOLLOW">
<script async src="https://www.googletagmanager.com/gtag/js?id=G-JPP6RFM2BP"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-JPP6RFM2BP')</script>
<link rel=alternate hreflang=zh href=https://kubernetes.io/zh/docs/concepts/services-networking/>
<link rel=alternate hreflang=ko href=https://kubernetes.io/ko/docs/concepts/services-networking/>
<link rel=alternate hreflang=ja href=https://kubernetes.io/ja/docs/concepts/services-networking/>
<link rel=alternate hreflang=fr href=https://kubernetes.io/fr/docs/concepts/services-networking/>
<link rel=alternate hreflang=de href=https://kubernetes.io/de/docs/concepts/services-networking/>
<link rel=alternate hreflang=es href=https://kubernetes.io/es/docs/concepts/services-networking/>
<link rel=alternate hreflang=pt-br href=https://kubernetes.io/pt-br/docs/concepts/services-networking/>
<link rel=alternate hreflang=id href=https://kubernetes.io/id/docs/concepts/services-networking/>
<link rel=alternate hreflang=uk href=https://kubernetes.io/uk/docs/concepts/services-networking/>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=generator content="Hugo 0.87.0">
<link rel=canonical type=text/html href=https://kubernetes.io/docs/concepts/services-networking/>
<link rel="shortcut icon" type=image/png href=/images/favicon.png>
<link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180>
<link rel=manifest href=/manifest.webmanifest>
<link rel=apple-touch-icon href=/images/kubernetes-192x192.png>
<title>Services, Load Balancing, and Networking | Kubernetes</title><meta property="og:title" content="Services, Load Balancing, and Networking">
<meta property="og:description" content="Concepts and resources behind networking in Kubernetes.
">
<meta property="og:type" content="website">
<meta property="og:url" content="https://kubernetes.io/docs/concepts/services-networking/"><meta property="og:site_name" content="Kubernetes">
<meta itemprop=name content="Services, Load Balancing, and Networking">
<meta itemprop=description content="Concepts and resources behind networking in Kubernetes.
"><meta name=twitter:card content="summary">
<meta name=twitter:title content="Services, Load Balancing, and Networking">
<meta name=twitter:description content="Concepts and resources behind networking in Kubernetes.
">
<link href=/scss/main.css rel=stylesheet>
<script src=/js/jquery-3.3.1.min.js integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin=anonymous></script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","url":"https://kubernetes.io","logo":"https://kubernetes.io/images/favicon.png"}</script>
<meta name=theme-color content="#326ce5">
<link rel=stylesheet href=/css/feature-states.css>
<meta name=description content="Concepts and resources behind networking in Kubernetes.
">
<meta property="og:description" content="Concepts and resources behind networking in Kubernetes.
">
<meta name=twitter:description content="Concepts and resources behind networking in Kubernetes.
">
<meta property="og:url" content="https://kubernetes.io/docs/concepts/services-networking/">
<meta property="og:title" content="Services, Load Balancing, and Networking">
<meta name=twitter:title content="Services, Load Balancing, and Networking">
<meta name=twitter:image content="https://kubernetes.io/images/favicon.png">
<meta name=twitter:image:alt content="Kubernetes">
<meta property="og:image" content="/images/kubernetes-horizontal-color.png">
<meta property="og:type" content="article">
<script src=/js/script.js></script>
</head>
<body class=td-section>
<header>
<nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar" data-auto-burger=primary>
<a class=navbar-brand href=/></a>
<div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar>
<ul class="navbar-nav mt-2 mt-lg-0">
<li class="nav-item mr-2 mb-lg-0">
<a class="nav-link active" href=/docs/>Documentation</a>
</li>
<li class="nav-item mr-2 mb-lg-0">
<a class=nav-link href=/blog/>Kubernetes Blog</a>
</li>
<li class="nav-item mr-2 mb-lg-0">
<a class=nav-link href=/training/>Training</a>
</li>
<li class="nav-item mr-2 mb-lg-0">
<a class=nav-link href=/partners/>Partners</a>
</li>
<li class="nav-item mr-2 mb-lg-0">
<a class=nav-link href=/community/>Community</a>
</li>
<li class="nav-item mr-2 mb-lg-0">
<a class=nav-link href=/case-studies/>Case Studies</a>
</li>
<li class="nav-item dropdown">
<a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>
Versions
</a>
<div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink>
<a class=dropdown-item href=/releases>Release Information</a>
<a class=dropdown-item href=https://kubernetes.io/docs/concepts/services-networking/>v1.27</a>
<a class=dropdown-item href=https://v1-26.docs.kubernetes.io/docs/concepts/services-networking/>v1.26</a>
<a class=dropdown-item href=https://v1-25.docs.kubernetes.io/docs/concepts/services-networking/>v1.25</a>
<a class=dropdown-item href=https://v1-24.docs.kubernetes.io/docs/concepts/services-networking/>v1.24</a>
<a class=dropdown-item href=https://v1-23.docs.kubernetes.io/docs/concepts/services-networking/>v1.23</a>
</div>
</li>
<li class="nav-item dropdown">
<a class="nav-link dropdown-toggle" href=# id=navbarDropdownMenuLink role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>
English
</a>
<div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink>
<a class=dropdown-item href=/zh/docs/concepts/services-networking/>中文 Chinese</a>
<a class=dropdown-item href=/ko/docs/concepts/services-networking/>한국어 Korean</a>
<a class=dropdown-item href=/ja/docs/concepts/services-networking/>日本語 Japanese</a>
<a class=dropdown-item href=/fr/docs/concepts/services-networking/>Français</a>
<a class=dropdown-item href=/de/docs/concepts/services-networking/>Deutsch</a>
<a class=dropdown-item href=/es/docs/concepts/services-networking/>Español</a>
<a class=dropdown-item href=/pt-br/docs/concepts/services-networking/>Português</a>
<a class=dropdown-item href=/id/docs/concepts/services-networking/>Bahasa Indonesia</a>
<a class=dropdown-item href=/uk/docs/concepts/services-networking/>Українська</a>
</div>
</li>
</ul>
</div>
<button id=hamburger onclick=kub.toggleMenu() data-auto-burger-exclude><div></div></button>
</nav>
</header>
<div class="container-fluid td-outer">
<div class=td-main>
<div class="row flex-xl-nowrap">
<main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main>
<div class=td-content>
<div class="pageinfo pageinfo-primary d-print-none">
<p>
This is the multi-page printable view of this section.
<a href=# onclick="return print(),!1">Click here to print</a>.
</p><p>
<a href=/docs/concepts/services-networking/>Return to the regular view of this page</a>.
</p>
</div>
<h1 class=title>Services, Load Balancing, and Networking</h1>
<div class=lead>Concepts and resources behind networking in Kubernetes.</div>
<ul>
<li>1: <a href=#pg-5701136fd2ce258047b6ddc389112352>Service</a></li>
<li>2: <a href=#pg-3a38878244d862dfdb8d7adb32f77584>Topology-aware traffic routing with topology keys</a></li>
<li>3: <a href=#pg-91cb8a4438b003df11bc1c426a81b756>DNS for Services and Pods</a></li>
<li>4: <a href=#pg-f804ac0532fcade3966ea2e3769ca031>Connecting Applications with Services</a></li>
<li>5: <a href=#pg-199bcc92443dbc9bed44819467d7eb75>Ingress</a></li>
<li>6: <a href=#pg-5a8edeb1f2dc8e38cd6d561bb08b0d78>Ingress Controllers</a></li>
<li>7: <a href=#pg-f51db1097575de8072afe1f5b156a70c>EndpointSlices</a></li>
<li>8: <a href=#pg-cd7657b1056ad32451974db57a951ba5>Service Internal Traffic Policy</a></li>
<li>9: <a href=#pg-374e5c954990aec58a0797adc70a5039>Topology Aware Hints</a></li>
<li>10: <a href=#pg-ded1daafdcd293023ee333728007ca61>Network Policies</a></li>
<li>11: <a href=#pg-21f8d19c60c33914baab66224c3d46a7>IPv4/IPv6 dual-stack</a></li>
</ul>
<div class=content>
<h2 id=the-kubernetes-network-model>The Kubernetes network model</h2>
<p>Every <a href=/docs/concepts/workloads/pods/><code>Pod</code></a> gets its own IP address.
This means you do not need to explicitly create links between <code>Pods</code> and you
almost never need to deal with mapping container ports to host ports.<br>
This creates a clean, backwards-compatible model where <code>Pods</code> can be treated
much like VMs or physical hosts from the perspectives of port allocation,
naming, service discovery, <a href=/docs/concepts/services-networking/ingress/#load-balancing>load balancing</a>, application configuration,
and migration.</p>
<p>Kubernetes imposes the following fundamental requirements on any networking
implementation (barring any intentional network segmentation policies):</p>
<ul>
<li>pods on a <a href=/docs/concepts/architecture/nodes/>node</a> can communicate with all pods on all nodes without NAT</li>
<li>agents on a node (e.g. system daemons, kubelet) can communicate with all
pods on that node</li>
</ul>
<p>Note: For those platforms that support <code>Pods</code> running in the host network (e.g.
Linux):</p>
<ul>
<li>pods in the host network of a node can communicate with all pods on all
nodes without NAT</li>
</ul>
<p>This model is not only less complex overall, but it is principally compatible
with the desire for Kubernetes to enable low-friction porting of apps from VMs
to containers. If your job previously ran in a VM, your VM had an IP and could
talk to other VMs in your project. This is the same basic model.</p>
<p>Kubernetes IP addresses exist at the <code>Pod</code> scope - containers within a <code>Pod</code>
share their network namespaces - including their IP address and MAC address.
This means that containers within a <code>Pod</code> can all reach each other's ports on
<code>localhost</code>. This also means that containers within a <code>Pod</code> must coordinate port
usage, but this is no different from processes in a VM. This is called the
"IP-per-pod" model.</p>
<p>How this is implemented is a detail of the particular container runtime in use.</p>
<p>It is possible to request ports on the <code>Node</code> itself which forward to your <code>Pod</code>
(called host ports), but this is a very niche operation. How that forwarding is
implemented is also a detail of the container runtime. The <code>Pod</code> itself is
blind to the existence or non-existence of host ports.</p>
<p>Kubernetes networking addresses four concerns:</p>
<ul>
<li>Containers within a Pod <a href=/docs/concepts/services-networking/dns-pod-service/>use networking to communicate</a> via loopback.</li>
<li>Cluster networking provides communication between different Pods.</li>
<li>The <a href=/docs/concepts/services-networking/service/>Service resource</a> lets you <a href=/docs/concepts/services-networking/connect-applications-service/>expose an application running in Pods</a> to be reachable from outside your cluster.</li>
<li>You can also use Services to <a href=/docs/concepts/services-networking/service-traffic-policy/>publish services only for consumption inside your cluster</a>.</li>
</ul>
</div>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-5701136fd2ce258047b6ddc389112352>1 - Service</h1>
An abstract way to expose an application running on a set of <a class=glossary-tooltip title="A Pod represents a set of running containers in your cluster." data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/pods/ target=_blank aria-label=Pods>Pods</a> as a network service.
<p>With Kubernetes you don't need to modify your application to use an unfamiliar service discovery mechanism.
Kubernetes gives Pods their own IP addresses and a single DNS name for a set of Pods,
and can load-balance across them.</p>
<h2 id=motivation>Motivation</h2>
<p>Kubernetes <a class=glossary-tooltip title="A Pod represents a set of running containers in your cluster." data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/pods/ target=_blank aria-label=Pods>Pods</a> are created and destroyed
to match the desired state of your cluster. Pods are nonpermanent resources.
If you use a <a class=glossary-tooltip title="Manages a replicated application on your cluster." data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/controllers/deployment/ target=_blank aria-label=Deployment>Deployment</a> to run your app,
it can create and destroy Pods dynamically.</p>
<p>Each Pod gets its own IP address, however in a Deployment, the set of Pods
running in one moment in time could be different from
the set of Pods running that application a moment later.</p>
<p>This leads to a problem: if some set of Pods (call them "backends") provides
functionality to other Pods (call them "frontends") inside your cluster,
how do the frontends find out and keep track of which IP address to connect
to, so that the frontend can use the backend part of the workload?</p>
<p>Enter <em>Services</em>.</p>
<h2 id=service-resource>Service resources</h2>
<p>In Kubernetes, a Service is an abstraction which defines a logical set of Pods
and a policy by which to access them (sometimes this pattern is called
a micro-service). The set of Pods targeted by a Service is usually determined
by a <a class=glossary-tooltip title="Allows users to filter a list of resources based on labels." data-toggle=tooltip data-placement=top href=/docs/concepts/overview/working-with-objects/labels/ target=_blank aria-label=selector>selector</a>.
To learn about other ways to define Service endpoints,
see <a href=#services-without-selectors>Services <em>without</em> selectors</a>.</p>
<p>For example, consider a stateless image-processing backend which is running with
3 replicas. Those replicas are fungible—frontends do not care which backend
they use. While the actual Pods that compose the backend set may change, the
frontend clients should not need to be aware of that, nor should they need to keep
track of the set of backends themselves.</p>
<p>The Service abstraction enables this decoupling.</p>
<h3 id=cloud-native-service-discovery>Cloud-native service discovery</h3>
<p>If you're able to use Kubernetes APIs for service discovery in your application,
you can query the <a class=glossary-tooltip title="Control plane component that serves the Kubernetes API." data-toggle=tooltip data-placement=top href=/docs/concepts/overview/components/#kube-apiserver target=_blank aria-label="API server">API server</a>
for Endpoints, that get updated whenever the set of Pods in a Service changes.</p>
<p>For non-native applications, Kubernetes offers ways to place a network port or load
balancer in between your application and the backend Pods.</p>
<h2 id=defining-a-service>Defining a Service</h2>
<p>A Service in Kubernetes is a REST object, similar to a Pod. Like all of the
REST objects, you can <code>POST</code> a Service definition to the API server to create
a new instance.
The name of a Service object must be a valid
<a href=/docs/concepts/overview/working-with-objects/names#rfc-1035-label-names>RFC 1035 label name</a>.</p>
<p>For example, suppose you have a set of Pods where each listens on TCP port 9376
and contains a label <code>app=MyApp</code>:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>MyApp<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>9376</span><span style=color:#bbb>
</span></code></pre></div><p>This specification creates a new Service object named "my-service", which
targets TCP port 9376 on any Pod with the <code>app=MyApp</code> label.</p>
<p>Kubernetes assigns this Service an IP address (sometimes called the "cluster IP"),
which is used by the Service proxies
(see <a href=#virtual-ips-and-service-proxies>Virtual IPs and service proxies</a> below).</p>
<p>The controller for the Service selector continuously scans for Pods that
match its selector, and then POSTs any updates to an Endpoint object
also named "my-service".</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> A Service can map <em>any</em> incoming <code>port</code> to a <code>targetPort</code>. By default and
for convenience, the <code>targetPort</code> is set to the same value as the <code>port</code>
field.
</div>
<p>Port definitions in Pods have names, and you can reference these names in the
<code>targetPort</code> attribute of a Service. For example, we can bind the <code>targetPort</code>
of the Service to the Pod port in the following way:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/name</span>:<span style=color:#bbb> </span>proxy<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:11.14.2<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>http-web-svc<span style=color:#bbb>
</span><span style=color:#bbb>        
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/name</span>:<span style=color:#bbb> </span>proxy<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>name-of-service-port<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span>http-web-svc<span style=color:#bbb>
</span></code></pre></div><p>This works even if there is a mixture of Pods in the Service using a single
configured name, with the same network protocol available via different
port numbers. This offers a lot of flexibility for deploying and evolving
your Services. For example, you can change the port numbers that Pods expose
in the next version of your backend software, without breaking clients.</p>
<p>The default protocol for Services is TCP; you can also use any other
<a href=#protocol-support>supported protocol</a>.</p>
<p>As many Services need to expose more than one port, Kubernetes supports multiple
port definitions on a Service object.
Each port definition can have the same <code>protocol</code>, or a different one.</p>
<h3 id=services-without-selectors>Services without selectors</h3>
<p>Services most commonly abstract access to Kubernetes Pods thanks to the selector,
but when used with a corresponding Endpoints object and without a selector, the Service can abstract other kinds of backends,
including ones that run outside the cluster. For example:</p>
<ul>
<li>You want to have an external database cluster in production, but in your
test environment you use your own databases.</li>
<li>You want to point your Service to a Service in a different
<a class=glossary-tooltip title="An abstraction used by Kubernetes to support isolation of groups of resources within a single cluster." data-toggle=tooltip data-placement=top href=/docs/concepts/overview/working-with-objects/namespaces target=_blank aria-label=Namespace>Namespace</a> or on another cluster.</li>
<li>You are migrating a workload to Kubernetes. While evaluating the approach,
you run only a portion of your backends in Kubernetes.</li>
</ul>
<p>In any of these scenarios you can define a Service <em>without</em> a Pod selector.
For example:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>9376</span><span style=color:#bbb>
</span></code></pre></div><p>Because this Service has no selector, the corresponding Endpoints object is not
created automatically. You can manually map the Service to the network address and port
where it's running, by adding an Endpoints object manually:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Endpoints<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>subsets</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>addresses</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>ip</span>:<span style=color:#bbb> </span><span style=color:#666>192.0.2.42</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>9376</span><span style=color:#bbb>
</span></code></pre></div><p>The name of the Endpoints object must be a valid
<a href=/docs/concepts/overview/working-with-objects/names#dns-subdomain-names>DNS subdomain name</a>.</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> <p>The endpoint IPs <em>must not</em> be: loopback (127.0.0.0/8 for IPv4, ::1/128 for IPv6), or
link-local (169.254.0.0/16 and 224.0.0.0/24 for IPv4, fe80::/64 for IPv6).</p>
<p>Endpoint IP addresses cannot be the cluster IPs of other Kubernetes Services,
because <a class=glossary-tooltip title="kube-proxy is a network proxy that runs on each node in the cluster." data-toggle=tooltip data-placement=top href=/docs/reference/command-line-tools-reference/kube-proxy/ target=_blank aria-label=kube-proxy>kube-proxy</a> doesn't support virtual IPs
as a destination.</p>
</div>
<p>Accessing a Service without a selector works the same as if it had a selector.
In the example above, traffic is routed to the single endpoint defined in
the YAML: <code>192.0.2.42:9376</code> (TCP).</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> The Kubernetes API server does not allow proxying to endpoints that are not mapped to
pods. Actions such as <code>kubectl proxy &lt;service-name></code> where the service has no
selector will fail due to this constraint. This prevents the Kubernetes API server
from being used as a proxy to endpoints the caller may not be authorized to access.
</div>
<p>An ExternalName Service is a special case of Service that does not have
selectors and uses DNS names instead. For more information, see the
<a href=#externalname>ExternalName</a> section later in this document.</p>
<h3 id=over-capacity-endpoints>Over Capacity Endpoints</h3>
<p>If an Endpoints resource has more than 1000 endpoints then a Kubernetes v1.22 (or later)
cluster annotates that Endpoints with <code>endpoints.kubernetes.io/over-capacity: truncated</code>.
This annotation indicates that the affected Endpoints object is over capacity and that
the endpoints controller has truncated the number of endpoints to 1000.</p>
<h3 id=endpointslices>EndpointSlices</h3>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.21 [stable]</code>
</div>
<p>EndpointSlices are an API resource that can provide a more scalable alternative
to Endpoints. Although conceptually quite similar to Endpoints, EndpointSlices
allow for distributing network endpoints across multiple resources. By default,
an EndpointSlice is considered "full" once it reaches 100 endpoints, at which
point additional EndpointSlices will be created to store any additional
endpoints.</p>
<p>EndpointSlices provide additional attributes and functionality which is
described in detail in <a href=/docs/concepts/services-networking/endpoint-slices/>EndpointSlices</a>.</p>
<h3 id=application-protocol>Application protocol</h3>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.20 [stable]</code>
</div>
<p>The <code>appProtocol</code> field provides a way to specify an application protocol for
each Service port. The value of this field is mirrored by the corresponding
Endpoints and EndpointSlice objects.</p>
<p>This field follows standard Kubernetes label syntax. Values should either be
<a href=https://www.iana.org/assignments/service-names>IANA standard service names</a> or
domain prefixed names such as <code>mycompany.com/my-custom-protocol</code>.</p>
<h2 id=virtual-ips-and-service-proxies>Virtual IPs and service proxies</h2>
<p>Every node in a Kubernetes cluster runs a <code>kube-proxy</code>. <code>kube-proxy</code> is
responsible for implementing a form of virtual IP for <code>Services</code> of type other
than <a href=#externalname><code>ExternalName</code></a>.</p>
<h3 id=why-not-use-round-robin-dns>Why not use round-robin DNS?</h3>
<p>A question that pops up every now and then is why Kubernetes relies on
proxying to forward inbound traffic to backends. What about other
approaches? For example, would it be possible to configure DNS records that
have multiple A values (or AAAA for IPv6), and rely on round-robin name
resolution?</p>
<p>There are a few reasons for using proxying for Services:</p>
<ul>
<li>There is a long history of DNS implementations not respecting record TTLs,
and caching the results of name lookups after they should have expired.</li>
<li>Some apps do DNS lookups only once and cache the results indefinitely.</li>
<li>Even if apps and libraries did proper re-resolution, the low or zero TTLs
on the DNS records could impose a high load on DNS that then becomes
difficult to manage.</li>
</ul>
<p>Later in this page you can read about various kube-proxy implementations work. Overall,
you should note that, when running <code>kube-proxy</code>, kernel level rules may be
modified (for example, iptables rules might get created), which won't get cleaned up,
in some cases until you reboot. Thus, running kube-proxy is something that should
only be done by an administrator which understands the consequences of having a
low level, privileged network proxying service on a computer. Although the <code>kube-proxy</code>
executable supports a <code>cleanup</code> function, this function is not an official feature and
thus is only available to use as-is.</p>
<h3 id=configuration>Configuration</h3>
<p>Note that the kube-proxy starts up in different modes, which are determined by its configuration.</p>
<ul>
<li>The kube-proxy's configuration is done via a ConfigMap, and the ConfigMap for kube-proxy effectively deprecates the behaviour for almost all of the flags for the kube-proxy.</li>
<li>The ConfigMap for the kube-proxy does not support live reloading of configuration.</li>
<li>The ConfigMap parameters for the kube-proxy cannot all be validated and verified on startup. For example, if your operating system doesn't allow you to run iptables commands, the standard kernel kube-proxy implementation will not work. Likewise, if you have an operating system which doesn't support <code>netsh</code>, it will not run in Windows userspace mode.</li>
</ul>
<h3 id=proxy-mode-userspace>User space proxy mode</h3>
<p>In this (legacy) mode, kube-proxy watches the Kubernetes control plane for the addition and
removal of Service and Endpoint objects. For each Service it opens a
port (randomly chosen) on the local node. Any connections to this "proxy port"
are proxied to one of the Service's backend Pods (as reported via
Endpoints). kube-proxy takes the <code>SessionAffinity</code> setting of the Service into
account when deciding which backend Pod to use.</p>
<p>Lastly, the user-space proxy installs iptables rules which capture traffic to
the Service's <code>clusterIP</code> (which is virtual) and <code>port</code>. The rules
redirect that traffic to the proxy port which proxies the backend Pod.</p>
<p>By default, kube-proxy in userspace mode chooses a backend via a round-robin algorithm.</p>
<p><img src=/images/docs/services-userspace-overview.svg alt="Services overview diagram for userspace proxy"></p>
<h3 id=proxy-mode-iptables><code>iptables</code> proxy mode</h3>
<p>In this mode, kube-proxy watches the Kubernetes control plane for the addition and
removal of Service and Endpoint objects. For each Service, it installs
iptables rules, which capture traffic to the Service's <code>clusterIP</code> and <code>port</code>,
and redirect that traffic to one of the Service's
backend sets. For each Endpoint object, it installs iptables rules which
select a backend Pod.</p>
<p>By default, kube-proxy in iptables mode chooses a backend at random.</p>
<p>Using iptables to handle traffic has a lower system overhead, because traffic
is handled by Linux netfilter without the need to switch between userspace and the
kernel space. This approach is also likely to be more reliable.</p>
<p>If kube-proxy is running in iptables mode and the first Pod that's selected
does not respond, the connection fails. This is different from userspace
mode: in that scenario, kube-proxy would detect that the connection to the first
Pod had failed and would automatically retry with a different backend Pod.</p>
<p>You can use Pod <a href=/docs/concepts/workloads/pods/pod-lifecycle/#container-probes>readiness probes</a>
to verify that backend Pods are working OK, so that kube-proxy in iptables mode
only sees backends that test out as healthy. Doing this means you avoid
having traffic sent via kube-proxy to a Pod that's known to have failed.</p>
<p><img src=/images/docs/services-iptables-overview.svg alt="Services overview diagram for iptables proxy"></p>
<h3 id=proxy-mode-ipvs>IPVS proxy mode</h3>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.11 [stable]</code>
</div>
<p>In <code>ipvs</code> mode, kube-proxy watches Kubernetes Services and Endpoints,
calls <code>netlink</code> interface to create IPVS rules accordingly and synchronizes
IPVS rules with Kubernetes Services and Endpoints periodically.
This control loop ensures that IPVS status matches the desired
state.
When accessing a Service, IPVS directs traffic to one of the backend Pods.</p>
<p>The IPVS proxy mode is based on netfilter hook function that is similar to
iptables mode, but uses a hash table as the underlying data structure and works
in the kernel space.
That means kube-proxy in IPVS mode redirects traffic with lower latency than
kube-proxy in iptables mode, with much better performance when synchronising
proxy rules. Compared to the other proxy modes, IPVS mode also supports a
higher throughput of network traffic.</p>
<p>IPVS provides more options for balancing traffic to backend Pods;
these are:</p>
<ul>
<li><code>rr</code>: round-robin</li>
<li><code>lc</code>: least connection (smallest number of open connections)</li>
<li><code>dh</code>: destination hashing</li>
<li><code>sh</code>: source hashing</li>
<li><code>sed</code>: shortest expected delay</li>
<li><code>nq</code>: never queue</li>
</ul>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> <p>To run kube-proxy in IPVS mode, you must make IPVS available on
the node before starting kube-proxy.</p>
<p>When kube-proxy starts in IPVS proxy mode, it verifies whether IPVS
kernel modules are available. If the IPVS kernel modules are not detected, then kube-proxy
falls back to running in iptables proxy mode.</p>
</div>
<p><img src=/images/docs/services-ipvs-overview.svg alt="Services overview diagram for IPVS proxy"></p>
<p>In these proxy models, the traffic bound for the Service's IP:Port is
proxied to an appropriate backend without the clients knowing anything
about Kubernetes or Services or Pods.</p>
<p>If you want to make sure that connections from a particular client
are passed to the same Pod each time, you can select the session affinity based
on the client's IP addresses by setting <code>service.spec.sessionAffinity</code> to "ClientIP"
(the default is "None").
You can also set the maximum session sticky time by setting
<code>service.spec.sessionAffinityConfig.clientIP.timeoutSeconds</code> appropriately.
(the default value is 10800, which works out to be 3 hours).</p>
<h2 id=multi-port-services>Multi-Port Services</h2>
<p>For some Services, you need to expose more than one port.
Kubernetes lets you configure multiple port definitions on a Service object.
When using multiple ports for a Service, you must give all of your ports names
so that these are unambiguous.
For example:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>MyApp<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>http<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>9376</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>https<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>443</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>9377</span><span style=color:#bbb>
</span></code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> <p>As with Kubernetes <a class=glossary-tooltip title="A client-provided string that refers to an object in a resource URL, such as /api/v1/pods/some-name." data-toggle=tooltip data-placement=top href=/docs/concepts/overview/working-with-objects/names target=_blank aria-label=names>names</a> in general, names for ports
must only contain lowercase alphanumeric characters and <code>-</code>. Port names must
also start and end with an alphanumeric character.</p>
<p>For example, the names <code>123-abc</code> and <code>web</code> are valid, but <code>123_abc</code> and <code>-web</code> are not.</p>
</div>
<h2 id=choosing-your-own-ip-address>Choosing your own IP address</h2>
<p>You can specify your own cluster IP address as part of a <code>Service</code> creation
request. To do this, set the <code>.spec.clusterIP</code> field. For example, if you
already have an existing DNS entry that you wish to reuse, or legacy systems
that are configured for a specific IP address and difficult to re-configure.</p>
<p>The IP address that you choose must be a valid IPv4 or IPv6 address from within the
<code>service-cluster-ip-range</code> CIDR range that is configured for the API server.
If you try to create a Service with an invalid clusterIP address value, the API
server will return a 422 HTTP status code to indicate that there's a problem.</p>
<h2 id=traffic-policies>Traffic policies</h2>
<h3 id=external-traffic-policy>External traffic policy</h3>
<p>You can set the <code>spec.externalTrafficPolicy</code> field to control how traffic from external sources is routed.
Valid values are <code>Cluster</code> and <code>Local</code>. Set the field to <code>Cluster</code> to route external traffic to all ready endpoints
and <code>Local</code> to only route to ready node-local endpoints. If the traffic policy is <code>Local</code> and there are are no node-local
endpoints, the kube-proxy does not forward any traffic for the relevant Service.</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> <div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.22 [alpha]</code>
</div>
<p>If you enable the <code>ProxyTerminatingEndpoints</code>
<a href=/docs/reference/command-line-tools-reference/feature-gates/>feature gate</a>
for the kube-proxy, the kube-proxy checks if the node
has local endpoints and whether or not all the local endpoints are marked as terminating.
If there are local endpoints and <strong>all</strong> of those are terminating, then the kube-proxy ignores
any external traffic policy of <code>Local</code>. Instead, whilst the node-local endpoints remain as all
terminating, the kube-proxy forwards traffic for that Service to healthy endpoints elsewhere,
as if the external traffic policy were set to <code>Cluster</code>.
This forwarding behavior for terminating endpoints exists to allow external load balancers to
gracefully drain connections that are backed by <code>NodePort</code> Services, even when the health check
node port starts to fail. Otherwise, traffic can be lost between the time a node is still in the node pool of a load
balancer and traffic is being dropped during the termination period of a pod.
</div>
<h3 id=internal-traffic-policy>Internal traffic policy</h3>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.22 [beta]</code>
</div>
<p>You can set the <code>spec.internalTrafficPolicy</code> field to control how traffic from internal sources is routed.
Valid values are <code>Cluster</code> and <code>Local</code>. Set the field to <code>Cluster</code> to route internal traffic to all ready endpoints
and <code>Local</code> to only route to ready node-local endpoints. If the traffic policy is <code>Local</code> and there are no node-local
endpoints, traffic is dropped by kube-proxy.</p>
<h2 id=discovering-services>Discovering services</h2>
<p>Kubernetes supports 2 primary modes of finding a Service - environment
variables and DNS.</p>
<h3 id=environment-variables>Environment variables</h3>
<p>When a Pod is run on a Node, the kubelet adds a set of environment variables
for each active Service. It adds <code>{SVCNAME}_SERVICE_HOST</code> and <code>{SVCNAME}_SERVICE_PORT</code> variables, where the Service name is upper-cased and dashes are converted to underscores. It also supports variables (see <a href=https://github.com/kubernetes/kubernetes/blob/dd2d12f6dc0e654c15d5db57a5f9f6ba61192726/pkg/kubelet/envvars/envvars.go#L72>makeLinkVariables</a>) that are compatible with Docker Engine's "<em><a href=https://docs.docker.com/network/links/>legacy container links</a></em>" feature.</p>
<p>For example, the Service <code>redis-master</code> which exposes TCP port 6379 and has been
allocated cluster IP address 10.0.0.11, produces the following environment
variables:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#b8860b>REDIS_MASTER_SERVICE_HOST</span><span style=color:#666>=</span>10.0.0.11
<span style=color:#b8860b>REDIS_MASTER_SERVICE_PORT</span><span style=color:#666>=</span><span style=color:#666>6379</span>
<span style=color:#b8860b>REDIS_MASTER_PORT</span><span style=color:#666>=</span>tcp://10.0.0.11:6379
<span style=color:#b8860b>REDIS_MASTER_PORT_6379_TCP</span><span style=color:#666>=</span>tcp://10.0.0.11:6379
<span style=color:#b8860b>REDIS_MASTER_PORT_6379_TCP_PROTO</span><span style=color:#666>=</span>tcp
<span style=color:#b8860b>REDIS_MASTER_PORT_6379_TCP_PORT</span><span style=color:#666>=</span><span style=color:#666>6379</span>
<span style=color:#b8860b>REDIS_MASTER_PORT_6379_TCP_ADDR</span><span style=color:#666>=</span>10.0.0.11
</code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> <p>When you have a Pod that needs to access a Service, and you are using
the environment variable method to publish the port and cluster IP to the client
Pods, you must create the Service <em>before</em> the client Pods come into existence.
Otherwise, those client Pods won't have their environment variables populated.</p>
<p>If you only use DNS to discover the cluster IP for a Service, you don't need to
worry about this ordering issue.</p>
</div>
<h3 id=dns>DNS</h3>
<p>You can (and almost always should) set up a DNS service for your Kubernetes
cluster using an <a href=/docs/concepts/cluster-administration/addons/>add-on</a>.</p>
<p>A cluster-aware DNS server, such as CoreDNS, watches the Kubernetes API for new
Services and creates a set of DNS records for each one. If DNS has been enabled
throughout your cluster then all Pods should automatically be able to resolve
Services by their DNS name.</p>
<p>For example, if you have a Service called <code>my-service</code> in a Kubernetes
namespace <code>my-ns</code>, the control plane and the DNS Service acting together
create a DNS record for <code>my-service.my-ns</code>. Pods in the <code>my-ns</code> namespace
should be able to find the service by doing a name lookup for <code>my-service</code>
(<code>my-service.my-ns</code> would also work).</p>
<p>Pods in other namespaces must qualify the name as <code>my-service.my-ns</code>. These names
will resolve to the cluster IP assigned for the Service.</p>
<p>Kubernetes also supports DNS SRV (Service) records for named ports. If the
<code>my-service.my-ns</code> Service has a port named <code>http</code> with the protocol set to
<code>TCP</code>, you can do a DNS SRV query for <code>_http._tcp.my-service.my-ns</code> to discover
the port number for <code>http</code>, as well as the IP address.</p>
<p>The Kubernetes DNS server is the only way to access <code>ExternalName</code> Services.
You can find more information about <code>ExternalName</code> resolution in
<a href=/docs/concepts/services-networking/dns-pod-service/>DNS Pods and Services</a>.</p>
<h2 id=headless-services>Headless Services</h2>
<p>Sometimes you don't need load-balancing and a single Service IP. In
this case, you can create what are termed "headless" Services, by explicitly
specifying <code>"None"</code> for the cluster IP (<code>.spec.clusterIP</code>).</p>
<p>You can use a headless Service to interface with other service discovery mechanisms,
without being tied to Kubernetes' implementation.</p>
<p>For headless <code>Services</code>, a cluster IP is not allocated, kube-proxy does not handle
these Services, and there is no load balancing or proxying done by the platform
for them. How DNS is automatically configured depends on whether the Service has
selectors defined:</p>
<h3 id=with-selectors>With selectors</h3>
<p>For headless Services that define selectors, the endpoints controller creates
<code>Endpoints</code> records in the API, and modifies the DNS configuration to return
A records (IP addresses) that point directly to the <code>Pods</code> backing the <code>Service</code>.</p>
<h3 id=without-selectors>Without selectors</h3>
<p>For headless Services that do not define selectors, the endpoints controller does
not create <code>Endpoints</code> records. However, the DNS system looks for and configures
either:</p>
<ul>
<li>CNAME records for <a href=#externalname><code>ExternalName</code></a>-type Services.</li>
<li>A records for any <code>Endpoints</code> that share a name with the Service, for all
other types.</li>
</ul>
<h2 id=publishing-services-service-types>Publishing Services (ServiceTypes)</h2>
<p>For some parts of your application (for example, frontends) you may want to expose a
Service onto an external IP address, that's outside of your cluster.</p>
<p>Kubernetes <code>ServiceTypes</code> allow you to specify what kind of Service you want.
The default is <code>ClusterIP</code>.</p>
<p><code>Type</code> values and their behaviors are:</p>
<ul>
<li><code>ClusterIP</code>: Exposes the Service on a cluster-internal IP. Choosing this value
makes the Service only reachable from within the cluster. This is the
default <code>ServiceType</code>.</li>
<li><a href=#type-nodeport><code>NodePort</code></a>: Exposes the Service on each Node's IP at a static port
(the <code>NodePort</code>). A <code>ClusterIP</code> Service, to which the <code>NodePort</code> Service
routes, is automatically created. You'll be able to contact the <code>NodePort</code> Service,
from outside the cluster,
by requesting <code>&lt;NodeIP>:&lt;NodePort></code>.</li>
<li><a href=#loadbalancer><code>LoadBalancer</code></a>: Exposes the Service externally using a cloud
provider's load balancer. <code>NodePort</code> and <code>ClusterIP</code> Services, to which the external
load balancer routes, are automatically created.</li>
<li><a href=#externalname><code>ExternalName</code></a>: Maps the Service to the contents of the
<code>externalName</code> field (e.g. <code>foo.bar.example.com</code>), by returning a <code>CNAME</code> record
with its value. No proxying of any kind is set up.
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> You need either <code>kube-dns</code> version 1.7 or CoreDNS version 0.0.8 or higher
to use the <code>ExternalName</code> type.
</div></li>
</ul>
<p>You can also use <a href=/docs/concepts/services-networking/ingress/>Ingress</a> to expose your Service. Ingress is not a Service type, but it acts as the entry point for your cluster. It lets you consolidate your routing rules
into a single resource as it can expose multiple services under the same IP address.</p>
<h3 id=type-nodeport>Type NodePort</h3>
<p>If you set the <code>type</code> field to <code>NodePort</code>, the Kubernetes control plane
allocates a port from a range specified by <code>--service-node-port-range</code> flag (default: 30000-32767).
Each node proxies that port (the same port number on every Node) into your Service.
Your Service reports the allocated port in its <code>.spec.ports[*].nodePort</code> field.</p>
<p>If you want to specify particular IP(s) to proxy the port, you can set the
<code>--nodeport-addresses</code> flag for kube-proxy or the equivalent <code>nodePortAddresses</code>
field of the
<a href=/docs/reference/config-api/kube-proxy-config.v1alpha1/>kube-proxy configuration file</a>
to particular IP block(s).</p>
<p>This flag takes a comma-delimited list of IP blocks (e.g. <code>10.0.0.0/8</code>, <code>192.0.2.0/25</code>) to specify IP address ranges that kube-proxy should consider as local to this node.</p>
<p>For example, if you start kube-proxy with the <code>--nodeport-addresses=127.0.0.0/8</code> flag, kube-proxy only selects the loopback interface for NodePort Services. The default for <code>--nodeport-addresses</code> is an empty list. This means that kube-proxy should consider all available network interfaces for NodePort. (That's also compatible with earlier Kubernetes releases).</p>
<p>If you want a specific port number, you can specify a value in the <code>nodePort</code>
field. The control plane will either allocate you that port or report that
the API transaction failed.
This means that you need to take care of possible port collisions yourself.
You also have to use a valid port number, one that's inside the range configured
for NodePort use.</p>
<p>Using a NodePort gives you the freedom to set up your own load balancing solution,
to configure environments that are not fully supported by Kubernetes, or even
to expose one or more nodes' IPs directly.</p>
<p>Note that this Service is visible as <code>&lt;NodeIP>:spec.ports[*].nodePort</code>
and <code>.spec.clusterIP:spec.ports[*].port</code>.
If the <code>--nodeport-addresses</code> flag for kube-proxy or the equivalent field
in the kube-proxy configuration file is set, <code>&lt;NodeIP></code> would be filtered node IP(s).</p>
<p>For example:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>NodePort<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>MyApp<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># By default and for convenience, the `targetPort` is set to the same value as the `port` field.</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># Optional field</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># By default and for convenience, the Kubernetes control plane will allocate a port from a range (default: 30000-32767)</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>nodePort</span>:<span style=color:#bbb> </span><span style=color:#666>30007</span><span style=color:#bbb>
</span></code></pre></div><h3 id=loadbalancer>Type LoadBalancer</h3>
<p>On cloud providers which support external load balancers, setting the <code>type</code>
field to <code>LoadBalancer</code> provisions a load balancer for your Service.
The actual creation of the load balancer happens asynchronously, and
information about the provisioned balancer is published in the Service's
<code>.status.loadBalancer</code> field.
For example:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>MyApp<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>9376</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>clusterIP</span>:<span style=color:#bbb> </span><span style=color:#666>10.0.171.239</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>LoadBalancer<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>loadBalancer</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>ingress</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>ip</span>:<span style=color:#bbb> </span><span style=color:#666>192.0.2.127</span><span style=color:#bbb>
</span></code></pre></div><p>Traffic from the external load balancer is directed at the backend Pods. The cloud provider decides how it is load balanced.</p>
<p>Some cloud providers allow you to specify the <code>loadBalancerIP</code>. In those cases, the load-balancer is created
with the user-specified <code>loadBalancerIP</code>. If the <code>loadBalancerIP</code> field is not specified,
the loadBalancer is set up with an ephemeral IP address. If you specify a <code>loadBalancerIP</code>
but your cloud provider does not support the feature, the <code>loadbalancerIP</code> field that you
set is ignored.</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> <p>On <strong>Azure</strong>, if you want to use a user-specified public type <code>loadBalancerIP</code>, you first need
to create a static type public IP address resource. This public IP address resource should
be in the same resource group of the other automatically created resources of the cluster.
For example, <code>MC_myResourceGroup_myAKSCluster_eastus</code>.</p>
<p>Specify the assigned IP address as loadBalancerIP. Ensure that you have updated the securityGroupName in the cloud provider configuration file. For information about troubleshooting <code>CreatingLoadBalancerFailed</code> permission issues see, <a href=https://docs.microsoft.com/en-us/azure/aks/static-ip>Use a static IP address with the Azure Kubernetes Service (AKS) load balancer</a> or <a href=https://github.com/Azure/AKS/issues/357>CreatingLoadBalancerFailed on AKS cluster with advanced networking</a>.</p>
</div>
<h4 id=load-balancers-with-mixed-protocol-types>Load balancers with mixed protocol types</h4>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.20 [alpha]</code>
</div>
<p>By default, for LoadBalancer type of Services, when there is more than one port defined, all
ports must have the same protocol, and the protocol must be one which is supported
by the cloud provider.</p>
<p>If the feature gate <code>MixedProtocolLBService</code> is enabled for the kube-apiserver it is allowed to use different protocols when there is more than one port defined.</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> The set of protocols that can be used for LoadBalancer type of Services is still defined by the cloud provider.
</div>
<h4 id=load-balancer-nodeport-allocation>Disabling load balancer NodePort allocation</h4>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.22 [beta]</code>
</div>
<p>You can optionally disable node port allocation for a Service of <code>type=LoadBalancer</code>, by setting
the field <code>spec.allocateLoadBalancerNodePorts</code> to <code>false</code>. This should only be used for load balancer implementations
that route traffic directly to pods as opposed to using node ports. By default, <code>spec.allocateLoadBalancerNodePorts</code>
is <code>true</code> and type LoadBalancer Services will continue to allocate node ports. If <code>spec.allocateLoadBalancerNodePorts</code>
is set to <code>false</code> on an existing Service with allocated node ports, those node ports will <strong>not</strong> be de-allocated automatically.
You must explicitly remove the <code>nodePorts</code> entry in every Service port to de-allocate those node ports.
Your cluster must have the <code>ServiceLBNodePortControl</code>
<a href=/docs/reference/command-line-tools-reference/feature-gates/>feature gate</a>
enabled to use this field.
For Kubernetes v1.23, this feature gate is enabled by default,
and you can use the <code>spec.allocateLoadBalancerNodePorts</code> field. For clusters running
other versions of Kubernetes, check the documentation for that release.</p>
<h4 id=load-balancer-class>Specifying class of load balancer implementation</h4>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.22 [beta]</code>
</div>
<p><code>spec.loadBalancerClass</code> enables you to use a load balancer implementation other than the cloud provider default.
Your cluster must have the <code>ServiceLoadBalancerClass</code> <a href=/docs/reference/command-line-tools-reference/feature-gates/>feature gate</a> enabled to use this field. For Kubernetes v1.23, this feature gate is enabled by default. For clusters running
other versions of Kubernetes, check the documentation for that release.
By default, <code>spec.loadBalancerClass</code> is <code>nil</code> and a <code>LoadBalancer</code> type of Service uses
the cloud provider's default load balancer implementation if the cluster is configured with
a cloud provider using the <code>--cloud-provider</code> component flag.
If <code>spec.loadBalancerClass</code> is specified, it is assumed that a load balancer
implementation that matches the specified class is watching for Services.
Any default load balancer implementation (for example, the one provided by
the cloud provider) will ignore Services that have this field set.
<code>spec.loadBalancerClass</code> can be set on a Service of type <code>LoadBalancer</code> only.
Once set, it cannot be changed.
The value of <code>spec.loadBalancerClass</code> must be a label-style identifier,
with an optional prefix such as "<code>internal-vip</code>" or "<code>example.com/internal-vip</code>".
Unprefixed names are reserved for end-users.</p>
<h4 id=internal-load-balancer>Internal load balancer</h4>
<p>In a mixed environment it is sometimes necessary to route traffic from Services inside the same
(virtual) network address block.</p>
<p>In a split-horizon DNS environment you would need two Services to be able to route both external and internal traffic to your endpoints.</p>
<p>To set an internal load balancer, add one of the following annotations to your Service
depending on the cloud Service provider you're using.</p>
<ul class="nav nav-tabs" id=service-tabs role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#service-tabs-0 role=tab aria-controls=service-tabs-0 aria-selected=true>Default</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#service-tabs-1 role=tab aria-controls=service-tabs-1>GCP</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#service-tabs-2 role=tab aria-controls=service-tabs-2>AWS</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#service-tabs-3 role=tab aria-controls=service-tabs-3>Azure</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#service-tabs-4 role=tab aria-controls=service-tabs-4>IBM Cloud</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#service-tabs-5 role=tab aria-controls=service-tabs-5>OpenStack</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#service-tabs-6 role=tab aria-controls=service-tabs-6>Baidu Cloud</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#service-tabs-7 role=tab aria-controls=service-tabs-7>Tencent Cloud</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#service-tabs-8 role=tab aria-controls=service-tabs-8>Alibaba Cloud</a></li></ul>
<div class=tab-content id=service-tabs><div id=service-tabs-0 class="tab-pane show active" role=tabpanel aria-labelledby=service-tabs-0>
<p><p>Select one of the tabs.</p>
</div>
<div id=service-tabs-1 class=tab-pane role=tabpanel aria-labelledby=service-tabs-1>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>[...]<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cloud.google.com/load-balancer-type</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;Internal&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span>[...]<span style=color:#bbb>
</span></code></pre></div></div>
<div id=service-tabs-2 class=tab-pane role=tabpanel aria-labelledby=service-tabs-2>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>[...]<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-internal</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span>[...]<span style=color:#bbb>
</span></code></pre></div></div>
<div id=service-tabs-3 class=tab-pane role=tabpanel aria-labelledby=service-tabs-3>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>[...]<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/azure-load-balancer-internal</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span>[...]<span style=color:#bbb>
</span></code></pre></div></div>
<div id=service-tabs-4 class=tab-pane role=tabpanel aria-labelledby=service-tabs-4>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>[...]<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.kubernetes.io/ibm-load-balancer-cloud-provider-ip-type</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;private&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span>[...]<span style=color:#bbb>
</span></code></pre></div></div>
<div id=service-tabs-5 class=tab-pane role=tabpanel aria-labelledby=service-tabs-5>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>[...]<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/openstack-internal-load-balancer</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span>[...]<span style=color:#bbb>
</span></code></pre></div></div>
<div id=service-tabs-6 class=tab-pane role=tabpanel aria-labelledby=service-tabs-6>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>[...]<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/cce-load-balancer-internal-vpc</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span>[...]<span style=color:#bbb>
</span></code></pre></div></div>
<div id=service-tabs-7 class=tab-pane role=tabpanel aria-labelledby=service-tabs-7>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>[...]<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>service.kubernetes.io/qcloud-loadbalancer-internal-subnetid</span>:<span style=color:#bbb> </span>subnet-xxxxx<span style=color:#bbb>
</span><span style=color:#bbb></span>[...]<span style=color:#bbb>
</span></code></pre></div></div>
<div id=service-tabs-8 class=tab-pane role=tabpanel aria-labelledby=service-tabs-8>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>[...]<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/alibaba-cloud-loadbalancer-address-type</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;intranet&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span>[...]<span style=color:#bbb>
</span></code></pre></div></div></div>
<h4 id=ssl-support-on-aws>TLS support on AWS</h4>
<p>For partial TLS / SSL support on clusters running on AWS, you can add three
annotations to a <code>LoadBalancer</code> service:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-ssl-cert</span>:<span style=color:#bbb> </span>arn:aws:acm:us-east-1:123456789012:certificate/12345678-1234-1234-1234-123456789012<span style=color:#bbb>
</span></code></pre></div><p>The first specifies the ARN of the certificate to use. It can be either a
certificate from a third party issuer that was uploaded to IAM or one created
within AWS Certificate Manager.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-backend-protocol</span>:<span style=color:#bbb> </span>(https|http|ssl|tcp)<span style=color:#bbb>
</span></code></pre></div><p>The second annotation specifies which protocol a Pod speaks. For HTTPS and
SSL, the ELB expects the Pod to authenticate itself over the encrypted
connection, using a certificate.</p>
<p>HTTP and HTTPS selects layer 7 proxying: the ELB terminates
the connection with the user, parses headers, and injects the <code>X-Forwarded-For</code>
header with the user's IP address (Pods only see the IP address of the
ELB at the other end of its connection) when forwarding requests.</p>
<p>TCP and SSL selects layer 4 proxying: the ELB forwards traffic without
modifying the headers.</p>
<p>In a mixed-use environment where some ports are secured and others are left unencrypted,
you can use the following annotations:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-backend-protocol</span>:<span style=color:#bbb> </span>http<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-ssl-ports</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;443,8443&#34;</span><span style=color:#bbb>
</span></code></pre></div><p>In the above example, if the Service contained three ports, <code>80</code>, <code>443</code>, and
<code>8443</code>, then <code>443</code> and <code>8443</code> would use the SSL certificate, but <code>80</code> would be proxied HTTP.</p>
<p>From Kubernetes v1.9 onwards you can use <a href=https://docs.aws.amazon.com/elasticloadbalancing/latest/classic/elb-security-policy-table.html>predefined AWS SSL policies</a> with HTTPS or SSL listeners for your Services.
To see which policies are available for use, you can use the <code>aws</code> command line tool:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>aws elb describe-load-balancer-policies --query <span style=color:#b44>&#39;PolicyDescriptions[].PolicyName&#39;</span>
</code></pre></div><p>You can then specify any one of those policies using the
"<code>service.beta.kubernetes.io/aws-load-balancer-ssl-negotiation-policy</code>"
annotation; for example:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-ssl-negotiation-policy</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;ELBSecurityPolicy-TLS-1-2-2017-01&#34;</span><span style=color:#bbb>
</span></code></pre></div><h4 id=proxy-protocol-support-on-aws>PROXY protocol support on AWS</h4>
<p>To enable <a href=https://www.haproxy.org/download/1.8/doc/proxy-protocol.txt>PROXY protocol</a>
support for clusters running on AWS, you can use the following service
annotation:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-proxy-protocol</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;*&#34;</span><span style=color:#bbb>
</span></code></pre></div><p>Since version 1.3.0, the use of this annotation applies to all ports proxied by the ELB
and cannot be configured otherwise.</p>
<h4 id=elb-access-logs-on-aws>ELB Access Logs on AWS</h4>
<p>There are several annotations to manage access logs for ELB Services on AWS.</p>
<p>The annotation <code>service.beta.kubernetes.io/aws-load-balancer-access-log-enabled</code>
controls whether access logs are enabled.</p>
<p>The annotation <code>service.beta.kubernetes.io/aws-load-balancer-access-log-emit-interval</code>
controls the interval in minutes for publishing the access logs. You can specify
an interval of either 5 or 60 minutes.</p>
<p>The annotation <code>service.beta.kubernetes.io/aws-load-balancer-access-log-s3-bucket-name</code>
controls the name of the Amazon S3 bucket where load balancer access logs are
stored.</p>
<p>The annotation <code>service.beta.kubernetes.io/aws-load-balancer-access-log-s3-bucket-prefix</code>
specifies the logical hierarchy you created for your Amazon S3 bucket.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-access-log-enabled</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># Specifies whether access logs are enabled for the load balancer</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-access-log-emit-interval</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;60&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># The interval for publishing the access logs. You can specify an interval of either 5 or 60 (minutes).</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-access-log-s3-bucket-name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;my-bucket&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># The name of the Amazon S3 bucket where the access logs are stored</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-access-log-s3-bucket-prefix</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;my-bucket-prefix/prod&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># The logical hierarchy you created for your Amazon S3 bucket, for example `my-bucket-prefix/prod`</span><span style=color:#bbb>
</span></code></pre></div><h4 id=connection-draining-on-aws>Connection Draining on AWS</h4>
<p>Connection draining for Classic ELBs can be managed with the annotation
<code>service.beta.kubernetes.io/aws-load-balancer-connection-draining-enabled</code> set
to the value of <code>"true"</code>. The annotation
<code>service.beta.kubernetes.io/aws-load-balancer-connection-draining-timeout</code> can
also be used to set maximum time, in seconds, to keep the existing connections open before deregistering the instances.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-connection-draining-enabled</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-connection-draining-timeout</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;60&#34;</span><span style=color:#bbb>
</span></code></pre></div><h4 id=other-elb-annotations>Other ELB annotations</h4>
<p>There are other annotations to manage Classic Elastic Load Balancers that are described below.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-connection-idle-timeout</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;60&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># The time, in seconds, that the connection is allowed to be idle (no data has been sent over the connection) before it is closed by the load balancer</span><span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-cross-zone-load-balancing-enabled</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># Specifies whether cross-zone load balancing is enabled for the load balancer</span><span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-additional-resource-tags</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;environment=prod,owner=devops&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># A comma-separated list of key-value pairs which will be recorded as</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># additional tags in the ELB.</span><span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-healthcheck-healthy-threshold</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># The number of successive successful health checks required for a backend to</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># be considered healthy for traffic. Defaults to 2, must be between 2 and 10</span><span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-healthcheck-unhealthy-threshold</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;3&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># The number of unsuccessful health checks required for a backend to be</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># considered unhealthy for traffic. Defaults to 6, must be between 2 and 10</span><span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-healthcheck-interval</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;20&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># The approximate interval, in seconds, between health checks of an</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># individual instance. Defaults to 10, must be between 5 and 300</span><span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-healthcheck-timeout</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;5&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># The amount of time, in seconds, during which no response means a failed</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># health check. This value must be less than the service.beta.kubernetes.io/aws-load-balancer-healthcheck-interval</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># value. Defaults to 5, must be between 2 and 60</span><span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-security-groups</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;sg-53fae93f&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># A list of existing security groups to be configured on the ELB created. Unlike the annotation</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># service.beta.kubernetes.io/aws-load-balancer-extra-security-groups, this replaces all other security groups previously assigned to the ELB and also overrides the creation </span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># of a uniquely generated security group for this ELB.</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># The first security group ID on this list is used as a source to permit incoming traffic to target worker nodes (service traffic and health checks).</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># If multiple ELBs are configured with the same security group ID, only a single permit line will be added to the worker node security groups, that means if you delete any</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># of those ELBs it will remove the single permit line and block access for all ELBs that shared the same security group ID.</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># This can cause a cross-service outage if not used properly</span><span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-extra-security-groups</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;sg-53fae93f,sg-42efd82e&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic>#  A list of additional security groups to be added to the created ELB, this leaves the uniquely generated security group in place, this ensures that every ELB</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># has a unique security group ID and a matching permit line to allow traffic to the target worker nodes (service traffic and health checks).</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># Security groups defined here can be shared between services. </span><span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-target-node-labels</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;ingress-gw,gw-name=public-api&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># A comma separated list of key-value pairs which are used</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># to select the target nodes for the load balancer</span><span style=color:#bbb>
</span></code></pre></div><h4 id=aws-nlb-support>Network Load Balancer support on AWS</h4>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.15 [beta]</code>
</div>
<p>To use a Network Load Balancer on AWS, use the annotation <code>service.beta.kubernetes.io/aws-load-balancer-type</code> with the value set to <code>nlb</code>.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-type</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;nlb&#34;</span><span style=color:#bbb>
</span></code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> NLB only works with certain instance classes; see the <a href=https://docs.aws.amazon.com/elasticloadbalancing/latest/network/target-group-register-targets.html#register-deregister-targets>AWS documentation</a>
on Elastic Load Balancing for a list of supported instance types.
</div>
<p>Unlike Classic Elastic Load Balancers, Network Load Balancers (NLBs) forward the
client's IP address through to the node. If a Service's <code>.spec.externalTrafficPolicy</code>
is set to <code>Cluster</code>, the client's IP address is not propagated to the end
Pods.</p>
<p>By setting <code>.spec.externalTrafficPolicy</code> to <code>Local</code>, the client IP addresses is
propagated to the end Pods, but this could result in uneven distribution of
traffic. Nodes without any Pods for a particular LoadBalancer Service will fail
the NLB Target Group's health check on the auto-assigned
<code>.spec.healthCheckNodePort</code> and not receive any traffic.</p>
<p>In order to achieve even traffic, either use a DaemonSet or specify a
<a href=/docs/concepts/scheduling-eviction/assign-pod-node/#affinity-and-anti-affinity>pod anti-affinity</a>
to not locate on the same node.</p>
<p>You can also use NLB Services with the <a href=/docs/concepts/services-networking/service/#internal-load-balancer>internal load balancer</a>
annotation.</p>
<p>In order for client traffic to reach instances behind an NLB, the Node security
groups are modified with the following IP rules:</p>
<table>
<thead>
<tr>
<th>Rule</th>
<th>Protocol</th>
<th>Port(s)</th>
<th>IpRange(s)</th>
<th>IpRange Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Health Check</td>
<td>TCP</td>
<td>NodePort(s) (<code>.spec.healthCheckNodePort</code> for <code>.spec.externalTrafficPolicy = Local</code>)</td>
<td>Subnet CIDR</td>
<td>kubernetes.io/rule/nlb/health=&lt;loadBalancerName></td>
</tr>
<tr>
<td>Client Traffic</td>
<td>TCP</td>
<td>NodePort(s)</td>
<td><code>.spec.loadBalancerSourceRanges</code> (defaults to <code>0.0.0.0/0</code>)</td>
<td>kubernetes.io/rule/nlb/client=&lt;loadBalancerName></td>
</tr>
<tr>
<td>MTU Discovery</td>
<td>ICMP</td>
<td>3,4</td>
<td><code>.spec.loadBalancerSourceRanges</code> (defaults to <code>0.0.0.0/0</code>)</td>
<td>kubernetes.io/rule/nlb/mtu=&lt;loadBalancerName></td>
</tr>
</tbody>
</table>
<p>In order to limit which client IP's can access the Network Load Balancer,
specify <code>loadBalancerSourceRanges</code>.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>loadBalancerSourceRanges</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;143.231.0.0/16&#34;</span><span style=color:#bbb>
</span></code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> If <code>.spec.loadBalancerSourceRanges</code> is not set, Kubernetes
allows traffic from <code>0.0.0.0/0</code> to the Node Security Group(s). If nodes have
public IP addresses, be aware that non-NLB traffic can also reach all instances
in those modified security groups.
</div>
<p>Further documentation on annotations for Elastic IPs and other common use-cases may be found
in the <a href=https://kubernetes-sigs.github.io/aws-load-balancer-controller/latest/guide/service/annotations/>AWS Load Balancer Controller documentation</a>.</p>
<h4 id=other-clb-annotations-on-tencent-kubernetes-engine-tke>Other CLB annotations on Tencent Kubernetes Engine (TKE)</h4>
<p>There are other annotations for managing Cloud Load Balancers on TKE as shown below.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># Bind Loadbalancers with specified nodes</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.kubernetes.io/qcloud-loadbalancer-backends-label</span>:<span style=color:#bbb> </span>key in (value1, value2)<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># ID of an existing load balancer</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span>service.kubernetes.io/tke-existed-lbid：lb-6swtxxxx<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># Custom parameters for the load balancer (LB), does not support modification of LB type yet</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.kubernetes.io/service.extensiveParameters</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># Custom parameters for the LB listener</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.kubernetes.io/service.listenerParameters</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># Specifies the type of Load balancer;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># valid values: classic (Classic Cloud Load Balancer) or application (Application Cloud Load Balancer)</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.kubernetes.io/loadbalance-type</span>:<span style=color:#bbb> </span>xxxxx<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># Specifies the public network bandwidth billing method;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># valid values: TRAFFIC_POSTPAID_BY_HOUR(bill-by-traffic) and BANDWIDTH_POSTPAID_BY_HOUR (bill-by-bandwidth).</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.kubernetes.io/qcloud-loadbalancer-internet-charge-type</span>:<span style=color:#bbb> </span>xxxxxx<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># Specifies the bandwidth value (value range: [1,2000] Mbps).</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.kubernetes.io/qcloud-loadbalancer-internet-max-bandwidth-out</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;10&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># When this annotation is set，the loadbalancers will only register nodes</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># with pod running on it, otherwise all nodes will be registered.</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.kubernetes.io/local-svc-only-bind-node-with-pod</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></code></pre></div><h3 id=externalname>Type ExternalName</h3>
<p>Services of type ExternalName map a Service to a DNS name, not to a typical selector such as
<code>my-service</code> or <code>cassandra</code>. You specify these Services with the <code>spec.externalName</code> parameter.</p>
<p>This Service definition, for example, maps
the <code>my-service</code> Service in the <code>prod</code> namespace to <code>my.database.example.com</code>:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>prod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>ExternalName<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>externalName</span>:<span style=color:#bbb> </span>my.database.example.com<span style=color:#bbb>
</span></code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> ExternalName accepts an IPv4 address string, but as a DNS name comprised of digits, not as an IP address. ExternalNames that resemble IPv4 addresses are not resolved by CoreDNS or ingress-nginx because ExternalName
is intended to specify a canonical DNS name. To hardcode an IP address, consider using
<a href=#headless-services>headless Services</a>.
</div>
<p>When looking up the host <code>my-service.prod.svc.cluster.local</code>, the cluster DNS Service
returns a <code>CNAME</code> record with the value <code>my.database.example.com</code>. Accessing
<code>my-service</code> works in the same way as other Services but with the crucial
difference that redirection happens at the DNS level rather than via proxying or
forwarding. Should you later decide to move your database into your cluster, you
can start its Pods, add appropriate selectors or endpoints, and change the
Service's <code>type</code>.</p>
<div class="alert alert-danger warning callout" role=alert>
<strong>Warning:</strong> <p>You may have trouble using ExternalName for some common protocols, including HTTP and HTTPS. If you use ExternalName then the hostname used by clients inside your cluster is different from the name that the ExternalName references.</p>
<p>For protocols that use hostnames this difference may lead to errors or unexpected responses. HTTP requests will have a <code>Host:</code> header that the origin server does not recognize; TLS servers will not be able to provide a certificate matching the hostname that the client connected to.</p>
</div>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> This section is indebted to the <a href=https://akomljen.com/kubernetes-tips-part-1/>Kubernetes Tips - Part
1</a> blog post from <a href=https://akomljen.com/>Alen Komljen</a>.
</div>
<h3 id=external-ips>External IPs</h3>
<p>If there are external IPs that route to one or more cluster nodes, Kubernetes Services can be exposed on those
<code>externalIPs</code>. Traffic that ingresses into the cluster with the external IP (as destination IP), on the Service port,
will be routed to one of the Service endpoints. <code>externalIPs</code> are not managed by Kubernetes and are the responsibility
of the cluster administrator.</p>
<p>In the Service spec, <code>externalIPs</code> can be specified along with any of the <code>ServiceTypes</code>.
In the example below, "<code>my-service</code>" can be accessed by clients on "<code>80.11.12.10:80</code>" (<code>externalIP:port</code>)</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>MyApp<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>http<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>9376</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>externalIPs</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:#666>80.11.12.10</span><span style=color:#bbb>
</span></code></pre></div><h2 id=shortcomings>Shortcomings</h2>
<p>Using the userspace proxy for VIPs works at small to medium scale, but will
not scale to very large clusters with thousands of Services. The
<a href=https://github.com/kubernetes/kubernetes/issues/1107>original design proposal for portals</a>
has more details on this.</p>
<p>Using the userspace proxy obscures the source IP address of a packet accessing
a Service.
This makes some kinds of network filtering (firewalling) impossible. The iptables
proxy mode does not
obscure in-cluster source IPs, but it does still impact clients coming through
a load balancer or node-port.</p>
<p>The <code>Type</code> field is designed as nested functionality - each level adds to the
previous. This is not strictly required on all cloud providers (e.g. Google Compute Engine does
not need to allocate a <code>NodePort</code> to make <code>LoadBalancer</code> work, but AWS does)
but the current API requires it.</p>
<h2 id=the-gory-details-of-virtual-ips>Virtual IP implementation</h2>
<p>The previous information should be sufficient for many people who want to
use Services. However, there is a lot going on behind the scenes that may be
worth understanding.</p>
<h3 id=avoiding-collisions>Avoiding collisions</h3>
<p>One of the primary philosophies of Kubernetes is that you should not be
exposed to situations that could cause your actions to fail through no fault
of your own. For the design of the Service resource, this means not making
you choose your own port number if that choice might collide with
someone else's choice. That is an isolation failure.</p>
<p>In order to allow you to choose a port number for your Services, we must
ensure that no two Services can collide. Kubernetes does that by allocating each
Service its own IP address.</p>
<p>To ensure each Service receives a unique IP, an internal allocator atomically
updates a global allocation map in <a class=glossary-tooltip title="Consistent and highly-available key value store used as Kubernetes' backing store for all cluster data." data-toggle=tooltip data-placement=top href=/docs/tasks/administer-cluster/configure-upgrade-etcd/ target=_blank aria-label=etcd>etcd</a>
prior to creating each Service. The map object must exist in the registry for
Services to get IP address assignments, otherwise creations will
fail with a message indicating an IP address could not be allocated.</p>
<p>In the control plane, a background controller is responsible for creating that
map (needed to support migrating from older versions of Kubernetes that used
in-memory locking). Kubernetes also uses controllers to check for invalid
assignments (eg due to administrator intervention) and for cleaning up allocated
IP addresses that are no longer used by any Services.</p>
<h3 id=ips-and-vips>Service IP addresses</h3>
<p>Unlike Pod IP addresses, which actually route to a fixed destination,
Service IPs are not actually answered by a single host. Instead, kube-proxy
uses iptables (packet processing logic in Linux) to define <em>virtual</em> IP addresses
which are transparently redirected as needed. When clients connect to the
VIP, their traffic is automatically transported to an appropriate endpoint.
The environment variables and DNS for Services are actually populated in
terms of the Service's virtual IP address (and port).</p>
<p>kube-proxy supports three proxy modes—userspace, iptables and IPVS—which
each operate slightly differently.</p>
<h4 id=userspace>Userspace</h4>
<p>As an example, consider the image processing application described above.
When the backend Service is created, the Kubernetes master assigns a virtual
IP address, for example 10.0.0.1. Assuming the Service port is 1234, the
Service is observed by all of the kube-proxy instances in the cluster.
When a proxy sees a new Service, it opens a new random port, establishes an
iptables redirect from the virtual IP address to this new port, and starts accepting
connections on it.</p>
<p>When a client connects to the Service's virtual IP address, the iptables
rule kicks in, and redirects the packets to the proxy's own port.
The "Service proxy" chooses a backend, and starts proxying traffic from the client to the backend.</p>
<p>This means that Service owners can choose any port they want without risk of
collision. Clients can connect to an IP and port, without being aware
of which Pods they are actually accessing.</p>
<h4 id=iptables>iptables</h4>
<p>Again, consider the image processing application described above.
When the backend Service is created, the Kubernetes control plane assigns a virtual
IP address, for example 10.0.0.1. Assuming the Service port is 1234, the
Service is observed by all of the kube-proxy instances in the cluster.
When a proxy sees a new Service, it installs a series of iptables rules which
redirect from the virtual IP address to per-Service rules. The per-Service
rules link to per-Endpoint rules which redirect traffic (using destination NAT)
to the backends.</p>
<p>When a client connects to the Service's virtual IP address the iptables rule kicks in.
A backend is chosen (either based on session affinity or randomly) and packets are
redirected to the backend. Unlike the userspace proxy, packets are never
copied to userspace, the kube-proxy does not have to be running for the virtual
IP address to work, and Nodes see traffic arriving from the unaltered client IP
address.</p>
<p>This same basic flow executes when traffic comes in through a node-port or
through a load-balancer, though in those cases the client IP does get altered.</p>
<h4 id=ipvs>IPVS</h4>
<p>iptables operations slow down dramatically in large scale cluster e.g 10,000 Services.
IPVS is designed for load balancing and based on in-kernel hash tables. So you can achieve performance consistency in large number of Services from IPVS-based kube-proxy. Meanwhile, IPVS-based kube-proxy has more sophisticated load balancing algorithms (least conns, locality, weighted, persistence).</p>
<h2 id=api-object>API Object</h2>
<p>Service is a top-level resource in the Kubernetes REST API. You can find more details
about the API object at: <a href=/docs/reference/generated/kubernetes-api/v1.23/#service-v1-core>Service API object</a>.</p>
<h2 id=protocol-support>Supported protocols</h2>
<h3 id=tcp>TCP</h3>
<p>You can use TCP for any kind of Service, and it's the default network protocol.</p>
<h3 id=udp>UDP</h3>
<p>You can use UDP for most Services. For type=LoadBalancer Services, UDP support
depends on the cloud provider offering this facility.</p>
<h3 id=sctp>SCTP</h3>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.20 [stable]</code>
</div>
<p>When using a network plugin that supports SCTP traffic, you can use SCTP for
most Services. For type=LoadBalancer Services, SCTP support depends on the cloud
provider offering this facility. (Most do not).</p>
<h4 id=caveat-sctp-overview>Warnings</h4>
<h5 id=caveat-sctp-multihomed>Support for multihomed SCTP associations</h5>
<div class="alert alert-danger warning callout" role=alert>
<strong>Warning:</strong> <p>The support of multihomed SCTP associations requires that the CNI plugin can support the assignment of multiple interfaces and IP addresses to a Pod.</p>
<p>NAT for multihomed SCTP associations requires special logic in the corresponding kernel modules.</p>
</div>
<h5 id=caveat-sctp-windows-os>Windows</h5>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> SCTP is not supported on Windows based nodes.
</div>
<h5 id=caveat-sctp-kube-proxy-userspace>Userspace kube-proxy</h5>
<div class="alert alert-danger warning callout" role=alert>
<strong>Warning:</strong> The kube-proxy does not support the management of SCTP associations when it is in userspace mode.
</div>
<h3 id=http>HTTP</h3>
<p>If your cloud provider supports it, you can use a Service in LoadBalancer mode
to set up external HTTP / HTTPS reverse proxying, forwarded to the Endpoints
of the Service.</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> You can also use <a class=glossary-tooltip title="An API object that manages external access to the services in a cluster, typically HTTP." data-toggle=tooltip data-placement=top href=/docs/concepts/services-networking/ingress/ target=_blank aria-label=Ingress>Ingress</a> in place of Service
to expose HTTP/HTTPS Services.
</div>
<h3 id=proxy-protocol>PROXY protocol</h3>
<p>If your cloud provider supports it,
you can use a Service in LoadBalancer mode to configure a load balancer outside
of Kubernetes itself, that will forward connections prefixed with
<a href=https://www.haproxy.org/download/1.8/doc/proxy-protocol.txt>PROXY protocol</a>.</p>
<p>The load balancer will send an initial series of octets describing the
incoming connection, similar to this example</p>
<pre><code>PROXY TCP4 192.0.2.202 10.0.42.7 12345 7\r\n
</code></pre><p>followed by the data from the client.</p>
<h2 id=what-s-next>What's next</h2>
<ul>
<li>Read <a href=/docs/concepts/services-networking/connect-applications-service/>Connecting Applications with Services</a></li>
<li>Read about <a href=/docs/concepts/services-networking/ingress/>Ingress</a></li>
<li>Read about <a href=/docs/concepts/services-networking/endpoint-slices/>EndpointSlices</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-3a38878244d862dfdb8d7adb32f77584>2 - Topology-aware traffic routing with topology keys</h1>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.21 [deprecated]</code>
</div>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> This feature, specifically the alpha <code>topologyKeys</code> API, is deprecated since
Kubernetes v1.21.
<a href=/docs/concepts/services-networking/topology-aware-hints/>Topology Aware Hints</a>,
introduced in Kubernetes v1.21, provide similar functionality.
</div>
<p><em>Service Topology</em> enables a service to route traffic based upon the Node
topology of the cluster. For example, a service can specify that traffic be
preferentially routed to endpoints that are on the same Node as the client, or
in the same availability zone.</p>
<h2 id=topology-aware-traffic-routing>Topology-aware traffic routing</h2>
<p>By default, traffic sent to a <code>ClusterIP</code> or <code>NodePort</code> Service may be routed to
any backend address for the Service. Kubernetes 1.7 made it possible to
route "external" traffic to the Pods running on the same Node that received the
traffic. For <code>ClusterIP</code> Services, the equivalent same-node preference for
routing wasn't possible; nor could you configure your cluster to favor routing
to endpoints within the same zone.
By setting <code>topologyKeys</code> on a Service, you're able to define a policy for routing
traffic based upon the Node labels for the originating and destination Nodes.</p>
<p>The label matching between the source and destination lets you, as a cluster
operator, designate sets of Nodes that are "closer" and "farther" from one another.
You can define labels to represent whatever metric makes sense for your own
requirements.
In public clouds, for example, you might prefer to keep network traffic within the
same zone, because interzonal traffic has a cost associated with it (and intrazonal
traffic typically does not). Other common needs include being able to route traffic
to a local Pod managed by a DaemonSet, or directing traffic to Nodes connected to the
same top-of-rack switch for the lowest latency.</p>
<h2 id=using-service-topology>Using Service Topology</h2>
<p>If your cluster has the <code>ServiceTopology</code> <a href=/docs/reference/command-line-tools-reference/feature-gates/>feature gate</a> enabled, you can control Service traffic
routing by specifying the <code>topologyKeys</code> field on the Service spec. This field
is a preference-order list of Node labels which will be used to sort endpoints
when accessing this Service. Traffic will be directed to a Node whose value for
the first label matches the originating Node's value for that label. If there is
no backend for the Service on a matching Node, then the second label will be
considered, and so forth, until no labels remain.</p>
<p>If no match is found, the traffic will be rejected, as if there were no
backends for the Service at all. That is, endpoints are chosen based on the first
topology key with available backends. If this field is specified and all entries
have no backends that match the topology of the client, the service has no
backends for that client and connections should fail. The special value <code>"*"</code> may
be used to mean "any topology". This catch-all value, if used, only makes sense
as the last value in the list.</p>
<p>If <code>topologyKeys</code> is not specified or empty, no topology constraints will be applied.</p>
<p>Consider a cluster with Nodes that are labeled with their hostname, zone name,
and region name. Then you can set the <code>topologyKeys</code> values of a service to direct
traffic as follows.</p>
<ul>
<li>Only to endpoints on the same node, failing if no endpoint exists on the node:
<code>["kubernetes.io/hostname"]</code>.</li>
<li>Preferentially to endpoints on the same node, falling back to endpoints in the
same zone, followed by the same region, and failing otherwise: <code>["kubernetes.io/hostname", "topology.kubernetes.io/zone", "topology.kubernetes.io/region"]</code>.
This may be useful, for example, in cases where data locality is critical.</li>
<li>Preferentially to the same zone, but fallback on any available endpoint if
none are available within this zone:
<code>["topology.kubernetes.io/zone", "*"]</code>.</li>
</ul>
<h2 id=constraints>Constraints</h2>
<ul>
<li>
<p>Service topology is not compatible with <code>externalTrafficPolicy=Local</code>, and
therefore a Service cannot use both of these features. It is possible to use
both features in the same cluster on different Services, only not on the same
Service.</p>
</li>
<li>
<p>Valid topology keys are currently limited to <code>kubernetes.io/hostname</code>,
<code>topology.kubernetes.io/zone</code>, and <code>topology.kubernetes.io/region</code>, but will
be generalized to other node labels in the future.</p>
</li>
<li>
<p>Topology keys must be valid label keys and at most 16 keys may be specified.</p>
</li>
<li>
<p>The catch-all value, <code>"*"</code>, must be the last value in the topology keys, if
it is used.</p>
</li>
</ul>
<h2 id=examples>Examples</h2>
<p>The following are common examples of using the Service Topology feature.</p>
<h3 id=only-node-local-endpoints>Only Node Local Endpoints</h3>
<p>A Service that only routes to node local endpoints. If no endpoints exist on the node, traffic is dropped:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>my-app<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>9376</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>topologyKeys</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;kubernetes.io/hostname&#34;</span><span style=color:#bbb>
</span></code></pre></div><h3 id=prefer-node-local-endpoints>Prefer Node Local Endpoints</h3>
<p>A Service that prefers node local Endpoints but falls back to cluster wide endpoints if node local endpoints do not exist:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>my-app<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>9376</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>topologyKeys</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;kubernetes.io/hostname&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;*&#34;</span><span style=color:#bbb>
</span></code></pre></div><h3 id=only-zonal-or-regional-endpoints>Only Zonal or Regional Endpoints</h3>
<p>A Service that prefers zonal then regional endpoints. If no endpoints exist in either, traffic is dropped.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>my-app<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>9376</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>topologyKeys</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;topology.kubernetes.io/zone&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;topology.kubernetes.io/region&#34;</span><span style=color:#bbb>
</span></code></pre></div><h3 id=prefer-node-local-zonal-then-regional-endpoints>Prefer Node Local, Zonal, then Regional Endpoints</h3>
<p>A Service that prefers node local, zonal, then regional endpoints but falls back to cluster wide endpoints.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>my-app<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>9376</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>topologyKeys</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;kubernetes.io/hostname&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;topology.kubernetes.io/zone&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;topology.kubernetes.io/region&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;*&#34;</span><span style=color:#bbb>
</span></code></pre></div><h2 id=what-s-next>What's next</h2>
<ul>
<li>Read about <a href=/docs/tasks/administer-cluster/enabling-service-topology>enabling Service Topology</a></li>
<li>Read <a href=/docs/concepts/services-networking/connect-applications-service/>Connecting Applications with Services</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-91cb8a4438b003df11bc1c426a81b756>3 - DNS for Services and Pods</h1>
<p>Kubernetes creates DNS records for services and pods. You can contact
services with consistent DNS names instead of IP addresses.</p>
<h2 id=introduction>Introduction</h2>
<p>Kubernetes DNS schedules a DNS Pod and Service on the cluster, and configures
the kubelets to tell individual containers to use the DNS Service's IP to
resolve DNS names.</p>
<p>Every Service defined in the cluster (including the DNS server itself) is
assigned a DNS name. By default, a client Pod's DNS search list includes the
Pod's own namespace and the cluster's default domain.</p>
<h3 id=namespaces-of-services>Namespaces of Services</h3>
<p>A DNS query may return different results based on the namespace of the pod making
it. DNS queries that don't specify a namespace are limited to the pod's
namespace. Access services in other namespaces by specifying it in the DNS query.</p>
<p>For example, consider a pod in a <code>test</code> namespace. A <code>data</code> service is in
the <code>prod</code> namespace.</p>
<p>A query for <code>data</code> returns no results, because it uses the pod's <code>test</code> namespace.</p>
<p>A query for <code>data.prod</code> returns the intended result, because it specifies the
namespace.</p>
<p>DNS queries may be expanded using the pod's <code>/etc/resolv.conf</code>. Kubelet
sets this file for each pod. For example, a query for just <code>data</code> may be
expanded to <code>data.test.svc.cluster.local</code>. The values of the <code>search</code> option
are used to expand queries. To learn more about DNS queries, see
<a href=https://www.man7.org/linux/man-pages/man5/resolv.conf.5.html>the <code>resolv.conf</code> manual page.</a></p>
<pre><code>nameserver 10.32.0.10
search &lt;namespace&gt;.svc.cluster.local svc.cluster.local cluster.local
options ndots:5
</code></pre><p>In summary, a pod in the <em>test</em> namespace can successfully resolve either
<code>data.prod</code> or <code>data.prod.svc.cluster.local</code>.</p>
<h3 id=dns-records>DNS Records</h3>
<p>What objects get DNS records?</p>
<ol>
<li>Services</li>
<li>Pods</li>
</ol>
<p>The following sections detail the supported DNS record types and layout that is
supported. Any other layout or names or queries that happen to work are
considered implementation details and are subject to change without warning.
For more up-to-date specification, see
<a href=https://github.com/kubernetes/dns/blob/master/docs/specification.md>Kubernetes DNS-Based Service Discovery</a>.</p>
<h2 id=services>Services</h2>
<h3 id=a-aaaa-records>A/AAAA records</h3>
<p>"Normal" (not headless) Services are assigned a DNS A or AAAA record,
depending on the IP family of the service, for a name of the form
<code>my-svc.my-namespace.svc.cluster-domain.example</code>. This resolves to the cluster IP
of the Service.</p>
<p>"Headless" (without a cluster IP) Services are also assigned a DNS A or AAAA record,
depending on the IP family of the service, for a name of the form
<code>my-svc.my-namespace.svc.cluster-domain.example</code>. Unlike normal
Services, this resolves to the set of IPs of the pods selected by the Service.
Clients are expected to consume the set or else use standard round-robin
selection from the set.</p>
<h3 id=srv-records>SRV records</h3>
<p>SRV Records are created for named ports that are part of normal or <a href=/docs/concepts/services-networking/service/#headless-services>Headless
Services</a>.
For each named port, the SRV record would have the form
<code>_my-port-name._my-port-protocol.my-svc.my-namespace.svc.cluster-domain.example</code>.
For a regular service, this resolves to the port number and the domain name:
<code>my-svc.my-namespace.svc.cluster-domain.example</code>.
For a headless service, this resolves to multiple answers, one for each pod
that is backing the service, and contains the port number and the domain name of the pod
of the form <code>auto-generated-name.my-svc.my-namespace.svc.cluster-domain.example</code>.</p>
<h2 id=pods>Pods</h2>
<h3 id=a-aaaa-records-1>A/AAAA records</h3>
<p>In general a pod has the following DNS resolution:</p>
<p><code>pod-ip-address.my-namespace.pod.cluster-domain.example</code>.</p>
<p>For example, if a pod in the <code>default</code> namespace has the IP address 172.17.0.3,
and the domain name for your cluster is <code>cluster.local</code>, then the Pod has a DNS name:</p>
<p><code>172-17-0-3.default.pod.cluster.local</code>.</p>
<p>Any pods exposed by a Service have the following DNS resolution available:</p>
<p><code>pod-ip-address.service-name.my-namespace.svc.cluster-domain.example</code>.</p>
<h3 id=pod-s-hostname-and-subdomain-fields>Pod's hostname and subdomain fields</h3>
<p>Currently when a pod is created, its hostname is the Pod's <code>metadata.name</code> value.</p>
<p>The Pod spec has an optional <code>hostname</code> field, which can be used to specify the
Pod's hostname. When specified, it takes precedence over the Pod's name to be
the hostname of the pod. For example, given a Pod with <code>hostname</code> set to
"<code>my-host</code>", the Pod will have its hostname set to "<code>my-host</code>".</p>
<p>The Pod spec also has an optional <code>subdomain</code> field which can be used to specify
its subdomain. For example, a Pod with <code>hostname</code> set to "<code>foo</code>", and <code>subdomain</code>
set to "<code>bar</code>", in namespace "<code>my-namespace</code>", will have the fully qualified
domain name (FQDN) "<code>foo.bar.my-namespace.svc.cluster-domain.example</code>".</p>
<p>Example:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>default-subdomain<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>clusterIP</span>:<span style=color:#bbb> </span>None<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb> </span><span style=color:#080;font-style:italic># Actually, no port is needed.</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>1234</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>1234</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>busybox1<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>hostname</span>:<span style=color:#bbb> </span>busybox-1<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>subdomain</span>:<span style=color:#bbb> </span>default-subdomain<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox:1.28<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- sleep<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:#b44>&#34;3600&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>busybox2<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>hostname</span>:<span style=color:#bbb> </span>busybox-2<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>subdomain</span>:<span style=color:#bbb> </span>default-subdomain<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox:1.28<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- sleep<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:#b44>&#34;3600&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span></code></pre></div><p>If there exists a headless service in the same namespace as the pod and with
the same name as the subdomain, the cluster's DNS Server also returns an A or AAAA
record for the Pod's fully qualified hostname.
For example, given a Pod with the hostname set to "<code>busybox-1</code>" and the subdomain set to
"<code>default-subdomain</code>", and a headless Service named "<code>default-subdomain</code>" in
the same namespace, the pod will see its own FQDN as
"<code>busybox-1.default-subdomain.my-namespace.svc.cluster-domain.example</code>". DNS serves an
A or AAAA record at that name, pointing to the Pod's IP. Both pods "<code>busybox1</code>" and
"<code>busybox2</code>" can have their distinct A or AAAA records.</p>
<p>The Endpoints object can specify the <code>hostname</code> for any endpoint addresses,
along with its IP.</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> Because A or AAAA records are not created for Pod names, <code>hostname</code> is required for the Pod's A or AAAA
record to be created. A Pod with no <code>hostname</code> but with <code>subdomain</code> will only create the
A or AAAA record for the headless service (<code>default-subdomain.my-namespace.svc.cluster-domain.example</code>),
pointing to the Pod's IP address. Also, Pod needs to become ready in order to have a
record unless <code>publishNotReadyAddresses=True</code> is set on the Service.
</div>
<h3 id=pod-sethostnameasfqdn-field>Pod's setHostnameAsFQDN field</h3>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.22 [stable]</code>
</div>
<p>When a Pod is configured to have fully qualified domain name (FQDN), its hostname is the short hostname. For example, if you have a Pod with the fully qualified domain name <code>busybox-1.default-subdomain.my-namespace.svc.cluster-domain.example</code>, then by default the <code>hostname</code> command inside that Pod returns <code>busybox-1</code> and the <code>hostname --fqdn</code> command returns the FQDN.</p>
<p>When you set <code>setHostnameAsFQDN: true</code> in the Pod spec, the kubelet writes the Pod's FQDN into the hostname for that Pod's namespace. In this case, both <code>hostname</code> and <code>hostname --fqdn</code> return the Pod's FQDN.</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> <p>In Linux, the hostname field of the kernel (the <code>nodename</code> field of <code>struct utsname</code>) is limited to 64 characters.</p>
<p>If a Pod enables this feature and its FQDN is longer than 64 character, it will fail to start. The Pod will remain in <code>Pending</code> status (<code>ContainerCreating</code> as seen by <code>kubectl</code>) generating error events, such as Failed to construct FQDN from pod hostname and cluster domain, FQDN <code>long-FQDN</code> is too long (64 characters is the max, 70 characters requested). One way of improving user experience for this scenario is to create an <a href=/docs/reference/access-authn-authz/extensible-admission-controllers/#admission-webhooks>admission webhook controller</a> to control FQDN size when users create top level objects, for example, Deployment.</p>
</div>
<h3 id=pod-s-dns-policy>Pod's DNS Policy</h3>
<p>DNS policies can be set on a per-pod basis. Currently Kubernetes supports the
following pod-specific DNS policies. These policies are specified in the
<code>dnsPolicy</code> field of a Pod Spec.</p>
<ul>
<li>"<code>Default</code>": The Pod inherits the name resolution configuration from the node
that the pods run on.
See <a href=/docs/tasks/administer-cluster/dns-custom-nameservers>related discussion</a>
for more details.</li>
<li>"<code>ClusterFirst</code>": Any DNS query that does not match the configured cluster
domain suffix, such as "<code>www.kubernetes.io</code>", is forwarded to the upstream
nameserver inherited from the node. Cluster administrators may have extra
stub-domain and upstream DNS servers configured.
See <a href=/docs/tasks/administer-cluster/dns-custom-nameservers>related discussion</a>
for details on how DNS queries are handled in those cases.</li>
<li>"<code>ClusterFirstWithHostNet</code>": For Pods running with hostNetwork, you should
explicitly set its DNS policy "<code>ClusterFirstWithHostNet</code>".</li>
<li>"<code>None</code>": It allows a Pod to ignore DNS settings from the Kubernetes
environment. All DNS settings are supposed to be provided using the
<code>dnsConfig</code> field in the Pod Spec.
See <a href=#pod-dns-config>Pod's DNS config</a> subsection below.</li>
</ul>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> "Default" is not the default DNS policy. If <code>dnsPolicy</code> is not
explicitly specified, then "ClusterFirst" is used.
</div>
<p>The example below shows a Pod with its DNS policy set to
"<code>ClusterFirstWithHostNet</code>" because it has <code>hostNetwork</code> set to <code>true</code>.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox:1.28<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- sleep<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:#b44>&#34;3600&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>imagePullPolicy</span>:<span style=color:#bbb> </span>IfNotPresent<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Always<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>hostNetwork</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>dnsPolicy</span>:<span style=color:#bbb> </span>ClusterFirstWithHostNet<span style=color:#bbb>
</span></code></pre></div><h3 id=pod-dns-config>Pod's DNS Config</h3>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.14 [stable]</code>
</div>
<p>Pod's DNS Config allows users more control on the DNS settings for a Pod.</p>
<p>The <code>dnsConfig</code> field is optional and it can work with any <code>dnsPolicy</code> settings.
However, when a Pod's <code>dnsPolicy</code> is set to "<code>None</code>", the <code>dnsConfig</code> field has
to be specified.</p>
<p>Below are the properties a user can specify in the <code>dnsConfig</code> field:</p>
<ul>
<li><code>nameservers</code>: a list of IP addresses that will be used as DNS servers for the
Pod. There can be at most 3 IP addresses specified. When the Pod's <code>dnsPolicy</code>
is set to "<code>None</code>", the list must contain at least one IP address, otherwise
this property is optional.
The servers listed will be combined to the base nameservers generated from the
specified DNS policy with duplicate addresses removed.</li>
<li><code>searches</code>: a list of DNS search domains for hostname lookup in the Pod.
This property is optional. When specified, the provided list will be merged
into the base search domain names generated from the chosen DNS policy.
Duplicate domain names are removed.
Kubernetes allows for at most 6 search domains.</li>
<li><code>options</code>: an optional list of objects where each object may have a <code>name</code>
property (required) and a <code>value</code> property (optional). The contents in this
property will be merged to the options generated from the specified DNS policy.
Duplicate entries are removed.</li>
</ul>
<p>The following is an example Pod with custom DNS settings:</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/en/examples/service/networking/custom-dns.yaml download=service/networking/custom-dns.yaml><code>service/networking/custom-dns.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('service-networking-custom-dns-yaml')" title="Copy service/networking/custom-dns.yaml to clipboard">
</img>
</div>
<div class=includecode id=service-networking-custom-dns-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>dns-example<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>dnsPolicy</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;None&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>dnsConfig</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>nameservers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:#666>1.2.3.4</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>searches</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- ns1.svc.cluster-domain.example<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- my.dns.search.suffix<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>options</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>ndots<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>edns0<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>When the Pod above is created, the container <code>test</code> gets the following contents
in its <code>/etc/resolv.conf</code> file:</p>
<pre><code>nameserver 1.2.3.4
search ns1.svc.cluster-domain.example my.dns.search.suffix
options ndots:2 edns0
</code></pre><p>For IPv6 setup, search path and name server should be setup like this:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#a2f>exec</span> -it dns-example -- cat /etc/resolv.conf
</code></pre></div><p>The output is similar to this:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>nameserver fd00:79:30::a
search default.svc.cluster-domain.example svc.cluster-domain.example cluster-domain.example
options ndots:5
</code></pre></div><h4 id=expanded-dns-configuration>Expanded DNS Configuration</h4>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes 1.22 [alpha]</code>
</div>
<p>By default, for Pod's DNS Config, Kubernetes allows at most 6 search domains and
a list of search domains of up to 256 characters.</p>
<p>If the feature gate <code>ExpandedDNSConfig</code> is enabled for the kube-apiserver and
the kubelet, it is allowed for Kubernetes to have at most 32 search domains and
a list of search domains of up to 2048 characters.</p>
<h2 id=what-s-next>What's next</h2>
<p>For guidance on administering DNS configurations, check
<a href=/docs/tasks/administer-cluster/dns-custom-nameservers/>Configure DNS Service</a></p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-f804ac0532fcade3966ea2e3769ca031>4 - Connecting Applications with Services</h1>
<h2 id=the-kubernetes-model-for-connecting-containers>The Kubernetes model for connecting containers</h2>
<p>Now that you have a continuously running, replicated application you can expose it on a network.</p>
<p>Kubernetes assumes that pods can communicate with other pods, regardless of which host they land on. Kubernetes gives every pod its own cluster-private IP address, so you do not need to explicitly create links between pods or map container ports to host ports. This means that containers within a Pod can all reach each other's ports on localhost, and all pods in a cluster can see each other without NAT. The rest of this document elaborates on how you can run reliable services on such a networking model.</p>
<p>This guide uses a simple nginx server to demonstrate proof of concept.</p>
<h2 id=exposing-pods-to-the-cluster>Exposing pods to the cluster</h2>
<p>We did this in a previous example, but let's do it once again and focus on the networking perspective.
Create an nginx Pod, and note that it has a container port specification:</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/en/examples/service/networking/run-my-nginx.yaml download=service/networking/run-my-nginx.yaml><code>service/networking/run-my-nginx.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('service-networking-run-my-nginx-yaml')" title="Copy service/networking/run-my-nginx.yaml to clipboard">
</img>
</div>
<div class=includecode id=service-networking-run-my-nginx-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-nginx<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>run</span>:<span style=color:#bbb> </span>my-nginx<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>2</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>run</span>:<span style=color:#bbb> </span>my-nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-nginx<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>This makes it accessible from any node in your cluster. Check the nodes the Pod is running on:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f ./run-my-nginx.yaml
kubectl get pods -l <span style=color:#b8860b>run</span><span style=color:#666>=</span>my-nginx -o wide
</code></pre></div><pre><code>NAME                        READY     STATUS    RESTARTS   AGE       IP            NODE
my-nginx-3800858182-jr4a2   1/1       Running   0          13s       10.244.3.4    kubernetes-minion-905m
my-nginx-3800858182-kna2y   1/1       Running   0          13s       10.244.2.5    kubernetes-minion-ljyd
</code></pre><p>Check your pods' IPs:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods -l <span style=color:#b8860b>run</span><span style=color:#666>=</span>my-nginx -o yaml | grep podIP
    podIP: 10.244.3.4
    podIP: 10.244.2.5
</code></pre></div><p>You should be able to ssh into any node in your cluster and use a tool such as <code>curl</code> to make queries against both IPs. Note that the containers are <em>not</em> using port 80 on the node, nor are there any special NAT rules to route traffic to the pod. This means you can run multiple nginx pods on the same node all using the same <code>containerPort</code>, and access them from any other pod or node in your cluster using the assigned IP address for the Service. If you want to arrange for a specific port on the host Node to be forwarded to backing Pods, you can - but the networking model should mean that you do not need to do so.</p>
<p>You can read more about the <a href=/docs/concepts/cluster-administration/networking/#the-kubernetes-network-model>Kubernetes Networking Model</a> if you're curious.</p>
<h2 id=creating-a-service>Creating a Service</h2>
<p>So we have pods running nginx in a flat, cluster wide, address space. In theory, you could talk to these pods directly, but what happens when a node dies? The pods die with it, and the Deployment will create new ones, with different IPs. This is the problem a Service solves.</p>
<p>A Kubernetes Service is an abstraction which defines a logical set of Pods running somewhere in your cluster, that all provide the same functionality. When created, each Service is assigned a unique IP address (also called clusterIP). This address is tied to the lifespan of the Service, and will not change while the Service is alive. Pods can be configured to talk to the Service, and know that communication to the Service will be automatically load-balanced out to some pod that is a member of the Service.</p>
<p>You can create a Service for your 2 nginx replicas with <code>kubectl expose</code>:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl expose deployment/my-nginx
</code></pre></div><pre><code>service/my-nginx exposed
</code></pre><p>This is equivalent to <code>kubectl apply -f</code> the following yaml:</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/en/examples/service/networking/nginx-svc.yaml download=service/networking/nginx-svc.yaml><code>service/networking/nginx-svc.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('service-networking-nginx-svc-yaml')" title="Copy service/networking/nginx-svc.yaml to clipboard">
</img>
</div>
<div class=includecode id=service-networking-nginx-svc-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-nginx<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>run</span>:<span style=color:#bbb> </span>my-nginx<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>run</span>:<span style=color:#bbb> </span>my-nginx<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>This specification will create a Service which targets TCP port 80 on any Pod
with the <code>run: my-nginx</code> label, and expose it on an abstracted Service port
(<code>targetPort</code>: is the port the container accepts traffic on, <code>port</code>: is the
abstracted Service port, which can be any port other pods use to access the
Service).
View <a href=/docs/reference/generated/kubernetes-api/v1.23/#service-v1-core>Service</a>
API object to see the list of supported fields in service definition.
Check your Service:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get svc my-nginx
</code></pre></div><pre><code>NAME       TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)   AGE
my-nginx   ClusterIP   10.0.162.149   &lt;none&gt;        80/TCP    21s
</code></pre><p>As mentioned previously, a Service is backed by a group of Pods. These Pods are
exposed through <code>endpoints</code>. The Service's selector will be evaluated continuously
and the results will be POSTed to an Endpoints object also named <code>my-nginx</code>.
When a Pod dies, it is automatically removed from the endpoints, and new Pods
matching the Service's selector will automatically get added to the endpoints.
Check the endpoints, and note that the IPs are the same as the Pods created in
the first step:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe svc my-nginx
</code></pre></div><pre><code>Name:                my-nginx
Namespace:           default
Labels:              run=my-nginx
Annotations:         &lt;none&gt;
Selector:            run=my-nginx
Type:                ClusterIP
IP:                  10.0.162.149
Port:                &lt;unset&gt; 80/TCP
Endpoints:           10.244.2.5:80,10.244.3.4:80
Session Affinity:    None
Events:              &lt;none&gt;
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get ep my-nginx
</code></pre></div><pre><code>NAME       ENDPOINTS                     AGE
my-nginx   10.244.2.5:80,10.244.3.4:80   1m
</code></pre><p>You should now be able to curl the nginx Service on <code>&lt;CLUSTER-IP>:&lt;PORT></code> from
any node in your cluster. Note that the Service IP is completely virtual, it
never hits the wire. If you're curious about how this works you can read more
about the <a href=/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies>service proxy</a>.</p>
<h2 id=accessing-the-service>Accessing the Service</h2>
<p>Kubernetes supports 2 primary modes of finding a Service - environment variables
and DNS. The former works out of the box while the latter requires the
<a href=https://releases.k8s.io/v1.23.17/cluster/addons/dns/coredns>CoreDNS cluster addon</a>.
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> If the service environment variables are not desired (because possible clashing with expected program ones,
too many variables to process, only using DNS, etc) you can disable this mode by setting the <code>enableServiceLinks</code>
flag to <code>false</code> on the <a href=/docs/reference/generated/kubernetes-api/v1.23/#pod-v1-core>pod spec</a>.
</div></p>
<h3 id=environment-variables>Environment Variables</h3>
<p>When a Pod runs on a Node, the kubelet adds a set of environment variables for
each active Service. This introduces an ordering problem. To see why, inspect
the environment of your running nginx Pods (your Pod name will be different):</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#a2f>exec</span> my-nginx-3800858182-jr4a2 -- printenv | grep SERVICE
</code></pre></div><pre><code>KUBERNETES_SERVICE_HOST=10.0.0.1
KUBERNETES_SERVICE_PORT=443
KUBERNETES_SERVICE_PORT_HTTPS=443
</code></pre><p>Note there's no mention of your Service. This is because you created the replicas
before the Service. Another disadvantage of doing this is that the scheduler might
put both Pods on the same machine, which will take your entire Service down if
it dies. We can do this the right way by killing the 2 Pods and waiting for the
Deployment to recreate them. This time around the Service exists <em>before</em> the
replicas. This will give you scheduler-level Service spreading of your Pods
(provided all your nodes have equal capacity), as well as the right environment
variables:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl scale deployment my-nginx --replicas<span style=color:#666>=</span>0; kubectl scale deployment my-nginx --replicas<span style=color:#666>=</span>2;

kubectl get pods -l <span style=color:#b8860b>run</span><span style=color:#666>=</span>my-nginx -o wide
</code></pre></div><pre><code>NAME                        READY     STATUS    RESTARTS   AGE     IP            NODE
my-nginx-3800858182-e9ihh   1/1       Running   0          5s      10.244.2.7    kubernetes-minion-ljyd
my-nginx-3800858182-j4rm4   1/1       Running   0          5s      10.244.3.8    kubernetes-minion-905m
</code></pre><p>You may notice that the pods have different names, since they are killed and recreated.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#a2f>exec</span> my-nginx-3800858182-e9ihh -- printenv | grep SERVICE
</code></pre></div><pre><code>KUBERNETES_SERVICE_PORT=443
MY_NGINX_SERVICE_HOST=10.0.162.149
KUBERNETES_SERVICE_HOST=10.0.0.1
MY_NGINX_SERVICE_PORT=80
KUBERNETES_SERVICE_PORT_HTTPS=443
</code></pre><h3 id=dns>DNS</h3>
<p>Kubernetes offers a DNS cluster addon Service that automatically assigns dns names to other Services. You can check if it's running on your cluster:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get services kube-dns --namespace<span style=color:#666>=</span>kube-system
</code></pre></div><pre><code>NAME       TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)         AGE
kube-dns   ClusterIP   10.0.0.10    &lt;none&gt;        53/UDP,53/TCP   8m
</code></pre><p>The rest of this section will assume you have a Service with a long lived IP
(my-nginx), and a DNS server that has assigned a name to that IP. Here we use the CoreDNS cluster addon (application name <code>kube-dns</code>), so you can talk to the Service from any pod in your cluster using standard methods (e.g. <code>gethostbyname()</code>). If CoreDNS isn't running, you can enable it referring to the <a href=https://github.com/coredns/deployment/tree/master/kubernetes>CoreDNS README</a> or <a href=/docs/tasks/administer-cluster/coredns/#installing-coredns>Installing CoreDNS</a>. Let's run another curl application to test this:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl run curl --image<span style=color:#666>=</span>radial/busyboxplus:curl -i --tty
</code></pre></div><pre><code>Waiting for pod default/curl-131556218-9fnch to be running, status is Pending, pod ready: false
Hit enter for command prompt
</code></pre><p>Then, hit enter and run <code>nslookup my-nginx</code>:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#666>[</span> root@curl-131556218-9fnch:/ <span style=color:#666>]</span>$ nslookup my-nginx
Server:    10.0.0.10
Address 1: 10.0.0.10

Name:      my-nginx
Address 1: 10.0.162.149
</code></pre></div><h2 id=securing-the-service>Securing the Service</h2>
<p>Till now we have only accessed the nginx server from within the cluster. Before exposing the Service to the internet, you want to make sure the communication channel is secure. For this, you will need:</p>
<ul>
<li>Self signed certificates for https (unless you already have an identity certificate)</li>
<li>An nginx server configured to use the certificates</li>
<li>A <a href=/docs/concepts/configuration/secret/>secret</a> that makes the certificates accessible to pods</li>
</ul>
<p>You can acquire all these from the <a href=https://github.com/kubernetes/examples/tree/master/staging/https-nginx/>nginx https example</a>. This requires having go and make tools installed. If you don't want to install those, then follow the manual steps later. In short:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>make keys <span style=color:#b8860b>KEY</span><span style=color:#666>=</span>/tmp/nginx.key <span style=color:#b8860b>CERT</span><span style=color:#666>=</span>/tmp/nginx.crt
kubectl create secret tls nginxsecret --key /tmp/nginx.key --cert /tmp/nginx.crt
</code></pre></div><pre><code>secret/nginxsecret created
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get secrets
</code></pre></div><pre><code>NAME                  TYPE                                  DATA      AGE
default-token-il9rc   kubernetes.io/service-account-token   1         1d
nginxsecret           kubernetes.io/tls                     2         1m
</code></pre><p>And also the configmap:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create configmap nginxconfigmap --from-file<span style=color:#666>=</span>default.conf
</code></pre></div><pre><code>configmap/nginxconfigmap created
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get configmaps
</code></pre></div><pre><code>NAME             DATA   AGE
nginxconfigmap   1      114s
</code></pre><p>Following are the manual steps to follow in case you run into problems running make (on windows for example):</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># Create a public private key pair</span>
openssl req -x509 -nodes -days <span style=color:#666>365</span> -newkey rsa:2048 -keyout /d/tmp/nginx.key -out /d/tmp/nginx.crt -subj <span style=color:#b44>&#34;/CN=my-nginx/O=my-nginx&#34;</span>
<span style=color:#080;font-style:italic># Convert the keys to base64 encoding</span>
cat /d/tmp/nginx.crt | base64
cat /d/tmp/nginx.key | base64
</code></pre></div><p>Use the output from the previous commands to create a yaml file as follows. The base64 encoded value should all be on a single line.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;v1&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;Secret&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;nginxsecret&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;default&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>kubernetes.io/tls<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>tls.crt</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSURIekNDQWdlZ0F3SUJBZ0lKQUp5M3lQK0pzMlpJTUEwR0NTcUdTSWIzRFFFQkJRVUFNQ1l4RVRBUEJnTlYKQkFNVENHNW5hVzU0YzNaak1SRXdEd1lEVlFRS0V3aHVaMmx1ZUhOMll6QWVGdzB4TnpFd01qWXdOekEzTVRKYQpGdzB4T0RFd01qWXdOekEzTVRKYU1DWXhFVEFQQmdOVkJBTVRDRzVuYVc1NGMzWmpNUkV3RHdZRFZRUUtFd2h1CloybHVlSE4yWXpDQ0FTSXdEUVlKS29aSWh2Y05BUUVCQlFBRGdnRVBBRENDQVFvQ2dnRUJBSjFxSU1SOVdWM0IKMlZIQlRMRmtobDRONXljMEJxYUhIQktMSnJMcy8vdzZhU3hRS29GbHlJSU94NGUrMlN5ajBFcndCLzlYTnBwbQppeW1CL3JkRldkOXg5UWhBQUxCZkVaTmNiV3NsTVFVcnhBZW50VWt1dk1vLzgvMHRpbGhjc3paenJEYVJ4NEo5Ci82UVRtVVI3a0ZTWUpOWTVQZkR3cGc3dlVvaDZmZ1Voam92VG42eHNVR0M2QURVODBpNXFlZWhNeVI1N2lmU2YKNHZpaXdIY3hnL3lZR1JBRS9mRTRqakxCdmdONjc2SU90S01rZXV3R0ljNDFhd05tNnNTSzRqYUNGeGpYSnZaZQp2by9kTlEybHhHWCtKT2l3SEhXbXNhdGp4WTRaNVk3R1ZoK0QrWnYvcW1mMFgvbVY0Rmo1NzV3ajFMWVBocWtsCmdhSXZYRyt4U1FVQ0F3RUFBYU5RTUU0d0hRWURWUjBPQkJZRUZPNG9OWkI3YXc1OUlsYkROMzhIYkduYnhFVjcKTUI4R0ExVWRJd1FZTUJhQUZPNG9OWkI3YXc1OUlsYkROMzhIYkduYnhFVjdNQXdHQTFVZEV3UUZNQU1CQWY4dwpEUVlKS29aSWh2Y05BUUVGQlFBRGdnRUJBRVhTMW9FU0lFaXdyMDhWcVA0K2NwTHI3TW5FMTducDBvMm14alFvCjRGb0RvRjdRZnZqeE04Tzd2TjB0clcxb2pGSW0vWDE4ZnZaL3k4ZzVaWG40Vm8zc3hKVmRBcStNZC9jTStzUGEKNmJjTkNUekZqeFpUV0UrKzE5NS9zb2dmOUZ3VDVDK3U2Q3B5N0M3MTZvUXRUakViV05VdEt4cXI0Nk1OZWNCMApwRFhWZmdWQTRadkR4NFo3S2RiZDY5eXM3OVFHYmg5ZW1PZ05NZFlsSUswSGt0ejF5WU4vbVpmK3FqTkJqbWZjCkNnMnlwbGQ0Wi8rUUNQZjl3SkoybFIrY2FnT0R4elBWcGxNSEcybzgvTHFDdnh6elZPUDUxeXdLZEtxaUMwSVEKQ0I5T2wwWW5scE9UNEh1b2hSUzBPOStlMm9KdFZsNUIyczRpbDlhZ3RTVXFxUlU9Ci0tLS0tRU5EIENFUlRJRklDQVRFLS0tLS0K&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>tls.key</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;LS0tLS1CRUdJTiBQUklWQVRFIEtFWS0tLS0tCk1JSUV2UUlCQURBTkJna3Foa2lHOXcwQkFRRUZBQVNDQktjd2dnU2pBZ0VBQW9JQkFRQ2RhaURFZlZsZHdkbFIKd1V5eFpJWmVEZWNuTkFhbWh4d1NpeWF5N1AvOE9ta3NVQ3FCWmNpQ0RzZUh2dGtzbzlCSzhBZi9WemFhWm9zcApnZjYzUlZuZmNmVUlRQUN3WHhHVFhHMXJKVEVGSzhRSHA3VkpMcnpLUC9QOUxZcFlYTE0yYzZ3MmtjZUNmZitrCkU1bEVlNUJVbUNUV09UM3c4S1lPNzFLSWVuNEZJWTZMMDUrc2JGQmd1Z0ExUE5JdWFubm9UTWtlZTRuMG4rTDQKb3NCM01ZUDhtQmtRQlAzeE9JNHl3YjREZXUraURyU2pKSHJzQmlIT05Xc0RadXJFaXVJMmdoY1kxeWIyWHI2UAozVFVOcGNSbC9pVG9zQngxcHJHclk4V09HZVdPeGxZZmcvbWIvNnBuOUYvNWxlQlkrZStjSTlTMkQ0YXBKWUdpCkwxeHZzVWtGQWdNQkFBRUNnZ0VBZFhCK0xkbk8ySElOTGo5bWRsb25IUGlHWWVzZ294RGQwci9hQ1Zkank4dlEKTjIwL3FQWkUxek1yall6Ry9kVGhTMmMwc0QxaTBXSjdwR1lGb0xtdXlWTjltY0FXUTM5SjM0VHZaU2FFSWZWNgo5TE1jUHhNTmFsNjRLMFRVbUFQZytGam9QSFlhUUxLOERLOUtnNXNrSE5pOWNzMlY5ckd6VWlVZWtBL0RBUlBTClI3L2ZjUFBacDRuRWVBZmI3WTk1R1llb1p5V21SU3VKdlNyblBESGtUdW1vVlVWdkxMRHRzaG9reUxiTWVtN3oKMmJzVmpwSW1GTHJqbGtmQXlpNHg0WjJrV3YyMFRrdWtsZU1jaVlMbjk4QWxiRi9DSmRLM3QraTRoMTVlR2ZQegpoTnh3bk9QdlVTaDR2Q0o3c2Q5TmtEUGJvS2JneVVHOXBYamZhRGR2UVFLQmdRRFFLM01nUkhkQ1pKNVFqZWFKClFGdXF4cHdnNzhZTjQyL1NwenlUYmtGcVFoQWtyczJxWGx1MDZBRzhrZzIzQkswaHkzaE9zSGgxcXRVK3NHZVAKOWRERHBsUWV0ODZsY2FlR3hoc0V0L1R6cEdtNGFKSm5oNzVVaTVGZk9QTDhPTm1FZ3MxMVRhUldhNzZxelRyMgphRlpjQ2pWV1g0YnRSTHVwSkgrMjZnY0FhUUtCZ1FEQmxVSUUzTnNVOFBBZEYvL25sQVB5VWs1T3lDdWc3dmVyClUycXlrdXFzYnBkSi9hODViT1JhM05IVmpVM25uRGpHVHBWaE9JeXg5TEFrc2RwZEFjVmxvcG9HODhXYk9lMTAKMUdqbnkySmdDK3JVWUZiRGtpUGx1K09IYnRnOXFYcGJMSHBzUVpsMGhucDBYSFNYVm9CMUliQndnMGEyOFVadApCbFBtWmc2d1BRS0JnRHVIUVV2SDZHYTNDVUsxNFdmOFhIcFFnMU16M2VvWTBPQm5iSDRvZUZKZmcraEppSXlnCm9RN3hqWldVR3BIc3AyblRtcHErQWlSNzdyRVhsdlhtOElVU2FsbkNiRGlKY01Pc29RdFBZNS9NczJMRm5LQTQKaENmL0pWb2FtZm1nZEN0ZGtFMXNINE9MR2lJVHdEbTRpb0dWZGIwMllnbzFyb2htNUpLMUI3MkpBb0dBUW01UQpHNDhXOTVhL0w1eSt5dCsyZ3YvUHM2VnBvMjZlTzRNQ3lJazJVem9ZWE9IYnNkODJkaC8xT2sybGdHZlI2K3VuCnc1YytZUXRSTHlhQmd3MUtpbGhFZDBKTWU3cGpUSVpnQWJ0LzVPbnlDak9OVXN2aDJjS2lrQ1Z2dTZsZlBjNkQKckliT2ZIaHhxV0RZK2Q1TGN1YSt2NzJ0RkxhenJsSlBsRzlOZHhrQ2dZRUF5elIzT3UyMDNRVVV6bUlCRkwzZAp4Wm5XZ0JLSEo3TnNxcGFWb2RjL0d5aGVycjFDZzE2MmJaSjJDV2RsZkI0VEdtUjZZdmxTZEFOOFRwUWhFbUtKCnFBLzVzdHdxNWd0WGVLOVJmMWxXK29xNThRNTBxMmk1NVdUTThoSDZhTjlaMTltZ0FGdE5VdGNqQUx2dFYxdEYKWSs4WFJkSHJaRnBIWll2NWkwVW1VbGc9Ci0tLS0tRU5EIFBSSVZBVEUgS0VZLS0tLS0K&#34;</span><span style=color:#bbb>
</span></code></pre></div><p>Now create the secrets using the file:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f nginxsecrets.yaml
kubectl get secrets
</code></pre></div><pre><code>NAME                  TYPE                                  DATA      AGE
default-token-il9rc   kubernetes.io/service-account-token   1         1d
nginxsecret           kubernetes.io/tls                     2         1m
</code></pre><p>Now modify your nginx replicas to start an https server using the certificate in the secret, and the Service, to expose both ports (80 and 443):</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/en/examples/service/networking/nginx-secure-app.yaml download=service/networking/nginx-secure-app.yaml><code>service/networking/nginx-secure-app.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('service-networking-nginx-secure-app-yaml')" title="Copy service/networking/nginx-secure-app.yaml to clipboard">
</img>
</div>
<div class=includecode id=service-networking-nginx-secure-app-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-nginx<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>run</span>:<span style=color:#bbb> </span>my-nginx<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>NodePort<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>8080</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>http<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>443</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>https<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>run</span>:<span style=color:#bbb> </span>my-nginx<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-nginx<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>run</span>:<span style=color:#bbb> </span>my-nginx<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>run</span>:<span style=color:#bbb> </span>my-nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-volume<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>secret</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>secretName</span>:<span style=color:#bbb> </span>nginxsecret<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>configmap-volume<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>configMap</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginxconfigmap<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginxhttps<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>bprashanth/nginxhttps:1.0<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>443</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/etc/nginx/ssl<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-volume<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/etc/nginx/conf.d<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>configmap-volume<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>Noteworthy points about the nginx-secure-app manifest:</p>
<ul>
<li>It contains both Deployment and Service specification in the same file.</li>
<li>The <a href=https://github.com/kubernetes/examples/tree/master/staging/https-nginx/default.conf>nginx server</a>
serves HTTP traffic on port 80 and HTTPS traffic on 443, and nginx Service
exposes both ports.</li>
<li>Each container has access to the keys through a volume mounted at <code>/etc/nginx/ssl</code>.
This is setup <em>before</em> the nginx server is started.</li>
</ul>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete deployments,svc my-nginx; kubectl create -f ./nginx-secure-app.yaml
</code></pre></div><p>At this point you can reach the nginx server from any node.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods -o yaml | grep -i podip
    podIP: 10.244.3.5
node $ curl -k https://10.244.3.5
...
&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;
</code></pre></div><p>Note how we supplied the <code>-k</code> parameter to curl in the last step, this is because we don't know anything about the pods running nginx at certificate generation time,
so we have to tell curl to ignore the CName mismatch. By creating a Service we linked the CName used in the certificate with the actual DNS name used by pods during Service lookup.
Let's test this from a pod (the same secret is being reused for simplicity, the pod only needs nginx.crt to access the Service):</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/en/examples/service/networking/curlpod.yaml download=service/networking/curlpod.yaml><code>service/networking/curlpod.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('service-networking-curlpod-yaml')" title="Copy service/networking/curlpod.yaml to clipboard">
</img>
</div>
<div class=includecode id=service-networking-curlpod-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>curl-deployment<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>curlpod<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>curlpod<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-volume<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>secret</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>secretName</span>:<span style=color:#bbb> </span>nginxsecret<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>curlpod<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- sh<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- -c<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- while true; do sleep 1; done<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>radial/busyboxplus:curl<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/etc/nginx/ssl<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-volume<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f ./curlpod.yaml
kubectl get pods -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>curlpod
</code></pre></div><pre><code>NAME                               READY     STATUS    RESTARTS   AGE
curl-deployment-1515033274-1410r   1/1       Running   0          1m
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#a2f>exec</span> curl-deployment-1515033274-1410r -- curl https://my-nginx --cacert /etc/nginx/ssl/tls.crt
...
&lt;title&gt;Welcome to nginx!&lt;/title&gt;
...
</code></pre></div><h2 id=exposing-the-service>Exposing the Service</h2>
<p>For some parts of your applications you may want to expose a Service onto an
external IP address. Kubernetes supports two ways of doing this: NodePorts and
LoadBalancers. The Service created in the last section already used <code>NodePort</code>,
so your nginx HTTPS replica is ready to serve traffic on the internet if your
node has a public IP.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get svc my-nginx -o yaml | grep nodePort -C <span style=color:#666>5</span>
  uid: 07191fb3-f61a-11e5-8ae5-42010af00002
spec:
  clusterIP: 10.0.162.149
  ports:
  - name: http
    nodePort: <span style=color:#666>31704</span>
    port: <span style=color:#666>8080</span>
    protocol: TCP
    targetPort: <span style=color:#666>80</span>
  - name: https
    nodePort: <span style=color:#666>32453</span>
    port: <span style=color:#666>443</span>
    protocol: TCP
    targetPort: <span style=color:#666>443</span>
  selector:
    run: my-nginx
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get nodes -o yaml | grep ExternalIP -C <span style=color:#666>1</span>
    - address: 104.197.41.11
      type: ExternalIP
    allocatable:
--
    - address: 23.251.152.56
      type: ExternalIP
    allocatable:
...

$ curl https://&lt;EXTERNAL-IP&gt;:&lt;NODE-PORT&gt; -k
...
&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;
</code></pre></div><p>Let's now recreate the Service to use a cloud load balancer. Change the <code>Type</code> of <code>my-nginx</code> Service from <code>NodePort</code> to <code>LoadBalancer</code>:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl edit svc my-nginx
kubectl get svc my-nginx
</code></pre></div><pre><code>NAME       TYPE           CLUSTER-IP     EXTERNAL-IP        PORT(S)               AGE
my-nginx   LoadBalancer   10.0.162.149     xx.xxx.xxx.xxx     8080:30163/TCP        21s
</code></pre><pre><code>curl https://&lt;EXTERNAL-IP&gt; -k
...
&lt;title&gt;Welcome to nginx!&lt;/title&gt;
</code></pre><p>The IP address in the <code>EXTERNAL-IP</code> column is the one that is available on the public internet. The <code>CLUSTER-IP</code> is only available inside your
cluster/private cloud network.</p>
<p>Note that on AWS, type <code>LoadBalancer</code> creates an ELB, which uses a (long)
hostname, not an IP. It's too long to fit in the standard <code>kubectl get svc</code>
output, in fact, so you'll need to do <code>kubectl describe service my-nginx</code> to
see it. You'll see something like this:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe service my-nginx
...
LoadBalancer Ingress:   a320587ffd19711e5a37606cf4a74574-1142138393.us-east-1.elb.amazonaws.com
...
</code></pre></div><h2 id=what-s-next>What's next</h2>
<ul>
<li>Learn more about <a href=/docs/tasks/access-application-cluster/service-access-application-cluster/>Using a Service to Access an Application in a Cluster</a></li>
<li>Learn more about <a href=/docs/tasks/access-application-cluster/connecting-frontend-backend/>Connecting a Front End to a Back End Using a Service</a></li>
<li>Learn more about <a href=/docs/tasks/access-application-cluster/create-external-load-balancer/>Creating an External Load Balancer</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-199bcc92443dbc9bed44819467d7eb75>5 - Ingress</h1>
<p>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.19 [stable]</code>
</div>
<p>An API object that manages external access to the services in a cluster, typically HTTP.</p>
<p>Ingress may provide load balancing, SSL termination and name-based virtual hosting.</p></p>
<h2 id=terminology>Terminology</h2>
<p>For clarity, this guide defines the following terms:</p>
<ul>
<li>Node: A worker machine in Kubernetes, part of a cluster.</li>
<li>Cluster: A set of Nodes that run containerized applications managed by Kubernetes. For this example, and in most common Kubernetes deployments, nodes in the cluster are not part of the public internet.</li>
<li>Edge router: A router that enforces the firewall policy for your cluster. This could be a gateway managed by a cloud provider or a physical piece of hardware.</li>
<li>Cluster network: A set of links, logical or physical, that facilitate communication within a cluster according to the Kubernetes <a href=/docs/concepts/cluster-administration/networking/>networking model</a>.</li>
<li>Service: A Kubernetes <a class=glossary-tooltip title="A way to expose an application running on a set of Pods as a network service." data-toggle=tooltip data-placement=top href=/docs/concepts/services-networking/service/ target=_blank aria-label=Service>Service</a> that identifies a set of Pods using <a class=glossary-tooltip title="Tags objects with identifying attributes that are meaningful and relevant to users." data-toggle=tooltip data-placement=top href=/docs/concepts/overview/working-with-objects/labels target=_blank aria-label=label>label</a> selectors. Unless mentioned otherwise, Services are assumed to have virtual IPs only routable within the cluster network.</li>
</ul>
<h2 id=what-is-ingress>What is Ingress?</h2>
<p><a href=/docs/reference/generated/kubernetes-api/v1.23/#ingress-v1-networking-k8s-io>Ingress</a> exposes HTTP and HTTPS routes from outside the cluster to
<a href=/docs/concepts/services-networking/service/ target=_blank>services</a> within the cluster.
Traffic routing is controlled by rules defined on the Ingress resource.</p>
<p>Here is a simple example where an Ingress sends all its traffic to one Service:
<figure>
<div class=mermaid>
graph LR;
client([client])-. Ingress-managed <br> load balancer .->ingress[Ingress];
ingress-->|routing rule|service[Service];
subgraph cluster
ingress;
service-->pod1[Pod];
service-->pod2[Pod];
end
classDef plain fill:#ddd,stroke:#fff,stroke-width:4px,color:#000;
classDef k8s fill:#326ce5,stroke:#fff,stroke-width:4px,color:#fff;
classDef cluster fill:#fff,stroke:#bbb,stroke-width:2px,color:#326ce5;
class ingress,service,pod1,pod2 k8s;
class client plain;
class cluster cluster;
</div>
</figure>
<noscript>
<div class="alert alert-secondary callout" role=alert>
<em class=javascript-required>JavaScript must be <a href=https://www.enable-javascript.com/>enabled</a> to view this content</em>
</div>
</noscript></p>
<p>An Ingress may be configured to give Services externally-reachable URLs, load balance traffic, terminate SSL / TLS, and offer name-based virtual hosting. An <a href=/docs/concepts/services-networking/ingress-controllers>Ingress controller</a> is responsible for fulfilling the Ingress, usually with a load balancer, though it may also configure your edge router or additional frontends to help handle the traffic.</p>
<p>An Ingress does not expose arbitrary ports or protocols. Exposing services other than HTTP and HTTPS to the internet typically
uses a service of type <a href=/docs/concepts/services-networking/service/#type-nodeport>Service.Type=NodePort</a> or
<a href=/docs/concepts/services-networking/service/#loadbalancer>Service.Type=LoadBalancer</a>.</p>
<h2 id=prerequisites>Prerequisites</h2>
<p>You must have an <a href=/docs/concepts/services-networking/ingress-controllers>Ingress controller</a> to satisfy an Ingress. Only creating an Ingress resource has no effect.</p>
<p>You may need to deploy an Ingress controller such as <a href=https://kubernetes.github.io/ingress-nginx/deploy/>ingress-nginx</a>. You can choose from a number of
<a href=/docs/concepts/services-networking/ingress-controllers>Ingress controllers</a>.</p>
<p>Ideally, all Ingress controllers should fit the reference specification. In reality, the various Ingress
controllers operate slightly differently.</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> Make sure you review your Ingress controller's documentation to understand the caveats of choosing it.
</div>
<h2 id=the-ingress-resource>The Ingress resource</h2>
<p>A minimal Ingress resource example:</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/en/examples/service/networking/minimal-ingress.yaml download=service/networking/minimal-ingress.yaml><code>service/networking/minimal-ingress.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('service-networking-minimal-ingress-yaml')" title="Copy service/networking/minimal-ingress.yaml to clipboard">
</img>
</div>
<div class=includecode id=service-networking-minimal-ingress-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>networking.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Ingress<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>minimal-ingress<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>nginx.ingress.kubernetes.io/rewrite-target</span>:<span style=color:#bbb> </span>/<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ingressClassName</span>:<span style=color:#bbb> </span>nginx-example<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>http</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>paths</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/testpath<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>pathType</span>:<span style=color:#bbb> </span>Prefix<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>backend</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>service</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>number</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>An Ingress needs <code>apiVersion</code>, <code>kind</code>, <code>metadata</code> and <code>spec</code> fields.
The name of an Ingress object must be a valid
<a href=/docs/concepts/overview/working-with-objects/names#dns-subdomain-names>DNS subdomain name</a>.
For general information about working with config files, see <a href=/docs/tasks/run-application/run-stateless-application-deployment/>deploying applications</a>, <a href=/docs/tasks/configure-pod-container/configure-pod-configmap/>configuring containers</a>, <a href=/docs/concepts/cluster-administration/manage-deployment/>managing resources</a>.
Ingress frequently uses annotations to configure some options depending on the Ingress controller, an example of which
is the <a href=https://github.com/kubernetes/ingress-nginx/blob/master/docs/examples/rewrite/README.md>rewrite-target annotation</a>.
Different <a href=/docs/concepts/services-networking/ingress-controllers>Ingress controllers</a> support different annotations. Review the documentation for
your choice of Ingress controller to learn which annotations are supported.</p>
<p>The Ingress <a href=https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status>spec</a>
has all the information needed to configure a load balancer or proxy server. Most importantly, it
contains a list of rules matched against all incoming requests. Ingress resource only supports rules
for directing HTTP(S) traffic.</p>
<p>If the <code>ingressClassName</code> is omitted, a <a href=#default-ingress-class>default Ingress class</a>
should be defined.</p>
<p>There are some ingress controllers, that work without the definition of a
default <code>IngressClass</code>. For example, the Ingress-NGINX controller can be
configured with a <a href=https://kubernetes.github.io/ingress-nginx/#what-is-the-flag-watch-ingress-without-class>flag</a>
<code>--watch-ingress-without-class</code>. It is <a href=https://kubernetes.github.io/ingress-nginx/#i-have-only-one-instance-of-the-ingresss-nginx-controller-in-my-cluster-what-should-i-do>recommended</a> though, to specify the
default <code>IngressClass</code> as shown <a href=#default-ingress-class>below</a>.</p>
<h3 id=ingress-rules>Ingress rules</h3>
<p>Each HTTP rule contains the following information:</p>
<ul>
<li>An optional host. In this example, no host is specified, so the rule applies to all inbound
HTTP traffic through the IP address specified. If a host is provided (for example,
foo.bar.com), the rules apply to that host.</li>
<li>A list of paths (for example, <code>/testpath</code>), each of which has an associated
backend defined with a <code>service.name</code> and a <code>service.port.name</code> or
<code>service.port.number</code>. Both the host and path must match the content of an
incoming request before the load balancer directs traffic to the referenced
Service.</li>
<li>A backend is a combination of Service and port names as described in the
<a href=/docs/concepts/services-networking/service/>Service doc</a> or a <a href=#resource-backend>custom resource backend</a> by way of a <a class=glossary-tooltip title="Custom code that defines a resource to add to your Kubernetes API server without building a complete custom server." data-toggle=tooltip data-placement=top href=/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/ target=_blank aria-label=CRD>CRD</a>. HTTP (and HTTPS) requests to the
Ingress that matches the host and path of the rule are sent to the listed backend.</li>
</ul>
<p>A <code>defaultBackend</code> is often configured in an Ingress controller to service any requests that do not
match a path in the spec.</p>
<h3 id=default-backend>DefaultBackend</h3>
<p>An Ingress with no rules sends all traffic to a single default backend and <code>.spec.defaultBackend</code>
is the backend that should handle requests in that case.
The <code>defaultBackend</code> is conventionally a configuration option of the
<a href=/docs/concepts/services-networking/ingress-controllers>Ingress controller</a> and
is not specified in your Ingress resources.
If no <code>.spec.rules</code> are specified, <code>.spec.defaultBackend</code> must be specified.
If <code>defaultBackend</code> is not set, the handling of requests that do not match any of the rules will be up to the
ingress controller (consult the documentation for your ingress controller to find out how it handles this case).</p>
<p>If none of the hosts or paths match the HTTP request in the Ingress objects, the traffic is
routed to your default backend.</p>
<h3 id=resource-backend>Resource backends</h3>
<p>A <code>Resource</code> backend is an ObjectRef to another Kubernetes resource within the
same namespace as the Ingress object. A <code>Resource</code> is a mutually exclusive
setting with Service, and will fail validation if both are specified. A common
usage for a <code>Resource</code> backend is to ingress data to an object storage backend
with static assets.</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/en/examples/service/networking/ingress-resource-backend.yaml download=service/networking/ingress-resource-backend.yaml><code>service/networking/ingress-resource-backend.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('service-networking-ingress-resource-backend-yaml')" title="Copy service/networking/ingress-resource-backend.yaml to clipboard">
</img>
</div>
<div class=includecode id=service-networking-ingress-resource-backend-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>networking.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Ingress<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>ingress-resource-backend<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>defaultBackend</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resource</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>k8s.example.com<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StorageBucket<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>static-assets<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>http</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>paths</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span>- <span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/icons<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>pathType</span>:<span style=color:#bbb> </span>ImplementationSpecific<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>backend</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>resource</span>:<span style=color:#bbb>
</span><span style=color:#bbb>                </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>k8s.example.com<span style=color:#bbb>
</span><span style=color:#bbb>                </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StorageBucket<span style=color:#bbb>
</span><span style=color:#bbb>                </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>icon-assets<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>After creating the Ingress above, you can view it with the following command:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl describe ingress ingress-resource-backend
</code></pre></div><pre><code>Name:             ingress-resource-backend
Namespace:        default
Address:
Default backend:  APIGroup: k8s.example.com, Kind: StorageBucket, Name: static-assets
Rules:
  Host        Path  Backends
  ----        ----  --------
  *
              /icons   APIGroup: k8s.example.com, Kind: StorageBucket, Name: icon-assets
Annotations:  &lt;none&gt;
Events:       &lt;none&gt;
</code></pre><h3 id=path-types>Path types</h3>
<p>Each path in an Ingress is required to have a corresponding path type. Paths
that do not include an explicit <code>pathType</code> will fail validation. There are three
supported path types:</p>
<ul>
<li>
<p><code>ImplementationSpecific</code>: With this path type, matching is up to the
IngressClass. Implementations can treat this as a separate <code>pathType</code> or treat
it identically to <code>Prefix</code> or <code>Exact</code> path types.</p>
</li>
<li>
<p><code>Exact</code>: Matches the URL path exactly and with case sensitivity.</p>
</li>
<li>
<p><code>Prefix</code>: Matches based on a URL path prefix split by <code>/</code>. Matching is case
sensitive and done on a path element by element basis. A path element refers
to the list of labels in the path split by the <code>/</code> separator. A request is a
match for path <em>p</em> if every <em>p</em> is an element-wise prefix of <em>p</em> of the
request path.</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> If the last element of the path is a substring of the last
element in request path, it is not a match (for example: <code>/foo/bar</code>
matches<code>/foo/bar/baz</code>, but does not match <code>/foo/barbaz</code>).
</div>
</li>
</ul>
<h3 id=examples>Examples</h3>
<table>
<thead>
<tr>
<th>Kind</th>
<th>Path(s)</th>
<th>Request path(s)</th>
<th>Matches?</th>
</tr>
</thead>
<tbody>
<tr>
<td>Prefix</td>
<td><code>/</code></td>
<td>(all paths)</td>
<td>Yes</td>
</tr>
<tr>
<td>Exact</td>
<td><code>/foo</code></td>
<td><code>/foo</code></td>
<td>Yes</td>
</tr>
<tr>
<td>Exact</td>
<td><code>/foo</code></td>
<td><code>/bar</code></td>
<td>No</td>
</tr>
<tr>
<td>Exact</td>
<td><code>/foo</code></td>
<td><code>/foo/</code></td>
<td>No</td>
</tr>
<tr>
<td>Exact</td>
<td><code>/foo/</code></td>
<td><code>/foo</code></td>
<td>No</td>
</tr>
<tr>
<td>Prefix</td>
<td><code>/foo</code></td>
<td><code>/foo</code>, <code>/foo/</code></td>
<td>Yes</td>
</tr>
<tr>
<td>Prefix</td>
<td><code>/foo/</code></td>
<td><code>/foo</code>, <code>/foo/</code></td>
<td>Yes</td>
</tr>
<tr>
<td>Prefix</td>
<td><code>/aaa/bb</code></td>
<td><code>/aaa/bbb</code></td>
<td>No</td>
</tr>
<tr>
<td>Prefix</td>
<td><code>/aaa/bbb</code></td>
<td><code>/aaa/bbb</code></td>
<td>Yes</td>
</tr>
<tr>
<td>Prefix</td>
<td><code>/aaa/bbb/</code></td>
<td><code>/aaa/bbb</code></td>
<td>Yes, ignores trailing slash</td>
</tr>
<tr>
<td>Prefix</td>
<td><code>/aaa/bbb</code></td>
<td><code>/aaa/bbb/</code></td>
<td>Yes, matches trailing slash</td>
</tr>
<tr>
<td>Prefix</td>
<td><code>/aaa/bbb</code></td>
<td><code>/aaa/bbb/ccc</code></td>
<td>Yes, matches subpath</td>
</tr>
<tr>
<td>Prefix</td>
<td><code>/aaa/bbb</code></td>
<td><code>/aaa/bbbxyz</code></td>
<td>No, does not match string prefix</td>
</tr>
<tr>
<td>Prefix</td>
<td><code>/</code>, <code>/aaa</code></td>
<td><code>/aaa/ccc</code></td>
<td>Yes, matches <code>/aaa</code> prefix</td>
</tr>
<tr>
<td>Prefix</td>
<td><code>/</code>, <code>/aaa</code>, <code>/aaa/bbb</code></td>
<td><code>/aaa/bbb</code></td>
<td>Yes, matches <code>/aaa/bbb</code> prefix</td>
</tr>
<tr>
<td>Prefix</td>
<td><code>/</code>, <code>/aaa</code>, <code>/aaa/bbb</code></td>
<td><code>/ccc</code></td>
<td>Yes, matches <code>/</code> prefix</td>
</tr>
<tr>
<td>Prefix</td>
<td><code>/aaa</code></td>
<td><code>/ccc</code></td>
<td>No, uses default backend</td>
</tr>
<tr>
<td>Mixed</td>
<td><code>/foo</code> (Prefix), <code>/foo</code> (Exact)</td>
<td><code>/foo</code></td>
<td>Yes, prefers Exact</td>
</tr>
</tbody>
</table>
<h4 id=multiple-matches>Multiple matches</h4>
<p>In some cases, multiple paths within an Ingress will match a request. In those
cases precedence will be given first to the longest matching path. If two paths
are still equally matched, precedence will be given to paths with an exact path
type over prefix path type.</p>
<h2 id=hostname-wildcards>Hostname wildcards</h2>
<p>Hosts can be precise matches (for example “<code>foo.bar.com</code>”) or a wildcard (for
example “<code>*.foo.com</code>”). Precise matches require that the HTTP <code>host</code> header
matches the <code>host</code> field. Wildcard matches require the HTTP <code>host</code> header is
equal to the suffix of the wildcard rule.</p>
<table>
<thead>
<tr>
<th>Host</th>
<th>Host header</th>
<th>Match?</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>*.foo.com</code></td>
<td><code>bar.foo.com</code></td>
<td>Matches based on shared suffix</td>
</tr>
<tr>
<td><code>*.foo.com</code></td>
<td><code>baz.bar.foo.com</code></td>
<td>No match, wildcard only covers a single DNS label</td>
</tr>
<tr>
<td><code>*.foo.com</code></td>
<td><code>foo.com</code></td>
<td>No match, wildcard only covers a single DNS label</td>
</tr>
</tbody>
</table>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/en/examples/service/networking/ingress-wildcard-host.yaml download=service/networking/ingress-wildcard-host.yaml><code>service/networking/ingress-wildcard-host.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('service-networking-ingress-wildcard-host-yaml')" title="Copy service/networking/ingress-wildcard-host.yaml to clipboard">
</img>
</div>
<div class=includecode id=service-networking-ingress-wildcard-host-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>networking.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Ingress<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>ingress-wildcard-host<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>host</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;foo.bar.com&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>http</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>paths</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>pathType</span>:<span style=color:#bbb> </span>Prefix<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/bar&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>backend</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>service</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>service1<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>number</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>host</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;*.foo.com&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>http</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>paths</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>pathType</span>:<span style=color:#bbb> </span>Prefix<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/foo&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>backend</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>service</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>service2<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>number</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<h2 id=ingress-class>Ingress class</h2>
<p>Ingresses can be implemented by different controllers, often with different
configuration. Each Ingress should specify a class, a reference to an
IngressClass resource that contains additional configuration including the name
of the controller that should implement the class.</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/en/examples/service/networking/external-lb.yaml download=service/networking/external-lb.yaml><code>service/networking/external-lb.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('service-networking-external-lb-yaml')" title="Copy service/networking/external-lb.yaml to clipboard">
</img>
</div>
<div class=includecode id=service-networking-external-lb-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>networking.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>IngressClass<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>external-lb<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>controller</span>:<span style=color:#bbb> </span>example.com/ingress-controller<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>parameters</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>k8s.example.com<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>IngressParameters<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>external-lb<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>The <code>.spec.parameters</code> field of an IngressClass lets you reference another
resource that provides configuration related to that IngressClass.</p>
<p>The specific type of parameters to use depends on the ingress controller
that you specify in the <code>.spec.controller</code> field of the IngressClass.</p>
<h3 id=ingressclass-scope>IngressClass scope</h3>
<p>Depending on your ingress controller, you may be able to use parameters
that you set cluster-wide, or just for one namespace.</p>
<ul class="nav nav-tabs" id=tabs-ingressclass-parameter-scope role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tabs-ingressclass-parameter-scope-0 role=tab aria-controls=tabs-ingressclass-parameter-scope-0 aria-selected=true>Cluster</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tabs-ingressclass-parameter-scope-1 role=tab aria-controls=tabs-ingressclass-parameter-scope-1>Namespaced</a></li></ul>
<div class=tab-content id=tabs-ingressclass-parameter-scope><div id=tabs-ingressclass-parameter-scope-0 class="tab-pane show active" role=tabpanel aria-labelledby=tabs-ingressclass-parameter-scope-0>
<p><p>The default scope for IngressClass parameters is cluster-wide.</p>
<p>If you set the <code>.spec.parameters</code> field and don't set
<code>.spec.parameters.scope</code>, or if you set <code>.spec.parameters.scope</code> to
<code>Cluster</code>, then the IngressClass refers to a cluster-scoped resource.
The <code>kind</code> (in combination the <code>apiGroup</code>) of the parameters
refers to a cluster-scoped API (possibly a custom resource), and
the <code>name</code> of the parameters identifies a specific cluster scoped
resource for that API.</p>
<p>For example:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>networking.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>IngressClass<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>external-lb-1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>controller</span>:<span style=color:#bbb> </span>example.com/ingress-controller<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>parameters</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># The parameters for this IngressClass are specified in a</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># ClusterIngressParameter (API group k8s.example.net) named</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># &#34;external-config-1&#34;. This definition tells Kubernetes to</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># look for a cluster-scoped parameter resource.</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>scope</span>:<span style=color:#bbb> </span>Cluster<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>k8s.example.net<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterIngressParameter<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>external-config-1<span style=color:#bbb>
</span></code></pre></div></div>
<div id=tabs-ingressclass-parameter-scope-1 class=tab-pane role=tabpanel aria-labelledby=tabs-ingressclass-parameter-scope-1>
<p><div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.23 [stable]</code>
</div>
<p>If you set the <code>.spec.parameters</code> field and set
<code>.spec.parameters.scope</code> to <code>Namespace</code>, then the IngressClass refers
to a namespaced-scoped resource. You must also set the <code>namespace</code>
field within <code>.spec.parameters</code> to the namespace that contains
the parameters you want to use.</p>
<p>The <code>kind</code> (in combination the <code>apiGroup</code>) of the parameters
refers to a namespaced API (for example: ConfigMap), and
the <code>name</code> of the parameters identifies a specific resource
in the namespace you specified in <code>namespace</code>.</p>
<p>Namespace-scoped parameters help the cluster operator delegate control over the
configuration (for example: load balancer settings, API gateway definition)
that is used for a workload. If you used a cluster-scoped parameter then either:</p>
<ul>
<li>the cluster operator team needs to approve a different team's changes every
time there's a new configuration change being applied.</li>
<li>the cluster operator must define specific access controls, such as
<a href=/docs/reference/access-authn-authz/rbac/>RBAC</a> roles and bindings, that let
the application team make changes to the cluster-scoped parameters resource.</li>
</ul>
<p>The IngressClass API itself is always cluster-scoped.</p>
<p>Here is an example of an IngressClass that refers to parameters that are
namespaced:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>networking.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>IngressClass<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>external-lb-2<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>controller</span>:<span style=color:#bbb> </span>example.com/ingress-controller<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>parameters</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># The parameters for this IngressClass are specified in an</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># IngressParameter (API group k8s.example.com) named &#34;external-config&#34;,</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># that&#39;s in the &#34;external-configuration&#34; namespace.</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>scope</span>:<span style=color:#bbb> </span>Namespace<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>k8s.example.com<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>IngressParameter<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>external-configuration<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>external-config<span style=color:#bbb>
</span></code></pre></div></div></div>
<h3 id=deprecated-annotation>Deprecated annotation</h3>
<p>Before the IngressClass resource and <code>ingressClassName</code> field were added in
Kubernetes 1.18, Ingress classes were specified with a
<code>kubernetes.io/ingress.class</code> annotation on the Ingress. This annotation was
never formally defined, but was widely supported by Ingress controllers.</p>
<p>The newer <code>ingressClassName</code> field on Ingresses is a replacement for that
annotation, but is not a direct equivalent. While the annotation was generally
used to reference the name of the Ingress controller that should implement the
Ingress, the field is a reference to an IngressClass resource that contains
additional Ingress configuration, including the name of the Ingress controller.</p>
<h3 id=default-ingress-class>Default IngressClass</h3>
<p>You can mark a particular IngressClass as default for your cluster. Setting the
<code>ingressclass.kubernetes.io/is-default-class</code> annotation to <code>true</code> on an
IngressClass resource will ensure that new Ingresses without an
<code>ingressClassName</code> field specified will be assigned this default IngressClass.</p>
<div class="alert alert-warning caution callout" role=alert>
<strong>Caution:</strong> If you have more than one IngressClass marked as the default for your cluster,
the admission controller prevents creating new Ingress objects that don't have
an <code>ingressClassName</code> specified. You can resolve this by ensuring that at most 1
IngressClass is marked as default in your cluster.
</div>
<p>There are some ingress controllers, that work without the definition of a
default <code>IngressClass</code>. For example, the Ingress-NGINX controller can be
configured with a <a href=https://kubernetes.github.io/ingress-nginx/#what-is-the-flag-watch-ingress-without-class>flag</a>
<code>--watch-ingress-without-class</code>. It is <a href=https://kubernetes.github.io/ingress-nginx/#i-have-only-one-instance-of-the-ingresss-nginx-controller-in-my-cluster-what-should-i-do>recommended</a> though, to specify the
default <code>IngressClass</code>:</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/en/examples/service/networking/default-ingressclass.yaml download=service/networking/default-ingressclass.yaml><code>service/networking/default-ingressclass.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('service-networking-default-ingressclass-yaml')" title="Copy service/networking/default-ingressclass.yaml to clipboard">
</img>
</div>
<div class=includecode id=service-networking-default-ingressclass-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>networking.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>IngressClass<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/component</span>:<span style=color:#bbb> </span>controller<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-example<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>ingressclass.kubernetes.io/is-default-class</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>controller</span>:<span style=color:#bbb> </span>k8s.io/ingress-nginx<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<h2 id=types-of-ingress>Types of Ingress</h2>
<h3 id=single-service-ingress>Ingress backed by a single Service</h3>
<p>There are existing Kubernetes concepts that allow you to expose a single Service
(see <a href=#alternatives>alternatives</a>). You can also do this with an Ingress by specifying a
<em>default backend</em> with no rules.</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/en/examples/service/networking/test-ingress.yaml download=service/networking/test-ingress.yaml><code>service/networking/test-ingress.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('service-networking-test-ingress-yaml')" title="Copy service/networking/test-ingress.yaml to clipboard">
</img>
</div>
<div class=includecode id=service-networking-test-ingress-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>networking.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Ingress<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-ingress<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>defaultBackend</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>service</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>number</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>If you create it using <code>kubectl apply -f</code> you should be able to view the state
of the Ingress you added:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl get ingress test-ingress
</code></pre></div><pre><code>NAME           CLASS         HOSTS   ADDRESS         PORTS   AGE
test-ingress   external-lb   *       203.0.113.123   80      59s
</code></pre><p>Where <code>203.0.113.123</code> is the IP allocated by the Ingress controller to satisfy
this Ingress.</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> Ingress controllers and load balancers may take a minute or two to allocate an IP address.
Until that time, you often see the address listed as <code>&lt;pending></code>.
</div>
<h3 id=simple-fanout>Simple fanout</h3>
<p>A fanout configuration routes traffic from a single IP address to more than one Service,
based on the HTTP URI being requested. An Ingress allows you to keep the number of load balancers
down to a minimum. For example, a setup like:</p>
<figure>
<div class=mermaid>
graph LR;
client([client])-. Ingress-managed <br> load balancer .->ingress[Ingress, 178.91.123.132];
ingress-->|/foo|service1[Service service1:4200];
ingress-->|/bar|service2[Service service2:8080];
subgraph cluster
ingress;
service1-->pod1[Pod];
service1-->pod2[Pod];
service2-->pod3[Pod];
service2-->pod4[Pod];
end
classDef plain fill:#ddd,stroke:#fff,stroke-width:4px,color:#000;
classDef k8s fill:#326ce5,stroke:#fff,stroke-width:4px,color:#fff;
classDef cluster fill:#fff,stroke:#bbb,stroke-width:2px,color:#326ce5;
class ingress,service1,service2,pod1,pod2,pod3,pod4 k8s;
class client plain;
class cluster cluster;
</div>
</figure>
<noscript>
<div class="alert alert-secondary callout" role=alert>
<em class=javascript-required>JavaScript must be <a href=https://www.enable-javascript.com/>enabled</a> to view this content</em>
</div>
</noscript>
<p>would require an Ingress such as:</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/en/examples/service/networking/simple-fanout-example.yaml download=service/networking/simple-fanout-example.yaml><code>service/networking/simple-fanout-example.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('service-networking-simple-fanout-example-yaml')" title="Copy service/networking/simple-fanout-example.yaml to clipboard">
</img>
</div>
<div class=includecode id=service-networking-simple-fanout-example-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>networking.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Ingress<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>simple-fanout-example<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>host</span>:<span style=color:#bbb> </span>foo.bar.com<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>http</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>paths</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/foo<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>pathType</span>:<span style=color:#bbb> </span>Prefix<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>backend</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>service</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>service1<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>number</span>:<span style=color:#bbb> </span><span style=color:#666>4200</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/bar<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>pathType</span>:<span style=color:#bbb> </span>Prefix<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>backend</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>service</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>service2<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>number</span>:<span style=color:#bbb> </span><span style=color:#666>8080</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>When you create the Ingress with <code>kubectl apply -f</code>:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe ingress simple-fanout-example
</code></pre></div><pre><code>Name:             simple-fanout-example
Namespace:        default
Address:          178.91.123.132
Default backend:  default-http-backend:80 (10.8.2.3:8080)
Rules:
  Host         Path  Backends
  ----         ----  --------
  foo.bar.com
               /foo   service1:4200 (10.8.0.90:4200)
               /bar   service2:8080 (10.8.0.91:8080)
Events:
  Type     Reason  Age                From                     Message
  ----     ------  ----               ----                     -------
  Normal   ADD     22s                loadbalancer-controller  default/test
</code></pre><p>The Ingress controller provisions an implementation-specific load balancer
that satisfies the Ingress, as long as the Services (<code>service1</code>, <code>service2</code>) exist.
When it has done so, you can see the address of the load balancer at the
Address field.</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> Depending on the <a href=/docs/concepts/services-networking/ingress-controllers/>Ingress controller</a>
you are using, you may need to create a default-http-backend
<a href=/docs/concepts/services-networking/service/>Service</a>.
</div>
<h3 id=name-based-virtual-hosting>Name based virtual hosting</h3>
<p>Name-based virtual hosts support routing HTTP traffic to multiple host names at the same IP address.</p>
<figure>
<div class=mermaid>
graph LR;
client([client])-. Ingress-managed <br> load balancer .->ingress[Ingress, 178.91.123.132];
ingress-->|Host: foo.bar.com|service1[Service service1:80];
ingress-->|Host: bar.foo.com|service2[Service service2:80];
subgraph cluster
ingress;
service1-->pod1[Pod];
service1-->pod2[Pod];
service2-->pod3[Pod];
service2-->pod4[Pod];
end
classDef plain fill:#ddd,stroke:#fff,stroke-width:4px,color:#000;
classDef k8s fill:#326ce5,stroke:#fff,stroke-width:4px,color:#fff;
classDef cluster fill:#fff,stroke:#bbb,stroke-width:2px,color:#326ce5;
class ingress,service1,service2,pod1,pod2,pod3,pod4 k8s;
class client plain;
class cluster cluster;
</div>
</figure>
<noscript>
<div class="alert alert-secondary callout" role=alert>
<em class=javascript-required>JavaScript must be <a href=https://www.enable-javascript.com/>enabled</a> to view this content</em>
</div>
</noscript>
<p>The following Ingress tells the backing load balancer to route requests based on
the <a href=https://tools.ietf.org/html/rfc7230#section-5.4>Host header</a>.</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/en/examples/service/networking/name-virtual-host-ingress.yaml download=service/networking/name-virtual-host-ingress.yaml><code>service/networking/name-virtual-host-ingress.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('service-networking-name-virtual-host-ingress-yaml')" title="Copy service/networking/name-virtual-host-ingress.yaml to clipboard">
</img>
</div>
<div class=includecode id=service-networking-name-virtual-host-ingress-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>networking.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Ingress<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>name-virtual-host-ingress<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>host</span>:<span style=color:#bbb> </span>foo.bar.com<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>http</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>paths</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>pathType</span>:<span style=color:#bbb> </span>Prefix<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>backend</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>service</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>service1<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>number</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>host</span>:<span style=color:#bbb> </span>bar.foo.com<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>http</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>paths</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>pathType</span>:<span style=color:#bbb> </span>Prefix<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>backend</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>service</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>service2<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>number</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>If you create an Ingress resource without any hosts defined in the rules, then any
web traffic to the IP address of your Ingress controller can be matched without a name based
virtual host being required.</p>
<p>For example, the following Ingress routes traffic
requested for <code>first.bar.com</code> to <code>service1</code>, <code>second.bar.com</code> to <code>service2</code>, and any traffic whose request host header doesn't match <code>first.bar.com</code> and <code>second.bar.com</code> to <code>service3</code>.</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/en/examples/service/networking/name-virtual-host-ingress-no-third-host.yaml download=service/networking/name-virtual-host-ingress-no-third-host.yaml><code>service/networking/name-virtual-host-ingress-no-third-host.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('service-networking-name-virtual-host-ingress-no-third-host-yaml')" title="Copy service/networking/name-virtual-host-ingress-no-third-host.yaml to clipboard">
</img>
</div>
<div class=includecode id=service-networking-name-virtual-host-ingress-no-third-host-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>networking.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Ingress<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>name-virtual-host-ingress-no-third-host<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>host</span>:<span style=color:#bbb> </span>first.bar.com<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>http</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>paths</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>pathType</span>:<span style=color:#bbb> </span>Prefix<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>backend</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>service</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>service1<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>number</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>host</span>:<span style=color:#bbb> </span>second.bar.com<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>http</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>paths</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>pathType</span>:<span style=color:#bbb> </span>Prefix<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>backend</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>service</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>service2<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>number</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>http</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>paths</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>pathType</span>:<span style=color:#bbb> </span>Prefix<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>backend</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>service</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>service3<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>number</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<h3 id=tls>TLS</h3>
<p>You can secure an Ingress by specifying a <a class=glossary-tooltip title="Stores sensitive information, such as passwords, OAuth tokens, and ssh keys." data-toggle=tooltip data-placement=top href=/docs/concepts/configuration/secret/ target=_blank aria-label=Secret>Secret</a>
that contains a TLS private key and certificate. The Ingress resource only
supports a single TLS port, 443, and assumes TLS termination at the ingress point
(traffic to the Service and its Pods is in plaintext).
If the TLS configuration section in an Ingress specifies different hosts, they are
multiplexed on the same port according to the hostname specified through the
SNI TLS extension (provided the Ingress controller supports SNI). The TLS secret
must contain keys named <code>tls.crt</code> and <code>tls.key</code> that contain the certificate
and private key to use for TLS. For example:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>testsecret-tls<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>tls.crt</span>:<span style=color:#bbb> </span>base64 encoded cert<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>tls.key</span>:<span style=color:#bbb> </span>base64 encoded key<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>kubernetes.io/tls<span style=color:#bbb>
</span></code></pre></div><p>Referencing this secret in an Ingress tells the Ingress controller to
secure the channel from the client to the load balancer using TLS. You need to make
sure the TLS secret you created came from a certificate that contains a Common
Name (CN), also known as a Fully Qualified Domain Name (FQDN) for <code>https-example.foo.com</code>.</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> Keep in mind that TLS will not work on the default rule because the
certificates would have to be issued for all the possible sub-domains. Therefore,
<code>hosts</code> in the <code>tls</code> section need to explicitly match the <code>host</code> in the <code>rules</code>
section.
</div>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/en/examples/service/networking/tls-example-ingress.yaml download=service/networking/tls-example-ingress.yaml><code>service/networking/tls-example-ingress.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('service-networking-tls-example-ingress-yaml')" title="Copy service/networking/tls-example-ingress.yaml to clipboard">
</img>
</div>
<div class=includecode id=service-networking-tls-example-ingress-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>networking.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Ingress<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>tls-example-ingress<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>tls</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>hosts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- https-example.foo.com<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>secretName</span>:<span style=color:#bbb> </span>testsecret-tls<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>host</span>:<span style=color:#bbb> </span>https-example.foo.com<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>http</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>paths</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>pathType</span>:<span style=color:#bbb> </span>Prefix<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>backend</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>service</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>service1<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>number</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> There is a gap between TLS features supported by various Ingress
controllers. Please refer to documentation on
<a href=https://kubernetes.github.io/ingress-nginx/user-guide/tls/>nginx</a>,
<a href=https://git.k8s.io/ingress-gce/README.md#frontend-https>GCE</a>, or any other
platform specific Ingress controller to understand how TLS works in your environment.
</div>
<h3 id=load-balancing>Load balancing</h3>
<p>An Ingress controller is bootstrapped with some load balancing policy settings
that it applies to all Ingress, such as the load balancing algorithm, backend
weight scheme, and others. More advanced load balancing concepts
(e.g. persistent sessions, dynamic weights) are not yet exposed through the
Ingress. You can instead get these features through the load balancer used for
a Service.</p>
<p>It's also worth noting that even though health checks are not exposed directly
through the Ingress, there exist parallel concepts in Kubernetes such as
<a href=/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/>readiness probes</a>
that allow you to achieve the same end result. Please review the controller
specific documentation to see how they handle health checks (for example:
<a href=https://git.k8s.io/ingress-nginx/README.md>nginx</a>, or
<a href=https://git.k8s.io/ingress-gce/README.md#health-checks>GCE</a>).</p>
<h2 id=updating-an-ingress>Updating an Ingress</h2>
<p>To update an existing Ingress to add a new Host, you can update it by editing the resource:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe ingress <span style=color:#a2f>test</span>
</code></pre></div><pre><code>Name:             test
Namespace:        default
Address:          178.91.123.132
Default backend:  default-http-backend:80 (10.8.2.3:8080)
Rules:
  Host         Path  Backends
  ----         ----  --------
  foo.bar.com
               /foo   service1:80 (10.8.0.90:80)
Annotations:
  nginx.ingress.kubernetes.io/rewrite-target:  /
Events:
  Type     Reason  Age                From                     Message
  ----     ------  ----               ----                     -------
  Normal   ADD     35s                loadbalancer-controller  default/test
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl edit ingress <span style=color:#a2f>test</span>
</code></pre></div><p>This pops up an editor with the existing configuration in YAML format.
Modify it to include the new Host:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>host</span>:<span style=color:#bbb> </span>foo.bar.com<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>http</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>paths</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>backend</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>service</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>service1<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>number</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/foo<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>pathType</span>:<span style=color:#bbb> </span>Prefix<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>host</span>:<span style=color:#bbb> </span>bar.baz.com<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>http</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>paths</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>backend</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>service</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>service2<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>number</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/foo<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>pathType</span>:<span style=color:#bbb> </span>Prefix<span style=color:#bbb>
</span><span style=color:#bbb></span>..<span style=color:#bbb>
</span></code></pre></div><p>After you save your changes, kubectl updates the resource in the API server, which tells the
Ingress controller to reconfigure the load balancer.</p>
<p>Verify this:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe ingress <span style=color:#a2f>test</span>
</code></pre></div><pre><code>Name:             test
Namespace:        default
Address:          178.91.123.132
Default backend:  default-http-backend:80 (10.8.2.3:8080)
Rules:
  Host         Path  Backends
  ----         ----  --------
  foo.bar.com
               /foo   service1:80 (10.8.0.90:80)
  bar.baz.com
               /foo   service2:80 (10.8.0.91:80)
Annotations:
  nginx.ingress.kubernetes.io/rewrite-target:  /
Events:
  Type     Reason  Age                From                     Message
  ----     ------  ----               ----                     -------
  Normal   ADD     45s                loadbalancer-controller  default/test
</code></pre><p>You can achieve the same outcome by invoking <code>kubectl replace -f</code> on a modified Ingress YAML file.</p>
<h2 id=failing-across-availability-zones>Failing across availability zones</h2>
<p>Techniques for spreading traffic across failure domains differ between cloud providers.
Please check the documentation of the relevant <a href=/docs/concepts/services-networking/ingress-controllers>Ingress controller</a> for details.</p>
<h2 id=alternatives>Alternatives</h2>
<p>You can expose a Service in multiple ways that don't directly involve the Ingress resource:</p>
<ul>
<li>Use <a href=/docs/concepts/services-networking/service/#loadbalancer>Service.Type=LoadBalancer</a></li>
<li>Use <a href=/docs/concepts/services-networking/service/#nodeport>Service.Type=NodePort</a></li>
</ul>
<h2 id=what-s-next>What's next</h2>
<ul>
<li>Learn about the <a href=/docs/reference/kubernetes-api/service-resources/ingress-v1/>Ingress</a> API</li>
<li>Learn about <a href=/docs/concepts/services-networking/ingress-controllers/>Ingress controllers</a></li>
<li><a href=/docs/tasks/access-application-cluster/ingress-minikube/>Set up Ingress on Minikube with the NGINX Controller</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-5a8edeb1f2dc8e38cd6d561bb08b0d78>6 - Ingress Controllers</h1>
<p>In order for the Ingress resource to work, the cluster must have an ingress controller running.</p>
<p>Unlike other types of controllers which run as part of the <code>kube-controller-manager</code> binary, Ingress controllers
are not started automatically with a cluster. Use this page to choose the ingress controller implementation
that best fits your cluster.</p>
<p>Kubernetes as a project supports and maintains <a href=https://github.com/kubernetes-sigs/aws-load-balancer-controller#readme>AWS</a>, <a href=https://git.k8s.io/ingress-gce/README.md#readme>GCE</a>, and
<a href=https://git.k8s.io/ingress-nginx/README.md#readme>nginx</a> ingress controllers.</p>
<h2 id=additional-controllers>Additional controllers</h2>
<div class="alert alert-secondary callout third-party-content" role=alert><strong>Note:</strong>
This section links to third party projects that provide functionality required by Kubernetes. The Kubernetes project authors aren't responsible for these projects, which are listed alphabetically. To add a project to this list, read the <a href=/docs/contribute/style/content-guide/#third-party-content>content guide</a> before submitting a change. <a href=#third-party-content-disclaimer>More information.</a></div>
<ul>
<li><a href="https://docs.microsoft.com/azure/application-gateway/tutorial-ingress-controller-add-on-existing?toc=https%3A%2F%2Fdocs.microsoft.com%2Fen-us%2Fazure%2Faks%2Ftoc.json&bc=https%3A%2F%2Fdocs.microsoft.com%2Fen-us%2Fazure%2Fbread%2Ftoc.json">AKS Application Gateway Ingress Controller</a> is an ingress controller that configures the <a href=https://docs.microsoft.com/azure/application-gateway/overview>Azure Application Gateway</a>.</li>
<li><a href=https://www.getambassador.io/>Ambassador</a> API Gateway is an <a href=https://www.envoyproxy.io>Envoy</a>-based ingress
controller.</li>
<li><a href=https://github.com/apache/apisix-ingress-controller>Apache APISIX ingress controller</a> is an <a href=https://github.com/apache/apisix>Apache APISIX</a>-based ingress controller.</li>
<li><a href=https://github.com/vmware/load-balancer-and-ingress-services-for-kubernetes>Avi Kubernetes Operator</a> provides L4-L7 load-balancing using <a href=https://avinetworks.com/>VMware NSX Advanced Load Balancer</a>.</li>
<li><a href=https://github.com/bfenetworks/ingress-bfe>BFE Ingress Controller</a> is a <a href=https://www.bfe-networks.net>BFE</a>-based ingress controller.</li>
<li>The <a href=https://github.com/citrix/citrix-k8s-ingress-controller#readme>Citrix ingress controller</a> works with
Citrix Application Delivery Controller.</li>
<li><a href=https://projectcontour.io/>Contour</a> is an <a href=https://www.envoyproxy.io/>Envoy</a> based ingress controller.</li>
<li><a href=https://getenroute.io/>EnRoute</a> is an <a href=https://www.envoyproxy.io>Envoy</a> based API gateway that can run as an ingress controller.</li>
<li><a href=https://github.com/megaease/easegress/blob/main/doc/reference/ingresscontroller.md>Easegress IngressController</a> is an <a href=https://megaease.com/easegress/>Easegress</a> based API gateway that can run as an ingress controller.</li>
<li>F5 BIG-IP <a href=https://clouddocs.f5.com/containers/latest/userguide/kubernetes/>Container Ingress Services for Kubernetes</a>
lets you use an Ingress to configure F5 BIG-IP virtual servers.</li>
<li><a href=https://gloo.solo.io>Gloo</a> is an open-source ingress controller based on <a href=https://www.envoyproxy.io>Envoy</a>,
which offers API gateway functionality.</li>
<li><a href=https://haproxy-ingress.github.io/>HAProxy Ingress</a> is an ingress controller for
<a href=https://www.haproxy.org/#desc>HAProxy</a>.</li>
<li>The <a href=https://github.com/haproxytech/kubernetes-ingress#readme>HAProxy Ingress Controller for Kubernetes</a>
is also an ingress controller for <a href=https://www.haproxy.org/#desc>HAProxy</a>.</li>
<li><a href=https://istio.io/latest/docs/tasks/traffic-management/ingress/kubernetes-ingress/>Istio Ingress</a>
is an <a href=https://istio.io/>Istio</a> based ingress controller.</li>
<li>The <a href=https://github.com/Kong/kubernetes-ingress-controller#readme>Kong Ingress Controller for Kubernetes</a>
is an ingress controller driving <a href=https://konghq.com/kong/>Kong Gateway</a>.</li>
<li>The <a href=https://www.nginx.com/products/nginx-ingress-controller/>NGINX Ingress Controller for Kubernetes</a>
works with the <a href=https://www.nginx.com/resources/glossary/nginx/>NGINX</a> webserver (as a proxy).</li>
<li>The <a href=https://www.pomerium.com/docs/k8s/ingress.html>Pomerium Ingress Controller</a> is based on <a href=https://pomerium.com/>Pomerium</a>, which offers context-aware access policy.</li>
<li><a href=https://opensource.zalando.com/skipper/kubernetes/ingress-controller/>Skipper</a> HTTP router and reverse proxy for service composition, including use cases like Kubernetes Ingress, designed as a library to build your custom proxy.</li>
<li>The <a href=https://doc.traefik.io/traefik/providers/kubernetes-ingress/>Traefik Kubernetes Ingress provider</a> is an
ingress controller for the <a href=https://traefik.io/traefik/>Traefik</a> proxy.</li>
<li><a href=https://github.com/TykTechnologies/tyk-operator>Tyk Operator</a> extends Ingress with Custom Resources to bring API Management capabilities to Ingress. Tyk Operator works with the Open Source Tyk Gateway & Tyk Cloud control plane.</li>
<li><a href=https://appscode.com/products/voyager>Voyager</a> is an ingress controller for
<a href=https://www.haproxy.org/#desc>HAProxy</a>.</li>
</ul>
<h2 id=using-multiple-ingress-controllers>Using multiple Ingress controllers</h2>
<p>You may deploy any number of ingress controllers using <a href=/docs/concepts/services-networking/ingress/#ingress-class>ingress class</a>
within a cluster. Note the <code>.metadata.name</code> of your ingress class resource. When you create an ingress you would need that name to specify the <code>ingressClassName</code> field on your Ingress object (refer to <a href=/docs/reference/kubernetes-api/service-resources/ingress-v1/#IngressSpec>IngressSpec v1 reference</a>. <code>ingressClassName</code> is a replacement of the older <a href=/docs/concepts/services-networking/ingress/#deprecated-annotation>annotation method</a>.</p>
<p>If you do not specify an IngressClass for an Ingress, and your cluster has exactly one IngressClass marked as default, then Kubernetes <a href=/docs/concepts/services-networking/ingress/#default-ingress-class>applies</a> the cluster's default IngressClass to the Ingress.
You mark an IngressClass as default by setting the <a href=/docs/reference/labels-annotations-taints/#ingressclass-kubernetes-io-is-default-class><code>ingressclass.kubernetes.io/is-default-class</code> annotation</a> on that IngressClass, with the string value <code>"true"</code>.</p>
<p>Ideally, all ingress controllers should fulfill this specification, but the various ingress
controllers operate slightly differently.</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> Make sure you review your ingress controller's documentation to understand the caveats of choosing it.
</div>
<h2 id=what-s-next>What's next</h2>
<ul>
<li>Learn more about <a href=/docs/concepts/services-networking/ingress/>Ingress</a>.</li>
<li><a href=/docs/tasks/access-application-cluster/ingress-minikube>Set up Ingress on Minikube with the NGINX Controller</a>.</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-f51db1097575de8072afe1f5b156a70c>7 - EndpointSlices</h1>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.21 [stable]</code>
</div>
<p><em>EndpointSlices</em> provide a simple way to track network endpoints within a
Kubernetes cluster. They offer a more scalable and extensible alternative to
Endpoints.</p>
<h2 id=motivation>Motivation</h2>
<p>The Endpoints API has provided a simple and straightforward way of
tracking network endpoints in Kubernetes. Unfortunately as Kubernetes clusters
and <a class=glossary-tooltip title="A way to expose an application running on a set of Pods as a network service." data-toggle=tooltip data-placement=top href=/docs/concepts/services-networking/service/ target=_blank aria-label=Services>Services</a> have grown to handle and
send more traffic to more backend Pods, limitations of that original API became
more visible.
Most notably, those included challenges with scaling to larger numbers of
network endpoints.</p>
<p>Since all network endpoints for a Service were stored in a single Endpoints
resource, those resources could get quite large. That affected the performance
of Kubernetes components (notably the master control plane) and resulted in
significant amounts of network traffic and processing when Endpoints changed.
EndpointSlices help you mitigate those issues as well as provide an extensible
platform for additional features such as topological routing.</p>
<h2 id=endpointslice-resource>EndpointSlice resources</h2>
<p>In Kubernetes, an EndpointSlice contains references to a set of network
endpoints. The control plane automatically creates EndpointSlices
for any Kubernetes Service that has a <a class=glossary-tooltip title="Allows users to filter a list of resources based on labels." data-toggle=tooltip data-placement=top href=/docs/concepts/overview/working-with-objects/labels/ target=_blank aria-label=selector>selector</a> specified. These EndpointSlices include
references to all the Pods that match the Service selector. EndpointSlices group
network endpoints together by unique combinations of protocol, port number, and
Service name.
The name of a EndpointSlice object must be a valid
<a href=/docs/concepts/overview/working-with-objects/names#dns-subdomain-names>DNS subdomain name</a>.</p>
<p>As an example, here's a sample EndpointSlice resource for the <code>example</code>
Kubernetes Service.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>discovery.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>EndpointSlice<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>example-abc<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubernetes.io/service-name</span>:<span style=color:#bbb> </span>example<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>addressType</span>:<span style=color:#bbb> </span>IPv4<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>http<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>endpoints</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>addresses</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:#b44>&#34;10.1.2.3&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>conditions</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>ready</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>hostname</span>:<span style=color:#bbb> </span>pod-1<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>nodeName</span>:<span style=color:#bbb> </span>node-1<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>zone</span>:<span style=color:#bbb> </span>us-west2-a<span style=color:#bbb>
</span></code></pre></div><p>By default, the control plane creates and manages EndpointSlices to have no
more than 100 endpoints each. You can configure this with the
<code>--max-endpoints-per-slice</code>
<a class=glossary-tooltip title="Control Plane component that runs controller processes." data-toggle=tooltip data-placement=top href=/docs/reference/command-line-tools-reference/kube-controller-manager/ target=_blank aria-label=kube-controller-manager>kube-controller-manager</a>
flag, up to a maximum of 1000.</p>
<p>EndpointSlices can act as the source of truth for
<a class=glossary-tooltip title="kube-proxy is a network proxy that runs on each node in the cluster." data-toggle=tooltip data-placement=top href=/docs/reference/command-line-tools-reference/kube-proxy/ target=_blank aria-label=kube-proxy>kube-proxy</a> when it comes to
how to route internal traffic. When enabled, they should provide a performance
improvement for services with large numbers of endpoints.</p>
<h3 id=address-types>Address types</h3>
<p>EndpointSlices support three address types:</p>
<ul>
<li>IPv4</li>
<li>IPv6</li>
<li>FQDN (Fully Qualified Domain Name)</li>
</ul>
<h3 id=conditions>Conditions</h3>
<p>The EndpointSlice API stores conditions about endpoints that may be useful for consumers.
The three conditions are <code>ready</code>, <code>serving</code>, and <code>terminating</code>.</p>
<h4 id=ready>Ready</h4>
<p><code>ready</code> is a condition that maps to a Pod's <code>Ready</code> condition. A running Pod with the <code>Ready</code>
condition set to <code>True</code> should have this EndpointSlice condition also set to <code>true</code>. For
compatibility reasons, <code>ready</code> is NEVER <code>true</code> when a Pod is terminating. Consumers should refer
to the <code>serving</code> condition to inspect the readiness of terminating Pods. The only exception to
this rule is for Services with <code>spec.publishNotReadyAddresses</code> set to <code>true</code>. Endpoints for these
Services will always have the <code>ready</code> condition set to <code>true</code>.</p>
<h4 id=serving>Serving</h4>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.20 [alpha]</code>
</div>
<p><code>serving</code> is identical to the <code>ready</code> condition, except it does not account for terminating states.
Consumers of the EndpointSlice API should check this condition if they care about pod readiness while
the pod is also terminating.</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> Although <code>serving</code> is almost identical to <code>ready</code>, it was added to prevent break the existing meaning
of <code>ready</code>. It may be unexpected for existing clients if <code>ready</code> could be <code>true</code> for terminating
endpoints, since historically terminating endpoints were never included in the Endpoints or
EndpointSlice API to begin with. For this reason, <code>ready</code> is <em>always</em> <code>false</code> for terminating
endpoints, and a new condition <code>serving</code> was added in v1.20 so that clients can track readiness
for terminating pods independent of the existing semantics for <code>ready</code>.
</div>
<h4 id=terminating>Terminating</h4>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.20 [alpha]</code>
</div>
<p><code>Terminating</code> is a condition that indicates whether an endpoint is terminating.
For pods, this is any pod that has a deletion timestamp set.</p>
<h3 id=topology>Topology information</h3>
<p>Each endpoint within an EndpointSlice can contain relevant topology information.
The topology information includes the location of the endpoint and information
about the corresponding Node and zone. These are available in the following
per endpoint fields on EndpointSlices:</p>
<ul>
<li><code>nodeName</code> - The name of the Node this endpoint is on.</li>
<li><code>zone</code> - The zone this endpoint is in.</li>
</ul>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> <p>In the v1 API, the per endpoint <code>topology</code> was effectively removed in favor of
the dedicated fields <code>nodeName</code> and <code>zone</code>.</p>
<p>Setting arbitrary topology fields on the <code>endpoint</code> field of an <code>EndpointSlice</code>
resource has been deprecated and is not supported in the v1 API.
Instead, the v1 API supports setting individual <code>nodeName</code> and <code>zone</code> fields.
These fields are automatically translated between API versions. For example, the
value of the <code>"topology.kubernetes.io/zone"</code> key in the <code>topology</code> field in
the v1beta1 API is accessible as the <code>zone</code> field in the v1 API.</p>
</div>
<h3 id=management>Management</h3>
<p>Most often, the control plane (specifically, the endpoint slice
<a class=glossary-tooltip title="A control loop that watches the shared state of the cluster through the apiserver and makes changes attempting to move the current state towards the desired state." data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/controller/ target=_blank aria-label=controller>controller</a>) creates and
manages EndpointSlice objects. There are a variety of other use cases for
EndpointSlices, such as service mesh implementations, that could result in other
entities or controllers managing additional sets of EndpointSlices.</p>
<p>To ensure that multiple entities can manage EndpointSlices without interfering
with each other, Kubernetes defines the
<a class=glossary-tooltip title="Tags objects with identifying attributes that are meaningful and relevant to users." data-toggle=tooltip data-placement=top href=/docs/concepts/overview/working-with-objects/labels target=_blank aria-label=label>label</a>
<code>endpointslice.kubernetes.io/managed-by</code>, which indicates the entity managing
an EndpointSlice.
The endpoint slice controller sets <code>endpointslice-controller.k8s.io</code> as the value
for this label on all EndpointSlices it manages. Other entities managing
EndpointSlices should also set a unique value for this label.</p>
<h3 id=ownership>Ownership</h3>
<p>In most use cases, EndpointSlices are owned by the Service that the endpoint
slice object tracks endpoints for. This ownership is indicated by an owner
reference on each EndpointSlice as well as a <code>kubernetes.io/service-name</code>
label that enables simple lookups of all EndpointSlices belonging to a Service.</p>
<h3 id=endpointslice-mirroring>EndpointSlice mirroring</h3>
<p>In some cases, applications create custom Endpoints resources. To ensure that
these applications do not need to concurrently write to both Endpoints and
EndpointSlice resources, the cluster's control plane mirrors most Endpoints
resources to corresponding EndpointSlices.</p>
<p>The control plane mirrors Endpoints resources unless:</p>
<ul>
<li>the Endpoints resource has a <code>endpointslice.kubernetes.io/skip-mirror</code> label
set to <code>true</code>.</li>
<li>the Endpoints resource has a <code>control-plane.alpha.kubernetes.io/leader</code>
annotation.</li>
<li>the corresponding Service resource does not exist.</li>
<li>the corresponding Service resource has a non-nil selector.</li>
</ul>
<p>Individual Endpoints resources may translate into multiple EndpointSlices. This
will occur if an Endpoints resource has multiple subsets or includes endpoints
with multiple IP families (IPv4 and IPv6). A maximum of 1000 addresses per
subset will be mirrored to EndpointSlices.</p>
<h3 id=distribution-of-endpointslices>Distribution of EndpointSlices</h3>
<p>Each EndpointSlice has a set of ports that applies to all endpoints within the
resource. When named ports are used for a Service, Pods may end up with
different target port numbers for the same named port, requiring different
EndpointSlices. This is similar to the logic behind how subsets are grouped
with Endpoints.</p>
<p>The control plane tries to fill EndpointSlices as full as possible, but does not
actively rebalance them. The logic is fairly straightforward:</p>
<ol>
<li>Iterate through existing EndpointSlices, remove endpoints that are no longer
desired and update matching endpoints that have changed.</li>
<li>Iterate through EndpointSlices that have been modified in the first step and
fill them up with any new endpoints needed.</li>
<li>If there's still new endpoints left to add, try to fit them into a previously
unchanged slice and/or create new ones.</li>
</ol>
<p>Importantly, the third step prioritizes limiting EndpointSlice updates over a
perfectly full distribution of EndpointSlices. As an example, if there are 10
new endpoints to add and 2 EndpointSlices with room for 5 more endpoints each,
this approach will create a new EndpointSlice instead of filling up the 2
existing EndpointSlices. In other words, a single EndpointSlice creation is
preferrable to multiple EndpointSlice updates.</p>
<p>With kube-proxy running on each Node and watching EndpointSlices, every change
to an EndpointSlice becomes relatively expensive since it will be transmitted to
every Node in the cluster. This approach is intended to limit the number of
changes that need to be sent to every Node, even if it may result with multiple
EndpointSlices that are not full.</p>
<p>In practice, this less than ideal distribution should be rare. Most changes
processed by the EndpointSlice controller will be small enough to fit in an
existing EndpointSlice, and if not, a new EndpointSlice is likely going to be
necessary soon anyway. Rolling updates of Deployments also provide a natural
repacking of EndpointSlices with all Pods and their corresponding endpoints
getting replaced.</p>
<h3 id=duplicate-endpoints>Duplicate endpoints</h3>
<p>Due to the nature of EndpointSlice changes, endpoints may be represented in more
than one EndpointSlice at the same time. This naturally occurs as changes to
different EndpointSlice objects can arrive at the Kubernetes client watch/cache
at different times. Implementations using EndpointSlice must be able to have the
endpoint appear in more than one slice. A reference implementation of how to
perform endpoint deduplication can be found in the <code>EndpointSliceCache</code>
implementation in <code>kube-proxy</code>.</p>
<h2 id=what-s-next>What's next</h2>
<ul>
<li>Read <a href=/docs/concepts/services-networking/connect-applications-service/>Connecting Applications with Services</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-cd7657b1056ad32451974db57a951ba5>8 - Service Internal Traffic Policy</h1>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.23 [beta]</code>
</div>
<p><em>Service Internal Traffic Policy</em> enables internal traffic restrictions to only route
internal traffic to endpoints within the node the traffic originated from. The
"internal" traffic here refers to traffic originated from Pods in the current
cluster. This can help to reduce costs and improve performance.</p>
<h2 id=using-service-internal-traffic-policy>Using Service Internal Traffic Policy</h2>
<p>The <code>ServiceInternalTrafficPolicy</code> <a href=/docs/reference/command-line-tools-reference/feature-gates/>feature gate</a>
is a Beta feature and enabled by default.
When the feature is enabled, you can enable the internal-only traffic policy for a
<a class=glossary-tooltip title="A way to expose an application running on a set of Pods as a network service." data-toggle=tooltip data-placement=top href=/docs/concepts/services-networking/service/ target=_blank aria-label=Services>Services</a>, by setting its
<code>.spec.internalTrafficPolicy</code> to <code>Local</code>.
This tells kube-proxy to only use node local endpoints for cluster internal traffic.</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> For pods on nodes with no endpoints for a given Service, the Service
behaves as if it has zero endpoints (for Pods on this node) even if the service
does have endpoints on other nodes.
</div>
<p>The following example shows what a Service looks like when you set
<code>.spec.internalTrafficPolicy</code> to <code>Local</code>:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>MyApp<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>9376</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>internalTrafficPolicy</span>:<span style=color:#bbb> </span>Local<span style=color:#bbb>
</span></code></pre></div><h2 id=how-it-works>How it works</h2>
<p>The kube-proxy filters the endpoints it routes to based on the
<code>spec.internalTrafficPolicy</code> setting. When it's set to <code>Local</code>, only node local
endpoints are considered. When it's <code>Cluster</code> or missing, all endpoints are
considered.
When the <a href=/docs/reference/command-line-tools-reference/feature-gates/>feature gate</a>
<code>ServiceInternalTrafficPolicy</code> is enabled, <code>spec.internalTrafficPolicy</code> defaults to "Cluster".</p>
<h2 id=constraints>Constraints</h2>
<ul>
<li>Service Internal Traffic Policy is not used when <code>externalTrafficPolicy</code> is set
to <code>Local</code> on a Service. It is possible to use both features in the same cluster
on different Services, just not on the same Service.</li>
</ul>
<h2 id=what-s-next>What's next</h2>
<ul>
<li>Read about <a href=/docs/concepts/services-networking/topology-aware-hints>Topology Aware Hints</a></li>
<li>Read about <a href=/docs/tasks/access-application-cluster/create-external-load-balancer/#preserving-the-client-source-ip>Service External Traffic Policy</a></li>
<li>Read <a href=/docs/concepts/services-networking/connect-applications-service/>Connecting Applications with Services</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-374e5c954990aec58a0797adc70a5039>9 - Topology Aware Hints</h1>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.23 [beta]</code>
</div>
<p><em>Topology Aware Hints</em> enable topology aware routing by including suggestions
for how clients should consume endpoints. This approach adds metadata to enable
consumers of EndpointSlice and / or Endpoints objects, so that traffic to
those network endpoints can be routed closer to where it originated.</p>
<p>For example, you can route traffic within a locality to reduce
costs, or to improve network performance.</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> The "topology-aware hints" feature is at Beta stage and it is <strong>NOT</strong> enabled
by default. To try out this feature, you have to enable the <code>TopologyAwareHints</code>
<a href=/docs/reference/command-line-tools-reference/feature-gates/>feature gate</a>.
</div>
<h2 id=motivation>Motivation</h2>
<p>Kubernetes clusters are increasingly deployed in multi-zone environments.
<em>Topology Aware Hints</em> provides a mechanism to help keep traffic within the zone
it originated from. This concept is commonly referred to as "Topology Aware
Routing". When calculating the endpoints for a <a class=glossary-tooltip title="A way to expose an application running on a set of Pods as a network service." data-toggle=tooltip data-placement=top href=/docs/concepts/services-networking/service/ target=_blank aria-label=Service>Service</a>,
the EndpointSlice controller considers the topology (region and zone) of each endpoint
and populates the hints field to allocate it to a zone.
Cluster components such as the <a class=glossary-tooltip title="kube-proxy is a network proxy that runs on each node in the cluster." data-toggle=tooltip data-placement=top href=/docs/reference/command-line-tools-reference/kube-proxy/ target=_blank aria-label=kube-proxy>kube-proxy</a>
can then consume those hints, and use them to influence how the traffic is routed
(favoring topologically closer endpoints).</p>
<h2 id=using-topology-aware-hints>Using Topology Aware Hints</h2>
<p>You can activate Topology Aware Hints for a Service by setting the
<code>service.kubernetes.io/topology-aware-hints</code> annotation to <code>auto</code>. This tells
the EndpointSlice controller to set topology hints if it is deemed safe.
Importantly, this does not guarantee that hints will always be set.</p>
<h2 id=implementation>How it works</h2>
<p>The functionality enabling this feature is split into two components: The
EndpointSlice controller and the kube-proxy. This section provides a high level overview
of how each component implements this feature.</p>
<h3 id=implementation-control-plane>EndpointSlice controller</h3>
<p>The EndpointSlice controller is responsible for setting hints on EndpointSlices
when this feature is enabled. The controller allocates a proportional amount of
endpoints to each zone. This proportion is based on the
<a href=/docs/tasks/administer-cluster/reserve-compute-resources/#node-allocatable>allocatable</a>
CPU cores for nodes running in that zone. For example, if one zone had 2 CPU
cores and another zone only had 1 CPU core, the controller would allocated twice
as many endpoints to the zone with 2 CPU cores.</p>
<p>The following example shows what an EndpointSlice looks like when hints have
been populated:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>discovery.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>EndpointSlice<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>example-hints<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubernetes.io/service-name</span>:<span style=color:#bbb> </span>example-svc<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>addressType</span>:<span style=color:#bbb> </span>IPv4<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>http<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>endpoints</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>addresses</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:#b44>&#34;10.1.2.3&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>conditions</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>ready</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>hostname</span>:<span style=color:#bbb> </span>pod-1<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>zone</span>:<span style=color:#bbb> </span>zone-a<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>hints</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>forZones</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;zone-a&#34;</span><span style=color:#bbb>
</span></code></pre></div><h3 id=implementation-kube-proxy>kube-proxy</h3>
<p>The kube-proxy component filters the endpoints it routes to based on the hints set by
the EndpointSlice controller. In most cases, this means that the kube-proxy is able
to route traffic to endpoints in the same zone. Sometimes the controller allocates endpoints
from a different zone to ensure more even distribution of endpoints between zones.
This would result in some traffic being routed to other zones.</p>
<h2 id=safeguards>Safeguards</h2>
<p>The Kubernetes control plane and the kube-proxy on each node apply some
safeguard rules before using Topology Aware Hints. If these don't check out,
the kube-proxy selects endpoints from anywhere in your cluster, regardless of the
zone.</p>
<ol>
<li>
<p><strong>Insufficient number of endpoints:</strong> If there are less endpoints than zones
in a cluster, the controller will not assign any hints.</p>
</li>
<li>
<p><strong>Impossible to achieve balanced allocation:</strong> In some cases, it will be
impossible to achieve a balanced allocation of endpoints among zones. For
example, if zone-a is twice as large as zone-b, but there are only 2
endpoints, an endpoint allocated to zone-a may receive twice as much traffic
as zone-b. The controller does not assign hints if it can't get this "expected
overload" value below an acceptable threshold for each zone. Importantly this
is not based on real-time feedback. It is still possible for individual
endpoints to become overloaded.</p>
</li>
<li>
<p><strong>One or more Nodes has insufficient information:</strong> If any node does not have
a <code>topology.kubernetes.io/zone</code> label or is not reporting a value for
allocatable CPU, the control plane does not set any topology-aware endpoint
hints and so kube-proxy does not filter endpoints by zone.</p>
</li>
<li>
<p><strong>One or more endpoints does not have a zone hint:</strong> When this happens,
the kube-proxy assumes that a transition from or to Topology Aware Hints is
underway. Filtering endpoints for a Service in this state would be dangerous
so the kube-proxy falls back to using all endpoints.</p>
</li>
<li>
<p><strong>A zone is not represented in hints:</strong> If the kube-proxy is unable to find
at least one endpoint with a hint targeting the zone it is running in, it falls
to using endpoints from all zones. This is most likely to happen as you add
a new zone into your existing cluster.</p>
</li>
</ol>
<h2 id=constraints>Constraints</h2>
<ul>
<li>
<p>Topology Aware Hints are not used when either <code>externalTrafficPolicy</code> or
<code>internalTrafficPolicy</code> is set to <code>Local</code> on a Service. It is possible to use
both features in the same cluster on different Services, just not on the same
Service.</p>
</li>
<li>
<p>This approach will not work well for Services that have a large proportion of
traffic originating from a subset of zones. Instead this assumes that incoming
traffic will be roughly proportional to the capacity of the Nodes in each
zone.</p>
</li>
<li>
<p>The EndpointSlice controller ignores unready nodes as it calculates the
proportions of each zone. This could have unintended consequences if a large
portion of nodes are unready.</p>
</li>
<li>
<p>The EndpointSlice controller does not take into account <a class=glossary-tooltip title="A core object consisting of three required properties: key, value, and effect. Tolerations enable the scheduling of pods on nodes or node groups that have a matching taint." data-toggle=tooltip data-placement=top href=/docs/concepts/scheduling-eviction/taint-and-toleration/ target=_blank aria-label=tolerations>tolerations</a> when deploying calculating the
proportions of each zone. If the Pods backing a Service are limited to a
subset of Nodes in the cluster, this will not be taken into account.</p>
</li>
<li>
<p>This may not work well with autoscaling. For example, if a lot of traffic is
originating from a single zone, only the endpoints allocated to that zone will
be handling that traffic. That could result in <a class=glossary-tooltip title="An API resource that automatically scales the number of pod replicas based on targeted CPU utilization or custom metric targets." data-toggle=tooltip data-placement=top href=/docs/tasks/run-application/horizontal-pod-autoscale/ target=_blank aria-label="Horizontal Pod Autoscaler">Horizontal Pod Autoscaler</a>
either not picking up on this event, or newly added pods starting in a
different zone.</p>
</li>
</ul>
<h2 id=what-s-next>What's next</h2>
<ul>
<li>Read <a href=/docs/concepts/services-networking/connect-applications-service/>Connecting Applications with Services</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-ded1daafdcd293023ee333728007ca61>10 - Network Policies</h1>
<p>If you want to control traffic flow at the IP address or port level (OSI layer 3 or 4), then you might consider using Kubernetes NetworkPolicies for particular applications in your cluster. NetworkPolicies are an application-centric construct which allow you to specify how a <a class=glossary-tooltip title="A Pod represents a set of running containers in your cluster." data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/pods/ target=_blank aria-label=pod>pod</a> is allowed to communicate with various network "entities" (we use the word "entity" here to avoid overloading the more common terms such as "endpoints" and "services", which have specific Kubernetes connotations) over the network. NetworkPolicies apply to a connection with a pod on one or both ends, and are not relevant to other connections.</p>
<p>The entities that a Pod can communicate with are identified through a combination of the following 3 identifiers:</p>
<ol>
<li>Other pods that are allowed (exception: a pod cannot block access to itself)</li>
<li>Namespaces that are allowed</li>
<li>IP blocks (exception: traffic to and from the node where a Pod is running is always allowed, regardless of the IP address of the Pod or the node)</li>
</ol>
<p>When defining a pod- or namespace- based NetworkPolicy, you use a <a class=glossary-tooltip title="Allows users to filter a list of resources based on labels." data-toggle=tooltip data-placement=top href=/docs/concepts/overview/working-with-objects/labels/ target=_blank aria-label=selector>selector</a> to specify what traffic is allowed to and from the Pod(s) that match the selector.</p>
<p>Meanwhile, when IP based NetworkPolicies are created, we define policies based on IP blocks (CIDR ranges).</p>
<h2 id=prerequisites>Prerequisites</h2>
<p>Network policies are implemented by the <a href=/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/>network plugin</a>. To use network policies, you must be using a networking solution which supports NetworkPolicy. Creating a NetworkPolicy resource without a controller that implements it will have no effect.</p>
<h2 id=the-two-sorts-of-pod-isolation>The Two Sorts of Pod Isolation</h2>
<p>There are two sorts of isolation for a pod: isolation for egress, and isolation for ingress. They concern what connections may be established. "Isolation" here is not absolute, rather it means "some restrictions apply". The alternative, "non-isolated for $direction", means that no restrictions apply in the stated direction. The two sorts of isolation (or not) are declared independently, and are both relevant for a connection from one pod to another.</p>
<p>By default, a pod is non-isolated for egress; all outbound connections are allowed. A pod is isolated for egress if there is any NetworkPolicy that both selects the pod and has "Egress" in its <code>policyTypes</code>; we say that such a policy applies to the pod for egress. When a pod is isolated for egress, the only allowed connections from the pod are those allowed by the <code>egress</code> list of some NetworkPolicy that applies to the pod for egress. The effects of those <code>egress</code> lists combine additively.</p>
<p>By default, a pod is non-isolated for ingress; all inbound connections are allowed. A pod is isolated for ingress if there is any NetworkPolicy that both selects the pod and has "Ingress" in its <code>policyTypes</code>; we say that such a policy applies to the pod for ingress. When a pod is isolated for ingress, the only allowed connections into the pod are those from the pod's node and those allowed by the <code>ingress</code> list of some NetworkPolicy that applies to the pod for ingress. The effects of those <code>ingress</code> lists combine additively.</p>
<p>Network policies do not conflict; they are additive. If any policy or policies apply to a given pod for a given direction, the connections allowed in that direction from that pod is the union of what the applicable policies allow. Thus, order of evaluation does not affect the policy result.</p>
<p>For a connection from a source pod to a destination pod to be allowed, both the egress policy on the source pod and the ingress policy on the destination pod need to allow the connection. If either side does not allow the connection, it will not happen.</p>
<h2 id=networkpolicy-resource>The NetworkPolicy resource</h2>
<p>See the <a href=/docs/reference/generated/kubernetes-api/v1.23/#networkpolicy-v1-networking-k8s-io>NetworkPolicy</a> reference for a full definition of the resource.</p>
<p>An example NetworkPolicy might look like this:</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/en/examples/service/networking/networkpolicy.yaml download=service/networking/networkpolicy.yaml><code>service/networking/networkpolicy.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('service-networking-networkpolicy-yaml')" title="Copy service/networking/networkpolicy.yaml to clipboard">
</img>
</div>
<div class=includecode id=service-networking-networkpolicy-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>networking.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>NetworkPolicy<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-network-policy<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>podSelector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>role</span>:<span style=color:#bbb> </span>db<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>policyTypes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- Ingress<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- Egress<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ingress</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>from</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>ipBlock</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>cidr</span>:<span style=color:#bbb> </span><span style=color:#666>172.17.0.0</span>/16<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>except</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span>- <span style=color:#666>172.17.1.0</span>/24<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>namespaceSelector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>project</span>:<span style=color:#bbb> </span>myproject<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>podSelector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>role</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>6379</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>egress</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>to</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>ipBlock</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>cidr</span>:<span style=color:#bbb> </span><span style=color:#666>10.0.0.0</span>/24<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>5978</span><span style=color:#bbb>
</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> POSTing this to the API server for your cluster will have no effect unless your chosen networking solution supports network policy.
</div>
<p><strong>Mandatory Fields</strong>: As with all other Kubernetes config, a NetworkPolicy
needs <code>apiVersion</code>, <code>kind</code>, and <code>metadata</code> fields. For general information
about working with config files, see
<a href=/docs/tasks/configure-pod-container/configure-pod-configmap/>Configure Containers Using a ConfigMap</a>,
and <a href=/docs/concepts/overview/working-with-objects/object-management>Object Management</a>.</p>
<p><strong>spec</strong>: NetworkPolicy <a href=https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#spec-and-status>spec</a> has all the information needed to define a particular network policy in the given namespace.</p>
<p><strong>podSelector</strong>: Each NetworkPolicy includes a <code>podSelector</code> which selects the grouping of pods to which the policy applies. The example policy selects pods with the label "role=db". An empty <code>podSelector</code> selects all pods in the namespace.</p>
<p><strong>policyTypes</strong>: Each NetworkPolicy includes a <code>policyTypes</code> list which may include either <code>Ingress</code>, <code>Egress</code>, or both. The <code>policyTypes</code> field indicates whether or not the given policy applies to ingress traffic to selected pod, egress traffic from selected pods, or both. If no <code>policyTypes</code> are specified on a NetworkPolicy then by default <code>Ingress</code> will always be set and <code>Egress</code> will be set if the NetworkPolicy has any egress rules.</p>
<p><strong>ingress</strong>: Each NetworkPolicy may include a list of allowed <code>ingress</code> rules. Each rule allows traffic which matches both the <code>from</code> and <code>ports</code> sections. The example policy contains a single rule, which matches traffic on a single port, from one of three sources, the first specified via an <code>ipBlock</code>, the second via a <code>namespaceSelector</code> and the third via a <code>podSelector</code>.</p>
<p><strong>egress</strong>: Each NetworkPolicy may include a list of allowed <code>egress</code> rules. Each rule allows traffic which matches both the <code>to</code> and <code>ports</code> sections. The example policy contains a single rule, which matches traffic on a single port to any destination in <code>10.0.0.0/24</code>.</p>
<p>So, the example NetworkPolicy:</p>
<ol>
<li>
<p>isolates "role=db" pods in the "default" namespace for both ingress and egress traffic (if they weren't already isolated)</p>
</li>
<li>
<p>(Ingress rules) allows connections to all pods in the "default" namespace with the label "role=db" on TCP port 6379 from:</p>
<ul>
<li>any pod in the "default" namespace with the label "role=frontend"</li>
<li>any pod in a namespace with the label "project=myproject"</li>
<li>IP addresses in the ranges 172.17.0.0–172.17.0.255 and 172.17.2.0–172.17.255.255 (ie, all of 172.17.0.0/16 except 172.17.1.0/24)</li>
</ul>
</li>
<li>
<p>(Egress rules) allows connections from any pod in the "default" namespace with the label "role=db" to CIDR 10.0.0.0/24 on TCP port 5978</p>
</li>
</ol>
<p>See the <a href=/docs/tasks/administer-cluster/declare-network-policy/>Declare Network Policy</a> walkthrough for further examples.</p>
<h2 id=behavior-of-to-and-from-selectors>Behavior of <code>to</code> and <code>from</code> selectors</h2>
<p>There are four kinds of selectors that can be specified in an <code>ingress</code> <code>from</code> section or <code>egress</code> <code>to</code> section:</p>
<p><strong>podSelector</strong>: This selects particular Pods in the same namespace as the NetworkPolicy which should be allowed as ingress sources or egress destinations.</p>
<p><strong>namespaceSelector</strong>: This selects particular namespaces for which all Pods should be allowed as ingress sources or egress destinations.</p>
<p><strong>namespaceSelector</strong> <em>and</em> <strong>podSelector</strong>: A single <code>to</code>/<code>from</code> entry that specifies both <code>namespaceSelector</code> and <code>podSelector</code> selects particular Pods within particular namespaces. Be careful to use correct YAML syntax; this policy:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ingress</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>from</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>namespaceSelector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>user</span>:<span style=color:#bbb> </span>alice<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>podSelector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>role</span>:<span style=color:#bbb> </span>client<span style=color:#bbb>
</span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></code></pre></div><p>contains a single <code>from</code> element allowing connections from Pods with the label <code>role=client</code> in namespaces with the label <code>user=alice</code>. But <em>this</em> policy:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ingress</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>from</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>namespaceSelector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>user</span>:<span style=color:#bbb> </span>alice<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>podSelector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>role</span>:<span style=color:#bbb> </span>client<span style=color:#bbb>
</span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></code></pre></div><p>contains two elements in the <code>from</code> array, and allows connections from Pods in the local Namespace with the label <code>role=client</code>, <em>or</em> from any Pod in any namespace with the label <code>user=alice</code>.</p>
<p>When in doubt, use <code>kubectl describe</code> to see how Kubernetes has interpreted the policy.</p>
<p><a name=behavior-of-ipblock-selectors></a>
<strong>ipBlock</strong>: This selects particular IP CIDR ranges to allow as ingress sources or egress destinations. These should be cluster-external IPs, since Pod IPs are ephemeral and unpredictable.</p>
<p>Cluster ingress and egress mechanisms often require rewriting the source or destination IP
of packets. In cases where this happens, it is not defined whether this happens before or
after NetworkPolicy processing, and the behavior may be different for different
combinations of network plugin, cloud provider, <code>Service</code> implementation, etc.</p>
<p>In the case of ingress, this means that in some cases you may be able to filter incoming
packets based on the actual original source IP, while in other cases, the "source IP" that
the NetworkPolicy acts on may be the IP of a <code>LoadBalancer</code> or of the Pod's node, etc.</p>
<p>For egress, this means that connections from pods to <code>Service</code> IPs that get rewritten to
cluster-external IPs may or may not be subject to <code>ipBlock</code>-based policies.</p>
<h2 id=default-policies>Default policies</h2>
<p>By default, if no policies exist in a namespace, then all ingress and egress traffic is allowed to and from pods in that namespace. The following examples let you change the default behavior
in that namespace.</p>
<h3 id=default-deny-all-ingress-traffic>Default deny all ingress traffic</h3>
<p>You can create a "default" ingress isolation policy for a namespace by creating a NetworkPolicy that selects all pods but does not allow any ingress traffic to those pods.</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/en/examples/service/networking/network-policy-default-deny-ingress.yaml download=service/networking/network-policy-default-deny-ingress.yaml><code>service/networking/network-policy-default-deny-ingress.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('service-networking-network-policy-default-deny-ingress-yaml')" title="Copy service/networking/network-policy-default-deny-ingress.yaml to clipboard">
</img>
</div>
<div class=includecode id=service-networking-network-policy-default-deny-ingress-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>networking.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>NetworkPolicy<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>default-deny-ingress<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>podSelector</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>policyTypes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- Ingress<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>This ensures that even pods that aren't selected by any other NetworkPolicy will still be isolated for ingress. This policy does not affect isolation for egress from any pod.</p>
<h3 id=allow-all-ingress-traffic>Allow all ingress traffic</h3>
<p>If you want to allow all incoming connections to all pods in a namespace, you can create a policy that explicitly allows that.</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/en/examples/service/networking/network-policy-allow-all-ingress.yaml download=service/networking/network-policy-allow-all-ingress.yaml><code>service/networking/network-policy-allow-all-ingress.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('service-networking-network-policy-allow-all-ingress-yaml')" title="Copy service/networking/network-policy-allow-all-ingress.yaml to clipboard">
</img>
</div>
<div class=includecode id=service-networking-network-policy-allow-all-ingress-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>networking.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>NetworkPolicy<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>allow-all-ingress<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>podSelector</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ingress</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- {}<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>policyTypes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- Ingress<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>With this policy in place, no additional policy or policies can cause any incoming connection to those pods to be denied. This policy has no effect on isolation for egress from any pod.</p>
<h3 id=default-deny-all-egress-traffic>Default deny all egress traffic</h3>
<p>You can create a "default" egress isolation policy for a namespace by creating a NetworkPolicy that selects all pods but does not allow any egress traffic from those pods.</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/en/examples/service/networking/network-policy-default-deny-egress.yaml download=service/networking/network-policy-default-deny-egress.yaml><code>service/networking/network-policy-default-deny-egress.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('service-networking-network-policy-default-deny-egress-yaml')" title="Copy service/networking/network-policy-default-deny-egress.yaml to clipboard">
</img>
</div>
<div class=includecode id=service-networking-network-policy-default-deny-egress-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>networking.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>NetworkPolicy<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>default-deny-egress<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>podSelector</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>policyTypes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- Egress<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>This ensures that even pods that aren't selected by any other NetworkPolicy will not be allowed egress traffic. This policy does not
change the ingress isolation behavior of any pod.</p>
<h3 id=allow-all-egress-traffic>Allow all egress traffic</h3>
<p>If you want to allow all connections from all pods in a namespace, you can create a policy that explicitly allows all outgoing connections from pods in that namespace.</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/en/examples/service/networking/network-policy-allow-all-egress.yaml download=service/networking/network-policy-allow-all-egress.yaml><code>service/networking/network-policy-allow-all-egress.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('service-networking-network-policy-allow-all-egress-yaml')" title="Copy service/networking/network-policy-allow-all-egress.yaml to clipboard">
</img>
</div>
<div class=includecode id=service-networking-network-policy-allow-all-egress-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>networking.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>NetworkPolicy<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>allow-all-egress<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>podSelector</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>egress</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- {}<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>policyTypes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- Egress<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>With this policy in place, no additional policy or policies can cause any outgoing connection from those pods to be denied. This policy has no effect on isolation for ingress to any pod.</p>
<h3 id=default-deny-all-ingress-and-all-egress-traffic>Default deny all ingress and all egress traffic</h3>
<p>You can create a "default" policy for a namespace which prevents all ingress AND egress traffic by creating the following NetworkPolicy in that namespace.</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/en/examples/service/networking/network-policy-default-deny-all.yaml download=service/networking/network-policy-default-deny-all.yaml><code>service/networking/network-policy-default-deny-all.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('service-networking-network-policy-default-deny-all-yaml')" title="Copy service/networking/network-policy-default-deny-all.yaml to clipboard">
</img>
</div>
<div class=includecode id=service-networking-network-policy-default-deny-all-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>networking.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>NetworkPolicy<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>default-deny-all<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>podSelector</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>policyTypes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- Ingress<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- Egress<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>This ensures that even pods that aren't selected by any other NetworkPolicy will not be allowed ingress or egress traffic.</p>
<h2 id=sctp-support>SCTP support</h2>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.20 [stable]</code>
</div>
<p>As a stable feature, this is enabled by default. To disable SCTP at a cluster level, you (or your cluster administrator) will need to disable the <code>SCTPSupport</code> <a href=/docs/reference/command-line-tools-reference/feature-gates/>feature gate</a> for the API server with <code>--feature-gates=SCTPSupport=false,…</code>.
When the feature gate is enabled, you can set the <code>protocol</code> field of a NetworkPolicy to <code>SCTP</code>.</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> You must be using a <a class=glossary-tooltip title="Container network interface (CNI) plugins are a type of Network plugin that adheres to the appc/CNI specification." data-toggle=tooltip data-placement=top href=/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/#cni target=_blank aria-label=CNI>CNI</a> plugin that supports SCTP protocol NetworkPolicies.
</div>
<h2 id=targeting-a-range-of-ports>Targeting a range of Ports</h2>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.22 [beta]</code>
</div>
<p>When writing a NetworkPolicy, you can target a range of ports instead of a single port.</p>
<p>This is achievable with the usage of the <code>endPort</code> field, as the following example:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>networking.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>NetworkPolicy<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>multi-port-egress<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>podSelector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>role</span>:<span style=color:#bbb> </span>db<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>policyTypes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- Egress<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>egress</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>to</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>ipBlock</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cidr</span>:<span style=color:#bbb> </span><span style=color:#666>10.0.0.0</span>/24<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>32000</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>endPort</span>:<span style=color:#bbb> </span><span style=color:#666>32768</span><span style=color:#bbb>
</span></code></pre></div><p>The above rule allows any Pod with label <code>role=db</code> on the namespace <code>default</code> to communicate
with any IP within the range <code>10.0.0.0/24</code> over TCP, provided that the target
port is between the range 32000 and 32768.</p>
<p>The following restrictions apply when using this field:</p>
<ul>
<li>As a beta feature, this is enabled by default. To disable the <code>endPort</code> field
at a cluster level, you (or your cluster administrator) need to disable the
<code>NetworkPolicyEndPort</code> <a href=/docs/reference/command-line-tools-reference/feature-gates/>feature gate</a>
for the API server with <code>--feature-gates=NetworkPolicyEndPort=false,…</code>.</li>
<li>The <code>endPort</code> field must be equal to or greater than the <code>port</code> field.</li>
<li><code>endPort</code> can only be defined if <code>port</code> is also defined.</li>
<li>Both ports must be numeric.</li>
</ul>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> Your cluster must be using a <a class=glossary-tooltip title="Container network interface (CNI) plugins are a type of Network plugin that adheres to the appc/CNI specification." data-toggle=tooltip data-placement=top href=/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/#cni target=_blank aria-label=CNI>CNI</a> plugin that
supports the <code>endPort</code> field in NetworkPolicy specifications.
If your <a href=/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/>network plugin</a>
does not support the <code>endPort</code> field and you specify a NetworkPolicy with that,
the policy will be applied only for the single <code>port</code> field.
</div>
<h2 id=targeting-a-namespace-by-its-name>Targeting a Namespace by its name</h2>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes 1.22 [stable]</code>
</div>
<p>The Kubernetes control plane sets an immutable label <code>kubernetes.io/metadata.name</code> on all
namespaces, provided that the <code>NamespaceDefaultLabelName</code>
<a href=/docs/reference/command-line-tools-reference/feature-gates/>feature gate</a> is enabled.
The value of the label is the namespace name.</p>
<p>While NetworkPolicy cannot target a namespace by its name with some object field, you can use the
standardized label to target a specific namespace.</p>
<h2 id=what-you-can-t-do-with-network-policies-at-least-not-yet>What you can't do with network policies (at least, not yet)</h2>
<p>As of Kubernetes 1.23, the following functionality does not exist in the NetworkPolicy API, but you might be able to implement workarounds using Operating System components (such as SELinux, OpenVSwitch, IPTables, and so on) or Layer 7 technologies (Ingress controllers, Service Mesh implementations) or admission controllers. In case you are new to network security in Kubernetes, its worth noting that the following User Stories cannot (yet) be implemented using the NetworkPolicy API.</p>
<ul>
<li>Forcing internal cluster traffic to go through a common gateway (this might be best served with a service mesh or other proxy).</li>
<li>Anything TLS related (use a service mesh or ingress controller for this).</li>
<li>Node specific policies (you can use CIDR notation for these, but you cannot target nodes by their Kubernetes identities specifically).</li>
<li>Targeting of services by name (you can, however, target pods or namespaces by their <a class=glossary-tooltip title="Tags objects with identifying attributes that are meaningful and relevant to users." data-toggle=tooltip data-placement=top href=/docs/concepts/overview/working-with-objects/labels target=_blank aria-label=labels>labels</a>, which is often a viable workaround).</li>
<li>Creation or management of "Policy requests" that are fulfilled by a third party.</li>
<li>Default policies which are applied to all namespaces or pods (there are some third party Kubernetes distributions and projects which can do this).</li>
<li>Advanced policy querying and reachability tooling.</li>
<li>The ability to log network security events (for example connections that are blocked or accepted).</li>
<li>The ability to explicitly deny policies (currently the model for NetworkPolicies are deny by default, with only the ability to add allow rules).</li>
<li>The ability to prevent loopback or incoming host traffic (Pods cannot currently block localhost access, nor do they have the ability to block access from their resident node).</li>
</ul>
<h2 id=what-s-next>What's next</h2>
<ul>
<li>See the <a href=/docs/tasks/administer-cluster/declare-network-policy/>Declare Network Policy</a>
walkthrough for further examples.</li>
<li>See more <a href=https://github.com/ahmetb/kubernetes-network-policy-recipes>recipes</a> for common scenarios enabled by the NetworkPolicy resource.</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-21f8d19c60c33914baab66224c3d46a7>11 - IPv4/IPv6 dual-stack</h1>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.23 [stable]</code>
</div>
<p>IPv4/IPv6 dual-stack networking enables the allocation of both IPv4 and IPv6 addresses to <a class=glossary-tooltip title="A Pod represents a set of running containers in your cluster." data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/pods/ target=_blank aria-label=Pods>Pods</a> and <a class=glossary-tooltip title="A way to expose an application running on a set of Pods as a network service." data-toggle=tooltip data-placement=top href=/docs/concepts/services-networking/service/ target=_blank aria-label=Services>Services</a>.</p>
<p>IPv4/IPv6 dual-stack networking is enabled by default for your Kubernetes cluster starting in 1.21, allowing the simultaneous assignment of both IPv4 and IPv6 addresses.</p>
<h2 id=supported-features>Supported Features</h2>
<p>IPv4/IPv6 dual-stack on your Kubernetes cluster provides the following features:</p>
<ul>
<li>Dual-stack Pod networking (a single IPv4 and IPv6 address assignment per Pod)</li>
<li>IPv4 and IPv6 enabled Services</li>
<li>Pod off-cluster egress routing (eg. the Internet) via both IPv4 and IPv6 interfaces</li>
</ul>
<h2 id=prerequisites>Prerequisites</h2>
<p>The following prerequisites are needed in order to utilize IPv4/IPv6 dual-stack Kubernetes clusters:</p>
<ul>
<li>Kubernetes 1.20 or later<br>
For information about using dual-stack services with earlier
Kubernetes versions, refer to the documentation for that version
of Kubernetes.</li>
<li>Provider support for dual-stack networking (Cloud provider or otherwise must be able to provide Kubernetes nodes with routable IPv4/IPv6 network interfaces)</li>
<li>A network plugin that supports dual-stack (such as Kubenet or Calico)</li>
</ul>
<h2 id=configure-ipv4-ipv6-dual-stack>Configure IPv4/IPv6 dual-stack</h2>
<p>To configure IPv4/IPv6 dual-stack, set dual-stack cluster network assignments:</p>
<ul>
<li>kube-apiserver:
<ul>
<li><code>--service-cluster-ip-range=&lt;IPv4 CIDR>,&lt;IPv6 CIDR></code></li>
</ul>
</li>
<li>kube-controller-manager:
<ul>
<li><code>--cluster-cidr=&lt;IPv4 CIDR>,&lt;IPv6 CIDR></code></li>
<li><code>--service-cluster-ip-range=&lt;IPv4 CIDR>,&lt;IPv6 CIDR></code></li>
<li><code>--node-cidr-mask-size-ipv4|--node-cidr-mask-size-ipv6</code> defaults to /24 for IPv4 and /64 for IPv6</li>
</ul>
</li>
<li>kube-proxy:
<ul>
<li><code>--cluster-cidr=&lt;IPv4 CIDR>,&lt;IPv6 CIDR></code></li>
</ul>
</li>
<li>kubelet:
<ul>
<li>when there is no <code>--cloud-provider</code> the administrator can pass a comma-separated pair
of IP addresses via <code>--node-ip</code> to manually configure dual-stack <code>.status.addresses</code>
for that Node.
If a Pod runs on that node in HostNetwork mode, the Pod reports these IP addresses in its
<code>.status.podIPs</code> field.
All <code>podIPs</code> in a node match the IP family preference defined by the
<code>.status.addresses</code> field for that Node.</li>
</ul>
</li>
</ul>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> <p>An example of an IPv4 CIDR: <code>10.244.0.0/16</code> (though you would supply your own address range)</p>
<p>An example of an IPv6 CIDR: <code>fdXY:IJKL:MNOP:15::/64</code> (this shows the format but is not a valid address - see <a href=https://tools.ietf.org/html/rfc4193>RFC 4193</a>)</p>
</div>
<h2 id=services>Services</h2>
<p>You can create <a class=glossary-tooltip title="A way to expose an application running on a set of Pods as a network service." data-toggle=tooltip data-placement=top href=/docs/concepts/services-networking/service/ target=_blank aria-label=Services>Services</a> which can use IPv4, IPv6, or both.</p>
<p>The address family of a Service defaults to the address family of the first service cluster IP range (configured via the <code>--service-cluster-ip-range</code> flag to the kube-apiserver).</p>
<p>When you define a Service you can optionally configure it as dual stack. To specify the behavior you want, you
set the <code>.spec.ipFamilyPolicy</code> field to one of the following values:</p>
<ul>
<li><code>SingleStack</code>: Single-stack service. The control plane allocates a cluster IP for the Service, using the first configured service cluster IP range.</li>
<li><code>PreferDualStack</code>:
<ul>
<li>Allocates IPv4 and IPv6 cluster IPs for the Service.</li>
</ul>
</li>
<li><code>RequireDualStack</code>: Allocates Service <code>.spec.ClusterIPs</code> from both IPv4 and IPv6 address ranges.
<ul>
<li>Selects the <code>.spec.ClusterIP</code> from the list of <code>.spec.ClusterIPs</code> based on the address family of the first element in the <code>.spec.ipFamilies</code> array.</li>
</ul>
</li>
</ul>
<p>If you would like to define which IP family to use for single stack or define the order of IP families for dual-stack, you can choose the address families by setting an optional field, <code>.spec.ipFamilies</code>, on the Service.</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> The <code>.spec.ipFamilies</code> field is immutable because the <code>.spec.ClusterIP</code> cannot be reallocated on a Service that already exists. If you want to change <code>.spec.ipFamilies</code>, delete and recreate the Service.
</div>
<p>You can set <code>.spec.ipFamilies</code> to any of the following array values:</p>
<ul>
<li><code>["IPv4"]</code></li>
<li><code>["IPv6"]</code></li>
<li><code>["IPv4","IPv6"]</code> (dual stack)</li>
<li><code>["IPv6","IPv4"]</code> (dual stack)</li>
</ul>
<p>The first family you list is used for the legacy <code>.spec.ClusterIP</code> field.</p>
<h3 id=dual-stack-service-configuration-scenarios>Dual-stack Service configuration scenarios</h3>
<p>These examples demonstrate the behavior of various dual-stack Service configuration scenarios.</p>
<h4 id=dual-stack-options-on-new-services>Dual-stack options on new Services</h4>
<ol>
<li>This Service specification does not explicitly define <code>.spec.ipFamilyPolicy</code>. When you create this Service, Kubernetes assigns a cluster IP for the Service from the first configured <code>service-cluster-ip-range</code> and sets the <code>.spec.ipFamilyPolicy</code> to <code>SingleStack</code>. (<a href=/docs/concepts/services-networking/service/#services-without-selectors>Services without selectors</a> and <a href=/docs/concepts/services-networking/service/#headless-services>headless Services</a> with selectors will behave in this same way.)</li>
</ol>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/en/examples/service/networking/dual-stack-default-svc.yaml download=service/networking/dual-stack-default-svc.yaml><code>service/networking/dual-stack-default-svc.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('service-networking-dual-stack-default-svc-yaml')" title="Copy service/networking/dual-stack-default-svc.yaml to clipboard">
</img>
</div>
<div class=includecode id=service-networking-dual-stack-default-svc-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>MyApp<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>MyApp<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<ol>
<li>
<p>This Service specification explicitly defines <code>PreferDualStack</code> in <code>.spec.ipFamilyPolicy</code>. When you create this Service on a dual-stack cluster, Kubernetes assigns both IPv4 and IPv6 addresses for the service. The control plane updates the <code>.spec</code> for the Service to record the IP address assignments. The field <code>.spec.ClusterIPs</code> is the primary field, and contains both assigned IP addresses; <code>.spec.ClusterIP</code> is a secondary field with its value calculated from <code>.spec.ClusterIPs</code>.</p>
<ul>
<li>For the <code>.spec.ClusterIP</code> field, the control plane records the IP address that is from the same address family as the first service cluster IP range.</li>
<li>On a single-stack cluster, the <code>.spec.ClusterIPs</code> and <code>.spec.ClusterIP</code> fields both only list one address.</li>
<li>On a cluster with dual-stack enabled, specifying <code>RequireDualStack</code> in <code>.spec.ipFamilyPolicy</code> behaves the same as <code>PreferDualStack</code>.</li>
</ul>
</li>
</ol>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/en/examples/service/networking/dual-stack-preferred-svc.yaml download=service/networking/dual-stack-preferred-svc.yaml><code>service/networking/dual-stack-preferred-svc.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('service-networking-dual-stack-preferred-svc-yaml')" title="Copy service/networking/dual-stack-preferred-svc.yaml to clipboard">
</img>
</div>
<div class=includecode id=service-networking-dual-stack-preferred-svc-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>MyApp<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ipFamilyPolicy</span>:<span style=color:#bbb> </span>PreferDualStack<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>MyApp<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<ol>
<li>This Service specification explicitly defines <code>IPv6</code> and <code>IPv4</code> in <code>.spec.ipFamilies</code> as well as defining <code>PreferDualStack</code> in <code>.spec.ipFamilyPolicy</code>. When Kubernetes assigns an IPv6 and IPv4 address in <code>.spec.ClusterIPs</code>, <code>.spec.ClusterIP</code> is set to the IPv6 address because that is the first element in the <code>.spec.ClusterIPs</code> array, overriding the default.</li>
</ol>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/en/examples/service/networking/dual-stack-preferred-ipfamilies-svc.yaml download=service/networking/dual-stack-preferred-ipfamilies-svc.yaml><code>service/networking/dual-stack-preferred-ipfamilies-svc.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('service-networking-dual-stack-preferred-ipfamilies-svc-yaml')" title="Copy service/networking/dual-stack-preferred-ipfamilies-svc.yaml to clipboard">
</img>
</div>
<div class=includecode id=service-networking-dual-stack-preferred-ipfamilies-svc-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>MyApp<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ipFamilyPolicy</span>:<span style=color:#bbb> </span>PreferDualStack<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ipFamilies</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- IPv6<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- IPv4<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>MyApp<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<h4 id=dual-stack-defaults-on-existing-services>Dual-stack defaults on existing Services</h4>
<p>These examples demonstrate the default behavior when dual-stack is newly enabled on a cluster where Services already exist. (Upgrading an existing cluster to 1.21 or beyond will enable dual-stack.)</p>
<ol>
<li>When dual-stack is enabled on a cluster, existing Services (whether <code>IPv4</code> or <code>IPv6</code>) are configured by the control plane to set <code>.spec.ipFamilyPolicy</code> to <code>SingleStack</code> and set <code>.spec.ipFamilies</code> to the address family of the existing Service. The existing Service cluster IP will be stored in <code>.spec.ClusterIPs</code>.</li>
</ol>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/en/examples/service/networking/dual-stack-default-svc.yaml download=service/networking/dual-stack-default-svc.yaml><code>service/networking/dual-stack-default-svc.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('service-networking-dual-stack-default-svc-yaml')" title="Copy service/networking/dual-stack-default-svc.yaml to clipboard">
</img>
</div>
<div class=includecode id=service-networking-dual-stack-default-svc-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>MyApp<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>MyApp<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>You can validate this behavior by using kubectl to inspect an existing service.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get svc my-service -o yaml
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>MyApp<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>clusterIP</span>:<span style=color:#bbb> </span><span style=color:#666>10.0.197.123</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>clusterIPs</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:#666>10.0.197.123</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ipFamilies</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- IPv4<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ipFamilyPolicy</span>:<span style=color:#bbb> </span>SingleStack<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>MyApp<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>ClusterIP<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>loadBalancer</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span></code></pre></div><ol>
<li>When dual-stack is enabled on a cluster, existing <a href=/docs/concepts/services-networking/service/#headless-services>headless Services</a> with selectors are configured by the control plane to set <code>.spec.ipFamilyPolicy</code> to <code>SingleStack</code> and set <code>.spec.ipFamilies</code> to the address family of the first service cluster IP range (configured via the <code>--service-cluster-ip-range</code> flag to the kube-apiserver) even though <code>.spec.ClusterIP</code> is set to <code>None</code>.</li>
</ol>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/en/examples/service/networking/dual-stack-default-svc.yaml download=service/networking/dual-stack-default-svc.yaml><code>service/networking/dual-stack-default-svc.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('service-networking-dual-stack-default-svc-yaml')" title="Copy service/networking/dual-stack-default-svc.yaml to clipboard">
</img>
</div>
<div class=includecode id=service-networking-dual-stack-default-svc-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>MyApp<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>MyApp<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>You can validate this behavior by using kubectl to inspect an existing headless service with selectors.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get svc my-service -o yaml
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>MyApp<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>clusterIP</span>:<span style=color:#bbb> </span>None<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>clusterIPs</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- None<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ipFamilies</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- IPv4<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ipFamilyPolicy</span>:<span style=color:#bbb> </span>SingleStack<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>MyApp<span style=color:#bbb>
</span></code></pre></div><h4 id=switching-services-between-single-stack-and-dual-stack>Switching Services between single-stack and dual-stack</h4>
<p>Services can be changed from single-stack to dual-stack and from dual-stack to single-stack.</p>
<ol>
<li>
<p>To change a Service from single-stack to dual-stack, change <code>.spec.ipFamilyPolicy</code> from <code>SingleStack</code> to <code>PreferDualStack</code> or <code>RequireDualStack</code> as desired. When you change this Service from single-stack to dual-stack, Kubernetes assigns the missing address family so that the Service now has IPv4 and IPv6 addresses.</p>
<p>Edit the Service specification updating the <code>.spec.ipFamilyPolicy</code> from <code>SingleStack</code> to <code>PreferDualStack</code>.</p>
</li>
</ol>
<p>Before:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ipFamilyPolicy</span>:<span style=color:#bbb> </span>SingleStack<span style=color:#bbb>
</span></code></pre></div><p>After:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ipFamilyPolicy</span>:<span style=color:#bbb> </span>PreferDualStack<span style=color:#bbb>
</span></code></pre></div><ol>
<li>To change a Service from dual-stack to single-stack, change <code>.spec.ipFamilyPolicy</code> from <code>PreferDualStack</code> or <code>RequireDualStack</code> to <code>SingleStack</code>. When you change this Service from dual-stack to single-stack, Kubernetes retains only the first element in the <code>.spec.ClusterIPs</code> array, and sets <code>.spec.ClusterIP</code> to that IP address and sets <code>.spec.ipFamilies</code> to the address family of <code>.spec.ClusterIPs</code>.</li>
</ol>
<h3 id=headless-services-without-selector>Headless Services without selector</h3>
<p>For <a href=/docs/concepts/services-networking/service/#without-selectors>Headless Services without selectors</a> and without <code>.spec.ipFamilyPolicy</code> explicitly set, the <code>.spec.ipFamilyPolicy</code> field defaults to <code>RequireDualStack</code>.</p>
<h3 id=service-type-loadbalancer>Service type LoadBalancer</h3>
<p>To provision a dual-stack load balancer for your Service:</p>
<ul>
<li>Set the <code>.spec.type</code> field to <code>LoadBalancer</code></li>
<li>Set <code>.spec.ipFamilyPolicy</code> field to <code>PreferDualStack</code> or <code>RequireDualStack</code></li>
</ul>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> To use a dual-stack <code>LoadBalancer</code> type Service, your cloud provider must support IPv4 and IPv6 load balancers.
</div>
<h2 id=egress-traffic>Egress traffic</h2>
<p>If you want to enable egress traffic in order to reach off-cluster destinations (eg. the public Internet) from a Pod that uses non-publicly routable IPv6 addresses, you need to enable the Pod to use a publicly routed IPv6 address via a mechanism such as transparent proxying or IP masquerading. The <a href=https://github.com/kubernetes-sigs/ip-masq-agent>ip-masq-agent</a> project supports IP masquerading on dual-stack clusters.</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> Ensure your <a class=glossary-tooltip title="Container network interface (CNI) plugins are a type of Network plugin that adheres to the appc/CNI specification." data-toggle=tooltip data-placement=top href=/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/#cni target=_blank aria-label=CNI>CNI</a> provider supports IPv6.
</div>
<h2 id=what-s-next>What's next</h2>
<ul>
<li><a href=/docs/tasks/network/validate-dual-stack>Validate IPv4/IPv6 dual-stack</a> networking</li>
<li><a href=/docs/setup/production-environment/tools/kubeadm/dual-stack-support/>Enable dual-stack networking using kubeadm
</a></li>
</ul>
</div>
</main>
</div>
</div>
<footer class=d-print-none>
<div class=footer__links>
<nav>
<a class=text-white href=/docs/home/>Home</a>
<a class=text-white href=/blog/>Blog</a>
<a class=text-white href=/training/>Training</a>
<a class=text-white href=/partners/>Partners</a>
<a class=text-white href=/community/>Community</a>
<a class=text-white href=/case-studies/>Case Studies</a>
</nav>
</div>
<div class=container-fluid>
<div class=row>
<div class="col-6 col-sm-2 text-xs-center order-sm-2">
<ul class="list-inline mb-0">
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="User mailing list" aria-label="User mailing list">
<a class=text-white target=_blank href=https://discuss.kubernetes.io>
<i class="fa fa-envelope"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Twitter aria-label=Twitter>
<a class=text-white target=_blank href=https://twitter.com/kubernetesio>
<i class="fab fa-twitter"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Calendar aria-label=Calendar>
<a class=text-white target=_blank href="https://calendar.google.com/calendar/embed?src=calendar%40kubernetes.io">
<i class="fas fa-calendar-alt"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Youtube aria-label=Youtube>
<a class=text-white target=_blank href=https://youtube.com/kubernetescommunity>
<i class="fab fa-youtube"></i>
</a>
</li>
</ul>
</div>
<div class="col-6 col-sm-2 text-right text-xs-center order-sm-3">
<ul class="list-inline mb-0">
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub>
<a class=text-white target=_blank href=https://github.com/kubernetes/kubernetes>
<i class="fab fa-github"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Slack aria-label=Slack>
<a class=text-white target=_blank href=https://slack.k8s.io>
<i class="fab fa-slack"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Contribute aria-label=Contribute>
<a class=text-white target=_blank href=https://git.k8s.io/community/contributors/guide>
<i class="fas fa-edit"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Stack Overflow" aria-label="Stack Overflow">
<a class=text-white target=_blank href=https://stackoverflow.com/questions/tagged/kubernetes>
<i class="fab fa-stack-overflow"></i>
</a>
</li>
</ul>
</div>
<div class="col-12 col-sm-8 text-center order-sm-2">
<small class=text-white>&copy; 2023 The Kubernetes Authors | Documentation Distributed under <a href=https://git.k8s.io/website/LICENSE class=light-text>CC BY 4.0</a></small>
<br>
<small class=text-white>Copyright &copy; 2023 The Linux Foundation &reg;. All rights reserved. The Linux Foundation has registered trademarks and uses trademarks. For a list of trademarks of The Linux Foundation, please see our <a href=https://www.linuxfoundation.org/trademark-usage class=light-text>Trademark Usage page</a></small>
<br>
<small class=text-white>ICP license: 京ICP备17074266号-3</small>
</div>
</div>
</div>
</footer>
</div>
<script src=/js/popper-1.14.3.min.js integrity=sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49 crossorigin=anonymous></script>
<script src=/js/bootstrap-4.3.1.min.js integrity=sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM crossorigin=anonymous></script>
<script src=/js/main.min.40616251a9b6e4b689e7769be0340661efa4d7ebb73f957404e963e135b4ed52.js integrity="sha256-QGFiUam25LaJ53ab4DQGYe+k1+u3P5V0BOlj4TW07VI=" crossorigin=anonymous></script>
</body>
</html>