<!doctype html><html lang=zh class=no-js>
<head>
<meta name=ROBOTS content="NOINDEX, NOFOLLOW">
<script async src="https://www.googletagmanager.com/gtag/js?id=G-JPP6RFM2BP"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-JPP6RFM2BP')</script>
<link rel=alternate hreflang=en href=https://kubernetes.io/docs/reference/kubectl/>
<link rel=alternate hreflang=ko href=https://kubernetes.io/ko/docs/reference/kubectl/>
<link rel=alternate hreflang=ja href=https://kubernetes.io/ja/docs/reference/kubectl/>
<link rel=alternate hreflang=fr href=https://kubernetes.io/fr/docs/reference/kubectl/>
<link rel=alternate hreflang=de href=https://kubernetes.io/de/docs/reference/kubectl/>
<link rel=alternate hreflang=es href=https://kubernetes.io/es/docs/reference/kubectl/>
<link rel=alternate hreflang=pt-br href=https://kubernetes.io/pt-br/docs/reference/kubectl/>
<link rel=alternate hreflang=id href=https://kubernetes.io/id/docs/reference/kubectl/>
<link rel=alternate hreflang=ru href=https://kubernetes.io/ru/docs/reference/kubectl/>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=generator content="Hugo 0.87.0">
<link rel=canonical type=text/html href=https://kubernetes.io/zh/docs/reference/kubectl/>
<link rel="shortcut icon" type=image/png href=/images/favicon.png>
<link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180>
<link rel=manifest href=/manifest.webmanifest>
<link rel=apple-touch-icon href=/images/kubernetes-192x192.png>
<title>kubectl | Kubernetes</title><meta property="og:title" content="kubectl">
<meta property="og:description" content="生产级别的容器编排系统">
<meta property="og:type" content="website">
<meta property="og:url" content="https://kubernetes.io/zh/docs/reference/kubectl/"><meta property="og:site_name" content="Kubernetes">
<meta itemprop=name content="kubectl">
<meta itemprop=description content="生产级别的容器编排系统"><meta name=twitter:card content="summary">
<meta name=twitter:title content="kubectl">
<meta name=twitter:description content="生产级别的容器编排系统">
<link href=/scss/main.css rel=stylesheet>
<script src=/js/jquery-3.3.1.min.js integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin=anonymous></script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","url":"https://kubernetes.io","logo":"https://kubernetes.io/images/favicon.png"}</script>
<meta name=theme-color content="#326ce5">
<link rel=stylesheet href=/css/feature-states.css>
<meta name=description content>
<meta property="og:description" content>
<meta name=twitter:description content>
<meta property="og:url" content="https://kubernetes.io/zh/docs/reference/kubectl/">
<meta property="og:title" content="kubectl">
<meta name=twitter:title content="kubectl">
<meta name=twitter:image content="https://kubernetes.io/images/favicon.png">
<meta name=twitter:image:alt content="Kubernetes">
<meta property="og:image" content="/images/kubernetes-horizontal-color.png">
<meta property="og:type" content="article">
<script src=/js/script.js></script>
</head>
<body class=td-section>
<header>
<nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar" data-auto-burger=primary>
<a class=navbar-brand href=/zh/></a>
<div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar>
<ul class="navbar-nav mt-2 mt-lg-0">
<li class="nav-item mr-2 mb-lg-0">
<a class="nav-link active" href=/zh/docs/>文档</a>
</li>
<li class="nav-item mr-2 mb-lg-0">
<a class=nav-link href=/zh/blog/>Kubernetes 博客</a>
</li>
<li class="nav-item mr-2 mb-lg-0">
<a class=nav-link href=/zh/training/>培训</a>
</li>
<li class="nav-item mr-2 mb-lg-0">
<a class=nav-link href=/zh/partners/>合作伙伴</a>
</li>
<li class="nav-item mr-2 mb-lg-0">
<a class=nav-link href=/zh/community/>社区</a>
</li>
<li class="nav-item mr-2 mb-lg-0">
<a class=nav-link href=/zh/case-studies/>案例分析</a>
</li>
<li class="nav-item dropdown">
<a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>
Versions
</a>
<div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink>
<a class=dropdown-item href=/releases>Release Information</a>
<a class=dropdown-item href=https://kubernetes.io/zh/docs/reference/kubectl/>v1.27</a>
<a class=dropdown-item href=https://v1-26.docs.kubernetes.io/zh/docs/reference/kubectl/>v1.26</a>
<a class=dropdown-item href=https://v1-25.docs.kubernetes.io/zh/docs/reference/kubectl/>v1.25</a>
<a class=dropdown-item href=https://v1-24.docs.kubernetes.io/zh/docs/reference/kubectl/>v1.24</a>
<a class=dropdown-item href=https://v1-23.docs.kubernetes.io/zh/docs/reference/kubectl/>v1.23</a>
</div>
</li>
<li class="nav-item dropdown">
<a class="nav-link dropdown-toggle" href=# id=navbarDropdownMenuLink role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>
中文 Chinese
</a>
<div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink>
<a class=dropdown-item href=/docs/reference/kubectl/>English</a>
<a class=dropdown-item href=/ko/docs/reference/kubectl/>한국어 Korean</a>
<a class=dropdown-item href=/ja/docs/reference/kubectl/>日本語 Japanese</a>
<a class=dropdown-item href=/fr/docs/reference/kubectl/>Français</a>
<a class=dropdown-item href=/de/docs/reference/kubectl/>Deutsch</a>
<a class=dropdown-item href=/es/docs/reference/kubectl/>Español</a>
<a class=dropdown-item href=/pt-br/docs/reference/kubectl/>Português</a>
<a class=dropdown-item href=/id/docs/reference/kubectl/>Bahasa Indonesia</a>
<a class=dropdown-item href=/ru/docs/reference/kubectl/>Русский</a>
</div>
</li>
</ul>
</div>
<button id=hamburger onclick=kub.toggleMenu() data-auto-burger-exclude><div></div></button>
</nav>
</header>
<div class="container-fluid td-outer">
<div class=td-main>
<div class="row flex-xl-nowrap">
<main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main>
<div class=td-content>
<div class="pageinfo pageinfo-primary d-print-none">
<p>
这是本节的多页打印视图。
<a href=# onclick="return print(),!1">点击此处打印</a>.
</p><p>
<a href=/zh/docs/reference/kubectl/>返回本页常规视图</a>.
</p>
</div>
<h1 class=title>kubectl</h1>
<ul>
<li>1: <a href=#pg-d7ffbf04ffbefb241fd0722423b80f5a>kubectl 命令</a></li>
<li>2: <a href=#pg-f14fe15ecc2d41b5e901ef5e872ca657>kubectl 概述</a></li>
<li>3: <a href=#pg-4d3e62632c189fcc3c1357cd8fb8799c>kubectl</a></li>
<li>4: <a href=#pg-a938176c695852fe70362c29cf615f1c>JSONPath 支持</a></li>
<li>5: <a href=#pg-8aba901ac13f124e5782b90ddb166ee2>kubectl 备忘单</a></li>
<li>6: <a href=#pg-8de6aceb8bf692c06cced446bac5bc92>kubectl 的用法约定</a></li>
<li>7: <a href=#pg-a7abc09192597e614b58f8b552b682f5>适用于 Docker 用户的 kubectl</a></li>
</ul>
<div class=content>
</div>
</div>
<div class=td-content>
<h1 id=pg-d7ffbf04ffbefb241fd0722423b80f5a>1 - kubectl 命令</h1>
<p><a href=/docs/reference/generated/kubectl/kubectl-commands/>kubectl 命令参考</a></p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-f14fe15ecc2d41b5e901ef5e872ca657>2 - kubectl 概述</h1>
<p>你可以使用 Kubectl 命令行工具管理 Kubernetes 集群。
<code>kubectl</code> 在 <code>$HOME/.kube</code> 目录中查找一个名为 <code>config</code> 的配置文件。
你可以通过设置 KUBECONFIG 环境变量或设置
<a href=/zh/docs/concepts/configuration/organize-cluster-access-kubeconfig/><code>--kubeconfig</code></a>
参数来指定其它 <a href=/zh/docs/concepts/configuration/organize-cluster-access-kubeconfig/>kubeconfig</a> 文件。</p>
<p>本文概述了 <code>kubectl</code> 语法和命令操作描述，并提供了常见的示例。
有关每个命令的详细信息，包括所有受支持的参数和子命令，
请参阅 <a href=/docs/reference/generated/kubectl/kubectl-commands/>kubectl</a> 参考文档。
有关安装说明，请参见<a href=/zh/docs/tasks/tools/install-kubectl/>安装 kubectl</a> 。</p>
<h2 id=语法>语法</h2>
<p>使用以下语法 <code>kubectl</code> 从终端窗口运行命令：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#666>[</span>command<span style=color:#666>]</span> <span style=color:#666>[</span>TYPE<span style=color:#666>]</span> <span style=color:#666>[</span>NAME<span style=color:#666>]</span> <span style=color:#666>[</span>flags<span style=color:#666>]</span>
</code></pre></div>
<p>其中 <code>command</code>、<code>TYPE</code>、<code>NAME</code> 和 <code>flags</code> 分别是：</p>
<ul>
<li>
<p><code>command</code>：指定要对一个或多个资源执行的操作，例如 <code>create</code>、<code>get</code>、<code>describe</code>、<code>delete</code>。</p>
</li>
<li>
<p><code>TYPE</code>：指定<a href=#%E8%B5%84%E6%BA%90%E7%B1%BB%E5%9E%8B>资源类型</a>。资源类型不区分大小写，
可以指定单数、复数或缩写形式。例如，以下命令输出相同的结果:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod pod1
kubectl get pods pod1
kubectl get po pod1
</code></pre></div></li>
</ul>
<ul>
<li>
<p><code>NAME</code>：指定资源的名称。名称区分大小写。
如果省略名称，则显示所有资源的详细信息 <code>kubectl get pods</code>。</p>
<p>在对多个资源执行操作时，你可以按类型和名称指定每个资源，或指定一个或多个文件：</p>
<ul>
<li>
<p>要按类型和名称指定资源：</p>
<ul>
<li>
<p>要对所有类型相同的资源进行分组，请执行以下操作：<code>TYPE1 name1 name2 name&lt;#></code>。</p>
<p>例子：<code>kubectl get pod example-pod1 example-pod2</code></p>
</li>
<li>
<p>分别指定多个资源类型：<code>TYPE1/name1 TYPE1/name2 TYPE2/name3 TYPE&lt;#>/name&lt;#></code>。</p>
<p>例子：<code>kubectl get pod/example-pod1 replicationcontroller/example-rc1</code></p>
</li>
</ul>
</li>
<li>
<p>用一个或多个文件指定资源：<code>-f file1 -f file2 -f file&lt;#></code></p>
<ul>
<li><a href=/zh/docs/concepts/configuration/overview/#general-configuration-tips>使用 YAML 而不是 JSON</a>
因为 YAML 更容易使用，特别是用于配置文件时。
例子：<code>kubectl get -f ./pod.yaml</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><code>flags</code>: 指定可选的参数。例如，可以使用 <code>-s</code> 或 <code>-server</code> 参数指定
Kubernetes API 服务器的地址和端口。</li>
</ul>
<div class="alert alert-warning caution callout" role=alert>
<strong>Caution:</strong>
<p>从命令行指定的参数会覆盖默认值和任何相应的环境变量。
</div>
<p>如果你需要帮助，从终端窗口运行 <code>kubectl help</code> 。</p>
<h2 id=操作>操作</h2>
<p>下表包含所有 kubectl 操作的简短描述和普通语法：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>语法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>alpha</code></td>
<td><code>kubectl alpha SUBCOMMAND [flags]</code></td>
<td>列出与 alpha 特性对应的可用命令，这些特性在 Kubernetes 集群中默认情况下是不启用的。</td>
</tr>
<tr>
<td><code>annotate</code></td>
<td><code>kubectl annotate (-f FILENAME | TYPE NAME | TYPE/NAME) KEY_1=VAL_1 ... KEY_N=VAL_N [--overwrite] [--all] [--resource-version=version] [flags]</code></td>
<td>添加或更新一个或多个资源的注解。</td>
</tr>
<tr>
<td><code>api-resources</code></td>
<td><code>kubectl api-resources [flags]</code></td>
<td>列出可用的 API 资源。</td>
</tr>
<tr>
<td><code>api-versions</code></td>
<td><code>kubectl api-versions [flags]</code></td>
<td>列出可用的 API 版本。</td>
</tr>
<tr>
<td><code>apply</code></td>
<td><code>kubectl apply -f FILENAME [flags]</code></td>
<td>从文件或 stdin 对资源应用配置更改。</td>
</tr>
<tr>
<td><code>attach</code></td>
<td><code>kubectl attach POD -c CONTAINER [-i] [-t] [flags]</code></td>
<td>附加到正在运行的容器，查看输出流或与容器（stdin）交互。</td>
</tr>
<tr>
<td><code>auth</code></td>
<td><code>kubectl auth [flags] [options]</code></td>
<td>检查授权。</td>
</tr>
<tr>
<td><code>autoscale</code></td>
<td><code>kubectl autoscale (-f FILENAME | TYPE NAME | TYPE/NAME) [--min=MINPODS] --max=MAXPODS [--cpu-percent=CPU] [flags]</code></td>
<td>自动伸缩由副本控制器管理的一组 pod。</td>
</tr>
<tr>
<td><code>certificate</code></td>
<td><code>kubectl certificate SUBCOMMAND [options]</code></td>
<td>修改证书资源。</td>
</tr>
<tr>
<td><code>cluster-info</code></td>
<td><code>kubectl cluster-info [flags]</code></td>
<td>显示有关集群中主服务器和服务的端口信息。</td>
</tr>
<tr>
<td><code>completion</code></td>
<td><code>kubectl completion SHELL [options]</code></td>
<td>为指定的 shell （bash 或 zsh）输出 shell 补齐代码。</td>
</tr>
<tr>
<td><code>config</code></td>
<td><code>kubectl config SUBCOMMAND [flags]</code></td>
<td>修改 kubeconfig 文件。有关详细信息，请参阅各个子命令。</td>
</tr>
<tr>
<td><code>convert</code></td>
<td><code>kubectl convert -f FILENAME [options]</code></td>
<td>在不同的 API 版本之间转换配置文件。配置文件可以是 YAML 或 JSON 格式。</td>
</tr>
<tr>
<td><code>cordon</code></td>
<td><code>kubectl cordon NODE [options]</code></td>
<td>将节点标记为不可调度。</td>
</tr>
<tr>
<td><code>cp</code></td>
<td><code>kubectl cp &lt;file-spec-src> &lt;file-spec-dest> [options]</code></td>
<td>在容器之间复制文件和目录。</td>
</tr>
<tr>
<td><code>create</code></td>
<td><code>kubectl create -f FILENAME [flags]</code></td>
<td>从文件或 stdin 创建一个或多个资源。</td>
</tr>
<tr>
<td><code>delete</code></td>
<td><code>kubectl delete (-f FILENAME | TYPE [NAME | /NAME | -l label | --all]) [flags]</code></td>
<td>从文件、标准输入或指定标签选择器、名称、资源选择器或资源中删除资源。</td>
</tr>
<tr>
<td><code>describe</code></td>
<td><code>kubectl describe (-f FILENAME | TYPE [NAME_PREFIX | /NAME | -l label]) [flags]</code></td>
<td>显示一个或多个资源的详细状态。</td>
</tr>
<tr>
<td><code>diff</code></td>
<td><code>kubectl diff -f FILENAME [flags]</code></td>
<td>将 live 配置和文件或标准输入做对比 (<strong>BETA</strong>)</td>
</tr>
<tr>
<td><code>drain</code></td>
<td><code>kubectl drain NODE [options]</code></td>
<td>腾空节点以准备维护。</td>
</tr>
<tr>
<td><code>edit</code></td>
<td><code>kubectl edit (-f FILENAME | TYPE NAME | TYPE/NAME) [flags]</code></td>
<td>使用默认编辑器编辑和更新服务器上一个或多个资源的定义。</td>
</tr>
<tr>
<td><code>exec</code></td>
<td><code>kubectl exec POD [-c CONTAINER] [-i] [-t] [flags] [-- COMMAND [args...]]</code></td>
<td>对 pod 中的容器执行命令。</td>
</tr>
<tr>
<td><code>explain</code></td>
<td><code>kubectl explain [--recursive=false] [flags]</code></td>
<td>获取多种资源的文档。例如 pod, node, service 等。</td>
</tr>
<tr>
<td><code>expose</code></td>
<td><code>kubectl expose (-f FILENAME | TYPE NAME | TYPE/NAME) [--port=port] [--protocol=TCP|UDP] [--target-port=number-or-name] [--name=name] [--external-ip=external-ip-of-service] [--type=type] [flags]</code></td>
<td>将副本控制器、服务或 pod 作为新的 Kubernetes 服务暴露。</td>
</tr>
<tr>
<td><code>get</code></td>
<td><code>kubectl get (-f FILENAME | TYPE [NAME | /NAME | -l label]) [--watch] [--sort-by=FIELD] [[-o | --output]=OUTPUT_FORMAT] [flags]</code></td>
<td>列出一个或多个资源。</td>
</tr>
<tr>
<td><code>kustomize</code></td>
<td><code>kubectl kustomize &lt;dir> [flags] [options]</code></td>
<td>列出从 kustomization.yaml 文件中的指令生成的一组 API 资源。参数必须是包含文件的目录的路径，或者是 git 存储库 URL，其路径后缀相对于存储库根目录指定了相同的路径。</td>
</tr>
<tr>
<td><code>label</code></td>
<td><code>kubectl label (-f FILENAME | TYPE NAME | TYPE/NAME) KEY_1=VAL_1 ... KEY_N=VAL_N [--overwrite] [--all] [--resource-version=version] [flags]</code></td>
<td>添加或更新一个或多个资源的标签。</td>
</tr>
<tr>
<td><code>logs</code></td>
<td><code>kubectl logs POD [-c CONTAINER] [--follow] [flags]</code></td>
<td>在 pod 中打印容器的日志。</td>
</tr>
<tr>
<td><code>options</code></td>
<td><code>kubectl options</code></td>
<td>全局命令行选项列表，适用于所有命令。</td>
</tr>
<tr>
<td><code>patch</code></td>
<td><code>kubectl patch (-f FILENAME | TYPE NAME | TYPE/NAME) --patch PATCH [flags]</code></td>
<td>使用策略合并 patch 程序更新资源的一个或多个字段。</td>
</tr>
<tr>
<td><code>plugin</code></td>
<td><code>kubectl plugin [flags] [options]</code></td>
<td>提供用于与插件交互的实用程序。</td>
</tr>
<tr>
<td><code>port-forward</code></td>
<td><code>kubectl port-forward POD [LOCAL_PORT:]REMOTE_PORT [...[LOCAL_PORT_N:]REMOTE_PORT_N] [flags]</code></td>
<td>将一个或多个本地端口转发到一个 pod。</td>
</tr>
<tr>
<td><code>proxy</code></td>
<td><code>kubectl proxy [--port=PORT] [--www=static-dir] [--www-prefix=prefix] [--api-prefix=prefix] [flags]</code></td>
<td>运行 Kubernetes API 服务器的代理。</td>
</tr>
<tr>
<td><code>replace</code></td>
<td><code>kubectl replace -f FILENAME</code></td>
<td>从文件或标准输入中替换资源。</td>
</tr>
<tr>
<td><code>rollout</code></td>
<td><code>kubectl rollout SUBCOMMAND [options]</code></td>
<td>管理资源的部署。有效的资源类型包括：Deployments, DaemonSets 和 StatefulSets。</td>
</tr>
<tr>
<td><code>run</code></td>
<td><code>kubectl run NAME --image=image [--env="key=value"] [--port=port] [--dry-run=server | client | none] [--overrides=inline-json] [flags]</code></td>
<td>在集群上运行指定的镜像。</td>
</tr>
<tr>
<td><code>scale</code></td>
<td><code>kubectl scale (-f FILENAME | TYPE NAME | TYPE/NAME) --replicas=COUNT [--resource-version=version] [--current-replicas=count] [flags]</code></td>
<td>更新指定副本控制器的大小。</td>
</tr>
<tr>
<td><code>set</code></td>
<td><code>kubectl set SUBCOMMAND [options]</code></td>
<td>配置应用程序资源。</td>
</tr>
<tr>
<td><code>taint</code></td>
<td><code>kubectl taint NODE NAME KEY_1=VAL_1:TAINT_EFFECT_1 ... KEY_N=VAL_N:TAINT_EFFECT_N [options]</code></td>
<td>更新一个或多个节点上的污点。</td>
</tr>
<tr>
<td><code>top</code></td>
<td><code>kubectl top [flags] [options]</code></td>
<td>显示资源（CPU/内存/存储）的使用情况。</td>
</tr>
<tr>
<td><code>uncordon</code></td>
<td><code>kubectl uncordon NODE [options]</code></td>
<td>将节点标记为可调度。</td>
</tr>
<tr>
<td><code>version</code></td>
<td><code>kubectl version [--client] [flags]</code></td>
<td>显示运行在客户端和服务器上的 Kubernetes 版本。</td>
</tr>
<tr>
<td><code>wait</code></td>
<td><code>kubectl wait ([-f FILENAME] | resource.group/resource.name | resource.group [(-l label | --all)]) [--for=delete|--for condition=available] [options]</code></td>
<td>实验性：等待一种或多种资源的特定条件。</td>
</tr>
</tbody>
</table>
<p>了解更多有关命令操作的信息，请参阅 <a href=/zh/docs/reference/kubectl/kubectl/>kubectl</a> 参考文档。</p>
<h2 id=资源类型>资源类型</h2>
<p>下表列出所有受支持的资源类型及其缩写别名:</p>
<p>(以下输出可以通过 <code>kubectl api-resources</code> 获取，内容以 Kubernetes 1.19.1 版本为准。)</p>
<table>
<thead>
<tr>
<th>资源名</th>
<th>缩写名</th>
<th>API 分组</th>
<th>按命名空间</th>
<th>资源类型</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>bindings</code></td>
<td></td>
<td></td>
<td>true</td>
<td>Binding</td>
</tr>
<tr>
<td><code>componentstatuses</code></td>
<td><code>cs</code></td>
<td></td>
<td>false</td>
<td>ComponentStatus</td>
</tr>
<tr>
<td><code>configmaps</code></td>
<td><code>cm</code></td>
<td></td>
<td>true</td>
<td>ConfigMap</td>
</tr>
<tr>
<td><code>endpoints</code></td>
<td><code>ep</code></td>
<td></td>
<td>true</td>
<td>Endpoints</td>
</tr>
<tr>
<td><code>events</code></td>
<td><code>ev</code></td>
<td></td>
<td>true</td>
<td>Event</td>
</tr>
<tr>
<td><code>limitranges</code></td>
<td><code>limits</code></td>
<td></td>
<td>true</td>
<td>LimitRange</td>
</tr>
<tr>
<td><code>namespaces</code></td>
<td><code>ns</code></td>
<td></td>
<td>false</td>
<td>Namespace</td>
</tr>
<tr>
<td><code>nodes</code></td>
<td><code>no</code></td>
<td></td>
<td>false</td>
<td>Node</td>
</tr>
<tr>
<td><code>persistentvolumeclaims</code></td>
<td><code>pvc</code></td>
<td></td>
<td>true</td>
<td>PersistentVolumeClaim</td>
</tr>
<tr>
<td><code>persistentvolumes</code></td>
<td><code>pv</code></td>
<td></td>
<td>false</td>
<td>PersistentVolume</td>
</tr>
<tr>
<td><code>pods</code></td>
<td><code>po</code></td>
<td></td>
<td>true</td>
<td>Pod</td>
</tr>
<tr>
<td><code>podtemplates</code></td>
<td></td>
<td></td>
<td>true</td>
<td>PodTemplate</td>
</tr>
<tr>
<td><code>replicationcontrollers</code></td>
<td><code>rc</code></td>
<td></td>
<td>true</td>
<td>ReplicationController</td>
</tr>
<tr>
<td><code>resourcequotas</code></td>
<td><code>quota</code></td>
<td></td>
<td>true</td>
<td>ResourceQuota</td>
</tr>
<tr>
<td><code>secrets</code></td>
<td></td>
<td></td>
<td>true</td>
<td>Secret</td>
</tr>
<tr>
<td><code>serviceaccounts</code></td>
<td><code>sa</code></td>
<td></td>
<td>true</td>
<td>ServiceAccount</td>
</tr>
<tr>
<td><code>services</code></td>
<td><code>svc</code></td>
<td></td>
<td>true</td>
<td>Service</td>
</tr>
<tr>
<td><code>mutatingwebhookconfigurations</code></td>
<td></td>
<td>admissionregistration.k8s.io</td>
<td>false</td>
<td>MutatingWebhookConfiguration</td>
</tr>
<tr>
<td><code>validatingwebhookconfigurations</code></td>
<td></td>
<td>admissionregistration.k8s.io</td>
<td>false</td>
<td>ValidatingWebhookConfiguration</td>
</tr>
<tr>
<td><code>customresourcedefinitions</code></td>
<td><code>crd,crds</code></td>
<td>apiextensions.k8s.io</td>
<td>false</td>
<td>CustomResourceDefinition</td>
</tr>
<tr>
<td><code>apiservices</code></td>
<td></td>
<td>apiregistration.k8s.io</td>
<td>false</td>
<td>APIService</td>
</tr>
<tr>
<td><code>controllerrevisions</code></td>
<td></td>
<td>apps</td>
<td>true</td>
<td>ControllerRevision</td>
</tr>
<tr>
<td><code>daemonsets</code></td>
<td><code>ds</code></td>
<td>apps</td>
<td>true</td>
<td>DaemonSet</td>
</tr>
<tr>
<td><code>deployments</code></td>
<td><code>deploy</code></td>
<td>apps</td>
<td>true</td>
<td>Deployment</td>
</tr>
<tr>
<td><code>replicasets</code></td>
<td><code>rs</code></td>
<td>apps</td>
<td>true</td>
<td>ReplicaSet</td>
</tr>
<tr>
<td><code>statefulsets</code></td>
<td><code>sts</code></td>
<td>apps</td>
<td>true</td>
<td>StatefulSet</td>
</tr>
<tr>
<td><code>tokenreviews</code></td>
<td></td>
<td>authentication.k8s.io</td>
<td>false</td>
<td>TokenReview</td>
</tr>
<tr>
<td><code>localsubjectaccessreviews</code></td>
<td></td>
<td>authorization.k8s.io</td>
<td>true</td>
<td>LocalSubjectAccessReview</td>
</tr>
<tr>
<td><code>selfsubjectaccessreviews</code></td>
<td></td>
<td>authorization.k8s.io</td>
<td>false</td>
<td>SelfSubjectAccessReview</td>
</tr>
<tr>
<td><code>selfsubjectrulesreviews</code></td>
<td></td>
<td>authorization.k8s.io</td>
<td>false</td>
<td>SelfSubjectRulesReview</td>
</tr>
<tr>
<td><code>subjectaccessreviews</code></td>
<td></td>
<td>authorization.k8s.io</td>
<td>false</td>
<td>SubjectAccessReview</td>
</tr>
<tr>
<td><code>horizontalpodautoscalers</code></td>
<td><code>hpa</code></td>
<td>autoscaling</td>
<td>true</td>
<td>HorizontalPodAutoscaler</td>
</tr>
<tr>
<td><code>cronjobs</code></td>
<td><code>cj</code></td>
<td>batch</td>
<td>true</td>
<td>CronJob</td>
</tr>
<tr>
<td><code>jobs</code></td>
<td></td>
<td>batch</td>
<td>true</td>
<td>Job</td>
</tr>
<tr>
<td><code>certificatesigningrequests</code></td>
<td><code>csr</code></td>
<td>certificates.k8s.io</td>
<td>false</td>
<td>CertificateSigningRequest</td>
</tr>
<tr>
<td><code>leases</code></td>
<td></td>
<td>coordination.k8s.io</td>
<td>true</td>
<td>Lease</td>
</tr>
<tr>
<td><code>endpointslices</code></td>
<td></td>
<td>discovery.k8s.io</td>
<td>true</td>
<td>EndpointSlice</td>
</tr>
<tr>
<td><code>events</code></td>
<td><code>ev</code></td>
<td>events.k8s.io</td>
<td>true</td>
<td>Event</td>
</tr>
<tr>
<td><code>ingresses</code></td>
<td><code>ing</code></td>
<td>extensions</td>
<td>true</td>
<td>Ingress</td>
</tr>
<tr>
<td><code>flowschemas</code></td>
<td></td>
<td>flowcontrol.apiserver.k8s.io</td>
<td>false</td>
<td>FlowSchema</td>
</tr>
<tr>
<td><code>prioritylevelconfigurations</code></td>
<td></td>
<td>flowcontrol.apiserver.k8s.io</td>
<td>false</td>
<td>PriorityLevelConfiguration</td>
</tr>
<tr>
<td><code>ingressclasses</code></td>
<td></td>
<td>networking.k8s.io</td>
<td>false</td>
<td>IngressClass</td>
</tr>
<tr>
<td><code>ingresses</code></td>
<td><code>ing</code></td>
<td>networking.k8s.io</td>
<td>true</td>
<td>Ingress</td>
</tr>
<tr>
<td><code>networkpolicies</code></td>
<td><code>netpol</code></td>
<td>networking.k8s.io</td>
<td>true</td>
<td>NetworkPolicy</td>
</tr>
<tr>
<td><code>runtimeclasses</code></td>
<td></td>
<td>node.k8s.io</td>
<td>false</td>
<td>RuntimeClass</td>
</tr>
<tr>
<td><code>poddisruptionbudgets</code></td>
<td><code>pdb</code></td>
<td>policy</td>
<td>true</td>
<td>PodDisruptionBudget</td>
</tr>
<tr>
<td><code>podsecuritypolicies</code></td>
<td><code>psp</code></td>
<td>policy</td>
<td>false</td>
<td>PodSecurityPolicy</td>
</tr>
<tr>
<td><code>clusterrolebindings</code></td>
<td></td>
<td>rbac.authorization.k8s.io</td>
<td>false</td>
<td>ClusterRoleBinding</td>
</tr>
<tr>
<td><code>clusterroles</code></td>
<td></td>
<td>rbac.authorization.k8s.io</td>
<td>false</td>
<td>ClusterRole</td>
</tr>
<tr>
<td><code>rolebindings</code></td>
<td></td>
<td>rbac.authorization.k8s.io</td>
<td>true</td>
<td>RoleBinding</td>
</tr>
<tr>
<td><code>roles</code></td>
<td></td>
<td>rbac.authorization.k8s.io</td>
<td>true</td>
<td>Role</td>
</tr>
<tr>
<td><code>priorityclasses</code></td>
<td><code>pc</code></td>
<td>scheduling.k8s.io</td>
<td>false</td>
<td>PriorityClass</td>
</tr>
<tr>
<td><code>csidrivers</code></td>
<td></td>
<td>storage.k8s.io</td>
<td>false</td>
<td>CSIDriver</td>
</tr>
<tr>
<td><code>csinodes</code></td>
<td></td>
<td>storage.k8s.io</td>
<td>false</td>
<td>CSINode</td>
</tr>
<tr>
<td><code>storageclasses</code></td>
<td><code>sc</code></td>
<td>storage.k8s.io</td>
<td>false</td>
<td>StorageClass</td>
</tr>
<tr>
<td><code>volumeattachments</code></td>
<td></td>
<td>storage.k8s.io</td>
<td>false</td>
<td>VolumeAttachment</td>
</tr>
</tbody>
</table>
<h2 id=输出选项>输出选项</h2>
<p>有关如何格式化或排序某些命令的输出的信息，请使用以下部分。有关哪些命令支持各种输出选项的详细信息，请参阅<a href=/zh/docs/reference/kubectl/kubectl/>kubectl</a> 参考文档。</p>
<h3 id=格式化输出>格式化输出</h3>
<p>所有 <code>kubectl</code> 命令的默认输出格式都是人类可读的纯文本格式。要以特定格式向终端窗口输出详细信息，可以将 <code>-o</code> 或 <code>--output</code> 参数添加到受支持的 <code>kubectl</code> 命令中。</p>
<h4 id=语法-1>语法</h4>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#666>[</span>command<span style=color:#666>]</span> <span style=color:#666>[</span>TYPE<span style=color:#666>]</span> <span style=color:#666>[</span>NAME<span style=color:#666>]</span> -o<span style=color:#666>=</span>&lt;output_format&gt;
</code></pre></div>
<p>根据 <code>kubectl</code> 操作，支持以下输出格式：</p>
<table>
<thead>
<tr>
<th>Output format</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>-o custom-columns=&lt;spec></code></td>
<td>使用逗号分隔的<a href=#custom-columns>自定义列</a>列表打印表。</td>
</tr>
<tr>
<td><code>-o custom-columns-file=&lt;filename></code></td>
<td>使用 <code>&lt;filename></code> 文件中的<a href=#custom-columns>自定义列</a>模板打印表。</td>
</tr>
<tr>
<td><code>-o json</code></td>
<td>输出 JSON 格式的 API 对象</td>
</tr>
<tr>
<td><code>-o jsonpath=&lt;template></code></td>
<td>打印 <a href=/zh/docs/reference/kubectl/jsonpath/>jsonpath</a> 表达式定义的字段</td>
</tr>
<tr>
<td><code>-o jsonpath-file=&lt;filename></code></td>
<td>打印 <code>&lt;filename></code> 文件中 <a href=/zh/docs/reference/kubectl/jsonpath/>jsonpath</a> 表达式定义的字段。</td>
</tr>
<tr>
<td><code>-o name</code></td>
<td>仅打印资源名称而不打印任何其他内容。</td>
</tr>
<tr>
<td><code>-o wide</code></td>
<td>以纯文本格式输出，包含任何附加信息。对于 pod 包含节点名。</td>
</tr>
<tr>
<td><code>-o yaml</code></td>
<td>输出 YAML 格式的 API 对象。</td>
</tr>
</tbody>
</table>
<h5 id=示例>示例</h5>
<p>在此示例中，以下命令将单个 pod 的详细信息输出为 YAML 格式的对象：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod web-pod-13je7 -o yaml
</code></pre></div>
<p>请记住：有关每个命令支持哪种输出格式的详细信息，请参阅 <a href=/zh/docs/reference/kubectl/kubectl/>kubectl</a> 参考文档。</p>
<h4 id=自定义列>自定义列</h4>
<p>要定义自定义列并仅将所需的详细信息输出到表中，可以使用该 custom-columns 选项。你可以选择内联定义自定义列或使用模板文件：<code>-o=custom-columns=&lt;spec></code> 或 <code>-o=custom-columns-file=&lt;filename></code>。</p>
<h5 id=示例-1>示例</h5>
<p>内联：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods &lt;pod-name&gt; -o custom-columns<span style=color:#666>=</span>NAME:.metadata.name,RSRC:.metadata.resourceVersion
</code></pre></div>
<p>模板文件：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods &lt;pod-name&gt; -o custom-columns-file<span style=color:#666>=</span>template.txt
</code></pre></div>
<p>其中，<code>template.txt</code> 文件包含：</p>
<pre><code>NAME          RSRC
metadata.name metadata.resourceVersion
</code></pre>
<p>运行任何一个命令的结果类似于:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>NAME           RSRC
submit-queue   <span style=color:#666>610995</span>
</code></pre></div>
<h4 id=server-side-列>Server-side 列</h4>
<p><code>kubectl</code> 支持从服务器接收关于对象的特定列信息。
这意味着对于任何给定的资源，服务器将返回与该资源相关的列和行，以便客户端打印。
通过让服务器封装打印的细节，这允许在针对同一集群使用的客户端之间提供一致的人类可读输出。</p>
<p>此功能默认启用。要禁用它，请将该 <code>--server-print=false</code> 参数添加到 <code>kubectl get</code> 命令中。</p>
<h5 id=例子>例子：</h5>
<p>要打印有关 pod 状态的信息，请使用如下命令：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods &lt;pod-name&gt; --server-print<span style=color:#666>=</span><span style=color:#a2f>false</span>
</code></pre></div>
<p>输出类似于：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>NAME       AGE
pod-name   1m
</code></pre></div>
<h3 id=排序列表对象>排序列表对象</h3>
<p>要将对象排序后输出到终端窗口，可以将 <code>--sort-by</code> 参数添加到支持的 <code>kubectl</code> 命令。通过使用 <code>--sort-by</code> 参数指定任何数字或字符串字段来对对象进行排序。要指定字段，请使用 <a href=/zh/docs/reference/kubectl/jsonpath/>jsonpath</a> 表达式。</p>
<h4 id=语法-2>语法</h4>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#666>[</span>command<span style=color:#666>]</span> <span style=color:#666>[</span>TYPE<span style=color:#666>]</span> <span style=color:#666>[</span>NAME<span style=color:#666>]</span> --sort-by<span style=color:#666>=</span>&lt;jsonpath_exp&gt;
</code></pre></div>
<h5 id=示例-2>示例</h5>
<p>要打印按名称排序的 pod 列表，请运行：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods --sort-by<span style=color:#666>=</span>.metadata.name
</code></pre></div>
<h2 id=示例-常用操作>示例：常用操作</h2>
<p>使用以下示例集来帮助你熟悉运行常用 kubectl 操作：</p>
<p><code>kubectl apply</code> - 以文件或标准输入为准应用或更新资源。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># 使用 example-service.yaml 中的定义创建服务。</span>
kubectl apply -f example-service.yaml

<span style=color:#080;font-style:italic># 使用 example-controller.yaml 中的定义创建 replication controller。</span>
kubectl apply -f example-controller.yaml

<span style=color:#080;font-style:italic># 使用 &lt;directory&gt; 路径下的任意 .yaml, .yml, 或 .json 文件 创建对象。</span>
kubectl apply -f &lt;directory&gt;
</code></pre></div>
<p><code>kubectl get</code> - 列出一个或多个资源。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># 以纯文本输出格式列出所有 pod。</span>
kubectl get pods

<span style=color:#080;font-style:italic># 以纯文本输出格式列出所有 pod，并包含附加信息(如节点名)。</span>
kubectl get pods -o wide

<span style=color:#080;font-style:italic># 以纯文本输出格式列出具有指定名称的副本控制器。提示：你可以使用别名 &#39;rc&#39; 缩短和替换 &#39;replicationcontroller&#39; 资源类型。</span>
kubectl get replicationcontroller &lt;rc-name&gt;

<span style=color:#080;font-style:italic># 以纯文本输出格式列出所有副本控制器和服务。</span>
kubectl get rc,services

<span style=color:#080;font-style:italic># 以纯文本输出格式列出所有守护程序集，包括未初始化的守护程序集。</span>
kubectl get ds --include-uninitialized

<span style=color:#080;font-style:italic># 列出在节点 server01 上运行的所有 pod</span>
kubectl get pods --field-selector<span style=color:#666>=</span>spec.nodeName<span style=color:#666>=</span>server01
</code></pre></div>
<p><code>kubectl describe</code> - 显示一个或多个资源的详细状态，默认情况下包括未初始化的资源。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># 显示名称为 &lt;node-name&gt; 的节点的详细信息。</span>
kubectl describe nodes &lt;node-name&gt;

<span style=color:#080;font-style:italic># 显示名为 &lt;pod-name&gt; 的 pod 的详细信息。</span>
kubectl describe pods/&lt;pod-name&gt;

<span style=color:#080;font-style:italic># 显示由名为 &lt;rc-name&gt; 的副本控制器管理的所有 pod 的详细信息。</span>
<span style=color:#080;font-style:italic># 记住：副本控制器创建的任何 pod 都以复制控制器的名称为前缀。</span>
kubectl describe pods &lt;rc-name&gt;

<span style=color:#080;font-style:italic># 描述所有的 pod，不包括未初始化的 pod</span>
kubectl describe pods
</code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>Note:</strong>
<p><code>kubectl get</code> 命令通常用于检索同一资源类型的一个或多个资源。
它具有丰富的参数，允许你使用 <code>-o</code> 或 <code>--output</code> 参数自定义输出格式。你可以指定 <code>-w</code> 或 <code>--watch</code> 参数以开始观察特定对象的更新。
<code>kubectl describe</code> 命令更侧重于描述指定资源的许多相关方面。它可以调用对 <code>API 服务器</code> 的多个 API 调用来为用户构建视图。
例如，该 <code>kubectl describe node</code> 命令不仅检索有关节点的信息，还检索在其上运行的 pod 的摘要，为节点生成的事件等。
</div>
<p><code>kubectl delete</code> - 从文件、stdin 或指定标签选择器、名称、资源选择器或资源中删除资源。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># 使用 pod.yaml 文件中指定的类型和名称删除 pod。</span>
kubectl delete -f pod.yaml

<span style=color:#080;font-style:italic># 删除所有带有 &#39;&lt;label-key&gt;=&lt;label-value&gt;&#39; 标签的 Pod 和服务。</span>
kubectl delete pods,services -l &lt;label-key&gt;<span style=color:#666>=</span>&lt;label-value&gt;

<span style=color:#080;font-style:italic># 删除所有 pod，包括未初始化的 pod。</span>
kubectl delete pods --all
</code></pre></div>
<p><code>kubectl exec</code> - 对 pod 中的容器执行命令。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># 从 pod &lt;pod-name&gt; 中获取运行 &#39;date&#39; 的输出。默认情况下，输出来自第一个容器。</span>
kubectl <span style=color:#a2f>exec</span> &lt;pod-name&gt; -- date

<span style=color:#080;font-style:italic># 运行输出 &#39;date&#39; 获取在容器的 &lt;container-name&gt; 中 pod &lt;pod-name&gt; 的输出。</span>
kubectl <span style=color:#a2f>exec</span> &lt;pod-name&gt; -c &lt;container-name&gt; -- date

<span style=color:#080;font-style:italic># 获取一个交互 TTY 并运行 /bin/bash &lt;pod-name &gt;。默认情况下，输出来自第一个容器。</span>
kubectl <span style=color:#a2f>exec</span> -ti &lt;pod-name&gt; -- /bin/bash
</code></pre></div>
<p><code>kubectl logs</code> - 打印 Pod 中容器的日志。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># 从 pod 返回日志快照。</span>
kubectl logs &lt;pod-name&gt;

<span style=color:#080;font-style:italic># 从 pod &lt;pod-name&gt; 开始流式传输日志。这类似于 &#39;tail -f&#39; Linux 命令。</span>
kubectl logs -f &lt;pod-name&gt;
</code></pre></div>
<h2 id=示例-创建和使用插件>示例：创建和使用插件</h2>
<p>使用以下示例来帮助你熟悉编写和使用 <code>kubectl</code> 插件：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># 用任何语言创建一个简单的插件，并为生成的可执行文件命名</span>
<span style=color:#080;font-style:italic># 以前缀 &#34;kubectl-&#34; 开始</span>
cat ./kubectl-hello
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080>#!/bin/sh
</span><span style=color:#080></span>
<span style=color:#080;font-style:italic># 这个插件打印单词 &#34;hello world&#34;</span>
<span style=color:#a2f>echo</span> <span style=color:#b44>&#34;hello world&#34;</span>
</code></pre></div><p>这个插件写好了，把它变成可执行的：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>sudo chmod a+x ./kubectl-hello

<span style=color:#080;font-style:italic># 并将其移动到路径中的某个位置</span>
sudo mv ./kubectl-hello /usr/local/bin
sudo chown root:root /usr/local/bin

<span style=color:#080;font-style:italic># 你现在已经创建并&#34;安装了&#34;一个 kubectl 插件。</span>
<span style=color:#080;font-style:italic># 你可以开始使用这个插件，从 kubectl 调用它，就像它是一个常规命令一样</span>
kubectl hello
</code></pre></div><pre><code>hello world
</code></pre>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># 你可以&#34;卸载&#34;一个插件，只需从你的路径中删除它</span>
sudo rm /usr/local/bin/kubectl-hello
</code></pre></div>
<p>为了查看可用的所有 <code>kubectl</code> 插件，你可以使用 <code>kubectl plugin list</code> 子命令：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl plugin list
</code></pre></div>
<p>输出类似于：</p>
<pre><code>The following kubectl-compatible plugins are available:

/usr/local/bin/kubectl-hello
/usr/local/bin/kubectl-foo
/usr/local/bin/kubectl-bar
</code></pre>
<p><code>kubectl plugin list</code>指令也可以向你告警哪些插件被运行，或是被其它插件覆盖了,例如:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>sudo chmod -x /usr/local/bin/kubectl-foo <span style=color:#080;font-style:italic># 删除执行权限</span>
kubectl plugin list
</code></pre></div>
<pre><code>The following kubectl-compatible plugins are available:

/usr/local/bin/kubectl-hello
/usr/local/bin/kubectl-foo
  - warning: /usr/local/bin/kubectl-foo identified as a plugin, but it is not executable
/usr/local/bin/kubectl-bar

error: one plugin warning was found
</code></pre>
<p>你可以将插件视为在现有 kubectl 命令之上构建更复杂功能的一种方法：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>cat ./kubectl-whoami
</code></pre></div>
<p>接下来的几个示例假设你已经将 <code>kubectl-whoami</code> 设置为以下内容:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080>#!/bin/bash
</span><span style=color:#080></span>
<span style=color:#080;font-style:italic>#这个插件利用 `kubectl config` 命令基于当前所选上下文输出当前用户的信息</span>
kubectl config view --template<span style=color:#666>=</span><span style=color:#b44>&#39;{{ range .contexts }}{{ if eq .name &#34;&#39;</span><span style=color:#a2f;font-weight:700>$(</span>kubectl config current-context<span style=color:#a2f;font-weight:700>)</span><span style=color:#b44>&#39;&#34; }}Current user: {{ printf &#34;%s\n&#34; .context.user }}{{ end }}{{ end }}&#39;</span>
</code></pre></div>
<p>运行以上命令将为你提供一个输出，其中包含 KUBECONFIG 文件中当前上下文的用户:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080>#!/bin/bash
</span><span style=color:#080></span><span style=color:#080;font-style:italic># 使文件成为可执行的</span>
sudo chmod +x ./kubectl-whoami

<span style=color:#080;font-style:italic># 然后移动到你的路径中</span>
sudo mv ./kubectl-whoami /usr/local/bin

kubectl whoami
Current user: plugins-user
</code></pre></div>
<p>要了解关于插件的更多信息，请查看<a href=https://github.com/kubernetes/sample-cli-plugin>示例 cli 插件</a>。</p>
<h2 id=what-s-next>What's next</h2>
<ul>
<li>
<p>开始使用 <a href=/docs/reference/generated/kubectl/kubectl-commands/>kubectl</a> 命令。</p>
</li>
<li>
<p>查看更多<a href=https://github.com/kubernetes/sample-cli-plugin>示例 cli 插件</a>。</p>
</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-4d3e62632c189fcc3c1357cd8fb8799c>3 - kubectl</h1>
<h2 id=synopsis>Synopsis</h2>
<p>kubectl 管理控制 Kubernetes 集群。</p>
<p>获取更多信息，请访问 <a href=/zh/docs/reference/kubectl/overview/>kubectl 概述</a>。</p>
<pre><code>kubectl [flags]
</code></pre><h2 id=options>Options</h2>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--add-dir-header</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
设置为 true 表示添加文件目录到日志信息头中
</td>
</tr>
<tr>
<td colspan=2>--alsologtostderr</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
表示将日志输出到文件的同时输出到 stderr
</td>
</tr>
<tr>
<td colspan=2>--as string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
以指定用户的身份执行操作
</td>
</tr>
<tr>
<td colspan=2>--as-group stringArray</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
模拟指定的组来执行操作，可以使用这个标志来指定多个组。
</td>
</tr>
<tr>
<td colspan=2>--azure-container-registry-config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
包含 Azure 容器仓库配置信息的文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--cache-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值: "$HOME/.kube/cache"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
默认缓存目录
</td>
</tr>
<tr>
<td colspan=2>--certificate-authority string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指向证书机构的 cert 文件路径
</td>
</tr>
<tr>
<td colspan=2>--client-certificate string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
TLS 使用的客户端证书路径
</td>
</tr>
<tr>
<td colspan=2>--client-key string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
TLS 使用的客户端密钥文件路径
</td>
</tr>
<tr>
<td colspan=2>--cloud-provider-gce-l7lb-src-cidrs cidrs&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值: 130.211.0.0/22,35.191.0.0/16</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
在 GCE 防火墙中开放的 CIDR，用来进行 L7 LB 流量代理和健康检查。
</td>
</tr>
<tr>
<td colspan=2>--cloud-provider-gce-lb-src-cidrs cidrs&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值: 130.211.0.0/22,209.85.152.0/22,209.85.204.0/22,35.191.0.0/16</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
在 GCE 防火墙中开放的 CIDR，用来进行 L4 LB 流量代理和健康检查。
</td>
</tr>
<tr>
<td colspan=2>--cluster string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
要使用的 kubeconfig 集群的名称
</td>
</tr>
<tr>
<td colspan=2>--context string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
要使用的 kubeconfig 上下文的名称
</td>
</tr>
<tr>
<td colspan=2>--default-not-ready-toleration-seconds int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值: 300</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
表示 `notReady` 状态的容忍度秒数：默认情况下，`NoExecute` 被添加到尚未具有此容忍度的每个 Pod 中。
</td>
</tr>
<tr>
<td colspan=2>--default-unreachable-toleration-seconds int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值: 300</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
表示 `unreachable` 状态的容忍度秒数：默认情况下，`NoExecute` 被添加到尚未具有此容忍度的每个 Pod 中。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubectl 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>--insecure-skip-tls-verify</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
设置为 true，则表示不会检查服务器证书的有效性。这样会导致您的 HTTPS 连接不安全。
</td>
</tr>
<tr>
<td colspan=2>--kubeconfig string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
CLI 请求使用的 kubeconfig 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--log-backtrace-at traceLocation&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值: 0</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
当日志机制运行到指定文件的指定行（file:N）时，打印调用堆栈信息
</td>
</tr>
<tr>
<td colspan=2>--log-dir string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果不为空，则将日志文件写入此目录
</td>
</tr>
<tr>
<td colspan=2>--log-file string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果不为空，则将使用此日志文件
</td>
</tr>
<tr>
<td colspan=2>--log-file-max-size uint&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值: 1800</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
定义日志文件的最大尺寸。单位为兆字节。如果值设置为 0，则表示日志文件大小不受限制。
</td>
</tr>
<tr>
<td colspan=2>--log-flush-frequency duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值: 5s</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
两次日志刷新操作之间的最长时间（秒）
</td>
</tr>
<tr>
<td colspan=2>--logtostderr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值: true</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
日志输出到 stderr 而不是文件中
</td>
</tr>
<tr>
<td colspan=2>--match-server-version</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
要求客户端版本和服务端版本相匹配
</td>
</tr>
<tr>
<td colspan=2>-n, --namespace string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果存在，CLI 请求将使用此命名空间
</td>
<tr>
<td colspan=2>--one-output</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果为 true，则只将日志写入初始严重级别（而不是同时写入所有较低的严重级别）。
</td>
</tr>
</tr>
<tr>
<td colspan=2>--password string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
API 服务器进行基本身份验证的密码
</td>
</tr>
<tr>
<td colspan=2>--profile string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值: "none"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
要记录的性能指标的名称。可取 (none|cpu|heap|goroutine|threadcreate|block|mutex) 其中之一。
</td>
</tr>
<tr>
<td colspan=2>--profile-output string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值: "profile.pprof"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
用于转储所记录的性能信息的文件名
</td>
</tr>
<tr>
<td colspan=2>--request-timeout string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值: "0"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
放弃单个服务器请求之前的等待时间，非零值需要包含相应时间单位（例如：1s、2m、3h）。零值则表示不做超时要求。
</td>
</tr>
<tr>
<td colspan=2>-s, --server string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
Kubernetes API 服务器的地址和端口
</td>
</tr>
<tr>
<td colspan=2>--skip-headers</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
设置为 true 则表示跳过在日志消息中出现 header 前缀信息
</td>
</tr>
<tr>
<td colspan=2>--skip-log-headers</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
设置为 true 则表示在打开日志文件时跳过 header 信息
</td>
</tr>
<tr>
<td colspan=2>--stderrthreshold severity&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值: 2</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
等于或高于此阈值的日志将输出到标准错误输出（stderr）
</td>
</tr>
<tr>
<td colspan=2>--token string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
用于对 API 服务器进行身份认证的持有者令牌
</td>
</tr>
<tr>
<td colspan=2>--user string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指定使用 kubeconfig 配置文件中的用户名
</td>
</tr>
<tr>
<td colspan=2>--username string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
用于 API 服务器的基本身份验证的用户名
</td>
</tr>
<tr>
<td colspan=2>-v, --v Level</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指定输出日志的日志详细级别
</td>
</tr>
<tr>
<td colspan=2>--version version[=true]</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
打印 kubectl 版本信息并退出
</td>
</tr>
<tr>
<td colspan=2>--vmodule moduleSpec</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
以逗号分隔的 pattern=N 设置列表，用于过滤文件的日志记录
</td>
</tr>
</tbody>
</table>
<h2 id=environment-variables>Environment variables</h2>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>KUBECONFIG</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubectl 的配置 ("kubeconfig") 文件的路径。默认值: "$HOME/.kube/config"
</td>
</tr>
<tr>
<td colspan=2>KUBECTL_COMMAND_HEADERS</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
设置为 false 时，关闭用于详细说明被调用的 kubectl 命令的额外 HTTP 标头 (Kubernetes 版本为 v1.22 或者更高)
</td>
</tr>
</tbody>
</table>
<h2 id=see-also>See Also</h2>
<ul>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands#annotate>kubectl annotate</a> - 更新资源所关联的注解</li>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands#api-resources>kubectl api-resources</a> - 打印服务器上所支持的 API 资源</li>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands#api-versions>kubectl api-versions</a> - 以“组/版本”的格式输出服务端所支持的 API 版本</li>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands#apply>kubectl apply</a> - 基于文件名或标准输入，将新的配置应用到资源上</li>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands#attach>kubectl attach</a> - 连接到一个正在运行的容器</li>
</ul>
<ul>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands#auth>kubectl auth</a> - 检查授权信息</li>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands#autoscale>kubectl autoscale</a> - 对一个资源对象（Deployment、ReplicaSet 或 ReplicationController ）进行扩缩</li>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands#certificate>kubectl certificate</a> - 修改证书资源</li>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands#cluster-info>kubectl cluster-info</a> - 显示集群信息</li>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands#completion>kubectl completion</a> - 根据已经给出的 Shell（bash 或 zsh），输出 Shell 补全后的代码</li>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands#config>kubectl config</a> - 修改 kubeconfig 配置文件</li>
</ul>
<ul>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands#convert>kubectl convert</a> - 在不同的 API 版本之间转换配置文件</li>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands#cordon>kubectl cordon</a> - 标记节点为不可调度的</li>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands#cp>kubectl cp</a> - 将文件和目录拷入/拷出容器</li>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands#create>kubectl create</a> - 通过文件或标准输入来创建资源</li>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands#debug>kubectl debug</a> - 创建用于排查工作负载和节点故障的调试会话</li>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands#delete>kubectl delete</a> - 通过文件名、标准输入、资源和名字删除资源，或者通过资源和标签选择器来删除资源</li>
</ul>
<ul>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands#describe>kubectl describe</a> - 显示某个资源或某组资源的详细信息</li>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands#diff>kubectl diff</a> - 显示目前版本与将要应用的版本之间的差异</li>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands#drain>kubectl drain</a> - 腾空节点，准备维护</li>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands#edit>kubectl edit</a> - 修改服务器上的某资源</li>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands#exec>kubectl exec</a> - 在容器中执行相关命令</li>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands#explain>kubectl explain</a> - 显示资源文档说明</li>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands#expose>kubectl expose</a> - 给定副本控制器、服务、Deployment 或 Pod，将其暴露为新的 kubernetes Service</li>
</ul>
<ul>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands#get>kubectl get</a> - 显示一个或者多个资源信息</li>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands#kustomize>kubectl kustomize</a> - 从目录或远程 URL 中构建 kustomization</li>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands#label>kubectl label</a> - 更新资源的标签</li>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands#logs>kubectl logs</a> - 输出 pod 中某容器的日志</li>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands#options>kubectl options</a> - 打印所有命令都支持的共有参数列表</li>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands#patch>kubectl patch</a> - 基于策略性合并修补（Stategic Merge Patch）规则更新某资源中的字段</li>
</ul>
<ul>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands#plugin>kubectl plugin</a> - 运行命令行插件</li>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands#port-forward>kubectl port-forward</a> - 将一个或者多个本地端口转发到 pod</li>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands#proxy>kubectl proxy</a> - 运行一个 kubernetes API 服务器代理</li>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands#replace>kubectl replace</a> - 基于文件名或标准输入替换资源</li>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands#rollout>kubectl rollout</a> - 管理资源的上线</li>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands#run>kubectl run</a> - 在集群中使用指定镜像启动容器</li>
</ul>
<ul>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands#scale>kubectl scale</a> - 为一个 Deployment、ReplicaSet 或 ReplicationController 设置一个新的规模尺寸值</li>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands#set>kubectl set</a> - 为对象设置功能特性</li>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands#taint>kubectl taint</a> - 在一个或者多个节点上更新污点配置</li>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands#top>kubectl top</a> - 显示资源（CPU /内存/存储）使用率</li>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands#uncordon>kubectl uncordon</a> - 标记节点为可调度的</li>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands#version>kubectl version</a> - 打印客户端和服务器的版本信息</li>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands#wait>kubectl wait</a> - 实验性：等待一个或多个资源达到某种状态</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-a938176c695852fe70362c29cf615f1c>4 - JSONPath 支持</h1>
<p>Kubectl 支持 JSONPath 模板。</p>
<p>JSONPath 模板由 {} 包起来的 JSONPath 表达式组成。Kubectl 使用 JSONPath 表达式来过滤 JSON 对象中的特定字段并格式化输出。除了原始的 JSONPath 模板语法，以下函数和语法也是有效的:</p>
<ol>
<li>使用双引号将 JSONPath 表达式内的文本引起来。</li>
<li>使用 <code>range</code>，<code>end</code> 运算符来迭代列表。</li>
<li>使用负片索引后退列表。负索引不会“环绕”列表，并且只要 <code>-index + listLength> = 0</code> 就有效。</li>
</ol>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong>
<ul>
<li>
<p><code>$</code> 运算符是可选的，因为默认情况下表达式总是从根对象开始。</p>
</li>
<li>
<p>结果对象将作为其 String() 函数输出。</p>
</li>
</ul>
</div>
<p>给定 JSON 输入:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;List&#34;</span>,
  <span style=color:green;font-weight:700>&#34;items&#34;</span>:[
    {
      <span style=color:green;font-weight:700>&#34;kind&#34;</span>:<span style=color:#b44>&#34;None&#34;</span>,
      <span style=color:green;font-weight:700>&#34;metadata&#34;</span>:{<span style=color:green;font-weight:700>&#34;name&#34;</span>:<span style=color:#b44>&#34;127.0.0.1&#34;</span>},
      <span style=color:green;font-weight:700>&#34;status&#34;</span>:{
        <span style=color:green;font-weight:700>&#34;capacity&#34;</span>:{<span style=color:green;font-weight:700>&#34;cpu&#34;</span>:<span style=color:#b44>&#34;4&#34;</span>},
        <span style=color:green;font-weight:700>&#34;addresses&#34;</span>:[{<span style=color:green;font-weight:700>&#34;type&#34;</span>: <span style=color:#b44>&#34;LegacyHostIP&#34;</span>, <span style=color:green;font-weight:700>&#34;address&#34;</span>:<span style=color:#b44>&#34;127.0.0.1&#34;</span>}]
      }
    },
    {
      <span style=color:green;font-weight:700>&#34;kind&#34;</span>:<span style=color:#b44>&#34;None&#34;</span>,
      <span style=color:green;font-weight:700>&#34;metadata&#34;</span>:{<span style=color:green;font-weight:700>&#34;name&#34;</span>:<span style=color:#b44>&#34;127.0.0.2&#34;</span>},
      <span style=color:green;font-weight:700>&#34;status&#34;</span>:{
        <span style=color:green;font-weight:700>&#34;capacity&#34;</span>:{<span style=color:green;font-weight:700>&#34;cpu&#34;</span>:<span style=color:#b44>&#34;8&#34;</span>},
        <span style=color:green;font-weight:700>&#34;addresses&#34;</span>:[
          {<span style=color:green;font-weight:700>&#34;type&#34;</span>: <span style=color:#b44>&#34;LegacyHostIP&#34;</span>, <span style=color:green;font-weight:700>&#34;address&#34;</span>:<span style=color:#b44>&#34;127.0.0.2&#34;</span>},
          {<span style=color:green;font-weight:700>&#34;type&#34;</span>: <span style=color:#b44>&#34;another&#34;</span>, <span style=color:green;font-weight:700>&#34;address&#34;</span>:<span style=color:#b44>&#34;127.0.0.3&#34;</span>}
        ]
      }
    }
  ],
  <span style=color:green;font-weight:700>&#34;users&#34;</span>:[
    {
      <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;myself&#34;</span>,
      <span style=color:green;font-weight:700>&#34;user&#34;</span>: {}
    },
    {
      <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;e2e&#34;</span>,
      <span style=color:green;font-weight:700>&#34;user&#34;</span>: {<span style=color:green;font-weight:700>&#34;username&#34;</span>: <span style=color:#b44>&#34;admin&#34;</span>, <span style=color:green;font-weight:700>&#34;password&#34;</span>: <span style=color:#b44>&#34;secret&#34;</span>}
    }
  ]
}
</code></pre></div>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
<th>示例</th>
<th>结果</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>text</code></td>
<td>纯文本</td>
<td><code>kind is {.kind}</code></td>
<td><code>kind is List</code></td>
</tr>
<tr>
<td><code>@</code></td>
<td>当前对象</td>
<td><code>{@}</code></td>
<td>与输入相同</td>
</tr>
<tr>
<td><code>.</code> or <code>[]</code></td>
<td>子运算符</td>
<td><code>{.kind}</code>, <code>{['kind']}</code> or <code>{['name\.type']}</code></td>
<td><code>List</code></td>
</tr>
<tr>
<td><code>..</code></td>
<td>递归下降</td>
<td><code>{..name}</code></td>
<td><code>127.0.0.1 127.0.0.2 myself e2e</code></td>
</tr>
<tr>
<td><code>*</code></td>
<td>通配符。获取所有对象</td>
<td><code>{.items[*].metadata.name}</code></td>
<td><code>[127.0.0.1 127.0.0.2]</code></td>
</tr>
<tr>
<td><code>[start:end :step]</code></td>
<td>下标运算符</td>
<td><code>{.users[0].name}</code></td>
<td><code>myself</code></td>
</tr>
<tr>
<td><code>[,]</code></td>
<td>并集运算符</td>
<td><code>{.items[*]['metadata.name', 'status.capacity']}</code></td>
<td><code>127.0.0.1 127.0.0.2 map[cpu:4] map[cpu:8]</code></td>
</tr>
<tr>
<td><code>?()</code></td>
<td>过滤</td>
<td><code>{.users[?(@.name=="e2e")].user.password}</code></td>
<td><code>secret</code></td>
</tr>
<tr>
<td><code>range</code>, <code>end</code></td>
<td>迭代列表</td>
<td><code>{range .items[*]}[{.metadata.name}, {.status.capacity}] {end}</code></td>
<td><code>[127.0.0.1, map[cpu:4]] [127.0.0.2, map[cpu:8]]</code></td>
</tr>
<tr>
<td><code>''</code></td>
<td>引用解释执行字符串</td>
<td><code>{range .items[*]}{.metadata.name}{'\t'}{end}</code></td>
<td><code>127.0.0.1 127.0.0.2</code></td>
</tr>
</tbody>
</table>
<p>使用 <code>kubectl</code> 和 JSONPath 表达式的示例:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods -o json
kubectl get pods -o<span style=color:#666>=</span><span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{@}&#39;</span>
kubectl get pods -o<span style=color:#666>=</span><span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.items[0]}&#39;</span>
kubectl get pods -o<span style=color:#666>=</span><span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.items[0].metadata.name}&#39;</span>
kubectl get pods -o<span style=color:#666>=</span><span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#34;{.items[*][&#39;metadata.name&#39;, &#39;status.capacity&#39;]}&#34;</span>
kubectl get pods -o<span style=color:#666>=</span><span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{range .items[*]}{.metadata.name}{&#34;\t&#34;}{.status.startTime}{&#34;\n&#34;}{end}&#39;</span>
</code></pre></div>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> <p>在 Windows 上，对于任何包含空格的 JSONPath 模板，您必须使用双引号（不是上面 bash 所示的单引号）。
反过来，这意味着您必须在模板中的所有文字周围使用单引号或转义的双引号。
例如:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cmd data-lang=cmd>C:<span style=color:#a0a000>\</span><span style=color:#080;font-style:italic>&gt; kubectl get pods -o=jsonpath=&#34;{range .items[*]}{.metadata.name}{&#39;\t&#39;}{.status.startTime}{&#39;\n&#39;}{end}&#34;</span>
C:<span style=color:#a0a000>\</span><span style=color:#080;font-style:italic>&gt; kubectl get pods -o=jsonpath=&#34;{range .items[*]}{.metadata.name}{\&#34;\t\&#34;}{.status.startTime}{\&#34;\n\&#34;}{end}&#34;</span>
</code></pre></div>
</div>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> <p>不支持 JSONPath 正则表达式。如需使用正则表达式进行匹配操作，您可以使用如 <code>jq</code> 之类的工具。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># kubectl 的 JSONpath 输出不支持正则表达式</span>
<span style=color:#080;font-style:italic># 下面的命令不会生效</span>
kubectl get pods -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.items[?(@.metadata.name=~/^test$/)].metadata.name}&#39;</span>

<span style=color:#080;font-style:italic># 下面的命令可以获得所需的结果</span>
kubectl get pods -o json | jq -r <span style=color:#b44>&#39;.items[] | select(.metadata.name | test(&#34;test-&#34;)).spec.containers[].image&#39;</span>
</code></pre></div>
</div>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-8aba901ac13f124e5782b90ddb166ee2>5 - kubectl 备忘单</h1>
<p>本页列举了常用的 “kubectl” 命令和标志</p>
<h2 id=kubectl-自动补全>Kubectl 自动补全</h2>
<h3 id=bash>BASH</h3>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#a2f>source</span> &lt;<span style=color:#666>(</span>kubectl completion bash<span style=color:#666>)</span> <span style=color:#080;font-style:italic># 在 bash 中设置当前 shell 的自动补全，要先安装 bash-completion 包。</span>
<span style=color:#a2f>echo</span> <span style=color:#b44>&#34;source &lt;(kubectl completion bash)&#34;</span> &gt;&gt; ~/.bashrc <span style=color:#080;font-style:italic># 在您的 bash shell 中永久的添加自动补全</span>
</code></pre></div><p>您还可以为 <code>kubectl</code> 使用一个速记别名，该别名也可以与 completion 一起使用：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#a2f>alias</span> <span style=color:#b8860b>k</span><span style=color:#666>=</span>kubectl
<span style=color:#a2f>complete</span> -F __start_kubectl k
</code></pre></div><h3 id=zsh>ZSH</h3>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#a2f>source</span> &lt;<span style=color:#666>(</span>kubectl completion zsh<span style=color:#666>)</span>  <span style=color:#080;font-style:italic># 在 zsh 中设置当前 shell 的自动补全</span>
<span style=color:#a2f>echo</span> <span style=color:#b44>&#34;[[ </span><span style=color:#b8860b>$commands</span><span style=color:#b44>[kubectl] ]] &amp;&amp; source &lt;(kubectl completion zsh)&#34;</span> &gt;&gt; ~/.zshrc <span style=color:#080;font-style:italic># 在您的 zsh shell 中永久的添加自动补全</span>
</code></pre></div>
<h2 id=kubectl-上下文和配置>Kubectl 上下文和配置</h2>
<p>设置 <code>kubectl</code> 与哪个 Kubernetes 集群进行通信并修改配置信息。
查看<a href=/zh/docs/tasks/access-application-cluster/configure-access-multiple-clusters/>使用 kubeconfig 跨集群授权访问</a>
文档获取配置文件详细信息。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl config view <span style=color:#080;font-style:italic># 显示合并的 kubeconfig 配置。</span>

<span style=color:#080;font-style:italic># 同时使用多个 kubeconfig 文件并查看合并的配置</span>
<span style=color:#b8860b>KUBECONFIG</span><span style=color:#666>=</span>~/.kube/config:~/.kube/kubconfig2 kubectl config view

<span style=color:#080;font-style:italic># 获取 e2e 用户的密码</span>
kubectl config view -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.users[?(@.name == &#34;e2e&#34;)].user.password}&#39;</span>

kubectl config view -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.users[].name}&#39;</span>    <span style=color:#080;font-style:italic># 显示第一个用户</span>
kubectl config view -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.users[*].name}&#39;</span>   <span style=color:#080;font-style:italic># 获取用户列表</span>
kubectl config get-contexts                          <span style=color:#080;font-style:italic># 显示上下文列表</span>
kubectl config current-context                       <span style=color:#080;font-style:italic># 展示当前所处的上下文</span>
kubectl config use-context my-cluster-name           <span style=color:#080;font-style:italic># 设置默认的上下文为 my-cluster-name</span>

<span style=color:#080;font-style:italic># 添加新的用户配置到 kubeconf 中，使用 basic auth 进行身份认证</span>
kubectl config set-credentials kubeuser/foo.kubernetes.com --username<span style=color:#666>=</span>kubeuser --password<span style=color:#666>=</span>kubepassword

<span style=color:#080;font-style:italic># 在指定上下文中持久性地保存名字空间，供所有后续 kubectl 命令使用</span>
kubectl config set-context --current --namespace<span style=color:#666>=</span>ggckad-s2

<span style=color:#080;font-style:italic># 使用特定的用户名和名字空间设置上下文</span>
kubectl config set-context gce --user<span style=color:#666>=</span>cluster-admin --namespace<span style=color:#666>=</span>foo <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  <span style=color:#666>&amp;&amp;</span> kubectl config use-context gce

kubectl config <span style=color:#a2f>unset</span> users.foo                       <span style=color:#080;font-style:italic># 删除用户 foo</span>
</code></pre></div>
<h2 id=kubectl-apply>Kubectl apply</h2>
<p><code>apply</code> 通过定义 Kubernetes 资源的文件来管理应用。
它通过运行 <code>kubectl apply</code> 在集群中创建和更新资源。
这是在生产中管理 Kubernetes 应用的推荐方法。
参见 <a href=https://kubectl.docs.kubernetes.io>Kubectl 文档</a>。</p>
<h2 id=creating-objects>创建对象</h2>
<p>Kubernetes 配置可以用 YAML 或 JSON 定义。可以使用的文件扩展名有
<code>.yaml</code>、<code>.yml</code> 和 <code>.json</code>。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl apply -f ./my-manifest.yaml           <span style=color:#080;font-style:italic># 创建资源</span>
kubectl apply -f ./my1.yaml -f ./my2.yaml     <span style=color:#080;font-style:italic># 使用多个文件创建</span>
kubectl apply -f ./dir                        <span style=color:#080;font-style:italic># 基于目录下的所有清单文件创建资源</span>
kubectl apply -f https://git.io/vPieo         <span style=color:#080;font-style:italic># 从 URL 中创建资源</span>
kubectl create deployment nginx --image<span style=color:#666>=</span>nginx <span style=color:#080;font-style:italic># 启动单实例 nginx</span>

<span style=color:#080;font-style:italic># 创建一个打印 “Hello World” 的 Job</span>
kubectl create job hello --image<span style=color:#666>=</span>busybox -- <span style=color:#a2f>echo</span> <span style=color:#b44>&#34;Hello World&#34;</span> 

<span style=color:#080;font-style:italic># 创建一个打印 “Hello World” 间隔1分钟的 CronJob</span>
kubectl create cronjob hello --image<span style=color:#666>=</span>busybox   --schedule<span style=color:#666>=</span><span style=color:#b44>&#34;*/1 * * * *&#34;</span> -- <span style=color:#a2f>echo</span> <span style=color:#b44>&#34;Hello World&#34;</span>    

kubectl explain pods                          <span style=color:#080;font-style:italic># 获取 pod 清单的文档说明</span>

<span style=color:#080;font-style:italic># 从标准输入创建多个 YAML 对象</span>
cat <span style=color:#b44>&lt;&lt;EOF | kubectl apply -f -
</span><span style=color:#b44>apiVersion: v1
</span><span style=color:#b44>kind: Pod
</span><span style=color:#b44>metadata:
</span><span style=color:#b44>  name: busybox-sleep
</span><span style=color:#b44>spec:
</span><span style=color:#b44>  containers:
</span><span style=color:#b44>  - name: busybox
</span><span style=color:#b44>    image: busybox
</span><span style=color:#b44>    args:
</span><span style=color:#b44>    - sleep
</span><span style=color:#b44>    - &#34;1000000&#34;
</span><span style=color:#b44>---
</span><span style=color:#b44>apiVersion: v1
</span><span style=color:#b44>kind: Pod
</span><span style=color:#b44>metadata:
</span><span style=color:#b44>  name: busybox-sleep-less
</span><span style=color:#b44>spec:
</span><span style=color:#b44>  containers:
</span><span style=color:#b44>  - name: busybox
</span><span style=color:#b44>    image: busybox
</span><span style=color:#b44>    args:
</span><span style=color:#b44>    - sleep
</span><span style=color:#b44>    - &#34;1000&#34;
</span><span style=color:#b44>EOF</span>

<span style=color:#080;font-style:italic># 创建有多个 key 的 Secret</span>
cat <span style=color:#b44>&lt;&lt;EOF | kubectl apply -f -
</span><span style=color:#b44>apiVersion: v1
</span><span style=color:#b44>kind: Secret
</span><span style=color:#b44>metadata:
</span><span style=color:#b44>  name: mysecret
</span><span style=color:#b44>type: Opaque
</span><span style=color:#b44>data:
</span><span style=color:#b44>  password: $(echo -n &#34;s33msi4&#34; | base64 -w0)
</span><span style=color:#b44>  username: $(echo -n &#34;jane&#34; | base64 -w0)
</span><span style=color:#b44>EOF</span>
</code></pre></div>
<h2 id=查看和查找资源>查看和查找资源</h2>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#080;font-style:italic># get 命令的基本输出</span>
kubectl get services                          <span style=color:#080;font-style:italic># 列出当前命名空间下的所有 services</span>
kubectl get pods --all-namespaces             <span style=color:#080;font-style:italic># 列出所有命名空间下的全部的 Pods</span>
kubectl get pods -o wide                      <span style=color:#080;font-style:italic># 列出当前命名空间下的全部 Pods，并显示更详细的信息</span>
kubectl get deployment my-dep                 <span style=color:#080;font-style:italic># 列出某个特定的 Deployment</span>
kubectl get pods                              <span style=color:#080;font-style:italic># 列出当前命名空间下的全部 Pods</span>
kubectl get pod my-pod -o yaml                <span style=color:#080;font-style:italic># 获取一个 pod 的 YAML</span>

<span style=color:#080;font-style:italic># describe 命令的详细输出</span>
kubectl describe nodes my-node
kubectl describe pods my-pod

<span style=color:#080;font-style:italic># 列出当前名字空间下所有 Services，按名称排序</span>
kubectl get services --sort-by<span style=color:#666>=</span>.metadata.name

<span style=color:#080;font-style:italic># 列出 Pods，按重启次数排序</span>
kubectl get pods --sort-by<span style=color:#666>=</span><span style=color:#b44>&#39;.status.containerStatuses[0].restartCount&#39;</span>

<span style=color:#080;font-style:italic># 列举所有 PV 持久卷，按容量排序</span>
kubectl get pv --sort-by<span style=color:#666>=</span>.spec.capacity.storage

<span style=color:#080;font-style:italic># 获取包含 app=cassandra 标签的所有 Pods 的 version 标签</span>
kubectl get pods --selector<span style=color:#666>=</span><span style=color:#b8860b>app</span><span style=color:#666>=</span>cassandra -o <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.items[*].metadata.labels.version}&#39;</span>

<span style=color:#080;font-style:italic># 检索带有 “.” 键值，例： &#39;ca.crt&#39;</span>
kubectl get configmap myconfig <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.data.ca\.crt}&#39;</span>

<span style=color:#080;font-style:italic># 获取所有工作节点（使用选择器以排除标签名称为 &#39;node-role.kubernetes.io/master&#39; 的结果）</span>
kubectl get node --selector<span style=color:#666>=</span><span style=color:#b44>&#39;!node-role.kubernetes.io/master&#39;</span>

<span style=color:#080;font-style:italic># 获取当前命名空间中正在运行的 Pods</span>
kubectl get pods --field-selector<span style=color:#666>=</span>status.phase<span style=color:#666>=</span>Running

<span style=color:#080;font-style:italic># 获取全部节点的 ExternalIP 地址</span>
kubectl get nodes -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.items[*].status.addresses[?(@.type==&#34;ExternalIP&#34;)].address}&#39;</span>

<span style=color:#080;font-style:italic># 列出属于某个特定 RC 的 Pods 的名称</span>
<span style=color:#080;font-style:italic># 在转换对于 jsonpath 过于复杂的场合，&#34;jq&#34; 命令很有用；可以在 https://stedolan.github.io/jq/ 找到它。</span>
<span style=color:#b8860b>sel</span><span style=color:#666>=</span><span style=color:#b68;font-weight:700>${</span><span style=color:#a2f;font-weight:700>$(</span>kubectl get rc my-rc --output<span style=color:#666>=</span>json | jq -j <span style=color:#b44>&#39;.spec.selector | to_entries | .[] | &#34;\(.key)=\(.value),&#34;&#39;</span><span style=color:#a2f;font-weight:700>)</span>%?<span style=color:#b68;font-weight:700>}</span>
<span style=color:#a2f>echo</span> <span style=color:#a2f;font-weight:700>$(</span>kubectl get pods --selector<span style=color:#666>=</span><span style=color:#b8860b>$sel</span> --output<span style=color:#666>=</span><span style=color:#b8860b>jsonpath</span><span style=color:#666>={</span>.items..metadata.name<span style=color:#666>}</span><span style=color:#a2f;font-weight:700>)</span>

<span style=color:#080;font-style:italic># 显示所有 Pods 的标签（或任何其他支持标签的 Kubernetes 对象）</span>
kubectl get pods --show-labels

<span style=color:#080;font-style:italic># 检查哪些节点处于就绪状态</span>
<span style=color:#b8860b>JSONPATH</span><span style=color:#666>=</span><span style=color:#b44>&#39;{range .items[*]}{@.metadata.name}:{range @.status.conditions[*]}{@.type}={@.status};{end}{end}&#39;</span> <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span> <span style=color:#666>&amp;&amp;</span> kubectl get nodes -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#34;</span><span style=color:#b8860b>$JSONPATH</span><span style=color:#b44>&#34;</span> | grep <span style=color:#b44>&#34;Ready=True&#34;</span>

<span style=color:#080;font-style:italic># 不使用外部工具来输出解码后的 Secret</span>
kubectl get secret my-secret -o go-template<span style=color:#666>=</span><span style=color:#b44>&#39;{{range $k,$v := .data}}{{&#34;### &#34;}}{{$k}}{{&#34;\n&#34;}}{{$v|base64decode}}{{&#34;\n\n&#34;}}{{end}}&#39;</span>

<span style=color:#080;font-style:italic># 列出被一个 Pod 使用的全部 Secret</span>
kubectl get pods -o json | jq <span style=color:#b44>&#39;.items[].spec.containers[].env[]?.valueFrom.secretKeyRef.name&#39;</span> | grep -v null | sort | uniq

<span style=color:#080;font-style:italic># 列举所有 Pods 中初始化容器的容器 ID（containerID）</span>
<span style=color:#080;font-style:italic># 可用于在清理已停止的容器时避免删除初始化容器</span>
kubectl get pods --all-namespaces -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{range .items[*].status.initContainerStatuses[*]}{.containerID}{&#34;\n&#34;}{end}&#39;</span> | cut -d/ -f3

<span style=color:#080;font-style:italic># 列出事件（Events），按时间戳排序</span>
kubectl get events --sort-by<span style=color:#666>=</span>.metadata.creationTimestamp

<span style=color:#080;font-style:italic># 比较当前的集群状态和假定某清单被应用之后的集群状态</span>
kubectl diff -f ./my-manifest.yaml

<span style=color:#080;font-style:italic># 生成一个句点分隔的树，其中包含为节点返回的所有键</span>
<span style=color:#080;font-style:italic># 在复杂的嵌套JSON结构中定位键时非常有用</span>
kubectl get nodes -o json | jq -c <span style=color:#b44>&#39;path(..)|[.[]|tostring]|join(&#34;.&#34;)&#39;</span>

<span style=color:#080;font-style:italic># 生成一个句点分隔的树，其中包含为pod等返回的所有键</span>
kubectl get pods -o json | jq -c <span style=color:#b44>&#39;path(..)|[.[]|tostring]|join(&#34;.&#34;)&#39;</span>

<span style=color:#080;font-style:italic># 假设你的 Pods 有默认的容器和默认的名字空间，并且支持 &#39;env&#39; 命令，可以使用以下脚本为所有 Pods 生成 ENV 变量。</span>
<span style=color:#080;font-style:italic># 该脚本也可用于在所有的 Pods 里运行任何受支持的命令，而不仅仅是 &#39;env&#39;。 </span>
<span style=color:#a2f;font-weight:700>for</span> pod in <span style=color:#a2f;font-weight:700>$(</span>kubectl get po --output<span style=color:#666>=</span><span style=color:#b8860b>jsonpath</span><span style=color:#666>={</span>.items..metadata.name<span style=color:#666>}</span><span style=color:#a2f;font-weight:700>)</span>; <span style=color:#a2f;font-weight:700>do</span> <span style=color:#a2f>echo</span> <span style=color:#b8860b>$pod</span> <span style=color:#666>&amp;&amp;</span> kubectl <span style=color:#a2f>exec</span> -it <span style=color:#b8860b>$pod</span> -- env; <span style=color:#a2f;font-weight:700>done</span>
</code></pre></div>
<h2 id=更新资源>更新资源</h2>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl <span style=color:#a2f>set</span> image deployment/frontend <span style=color:#b8860b>www</span><span style=color:#666>=</span>image:v2               <span style=color:#080;font-style:italic># 滚动更新 &#34;frontend&#34; Deployment 的 &#34;www&#34; 容器镜像</span>
kubectl rollout <span style=color:#a2f>history</span> deployment/frontend                      <span style=color:#080;font-style:italic># 检查 Deployment 的历史记录，包括版本</span>
kubectl rollout undo deployment/frontend                         <span style=color:#080;font-style:italic># 回滚到上次部署版本</span>
kubectl rollout undo deployment/frontend --to-revision<span style=color:#666>=</span><span style=color:#666>2</span>         <span style=color:#080;font-style:italic># 回滚到特定部署版本</span>
kubectl rollout status -w deployment/frontend                    <span style=color:#080;font-style:italic># 监视 &#34;frontend&#34; Deployment 的滚动升级状态直到完成</span>
kubectl rollout restart deployment/frontend                      <span style=color:#080;font-style:italic># 轮替重启 &#34;frontend&#34; Deployment</span>

cat pod.json | kubectl replace -f -                              <span style=color:#080;font-style:italic># 通过传入到标准输入的 JSON 来替换 Pod</span>

<span style=color:#080;font-style:italic># 强制替换，删除后重建资源。会导致服务不可用。</span>
kubectl replace --force -f ./pod.json

<span style=color:#080;font-style:italic># 为多副本的 nginx 创建服务，使用 80 端口提供服务，连接到容器的 8000 端口。</span>
kubectl expose rc nginx --port<span style=color:#666>=</span><span style=color:#666>80</span> --target-port<span style=color:#666>=</span><span style=color:#666>8000</span>

<span style=color:#080;font-style:italic># 将某单容器 Pod 的镜像版本（标签）更新到 v4</span>
kubectl get pod mypod -o yaml | sed <span style=color:#b44>&#39;s/\(image: myimage\):.*$/\1:v4/&#39;</span> | kubectl replace -f -

kubectl label pods my-pod new-label<span style=color:#666>=</span>awesome                      <span style=color:#080;font-style:italic># 添加标签</span>
kubectl annotate pods my-pod icon-url<span style=color:#666>=</span>http://goo.gl/XXBTWq       <span style=color:#080;font-style:italic># 添加注解</span>
kubectl autoscale deployment foo --min<span style=color:#666>=</span><span style=color:#666>2</span> --max<span style=color:#666>=</span><span style=color:#666>10</span>                <span style=color:#080;font-style:italic># 对 &#34;foo&#34; Deployment 自动伸缩容</span>
</code></pre></div>
<h2 id=部分更新资源>部分更新资源</h2>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#080;font-style:italic># 部分更新某节点</span>
kubectl patch node k8s-node-1 -p <span style=color:#b44>&#39;{&#34;spec&#34;:{&#34;unschedulable&#34;:true}}&#39;</span>

<span style=color:#080;font-style:italic># 更新容器的镜像；spec.containers[*].name 是必须的。因为它是一个合并性质的主键。</span>
kubectl patch pod valid-pod -p <span style=color:#b44>&#39;{&#34;spec&#34;:{&#34;containers&#34;:[{&#34;name&#34;:&#34;kubernetes-serve-hostname&#34;,&#34;image&#34;:&#34;new image&#34;}]}}&#39;</span>

<span style=color:#080;font-style:italic># 使用带位置数组的 JSON patch 更新容器的镜像</span>
kubectl patch pod valid-pod --type<span style=color:#666>=</span><span style=color:#b44>&#39;json&#39;</span> -p<span style=color:#666>=</span><span style=color:#b44>&#39;[{&#34;op&#34;: &#34;replace&#34;, &#34;path&#34;: &#34;/spec/containers/0/image&#34;, &#34;value&#34;:&#34;new image&#34;}]&#39;</span>

<span style=color:#080;font-style:italic># 使用带位置数组的 JSON patch 禁用某 Deployment 的 livenessProbe</span>
kubectl patch deployment valid-deployment  --type json   -p<span style=color:#666>=</span><span style=color:#b44>&#39;[{&#34;op&#34;: &#34;remove&#34;, &#34;path&#34;: &#34;/spec/template/spec/containers/0/livenessProbe&#34;}]&#39;</span>

<span style=color:#080;font-style:italic># 在带位置数组中添加元素</span>
kubectl patch sa default --type<span style=color:#666>=</span><span style=color:#b44>&#39;json&#39;</span> -p<span style=color:#666>=</span><span style=color:#b44>&#39;[{&#34;op&#34;: &#34;add&#34;, &#34;path&#34;: &#34;/secrets/1&#34;, &#34;value&#34;: {&#34;name&#34;: &#34;whatever&#34; } }]&#39;</span>
</code></pre></div>
<h2 id=编辑资源>编辑资源</h2>
<p>使用你偏爱的编辑器编辑 API 资源。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl edit svc/docker-registry                      <span style=color:#080;font-style:italic># 编辑名为 docker-registry 的服务</span>
<span style=color:#b8860b>KUBE_EDITOR</span><span style=color:#666>=</span><span style=color:#b44>&#34;nano&#34;</span> kubectl edit svc/docker-registry   <span style=color:#080;font-style:italic># 使用其他编辑器</span>
</code></pre></div>
<h2 id=对资源进行伸缩>对资源进行伸缩</h2>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl scale --replicas<span style=color:#666>=</span><span style=color:#666>3</span> rs/foo                                 <span style=color:#080;font-style:italic># 将名为 &#39;foo&#39; 的副本集伸缩到 3 副本</span>
kubectl scale --replicas<span style=color:#666>=</span><span style=color:#666>3</span> -f foo.yaml                            <span style=color:#080;font-style:italic># 将在 &#34;foo.yaml&#34; 中的特定资源伸缩到 3 个副本</span>
kubectl scale --current-replicas<span style=color:#666>=</span><span style=color:#666>2</span> --replicas<span style=color:#666>=</span><span style=color:#666>3</span> deployment/mysql  <span style=color:#080;font-style:italic># 如果名为 mysql 的 Deployment 的副本当前是 2，那么将它伸缩到 3</span>
kubectl scale --replicas<span style=color:#666>=</span><span style=color:#666>5</span> rc/foo rc/bar rc/baz                   <span style=color:#080;font-style:italic># 伸缩多个副本控制器</span>
</code></pre></div>
<h2 id=删除资源>删除资源</h2>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl delete -f ./pod.json                                              <span style=color:#080;font-style:italic># 删除在 pod.json 中指定的类型和名称的 Pod</span>
kubectl delete pod,service baz foo                                        <span style=color:#080;font-style:italic># 删除名称为 &#34;baz&#34; 和 &#34;foo&#34; 的 Pod 和服务</span>
kubectl delete pods,services -l <span style=color:#b8860b>name</span><span style=color:#666>=</span>myLabel                              <span style=color:#080;font-style:italic># 删除包含 name=myLabel 标签的 pods 和服务</span>
kubectl -n my-ns delete pod,svc --all                                     <span style=color:#080;font-style:italic># 删除在 my-ns 名字空间中全部的 Pods 和服务</span>
<span style=color:#080;font-style:italic># 删除所有与 pattern1 或 pattern2 awk 模式匹配的 Pods</span>
kubectl get pods  -n mynamespace --no-headers<span style=color:#666>=</span><span style=color:#a2f>true</span> | awk <span style=color:#b44>&#39;/pattern1|pattern2/{print $1}&#39;</span> | xargs  kubectl delete -n mynamespace pod
</code></pre></div>
<h2 id=与运行中的-pods-进行交互>与运行中的 Pods 进行交互</h2>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl logs my-pod                                 <span style=color:#080;font-style:italic># 获取 pod 日志（标准输出）</span>
kubectl logs -l <span style=color:#b8860b>name</span><span style=color:#666>=</span>myLabel                        <span style=color:#080;font-style:italic># 获取含 name=myLabel 标签的 Pods 的日志（标准输出）</span>
kubectl logs my-pod --previous                      <span style=color:#080;font-style:italic># 获取上个容器实例的 pod 日志（标准输出）</span>
kubectl logs my-pod -c my-container                 <span style=color:#080;font-style:italic># 获取 Pod 容器的日志（标准输出, 多容器场景）</span>
kubectl logs -l <span style=color:#b8860b>name</span><span style=color:#666>=</span>myLabel -c my-container        <span style=color:#080;font-style:italic># 获取含 name=myLabel 标签的 Pod 容器日志（标准输出, 多容器场景）</span>
kubectl logs my-pod -c my-container --previous      <span style=color:#080;font-style:italic># 获取 Pod 中某容器的上个实例的日志（标准输出, 多容器场景）</span>
kubectl logs -f my-pod                              <span style=color:#080;font-style:italic># 流式输出 Pod 的日志（标准输出）</span>
kubectl logs -f my-pod -c my-container              <span style=color:#080;font-style:italic># 流式输出 Pod 容器的日志（标准输出, 多容器场景）</span>
kubectl logs -f -l <span style=color:#b8860b>name</span><span style=color:#666>=</span>myLabel --all-containers    <span style=color:#080;font-style:italic># 流式输出含 name=myLabel 标签的 Pod 的所有日志（标准输出）</span>
kubectl run -i --tty busybox --image<span style=color:#666>=</span>busybox -- sh  <span style=color:#080;font-style:italic># 以交互式 Shell 运行 Pod</span>
kubectl run nginx --image<span style=color:#666>=</span>nginx -n mynamespace      <span style=color:#080;font-style:italic># 在指定名字空间中运行 nginx Pod</span>
kubectl run nginx --image<span style=color:#666>=</span>nginx                     <span style=color:#080;font-style:italic># 运行 ngins Pod 并将其规约写入到名为 pod.yaml 的文件</span>
  --dry-run<span style=color:#666>=</span>client -o yaml &gt; pod.yaml

kubectl attach my-pod -i                            <span style=color:#080;font-style:italic># 挂接到一个运行的容器中</span>
kubectl port-forward my-pod 5000:6000               <span style=color:#080;font-style:italic># 在本地计算机上侦听端口 5000 并转发到 my-pod 上的端口 6000</span>
kubectl <span style=color:#a2f>exec</span> my-pod -- ls /                         <span style=color:#080;font-style:italic># 在已有的 Pod 中运行命令（单容器场景）</span>
kubectl <span style=color:#a2f>exec</span> --stdin --tty my-pod -- /bin/sh        <span style=color:#080;font-style:italic># 使用交互 shell 访问正在运行的 Pod (一个容器场景)</span>
kubectl <span style=color:#a2f>exec</span> my-pod -c my-container -- ls /         <span style=color:#080;font-style:italic># 在已有的 Pod 中运行命令（多容器场景）</span>
kubectl top pod POD_NAME --containers               <span style=color:#080;font-style:italic># 显示给定 Pod 和其中容器的监控数据</span>
kubectl top pod POD_NAME --sort-by<span style=color:#666>=</span>cpu              <span style=color:#080;font-style:italic># 显示给定 Pod 的指标并且按照 &#39;cpu&#39; 或者 &#39;memory&#39; 排序</span>
</code></pre></div>
<h2 id=与-deployments-和-services-进行交互>与 Deployments 和 Services 进行交互</h2>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl logs deploy/my-deployment                         <span style=color:#080;font-style:italic># 获取一个 Deployment 的 Pod 的日志（单容器例子）</span>
kubectl logs deploy/my-deployment -c my-container         <span style=color:#080;font-style:italic># 获取一个 Deployment 的 Pod 的日志（多容器例子）</span>

kubectl port-forward svc/my-service <span style=color:#666>5000</span>                  <span style=color:#080;font-style:italic># 侦听本地端口 5000 并转发到 Service 后端端口 5000</span>
kubectl port-forward svc/my-service 5000:my-service-port  <span style=color:#080;font-style:italic># 侦听本地端口 5000 并转发到名字为 &lt;my-service-port&gt; 的 Service 目标端口</span>

kubectl port-forward deploy/my-deployment 5000:6000       <span style=color:#080;font-style:italic># 侦听本地端口 5000 并转发到 &lt;my-deployment&gt; 创建的 Pod 里的端口 6000</span>
kubectl <span style=color:#a2f>exec</span> deploy/my-deployment -- ls                   <span style=color:#080;font-style:italic># 在 Deployment 里的第一个 Pod 的第一个容器里运行命令（单容器和多容器例子）</span>
</code></pre></div>
<h2 id=与节点和集群进行交互>与节点和集群进行交互</h2>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl cordon my-node                                                <span style=color:#080;font-style:italic># 标记 my-node 节点为不可调度</span>
kubectl drain my-node                                                 <span style=color:#080;font-style:italic># 对 my-node 节点进行清空操作，为节点维护做准备</span>
kubectl uncordon my-node                                              <span style=color:#080;font-style:italic># 标记 my-node 节点为可以调度</span>
kubectl top node my-node                                              <span style=color:#080;font-style:italic># 显示给定节点的度量值</span>
kubectl cluster-info                                                  <span style=color:#080;font-style:italic># 显示主控节点和服务的地址</span>
kubectl cluster-info dump                                             <span style=color:#080;font-style:italic># 将当前集群状态转储到标准输出</span>
kubectl cluster-info dump --output-directory<span style=color:#666>=</span>/path/to/cluster-state   <span style=color:#080;font-style:italic># 将当前集群状态输出到 /path/to/cluster-state</span>

<span style=color:#080;font-style:italic># 如果已存在具有指定键和效果的污点，则替换其值为指定值。</span>
kubectl taint nodes foo <span style=color:#b8860b>dedicated</span><span style=color:#666>=</span>special-user:NoSchedule
</code></pre></div>
<h3 id=资源类型>资源类型</h3>
<p>列出所支持的全部资源类型和它们的简称、<a href=/zh/docs/concepts/overview/kubernetes-api/#api-groups-and-versioning>API 组</a>, 是否是<a href=/zh/docs/concepts/overview/working-with-objects/namespaces>名字空间作用域</a> 和 <a href=/zh/docs/concepts/overview/working-with-objects/kubernetes-objects>Kind</a>。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl api-resources
</code></pre></div>
<p>用于探索 API 资源的其他操作：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl api-resources --namespaced<span style=color:#666>=</span><span style=color:#a2f>true</span>      <span style=color:#080;font-style:italic># 所有命名空间作用域的资源</span>
kubectl api-resources --namespaced<span style=color:#666>=</span><span style=color:#a2f>false</span>     <span style=color:#080;font-style:italic># 所有非命名空间作用域的资源</span>
kubectl api-resources -o name                <span style=color:#080;font-style:italic># 用简单格式列举所有资源（仅显示资源名称）</span>
kubectl api-resources -o wide                <span style=color:#080;font-style:italic># 用扩展格式列举所有资源（又称 &#34;wide&#34; 格式）</span>
kubectl api-resources --verbs<span style=color:#666>=</span>list,get       <span style=color:#080;font-style:italic># 支持 &#34;list&#34; 和 &#34;get&#34; 请求动词的所有资源</span>
kubectl api-resources --api-group<span style=color:#666>=</span>extensions <span style=color:#080;font-style:italic># &#34;extensions&#34; API 组中的所有资源</span>
</code></pre></div>
<h3 id=格式化输出>格式化输出</h3>
<p>要以特定格式将详细信息输出到终端窗口，将 <code>-o</code>（或者 <code>--output</code>）参数添加到支持的 <code>kubectl</code> 命令中。</p>
<table>
<thead>
<tr>
<th>输出格式</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>-o=custom-columns=&lt;spec></code></td>
<td>使用逗号分隔的自定义列来打印表格</td>
</tr>
<tr>
<td><code>-o=custom-columns-file=&lt;filename></code></td>
<td>使用 <code>&lt;filename></code> 文件中的自定义列模板打印表格</td>
</tr>
<tr>
<td><code>-o=json</code></td>
<td>输出 JSON 格式的 API 对象</td>
</tr>
<tr>
<td><code>-o=jsonpath=&lt;template></code></td>
<td>打印 <a href=/zh/docs/reference/kubectl/jsonpath>jsonpath</a> 表达式中定义的字段</td>
</tr>
<tr>
<td><code>-o=jsonpath-file=&lt;filename></code></td>
<td>打印在 <code>&lt;filename></code> 文件中定义的 <a href=/zh/docs/reference/kubectl/jsonpath>jsonpath</a> 表达式所指定的字段。</td>
</tr>
<tr>
<td><code>-o=name</code></td>
<td>仅打印资源名称而不打印其他内容</td>
</tr>
<tr>
<td><code>-o=wide</code></td>
<td>以纯文本格式输出额外信息，对于 Pod 来说，输出中包含了节点名称</td>
</tr>
<tr>
<td><code>-o=yaml</code></td>
<td>输出 YAML 格式的 API 对象</td>
</tr>
</tbody>
</table>
<p>使用 <code>-o=custom-columns</code> 的示例：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#080;font-style:italic># 集群中运行着的所有镜像</span>
kubectl get pods -A -o<span style=color:#666>=</span>custom-columns<span style=color:#666>=</span><span style=color:#b44>&#39;DATA:spec.containers[*].image&#39;</span>

<span style=color:#080;font-style:italic># 列举 default 名字空间中运行的所有镜像，按 Pod 分组</span>
kubectl get pods --namespace default --output<span style=color:#666>=</span>custom-columns<span style=color:#666>=</span><span style=color:#b44>&#34;NAME:.metadata.name,IMAGE:.spec.containers[*].image&#34;</span>

<span style=color:#080;font-style:italic># 除 &#34;k8s.gcr.io/coredns:1.6.2&#34; 之外的所有镜像</span>
kubectl get pods -A -o<span style=color:#666>=</span>custom-columns<span style=color:#666>=</span><span style=color:#b44>&#39;DATA:spec.containers[?(@.image!=&#34;k8s.gcr.io/coredns:1.6.2&#34;)].image&#39;</span>

<span style=color:#080;font-style:italic># 输出 metadata 下面的所有字段，无论 Pod 名字为何</span>
kubectl get pods -A -o<span style=color:#666>=</span>custom-columns<span style=color:#666>=</span><span style=color:#b44>&#39;DATA:metadata.*&#39;</span>
</code></pre></div><p>有关更多示例，请参看 kubectl <a href=/zh/docs/reference/kubectl/overview/#custom-columns>参考文档</a>。</p>
<h3 id=kubectl-日志输出详细程度和调试>Kubectl 日志输出详细程度和调试</h3>
<p>Kubectl 日志输出详细程度是通过 <code>-v</code> 或者 <code>--v</code> 来控制的，参数后跟一个数字表示日志的级别。
Kubernetes 通用的日志习惯和相关的日志级别在
<a href=https://github.com/kubernetes/community/blob/master/contributors/devel/sig-instrumentation/logging.md>这里</a> 有相应的描述。</p>
<table>
<thead>
<tr>
<th>详细程度</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>--v=0</code></td>
<td>用于那些应该 <em>始终</em> 对运维人员可见的信息，因为这些信息一般很有用。</td>
</tr>
<tr>
<td><code>--v=1</code></td>
<td>如果您不想要看到冗余信息，此值是一个合理的默认日志级别。</td>
</tr>
<tr>
<td><code>--v=2</code></td>
<td>输出有关服务的稳定状态的信息以及重要的日志消息，这些信息可能与系统中的重大变化有关。这是建议大多数系统设置的默认日志级别。</td>
</tr>
<tr>
<td><code>--v=3</code></td>
<td>包含有关系统状态变化的扩展信息。</td>
</tr>
<tr>
<td><code>--v=4</code></td>
<td>包含调试级别的冗余信息。</td>
</tr>
<tr>
<td><code>--v=5</code></td>
<td>跟踪级别的详细程度。</td>
</tr>
<tr>
<td><code>--v=6</code></td>
<td>显示所请求的资源。</td>
</tr>
<tr>
<td><code>--v=7</code></td>
<td>显示 HTTP 请求头。</td>
</tr>
<tr>
<td><code>--v=8</code></td>
<td>显示 HTTP 请求内容。</td>
</tr>
<tr>
<td><code>--v=9</code></td>
<td>显示 HTTP 请求内容而且不截断内容。</td>
</tr>
</tbody>
</table>
<h2 id=what-s-next>What's next</h2>
<ul>
<li>参阅 <a href=/zh/docs/reference/kubectl/overview/>kubectl 概述</a>，进一步了解<a href=/zh/docs/reference/kubectl/jsonpath>JsonPath</a>。</li>
<li>参阅 <a href=/zh/docs/reference/kubectl/kubectl/>kubectl</a> 选项。</li>
<li>参阅 <a href=/zh/docs/reference/kubectl/conventions/>kubectl 使用约定</a>来理解如何在可复用的脚本中使用它。</li>
<li>查看社区中其他的 <a href=https://github.com/dennyzhang/cheatsheet-kubernetes-A4>kubectl 备忘单</a>。</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-8de6aceb8bf692c06cced446bac5bc92>6 - kubectl 的用法约定</h1>
<p><code>kubectl</code> 的推荐用法约定。</p>
<h2 id=在可重用脚本中使用-kubectl>在可重用脚本中使用 <code>kubectl</code></h2>
<p>对于脚本中的稳定输出：</p>
<ul>
<li>请求一个面向机器的输出格式，例如 <code>-o name</code>、<code>-o json</code>、<code>-o yaml</code>、<code>-o go template</code> 或 <code>-o jsonpath</code>。</li>
<li>完全限定版本。例如 <code>jobs.v1.batch/myjob</code>。这将确保 kubectl 不会使用其默认版本，该版本会随着时间的推移而更改。</li>
<li>不要依赖上下文、首选项或其他隐式状态。</li>
</ul>
<h2 id=最佳实践>最佳实践</h2>
<h3 id=kubectl-run><code>kubectl run</code></h3>
<p>若希望 <code>kubectl run</code> 满足基础设施即代码的要求：</p>
<ul>
<li>使用特定版本的标签标记镜像，不要将该标签移动到新版本。例如，使用 <code>:v1234</code>、<code>v1.2.3</code>、<code>r03062016-1-4</code>，而不是 <code>:latest</code>（有关详细信息，请参阅<a href=/zh/docs/concepts/configuration/overview/#container-images>配置的最佳实践</a>)。</li>
<li>使用基于版本控制的脚本来运行包含大量参数的镜像。</li>
<li>对于无法通过 <code>kubectl run</code> 参数来表示的功能特性，使用基于源码控制的配置文件，以记录要使用的功能特性。</li>
</ul>
<p>你可以使用 <code>--dry-run=client</code> 参数来预览而不真正提交即将下发到集群的对象实例：</p>
<h3 id=kubectl-apply><code>kubectl apply</code></h3>
<ul>
<li>您可以使用 <code>kubectl apply</code> 命令创建或更新资源。有关使用 kubectl apply 更新资源的详细信息，请参阅 <a href=https://kubectl.docs.kubernetes.io>Kubectl 文档</a>。</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-a7abc09192597e614b58f8b552b682f5>7 - 适用于 Docker 用户的 kubectl</h1>
<p>您可以使用 Kubernetes 命令行工具 <code>kubectl</code> 与 API 服务器进行交互。如果您熟悉 Docker 命令行工具，则使用 kubectl 非常简单。但是，Docker 命令和 kubectl 命令之间有一些区别。以下显示了 Docker 子命令，并描述了等效的 <code>kubectl</code> 命令。</p>
<h2 id=docker-run>docker run</h2>
<p>要运行 nginx 部署并将其暴露，请参见<a href=/docs/reference/generated/kubectl/kubectl-commands#-em-deployment-em->kubectl create deployment</a>
docker:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>docker run -d --restart<span style=color:#666>=</span>always -e <span style=color:#b8860b>DOMAIN</span><span style=color:#666>=</span>cluster --name nginx-app -p 80:80 nginx
</code></pre></div><pre><code>55c103fa129692154a7652490236fee9be47d70a8dd562281ae7d2f9a339a6db
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>docker ps
</code></pre></div><pre><code>CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                NAMES
55c103fa1296        nginx               &quot;nginx -g 'daemon of…&quot;   9 seconds ago       Up 9 seconds        0.0.0.0:80-&gt;80/tcp   nginx-app
</code></pre><p>kubectl:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># 启动运行 nginx 的 Pod</span>
kubectl create deployment --image<span style=color:#666>=</span>nginx nginx-app
</code></pre></div><pre><code>deployment.apps/nginx-app created
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># add env to nginx-app</span>
kubectl <span style=color:#a2f>set</span> env deployment/nginx-app  <span style=color:#b8860b>DOMAIN</span><span style=color:#666>=</span>cluster
</code></pre></div><pre><code>deployment.apps/nginx-app env updated
</code></pre><div class="alert alert-info note callout" role=alert>
<strong>Note:</strong>
<p><code>kubectl</code> 命令打印创建或突变资源的类型和名称，然后可以在后续命令中使用。部署后，您可以公开新服务。
</div>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># 通过服务公开端口</span>
kubectl expose deployment nginx-app --port<span style=color:#666>=</span><span style=color:#666>80</span> --name<span style=color:#666>=</span>nginx-http
</code></pre></div><pre><code>service &quot;nginx-http&quot; exposed
</code></pre>
<p>在 kubectl 命令中，我们创建了一个 <a href=/zh/docs/concepts/workloads/controllers/deployment/>Deployment</a>，这将保证有 N 个运行 nginx 的 pod(N 代表 spec 中声明的 replica 数，默认为 1)。我们还创建了一个 <a href=/zh/docs/concepts/services-networking/service/>service</a>，其选择器与容器标签匹配。查看<a href=/zh/docs/tasks/access-application-cluster/service-access-application-cluster>使用服务访问群集中的应用程序</a> 获取更多信息。</p>
<p>默认情况下镜像会在后台运行，与 <code>docker run -d ...</code> 类似，如果您想在前台运行，使用 <a href=/docs/reference/generated/kubectl/kubectl-commands/#run><code>kubectl run</code></a> 在前台运行 Pod:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl run <span style=color:#666>[</span>-i<span style=color:#666>]</span> <span style=color:#666>[</span>--tty<span style=color:#666>]</span> --attach &lt;name&gt; --image<span style=color:#666>=</span>&lt;image&gt;
</code></pre></div>
<p>与 <code>docker run ...</code> 不同的是，如果指定了 <code>--attach</code> ，我们将连接到 <code>stdin</code>，<code>stdout</code> 和 <code>stderr</code>，而不能控制具体连接到哪个输出流（<code>docker -a ...</code>）。要从容器中退出，可以输入 Ctrl + P，然后按 Ctrl + Q。</p>
<p>因为我们使用 Deployment 启动了容器，如果您终止连接到的进程（例如 <code>ctrl-c</code>），容器将会重启，这跟 <code>docker run -it</code> 不同。
如果想销毁该 Deployment（和它的 pod），您需要运行 <code>kubectl delete deployment &lt;name></code>。</p>
<h2 id=docker-ps>docker ps</h2>
<p>如何列出哪些正在运行？查看 <a href=/docs/reference/generated/kubectl/kubectl-commands/#get>kubectl get</a>。</p>
<p>使用 docker 命令：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>docker ps -a
</code></pre></div><pre><code>CONTAINER ID        IMAGE               COMMAND                  CREATED              STATUS                     PORTS                NAMES
14636241935f        ubuntu:16.04        &quot;echo test&quot;              5 seconds ago        Exited (0) 5 seconds ago                        cocky_fermi
55c103fa1296        nginx               &quot;nginx -g 'daemon of…&quot;   About a minute ago   Up About a minute          0.0.0.0:80-&gt;80/tcp   nginx-app
</code></pre>
<p>使用 kubectl 命令：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get po
</code></pre></div><pre><code>NAME                        READY     STATUS      RESTARTS   AGE
nginx-app-8df569cb7-4gd89   1/1       Running     0          3m
ubuntu                      0/1       Completed   0          20s
</code></pre><h2 id=docker-attach>docker attach</h2>
<p>如何连接到已经运行在容器中的进程？查看 <a href=/docs/reference/generated/kubectl/kubectl-commands/#attach>kubectl attach</a>。</p>
<p>使用 docker 命令：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>docker ps
</code></pre></div><pre><code>CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                NAMES
55c103fa1296        nginx               &quot;nginx -g 'daemon of…&quot;   5 minutes ago       Up 5 minutes        0.0.0.0:80-&gt;80/tcp   nginx-app
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>docker attach 55c103fa1296
...
</code></pre></div><p>kubectl:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods
</code></pre></div><pre><code>NAME              READY     STATUS    RESTARTS   AGE
nginx-app-5jyvm   1/1       Running   0          10m
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl attach -it nginx-app-5jyvm
...
</code></pre></div>
<p>要从容器中分离，可以输入 Ctrl + P，然后按 Ctrl + Q。</p>
<h2 id=docker-exec>docker exec</h2>
<p>如何在容器中执行命令？查看 <a href=/docs/reference/generated/kubectl/kubectl-commands/#exec>kubectl exec</a>。</p>
<p>使用 docker 命令：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>docker ps
</code></pre></div><pre><code>CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                NAMES
55c103fa1296        nginx               &quot;nginx -g 'daemon of…&quot;   6 minutes ago       Up 6 minutes        0.0.0.0:80-&gt;80/tcp   nginx-app
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>docker <span style=color:#a2f>exec</span> 55c103fa1296 cat /etc/hostname
</code></pre></div><pre><code>55c103fa1296
</code></pre>
<p>使用 kubectl 命令：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get po
</code></pre></div><pre><code>NAME              READY     STATUS    RESTARTS   AGE
nginx-app-5jyvm   1/1       Running   0          10m
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#a2f>exec</span> nginx-app-5jyvm -- cat /etc/hostname
</code></pre></div><pre><code>nginx-app-5jyvm
</code></pre>
<p>执行交互式命令怎么办？</p>
<p>使用 docker 命令：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>docker <span style=color:#a2f>exec</span> -ti 55c103fa1296 /bin/sh
<span style=color:#080;font-style:italic># exit</span>
</code></pre></div><p>kubectl:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#a2f>exec</span> -ti nginx-app-5jyvm -- /bin/sh      
<span style=color:#080;font-style:italic># exit</span>
</code></pre></div>
<p>更多信息请查看<a href=/zh/docs/tasks/debug-application-cluster/get-shell-running-container/>获取运行中容器的 Shell 环境</a>。</p>
<h2 id=docker-logs>docker logs</h2>
<p>如何查看运行中进程的 stdout/stderr？查看 <a href=/docs/reference/generated/kubectl/kubectl-commands/#logs>kubectl logs</a>。</p>
<p>使用 docker 命令：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>docker logs -f a9e
</code></pre></div><pre><code>192.168.9.1 - - [14/Jul/2015:01:04:02 +0000] &quot;GET / HTTP/1.1&quot; 200 612 &quot;-&quot; &quot;curl/7.35.0&quot; &quot;-&quot;
192.168.9.1 - - [14/Jul/2015:01:04:03 +0000] &quot;GET / HTTP/1.1&quot; 200 612 &quot;-&quot; &quot;curl/7.35.0&quot; &quot;-&quot;
</code></pre>
<p>使用 kubectl 命令：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl logs -f nginx-app-zibvs
</code></pre></div><pre><code>10.240.63.110 - - [14/Jul/2015:01:09:01 +0000] &quot;GET / HTTP/1.1&quot; 200 612 &quot;-&quot; &quot;curl/7.26.0&quot; &quot;-&quot;
10.240.63.110 - - [14/Jul/2015:01:09:02 +0000] &quot;GET / HTTP/1.1&quot; 200 612 &quot;-&quot; &quot;curl/7.26.0&quot; &quot;-&quot;
</code></pre>
<p>现在是时候提一下 pod 和容器之间的细微差别了；默认情况下如果 pod 中的进程退出 pod 也不会终止，相反它将会重启该进程。这类似于 docker run 时的 <code>--restart=always</code> 选项， 这是主要差别。在 docker 中，进程的每个调用的输出都是被连接起来的，但是对于 kubernetes，每个调用都是分开的。要查看以前在 kubernetes 中执行的输出，请执行以下操作：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl logs --previous nginx-app-zibvs
</code></pre></div><pre><code>10.240.63.110 - - [14/Jul/2015:01:09:01 +0000] &quot;GET / HTTP/1.1&quot; 200 612 &quot;-&quot; &quot;curl/7.26.0&quot; &quot;-&quot;
10.240.63.110 - - [14/Jul/2015:01:09:02 +0000] &quot;GET / HTTP/1.1&quot; 200 612 &quot;-&quot; &quot;curl/7.26.0&quot; &quot;-&quot;
</code></pre>
<p>查看<a href=/zh/docs/concepts/cluster-administration/logging/>日志架构</a>获取更多信息。</p>
<h2 id=docker-stop-and-docker-rm>docker stop and docker rm</h2>
<p>如何停止和删除运行中的进程？查看 <a href=/docs/reference/generated/kubectl/kubectl-commands/#delete>kubectl delete</a>。</p>
<p>使用 docker 命令：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>docker ps
</code></pre></div><pre><code>CONTAINER ID        IMAGE               COMMAND                CREATED             STATUS              PORTS                         NAMES
a9ec34d98787        nginx               &quot;nginx -g 'daemon of&quot;  22 hours ago        Up 22 hours         0.0.0.0:80-&gt;80/tcp, 443/tcp   nginx-app
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>docker stop a9ec34d98787
</code></pre></div><pre><code>a9ec34d98787
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>docker rm a9ec34d98787
</code></pre></div><pre><code>a9ec34d98787
</code></pre>
<p>使用 kubectl 命令：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get deployment nginx-app
</code></pre></div><pre><code>NAME         READY   UP-TO-DATE   AVAILABLE   AGE
nginx-app    1/1     1            1           2m
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get po -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>nginx-app
</code></pre></div><pre><code>NAME                         READY     STATUS    RESTARTS   AGE
nginx-app-2883164633-aklf7   1/1       Running   0          2m
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete deployment nginx-app
</code></pre></div><pre><code>deployment &quot;nginx-app&quot; deleted
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get po -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>nginx-app
<span style=color:#080;font-style:italic># Return nothing</span>
</code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>Note:</strong>
<p>请注意，我们不直接删除 pod。使用 kubectl 命令，我们要删除拥有该 pod 的 Deployment。如果我们直接删除 pod，Deployment 将会重新创建该 pod。
</div>
<h2 id=docker-login>docker login</h2>
<p>在 kubectl 中没有对 <code>docker login</code> 的直接模拟。如果您有兴趣在私有镜像仓库中使用 Kubernetes，请参阅<a href=/zh/docs/concepts/containers/images/#using-a-private-registry>使用私有镜像仓库</a>。</p>
<h2 id=docker-version>docker version</h2>
<p>如何查看客户端和服务端的版本？查看 <a href=/docs/reference/generated/kubectl/kubectl-commands/#version>kubectl version</a>。</p>
<p>使用 docker 命令：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>docker version
</code></pre></div><pre><code>Client version: 1.7.0
Client API version: 1.19
Go version (client): go1.4.2
Git commit (client): 0baf609
OS/Arch (client): linux/amd64
Server version: 1.7.0
Server API version: 1.19
Go version (server): go1.4.2
Git commit (server): 0baf609
OS/Arch (server): linux/amd64
</code></pre>
<p>使用 kubectl 命令：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl version
</code></pre></div><pre><code>Client Version: version.Info{Major:&quot;1&quot;, Minor:&quot;6&quot;, GitVersion:&quot;v1.6.9+a3d1dfa6f4335&quot;, GitCommit:&quot;9b77fed11a9843ce3780f70dd251e92901c43072&quot;, GitTreeState:&quot;dirty&quot;, BuildDate:&quot;2017-08-29T20:32:58Z&quot;, OpenPaasKubernetesVersion:&quot;v1.03.02&quot;, GoVersion:&quot;go1.7.5&quot;, Compiler:&quot;gc&quot;, Platform:&quot;linux/amd64&quot;}
Server Version: version.Info{Major:&quot;1&quot;, Minor:&quot;6&quot;, GitVersion:&quot;v1.6.9+a3d1dfa6f4335&quot;, GitCommit:&quot;9b77fed11a9843ce3780f70dd251e92901c43072&quot;, GitTreeState:&quot;dirty&quot;, BuildDate:&quot;2017-08-29T20:32:58Z&quot;, OpenPaasKubernetesVersion:&quot;v1.03.02&quot;, GoVersion:&quot;go1.7.5&quot;, Compiler:&quot;gc&quot;, Platform:&quot;linux/amd64&quot;}
</code></pre><h2 id=docker-info>docker info</h2>
<p>如何获取有关环境和配置的各种信息？查看 <a href=/docs/reference/generated/kubectl/kubectl-commands/#cluster-info>kubectl cluster-info</a>。</p>
<p>使用 docker 命令：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>docker info
</code></pre></div><pre><code>Containers: 40
Images: 168
Storage Driver: aufs
 Root Dir: /usr/local/google/docker/aufs
 Backing Filesystem: extfs
 Dirs: 248
 Dirperm1 Supported: false
Execution Driver: native-0.2
Logging Driver: json-file
Kernel Version: 3.13.0-53-generic
Operating System: Ubuntu 14.04.2 LTS
CPUs: 12
Total Memory: 31.32 GiB
Name: k8s-is-fun.mtv.corp.google.com
ID: ADUV:GCYR:B3VJ:HMPO:LNPQ:KD5S:YKFQ:76VN:IANZ:7TFV:ZBF4:BYJO
WARNING: No swap limit support
</code></pre>
<p>使用 kubectl 命令：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl cluster-info
</code></pre></div><pre><code>Kubernetes master is running at https://108.59.85.141
KubeDNS is running at https://108.59.85.141/api/v1/namespaces/kube-system/services/kube-dns/proxy
kubernetes-dashboard is running at https://108.59.85.141/api/v1/namespaces/kube-system/services/kubernetes-dashboard/proxy
Grafana is running at https://108.59.85.141/api/v1/namespaces/kube-system/services/monitoring-grafana/proxy
Heapster is running at https://108.59.85.141/api/v1/namespaces/kube-system/services/monitoring-heapster/proxy
InfluxDB is running at https://108.59.85.141/api/v1/namespaces/kube-system/services/monitoring-influxdb/proxy
</code></pre>
</div>
</main>
</div>
</div>
<footer class=d-print-none>
<div class=footer__links>
<nav>
<a class=text-white href=/zh/docs/home/>主页</a>
<a class=text-white href=/zh/blog/>博客</a>
<a class=text-white href=/zh/training/>培训</a>
<a class=text-white href=/zh/partners/>合作伙伴</a>
<a class=text-white href=/zh/community/>社区</a>
<a class=text-white href=/zh/case-studies/>案例分析</a>
</nav>
</div>
<div class=container-fluid>
<div class=row>
<div class="col-6 col-sm-2 text-xs-center order-sm-2">
<ul class="list-inline mb-0">
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="User mailing list" aria-label="User mailing list">
<a class=text-white target=_blank href=https://discuss.kubernetes.io>
<i class="fa fa-envelope"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Twitter aria-label=Twitter>
<a class=text-white target=_blank href=https://twitter.com/kubernetesio>
<i class="fab fa-twitter"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Calendar aria-label=Calendar>
<a class=text-white target=_blank href="https://calendar.google.com/calendar/embed?src=calendar%40kubernetes.io">
<i class="fas fa-calendar-alt"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Youtube aria-label=Youtube>
<a class=text-white target=_blank href=https://youtube.com/kubernetescommunity>
<i class="fab fa-youtube"></i>
</a>
</li>
</ul>
</div>
<div class="col-6 col-sm-2 text-right text-xs-center order-sm-3">
<ul class="list-inline mb-0">
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub>
<a class=text-white target=_blank href=https://github.com/kubernetes/kubernetes>
<i class="fab fa-github"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Slack aria-label=Slack>
<a class=text-white target=_blank href=https://slack.k8s.io>
<i class="fab fa-slack"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Contribute aria-label=Contribute>
<a class=text-white target=_blank href=https://git.k8s.io/community/contributors/guide>
<i class="fas fa-edit"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Stack Overflow" aria-label="Stack Overflow">
<a class=text-white target=_blank href=https://stackoverflow.com/questions/tagged/kubernetes>
<i class="fab fa-stack-overflow"></i>
</a>
</li>
</ul>
</div>
<div class="col-12 col-sm-8 text-center order-sm-2">
<small class=text-white>&copy; 2023 The Kubernetes Authors | Documentation Distributed under <a href=https://git.k8s.io/website/LICENSE class=light-text>CC BY 4.0</a></small>
<br>
<small class=text-white>Copyright &copy; 2023 The Linux Foundation &reg;. All rights reserved. The Linux Foundation has registered trademarks and uses trademarks. For a list of trademarks of The Linux Foundation, please see our <a href=https://www.linuxfoundation.org/trademark-usage class=light-text>Trademark Usage page</a></small>
<br>
<small class=text-white>ICP license: 京ICP备17074266号-3</small>
</div>
</div>
</div>
</footer>
</div>
<script src=/js/popper-1.14.3.min.js integrity=sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49 crossorigin=anonymous></script>
<script src=/js/bootstrap-4.3.1.min.js integrity=sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM crossorigin=anonymous></script>
<script src=/js/main.min.40616251a9b6e4b689e7769be0340661efa4d7ebb73f957404e963e135b4ed52.js integrity="sha256-QGFiUam25LaJ53ab4DQGYe+k1+u3P5V0BOlj4TW07VI=" crossorigin=anonymous></script>
</body>
</html>