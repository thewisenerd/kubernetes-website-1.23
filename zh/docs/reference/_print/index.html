<!doctype html><html lang=zh class=no-js>
<head>
<meta name=ROBOTS content="NOINDEX, NOFOLLOW">
<script async src="https://www.googletagmanager.com/gtag/js?id=G-JPP6RFM2BP"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-JPP6RFM2BP')</script>
<link rel=alternate hreflang=en href=https://kubernetes.io/docs/reference/>
<link rel=alternate hreflang=ko href=https://kubernetes.io/ko/docs/reference/>
<link rel=alternate hreflang=ja href=https://kubernetes.io/ja/docs/reference/>
<link rel=alternate hreflang=fr href=https://kubernetes.io/fr/docs/reference/>
<link rel=alternate hreflang=de href=https://kubernetes.io/de/docs/reference/>
<link rel=alternate hreflang=es href=https://kubernetes.io/es/docs/reference/>
<link rel=alternate hreflang=pt-br href=https://kubernetes.io/pt-br/docs/reference/>
<link rel=alternate hreflang=id href=https://kubernetes.io/id/docs/reference/>
<link rel=alternate hreflang=ru href=https://kubernetes.io/ru/docs/reference/>
<link rel=alternate hreflang=pl href=https://kubernetes.io/pl/docs/reference/>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=generator content="Hugo 0.87.0">
<link rel=canonical type=text/html href=https://kubernetes.io/zh/docs/reference/>
<link rel="shortcut icon" type=image/png href=/images/favicon.png>
<link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180>
<link rel=manifest href=/manifest.webmanifest>
<link rel=apple-touch-icon href=/images/kubernetes-192x192.png>
<title>参考 | Kubernetes</title><meta property="og:title" content="参考">
<meta property="og:description" content="生产级别的容器编排系统">
<meta property="og:type" content="website">
<meta property="og:url" content="https://kubernetes.io/zh/docs/reference/"><meta property="og:site_name" content="Kubernetes">
<meta itemprop=name content="参考">
<meta itemprop=description content="生产级别的容器编排系统"><meta name=twitter:card content="summary">
<meta name=twitter:title content="参考">
<meta name=twitter:description content="生产级别的容器编排系统">
<link href=/scss/main.css rel=stylesheet>
<script src=/js/jquery-3.3.1.min.js integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin=anonymous></script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","url":"https://kubernetes.io","logo":"https://kubernetes.io/images/favicon.png"}</script>
<meta name=theme-color content="#326ce5">
<link rel=stylesheet href=/css/feature-states.css>
<meta name=description content="这是 Kubernetes 文档的参考部分。
API 参考   术语表 - 一个全面的标准化的 Kubernetes 术语表
  Kubernetes API 参考
  Kubernetes API 单页参考 v1.23。
  使用 Kubernetes API  - Kubernetes 的 API 概述
  API 的访问控制 - 关于 Kubernetes 如何控制 API 访问的详细信息
  常见的标签、注解和污点
  官方支持的客户端库 如果您需要通过编程语言调用 Kubernetes API，您可以使用 客户端库。以下是官方支持的客户端库：
 Kubernetes Go 语言客户端库 Kubernetes Python 语言客户端库 Kubernetes Java 语言客户端库 Kubernetes JavaScript 语言客户端库 Kubernetes C# 语言客户端库 Kubernetes Haskell 语言客户端库  CLI  kubectl - 主要的 CLI 工具，用于运行命令和管理 Kubernetes 集群。  JSONPath - 通过 kubectl 使用 JSONPath 表达式 的语法指南。   kubeadm - 此 CLI 工具可轻松配置安全的 Kubernetes 集群。  组件   kubelet - 在每个节点上运行的主代理。kubelet 接收一组 PodSpecs 并确保其所描述的容器健康地运行。">
<meta property="og:description" content="这是 Kubernetes 文档的参考部分。
API 参考   术语表 - 一个全面的标准化的 Kubernetes 术语表
  Kubernetes API 参考
  Kubernetes API 单页参考 v1.23。
  使用 Kubernetes API  - Kubernetes 的 API 概述
  API 的访问控制 - 关于 Kubernetes 如何控制 API 访问的详细信息
  常见的标签、注解和污点
  官方支持的客户端库 如果您需要通过编程语言调用 Kubernetes API，您可以使用 客户端库。以下是官方支持的客户端库：
 Kubernetes Go 语言客户端库 Kubernetes Python 语言客户端库 Kubernetes Java 语言客户端库 Kubernetes JavaScript 语言客户端库 Kubernetes C# 语言客户端库 Kubernetes Haskell 语言客户端库  CLI  kubectl - 主要的 CLI 工具，用于运行命令和管理 Kubernetes 集群。  JSONPath - 通过 kubectl 使用 JSONPath 表达式 的语法指南。   kubeadm - 此 CLI 工具可轻松配置安全的 Kubernetes 集群。  组件   kubelet - 在每个节点上运行的主代理。kubelet 接收一组 PodSpecs 并确保其所描述的容器健康地运行。">
<meta name=twitter:description content="这是 Kubernetes 文档的参考部分。
API 参考   术语表 - 一个全面的标准化的 Kubernetes 术语表
  Kubernetes API 参考
  Kubernetes API 单页参考 v1.23。
  使用 Kubernetes API  - Kubernetes 的 API 概述
  API 的访问控制 - 关于 Kubernetes 如何控制 API 访问的详细信息
  常见的标签、注解和污点
  官方支持的客户端库 如果您需要通过编程语言调用 Kubernetes API，您可以使用 客户端库。以下是官方支持的客户端库：
 Kubernetes Go 语言客户端库 Kubernetes Python 语言客户端库 Kubernetes Java 语言客户端库 Kubernetes JavaScript 语言客户端库 Kubernetes C# 语言客户端库 Kubernetes Haskell 语言客户端库  CLI  kubectl - 主要的 CLI 工具，用于运行命令和管理 Kubernetes 集群。  JSONPath - 通过 kubectl 使用 JSONPath 表达式 的语法指南。   kubeadm - 此 CLI 工具可轻松配置安全的 Kubernetes 集群。  组件   kubelet - 在每个节点上运行的主代理。kubelet 接收一组 PodSpecs 并确保其所描述的容器健康地运行。">
<meta property="og:url" content="https://kubernetes.io/zh/docs/reference/">
<meta property="og:title" content="参考">
<meta name=twitter:title content="参考">
<meta name=twitter:image content="https://kubernetes.io/images/favicon.png">
<meta name=twitter:image:alt content="Kubernetes">
<meta property="og:image" content="/images/kubernetes-horizontal-color.png">
<meta property="og:type" content="article">
<script src=/js/script.js></script>
</head>
<body class=td-section>
<header>
<nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar" data-auto-burger=primary>
<a class=navbar-brand href=/zh/></a>
<div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar>
<ul class="navbar-nav mt-2 mt-lg-0">
<li class="nav-item mr-2 mb-lg-0">
<a class="nav-link active" href=/zh/docs/>文档</a>
</li>
<li class="nav-item mr-2 mb-lg-0">
<a class=nav-link href=/zh/blog/>Kubernetes 博客</a>
</li>
<li class="nav-item mr-2 mb-lg-0">
<a class=nav-link href=/zh/training/>培训</a>
</li>
<li class="nav-item mr-2 mb-lg-0">
<a class=nav-link href=/zh/partners/>合作伙伴</a>
</li>
<li class="nav-item mr-2 mb-lg-0">
<a class=nav-link href=/zh/community/>社区</a>
</li>
<li class="nav-item mr-2 mb-lg-0">
<a class=nav-link href=/zh/case-studies/>案例分析</a>
</li>
<li class="nav-item dropdown">
<a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>
Versions
</a>
<div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink>
<a class=dropdown-item href=/releases>Release Information</a>
<a class=dropdown-item href=https://kubernetes.io/zh/docs/reference/>v1.27</a>
<a class=dropdown-item href=https://v1-26.docs.kubernetes.io/zh/docs/reference/>v1.26</a>
<a class=dropdown-item href=https://v1-25.docs.kubernetes.io/zh/docs/reference/>v1.25</a>
<a class=dropdown-item href=https://v1-24.docs.kubernetes.io/zh/docs/reference/>v1.24</a>
<a class=dropdown-item href=https://v1-23.docs.kubernetes.io/zh/docs/reference/>v1.23</a>
</div>
</li>
<li class="nav-item dropdown">
<a class="nav-link dropdown-toggle" href=# id=navbarDropdownMenuLink role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>
中文 Chinese
</a>
<div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink>
<a class=dropdown-item href=/docs/reference/>English</a>
<a class=dropdown-item href=/ko/docs/reference/>한국어 Korean</a>
<a class=dropdown-item href=/ja/docs/reference/>日本語 Japanese</a>
<a class=dropdown-item href=/fr/docs/reference/>Français</a>
<a class=dropdown-item href=/de/docs/reference/>Deutsch</a>
<a class=dropdown-item href=/es/docs/reference/>Español</a>
<a class=dropdown-item href=/pt-br/docs/reference/>Português</a>
<a class=dropdown-item href=/id/docs/reference/>Bahasa Indonesia</a>
<a class=dropdown-item href=/ru/docs/reference/>Русский</a>
<a class=dropdown-item href=/pl/docs/reference/>Polski</a>
</div>
</li>
</ul>
</div>
<button id=hamburger onclick=kub.toggleMenu() data-auto-burger-exclude><div></div></button>
</nav>
</header>
<div class="container-fluid td-outer">
<div class=td-main>
<div class="row flex-xl-nowrap">
<main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main>
<div class=td-content>
<div class="pageinfo pageinfo-primary d-print-none">
<p>
这是本节的多页打印视图。
<a href=# onclick="return print(),!1">点击此处打印</a>.
</p><p>
<a href=/zh/docs/reference/>返回本页常规视图</a>.
</p>
</div>
<h1 class=title>参考</h1>
<ul>
<li>1: <a href=#pg-2b03679960950df772fb4fe7d78427b9>词汇表</a></li>
<li>2: <a href=#pg-882c82a32bfb4d7946585a93a966b442>API 概述</a></li>
<ul>
<li>2.1: <a href=#pg-2b5428a2ff6f4831fd972ef50e12b3eb>Kubernetes API 概念</a></li>
<li>2.2: <a href=#pg-040d9484db673074f1b8ba3465be9d91>服务器端应用（Server-Side Apply）</a></li>
<li>2.3: <a href=#pg-79880efc25dc8cb3b6962ad78a964319>客户端库</a></li>
<li>2.4: <a href=#pg-8d2ce3e7b2223cda0ccd428f4d5ea24b>Kubernetes 弃用策略</a></li>
<li>2.5: <a href=#pg-2479c39af50fd55b898a3bcfb5988077>已弃用 API 的迁移指南</a></li>
<li>2.6: <a href=#pg-e4dbb59f8f23854d7b7d574e169923c4>Kubernetes API 健康端点</a></li>
</ul>
<li>3: <a href=#pg-99b26586d8a33ec06996dcf7892a9683>API 访问控制</a></li>
<ul>
<li>3.1: <a href=#pg-a6264859a5ad6e2f4a6e4cff9ce4fa8b>用户认证</a></li>
<li>3.2: <a href=#pg-de45b6ca7419a0e308044425b2ac52bb>使用启动引导令牌（Bootstrap Tokens）认证</a></li>
<li>3.3: <a href=#pg-3d0c14d1e3cfade38febc343cd044c73>证书签名请求</a></li>
<li>3.4: <a href=#pg-518807b9b00bda46d7c7e6e0b17c18f8>使用准入控制器</a></li>
<li>3.5: <a href=#pg-d04751f776f1faa6a82bbb7f0a200950>动态准入控制</a></li>
<li>3.6: <a href=#pg-bea207258f3576b8ec7444a20d498e1d>管理服务账号</a></li>
<li>3.7: <a href=#pg-342be69d36f174f762c36f4fe11fcb20>鉴权概述</a></li>
<li>3.8: <a href=#pg-954776b47f2d90515f375623a0ce98e1>使用 RBAC 鉴权</a></li>
<li>3.9: <a href=#pg-9cbb97d4d9f08d67931a1baae4e6519c>使用 Node 鉴权</a></li>
<li>3.10: <a href=#pg-215c25173044b8f97e9b0494b0c7e53f>Webhook 模式</a></li>
<li>3.11: <a href=#pg-643e4cec52a8577e9454649bdaac84d0>从 PodSecurityPolicy 映射到 Pod 安全性标准</a></li>
<li>3.12: <a href=#pg-a5bdc757c01991e5e6ab1a82b90639ea>使用 ABAC 鉴权</a></li>
</ul>
<li>4: <a href=#pg-e7512a333ae98d32429d24b2290eb15a>众所周知的标签、注解和污点</a></li>
<ul>
<li>4.1: <a href=#pg-0adf63217075ed2dc0a3030d9673e75e>审计注解</a></li>
</ul>
<li>5: <a href=#pg-60a16da3955f1de774f1f8dd756f2251>Kubernetes API</a></li>
<ul>
<li>5.1: <a href=#pg-5037aed176781855678f89b4c21626ac>工作负载资源</a></li>
<ul>
</ul>
<li>5.2: <a href=#pg-54e55c546ba2153921dc8b78bafd699e>Service 资源</a></li>
<ul>
</ul>
<li>5.3: <a href=#pg-ef67581d88f69ea15be11159c033f33b>配置和存储资源</a></li>
<ul>
</ul>
<li>5.4: <a href=#pg-6a5e06a0dc59d104938425c049f2f29b>身份认证资源</a></li>
<ul>
<li>5.4.1: <a href=#pg-4140627880f82c11a5e16b3c4043cfdb>TokenReview</a></li>
</ul>
<li>5.5: <a href=#pg-5362c9a7583eca653d4a705ba4e460ff>鉴权资源</a></li>
<ul>
</ul>
<li>5.6: <a href=#pg-d8857a338d5c6dc04752576100c946d9>策略资源</a></li>
<ul>
</ul>
<li>5.7: <a href=#pg-020d8f776dea9802131630c210dc4c0a>扩展资源</a></li>
<ul>
</ul>
<li>5.8: <a href=#pg-692a25c0f0c88fc9b8c1e82cd0b0ee9e>集群资源</a></li>
<ul>
</ul>
<li>5.9: <a href=#pg-0a260d85a5da2504fce8c56b77c45024>公共定义</a></li>
<ul>
<li>5.9.1: <a href=#pg-9eba5edb3c1d93f9a74827e3a71014dd>删除选项</a></li>
<li>5.9.2: <a href=#pg-26234b02eb0546f7a178da9c373cb197>标签选择器</a></li>
<li>5.9.3: <a href=#pg-dbe3b11fb1cfde0aac65f945d84b11d6>ListMeta</a></li>
<li>5.9.4: <a href=#pg-026383e0b43a68744a8b27a82bb4926d>LocalObjectReference</a></li>
<li>5.9.5: <a href=#pg-deb2d19043a047688f72480af2f1b1e0>NodeSelectorRequirement</a></li>
<li>5.9.6: <a href=#pg-47b6e1916665dd55bbeb2b33847653ed>ObjectFieldSelector</a></li>
<li>5.9.7: <a href=#pg-77f040b7d1c00efcedc11902ed78fc08>ObjectMeta</a></li>
<li>5.9.8: <a href=#pg-cf854f859540243f660c2798d641498c>ObjectReference</a></li>
<li>5.9.9: <a href=#pg-1997570a6710a3eaf78270f2e2535167>Patch</a></li>
<li>5.9.10: <a href=#pg-51b0e3fdb6e89030bd9e49dbb990918c>Quantity</a></li>
<li>5.9.11: <a href=#pg-406fd6938a5a3283ee7a816347603389>ResourceFieldSelector</a></li>
<li>5.9.12: <a href=#pg-b86f72d0a9c9625228b55ff79c154b63>Status</a></li>
<li>5.9.13: <a href=#pg-ad5a39cd0d4233c0afb2a1daf17b95b3>TypedLocalObjectReference</a></li>
</ul>
<li>5.10: <a href=#pg-6fbe4a9bf41cfee30909689bd978c45f>常用参数</a></li>
</ul>
<li>6: <a href=#pg-af7c1f9168ec67f957edc504f43faf9a>Kubernetes 问题和安全</a></li>
<ul>
<li>6.1: <a href=#pg-980c0542a3b195a20cfd4358792e2a38>Kubernetes 问题追踪</a></li>
<li>6.2: <a href=#pg-1f7dc06f1cc1ea2cdde4480e54d5fb34>Kubernetes 安全和信息披露</a></li>
</ul>
<li>7: <a href=#pg-75e3b4b5f680fdd081dc8af8060a2bf7>节点参考信息</a></li>
<ul>
<li>7.1: <a href=#pg-26e96c9d268f9c39dfc525b98f477a12>关于 dockershim 移除和使用兼容 CRI 运行时的外部文章</a></li>
</ul>
<li>8: <a href=#pg-5bbbc5163b35431b3bff029ab9ec57d3>安装工具</a></li>
<ul>
<li>8.1: <a href=#pg-f351ced098abbb076bc8c4be1053672b>Kubeadm</a></li>
<ul>
<li>8.1.1: <a href=#pg-36c22b52e8447eb3d2452d4f56fbea9b>创建 Kubeadm</a></li>
<ul>
<li>8.1.1.1: <a href=#pg-fd3ad295c1f10bfa333f841bbdffba81></a></li>
<li>8.1.1.2: <a href=#pg-8df9aba508b2736a6712ef46227eea7d></a></li>
<li>8.1.1.3: <a href=#pg-018648dfc6f28bc9b969f45af0563cae></a></li>
<li>8.1.1.4: <a href=#pg-4a1ff27cdf01c1c47d034278048e776b></a></li>
<li>8.1.1.5: <a href=#pg-5d6b2999153cd86f56329534249fc4ec></a></li>
<li>8.1.1.6: <a href=#pg-adb5eecdc351074cc2e0cc2b1b4f04a8></a></li>
<li>8.1.1.7: <a href=#pg-df4c2dc6cba0be90d8d7de2fca9b87f7></a></li>
<li>8.1.1.8: <a href=#pg-6d6746e8ac1f1602f7dab1056b27e5c2></a></li>
<li>8.1.1.9: <a href=#pg-7449c7fa06f25b967cf531e937b0f4b2></a></li>
<li>8.1.1.10: <a href=#pg-b5c6ae77d3be9bd358c68667006cfc18></a></li>
<li>8.1.1.11: <a href=#pg-4f804e59ec1739e733807d2b591d771f></a></li>
<li>8.1.1.12: <a href=#pg-f5cf8caa95834803b133d53c321ab4a9></a></li>
<li>8.1.1.13: <a href=#pg-ee770858e2bb767b79d572b4882af656></a></li>
<li>8.1.1.14: <a href=#pg-7484bf11b6183f4c329b1f66734cc886></a></li>
<li>8.1.1.15: <a href=#pg-bf444d915ab856dba693c36294c5427b></a></li>
<li>8.1.1.16: <a href=#pg-f5c087e087714c5290b4967dd7924b3b></a></li>
<li>8.1.1.17: <a href=#pg-20703ce1c236264ad78cb1ad7244723e></a></li>
<li>8.1.1.18: <a href=#pg-49aaa494ef75de67609987a43e5ee520></a></li>
<li>8.1.1.19: <a href=#pg-d63311c16e6468f5a5940aadd902faa7></a></li>
<li>8.1.1.20: <a href=#pg-6678a79b85306310066616185153377d></a></li>
<li>8.1.1.21: <a href=#pg-8f73e208cc67d221165f6294393881a7></a></li>
<li>8.1.1.22: <a href=#pg-9aec3477159c105a46f4479de1c21418></a></li>
<li>8.1.1.23: <a href=#pg-045e41c28798930e21f77a90c3a90263></a></li>
<li>8.1.1.24: <a href=#pg-e7d83478123771ad14f475ee44440303></a></li>
<li>8.1.1.25: <a href=#pg-57a6b20d9571220989a7a445d4459468></a></li>
<li>8.1.1.26: <a href=#pg-92a2c11eef37937af846b55d9b87a544></a></li>
<li>8.1.1.27: <a href=#pg-dcfffcaafb438cd650475945ddc129ee></a></li>
<li>8.1.1.28: <a href=#pg-6eaa2624c512051ff2a9cdbc6ee54949></a></li>
<li>8.1.1.29: <a href=#pg-4b7ada30e3923594b2907dcb8b431080></a></li>
<li>8.1.1.30: <a href=#pg-6d1154da2e554de858cf4e7b37c054fa></a></li>
<li>8.1.1.31: <a href=#pg-d3a16914ddc849435ed864163978ddbf></a></li>
<li>8.1.1.32: <a href=#pg-8a257337ea78e5d9a0c54aa971eaf991></a></li>
<li>8.1.1.33: <a href=#pg-77759011117e7974cbfee9694b6f8801></a></li>
<li>8.1.1.34: <a href=#pg-8e1920b2caaa8de839cd3997edca80e9></a></li>
<li>8.1.1.35: <a href=#pg-00aa8c2e4b3b2fd3a4b7986976b7bfda></a></li>
<li>8.1.1.36: <a href=#pg-316aa97ee5719be5a723ac1b77c44f5a></a></li>
<li>8.1.1.37: <a href=#pg-759e85e62b32c0697ab37c214e99a864></a></li>
<li>8.1.1.38: <a href=#pg-2e7091074560abc2a8e7b897cdd8a7b6></a></li>
<li>8.1.1.39: <a href=#pg-eedb8f5a6ed4cff1dfb1a5d14176b5b3></a></li>
<li>8.1.1.40: <a href=#pg-c55f2fa6bdaa124b37da090a3ef90902></a></li>
<li>8.1.1.41: <a href=#pg-10f416336efdcee22d691869e7585b9f></a></li>
<li>8.1.1.42: <a href=#pg-c4b6d149cda7cac896f4374c821b7fc6></a></li>
<li>8.1.1.43: <a href=#pg-1db087626f4f368e932df6f12993a5ab></a></li>
<li>8.1.1.44: <a href=#pg-e85da83e18a50e472eb56320af55768a></a></li>
<li>8.1.1.45: <a href=#pg-eb911bdcb8bb53ceb8b253089ab0d814></a></li>
<li>8.1.1.46: <a href=#pg-62c5dc89c39f3ecd6aee57545d12891a></a></li>
<li>8.1.1.47: <a href=#pg-2a79e12b9455f0ca1a6d5b00a9841249></a></li>
<li>8.1.1.48: <a href=#pg-a2c8efac328fcf416e558bf167ef417d></a></li>
<li>8.1.1.49: <a href=#pg-d93bd37094201bdefdb3908c9a6c86b3></a></li>
<li>8.1.1.50: <a href=#pg-efa9ae4c92ed1c26dc04bb049db38cec></a></li>
<li>8.1.1.51: <a href=#pg-576c00359074987304b3b418cec9a5b1></a></li>
<li>8.1.1.52: <a href=#pg-e6097fe5dd013abd9f356c2566ef7b63></a></li>
<li>8.1.1.53: <a href=#pg-5ab65eab2498cc1893af5b3bf8fe08fc></a></li>
<li>8.1.1.54: <a href=#pg-fcb78718510a9d3027d1bb9d379c0c17></a></li>
<li>8.1.1.55: <a href=#pg-a0e1457f667eb757f82f8c42901aa6c5></a></li>
<li>8.1.1.56: <a href=#pg-59e362bf565041872395d165e99eafc1></a></li>
<li>8.1.1.57: <a href=#pg-2a5040747a02ae2b2326c9901f1725d3></a></li>
<li>8.1.1.58: <a href=#pg-043bd19497eefb77a6ed30a4d704fe7c></a></li>
<li>8.1.1.59: <a href=#pg-bffb0d67824e75ade7232d09754b9718></a></li>
<li>8.1.1.60: <a href=#pg-a37b5872c572c71775e389df50fca215></a></li>
<li>8.1.1.61: <a href=#pg-3f49598c499c3356d89d98fdc8c8ad79></a></li>
<li>8.1.1.62: <a href=#pg-7d68ac74e5301f789ddd2e25dd36218e></a></li>
<li>8.1.1.63: <a href=#pg-e7c1ae3d905d9b6854216e26651955cd></a></li>
<li>8.1.1.64: <a href=#pg-967a98823c19c8338bfc0e1338a20fb1></a></li>
<li>8.1.1.65: <a href=#pg-b5838cc93a3fdb37b61afd201a71edd9></a></li>
<li>8.1.1.66: <a href=#pg-f54c84a0fdada369a87b2ced6ccfc38f></a></li>
<li>8.1.1.67: <a href=#pg-0d96e214c09a8f014e984a6b980522b3></a></li>
<li>8.1.1.68: <a href=#pg-48afa88840a20edf1ad613c18480d4fc></a></li>
<li>8.1.1.69: <a href=#pg-14da359f76a0f36af507d289dd4a5050></a></li>
<li>8.1.1.70: <a href=#pg-3fda282409b804a14879b9c65c035797></a></li>
<li>8.1.1.71: <a href=#pg-e044e6c69c2b1512c8d89430e0400771></a></li>
<li>8.1.1.72: <a href=#pg-9f968809f867b76728697577492429e8></a></li>
<li>8.1.1.73: <a href=#pg-c3c506c1683aed34398a34ab66d609da></a></li>
<li>8.1.1.74: <a href=#pg-2c1a5a4405dca745ef50b4e86f5977c7></a></li>
<li>8.1.1.75: <a href=#pg-003aaef561d065ecdaeb2c325b6b9253></a></li>
<li>8.1.1.76: <a href=#pg-535f050663a6d8db3a61df2b19a0714b></a></li>
<li>8.1.1.77: <a href=#pg-2f0a684baffe3cdf830c16693412f8e0></a></li>
<li>8.1.1.78: <a href=#pg-aba528e06c437710b269f4e41f854fdd></a></li>
<li>8.1.1.79: <a href=#pg-1d7987a759cd1519def4d433710cdff1></a></li>
<li>8.1.1.80: <a href=#pg-33216a69b333c330cb8b305a119abc7c></a></li>
<li>8.1.1.81: <a href=#pg-53abd743076fc859067264f3e8e676e0></a></li>
<li>8.1.1.82: <a href=#pg-3a08eb202d572e417768a942ad24c59f></a></li>
<li>8.1.1.83: <a href=#pg-11ed4820a6c3b411d9c4b87163cf0ae7></a></li>
<li>8.1.1.84: <a href=#pg-e81c9d9320242b5ed4b063beea6696f8></a></li>
<li>8.1.1.85: <a href=#pg-47f2d404188d6eb1fbf6fffd7fba4e48></a></li>
<li>8.1.1.86: <a href=#pg-257824537b4c6c6b33249aa786461156></a></li>
<li>8.1.1.87: <a href=#pg-e10faf6f940de61052258af59e036518></a></li>
<li>8.1.1.88: <a href=#pg-a46a193f2322aa88cb3b2de2447b0461></a></li>
<li>8.1.1.89: <a href=#pg-f5b27d7bd0eeed918f8635c68d220dc5></a></li>
<li>8.1.1.90: <a href=#pg-370e9ffda66b4c48dfa54ea37c3aad21></a></li>
<li>8.1.1.91: <a href=#pg-6bd27042c883aa5c498647d37762392c></a></li>
<li>8.1.1.92: <a href=#pg-3a000435e1cca0be398b44b487f530c8></a></li>
<li>8.1.1.93: <a href=#pg-97fbe97ca22de377e7fbf2517e0451b6></a></li>
<li>8.1.1.94: <a href=#pg-bee6749065a369c2ab5b311eb43c40ba></a></li>
<li>8.1.1.95: <a href=#pg-bdd9680ec894593d17f782d5e5665fd4></a></li>
<li>8.1.1.96: <a href=#pg-1d005baad1a1e217d7ae0210fec96c3f></a></li>
<li>8.1.1.97: <a href=#pg-c79d11d27bed54caac743c93e0b2fb24></a></li>
<li>8.1.1.98: <a href=#pg-ba78e64c325e4131dd741235e2a1b2c0></a></li>
<li>8.1.1.99: <a href=#pg-872d33f1fbc83cb2f0bf89b4bd545174></a></li>
<li>8.1.1.100: <a href=#pg-7d8c1710684742ca940f580674225d9d></a></li>
<li>8.1.1.101: <a href=#pg-28dcf20d89c7bb1c8e7a3873d7703d5d></a></li>
<li>8.1.1.102: <a href=#pg-f869b6331e40c6f9eb01314f96d3113e></a></li>
<li>8.1.1.103: <a href=#pg-19a94d2f7649959b218952cef00729f4></a></li>
<li>8.1.1.104: <a href=#pg-b22d3ed181fb7f926ae2081f8fc8c14d></a></li>
<li>8.1.1.105: <a href=#pg-ae1ea74c2c21b25a3c1eacdaf549274b></a></li>
<li>8.1.1.106: <a href=#pg-633020ef232bc34f60c82153578a6c9b></a></li>
<li>8.1.1.107: <a href=#pg-e938edeb3d824f9b364de617a1f10a93></a></li>
<li>8.1.1.108: <a href=#pg-aa9f718186487df2ab6885cae45f5d37></a></li>
<li>8.1.1.109: <a href=#pg-60d816e74ec8e0301cc484b19d7694e6></a></li>
</ul>
<li>8.1.2: <a href=#pg-82b2fcf985bae77dcb754387a9fcc64f>kubeadm init</a></li>
<li>8.1.3: <a href=#pg-2a2b5f34806b4b1bd2c12682ac170d68>kubeadm join</a></li>
<li>8.1.4: <a href=#pg-2c20539d9fabf5982e2dd931742714bd>kubeadm upgrade</a></li>
<li>8.1.5: <a href=#pg-5042dc49c5348b3674d3878f37f7670b>kubeadm config</a></li>
<li>8.1.6: <a href=#pg-6eb5bc1e7114609930a76c683cc27c2b>kubeadm reset</a></li>
<li>8.1.7: <a href=#pg-516f4705fb2f5f62c76c7742772726a3>kubeadm token</a></li>
<li>8.1.8: <a href=#pg-34c4af6f36d969ed08ba840e7fb64c6d>kubeadm version</a></li>
<li>8.1.9: <a href=#pg-92a39c69c3689119dd5fa12886cb73a3>kubeadm alpha</a></li>
<li>8.1.10: <a href=#pg-6a1fed09235bbf3644c804339928f10e>kubeadm certs</a></li>
<li>8.1.11: <a href=#pg-fbe8dcd222ce5795a5c325670a26b067>kubeadm init phase</a></li>
<li>8.1.12: <a href=#pg-62a742c564b0b5b7ac12a95e67cc425a>kubeadm join phase</a></li>
<li>8.1.13: <a href=#pg-1ab2d643d770ca684548de4ddbc7d8c4>kubeadm kubeconfig</a></li>
<li>8.1.14: <a href=#pg-b969d0033ce5d9036463521fb1f150b3>kubeadm reset phase</a></li>
<li>8.1.15: <a href=#pg-dfd085b5ab706bd84dda15847dd27f1b>kubeadm upgrade phase</a></li>
<li>8.1.16: <a href=#pg-455b6412a275b743ee8ad90f35808393>实现细节</a></li>
</ul>
</ul>
<li>9: <a href=#pg-df8ff2190764e70c3de2015e2cb46b14>端口和协议</a></li>
<li>10: <a href=#pg-03460a7254c6c73eb2a1bb3dd7d25910>kubectl</a></li>
<ul>
<li>10.1: <a href=#pg-d7ffbf04ffbefb241fd0722423b80f5a>kubectl 命令</a></li>
<li>10.2: <a href=#pg-f14fe15ecc2d41b5e901ef5e872ca657>kubectl 概述</a></li>
<li>10.3: <a href=#pg-4d3e62632c189fcc3c1357cd8fb8799c>kubectl</a></li>
<li>10.4: <a href=#pg-a938176c695852fe70362c29cf615f1c>JSONPath 支持</a></li>
<li>10.5: <a href=#pg-8aba901ac13f124e5782b90ddb166ee2>kubectl 备忘单</a></li>
<li>10.6: <a href=#pg-8de6aceb8bf692c06cced446bac5bc92>kubectl 的用法约定</a></li>
<li>10.7: <a href=#pg-a7abc09192597e614b58f8b552b682f5>适用于 Docker 用户的 kubectl</a></li>
</ul>
<li>11: <a href=#pg-54e562dd1441d0195970a6526b0055cc>组件工具</a></li>
<ul>
<li>11.1: <a href=#pg-ca5d01a42c486d535539d3038aa67eb9>特性门控</a></li>
<li>11.2: <a href=#pg-29e506a6018204679ef5459653a7aa1f>kubelet</a></li>
<li>11.3: <a href=#pg-ec8ff2888d36f533a57bc9704ccc84e0>kube-apiserver</a></li>
<li>11.4: <a href=#pg-8a37271ec8fd36a3a1ce07c4c58533d9>kube-controller-manager</a></li>
<li>11.5: <a href=#pg-a727de6cb5a090d5f115f88a8606c438>kube-proxy</a></li>
<li>11.6: <a href=#pg-57e59e5ddd9db63da6c9d27cc0e2f254>kube-scheduler</a></li>
<li>11.7: <a href=#pg-1715b765e2ff39feffd103d59ec0ef07>Kubelet 认证/鉴权</a></li>
<li>11.8: <a href=#pg-bdd3803a4bb6efcc44a7ab03590ce93c>TLS 启动引导</a></li>
</ul>
<li>12: <a href=#pg-a6ae13190e147ef3922315c2091fc258>配置 API</a></li>
<ul>
<li>12.1: <a href=#pg-8f61883225b6bed85530d1904e148392>kube-apiserver Audit 配置 (v1)</a></li>
<li>12.2: <a href=#pg-eaf7c149d8e3f45225002d76aa5af774>kube-apiserver 加密配置 (v1)</a></li>
<li>12.3: <a href=#pg-fd52840184e93a463355aa21a234f263>kube-apiserver 配置 (v1)</a></li>
<li>12.4: <a href=#pg-e9edd8df1106a991be062e37a9ef87b5>kube-apiserver 配置 (v1alpha1)</a></li>
<li>12.5: <a href=#pg-d8644f8d8b33ff33a31c8b55065eaf37>kube-proxy 配置 (v1alpha1)</a></li>
<li>12.6: <a href=#pg-5cf379787cc3cd6f11182678610e6b5e>kube-scheduler 配置 (v1beta2)</a></li>
<li>12.7: <a href=#pg-2d4b71a4502f9ff672631862fe08b182>kube-scheduler 配置 (v1beta3)</a></li>
<li>12.8: <a href=#pg-81f4b8f1501e8345c99315695078a771>kubeadm 配置 (v1beta2)</a></li>
<li>12.9: <a href=#pg-675226e13e76ef189fe0156f7e52353a>kubeadm 配置 (v1beta3)</a></li>
<li>12.10: <a href=#pg-f0a175531432662368ed2e01f663b35f>Kubelet 配置 (v1alpha1)</a></li>
<li>12.11: <a href=#pg-aaa2b8b78fe84a05914c155652d10956>Kubelet 配置 (v1beta1)</a></li>
<li>12.12: <a href=#pg-74f43b2a33c21414f1ed8c359b37d326>WebhookAdmission 配置 (v1)</a></li>
<li>12.13: <a href=#pg-eee842643d4d2c372827920430a15614>客户端身份认证（Client Authentication） (v1)</a></li>
<li>12.14: <a href=#pg-2896357fe4f62fe85522254410e0be7d>客户端身份认证（Client Authentication）(v1beta1)</a></li>
</ul>
<li>13: <a href=#pg-f8b023454daa9497b7eea35b7d35c075>调度</a></li>
<ul>
<li>13.1: <a href=#pg-ef4fb938b6b63c95f5f26f9b1cec3054>调度器配置</a></li>
<li>13.2: <a href=#pg-5a0a68fb6a7ffefb6d5f861100fa0ae3>调度策略</a></li>
</ul>
<li>14: <a href=#pg-c808ce38575e73f72835d7ed02b03780>其他工具</a></li>
<ul>
<li>14.1: <a href=#pg-7424d2e36f2d487fc836016d83838bac>从 Docker 命令行映射到 crictl</a></li>
</ul>
</ul>
<div class=content>
<p>这是 Kubernetes 文档的参考部分。</p>
<h2 id=api-参考>API 参考</h2>
<ul>
<li>
<p><a href=/zh/docs/reference/glossary/>术语表</a> - 一个全面的标准化的 Kubernetes 术语表</p>
</li>
<li>
<p><a href=/zh/docs/reference/kubernetes-api/>Kubernetes API 参考</a></p>
</li>
<li>
<p><a href=/docs/reference/generated/kubernetes-api/v1.23/>Kubernetes API 单页参考 v1.23</a>。</p>
</li>
<li>
<p><a href=/zh/docs/reference/using-api/>使用 Kubernetes API </a> - Kubernetes 的 API 概述</p>
</li>
<li>
<p><a href=/zh/docs/reference/access-authn-authz/>API 的访问控制</a> - 关于 Kubernetes 如何控制 API 访问的详细信息</p>
</li>
<li>
<p><a href=/zh/docs/reference/labels-annotations-taints/>常见的标签、注解和污点</a></p>
</li>
</ul>
<h2 id=官方支持的客户端库>官方支持的客户端库</h2>
<p>如果您需要通过编程语言调用 Kubernetes API，您可以使用
<a href=/zh/docs/reference/using-api/client-libraries/>客户端库</a>。以下是官方支持的客户端库：</p>
<ul>
<li><a href=https://github.com/kubernetes/client-go/>Kubernetes Go 语言客户端库</a></li>
<li><a href=https://github.com/kubernetes-client/python>Kubernetes Python 语言客户端库</a></li>
<li><a href=https://github.com/kubernetes-client/java>Kubernetes Java 语言客户端库</a></li>
<li><a href=https://github.com/kubernetes-client/javascript>Kubernetes JavaScript 语言客户端库</a></li>
<li><a href=https://github.com/kubernetes-client/csharp>Kubernetes C# 语言客户端库</a></li>
<li><a href=https://github.com/kubernetes-client/haskell>Kubernetes Haskell 语言客户端库</a></li>
</ul>
<h2 id=cli>CLI</h2>
<ul>
<li><a href=/zh/docs/reference/kubectl/>kubectl</a> - 主要的 CLI 工具，用于运行命令和管理 Kubernetes 集群。
<ul>
<li><a href=/zh/docs/reference/kubectl/jsonpath/>JSONPath</a> - 通过 kubectl 使用
<a href=https://goessner.net/articles/JsonPath/>JSONPath 表达式</a> 的语法指南。</li>
</ul>
</li>
<li><a href=/zh/docs/reference/setup-tools/kubeadm/>kubeadm</a> - 此 CLI 工具可轻松配置安全的 Kubernetes 集群。</li>
</ul>
<h2 id=组件>组件</h2>
<ul>
<li>
<p><a href=/zh/docs/reference/command-line-tools-reference/kubelet/>kubelet</a> -
在每个节点上运行的主代理。kubelet 接收一组 PodSpecs 并确保其所描述的容器健康地运行。</p>
</li>
<li>
<p><a href=/zh/docs/reference/command-line-tools-reference/kube-apiserver/>kube-apiserver</a> -
REST API，用于验证和配置 API 对象（如 Pod、服务或副本控制器等）的数据。</p>
</li>
<li>
<p><a href=/zh/docs/reference/command-line-tools-reference/kube-controller-manager/>kube-controller-manager</a> -
一个守护进程，其中包含 Kubernetes 所附带的核心控制回路。</p>
</li>
<li>
<p><a href=/zh/docs/reference/command-line-tools-reference/kube-proxy/>kube-proxy</a> -
可进行简单的 TCP/UDP 流转发或针对一组后端执行轮流 TCP/UDP 转发。</p>
</li>
<li>
<p><a href=/zh/docs/reference/command-line-tools-reference/kube-scheduler/>kube-scheduler</a> -
一个调度程序，用于管理可用性、性能和容量。</p>
<ul>
<li><a href=/zh/docs/reference/scheduling/policies>调度策略</a></li>
<li><a href=/zh/docs/reference/scheduling/config#profiles>调度配置</a></li>
<li>应该在控制平面和工作节点上打开的 <a href=/zh/docs/reference/ports-and-protocols/>端口和协议</a> -
列表</li>
</ul>
</li>
</ul>
<h2 id=配置-api>配置 API</h2>
<p>本节包含用于配置 kubernetes 组件或工具的 "未发布" API 的文档。
尽管这些 API 对于用户或操作者使用或管理集群来说是必不可少的，
它们大都没有以 RESTful 的方式在 API 服务器上公开。</p>
<ul>
<li><a href=/zh/docs/reference/config-api/apiserver-config.v1alpha1/>kube-apiserver 配置 (v1alpha1)</a></li>
<li><a href=/zh/docs/reference/config-api/apiserver-config.v1/>kube-apiserver 配置 (v1)</a></li>
<li><a href=/zh/docs/reference/config-api/apiserver-encryption.v1/>kube-apiserver 加密 (v1)</a></li>
<li><a href=/zh/docs/reference/config-api/kubelet-config.v1alpha1/>kubelet 配置 (v1alpha1)</a> 和
<a href=/zh/docs/reference/config-api/kubelet-config.v1beta1/>kubelet 配置 (v1beta1)</a></li>
<li><a href=/zh/docs/reference/config-api/kubelet-credentialprovider.v1alpha1/>kubelet 凭据驱动 (v1alpha1)</a></li>
<li><a href=/zh/docs/reference/config-api/kube-scheduler-config.v1beta2/>kube-scheduler 配置 (v1beta2)</a> 和
<a href=/zh/docs/reference/config-api/kube-scheduler-config.v1beta3/>kube-scheduler 配置 (v1beta3)</a></li>
<li><a href=/zh/docs/reference/config-api/kube-proxy-config.v1alpha1/>kube-proxy 配置 (v1alpha1)</a></li>
<li><a href=/zh/docs/reference/config-api/apiserver-audit.v1/><code>audit.k8s.io/v1</code> API</a></li>
<li><a href=/zh/docs/reference/config-api/client-authentication.v1beta1/>客户端认证 API (v1beta1)</a> 和
<a href=/zh/docs/reference/config-api/client-authentication.v1/>客户端认证 API (v1)</a></li>
<li><a href=/zh/docs/reference/config-api/apiserver-webhookadmission.v1/>WebhookAdmission 配置 (v1)</a></li>
</ul>
<h2 id=kubeadm-的配置-api>kubeadm 的配置 API</h2>
<ul>
<li><a href=/zh/docs/reference/config-api/kubeadm-config.v1beta2/>v1beta2</a></li>
<li><a href=/zh/docs/reference/config-api/kubeadm-config.v1beta3/>v1beta3</a></li>
</ul>
<h2 id=设计文档>设计文档</h2>
<p>Kubernetes 功能的设计文档归档，不妨考虑从
<a href=https://git.k8s.io/community/contributors/design-proposals/architecture/architecture.md>Kubernetes 架构</a> 和
<a href=https://git.k8s.io/community/contributors/design-proposals>Kubernetes 设计概述</a>
开始阅读。</p>
</div>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-2b03679960950df772fb4fe7d78427b9>1 - 词汇表</h1>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-882c82a32bfb4d7946585a93a966b442>2 - API 概述</h1>
<p>本文提供了 Kubernetes API 的参考信息。</p>
<p>REST API 是 Kubernetes 的基本结构。
所有操作和组件之间的通信及外部用户命令都是调用 API 服务器处理的 REST API。
因此，Kubernetes 平台视一切皆为 API 对象，
且它们在 <a href=/docs/reference/generated/kubernetes-api/v1.23/>API</a> 中有相应的定义。</p>
<p><a href=/docs/reference/generated/kubernetes-api/v1.23/>Kubernetes API 参考</a>列
出了 Kubernetes v1.23 版本的 API。</p>
<p>如需了解一般背景信息，请查阅 <a href=/zh/docs/concepts/overview/kubernetes-api/>Kubernetes API</a>。
<a href=/zh/docs/concepts/security/controlling-access/>Kubernetes API 控制访问</a>描述了客户端如何
向 Kubernetes API 服务器进行身份认证以及他们的请求如何被鉴权。</p>
<h2 id=api-版本控制>API 版本控制</h2>
<p>JSON 和 Protobuf 序列化模式遵循相同的模式更改原则。
以下描述涵盖了这两种格式。</p>
<p>API 版本控制和软件版本控制是间接相关的。
<a href=https://git.k8s.io/community/contributors/design-proposals/release/versioning.md>API 和发布版本控制提案</a>
描述了 API 版本控制和软件版本控制间的关系。</p>
<p>不同的 API 版本代表着不同的稳定性和支持级别。
你可以在 <a href=https://git.k8s.io/community/contributors/devel/sig-architecture/api_changes.md#alpha-beta-and-stable-versions>API 变更文档</a>
中查看到更多的不同级别的判定标准。</p>
<p>下面是每个级别的摘要：</p>
<ul>
<li>Alpha:
<ul>
<li>版本名称包含 <code>alpha</code>（例如，<code>v1alpha1</code>）。</li>
<li>软件可能会有 Bug。启用某个特性可能会暴露出 Bug。
某些特性可能默认禁用。</li>
<li>对某个特性的支持可能会随时被删除，恕不另行通知。</li>
<li>API 可能在以后的软件版本中以不兼容的方式更改，恕不另行通知。</li>
<li>由于缺陷风险增加和缺乏长期支持，建议该软件仅用于短期测试集群。</li>
</ul>
</li>
</ul>
<ul>
<li>
<p>Beta:</p>
<ul>
<li>版本名称包含 <code>beta</code> （例如， <code>v2beta3</code>）。</li>
<li>软件被很好的测试过。启用某个特性被认为是安全的。
特性默认开启。</li>
<li>尽管一些特性会发生细节上的变化，但它们将会被长期支持。</li>
</ul>
<ul>
<li>在随后的 Beta 版或稳定版中，对象的模式和（或）语义可能以不兼容的方式改变。
当这种情况发生时，将提供迁移说明。
模式更改可能需要删除、编辑和重建 API 对象。
编辑过程可能并不简单。
对于依赖此功能的应用程序，可能需要停机迁移。</li>
<li>该版本的软件不建议生产使用。
后续发布版本可能会有不兼容的变动。
如果你有多个集群可以独立升级，可以放宽这一限制。</li>
</ul>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 请试用测试版特性时并提供反馈。特性完成 Beta 阶段测试后，
就可能不会有太多的变更了。
</div>
</li>
</ul>
<ul>
<li>Stable:
<ul>
<li>版本名称如 <code>vX</code>，其中 <code>X</code> 为整数。</li>
<li>特性的稳定版本会出现在后续很多版本的发布软件中。</li>
</ul>
</li>
</ul><!--## API groups-->
<h2 id=api-组>API 组</h2>
<p><a href=https://git.k8s.io/community/contributors/design-proposals/api-machinery/api-group.md>API 组</a>
能够简化对 Kubernetes API 的扩展。
API 组信息出现在REST 路径中，也出现在序列化对象的 <code>apiVersion</code> 字段中。</p>
<p>以下是 Kubernetes 中的几个组：</p>
<ul>
<li><em>核心</em>（也叫 <em>legacy</em>）组的 REST 路径为 <code>/api/v1</code>。
核心组并不作为 <code>apiVersion</code> 字段的一部分，例如， <code>apiVersion: v1</code>。</li>
<li>指定的组位于 REST 路径 <code>/apis/$GROUP_NAME/$VERSION</code>，
并且使用 <code>apiVersion: $GROUP_NAME/$VERSION</code> （例如， <code>apiVersion: batch/v1</code>）。
你可以在 <a href=/docs/reference/generated/kubernetes-api/v1.23/#-strong-api-groups-strong->Kubernetes API 参考文档</a>
中查看全部的 API 组。</li>
</ul>
<h2 id=enabling-or-disabling>启用或禁用 API 组 </h2>
<p>资源和 API 组是在默认情况下被启用的。
你可以通过在 API 服务器上设置 <code>--runtime-config</code> 参数来启用或禁用它们。
<code>--runtime-config</code> 参数接受逗号分隔的 <code>&lt;key>[=&lt;value>]</code> 对，
来描述 API 服务器的运行时配置。如果省略了 <code>=&lt;value></code> 部分，那么视其指定为 <code>=true</code>。
例如：</p>
<ul>
<li>禁用 <code>batch/v1</code>， 对应参数设置 <code>--runtime-config=batch/v1=false</code></li>
<li>启用 <code>batch/v2alpha1</code>， 对应参数设置 <code>--runtime-config=batch/v2alpha1</code></li>
</ul>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 启用或禁用组或资源时，
你需要重启 API 服务器和控制器管理器来使 <code>--runtime-config</code> 生效。
</div>
<h2 id=持久化>持久化</h2>
<p>Kubernetes 通过 API 资源来将序列化的状态写到 <a class=glossary-tooltip title="etcd 是兼具一致性和高可用性的键值数据库，用作保存 Kubernetes 所有集群数据的后台数据库。" data-toggle=tooltip data-placement=top href=/zh/docs/tasks/administer-cluster/configure-upgrade-etcd/ target=_blank aria-label=etcd>etcd</a> 中存储。</p>
<h2 id=what-s-next>What's next</h2>
<ul>
<li>进一步了解 <a href=https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#api-conventions>API 惯例</a></li>
<li>阅读 <a href=https://github.com/kubernetes/community/blob/master/contributors/design-proposals/api-machinery/aggregated-api-servers.md>聚合器</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-2b5428a2ff6f4831fd972ef50e12b3eb>2.1 - Kubernetes API 概念</h1>
<p>本页描述 Kubernetes API 的通用概念。</p>
<p>Kubernetes API 是基于资源的（RESTful）、通过 HTTP 提供的编程接口。
API 支持通过标准的 HTTP 动词（POST、PUT、PATCH、DELETE 和 GET）
检视、创建、更新和删除主要资源，为很多允许细粒度权限控制的对象提供子资源
（如将 Pod 绑定到节点上），并且出于便利性或效率考虑，支持并提供这些资源的
不同表示形式。
Kubernetes API 还通过 "watch" 和一致性的列表支持高效的资源变更通知，
从而允许其他组件对资源的状态进行高效的缓存和同步。</p>
<h2 id=standard-api-terminology>标准 API 术语 </h2>
<p>大多数 Kubernetes API 资源类型都是
<a href=/zh/docs/concepts/overview/working-with-objects/kubernetes-objects/#kubernetes-objects>对象</a>：
它们代表的是集群中某一概念的具体实例，例如一个 Pod 或名字空间。
为数不多的几个 API 资源类型是“虚拟的” - 它们通常代表的是操作而非对象本身，
例如访问权限检查（使用 POST 请求发送一个 JSON 编码的 <code>SubjectAccessReview</code>
负载到 <code>subjectaccessreviews</code> 资源）。
所有对象都有一个唯一的名字，以便支持幂等的创建和检视操作，不过如果虚拟资源类型
不可检视或者不要求幂等，可以不具有唯一的名字。</p>
<p>Kubernetes 一般会利用标准的 RESTful 术语来描述 API 概念：</p>
<ul>
<li><strong>资源类型（Resource Type）</strong> 是在 URL 中使用的名称（<code>pods</code>、<code>namespaces</code>、<code>services</code>）</li>
<li>所有资源类型都有具有一个 JSON 形式（其对象的模式定义）的具体表示，称作<strong>类别（Kind）</strong></li>
<li>某资源类型的实例的列表称作 <strong>集合（Collection）</strong></li>
<li>资源类型的单个实例被称作 <strong>资源（Resource）</strong></li>
</ul>
<p>所有资源类型要么是集群作用域的（<code>/apis/GROUP/VERSION/*</code>），要么是名字空间
作用域的（<code>/apis/GROUP/VERSION/namespaces/NAMESPACE/*</code>）。
名字空间作用域的资源类型会在其名字空间被删除时也被删除，并且对该资源类型的
访问是由定义在名字空间域中的授权检查来控制的。
下列路径用来检视集合和资源：</p>
<ul>
<li>集群作用域的资源：
<ul>
<li><code>GET /apis/GROUP/VERSION/RESOURCETYPE</code> - 返回指定资源类型的资源的集合</li>
<li><code>GET /apis/GROUP/VERSION/RESOURCETYPE/NAME</code> - 返回指定资源类型下名称为 NAME 的资源</li>
</ul>
</li>
<li>名字空间作用域的资源：
<ul>
<li><code>GET /apis/GROUP/VERSION/RESOURCETYPE</code> - 返回所有名字空间中指定资源类型的全部实例的集合</li>
<li><code>GET /apis/GROUP/VERSION/namespaces/NAMESPACE/RESOURCETYPE</code> - 返回名字空间 NAMESPACE 内给定资源类型的全部实例的集合</li>
<li><code>GET /apis/GROUP/VERSION/namespaces/NAMESPACE/RESOURCETYPE/NAME</code> - 返回名字空间 NAMESPACE 中给定资源类型的名称为 NAME 的实例</li>
</ul>
</li>
</ul>
<p>由于名字空间本身是一个集群作用域的资源类型，你可以通过 <code>GET /api/v1/namespaces/</code>
检视所有名字空间的列表，使用 <code>GET /api/v1/namespaces/NAME</code> 查看特定名字空间的
详细信息。</p>
<p>几乎所有对象资源类型都支持标准的 HTTP 动词 - GET、POST、PUT、PATCH 和 DELETE。
Kubernetes 使用术语 <strong>list</strong> 来描述返回资源集合的操作，以便与返回单个资源的、
通常称作 <strong>get</strong> 的操作相区分。</p>
<p>某些资源类型有一个或多个子资源（Sub-resource），表现为对应资源下面的子路径：</p>
<ul>
<li>集群作用域的子资源：<code>GET /apis/GROUP/VERSION/RESOURCETYPE/NAME/SUBRESOURCE</code></li>
<li>名字空间作用域的子资源：<code>GET /apis/GROUP/VERSION/namespaces/NAMESPACE/RESOURCETYPE/NAME/SUBRESOURCE</code></li>
</ul>
<p>取决于对象是什么，每个子资源所支持的动词有所不同 - 参见 API 文档以了解更多信息。
跨多个资源来访问其子资源是不可能的 - 如果需要这一能力，则通常意味着需要一种
新的虚拟资源类型了。</p>
<h2 id=efficient-detection-of-changes>高效检测变更 </h2>
<p>为了使客户端能够构造一个模型来表达集群的当前状态，所有 Kubernetes 对象资源类型
都需要支持一致的列表和一个称作 <strong>watch</strong> 的增量变更通知信源（feed）。
每个 Kubernetes 对象都有一个 <code>resourceVersion</code> 字段，代表该资源在下层数据库中
存储的版本。检视资源集合（名字空间作用域或集群作用域）时，服务器返回的响应
中会包含 <code>resourceVersion</code> 值，可用来向服务器发起 watch 请求。
服务器会返回所提供的 <code>resourceVersion</code> 之后发生的所有变更（创建、删除和更新）。
这使得客户端能够取回当前的状态并监视其变更，且不会错过任何变更事件。
客户端的监视连接被断开时，可以从最后返回的 <code>resourceVersion</code> 重启新的监视连接，
或者执行一个新的集合请求之后从头开始监视操作。
参阅<a href=#resource-versions>资源版本语义</a>以了解更多细节。</p>
<p>例如：</p>
<ol>
<li>
<p>列举给定名字空间中的所有 Pods：</p>
<pre><code class=language-console data-lang=console>GET /api/v1/namespaces/test/pods
---
200 OK
Content-Type: application/json
{
  &quot;kind&quot;: &quot;PodList&quot;,
  &quot;apiVersion&quot;: &quot;v1&quot;,
  &quot;metadata&quot;: {&quot;resourceVersion&quot;:&quot;10245&quot;},
  &quot;items&quot;: [...]
}
</code></pre></li>
</ol>
<ol start=2>
<li>
<p>从资源版本 10245 开始，以 JSON 对象的形式接收所有创建、删除或更新操作的通知：</p>
<pre><code class=language-console data-lang=console>GET /api/v1/namespaces/test/pods?watch=1&amp;resourceVersion=10245
---
200 OK
Transfer-Encoding: chunked
Content-Type: application/json

{
  &quot;type&quot;: &quot;ADDED&quot;,
  &quot;object&quot;: {&quot;kind&quot;: &quot;Pod&quot;, &quot;apiVersion&quot;: &quot;v1&quot;, &quot;metadata&quot;: {&quot;resourceVersion&quot;: &quot;10596&quot;, ...}, ...}
}
{
  &quot;type&quot;: &quot;MODIFIED&quot;,
  &quot;object&quot;: {&quot;kind&quot;: &quot;Pod&quot;, &quot;apiVersion&quot;: &quot;v1&quot;, &quot;metadata&quot;: {&quot;resourceVersion&quot;: &quot;11020&quot;, ...}, ...}
}
...
</code></pre></li>
</ol>
<p>给定的 Kubernetes 服务器只会保留一定的时间内发生的历史变更列表。
使用 etcd3 的集群默认保存过去 5 分钟内发生的变更。
当所请求的 watch 操作因为资源的历史版本不存在而失败，客户端必须能够处理
因此而返回的状态代码 <code>410 Gone</code>，清空其本地的缓存，重新执行 list 操作，
并基于新的 list 操作所返回的 <code>resourceVersion</code> 来开始新的 watch 操作。
大多数客户端库都能够提供某种形式的、包含此逻辑的工具。
（在 Go 语言客户端库中，这一设施称作 <code>Reflector</code>，位于
<code>k8s.io/client-go/cache</code> 包中。)</p>
<h3 id=Watch-bookmark>监视书签 </h3>
<p>为了处理历史窗口过短的问题，我们引入了 <code>bookmark（书签）</code> 监视事件的概念。
该事件是一种特殊事件，用来标示客户端所请求的、指定的 <code>resourceVersion</code> 之前
的所有变更都以被发送。该事件中返回的对象是所请求的资源类型，但其中仅包含
<code>resourceVersion</code> 字段，例如：</p>
<pre><code class=language-console data-lang=console>GET /api/v1/namespaces/test/pods?watch=1&amp;resourceVersion=10245&amp;allowWatchBookmarks=true
---
200 OK
Transfer-Encoding: chunked
Content-Type: application/json

{
  &quot;type&quot;: &quot;ADDED&quot;,
  &quot;object&quot;: {&quot;kind&quot;: &quot;Pod&quot;, &quot;apiVersion&quot;: &quot;v1&quot;, &quot;metadata&quot;: {&quot;resourceVersion&quot;: &quot;10596&quot;, ...}, ...}
}
...
{
  &quot;type&quot;: &quot;BOOKMARK&quot;,
  &quot;object&quot;: {&quot;kind&quot;: &quot;Pod&quot;, &quot;apiVersion&quot;: &quot;v1&quot;, &quot;metadata&quot;: {&quot;resourceVersion&quot;: &quot;12746&quot;} }
}
</code></pre>
<p>通过在 watch 请求中设置 <code>allowWatchBookmarks=true</code> 选项，可以请求 <code>bookmark</code>
事件，但是客户端不能假定服务器端会按某特定时间间隔返回书签事件，甚至也不能
假定服务器一定会发送 <code>bookmark</code> 事件。</p>
<h2 id=retrieving-large-results-sets-in-chunks>分块检视大体量结果 </h2>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.9 [beta]</code>
</div>
<p>在较大规模的集群中，检视某些资源类型的集合时可能会返回较大体量的响应数据，对
服务器和客户端都会造成影响。例如，某集群可能包含数万个 Pod，每个 Pod 的 JSON
编码都有 1-2 KB 的大小。返回所有名字空间的全部 Pod 时，其结果可能体量很大
（10-20 MB）且耗用大量的服务器资源。
从 Kubernetes 1.9 开始，服务器支持将单一的大体量集合请求分解成多个小数据块
同时还保证整个请求的一致性的能力。
各个数据块可以按顺序返回，进而降低请求的尺寸，允许面向用户的客户端以增量形式
呈现返回结果，改进系统响应效果。</p>
<p>为了用分块的形式返回一个列表，集合请求上可以设置两个新的参数 <code>limit</code> 和
<code>continue</code>，并且所有 list 操作的返回结果列表的 <code>metadata</code> 字段中会包含一个
新的 <code>continue</code> 字段。
客户端应该将 <code>limit</code> 设置为希望在每个数据块中收到的结果个数上限，而服务器则
会在结果中至多返回 <code>limit</code> 个资源并在集合中还有更多资源的时候包含一个
<code>continue</code> 值。客户端在下次请求时则可以将此 <code>continue</code> 值传递给服务器，
告知后者要从何处开始返回结果的下一个数据块。
通过重复这一操作直到服务器端返回空的 <code>continue</code> 值，客户端可以受到结果的
全集。</p>
<p>与 watch 操作类似，<code>continue</code> 令牌也会在很短的时间（默认为 5 分钟）内过期，
并在无法返回更多结果时返回 <code>410 Gone</code> 代码。
这时，客户端需要从头开始执行上述检视操作或者忽略 <code>limit</code> 参数。</p>
<p>例如，如果集群上有 1253 个 Pods，客户端希望每次收到包含至多 500 个 Pod 的
数据块，它应按下面的步骤来请求数据块：</p>
<ol>
<li>列举集群中所有 Pod，每次接收至多 500 个 Pods：</li>
</ol>
<pre><code class=language-console data-lang=console>GET /api/v1/pods?limit=500
---
200 OK
Content-Type: application/json

{
  &quot;kind&quot;: &quot;PodList&quot;,
  &quot;apiVersion&quot;: &quot;v1&quot;,
  &quot;metadata&quot;: {
    &quot;resourceVersion&quot;:&quot;10245&quot;,
    &quot;continue&quot;: &quot;ENCODED_CONTINUE_TOKEN&quot;,
    ...
  },
  &quot;items&quot;: [...] // returns pods 1-500
}
</code></pre>
<ol start=2>
<li>继续前面的调用，返回下一组 500 个 Pods：</li>
</ol>
<pre><code class=language-console data-lang=console>GET /api/v1/pods?limit=500&amp;continue=ENCODED_CONTINUE_TOKEN
---
200 OK
Content-Type: application/json

{
  &quot;kind&quot;: &quot;PodList&quot;,
  &quot;apiVersion&quot;: &quot;v1&quot;,
  &quot;metadata&quot;: {
    &quot;resourceVersion&quot;:&quot;10245&quot;,
    &quot;continue&quot;: &quot;ENCODED_CONTINUE_TOKEN_2&quot;,
    ...
  },
  &quot;items&quot;: [...] // returns pods 501-1000
}
</code></pre>
<ol start=3>
<li>继续前面的调用，返回最后 253 个 Pods：</li>
</ol>
<pre><code class=language-console data-lang=console>GET /api/v1/pods?limit=500&amp;continue=ENCODED_CONTINUE_TOKEN_2
---
200 OK
Content-Type: application/json

{
  &quot;kind&quot;: &quot;PodList&quot;,
  &quot;apiVersion&quot;: &quot;v1&quot;,
  &quot;metadata&quot;: {
    &quot;resourceVersion&quot;:&quot;10245&quot;,
    &quot;continue&quot;: &quot;&quot;, // continue token is empty because we have reached the end of the list
    ...
  },
  &quot;items&quot;: [...] // returns pods 1001-1253
}
</code></pre>
<p>注意 list 操作的 <code>resourceVersion</code> 在每个请求中都设置的是同一个数值，
这表明服务器要向我们展示一个一致的 Pods 快照视图。
在版本 <code>10245</code> 之后创建、更新或删除的 Pods 都不会显示出来，除非用户发出
list 请求时不指定 <code>continue</code> 令牌。
这一设计使得客户端能够将较大的响应切分为较小的数据块，且能够对较大的集合
执行监视动作而不会错失任何更新事件。</p>
<h2 id=receiving-resources-as-tables>以表格形式接收资源 </h2>
<p><code>kubectl get</code> 命令的输出是一个包含一个或多个资源的简单表格形式。
过去，客户端需要重复 <code>kubectl</code> 中所实现的表格输出和描述输出逻辑，以执行
简单的对象列表操作。
这一方法在处理某些对象时，需要引入不容忽视的逻辑。
此外，<a href=/zh/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/>API 聚合</a>
和<a href=/zh/docs/concepts/extend-kubernetes/api-extension/custom-resources/>定制资源</a>
所提供的资源类型都是编译时不可预知的。这意味着，客户端必须针对无法
识别的类型提供通用的实现逻辑。</p>
<p>为了避免上述各种潜在的局限性，客户端可以请求服务器端返回对象的表格（Table）
表现形式，从而将打印输出的特定细节委托给服务器。
Kubernetes API 实现标准的 HTTP 内容类型（Content Type）协商：为 <code>GET</code> 调用
传入一个值为 <code>application/json;as=Table;g=meta.k8s.io;v=v1beta1</code> 的 <code>Accept</code>
头部即可请求服务器以 Table 的内容类型返回对象。</p>
<p>例如，以 Table 格式列举集群中所有 Pods：</p>
<pre><code class=language-console data-lang=console>GET /api/v1/pods
Accept: application/json;as=Table;g=meta.k8s.io;v=v1beta1
---
200 OK
Content-Type: application/json

{
    &quot;kind&quot;: &quot;Table&quot;,
    &quot;apiVersion&quot;: &quot;meta.k8s.io/v1beta1&quot;,
    ...
    &quot;columnDefinitions&quot;: [
        ...
    ]
}
</code></pre>
<p>对于在服务器上不存在定制的 Table 定义的 API 资源类型而言，服务器会返回
一个默认的 Table 响应，其中包含资源的 <code>name</code> 和 <code>creationTimestamp</code> 字段。</p>
<pre><code class=language-console data-lang=console>GET /apis/crd.example.com/v1alpha1/namespaces/default/resources
---
200 OK
Content-Type: application/json
...

{
    &quot;kind&quot;: &quot;Table&quot;,
    &quot;apiVersion&quot;: &quot;meta.k8s.io/v1beta1&quot;,
    ...
    &quot;columnDefinitions&quot;: [
        {
            &quot;name&quot;: &quot;Name&quot;,
            &quot;type&quot;: &quot;string&quot;,
            ...
        },
        {
            &quot;name&quot;: &quot;Created At&quot;,
            &quot;type&quot;: &quot;date&quot;,
            ...
        }
    ]
}
</code></pre>
<p><code>kube-apiserver</code> 从 1.10 版本开始提供 Table 响应。
因此，并非所有 API 资源类型都支持 Table 响应，尤其是使用客户端访问较老的集群时。
如果客户端需要能够处理所有资源类型，或者有可能需要与较老的集群交互，
则需要在其 <code>Accept</code> 头部设定多个内容类型值，以便可以回退到非表格形式的 JSON
表示。</p>
<pre><code>Accept: application/json;as=Table;g=meta.k8s.io;v=v1beta1, application/json
</code></pre>
<h2 id=alternate-representations-of-resources>资源的其他表示形式 </h2>
<p>默认情况下，Kubernetes 返回 JSON 序列化的的对象并设定内容类型为
<code>application/json</code>。这是 API 的默认序列化格式。
不过，客户端也可出于大规模环境中更佳性能的需求而请求对象的更为高效的 Protobuf
表现形式。
Kubernetes API 实现了标准的 HTTP 内容类型协商：为 <code>GET</code> 调用传递一个 <code>Accept</code>
头部来请求服务器以所指定的内容类型返回对象，同时在通过 <code>PUT</code> 或 <code>POST</code> 调用
向服务器发送 Protobuf 格式的对象时提供 <code>Content-Type</code> 头部。
服务器会能够支持所请求的格式时返回 <code>Content-Type</code> 头部，并在所提供的内容类型
不合法时返回 <code>406 Not acceptable（无法接受）</code> 错误。</p>
<p>请参阅 API 文档了解每个 API 所支持的内容类型。</p>
<p>例如：</p>
<ol>
<li>以 Protobuf 格式列举集群上的所有 Pods：</li>
</ol>
<pre><code class=language-console data-lang=console>GET /api/v1/pods
Accept: application/vnd.kubernetes.protobuf
---
200 OK
Content-Type: application/vnd.kubernetes.protobuf

... binary encoded PodList object
</code></pre>
<ol start=2>
<li>通过向服务器发送 Protobuf 编码的数据创建 Pod，但请求以 JSON 形式接收响应：</li>
</ol>
<pre><code class=language-console data-lang=console>POST /api/v1/namespaces/test/pods
Content-Type: application/vnd.kubernetes.protobuf
Accept: application/json
... binary encoded Pod object
---
200 OK
Content-Type: application/json

{
  &quot;kind&quot;: &quot;Pod&quot;,
  &quot;apiVersion&quot;: &quot;v1&quot;,
  ...
}
</code></pre>
<p>并非所有 API 资源类型都支持 Protobuf，尤其是那些通过定制资源定义（CRD）或通过
API 扩展而加入的资源。如果客户端必须能够处理所有资源类型，则应在其 <code>Accept</code>
头部指定多种内容类型以便可以回退到 JSON 格式：</p>
<pre><code class=language-console data-lang=console>Accept: application/vnd.kubernetes.protobuf, application/json
</code></pre>
<h3 id=protobuf-encoding>Protobuf encoding</h3>
<p>Kubernetes 使用封套形式来对 Protobuf 响应进行编码。
封套外层由 4 个字节的特殊数字开头，便于从磁盘文件或 etcd 中辩识 Protobuf
格式的（而不是 JSON）数据。
接下来存放的是 Protobuf 编码的封套消息，其中描述下层对象的编码和类型，最后
才是对象本身。</p>
<p>封套格式如下：</p>
<pre><code class=language-console data-lang=console>四个字节的特殊数字前缀：
  字节 0-3: &quot;k8s\x00&quot; [0x6b, 0x38, 0x73, 0x00]

使用下面 IDL 来编码的 Protobuf 消息：
  message Unknown {
    // typeMeta 应该包含 &quot;kind&quot; 和 &quot;apiVersion&quot; 的字符串值，就像
    // 对应的 JSON 对象中所设置的那样
    optional TypeMeta typeMeta = 1;

    // raw 中将保存用 protobuf 序列化的完整对象。
    // 参阅客户端库中为指定 kind 所作的 protobuf 定义
    optional bytes raw = 2;

    // contentEncoding 用于 raw 数据的编码格式。未设置此值意味着没有特殊编码。
    optional string contentEncoding = 3;

    // contentType 包含 raw 数据所采用的序列化方法。
    // 未设置此值意味着  application/vnd.kubernetes.protobuf，且通常被忽略
    optional string contentType = 4;
  }

  message TypeMeta {
    // apiVersion 是 type 对应的组名/版本
    optional string apiVersion = 1;
    // kind 是对象模式定义的名称。此对象应该存在一个 protobuf 定义。
    optional string kind = 2;
  }
</code></pre>
<p>收到 <code>application/vnd.kubernetes.protobuf</code> 格式响应的客户端在响应与预期的前缀
不匹配时应该拒绝响应，因为将来的版本可能需要以某种不兼容的方式更改序列化格式，
并且这种更改是通过变更前缀完成的。</p>
<h2 id=resource-deletion>资源删除 </h2>
<p>资源删除要经过两个阶段：1) 终止（finalization），和 2）去除。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;ConfigMap&#34;</span>,
  <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;v1&#34;</span>,
  <span style=color:green;font-weight:700>&#34;metadata&#34;</span>: {
    <span style=color:green;font-weight:700>&#34;finalizers&#34;</span>: {<span style=color:green;font-weight:700>&#34;url.io/neat-finalization&#34;</span>, <span style=color:green;font-weight:700>&#34;other-url.io/my-finalizer&#34;</span>},
    <span style=color:green;font-weight:700>&#34;deletionTimestamp&#34;</span>: <span>nil</span>,
  }
}
</code></pre></div>
<p>当客户端首先删除某资源时，其 <code>.metadata.deletionTimestamp</code> 会被设置为当前时间。
一旦 <code>.metadata.deletionTimestamp</code> 被设置，则对终结器（finalizers）执行动作
的外部控制器就可以在任何时候、以任何顺序执行其清理工作。
这里不强调顺序是因为很可能带来 <code>.metadata.finalizers</code> 被锁定的风险。
<code>.metadata.finalizers</code> 是一个共享的字段，任何具有相关权限的主体都可以对其
执行重排序的操作。如果终结器列表要按顺序处理，则很可能导致负责列表中第一个
终结器的组件要等待负责列表中排序靠后的终结器的组件的信号（可能是字段值变更、
外部系统或者其他形式），从而导致死锁行为。
在不对终结器顺序作强制要求的情况下，终结器可以自行排序，且不会因为其在列表
中的顺序而引入任何不稳定因素。</p>
<p>当最后一个终结器也被移除时，资源才真正从 etcd 中移除。</p>
<h2 id=single-resource-api>单个资源 API </h2>
<p>API 动词 GET、CREATE、UPDATE、PATCH、DELETE 和 PROXY 仅支持单个资源。
这些支持单一资源的动词不支持以有序或无序列表甚或事务的形式同时提交给
多个资源。
包括 kubectl 在内的客户端将解析资源的列表，并执行单一资源的 API 请求。</p>
<p>API 动词 LIST 和 WATCH 支持获取多个资源，而 DELETECOLLECTION 支持删除多个
资源。</p>
<h2 id=dry-run>试运行 </h2>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.18 [stable]</code>
</div>
<p>修改性质的动词（<code>POST</code>、<code>PUT</code>、<code>PATCH</code> 和 <code>DELETE</code>）可以支持 <em>试运行（dry
run）</em> 模式的请求。试运行模式可帮助通过典型的请求阶段（准入控制链、合法性
检查、合并冲突）来评估请求，只是最终的对象不会写入存储。请求的响应主体与
非试运行模式下的响应尽可能接近。系统会保证试运行模式的请求不会被写入到存储
中，也不会产生其他副作用。</p>
<h3 id=make-a-dry-run-request>发起试运行请求 </h3>
<p>通过设置 <code>dryRun</code> 查询参数可以触发试运行模式。此参数是一个字符串，以枚举值
的形式工作且可接受的值只有：</p>
<ul>
<li>
<p><code>All</code>：每个阶段被会正常运行，除了最后的存储阶段。准入控制器会被运行来检查请求
是否合法，变更性（Mutating）控制器会变更请求，<code>PATCH</code> 请求也会触发合并操作，
对象字段的默认值也会被设置，且基于模式定义的合法性检查也会被执行。
所生成的变更不会被写入到下层的持久性存储中，但本来会写入到数据库中的最终对象
会和正常的状态代码一起被返回给用户。如果请求会触发准入控制器而该准入控制器
带有一定的副作用，则请求会失败而不是冒险产生不希望的副作用。
所有的内置准入控制器插件都支持试运行模式。此外，准入控制 Webhook 也可在其
<a href=/docs/reference/generated/kubernetes-api/v1.23/#webhook-v1beta1-admissionregistration-k8s-io>配置对象</a>
中通过将 <code>sideEffects</code> 字段设置为 "None" 来声明自身不会产生副作用。
如果某 Webhook 确实会产生副作用，那么 <code>sideEffects</code> 字段应该设置为 "NoneOnDryRun"，
并且 Webhook 应该被更改以支持 AdmissionReview 中的 <code>dryRun</code> 字段，从而避免
在试运行时产生副作用。</p>
</li>
<li>
<p>空字符串（也即默认值）：保留默认的修改行为。</p>
</li>
</ul>
<p>例如：</p>
<pre><code class=language-console data-lang=console>POST /api/v1/namespaces/test/pods?dryRun=All
Content-Type: application/json
Accept: application/json
</code></pre>
<p>响应会与非试运行模式请求的响应看起来相同，只是某些生成字段的值可能会不同。</p>
<h3 id=dry-run-authorization>试运行的授权 </h3>
<p>试运行和非试运行请求的鉴权是完全相同的。因此，要发起一个试运行请求，用户必须
被授权执行非试运行请求。</p>
<p>例如，要在 Deployment 对象上试运行 <code>PATCH</code> 操作，你必须具有对 Deployment 执行
<code>PATCH</code> 操作的访问权限，如下面的 RBAC 规则所示：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;extensions&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;apps&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;deployments&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;patch&#34;</span>]<span style=color:#bbb>
</span></code></pre></div>
<p>参阅<a href=/zh/docs/reference/access-authn-authz/authorization/>鉴权概述</a>以了解鉴权细节。</p>
<h3 id=generated-values>生成的值 </h3>
<p>对象的某些值通常是在对象被写入数据库之前生成的。很重要的一点是不要依赖试运行
请求为这些字段所设置的值，因为试运行模式下所得到的这些值与真实请求所获得的
值很可能不同。这类字段有：</p>
<ul>
<li><code>name</code>：如果设置了 <code>generateName</code> 字段，则 <code>name</code> 会获得一个唯一的随机名称</li>
<li><code>creationTimestamp</code>/<code>deletionTimestamp</code>：记录对象的创建/删除时间</li>
<li><code>UID</code>：唯一性标识对象，取值随机生成（非确定性）</li>
<li><code>resourceVersion</code>： 跟踪对象的持久化（存储）版本</li>
<li>变更性准入控制器所设置的字段</li>
<li>对于 <code>Service</code> 资源：<code>kube-apiserver</code> 为 <code>v1.Service</code> 对象分配的端口和 IP</li>
</ul>
<h2 id=server-side-apply>服务器端应用 </h2>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.16 [beta]</code>
</div>
<p>从 Kubernetes v1.18 开始，可以启用<a href=/zh/docs/reference/using-api/server-side-apply/>服务器端应用</a>功能
特性，启用该特性后，控制面会跟踪所有新创建的对象的托管字段。服务器端应用提供了一种简洁的模式来管理字段冲突，提供服务器端的 <code>Apply</code> 和 <code>Update</code> 操作，并取代了
<code>kubectl apply</code> 的客户端功能。有关该特性的详细描述，请参见<a href=/zh/docs/reference/using-api/server-side-apply/>服务器端应用</a>章节</p>
<h2 id=resource-versions>资源版本 </h2>
<p>资源版本采用字符串来表达，用来标示对象的服务器端内部版本。
客户端可以使用资源版本来判定对象是否被更改，或者在读取、列举或监视资源时
用来表达数据一致性需求。
客户端必需将资源版本视为不透明的对象，将其原封不动地传递回服务器端。
例如，客户端一定不能假定资源版本是某种数值标识，也不可以对两个资源版本值
进行比较看其是否相同（也就是不可以比较两个版本值以判断其中一个比另一个
大或小）。</p>
<h3 id=resourceVersion-in-metadata><code>metadata</code> 中的 <code>resourceVersion</code> </h3>
<p>客户端可以在资源中看到资源版本信息，这里的资源包括从服务器返回的 Watch 事件
以及 list 操作响应：</p>
<p><a href=/docs/reference/generated/kubernetes-api/v1.23/#objectmeta-v1-meta>v1.meta/ObjectMeta</a> - 资源
的 <code>metadata.resourceVersion</code> 值标明该实例上次被更改时的资源版本。</p>
<p><a href=/docs/reference/generated/kubernetes-api/v1.23/#listmeta-v1-meta>v1.meta/ListMeta</a> - 资源集合
（即 list 操作的响应）的 <code>metadata.resourceVersion</code> 所标明的是 list 响应被构造
时的资源版本。</p>
<h3 id=the-resourceversion-parameter><code>resourceVersion</code> 参数 </h3>
<p>GET、LIST 和 WATCH 操作都支持 <code>resourceVersion</code> 参数。</p>
<p>参数的具体含义取决于所执行的操作和所给的 <code>resourceVersion</code> 值：</p>
<p>对于 GET 和 LIST 而言，资源版本的语义为：</p>
<p><strong>GET：</strong></p>
<table>
<thead>
<tr>
<th>resourceVersion 未设置</th>
<th>resourceVersion="0"</th>
<th>resourceVersion="&lt;非零值>"</th>
</tr>
</thead>
<tbody>
<tr>
<td>最新版本</td>
<td>任何版本</td>
<td>不老于给定版本</td>
</tr>
</tbody>
</table>
<p><strong>LIST：</strong></p>
<p>v1.19 及以上版本的 API 服务器支持 <code>resourceVersionMatch</code> 参数，用以确定如何对
LIST 调用应用 resourceVersion 值。
强烈建议在为 LIST 调用设置了 <code>resourceVersion</code> 时也设置 <code>resourceVersionMatch</code>。
如果 <code>resourceVersion</code> 未设置，则 <code>resourceVersionMatch</code> 是不允许设置的。
为了向后兼容，客户端必须能够容忍服务器在某些场景下忽略 <code>resourceVersionMatch</code> 的行为：</p>
<ul>
<li>
<p>当设置 <code>resourceVersionMatch=NotOlderThan</code> 且指定了 <code>limit</code> 时，客户端必须能够
处理 HTTP 410 "Gone" 响应。例如，客户端可以使用更新一点的 <code>resourceVersion</code>
来重试，或者回退到 <code>resourceVersion=""</code> （即允许返回任何版本）。</p>
</li>
<li>
<p>当设置了 <code>resourceVersionMatch=Exact</code> 且未指定 <code>limit</code> 时，客户端必须验证
响应数据中 <code>ListMeta</code> 的 <code>resourceVersion</code> 与所请求的 <code>resourceVersion</code> 匹配，
并处理二者可能不匹配的情况。例如，客户端可以重试设置了 <code>limit</code> 的请求。</p>
</li>
</ul>
<p>除非你对一致性有着非常强烈的需求，使用 <code>resourceVersionMatch=NotOlderThan</code>
同时为 <code>resourceVersion</code> 设定一个已知值是优选的交互方式，因为与不设置
<code>resourceVersion</code> 和 <code>resourceVersionMatch</code> 相比，这种配置可以取得更好的
集群性能和可扩缩性。后者需要提供带票选能力的读操作。</p>
<table><caption style=display:none>list 操作的 resourceVersionMatch 与分页参数</caption>
<thead>
<tr>
<th>resourceVersionMatch 参数</th>
<th>分页参数</th>
<th>resourceVersion 未设置</th>
<th>resourceVersion="0"</th>
<th>resourceVersion="&lt;非零值>"</th>
</tr>
</thead>
<tbody>
<tr>
<td>resourceVersionMatch 未设置</td>
<td>limit 未设置</td>
<td>最新版本</td>
<td>任意版本</td>
<td>不老于指定版本</td>
</tr>
<tr>
<td>resourceVersionMatch 未设置</td>
<td>limit=&lt;n>, continue 未设置</td>
<td>最新版本</td>
<td>任意版本</td>
<td>精确匹配</td>
</tr>
<tr>
<td>resourceVersionMatch 未设置</td>
<td>limit=&lt;n>, continue=&lt;token></td>
<td>从 token 开始、精确匹配</td>
<td>非法请求，视为从 token 开始、精确匹配</td>
<td>非法请求，返回 HTTP <code>400 Bad Request</code></td>
</tr>
<tr>
<td>resourceVersionMatch=Exact [1]</td>
<td>limit 未设置</td>
<td>非法请求</td>
<td>非法请求</td>
<td>精确匹配</td>
</tr>
<tr>
<td>resourceVersionMatch=Exact [1]</td>
<td>limit=&lt;n>, continue 未设置</td>
<td>非法请求</td>
<td>非法请求</td>
<td>精确匹配</td>
</tr>
<tr>
<td>resourceVersionMatch=NotOlderThan [1]</td>
<td>limit 未设置</td>
<td>非法请求</td>
<td>任意版本</td>
<td>不老于指定版本</td>
</tr>
<tr>
<td>resourceVersionMatch=NotOlderThan [1]</td>
<td>limit=&lt;n>, continue 未设置</td>
<td>非法请求</td>
<td>任意版本</td>
<td>不老于指定版本</td>
</tr>
</tbody>
</table>
<p><strong>脚注：</strong></p>
<p>[1] 如果服务器无法正确处理 <code>resourceVersionMatch</code> 参数，其行为与未设置该参数相同。
</small></p>
<p>GET 和 LIST 操作的语义含义如下：</p>
<ul>
<li><strong>最新版本：</strong> 返回资源版本为最新的数据。所返回的数据必须一致
（通过票选读操作从 etcd 中取出）。</li>
<li><strong>任意版本：</strong> 返回任意资源版本的数据。优选最新可用的资源版本，不过不能保证
强一致性；返回的数据可能是任何资源版本的。请求返回的数据有可能是客户端以前
看到过的很老的资源版本。尤其在某些高可用配置环境中，网络分区或者高速缓存
未被更新等状态都可能导致这种状况。不能容忍这种不一致性的客户端不应采用此
语义。</li>
</ul>
<ul>
<li>
<p><strong>不老于指定版本：</strong> 返回至少比所提供的 <code>resourceVersion</code> 还要新的数据。
优选最新的可用数据，不过最终提供的可能是不老于所给 <code>resourceVersion</code> 的任何版本。
对于发给能够正确处理 <code>resourceVersionMatch</code> 参数的服务器的 LIST 请求，此语义
保证 <code>ListMeta</code> 中的 <code>resourceVersion</code> 不老于请求的 <code>resourceVersion</code>，不过
不对列表条目之 <code>ObjectMeta</code> 的 <code>resourceVersion</code> 提供任何保证。
这是因为 <code>ObjectMeta.resourceVersion</code> 所跟踪的是列表条目对象上次更新的时间，
而不是对象被返回时是否是最新。</p>
</li>
<li>
<p><strong>确定版本：</strong> 返回精确匹配所给资源版本的数据。如果所指定的 resourceVersion
的数据不可用，服务器会响应 HTTP 410 "Gone"。
对于发送给能够正确处理 <code>resourceVersionMatch</code> 参数的服务器的 LIST 请求而言，
此语义会保证 ListMeta 中的 <code>resourceVersion</code> 与所请求的 <code>resourceVersion</code>
匹配， 不过不对列表条目之 <code>ObjectMeta</code> 的 <code>resourceVersion</code> 提供任何保证。
这是因为 <code>ObjectMeta.resourceVersion</code> 所跟踪的是列表条目对象上次更新的时间，
而不是对象被返回时是否是最新。</p>
</li>
<li>
<p><strong>Continue 令牌、精确匹配：</strong> 返回原先带分页参数的 LIST 调用中指定的资源版本的数据。
在最初的带分页参数的 LIST 调用之后，所有分页式的 LIST 调用都使用所返回的 Continue
令牌来跟踪最初提供的资源版本，</p>
</li>
</ul>
<p>对于 WATCH 操作而言，资源版本的语义如下：</p>
<p><strong>WATCH：</strong></p>
<table><caption style=display:none>watch 操作的 resourceVersion 设置</caption>
<thead>
<tr>
<th>resourceVersion 未设置</th>
<th>resourceVersion="0"</th>
<th>resourceVersion="&lt;非零值>"</th>
</tr>
</thead>
<tbody>
<tr>
<td>读取状态并从最新版本开始</td>
<td>读取状态并从任意版本开始</td>
<td>从指定版本开始</td>
</tr>
</tbody>
</table>
<p>WATCH 操作语义的含义如下：</p>
<ul>
<li><strong>读取状态并从最新版本开始：</strong> 从最新的资源版本开始 WATCH 操作。这里的
最新版本必须是一致的（即通过票选读操作从 etcd 中取出）。为了建立初始状态，
WATCH 首先会处理一组合成的 "Added" 事件，这些事件涵盖在初始资源版本中存在
的所有资源实例。
所有后续的 WATCH 事件都是关于 WATCH 开始时所处资源版本之后发生的变更。</li>
</ul>
<ul>
<li><strong>读取状态并从任意版本开始：</strong> 警告：通过这种方式初始化的 WATCH 操作可能会
返回任何状态的停滞数据。请在使用此语义之前执行复核，并在可能的情况下采用其他
语义。此语义会从任意资源版本开始执行 WATCH 操作，优选最新的可用的资源版本，
不过不是必须的；采用任何资源版本作为起始版本都是被允许的。
WATCH 操作有可能起始于客户端已经观测到的很老的版本。在高可用配置环境中，因为
网络分裂或者高速缓存未及时更新的原因都会造成此现象。
如果客户端不能容忍这种不一致性，就不要使用此语义来启动 WATCH 操作。
为了建立初始状态，WATCH 首先会处理一组合成的 "Added" 事件，这些事件涵盖在
初始资源版本中存在的所有资源实例。
所有后续的 WATCH 事件都是关于 WATCH 开始时所处资源版本之后发生的变更。</li>
</ul>
<ul>
<li><strong>从指定版本开始：</strong> 从某确切资源版本开始执行 WATCH 操作。WATCH 事件都是
关于 WATCH 开始时所处资源版本之后发生的变更。与前面两种语义不同，WATCH 操作
开始的时候不会生成或处理为所提供资源版本合成的 "Added" 事件。
我们假定客户端既然能够提供确切资源版本，就应该已经拥有了起始资源版本对应的初始状态。</li>
</ul>
<h3 id=410-gone-responses>"410 Gone" 响应 </h3>
<p>服务器不需要提供所有老的资源版本，在客户端请求的是早于服务器端所保留版本的
<code>resourceVersion</code> 时，可以返回 HTTP <code>410 (Gone)</code> 状态码。
客户端必须能够容忍 <code>410 (Gone)</code> 响应。
参阅<a href=#efficient-detection-of-changes>高效检测变更</a>以了解如何在监测资源时
处理 <code>410 (Gone)</code> 响应。</p>
<p>如果所请求的 <code>resourceVersion</code> 超出了可应用的 <code>limit</code>，那么取决于请求是否
是通过高速缓存来满足的，API 服务器可能会返回一个 <code>410 Gone</code> HTTP 响应。</p>
<h3 id=unavailable-resource-versions>不可用的资源版本 </h3>
<p>服务器不必未无法识别的资源版本提供服务。针对无法识别的资源版本的 LIST 和 GET 请求
可能会短暂等待，以期资源版本可用。如果所给的资源版本在一定的时间段内仍未变得
可用，服务器应该超时并返回 <code>504 (Gateway Timeout)</code>，且可在响应中添加
<code>Retry-After</code> 响应头部字段，标明客户端在再次尝试之前应该等待多少秒钟。
目前，<code>kube-apiserver</code> 也能使用 <code>Too large resource version（资源版本过高）</code>
消息来标识这类响应。针对某无法识别的资源版本的 WATCH 操作可能会无限期
（直到请求超时）地等待下去，直到资源版本可用。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-040d9484db673074f1b8ba3465be9d91>2.2 - 服务器端应用（Server-Side Apply）</h1>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.22 [stable]</code>
</div>
<h2 id=introduction>简介</h2>
<p>服务器端应用协助用户、控制器通过声明式配置的方式管理他们的资源。
客户端可以发送完整描述的目标（A fully specified intent），
声明式地创建和/或修改
<a href=/zh/docs/concepts/overview/working-with-objects/kubernetes-objects/>对象</a>。</p>
<p>一个完整描述的目标并不是一个完整的对象，仅包括能体现用户意图的字段和值。
该目标（intent）可以用来创建一个新对象，
也可以通过服务器来实现与现有对象的<a href=#merge-strategy>合并</a>。</p>
<p>系统支持多个应用者（appliers）在同一个对象上开展协作。</p>
<p>“<a href=#field-management>字段管理（field management）</a>”机制追踪对象字段的变化。
当一个字段值改变时，其所有权从当前管理器（manager）转移到施加变更的管理器。
当尝试将新配置应用到一个对象时，如果字段有不同的值，且由其他管理器管理，
将会引发<a href=#conflicts>冲突</a>。
冲突引发警告信号：此操作可能抹掉其他协作者的修改。
冲突可以被刻意忽略，这种情况下，值将会被改写，所有权也会发生转移。</p>
<p>当你从配置文件中删除一个字段，然后应用这个配置文件，
这将触发服务端应用检查此字段是否还被其他字段管理器拥有。
如果没有，那就从活动对象中删除该字段；如果有，那就重置为默认值。
该规则同样适用于 list 或 map 项目。</p>
<p>服务器端应用既是原有 <code>kubectl apply</code> 的替代品，
也是控制器发布自身变化的一个简化机制。</p>
<p>如果你启用了服务器端应用，控制平面就会跟踪被所有新创建对象管理的字段。</p>
<h2 id=field-management>字段管理</h2>
<p>相对于通过 <code>kubectl</code> 管理的注解 <code>last-applied</code>，
服务器端应用使用了一种更具声明式特点的方法：
它持续的跟踪用户的字段管理，而不仅仅是最后一次的执行状态。
这就意味着，作为服务器端应用的一个副作用，
关于用哪一个字段管理器负责管理对象中的哪个字段的这类信息，都要对外界开放了。</p>
<p>用户管理字段这件事，在服务器端应用的场景中，意味着用户依赖并期望字段的值不要改变。
最后一次对字段值做出断言的用户将被记录到当前字段管理器。
这可以通过发送 <code>POST</code>、 <code>PUT</code>、
或非应用（non-apply）方式的 <code>PATCH</code> 等命令来修改字段值的方式实现，
或通过把字段放在配置文件中，然后发送到服务器端应用的服务端点的方式实现。
当使用服务器端应用，尝试着去改变一个被其他人管理的字段，
会导致请求被拒绝（在没有设置强制执行时，参见<a href=#conflicts>冲突</a>）。</p>
<p>如果两个或以上的应用者均把同一个字段设置为相同值，他们将共享此字段的所有权。
后续任何改变共享字段值的尝试，不管由那个应用者发起，都会导致冲突。
共享字段的所有者可以放弃字段的所有权，这只需从配置文件中删除该字段即可。</p>
<p>字段管理的信息存储在 <code>managedFields</code> 字段中，该字段是对象的
<a href=/docs/reference/generated/kubernetes-api/v1.23/#objectmeta-v1-meta><code>metadata</code></a>
中的一部分。</p>
<p>服务器端应用创建对象的简单示例如下：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-cm<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>test-label</span>:<span style=color:#bbb> </span>test<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>managedFields</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>manager</span>:<span style=color:#bbb> </span>kubectl<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>operation</span>:<span style=color:#bbb> </span>Apply<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>time</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2010-10-10T0:00:00Z&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>fieldsType</span>:<span style=color:#bbb> </span>FieldsV1<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>fieldsV1</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>f:metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>f:labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>f:test-label</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>f:data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>f:key</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>some value<span style=color:#bbb>
</span></code></pre></div>
<p>上述对象在 <code>metadata.managedFields</code> 中包含了唯一的管理器。
管理器由管理实体自身的基本信息组成，比如操作类型、API 版本、以及它管理的字段。</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 该字段由 API 服务器管理，用户不应该改动它。
</div>
<p>不过，执行 <code>Update</code> 操作修改 <code>metadata.managedFields</code> 也是可实现的。
强烈不鼓励这么做，但当发生如下情况时，
比如 <code>managedFields</code> 进入不一致的状态（显然不应该发生这种情况），
这么做也是一个合理的尝试。</p>
<p><code>managedFields</code> 的格式在
<a href=/docs/reference/generated/kubernetes-api/v1.23/#fieldsv1-v1-meta>API</a>
文档中描述。</p>
<h2 id=conflicts>冲突</h2>
<p>冲突是一种特定的错误状态，
发生在执行 <code>Apply</code> 改变一个字段，而恰巧该字段被其他用户声明过主权时。
这可以防止一个应用者不小心覆盖掉其他用户设置的值。
冲突发生时，应用者有三种办法来解决它：</p>
<ul>
<li>
<p><strong>覆盖前值，成为唯一的管理器：</strong> 如果打算覆盖该值（或应用者是一个自动化部件，比如控制器），
应用者应该设置查询参数 <code>force</code> 为 true，然后再发送一次请求。
这将强制操作成功，改变字段的值，从所有其他管理器的 managedFields 条目中删除指定字段。</p>
</li>
<li>
<p><strong>不覆盖前值，放弃管理权：</strong> 如果应用者不再关注该字段的值，
可以从配置文件中删掉它，再重新发送请求。
这就保持了原值不变，并从 managedFields 的应用者条目中删除该字段。</p>
</li>
<li>
<p><strong>不覆盖前值，成为共享的管理器：</strong> 如果应用者仍然关注字段值，并不想覆盖它，
他们可以在配置文件中把字段的值改为和服务器对象一样，再重新发送请求。
这样在不改变字段值的前提下，
就实现了字段管理被应用者和所有声明了管理权的其他的字段管理器共享。</p>
</li>
</ul>
<h2 id=managers>管理器</h2>
<p>管理器识别出正在修改对象的工作流程（在冲突时尤其有用）,
管理器可以通过修改请求的参数 <code>fieldManager</code> 指定。
虽然 kubectl 默认发往 <code>kubectl</code> 服务端点，但它则请求到应用的服务端点（apply endpoint）。
对于其他的更新，它默认的是从用户代理计算得来。</p>
<h2 id=apply-and-update>应用和更新</h2>
<p>此特性涉及两类操作，分别是 <code>Apply</code>
（内容类型为 <code>application/apply-patch+yaml</code> 的 <code>PATCH</code> 请求）
和 <code>Update</code> （所有修改对象的其他操作）。
这两类操作都会更新字段 <code>managedFields</code>，但行为表现有一点不同。</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> <p>不管你提交的是 JSON 数据还是 YAML 数据，
都要使用 <code>application/apply-patch+yaml</code> 作为 <code>Content-Type</code> 的值。</p>
<p>所有的 JSON 文档 都是合法的 YAML。</p>
</div>
<p>例如，在冲突发生的时候，只有 <code>apply</code> 操作失败，而 <code>update</code> 则不会。
此外，<code>apply</code> 操作必须通过提供一个 <code>fieldManager</code> 查询参数来标识自身，
而此查询参数对于 <code>update</code> 操作则是可选的。
最后，当使用 <code>apply</code> 命令时，你不能在应用中的对象中持有 <code>managedFields</code>。</p>
<p>一个包含多个管理器的对象，示例如下：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-cm<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>test-label</span>:<span style=color:#bbb> </span>test<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>managedFields</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>manager</span>:<span style=color:#bbb> </span>kubectl<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>operation</span>:<span style=color:#bbb> </span>Apply<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>fields</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>f:metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>f:labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>f:test-label</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>manager</span>:<span style=color:#bbb> </span>kube-controller-manager<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>operation</span>:<span style=color:#bbb> </span>Update<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>time</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;2019-03-30T16:00:00.000Z&#39;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>fields</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>f:data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>f:key</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>new value<span style=color:#bbb>
</span></code></pre></div>
<p>在这个例子中，
第二个操作被管理器 <code>kube-controller-manager</code> 以 <code>Update</code> 的方式运行。
此 <code>update</code> 更改 data 字段的值，
并使得字段管理器被改为 <code>kube-controller-manager</code>。</p>
<p>如果把 <code>update</code> 操作改为 <code>Apply</code>，那就会因为所有权冲突的原因，导致操作失败。</p>
<h2 id=merge-strategy>合并策略</h2>
<p>由服务器端应用实现的合并策略，提供了一个总体更稳定的对象生命周期。
服务器端应用试图依据负责管理它们的主体来合并字段，而不是根据值来否决。
这么做是为了多个主体可以更新同一个对象，且不会引起意外的相互干扰。</p>
<p>当用户发送一个“完整描述的目标”对象到服务器端应用的服务端点，
服务器会将它和活动对象做一次合并，如果两者中有重复定义的值，那就以配置文件的为准。
如果配置文件中的项目集合不是此用户上一次操作项目的超集，
所有缺少的、没有其他应用者管理的项目会被删除。
关于合并时用来做决策的对象规格的更多信息，参见
<a href=https://sigs.k8s.io/structured-merge-diff>sigs.k8s.io/structured-merge-diff</a>.</p>
<p>Kubernetes 1.16 和 1.17 中添加了一些标记，
允许 API 开发人员描述由 list、map、和 structs 支持的合并策略。
这些标记可应用到相应类型的对象，在 Go 文件或在
<a href=/docs/reference/generated/kubernetes-api/v1.23#jsonschemaprops-v1-apiextensions-k8s-io>CRD</a>
的 OpenAPI 的模式中定义：</p>
<table>
<thead>
<tr>
<th>Golang 标记</th>
<th>OpenAPI extension</th>
<th>可接受的值</th>
<th>描述</th>
<th>引入版本</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>//+listType</code></td>
<td><code>x-kubernetes-list-type</code></td>
<td><code>atomic</code>/<code>set</code>/<code>map</code></td>
<td>适用于 list。<code>set</code> 适用于仅包含标量元素的列表。这些元素必须是不重复的。<code>map</code> 仅适用于包含嵌套类型的列表。列表中的键（参见 <code>listMapKey</code>）不可以重复。<code>atomic</code> 适用于任何类型的列表。如果配置为 <code>atomic</code>，则合并时整个列表会被替换掉。任何时候，只有一个管理器负责管理指定列表。如果配置为 <code>set</code> 或 <code>map</code>，不同的管理器也可以分开管理条目。</td>
<td>1.16</td>
</tr>
<tr>
<td><code>//+listMapKey</code></td>
<td><code>x-kubernetes-list-map-keys</code></td>
<td>字段名称的列表，例如，<code>["port", "protocol"]</code></td>
<td>仅当 <code>+listType=map</code> 时适用。取值为字段名称的列表，这些字段值的组合能够唯一标识列表中的条目。尽管可以存在多个键，<code>listMapKey</code> 是单数的，这是因为键名需要在 Go 类型中各自独立指定。键字段必须是标量。</td>
<td>1.16</td>
</tr>
<tr>
<td><code>//+mapType</code></td>
<td><code>x-kubernetes-map-type</code></td>
<td><code>atomic</code>/<code>granular</code></td>
<td>适用于 map。 <code>atomic</code> 指 map 只能被单个的管理器整个的替换。 <code>granular</code> 指 map 支持多个管理器各自更新自己的字段。</td>
<td>1.17</td>
</tr>
<tr>
<td><code>//+structType</code></td>
<td><code>x-kubernetes-map-type</code></td>
<td><code>atomic</code>/<code>granular</code></td>
<td>适用于 structs；否则就像 <code>//+mapType</code> 有相同的用法和 openapi 注释.</td>
<td>1.17</td>
</tr>
</tbody>
</table>
<p>若未指定 <code>listType</code>，API 服务器将 <code>patchMergeStrategy=merge</code> 标记解释为
<code>listType=map</code> 并且视对应的 <code>patchMergeKey</code> 标记为 <code>listMapKey</code> 取值。</p>
<p><code>atomic</code> 列表类型是递归的。</p>
<p>这些标记都是用源代码注释的方式给出的，不必作为字段标签（tag）再重复。</p>
<h3 id=compatibility-across-toplogy-changes>拓扑变化时的兼容性 </h3>
<p>在极少的情况下，CRD 或者内置类型的作者可能希望更改其资源中的某个字段的
拓扑配置，同时又不提升版本号。
通过升级集群或者更新 CRD 来更改类型的拓扑信息与更新现有对象的结果不同。
变更的类型有两种：一种是将字段从 <code>map</code>/<code>set</code>/<code>granular</code> 更改为 <code>atomic</code>，
另一种是做逆向改变。</p>
<p>当 <code>listType</code>、<code>mapType</code> 或 <code>structType</code> 从 <code>map</code>/<code>set</code>/<code>granular</code> 改为
<code>atomic</code> 时，现有对象的整个列表、映射或结构的属主都会变为这些类型的
元素之一的属主。这意味着，对这些对象的进一步变更会引发冲突。</p>
<p>当一个列表、映射或结构从 <code>atomic</code> 改为 <code>map</code>/<code>set</code>/<code>granular</code> 之一
时，API 服务器无法推导这些字段的新的属主。因此，当对象的这些字段
再次被更新时不会引发冲突。出于这一原因，不建议将某类型从 <code>atomic</code> 改为
<code>map</code>/<code>set</code>/<code>granular</code>。</p>
<p>以下面的自定义资源为例：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>example.com/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Foo<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo-sample<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>managedFields</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>manager</span>:<span style=color:#bbb> </span>manager-one<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>operation</span>:<span style=color:#bbb> </span>Apply<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>example.com/v1<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>fields</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>f:spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>f:data</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>key1</span>:<span style=color:#bbb> </span>val1<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>key2</span>:<span style=color:#bbb> </span>val2<span style=color:#bbb>
</span></code></pre></div>
<p>在 <code>spec.data</code> 从 <code>atomic</code> 改为 <code>granular</code> 之前，<code>manager-one</code> 是
<code>spec.data</code> 字段及其所包含字段（<code>key1</code> 和 <code>key2</code>）的属主。
当对应的 CRD 被更改，使得 <code>spec.data</code> 变为 <code>granular</code> 拓扑时，
<code>manager-one</code> 继续拥有顶层字段 <code>spec.data</code>（这意味着其他管理者想
删除名为 <code>data</code> 的映射而不引起冲突是不可能的），但不再拥有
<code>key1</code> 和 <code>key2</code>。因此，其他管理者可以在不引起冲突的情况下更改
或删除这些字段。</p>
<h3 id=custom-resources>自定义资源</h3>
<p>默认情况下，服务器端应用把自定义资源看做非结构化数据。
所有的键值（keys）就像 struct 的字段一样被处理，
所有的 list 被认为是原子性的。</p>
<p>如果自定义资源定义（Custom Resource Definition，CRD）定义了一个
<a href=/docs/reference/generated/kubernetes-api/v1.23#jsonschemaprops-v1-apiextensions-k8s-io>模式</a>，
它包含类似以前“合并策略”章节中定义过的注解，
这些注解将在合并此类型的对象时使用。</p>
<h2 id=using-server-side-apply-in-controller>在控制器中使用服务器端应用</h2>
<p>控制器的开发人员可以把服务器端应用作为简化控制器的更新逻辑的方式。
读-改-写 和/或 patch 的主要区别如下所示：</p>
<ul>
<li>应用的对象必须包含控制器关注的所有字段。</li>
<li>对于在控制器没有执行过应用操作之前就已经存在的字段，不能删除。
（控制器在这种用例环境下，依然可以发送一个 PATCH/UPDATE）</li>
<li>对象不必事先读取，<code>resourceVersion</code> 不必指定。</li>
</ul>
<p>强烈推荐：设置控制器在冲突时强制执行，这是因为冲突发生时，它们没有其他解决方案或措施。</p>
<h2 id=transferring-ownership>转移所有权</h2>
<p>除了通过<a href=#conflicts>冲突解决方案</a>提供的并发控制，
服务器端应用提供了一些协作方式来将字段所有权从用户转移到控制器。</p>
<p>最好通过例子来说明这一点。
让我们来看看，在使用 Horizo​​ntalPodAutoscaler 资源和与之配套的控制器，
且开启了 Deployment 的自动水平扩展功能之后，
怎么安全的将 <code>replicas</code> 字段的所有权从用户转移到控制器。</p>
<p>假设用户定义了 Deployment，且 <code>replicas</code> 字段已经设置为期望的值：</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/application/ssa/nginx-deployment.yaml download=application/ssa/nginx-deployment.yaml><code>application/ssa/nginx-deployment.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('application-ssa-nginx-deployment-yaml')" title="Copy application/ssa/nginx-deployment.yaml to clipboard">
</img>
</div>
<div class=includecode id=application-ssa-nginx-deployment-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-deployment<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.14.2<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>并且，用户使用服务器端应用，像这样创建 Deployment：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/application/ssa/nginx-deployment.yaml --server-side
</code></pre></div>
<p>然后，为 Deployment 启用 HPA，例如：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl autoscale deployment nginx-deployment --cpu-percent<span style=color:#666>=</span><span style=color:#666>50</span> --min<span style=color:#666>=</span><span style=color:#666>1</span> --max<span style=color:#666>=</span><span style=color:#666>10</span>
</code></pre></div>
<p>现在，用户希望从他们的配置中删除 <code>replicas</code>，所以他们总是和 HPA 控制器冲突。
然而，这里存在一个竟态：
在 HPA 需要调整 <code>replicas</code> 之前会有一个时间窗口，
如果在 HPA 写入字段成为所有者之前，用户删除了<code>replicas</code>，
那 API 服务器就会把 <code>replicas</code> 的值设为 1， 也就是默认值。
这不是用户希望发生的事情，即使是暂时的。</p>
<p>这里有两个解决方案：</p>
<ul>
<li>（基本操作）把 <code>replicas</code> 留在配置文件中；当 HPA 最终写入那个字段，
系统基于此事件告诉用户：冲突发生了。在这个时间点，可以安全的删除配置文件。</li>
<li>（高级操作）然而，如果用户不想等待，比如他们想为合作伙伴保持集群清晰，
那他们就可以执行以下步骤，安全的从配置文件中删除 <code>replicas</code>。</li>
</ul>
<p>首先，用户新定义一个只包含 <code>replicas</code> 字段的配置文件：</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/application/ssa/nginx-deployment-replicas-only.yaml download=application/ssa/nginx-deployment-replicas-only.yaml><code>application/ssa/nginx-deployment-replicas-only.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('application-ssa-nginx-deployment-replicas-only-yaml')" title="Copy application/ssa/nginx-deployment-replicas-only.yaml to clipboard">
</img>
</div>
<div class=includecode id=application-ssa-nginx-deployment-replicas-only-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-deployment<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>用户使用名为 <code>handover-to-hpa</code> 的字段管理器，应用此配置文件。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/application/ssa/nginx-deployment-replicas-only.yaml <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --server-side --field-manager<span style=color:#666>=</span>handover-to-hpa <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --validate<span style=color:#666>=</span><span style=color:#a2f>false</span>
</code></pre></div>
<p>如果应用操作和 HPA 控制器产生冲突，那什么都不做。
冲突表明控制器在更早的流程中已经对字段声明过所有权。</p>
<p>在此时间点，用户可以从配置文件中删除 <code>replicas</code> 。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/application/ssa/nginx-deployment-no-replicas.yaml download=application/ssa/nginx-deployment-no-replicas.yaml><code>application/ssa/nginx-deployment-no-replicas.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('application-ssa-nginx-deployment-no-replicas-yaml')" title="Copy application/ssa/nginx-deployment-no-replicas.yaml to clipboard">
</img>
</div>
<div class=includecode id=application-ssa-nginx-deployment-no-replicas-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-deployment<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.14.2<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>注意，只要 HPA 控制器为 <code>replicas</code> 设置了一个新值，
该临时字段管理器将不再拥有任何字段，会被自动删除。
这里不需要执行清理工作。</p>
<h3 id=transferring-ownership-between-users>在用户之间转移所有权</h3>
<p>通过在配置文件中把一个字段设置为相同的值，用户可以在他们之间转移字段的所有权，
从而共享了字段的所有权。
当用户共享了字段的所有权，任何一个用户可以从他的配置文件中删除该字段，
并应用该变更，从而放弃所有权，并实现了所有权向其他用户的转移。</p>
<h2 id=comparison-with-client-side-apply>与客户端应用的对比</h2>
<p>由服务器端应用实现的冲突检测和解决方案的一个结果就是，
应用者总是可以在本地状态中得到最新的字段值。
如果得不到最新值，下次执行应用操作时就会发生冲突。
解决冲突三个选项的任意一个都会保证：此应用过的配置文件是服务器上对象字段的最新子集。</p>
<p>这和客户端应用（Client Side Apply） 不同，如果有其他用户覆盖了此值，
过期的值被留在了应用者本地的配置文件中。
除非用户更新了特定字段，此字段才会准确，
应用者没有途径去了解下一次应用操作是否会覆盖其他用户的修改。</p>
<p>另一个区别是使用客户端应用的应用者不能改变他们正在使用的 API 版本，但服务器端应用支持这个场景。</p>
<h2 id=upgrading-from-client-side-apply-to-server-side-apply>从客户端应用升级到服务器端应用</h2>
<p>客户端应用方式时，用户使用 <code>kubectl apply</code> 管理资源，
可以通过使用下面标记切换为使用服务器端应用。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply --server-side <span style=color:#666>[</span>--dry-run<span style=color:#666>=</span>server<span style=color:#666>]</span>
</code></pre></div>
<p>默认情况下，对象的字段管理从客户端应用方式迁移到 kubectl 触发的服务器端应用时，不会发生冲突。</p>
<div class="alert alert-warning caution callout" role=alert>
<strong>Caution:</strong> <p>保持注解 <code>last-applied-configuration</code> 是最新的。
从注解能推断出字段是由客户端应用管理的。
任何没有被客户端应用管理的字段将引发冲突。</p>
<p>举例说明，比如你在客户端应用之后，
使用 <code>kubectl scale</code> 去更新 <code>replicas</code> 字段，
可是该字段并没有被客户端应用所拥有，
在执行 <code>kubectl apply --server-side</code> 时就会产生冲突。</p>
</div>
<p>此操作以 <code>kubectl</code> 作为字段管理器来应用到服务器端应用。
作为例外，可以指定一个不同的、非默认字段管理器停止的这种行为，如下面的例子所示。
对于 kubectl 触发的服务器端应用，默认的字段管理器是 <code>kubectl</code>。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply --server-side --field-manager<span style=color:#666>=</span>my-manager <span style=color:#666>[</span>--dry-run<span style=color:#666>=</span>server<span style=color:#666>]</span>
</code></pre></div>
<h2 id=downgrading-from-server-side-apply-to-client-side-apply>从服务器端应用降级到客户端应用</h2>
<p>如果你用 <code>kubectl apply --server-side</code> 管理一个资源，
可以直接用 <code>kubectl apply</code> 命令将其降级为客户端应用。</p>
<p>降级之所以可行，这是因为 <code>kubectl server-side apply</code>
会保存最新的 <code>last-applied-configuration</code> 注解。</p>
<p>此操作以 <code>kubectl</code> 作为字段管理器应用到服务器端应用。
作为例外，可以指定一个不同的、非默认字段管理器停止这种行为，如下面的例子所示。
对于 kubectl 触发的服务器端应用，默认的字段管理器是 <code>kubectl</code>。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply --server-side --field-manager<span style=color:#666>=</span>my-manager <span style=color:#666>[</span>--dry-run<span style=color:#666>=</span>server<span style=color:#666>]</span>
</code></pre></div>
<h2 id=api-endpoint>API 端点</h2>
<p>启用了服务器端应用特性之后，
<code>PATCH</code> 服务端点接受额外的内容类型 <code>application/apply-patch+yaml</code>。
服务器端应用的用户就可以把 YAMl 格式的
部分定义对象（partially specified objects）发送到此端点。
当一个配置文件被应用时，它应该包含所有体现你意图的字段。</p>
<h2 id=clearing-managedfields>清除 ManagedFields</h2>
<p>可以从对象中剥离所有 managedField，
实现方法是通过使用 <code>MergePatch</code>、 <code>StrategicMergePatch</code>、
<code>JSONPatch</code>、 <code>Update</code>、以及所有的非应用方式的操作来覆盖它。
这可以通过用空条目覆盖 managedFields 字段的方式实现。以下是两个示例：</p>
<pre><code class=language-console data-lang=console>PATCH /api/v1/namespaces/default/configmaps/example-cm
Content-Type: application/merge-patch+json
Accept: application/json
Data: {&quot;metadata&quot;:{&quot;managedFields&quot;: [{}]}}
</code></pre><pre><code class=language-console data-lang=console>PATCH /api/v1/namespaces/default/configmaps/example-cm
Content-Type: application/json-patch+json
Accept: application/json
Data: [{&quot;op&quot;: &quot;replace&quot;, &quot;path&quot;: &quot;/metadata/managedFields&quot;, &quot;value&quot;: [{}]}]
</code></pre>
<p>这一操作将用只包含一个空条目的列表覆写 managedFields，
来实现从对象中整个的去除 managedFields。
注意，只把 managedFields 设置为空列表并不会重置字段。
这么做是有目的的，所以 managedFields 将永远不会被与该字段无关的客户删除。</p>
<p>在重置操作结合 managedFields 以外其他字段更改的场景中，
将导致 managedFields 首先被重置，其他改变被押后处理。
其结果是，应用者取得了同一个请求中所有字段的所有权。</p>
<div class="alert alert-warning caution callout" role=alert>
<strong>Caution:</strong> 对于不接受资源对象类型的子资源（sub-resources），
服务器端应用不能正确地跟踪其所有权。
如果你对这样的子资源使用服务器端应用，变更的字段将不会被跟踪。
</div>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-79880efc25dc8cb3b6962ad78a964319>2.3 - 客户端库</h1>
<p>本页面包含基于各种编程语言使用 Kubernetes API 的客户端库概述。</p>
<p>在使用 <a href=/zh/docs/reference/using-api/>Kubernetes REST API</a> 编写应用程序时，
您并不需要自己实现 API 调用和 “请求/响应” 类型。
您可以根据自己的编程语言需要选择使用合适的客户端库。</p>
<p>客户端库通常为您处理诸如身份验证之类的常见任务。
如果 API 客户端在 Kubernetes 集群中运行，大多数客户端库可以发现并使用 Kubernetes 服务帐户进行身份验证，
或者能够理解 <a href=/zh/docs/tasks/access-application-cluster/configure-access-multiple-clusters/>kubeconfig 文件</a>
格式来读取凭据和 API 服务器地址。</p>
<h2 id=officially-supported-kubernetes-client-libraries>官方支持的 Kubernetes 客户端库 </h2>
<p>以下客户端库由 <a href=https://github.com/kubernetes/community/tree/master/sig-api-machinery>Kubernetes SIG API Machinery</a> 正式维护。</p>
<table>
<thead>
<tr>
<th>语言</th>
<th>客户端库</th>
<th>样例程序</th>
</tr>
</thead>
<tbody>
<tr>
<td>dotnet</td>
<td><a href=https://github.com/kubernetes-client/csharp>github.com/kubernetes-client/csharp</a></td>
<td><a href=https://github.com/kubernetes-client/csharp/tree/master/examples/simple>浏览</a></td>
</tr>
<tr>
<td>Go</td>
<td><a href=https://github.com/kubernetes/client-go/>github.com/kubernetes/client-go/</a></td>
<td><a href=https://github.com/kubernetes/client-go/tree/master/examples>浏览</a></td>
</tr>
<tr>
<td>Haskell</td>
<td><a href=https://github.com/kubernetes-client/haskell>github.com/kubernetes-client/haskell</a></td>
<td><a href=https://github.com/kubernetes-client/haskell/tree/master/kubernetes-client/example>浏览</a></td>
</tr>
<tr>
<td>Java</td>
<td><a href=https://github.com/kubernetes-client/java/>github.com/kubernetes-client/java</a></td>
<td><a href=https://github.com/kubernetes-client/java#installation>浏览</a></td>
</tr>
<tr>
<td>JavaScript</td>
<td><a href=https://github.com/kubernetes-client/javascript>github.com/kubernetes-client/javascript</a></td>
<td><a href=https://github.com/kubernetes-client/javascript/tree/master/examples>浏览</a></td>
</tr>
<tr>
<td>Python</td>
<td><a href=https://github.com/kubernetes-client/python/>github.com/kubernetes-client/python/</a></td>
<td><a href=https://github.com/kubernetes-client/python/tree/master/examples>浏览</a></td>
</tr>
</tbody>
</table>
<h2 id=community-maintained-client-libraries>社区维护的客户端库 </h2>
<div class="alert alert-secondary callout third-party-content" role=alert><strong>Note:</strong>
This section links to third party projects that provide functionality required by Kubernetes. The Kubernetes project authors aren't responsible for these projects, which are listed alphabetically. To add a project to this list, read the <a href=/docs/contribute/style/content-guide/#third-party-content>content guide</a> before submitting a change. <a href=#third-party-content-disclaimer>More information.</a></div>
<p>以下 Kubernetes API 客户端库是由社区，而非 Kubernetes 团队支持、维护的。</p>
<table>
<thead>
<tr>
<th>语言</th>
<th>客户端库</th>
</tr>
</thead>
<tbody>
<tr>
<td>Clojure</td>
<td><a href=https://github.com/yanatan16/clj-kubernetes-api>github.com/yanatan16/clj-kubernetes-api</a></td>
</tr>
<tr>
<td>DotNet</td>
<td><a href=https://github.com/tonnyeremin/kubernetes_gen>github.com/tonnyeremin/kubernetes_gen</a></td>
</tr>
<tr>
<td>DotNet (RestSharp)</td>
<td><a href=https://github.com/masroorhasan/Kubernetes.DotNet>github.com/masroorhasan/Kubernetes.DotNet</a></td>
</tr>
<tr>
<td>Elixir</td>
<td><a href=https://github.com/obmarg/kazan/>github.com/obmarg/kazan</a></td>
</tr>
<tr>
<td>Elixir</td>
<td><a href=https://github.com/coryodaniel/k8s>github.com/coryodaniel/k8s</a></td>
</tr>
<tr>
<td>Go</td>
<td><a href=https://github.com/ericchiang/k8s>github.com/ericchiang/k8s</a></td>
</tr>
<tr>
<td>Java (OSGi)</td>
<td><a href=https://bitbucket.org/amdatulabs/amdatu-kubernetes>bitbucket.org/amdatulabs/amdatu-kubernetes</a></td>
</tr>
<tr>
<td>Java (Fabric8, OSGi)</td>
<td><a href=https://github.com/fabric8io/kubernetes-client>github.com/fabric8io/kubernetes-client</a></td>
</tr>
<tr>
<td>Java</td>
<td><a href=https://github.com/manusa/yakc>github.com/manusa/yakc</a></td>
</tr>
<tr>
<td>Lisp</td>
<td><a href=https://github.com/brendandburns/cl-k8s>github.com/brendandburns/cl-k8s</a></td>
</tr>
<tr>
<td>Lisp</td>
<td><a href=https://github.com/xh4/cube>github.com/xh4/cube</a></td>
</tr>
<tr>
<td>Node.js (TypeScript)</td>
<td><a href=https://github.com/Goyoo/node-k8s-client>github.com/Goyoo/node-k8s-client</a></td>
</tr>
<tr>
<td>Node.js</td>
<td><a href=https://github.com/ajpauwels/easy-k8s>github.com/ajpauwels/easy-k8s</a></td>
</tr>
<tr>
<td>Node.js</td>
<td><a href=https://github.com/godaddy/kubernetes-client>github.com/godaddy/kubernetes-client</a></td>
</tr>
<tr>
<td>Node.js</td>
<td><a href=https://github.com/tenxcloud/node-kubernetes-client>github.com/tenxcloud/node-kubernetes-client</a></td>
</tr>
<tr>
<td>Perl</td>
<td><a href=https://metacpan.org/pod/Net::Kubernetes>metacpan.org/pod/Net::Kubernetes</a></td>
</tr>
<tr>
<td>PHP</td>
<td><a href=https://github.com/allansun/kubernetes-php-client>github.com/allansun/kubernetes-php-client</a></td>
</tr>
<tr>
<td>PHP</td>
<td><a href=https://github.com/maclof/kubernetes-client>github.com/maclof/kubernetes-client</a></td>
</tr>
<tr>
<td>PHP</td>
<td><a href=https://github.com/travisghansen/kubernetes-client-php>github.com/travisghansen/kubernetes-client-php</a></td>
</tr>
<tr>
<td>PHP</td>
<td><a href=https://github.com/renoki-co/php-k8s>github.com/renoki-co/php-k8s</a></td>
</tr>
<tr>
<td>Python</td>
<td><a href=https://github.com/fiaas/k8s>github.com/fiaas/k8s</a></td>
</tr>
<tr>
<td>Python</td>
<td><a href=https://github.com/gtsystem/lightkube>github.com/gtsystem/lightkube</a></td>
</tr>
<tr>
<td>Python</td>
<td><a href=https://github.com/mnubo/kubernetes-py>github.com/mnubo/kubernetes-py</a></td>
</tr>
<tr>
<td>Python</td>
<td><a href=https://github.com/tomplus/kubernetes_asyncio>github.com/tomplus/kubernetes_asyncio</a></td>
</tr>
<tr>
<td>Python</td>
<td><a href=https://github.com/Frankkkkk/pykorm>github.com/Frankkkkk/pykorm</a></td>
</tr>
<tr>
<td>Ruby</td>
<td><a href=https://github.com/abonas/kubeclient>github.com/abonas/kubeclient</a></td>
</tr>
<tr>
<td>Ruby</td>
<td><a href=https://github.com/k8s-ruby/k8s-ruby>github.com/k8s-ruby/k8s-ruby</a></td>
</tr>
<tr>
<td>Ruby</td>
<td><a href=https://github.com/kontena/k8s-client>github.com/kontena/k8s-client</a></td>
</tr>
<tr>
<td>Rust</td>
<td><a href=https://github.com/clux/kube-rs>github.com/clux/kube-rs</a></td>
</tr>
<tr>
<td>Rust</td>
<td><a href=https://github.com/ynqa/kubernetes-rust>github.com/ynqa/kubernetes-rust</a></td>
</tr>
<tr>
<td>Scala</td>
<td><a href=https://github.com/hagay3/skuber>github.com/hagay3/skuber</a></td>
</tr>
<tr>
<td>Scala</td>
<td><a href=https://github.com/joan38/kubernetes-client>github.com/joan38/kubernetes-client</a></td>
</tr>
<tr>
<td>Swift</td>
<td><a href=https://github.com/swiftkube/client>github.com/swiftkube/client</a></td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-8d2ce3e7b2223cda0ccd428f4d5ea24b>2.4 - Kubernetes 弃用策略</h1>
<p>本文档详细解释系统中各个层面的弃用策略（Deprecation Policy）。</p>
<p>Kubernetes 是一个组件众多、贡献者人数众多的大系统。
就像很多类似的软件，所提供的功能特性集合会随着时间推移而自然发生变化，
而且有时候某个功能特性可能需要被去除。被去除的可能是一个 API、一个参数标志或者
甚至某整个功能特性。为了避免影响到现有用户，Kubernetes 对于其中渐次移除
的各个方面规定了一种弃用策略并遵从此策略。</p>
<h2 id=deprecating-parts-of-the-api>弃用 API 的一部分 </h2>
<p>由于 Kubernetes 是一个 API 驱动的系统，API 会随着时间推移而演化，以反映
人们对问题空间的认识的变化。Kubernetes API 实际上是一个 API 集合，其中每个
成员称作“API 组（API Group）”，并且每个 API 组都是独立管理版本的。
<a href=/zh/docs/reference/using-api/#api-versioning>API 版本</a>会有
三类，每类有不同的废弃策略：</p>
<table>
<thead>
<tr>
<th>示例</th>
<th>分类</th>
</tr>
</thead>
<tbody>
<tr>
<td>v1</td>
<td>正式发布（Generally available，GA，稳定版本）</td>
</tr>
<tr>
<td>v1beta1</td>
<td>Beta （预发布）</td>
</tr>
<tr>
<td>v1alpha1</td>
<td>Alpha （试验性）</td>
</tr>
</tbody>
</table>
<p>给定的 Kubernetes 发布版本中可以支持任意数量的 API 组，且每组可以包含
任意个数的版本。</p>
<p>下面的规则负责指导 API 元素的弃用，具体元素包括：</p>
<ul>
<li>REST 资源（也即 API 对象）</li>
<li>REST 资源的字段</li>
<li>REST 资源的注解，包含“beta”类注解但不包含“alpha”类注解</li>
<li>枚举值或者常数值</li>
<li>组件配置结构</li>
</ul>
<p>以下是跨正式发布版本时要实施的规则，不适用于对 master 或发布分支上
不同提交之间的变化。</p>
<p><strong>规则 #1：只能在增加 API 组版本号时删除 API 元素。</strong></p>
<p>一旦在某个特定 API 组版本中添加了 API 元素，则该元素不可从该版本中删除，
且其行为也不能大幅度地变化，无论属于哪一类（GA、Alpha 或 Beta）。</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 由于历史原因，Kubernetes 中存在两个“单体式（Monolithic）”API 组 -
“core”（无组名）和“extensions”。这两个遗留 API 组中的资源会被逐渐迁移到
更为特定领域的 API 组中。
</div>
<p><strong>规则 #2：在给定的发布版本中，API 对象必须能够在不同的 API 版本之间来回
转换且不造成信息丢失，除非整个 REST 资源在某些版本中完全不存在。</strong></p>
<p>例如，一个对象可被用 v1 来写入之后用 v2 来读出并转换为 v1，所得到的 v1 必须
与原来的 v1 对象完全相同。v2 中的表现形式可能与 v1 不同，但系统知道如何
在两个版本之间执行双向转换。
此外，v2 中添加的所有新字段都必须能够转换为 v1 再转换回来。这意味着 v1 必须
添加一个新的等效字段或者将其表现为一个注解。</p>
<p><strong>规则 #3：给定类别的 API 版本不可被弃用以支持稳定性更差的 API 版本。</strong></p>
<ul>
<li>一个正式发布的（GA）API 版本可替换 beta 或 alpha API 版本。</li>
<li>Beta API 版本可以替换早期的 beta 和 alpha API 版本，但 <strong>不可以</strong> 替换正式的 API 版本。</li>
<li>Alpha API 版本可以替换早期的 alpha API 版本，但 <strong>不可以</strong> 替换正式的或 beta API 版本。</li>
</ul>
<p><strong>规则 #4a：最短 API 生命周期由 API 稳定性级别决定</strong></p>
<ul>
<li><strong>GA API 版本可以被标记为已弃用，但不得在 Kubernetes 的主要版本中删除</strong></li>
<li><strong>Beta API 版本必须支持 9 个月或弃用后的 3 个版本（以较长者为准）</strong></li>
<li><strong>Alpha API 版本可能会在任何版本中被删除，不另行通知</strong></li>
</ul>
<p>这确保了 beta API 支持涵盖了<a href=/zh/releases/version-skew-policy/>最多 2 个版本的支持版本偏差</a>。</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong>
<p>目前没有删除正式版本 API 的 Kubernetes 主要版本修订计划。
</div>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 在 <a href=https://github.com/kubernetes/kubernetes/issues/52185>#52185</a> 被解决之前，
已经被保存到持久性存储中的 API 版本都不可以被去除。
你可以禁止这些版本所对应的 REST 末端（在符合本文中弃用时间线的前提下），
但是 API 服务器必须仍能解析和转换存储中以前写入的数据。
</div>
<p><strong>规则 #4b：标记为“preferred（优选的）” API 版本和给定 API 组的
“storage version（存储版本）”在既支持老版本也支持新版本的 Kubernetes 发布
版本出来以前不可以提升其版本号。</strong></p>
<p>用户必须能够升级到 Kubernetes 新的发行版本，之后再回滚到前一个发行版本，且
整个过程中无需针对新的 API 版本做任何转换，也不允许出现功能损坏的情况，
除非用户显式地使用了仅在较新版本中才存在的功能特性。
就对象的存储表示而言，这一点尤其是不言自明的。</p>
<p>以上所有规则最好通过例子来说明。假定现有 Kubernetes 发行版本为 X，其中引入了
新的 API 组。大约每隔 4 个月会有一个新的 Kubernetes 版本被发布（每年 3 个版本）。
下面的表格描述了在一系列后续的发布版本中哪些 API 版本是受支持的。</p>
<table>
<thead>
<tr>
<th>发布版本</th>
<th>API 版本</th>
<th>优选/存储版本</th>
<th>注释</th>
</tr>
</thead>
<tbody>
<tr>
<td>X</td>
<td>v1alpha1</td>
<td>v1alpha1</td>
<td></td>
</tr>
<tr>
<td>X+1</td>
<td>v1alpha2</td>
<td>v1alpha2</td>
<td>
<ul>
<li>v1alpha1 被去除，发布说明中会包含 "action required（采取行动）" 说明</li>
</ul>
</td>
</tr>
<tr>
<td>X+2</td>
<td>v1beta1</td>
<td>v1beta1</td>
<td>
<ul>
<li>v1alpha2 被去除，发布说明中包含对应的 "action required（采取行动）" 说明</li>
</ul>
</td>
</tr>
<tr>
<td>X+3</td>
<td>v1beta2、v1beta1（已弃用）</td>
<td>v1beta1</td>
<td>
<ul>
<li>v1beta1 被弃用，发布说明中包含对应的 "action required（采取行动）" 说明</li>
</ul>
</td>
</tr>
<tr>
<td>X+4</td>
<td>v1beta2、v1beta1（已弃用）</td>
<td>v1beta2</td>
<td></td>
</tr>
<tr>
<td>X+5</td>
<td>v1、v1beta1（已弃用）、v1beta2（已弃用）</td>
<td>v1beta2</td>
<td>
<ul>
<li>v1beta2 被弃用，发布说明中包含对应的 "action required（采取行动）" 说明</li>
</ul>
</td>
</tr>
<tr>
<td>X+6</td>
<td>v1、v1beta2（已弃用）</td>
<td>v1</td>
<td>
<ul>
<li>v1beta1 被去除，发布说明中包含对应的 "action required（采取行动）" 说明</li>
</ul>
</td>
</tr>
<tr>
<td>X+7</td>
<td>v1、v1beta2（已弃用）</td>
<td>v1</td>
<td></td>
</tr>
<tr>
<td>X+8</td>
<td>v2alpha1、v1</td>
<td>v1</td>
<td>
<ul>
<li>v1beta2 被去除，发布说明中包含对应的 "action required（采取行动）" 说明</li>
</ul>
</td>
</tr>
<tr>
<td>X+9</td>
<td>v2alpha2、v1</td>
<td>v1</td>
<td>
<ul>
<li>v2alpha1 被删除，发布说明中包含对应的 "action required（采取行动）" 说明</li>
</ul>
</td>
</tr>
<tr>
<td>X+10</td>
<td>v2beta1、v1</td>
<td>v1</td>
<td>
<ul>
<li>v2alpha2 被删除，发布说明中包含对应的 "action required（采取行动）" 说明</li>
</ul>
</td>
</tr>
<tr>
<td>X+11</td>
<td>v2beta2、v2beta1（已弃用）、v1</td>
<td>v1</td>
<td>
<ul>
<li>v2beta1 被弃用，发布说明中包含对应的 "action required（采取行动）" 说明</li>
</ul>
</td>
</tr>
<tr>
<td>X+12</td>
<td>v2、v2beta2（已弃用）、v2beta1（已弃用）、v1（已弃用）</td>
<td>v1</td>
<td>
<ul>
<li>v2beta2 已被弃用，发布说明中包含对应的 "action required（采取行动）" 说明</li>
<li>v1 已被弃用，取而代之的是 v2，但不会被删除</li>
</ul>
</td>
</tr>
<tr>
<td>X+13</td>
<td>v2、v2beta1（已弃用）、v2beta2（已弃用）、v1（已弃用）</td>
<td>v2</td>
<td></td>
</tr>
<tr>
<td>X+14</td>
<td>v2、v2beta2（已弃用）、v1（已弃用）</td>
<td>v2</td>
<td>
<ul>
<li>v2beta1 被删除，发布说明中包含对应的 "action required（采取行动）" 说明</li>
</ul>
</td>
</tr>
<tr>
<td>X+15</td>
<td>v2、v1（已弃用）</td>
<td>v2</td>
<td>
<ul>
<li>v2beta2 被删除，发布说明中包含对应的 "action required（采取行动）" 说明</li>
</ul>
</td>
</tr>
</tbody>
</table>
<h3 id=rest-resources-aka-api-objects>REST 资源（也即 API 对象） </h3>
<p>考虑一个假想的名为 Widget 的 REST 资源，在上述时间线中位于 API v1，
而现在打算将其弃用。
我们会在文档和
<a href=https://groups.google.com/forum/#!forum/kubernetes-announce>声明</a>
中与 X+1 版本的发布同步记述此弃用决定。
Wdiget 资源仍会在 API 版本 v1（已弃用）中存在，但不会出现在 v2alpha1 中。
Widget 资源会 X+8 发布版本之前（含 X+8）一直存在并可用。
只有在发布版本 X+9 中，API v1 寿终正寝时，Widget
才彻底消失，相应的资源行为也被移除。</p>
<p>从 Kubernetes v1.19 开始，当 API 请求被发送到一个已弃用的 REST API 末端时：</p>
<ol>
<li>
<p>API 响应中会包含一个 <code>Warning</code> 头部字段（如 <a href=https://tools.ietf.org/html/rfc7234#section-5.5>RFC7234 5.5 节</a>所定义）；</p>
</li>
<li>
<p>该请求会导致对应的
<a href=/zh/docs/tasks/debug-application-cluster/audit/>审计事件</a>
中会增加一个注解 <code>"k8s.io/deprecated":"true"</code>。</p>
</li>
<li>
<p><code>kube-apiserver</code> 进程的 <code>apiserver_requested_deprecated_apis</code> 度量值会被
设置为 <code>1</code>。
该度量值还附带 <code>group</code>、<code>version</code>、<code>resource</code> 和 <code>subresource</code> 标签
（可供添加到度量值 <code>apiserver_request_total</code> 上），
和一个 <code>removed_release</code> 标签，标明该 API 将消失的 Kubernetes 发布版本。
下面的 Prometheus 查询会返回对 v1.22 中将移除的、已弃用的 API
的请求的信息：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-promql data-lang=promql><span style=color:#b8860b>apiserver_requested_deprecated_apis</span>{<span style=color:#a0a000>removed_release</span><span style=color:#666>=</span>&#34;<span style=color:#b44>1.22</span>&#34;}<span style=color:#bbb> </span><span style=color:#666>*</span><span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>on</span><span style=color:#666>(</span><span style=color:#a2f;font-weight:700>group</span>,<span style=color:#b8860b>version</span>,<span style=color:#b8860b>resource</span>,<span style=color:#b8860b>subresource</span><span style=color:#666>)</span><span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>group_right</span><span style=color:#666>()</span><span style=color:#bbb> </span><span style=color:#b8860b>apiserver_request_total</span><span style=color:#bbb>
</span></code></pre></div></li>
</ol>
<h3 id=fields-of-rest-resources>REST 资源的字段 </h3>
<p>就像整个 REST 资源一样，在 API v1 中曾经存在的各个字段在 API v1 被移除
之前必须一直存在且起作用。
与整个资源上的规定不同，v2 API 可以选择为字段提供不同的表示方式，
只要对应的资源对象可在不同版本之间来回转换即可。
例如，v1 版本中一个名为 "magnitude" 的已弃用字段可能在 API v2 中被命名
为 "deprecatedMagnitude"。当 v1 最终被移除时，废弃的字段也可以从 v2
中移除。</p>
<h3 id=enumerated-or-constant-values>枚举值或常数值</h3>
<p>就像前文讲述的 REST 资源及其中的单个字段一样，API v1 中所支持的常数值
必须在 API v1 被移除之前一直存在且起作用。</p>
<h3 id=component-config-structures>组件配置结构 </h3>
<p>组件的配置也是有版本的，并且按 REST 资源的方式来管理。</p>
<h3 id=future-work>将来的工作 </h3>
<p>随着时间推移，Kubernetes 会引入粒度更细的 API 版本。
到那时，这里的规则会根据需要进行调整。</p>
<h2 id=弃用一个标志或-cli-命令>弃用一个标志或 CLI 命令</h2>
<p>Kubernetes 系统中包含若干不同的、相互协作的程序。
有时，Kubernetes 可能会删除这些程序的某些标志或 CLI 命令（统称“命令行元素”）。
这些程序可以天然地划分到两个大组中：面向用户的和面向管理员的程序。
二者之间的弃用策略略有不同。
除非某个标志显示地通过前缀或文档来标明其为“alpha”或“beta”，
该标志要被视作正式发布的（GA）。</p>
<p>命令行元素相当于系统的 API 的一部分，不过因为它们并没有采用 REST API
一样的方式来管理版本，其弃用规则规定如下：</p>
<p><strong>规则 #5a：面向用户的命令行元素（例如，kubectl）必须在其宣布被弃用其
在以下时长内仍能使用：</strong></p>
<ul>
<li><strong>GA：12 个月或者 2 个发布版本（取其较长者）</strong></li>
<li><strong>Beta：3 个月或者 1 个发布版本（取其较长者）</strong></li>
<li><strong>Alpha：0 发布版本</strong></li>
</ul>
<p><strong>规则 #5b：面向管理员的命令行元素（例如，kubelet）必须在其被宣布弃用
之后以下时长内保持可用：</strong></p>
<ul>
<li><strong>GA：6 个月或 1 个发行版本（取其较长者）</strong></li>
<li><strong>Beta: 3 个月或 1 个发行版本（取其较长者）</strong></li>
<li><strong>Alpha: 0 个发布版本</strong></li>
</ul>
<p><strong>规则 #6：被弃用的 CLI 元素在被用到时必须能够产生警告，而警告的
产生是可以被禁止的。</strong></p>
<h2 id=deprecating-a-feature-or-behavior>弃用某功能特性或行为 </h2>
<p>在一些较偶然的情形下，某 Kubernetes 发行版本需要弃用系统的某项功能
特性或者行为，而对应的功能特性或行为并不受 API 或 CLI 控制。在这种情况下，
其弃用规则如下：</p>
<p><strong>规则 #7：被弃用的行为必须在被宣布弃用之后至少 1 年时间内必须保持能用。</strong></p>
<p>这并不意味着对系统的所有更改都受此策略约束。
此规则仅适用于重大的、用户可见的行为；这些行为会影响到在 Kubernetes
中运行的应用的正确性，或者影响到 Kubernetes 集群的管理。
此规则也适用于那些被整个移除的功能特性或行为。</p>
<p>上述规则的一个例外是 <em>特性门控（Feature Gates）</em>。特性门控是一些键值偶对，
允许用户启用或禁用一些试验性的功能特性。</p>
<p>特性门控意在覆盖功能特性的整个开发周期，它们无意成为长期的 API。
因此，它们会在某功能特性正式发布或被抛弃之后被弃用和删除。</p>
<p>随着一个功能特性经过不同的成熟阶段，相关的特性门控也会演化。
与功能特性生命周期对应的特性门控状态为：</p>
<ul>
<li>Alpha：特性门控默认被禁用，只能由用户显式启用。</li>
<li>Beta：特性门控默认被弃用，可被用户显式禁用。</li>
<li>GA: 特性门控被弃用（参见<a href=#deprecation>弃用</a>），并且不再起作用。</li>
<li>GA，弃用窗口期结束：特性门控被删除，不再接受调用。</li>
</ul>
<h3 id=deprecation>弃用 </h3>
<p>功能特性在正式发布之前的生命周期内任何时间点都可被移除。
当未正式发布的功能特性被移除时，它们对应的特性门控也被弃用。</p>
<p>当尝试禁用一个不再起作用的特性门控时，该调用会失败，这样可以避免
毫无迹象地执行一些不受支持的场景。</p>
<p>在某些场合，移除一个即将正式发布的功能特性需要很长时间。特性门控
可以保持其功能，直到对应的功能特性被彻底去除，直到那时特性门控
自身才可被弃用。</p>
<p>由于移除一个已经正式发布的功能特性对应的特性门控也需要一定时间，对特性
门控的调用可能一直被允许，前提是特性门控对功能本身无影响且特性门控不会
引发任何错误。</p>
<p>意在允许用户禁用的功能特性应该包含一个在相关联的特性门控中禁用该功能的机制。</p>
<p>特性门控的版本管理与之前讨论的组件版本管理不同，因此其对应的弃用策略如下：</p>
<p><strong>规则 #8：特性门控所对应的功能特性经历下面所列的成熟性阶段转换时，特性门控
必须被弃用。特性门控弃用时必须在以下时长内保持其功能可用：</strong></p>
<ul>
<li><strong>Beta 特性转为 GA：6 个月或者 2 个发布版本（取其较长者）</strong></li>
<li><strong>Beta 特性转为丢弃：3 个月或者 1 个发布版本（取其较长者）</strong></li>
<li><strong>Alpha 特性转为丢弃：0 个发布版本</strong></li>
</ul>
<p><strong>规则 #9：已弃用的特色门控再被使用时必须给出警告回应。当特性门控被
弃用时，必须在发布说明和对应的 CLI 帮助信息中通过文档宣布。
警告信息和文档都要标明是否某特性门控不再起作用。</strong></p>
<h3 id=deprecating-a-metric>弃用度量值 </h3>
<p>Kubernetes 控制平面的每个组件都公开度量值（通常是 <code>/metrics</code> 端点），它们通常由集群管理员使用。
并不是所有的度量值都是同样重要的：一些度量值通常用作 SLIs 或被使用来确定 SLOs，这些往往比较重要。
其他度量值在本质上带有实验性，或者主要用于 Kubernetes 开发过程。</p>
<p>因此，度量值分为两个稳定性类别（<code>ALPHA</code> 和 <code>STABLE</code>）;
此分类会影响在 Kubernetes 发布版本中移除某度量值。
所对应的分类取决于对该度量值重要性的预期。
弃用和移除度量值的规则如下：</p>
<p><strong>规则 #9a: 对于相应的稳定性类别，度量值起作用的周期必须不小于：</strong></p>
<ul>
<li><strong>STABLE: 4 个发布版本或者 12 个月 (取其较长者)</strong></li>
<li><strong>ALPHA: 0 个发布版本</strong></li>
</ul>
<p><strong>规则 #9b: 在度量值被宣布启用之后，它起作用的周期必须不小于：</strong></p>
<ul>
<li><strong>STABLE: 3 个发布版本或者 9 个月 (取其较长者)</strong></li>
<li><strong>ALPHA: 0 个发布版本</strong></li>
</ul>
<p>已弃用的度量值将在其描述文本前加上一个已弃用通知字符串 '(Deprecated from x.y)'，
并将在度量值被记录期间发出警告日志。就像稳定的、未被弃用的度量指标一样，
被弃用的度量值将自动注册到 metrics 端点，因此被弃用的度量值也是可见的。</p>
<p>在随后的版本中（当度量值 <code>deprecatedVersion</code> 等于_当前 Kubernetes 版本 - 3_），
被弃用的度量值将变成 _隐藏（Hidden）_ metric 度量值。
与被弃用的度量值不同，隐藏的度量值将不再被自动注册到 metrics 端点（因此被隐藏）。
但是，它们可以通过可执行文件的命令行标志显式启用
（<code>--show-hidden-metrics-for-version=</code>）。
如果集群管理员不能对早期的弃用警告作出反应，这一设计就为他们提供了抓紧迁移弃用度量值的途径。
隐藏的度量值应该在再过一个发行版本后被删除。</p>
<h2 id=exceptions>例外 </h2>
<p>没有策略可以覆盖所有情况。此策略文档是一个随时被更新的文档，会随着时间
推移演化。在实践中，会有一些情况无法很好地匹配到这里的弃用策略，或者
这里的策略变成了很严重的羁绊。这类情形要与 SIG 和项目牵头人讨论，
寻求对应场景的最佳解决方案。请一直铭记，Kubernetes 承诺要成为一个
稳定的系统，至少会尽力做到不会影响到其用户。此弃用策略的任何例外情况
都会在所有相关的发布说明中公布。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-2479c39af50fd55b898a3bcfb5988077>2.5 - 已弃用 API 的迁移指南</h1>
<p>随着 Kubernetes API 的演化，APIs 会周期性地被重组或升级。
当 APIs 演化时，老的 API 会被弃用并被最终删除。
本页面包含你在将已弃用 API 版本迁移到新的更稳定的 API 版本时需要了解的知识。</p>
<h2 id=removed-apis-by-release>各发行版本中移除的 API </h2>
<h3 id=v1-26>v1.26</h3>
<p><strong>v1.26</strong> 发行版本中将去除以下已弃用的 API 版本：</p>
<h4 id=flowcontrol-resources-v126>流控制资源 </h4>
<p><strong>flowcontrol.apiserver.k8s.io/v1beta1</strong> API 版本的 FlowSchema
和 PriorityLevelConfiguration 将不会在 v1.26 中提供。</p>
<ul>
<li>迁移清单和 API 客户端使用 <strong>flowcontrol.apiserver.k8s.io/v1beta2</strong> API 版本，
此 API 从 v1.23 版本开始可用；</li>
<li>所有的已保存的对象都可以通过新的 API 来访问；</li>
<li>没有需要额外注意的变更</li>
</ul>
<h4 id=horizontalpodautoscaler-v126>HorizontalPodAutoscaler</h4>
<p><strong>autoscaling/v2beta2</strong> API 版本的 HorizontalPodAutoscaler 将不会在
v1.26 版本中提供。</p>
<ul>
<li>迁移清单和 API 客户端使用 <strong>autoscaling/v2</strong> API 版本，
此 API 从 v1.23 版本开始可用；</li>
<li>所有的已保存的对象都可以通过新的 API 来访问；</li>
</ul>
<h3 id=v1-25>v1.25</h3>
<p><strong>v1.25</strong> 发行版本将停止提供以下已废弃 API 版本：</p>
<h4 id=cronjob-v125>CronJob</h4>
<p><strong>batch/v1beta1</strong> API 版本的 CronJob 将不会在 v1.25 版本中继续提供。</p>
<ul>
<li>迁移清单和 API 客户端使用 <strong>batch/v1</strong> API 版本，此 API 从 v1.21 版本开始可用；</li>
<li>所有的已保存的对象都可以通过新的 API 来访问；</li>
<li>没有需要额外注意的变更</li>
</ul>
<h4 id=endpointslice-v125>EndpointSlice</h4>
<p><strong>discovery.k8s.io/v1beta1</strong> API 版本的 EndpointSlice 将不会在 v1.25 版本中继续提供。</p>
<ul>
<li>迁移清单和 API 客户端使用 <strong>discovery.k8s.io/v1</strong> API 版本，此 API 从 v1.21 版本开始可用；</li>
<li>所有的已保存的对象都可以通过新的 API 来访问；</li>
<li><strong>discovery.k8s.io/v1</strong> 中值得注意的变更有：
<ul>
<li>使用每个 Endpoint 的 <code>nodeName</code> 字段而不是已被弃用的
<code>topology["kubernetes.io/hostname"]</code> 字段；</li>
<li>使用每个 Endpoint 的 <code>zone</code> 字段而不是已被弃用的
<code>topology["kubernetes.io/zone"]</code> 字段；</li>
<li><code>topology</code> 字段被替换为 <code>deprecatedTopology</code>，并且在 v1 版本中不可写入。</li>
</ul>
</li>
</ul>
<h4 id=event-v125>Event</h4>
<p><strong>events.k8s.io/v1beta1</strong> API 版本的 Event 将不会在 v1.25 版本中继续提供。</p>
<ul>
<li>迁移清单和 API 客户端使用 <strong>events.k8s.io/v1</strong> API 版本，此 API 从 v1.19 版本开始可用；</li>
<li>所有的已保存的对象都可以通过新的 API 来访问；</li>
</ul>
<ul>
<li><strong>events.k8s.io/v1</strong> 中值得注意的变更有：
<ul>
<li><code>type</code> 字段只能设置为 <code>Normal</code> 和 <code>Warning</code> 之一；</li>
<li><code>involvedObject</code> 字段被更名为 <code>regarding</code>；</li>
<li><code>action</code>、<code>reason</code>、<code>reportingController</code> 和 <code>reportingInstance</code> 字段
在创建新的 <strong>events.k8s.io/v1</strong> 版本 Event 时都是必需的字段；</li>
<li>使用 <code>eventTime</code> 而不是已被弃用的 <code>firstTimestamp</code> 字段
（该字段已被更名为 <code>deprecatedFirstTimestamp</code>，且不允许出现在新的 <strong>events.k8s.io/v1</strong> Event 对象中）；</li>
<li>使用 <code>series.lastObservedTime</code> 而不是已被弃用的 <code>lastTimestamp</code> 字段
（该字段已被更名为 <code>deprecatedLastTimestamp</code>，且不允许出现在新的 <strong>events.k8s.io/v1</strong> Event 对象中）；</li>
<li>使用 <code>series.count</code> 而不是已被弃用的 <code>count</code> 字段
（该字段已被更名为 <code>deprecatedCount</code>，且不允许出现在新的 <strong>events.k8s.io/v1</strong> Event 对象中）；</li>
<li>使用 <code>reportingController</code> 而不是已被弃用的 <code>source.component</code> 字段
（该字段已被更名为 <code>deprecatedSource.component</code>，且不允许出现在新的 <strong>events.k8s.io/v1</strong> Event 对象中）；</li>
<li>使用 <code>reportingInstance</code> 而不是已被弃用的 <code>source.host</code> 字段
（该字段已被更名为 <code>deprecatedSource.host</code>，且不允许出现在新的 <strong>events.k8s.io/v1</strong> Event 对象中）。</li>
</ul>
</li>
</ul>
<h4 id=horizontalpodautoscaler-v125>HorizontalPodAutoscaler</h4>
<p><strong>autoscaling/v2beta1</strong> API 版本的 HorizontalPodAutoscaler 将不会在 v1.25 版本中继续提供。</p>
<ul>
<li>迁移清单和 API 客户端使用 <strong>autoscaling/v2</strong> API 版本，此 API 从 v1.23 版本开始可用；</li>
<li>所有的已保存的对象都可以通过新的 API 来访问；</li>
</ul>
<h4 id=poddisruptionbudget-v125>PodDisruptionBudget</h4>
<p><strong>policy/v1beta1</strong> API 版本的 PodDisruptionBudget 将不会在 v1.25 版本中继续提供。</p>
<ul>
<li>迁移清单和 API 客户端使用 <strong>policy/v1</strong> API 版本，此 API 从 v1.21 版本开始可用；</li>
<li>所有的已保存的对象都可以通过新的 API 来访问；</li>
<li><strong>policy/v1</strong> 中需要额外注意的变更有：
<ul>
<li>在 <code>policy/v1</code> 版本的 PodDisruptionBudget 中将 <code>spec.selector</code>
设置为空（<code>{}</code>）时会选择名字空间中的所有 Pods（在 <code>policy/v1beta1</code>
版本中，空的 <code>spec.selector</code> 不会选择任何 Pods）。如果 <code>spec.selector</code>
未设置，则在两个 API 版本下都不会选择任何 Pods。</li>
</ul>
</li>
</ul>
<h4 id=psp-v125>PodSecurityPolicy</h4>
<p><strong>policy/v1beta1</strong> API 版本中的 PodSecurityPolicy 将不会在 v1.25 中提供，
并且 PodSecurityPolicy 准入控制器也会被删除。</p>
<p>PodSecurityPolicy 的替换方案仍在讨论过程中，不过当前的用法可以迁移到
<a href=/zh/docs/reference/access-authn-authz/extensible-admission-controllers/>第三方准入性质的 Webhook</a>。</p>
<h4 id=runtimeclass-v125>RuntimeClass</h4>
<p><strong>node.k8s.io/v1beta1</strong> API 版本中的 RuntimeClass 将不会在 v1.25 中提供。</p>
<ul>
<li>迁移清单和 API 客户端使用 <strong>node.k8s.io/v1</strong> API 版本，此 API 从 v1.20 版本开始可用；</li>
<li>所有的已保存的对象都可以通过新的 API 来访问；</li>
<li>没有需要额外注意的变更</li>
</ul>
<h3 id=v1-22>v1.22</h3>
<p><strong>v1.22</strong> 发行版本停止提供以下已废弃 API 版本：</p>
<h4 id=webhook-resources-v122>Webhook 资源 </h4>
<p><strong>admissionregistration.k8s.io/v1beta1</strong> API 版本的 MutatingWebhookConfiguration
和 ValidatingWebhookConfiguration 不在 v1.22 版本中继续提供。</p>
<ul>
<li>迁移清单和 API 客户端使用 <strong>admissionregistration.k8s.io/v1</strong> API 版本，
此 API 从 v1.16 版本开始可用；</li>
<li>所有的已保存的对象都可以通过新的 API 来访问；</li>
</ul>
<ul>
<li>值得注意的变更：
<ul>
<li><code>webhooks[*].failurePolicy</code> 在 v1 版本中默认值从 <code>Ignore</code> 改为 <code>Fail</code></li>
<li><code>webhooks[*].matchPolicy</code> 在 v1 版本中默认值从 <code>Exact</code> 改为 <code>Equivalent</code></li>
<li><code>webhooks[*].timeoutSeconds</code> 在 v1 版本中默认值从 <code>30s</code> 改为 <code>10s</code></li>
<li><code>webhooks[*].sideEffects</code> 的默认值被删除，并且该字段变为必须指定；
在 v1 版本中可选的值只能是 <code>None</code> 和 <code>NoneOnDryRun</code> 之一</li>
<li><code>webhooks[*].admissionReviewVersions</code> 的默认值被删除，在 v1
版本中此字段变为必须指定（AdmissionReview 的被支持版本包括 <code>v1</code> 和 <code>v1beta1</code>）</li>
<li><code>webhooks[*].name</code> 必须在通过 <code>admissionregistration.k8s.io/v1</code>
创建的对象列表中唯一</li>
</ul>
</li>
</ul>
<h4 id=customresourcedefinition-v122>CustomResourceDefinition</h4>
<p><strong>apiextensions.k8s.io/v1beta1</strong> API 版本的 CustomResourceDefinition
不在 v1.22 版本中继续提供。</p>
<ul>
<li>迁移清单和 API 客户端使用 <strong>apiextensions/v1</strong> API 版本，此 API 从 v1.16 版本开始可用；</li>
<li>所有的已保存的对象都可以通过新的 API 来访问；</li>
</ul>
<ul>
<li>值得注意的变更：
<ul>
<li><code>spec.scope</code> 的默认值不再是 <code>Namespaced</code>，该字段必须显式指定</li>
<li><code>spec.version</code> 在 v1 版本中被删除；应改用 <code>spec.versions</code></li>
<li><code>spec.validation</code> 在 v1 版本中被删除；应改用 <code>spec.versions[*].schema</code></li>
<li><code>spec.subresources</code> 在 v1 版本中被删除；应改用 <code>spec.versions[*].subresources</code></li>
<li><code>spec.additionalPrinterColumns</code> 在 v1 版本中被删除；应改用
<code>spec.versions[*].additionalPrinterColumns</code></li>
<li><code>spec.conversion.webhookClientConfig</code> 在 v1 版本中被移动到
<code>spec.conversion.webhook.clientConfig</code> 中</li>
</ul>
<ul>
<li><code>spec.conversion.conversionReviewVersions</code> 在 v1 版本中被移动到
<code>spec.conversion.webhook.conversionReviewVersions</code></li>
<li><code>spec.versions[*].schema.openAPIV3Schema</code> 在创建 v1 版本的
CustomResourceDefinition 对象时变成必需字段，并且其取值必须是一个
<a href=/zh/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/#specifying-a-structural-schema>结构化的 Schema</a></li>
<li><code>spec.preserveUnknownFields: true</code> 在创建 v1 版本的 CustomResourceDefinition
对象时不允许指定；该配置必须在 Schema 定义中使用
<code>x-kubernetes-preserve-unknown-fields: true</code> 来设置</li>
<li>在 v1 版本中，<code>additionalPrinterColumns</code> 的条目中的 <code>JSONPath</code> 字段被更名为
<code>jsonPath</code>（补丁 <a href=https://github.com/kubernetes/kubernetes/issues/66531>#66531</a>）</li>
</ul>
</li>
</ul>
<h4 id=apiservice-v122>APIService</h4>
<p><strong>apiregistration/v1beta1</strong> API 版本的 APIService 不在 v1.22 版本中继续提供。</p>
<ul>
<li>迁移清单和 API 客户端使用 <strong>apiregistration.k8s.io/v1</strong> API 版本，此 API 从
v1.10 版本开始可用；</li>
<li>所有的已保存的对象都可以通过新的 API 来访问；</li>
<li>没有需要额外注意的变更</li>
</ul>
<h4 id=tokenreview-v122>TokenReview</h4>
<p><strong>authentication.k8s.io/v1beta1</strong> API 版本的 TokenReview 不在 v1.22 版本中继续提供。</p>
<ul>
<li>迁移清单和 API 客户端使用 <strong>authentication.k8s.io/v1</strong> API 版本，此 API 从
v1.6 版本开始可用；</li>
<li>所有的已保存的对象都可以通过新的 API 来访问；</li>
<li>没有需要额外注意的变更</li>
</ul>
<h4 id=subjectaccessreview-resources-v122>SubjectAccessReview resources</h4>
<p><strong>authorization.k8s.io/v1beta1</strong> API 版本的 LocalSubjectAccessReview、
SelfSubjectAccessReview、SubjectAccessReview 不在 v1.22 版本中继续提供。</p>
<ul>
<li>迁移清单和 API 客户端使用 <strong>authorization.k8s.io/v1</strong> API 版本，此 API 从
v1.6 版本开始可用；</li>
<li>所有的已保存的对象都可以通过新的 API 来访问；</li>
<li>需要额外注意的变更：
<ul>
<li><code>spec.group</code> 在 v1 版本中被更名为 <code>spec.groups</code>
（补丁 <a href=https://github.com/kubernetes/kubernetes/issues/32709>#32709</a>）</li>
</ul>
</li>
</ul>
<h4 id=certificatesigningrequest-v122>CertificateSigningRequest</h4>
<p><strong>certificates.k8s.io/v1beta1</strong> API 版本的 CertificateSigningRequest 不在
v1.22 版本中继续提供。</p>
<ul>
<li>迁移清单和 API 客户端使用 <strong>certificates.k8s.io/v1</strong> API 版本，此 API 从
v1.19 版本开始可用；</li>
<li>所有的已保存的对象都可以通过新的 API 来访问；</li>
</ul>
<ul>
<li><code>certificates.k8s.io/v1</code> 中需要额外注意的变更：
<ul>
<li>对于请求证书的 API 客户端而言：
<ul>
<li><code>spec.signerName</code> 现在变成必需字段（参阅
<a href=/zh/docs/reference/access-authn-authz/certificate-signing-requests/#kubernetes-signers>已知的 Kubernetes 签署者</a>），
并且通过 <code>certificates.k8s.io/v1</code> API 不可以创建签署者为
<code>kubernetes.io/legacy-unknown</code> 的请求</li>
<li><code>spec.usages</code> 现在变成必需字段，其中不可以包含重复的字符串值，
并且只能包含已知的用法字符串</li>
</ul>
</li>
<li>对于要批准或者签署证书的 API 客户端而言：
<ul>
<li><code>status.conditions</code> 中不可以包含重复的类型</li>
<li><code>status.conditions[*].status</code> 字段现在变为必需字段</li>
<li><code>status.certificate</code> 必须是 PEM 编码的，而且其中只能包含 <code>CERTIFICATE</code>
数据块</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id=lease-v122>Lease</h4>
<p><strong>coordination.k8s.io/v1beta1</strong> API 版本的 Lease 不在 v1.22 版本中继续提供。</p>
<ul>
<li>迁移清单和 API 客户端使用 <strong>coordination.k8s.io/v1</strong> API 版本，此 API 从
v1.14 版本开始可用；</li>
<li>所有的已保存的对象都可以通过新的 API 来访问；</li>
<li>没有需要额外注意的变更</li>
</ul>
<h4 id=ingress-v122>Ingress</h4>
<p><strong>extensions/v1beta1</strong> 和 <strong>networking.k8s.io/v1beta1</strong> API 版本的 Ingress
不在 v1.22 版本中继续提供。</p>
<ul>
<li>迁移清单和 API 客户端使用 <strong>networking.k8s.io/v1</strong> API 版本，此 API 从
v1.19 版本开始可用；</li>
<li>所有的已保存的对象都可以通过新的 API 来访问；</li>
</ul>
<ul>
<li>值得注意的变更：
<ul>
<li><code>spec.backend</code> 字段被更名为 <code>spec.defaultBackend</code></li>
<li>后端的 <code>serviceName</code> 字段被更名为 <code>service.name</code></li>
<li>数值表示的后端 <code>servicePort</code> 字段被更名为 <code>service.port.number</code></li>
<li>字符串表示的后端 <code>servicePort</code> 字段被更名为 <code>service.port.name</code></li>
<li>对所有要指定的路径，<code>pathType</code> 都成为必需字段。
可选项为 <code>Prefix</code>、<code>Exact</code> 和 <code>ImplementationSpecific</code>。
要匹配 <code>v1beta1</code> 版本中未定义路径类型时的行为，可使用 <code>ImplementationSpecific</code></li>
</ul>
</li>
</ul>
<h4 id=ingressclass-v122>IngressClass</h4>
<p><strong>networking.k8s.io/v1beta1</strong> API 版本的 IngressClass 不在 v1.22 版本中继续提供。</p>
<ul>
<li>迁移清单和 API 客户端使用 <strong>networking.k8s.io/v1</strong> API 版本，此 API 从
v1.19 版本开始可用；</li>
<li>所有的已保存的对象都可以通过新的 API 来访问；</li>
<li>没有需要额外注意的变更</li>
</ul>
<h4 id=rbac-resources-v122>RBAC 资源 </h4>
<p><strong>rbac.authorization.k8s.io/v1beta1</strong> API 版本的 ClusterRole、ClusterRoleBinding、
Role 和 RoleBinding 不在 v1.22 版本中继续提供。</p>
<ul>
<li>迁移清单和 API 客户端使用 <strong>rbac.authorization.k8s.io/v1</strong> API 版本，此 API 从
v1.8 版本开始可用；</li>
<li>所有的已保存的对象都可以通过新的 API 来访问；</li>
<li>没有需要额外注意的变更</li>
</ul>
<h4 id=priorityclass-v122>PriorityClass</h4>
<p><strong>scheduling.k8s.io/v1beta1</strong> API 版本的 PriorityClass 不在 v1.22 版本中继续提供。</p>
<ul>
<li>迁移清单和 API 客户端使用 <strong>scheduling.k8s.io/v1</strong> API 版本，此 API 从
v1.14 版本开始可用；</li>
<li>所有的已保存的对象都可以通过新的 API 来访问；</li>
<li>没有需要额外注意的变更</li>
</ul>
<h4 id=storage-resources-v122>存储资源 </h4>
<p><strong>storage.k8s.io/v1beta1</strong> API 版本的 CSIDriver、CSINode、StorageClass
和 VolumeAttachment 不在 v1.22 版本中继续提供。</p>
<ul>
<li>迁移清单和 API 客户端使用 <strong>storage.k8s.io/v1</strong> API 版本
<ul>
<li>CSIDriver 从 v1.19 版本开始在 <strong>storage.k8s.io/v1</strong> 中提供；</li>
<li>CSINode 从 v1.17 版本开始在 <strong>storage.k8s.io/v1</strong> 中提供；</li>
<li>StorageClass 从 v1.6 版本开始在 <strong>storage.k8s.io/v1</strong> 中提供；</li>
<li>VolumeAttachment 从 v1.13 版本开始在 <strong>storage.k8s.io/v1</strong> 中提供；</li>
</ul>
</li>
<li>所有的已保存的对象都可以通过新的 API 来访问；</li>
<li>没有需要额外注意的变更</li>
</ul>
<h3 id=v1-16>v1.16</h3>
<p><strong>v1.16</strong> 发行版本停止提供以下已废弃 API 版本：</p>
<h4 id=networkpolicy-v116>NetworkPolicy</h4>
<p><strong>extensions/v1beta1</strong> API 版本的 NetworkPolicy 不在 v1.16 版本中继续提供。</p>
<ul>
<li>迁移清单和 API 客户端使用 <strong>networking.k8s.io/v1</strong> API 版本，此 API 从
v1.8 版本开始可用；</li>
<li>所有的已保存的对象都可以通过新的 API 来访问；</li>
</ul>
<h4 id=daemonset-v116>DaemonSet</h4>
<p><strong>extensions/v1beta1</strong> 和 <strong>apps/v1beta2</strong> API 版本的 DaemonSet 在
v1.16 版本中不再继续提供。</p>
<ul>
<li>迁移清单和 API 客户端使用 <strong>apps/v1</strong> API 版本，此 API 从 v1.9 版本开始可用；</li>
<li>所有的已保存的对象都可以通过新的 API 来访问；</li>
</ul>
<ul>
<li>值得注意的变更：
<ul>
<li><code>spec.templateGeneration</code> 字段被删除</li>
<li><code>spec.selector</code> 现在变成必需字段，并且在对象创建之后不可变更；
可以将现有模板的标签作为选择算符以实现无缝迁移。</li>
<li><code>spec.updateStrategy.type</code> 的默认值变为 <code>RollingUpdate</code>
（<code>extensions/v1beta1</code> API 版本中的默认值是 <code>OnDelete</code>）。</li>
</ul>
</li>
</ul>
<h4 id=deployment-v116>Deployment</h4>
<p><strong>extensions/v1beta1</strong>、<strong>apps/v1beta1</strong> 和 <strong>apps/v1beta2</strong> API 版本的
Deployment 在 v1.16 版本中不再继续提供。</p>
<ul>
<li>迁移清单和 API 客户端使用 <strong>apps/v1</strong> API 版本，此 API 从 v1.9 版本开始可用；</li>
<li>所有的已保存的对象都可以通过新的 API 来访问；</li>
</ul>
<ul>
<li>值得注意的变更：
<ul>
<li><code>spec.rollbackTo</code> 字段被删除</li>
<li><code>spec.selector</code> 字段现在变为必需字段，并且在 Deployment 创建之后不可变更；
可以使用现有的模板的标签作为选择算符以实现无缝迁移。</li>
<li><code>spec.progressDeadlineSeconds</code> 的默认值变为 <code>600</code> 秒
（<code>extensions/v1beta1</code> 中的默认值是没有期限）</li>
<li><code>spec.revisionHistoryLimit</code> 的默认值变为 <code>10</code>
（<code>apps/v1beta1</code> API 版本中此字段默认值为 <code>2</code>，在<code>extensions/v1beta1</code> API
版本中的默认行为是保留所有历史记录）。</li>
<li><code>maxSurge</code> 和 <code>maxUnavailable</code> 的默认值变为 <code>25%</code>
（在 <code>extensions/v1beta1</code> API 版本中，这些字段的默认值是 <code>1</code>）。</li>
</ul>
</li>
</ul>
<h4 id=statefulset-v116>StatefulSet</h4>
<p><strong>apps/v1beta1</strong> 和 <strong>apps/v1beta2</strong> API 版本的 StatefulSet 在 v1.16 版本中不再继续提供。</p>
<ul>
<li>迁移清单和 API 客户端使用 <strong>apps/v1</strong> API 版本，此 API 从 v1.9 版本开始可用；</li>
<li>所有的已保存的对象都可以通过新的 API 来访问；</li>
</ul>
<ul>
<li>值得注意的变更：
<ul>
<li><code>spec.selector</code> 字段现在变为必需字段，并且在 StatefulSet 创建之后不可变更；
可以使用现有的模板的标签作为选择算符以实现无缝迁移。</li>
<li><code>spec.updateStrategy.type</code> 的默认值变为 <code>RollingUpdate</code>
（<code>apps/v1beta1</code> API 版本中的默认值是 <code>OnDelete</code>）。</li>
</ul>
</li>
</ul>
<h4 id=replicaset-v116>ReplicaSet</h4>
<p><strong>extensions/v1beta1</strong>、<strong>apps/v1beta1</strong> 和 <strong>apps/v1beta2</strong> API 版本的
ReplicaSet 在 v1.16 版本中不再继续提供。</p>
<ul>
<li>迁移清单和 API 客户端使用 <strong>apps/v1</strong> API 版本，此 API 从 v1.9 版本开始可用；</li>
<li>所有的已保存的对象都可以通过新的 API 来访问；</li>
</ul>
<ul>
<li>值得注意的变更：
<ul>
<li><code>spec.selector</code> 现在变成必需字段，并且在对象创建之后不可变更；
可以将现有模板的标签作为选择算符以实现无缝迁移。</li>
</ul>
</li>
</ul>
<h4 id=psp-v116>PodSecurityPolicy</h4>
<p><strong>extensions/v1beta1</strong> API 版本的 PodSecurityPolicy 在 v1.16 版本中不再继续提供。</p>
<ul>
<li>迁移清单和 API 客户端使用 <strong>policy/v1beta1</strong> API 版本，此 API 从 v1.10 版本开始可用；</li>
<li>注意 <strong>policy/v1beta1</strong> API 版本的 PodSecurityPolicy 会在 v1.25 版本中移除。</li>
</ul>
<h2 id=what-to-do>需要做什么 </h2>
<h3 id=在禁用已启用-api-的情况下执行测试>在禁用已启用 API 的情况下执行测试</h3>
<p>你可以通过在启动 API 服务器时禁用特定的 API 版本来模拟即将发生的
API 移除，从而完成测试。在 API 服务器启动参数中添加如下标志：</p>
<p><code>--runtime-config=&lt;group>/&lt;version>=false</code></p>
<p>例如：</p>
<p><code>--runtime-config=admissionregistration.k8s.io/v1beta1=false,apiextensions.k8s.io/v1beta1,...</code></p>
<h3 id=定位何处使用了已弃用的-api>定位何处使用了已弃用的 API</h3>
<p>使用 <a href=https://kubernetes.io/blog/2020/09/03/warnings/#deprecation-warnings>client warnings, metrics, and audit information available in 1.19+</a>
来定位在何处使用了已启用的 API。</p>
<h3 id=迁移到未被弃用的-api>迁移到未被弃用的 API</h3>
<ul>
<li>更新自定义的集成组件和控制器，调用未被弃用的 API</li>
<li>更改 YAML 文件引用未被弃用的 API</li>
</ul>
<p>你可以用 <code>kubectl-convert</code> 命令（在 v1.20 之前是 <code>kubectl convert</code>）
来自动转换现有对象：</p>
<p><code>kubectl-convert -f &lt;file> --output-version &lt;group>/&lt;version></code>.</p>
<p>例如，要将较老的 Deployment 转换为 <code>apps/v1</code> 版本，你可以运行</p>
<p><code>kubectl-convert -f ./my-deployment.yaml --output-version apps/v1</code></p>
<p>注意这种操作生成的结果中可能使用的默认值并不理想。
要进一步了解某个特定资源，可查阅 Kubernetes <a href=/zh/docs/reference/kubernetes-api/>API 参考</a>。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-e4dbb59f8f23854d7b7d574e169923c4>2.6 - Kubernetes API 健康端点</h1>
<p>Kubernetes <a class=glossary-tooltip title="提供 Kubernetes API 服务的控制面组件。" data-toggle=tooltip data-placement=top href=/zh/docs/reference/command-line-tools-reference/kube-apiserver/ target=_blank aria-label="API 服务器">API 服务器</a> 提供 API 端点以指示 API 服务器的当前状态。
本文描述了这些 API 端点，并说明如何使用。</p>
<h2 id=api-endpoints-for-health>API 健康端点 </h2>
<p>Kubernetes API 服务器提供 3 个 API 端点（<code>healthz</code>、<code>livez</code> 和 <code>readyz</code>）来表明 API 服务器的当前状态。
<code>healthz</code> 端点已被弃用（自 Kubernetes v1.16 起），你应该使用更为明确的 <code>livez</code> 和 <code>readyz</code> 端点。
<code>livez</code> 端点可与 <code>--livez-grace-period</code> <a href=/zh/docs/reference/command-line-tools-reference/kube-apiserver>标志</a>一起使用，来指定启动持续时间。
为了正常关机，你可以使用 <code>/readyz</code> 端点并指定 <code>--shutdown-delay-duration</code> <a href=/zh/docs/reference/command-line-tools-reference/kube-apiserver>标志</a>。
检查 API 服务器的 <code>healthz</code>/<code>livez</code>/<code>readyz</code> 端点的机器应依赖于 HTTP 状态代码。
状态码 <code>200</code> 表示 API 服务器是 <code>healthy</code>、<code>live</code> 还是 <code>ready</code>，具体取决于所调用的端点。
以下更详细的选项供操作人员使用，用来调试其集群或了解 API 服务器的状态。</p>
<p>以下示例将显示如何与运行状况 API 端点进行交互。</p>
<p>对于所有端点，都可以使用 <code>verbose</code> 参数来打印检查项以及检查状态。
这对于操作人员调试 API 服务器的当前状态很有用，这些不打算给机器使用：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>curl -k https://localhost:6443/livez?verbose
</code></pre></div>
<p>或从具有身份验证的远程主机：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get --raw<span style=color:#666>=</span><span style=color:#b44>&#39;/readyz?verbose&#39;</span>
</code></pre></div>
<p>输出将如下所示：</p>
<pre><code>[+]ping ok
[+]log ok
[+]etcd ok
[+]poststarthook/start-kube-apiserver-admission-initializer ok
[+]poststarthook/generic-apiserver-start-informers ok
[+]poststarthook/start-apiextensions-informers ok
[+]poststarthook/start-apiextensions-controllers ok
[+]poststarthook/crd-informer-synced ok
[+]poststarthook/bootstrap-controller ok
[+]poststarthook/rbac/bootstrap-roles ok
[+]poststarthook/scheduling/bootstrap-system-priority-classes ok
[+]poststarthook/start-cluster-authentication-info-controller ok
[+]poststarthook/start-kube-aggregator-informers ok
[+]poststarthook/apiservice-registration-controller ok
[+]poststarthook/apiservice-status-available-controller ok
[+]poststarthook/kube-apiserver-autoregistration ok
[+]autoregister-completion ok
[+]poststarthook/apiservice-openapi-controller ok
healthz check passed
</code></pre>
<p>Kubernetes API 服务器也支持排除特定的检查项。
查询参数也可以像以下示例一样进行组合：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>curl -k <span style=color:#b44>&#39;https://localhost:6443/readyz?verbose&amp;exclude=etcd&#39;</span>
</code></pre></div>
<p>输出显示排除了 <code>etcd</code> 检查：</p>
<pre><code>[+]ping ok
[+]log ok
[+]etcd excluded: ok
[+]poststarthook/start-kube-apiserver-admission-initializer ok
[+]poststarthook/generic-apiserver-start-informers ok
[+]poststarthook/start-apiextensions-informers ok
[+]poststarthook/start-apiextensions-controllers ok
[+]poststarthook/crd-informer-synced ok
[+]poststarthook/bootstrap-controller ok
[+]poststarthook/rbac/bootstrap-roles ok
[+]poststarthook/scheduling/bootstrap-system-priority-classes ok
[+]poststarthook/start-cluster-authentication-info-controller ok
[+]poststarthook/start-kube-aggregator-informers ok
[+]poststarthook/apiservice-registration-controller ok
[+]poststarthook/apiservice-status-available-controller ok
[+]poststarthook/kube-apiserver-autoregistration ok
[+]autoregister-completion ok
[+]poststarthook/apiservice-openapi-controller ok
[+]shutdown ok
healthz check passed
</code></pre>
<h2 id=individual-health-check>独立健康检查 </h2>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.23 [alpha]</code>
</div>
<p>每个单独的健康检查都会公开一个 HTTP 端点，并且可以单独检查。
单个运行状况检查的模式为 <code>/livez/&lt;healthcheck-name></code>，其中 <code>livez</code> 和 <code>readyz</code> 表明你要检查的是 API 服务器是否存活或就绪。
<code>&lt;healthcheck-name></code> 的路径可以通过上面的 <code>verbose</code> 参数发现 ，并采用 <code>[+]</code> 和 <code>ok</code> 之间的路径。
这些单独的健康检查不应由机器使用，但对于操作人员调试系统而言，是有帮助的：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>curl -k https://localhost:6443/livez/etcd
</code></pre></div>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-99b26586d8a33ec06996dcf7892a9683>3 - API 访问控制</h1>
<p>关于 Kubernetes 如何实现和控制 API 访问的介绍性材料，可阅读
<a href=/zh/docs/concepts/security/controlling-access/>控制 Kubernetes API 的访问</a>。</p>
<p>参考文档：</p>
<ul>
<li><a href=/zh/docs/reference/access-authn-authz/authentication/>身份认证</a>
<ul>
<li><a href=/zh/docs/reference/access-authn-authz/bootstrap-tokens/>使用启动引导令牌来执行身份认证</a></li>
</ul>
</li>
<li><a href=/zh/docs/reference/access-authn-authz/admission-controllers/>准入控制器</a>
<ul>
<li><a href=/zh/docs/reference/access-authn-authz/extensible-admission-controllers/>动态准入控制</a></li>
</ul>
</li>
<li><a href=/zh/docs/reference/access-authn-authz/authorization/>鉴权与授权</a>
<ul>
<li><a href=/zh/docs/reference/access-authn-authz/rbac/>基于角色的访问控制</a></li>
<li><a href=/zh/docs/reference/access-authn-authz/abac/>基于属性的访问控制</a></li>
<li><a href=/zh/docs/reference/access-authn-authz/node/>节点鉴权</a></li>
<li><a href=/zh/docs/reference/access-authn-authz/webhook/>Webhook 鉴权</a></li>
</ul>
</li>
<li><a href=/zh/docs/reference/access-authn-authz/certificate-signing-requests/>证书签名请求</a>
<ul>
<li>包含 <a href=/zh/docs/reference/access-authn-authz/certificate-signing-requests/#approval-rejection>CSR 的批复</a>
和<a href=/zh/docs/reference/access-authn-authz/certificate-signing-requests/#signing>证书签名</a></li>
</ul>
</li>
<li>服务账号
<ul>
<li><a href=/zh/docs/tasks/configure-pod-container/configure-service-account/>开发者指南</a></li>
<li><a href=/zh/docs/reference/access-authn-authz/service-accounts-admin/>管理文档</a></li>
</ul>
</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-a6264859a5ad6e2f4a6e4cff9ce4fa8b>3.1 - 用户认证</h1>
<p>本页提供身份认证有关的概述。</p>
<h2 id=users-in-kubernetes>Kubernetes 中的用户 </h2>
<p>所有 Kubernetes 集群都有两类用户：由 Kubernetes 管理的服务账号和普通用户。</p>
<p>Kubernetes 假定普通用户是由一个与集群无关的服务通过以下方式之一进行管理的：</p>
<ul>
<li>负责分发私钥的管理员</li>
<li>类似 Keystone 或者 Google Accounts 这类用户数据库</li>
<li>包含用户名和密码列表的文件</li>
</ul>
<p>有鉴于此，<em>Kubernetes 并不包含用来代表普通用户账号的对象</em>。
普通用户的信息无法通过 API 调用添加到集群中。</p>
<p>尽管无法通过 API 调用来添加普通用户，Kubernetes 仍然认为能够提供由集群的证书
机构签名的合法证书的用户是通过身份认证的用户。基于这样的配置，Kubernetes
使用证书中的 'subject' 的通用名称（Common Name）字段（例如，"/CN=bob"）来
确定用户名。接下来，基于角色访问控制（RBAC）子系统会确定用户是否有权针对
某资源执行特定的操作。进一步的细节可参阅
<a href=/zh/docs/reference/access-authn-authz/certificate-signing-requests/#normal-user>证书请求</a>
下普通用户主题。</p>
<p>与此不同，服务账号是 Kubernetes API 所管理的用户。它们被绑定到特定的名字空间，
或者由 API 服务器自动创建，或者通过 API 调用创建。服务账号与一组以 Secret 保存
的凭据相关，这些凭据会被挂载到 Pod 中，从而允许集群内的进程访问 Kubernetes
API。</p>
<p>API 请求则或者与某普通用户相关联，或者与某服务账号相关联，亦或者被视作
<a href=#anonymous-requests>匿名请求</a>。这意味着集群内外的每个进程在向 API 服务器发起
请求时都必须通过身份认证，否则会被视作匿名用户。这里的进程可以是在某工作站上
输入 <code>kubectl</code> 命令的操作人员，也可以是节点上的 <code>kubelet</code> 组件，还可以是控制面
的成员。</p>
<h2 id=authentication-strategies>身份认证策略 </h2>
<p>Kubernetes 通过身份认证插件利用客户端证书、持有者令牌（Bearer Token）或身份认证代理（Proxy）
来认证 API 请求的身份。HTTP 请求发给 API 服务器时，插件会将以下属性关联到请求本身：</p>
<ul>
<li>用户名：用来辩识最终用户的字符串。常见的值可以是 <code>kube-admin</code> 或 <code>jane@example.com</code>。</li>
<li>用户 ID：用来辩识最终用户的字符串，旨在比用户名有更好的一致性和唯一性。</li>
<li>用户组：取值为一组字符串，其中各个字符串用来标明用户是某个命名的用户逻辑集合的成员。
常见的值可能是 <code>system:masters</code> 或者 <code>devops-team</code> 等。</li>
<li>附加字段：一组额外的键-值映射，键是字符串，值是一组字符串；用来保存一些鉴权组件可能
觉得有用的额外信息。</li>
</ul>
<p>所有（属性）值对于身份认证系统而言都是不透明的，只有被
<a href=/zh/docs/reference/access-authn-authz/authorization/>鉴权组件</a>
解释过之后才有意义。</p>
<p>你可以同时启用多种身份认证方法，并且你通常会至少使用两种方法：</p>
<ul>
<li>针对服务账号使用服务账号令牌</li>
<li>至少另外一种方法对用户的身份进行认证</li>
</ul>
<p>当集群中启用了多个身份认证模块时，第一个成功地对请求完成身份认证的模块会
直接做出评估决定。API 服务器并不保证身份认证模块的运行顺序。</p>
<p>对于所有通过身份认证的用户，<code>system:authenticated</code> 组都会被添加到其组列表中。</p>
<p>与其它身份认证协议（LDAP、SAML、Kerberos、X509 的替代模式等等）都可以通过
使用一个<a href=#authenticating-proxy>身份认证代理</a>或
<a href=#webhook-token-authentication>身份认证 Webhoook</a>来实现。</p>
<h3 id=x509-client-certs>X509 客户证书 </h3>
<p>通过给 API 服务器传递 <code>--client-ca-file=SOMEFILE</code> 选项，就可以启动客户端证书身份认证。
所引用的文件必须包含一个或者多个证书机构，用来验证向 API 服务器提供的客户端证书。
如果提供了客户端证书并且证书被验证通过，则 subject 中的公共名称（Common Name）就被
作为请求的用户名。
自 Kubernetes 1.4 开始，客户端证书还可以通过证书的 organization 字段标明用户的组成员信息。
要包含用户的多个组成员信息，可以在证书种包含多个 organization 字段。</p>
<p>例如，使用 <code>openssl</code> 命令行工具生成一个证书签名请求：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>openssl req -new -key jbeda.pem -out jbeda-csr.pem -subj <span style=color:#b44>&#34;/CN=jbeda/O=app1/O=app2&#34;</span>
</code></pre></div>
<p>此命令将使用用户名 <code>jbeda</code> 生成一个证书签名请求（CSR），且该用户属于 "app" 和
"app2" 两个用户组。</p>
<p>参阅<a href=/zh/docs/tasks/administer-cluster/certificates/>管理证书</a>了解如何生成客户端证书。</p>
<h3 id=static-token-file>静态令牌文件 </h3>
<p>当 API 服务器的命令行设置了 <code>--token-auth-file=SOMEFILE</code> 选项时，会从文件中
读取持有者令牌。目前，令牌会长期有效，并且在不重启 API 服务器的情况下
无法更改令牌列表。</p>
<p>令牌文件是一个 CSV 文件，包含至少 3 个列：令牌、用户名和用户的 UID。
其余列被视为可选的组名。</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> <p>如果要设置的组名不止一个，则对应的列必须用双引号括起来，例如</p>
<pre><code class=language-conf data-lang=conf>token,user,uid,&quot;group1,group2,group3&quot;
</code></pre>
</div>
<h4 id=putting-a-bearer-token-in-a-request>在请求中放入持有者令牌 </h4>
<p>当使用持有者令牌来对某 HTTP 客户端执行身份认证时，API 服务器希望看到
一个名为 <code>Authorization</code> 的 HTTP 头，其值格式为 <code>Bearer &lt;token></code>。
持有者令牌必须是一个可以放入 HTTP 头部值字段的字符序列，至多可使用
HTTP 的编码和引用机制。
例如：如果持有者令牌为 <code>31ada4fd-adec-460c-809a-9e56ceb75269</code>，则其
出现在 HTTP 头部时如下所示：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-http data-lang=http><span>Authorization: Bearer 31ada4fd-adec-460c-809a-9e56ceb75269
</span></code></pre></div>
<h3 id=bootstrap-tokens>启动引导令牌 </h3>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.18 [stable]</code>
</div>
<p>为了支持平滑地启动引导新的集群，Kubernetes 包含了一种动态管理的持有者令牌类型，
称作 <em>启动引导令牌（Bootstrap Token）</em>。
这些令牌以 Secret 的形式保存在 <code>kube-system</code> 名字空间中，可以被动态管理和创建。
控制器管理器包含的 <code>TokenCleaner</code> 控制器能够在启动引导令牌过期时将其删除。</p>
<p>这些令牌的格式为 <code>[a-z0-9]{6}.[a-z0-9]{16}</code>。第一个部分是令牌的 ID；第二个部分
是令牌的 Secret。你可以用如下所示的方式来在 HTTP 头部设置令牌：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-http data-lang=http><span>Authorization: Bearer 781292.db7bc3a58fc5f07e
</span></code></pre></div>
<p>你必须在 API 服务器上设置 <code>--enable-bootstrap-token-auth</code> 标志来启用基于启动
引导令牌的身份认证组件。
你必须通过控制器管理器的 <code>--controllers</code> 标志来启用 TokenCleaner 控制器；
这可以通过类似 <code>--controllers=*,tokencleaner</code> 这种设置来做到。
如果你使用 <code>kubeadm</code> 来启动引导新的集群，该工具会帮你完成这些设置。</p>
<p>身份认证组件的认证结果为 <code>system:bootstrap:&lt;令牌 ID></code>，该用户属于
<code>system:bootstrappers</code> 用户组。
这里的用户名和组设置都是有意设计成这样，其目的是阻止用户在启动引导集群之后
继续使用这些令牌。
这里的用户名和组名可以用来（并且已经被 <code>kubeadm</code> 用来）构造合适的鉴权
策略，以完成启动引导新集群的工作。</p>
<p>请参阅<a href=/zh/docs/reference/access-authn-authz/bootstrap-tokens/>启动引导令牌</a>
以了解关于启动引导令牌身份认证组件与控制器的更深入的信息，以及如何使用
<code>kubeadm</code> 来管理这些令牌。</p>
<h3 id=service-account-tokens>服务账号令牌 </h3>
<p>服务账号（Service Account）是一种自动被启用的用户认证机制，使用经过签名的
持有者令牌来验证请求。该插件可接受两个可选参数：</p>
<ul>
<li><code>--service-account-key-file</code> 一个包含用来为持有者令牌签名的 PEM 编码密钥。
若未指定，则使用 API 服务器的 TLS 私钥。</li>
<li><code>--service-account-lookup</code> 如果启用，则从 API 删除的令牌会被回收。</li>
</ul>
<p>服务账号通常由 API 服务器自动创建并通过 <code>ServiceAccount</code>
<a href=/zh/docs/reference/access-authn-authz/admission-controllers/>准入控制器</a>
关联到集群中运行的 Pod 上。
持有者令牌会挂载到 Pod 中可预知的位置，允许集群内进程与 API 服务器通信。
服务账号也可以使用 Pod 规约的 <code>serviceAccountName</code> 字段显式地关联到 Pod 上。</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> <code>serviceAccountName</code> 通常会被忽略，因为关联关系是自动建立的。
</div>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-deployment<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>serviceAccountName</span>:<span style=color:#bbb> </span>bob-the-bot<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.14.2<span style=color:#bbb>
</span></code></pre></div>
<p>在集群外部使用服务账号持有者令牌也是完全合法的，且可用来为长时间运行的、需要与
Kubernetes API 服务器通信的任务创建标识。要手动创建服务账号，可以使用
<code>kubectl create serviceaccount &lt;名称></code> 命令。此命令会在当前的名字空间中生成一个
服务账号和一个与之关联的 Secret。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl create serviceaccount jenkins
</code></pre></div><pre><code>serviceaccount/jenkins created
</code></pre>
<p>查验相关联的 Secret：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl get serviceaccounts jenkins -o yaml
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ServiceAccount<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>secrets</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>jenkins-token-1yvwg<span style=color:#bbb>
</span></code></pre></div>
<p>所创建的 Secret 中会保存 API 服务器的公开的 CA 证书和一个已签名的 JSON Web
令牌（JWT）。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl get secret jenkins-token-1yvwg -o yaml
</code></pre></div>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ca.crt</span>:<span style=color:#bbb> </span>&lt;Base64 编码的 API 服务器 CA&gt;<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>ZGVmYXVsdA==<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>token</span>:<span style=color:#bbb> </span>&lt;Base64 编码的持有者令牌&gt;<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>kubernetes.io/service-account-token<span style=color:#bbb>
</span></code></pre></div>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 字段值是按 Base64 编码的，这是因为 Secret 数据总是采用 Base64 编码来存储。
</div>
<p>已签名的 JWT 可以用作持有者令牌，并将被认证为所给的服务账号。
关于如何在请求中包含令牌，请参阅<a href=#putting-a-bearer-token-in-a-request>前文</a>。
通常，这些 Secret 数据会被挂载到 Pod 中以便集群内访问 API 服务器时使用，
不过也可以在集群外部使用。</p>
<p>服务账号被身份认证后，所确定的用户名为 <code>system:serviceaccount:&lt;名字空间>:&lt;服务账号></code>，
并被分配到用户组 <code>system:serviceaccounts</code> 和 <code>system:serviceaccounts:&lt;名字空间></code>。</p>
<p>警告：由于服务账号令牌保存在 Secret 对象中，任何能够读取这些 Secret 的用户
都可以被认证为对应的服务账号。在为用户授予访问服务账号的权限时，以及对 Secret
的读权限时，要格外小心。</p>
<h3 id=openid-connect-tokens>OpenID Connect（OIDC）令牌 </h3>
<p><a href=https://openid.net/connect/>OpenID Connect</a> 是一种 OAuth2 认证方式，
被某些 OAuth2 提供者支持，例如 Azure 活动目录、Salesforce 和 Google。
协议对 OAuth2 的主要扩充体现在有一个附加字段会和访问令牌一起返回，
这一字段称作 <a href=https://openid.net/specs/openid-connect-core-1_0.html#IDToken>ID Token（ID 令牌）</a>。
ID 令牌是一种由服务器签名的 JSON Web 令牌（JWT），其中包含一些可预知的字段，
例如用户的邮箱地址，</p>
<p>要识别用户，身份认证组件使用 OAuth2
<a href=https://openid.net/specs/openid-connect-core-1_0.html#TokenResponse>令牌响应</a>
中的 <code>id_token</code>（而非 <code>access_token</code>）作为持有者令牌。
关于如何在请求中设置令牌，可参见<a href=#putting-a-bearer-token-in-a-request>前文</a>。</p>
<figure>
<div class=mermaid>
sequenceDiagram
participant user as 用户
participant idp as 身份提供者
participant kube as Kubectl
participant api as API 服务器
user ->> idp: 1. 登录到 IdP
activate idp
idp -->> user: 2. 提供 access_token,<br>id_token, 和 refresh_token
deactivate idp
activate user
user ->> kube: 3. 调用 Kubectl 并<br>设置 --token 为 id_token<br>或者将令牌添加到 .kube/config
deactivate user
activate kube
kube ->> api: 4. Authorization: Bearer...
deactivate kube
activate api
api ->> api: 5. JWT 签名合法么？
api ->> api: 6. JWT 是否已过期？(iat+exp)
api ->> api: 7. 用户被授权了么？
api -->> kube: 8. 已授权：执行<br>操作并返回结果
deactivate api
activate kube
kube --x user: 9. 返回结果
deactivate kube
</div>
</figure>
<noscript>
<div class="alert alert-secondary callout" role=alert>
<em class=javascript-required>JavaScript must be <a href=https://www.enable-javascript.com/>enabled</a> to view this content</em>
</div>
</noscript>
<ol>
<li>登录到你的身份服务（Identity Provider）</li>
<li>你的身份服务将为你提供 <code>access_token</code>、<code>id_token</code> 和 <code>refresh_token</code></li>
<li>在使用 <code>kubectl</code> 时，将 <code>id_token</code> 设置为 <code>--token</code> 标志值，或者将其直接添加到
<code>kubeconfig</code> 中</li>
<li><code>kubectl</code> 将你的 <code>id_token</code> 放到一个称作 <code>Authorization</code> 的头部，发送给 API 服务器</li>
<li>API 服务器将负责通过检查配置中引用的证书来确认 JWT 的签名是合法的</li>
<li>检查确认 <code>id_token</code> 尚未过期</li>
<li>确认用户有权限执行操作</li>
<li>鉴权成功之后，API 服务器向 <code>kubectl</code> 返回响应</li>
<li><code>kubectl</code> 向用户提供反馈信息</li>
</ol>
<p>由于用来验证你是谁的所有数据都在 <code>id_token</code> 中，Kubernetes 不需要再去联系身份服务。
在一个所有请求都是无状态请求的模型中，这一工作方式可以使得身份认证的解决方案更容易处理大规模请求。
不过，此访问也有一些挑战：</p>
<ol>
<li>Kubernetes 没有提供用来触发身份认证过程的 "Web 界面"。
因为不存在用来收集用户凭据的浏览器或用户接口，你必须自己先行完成对身份服务的认证过程。</li>
<li><code>id_token</code> 令牌不可收回。因其属性类似于证书，其生命期一般很短（只有几分钟），
所以，每隔几分钟就要获得一个新的令牌这件事可能很让人头疼。</li>
<li>如果需要向 Kubernetes 控制面板执行身份认证，你必须使用 <code>kubectl proxy</code>
命令或者一个能够注入 <code>id_token</code> 的反向代理。</li>
</ol>
<h4 id=configuring-the-api-server>配置 API 服务器 </h4>
<p>要启用此插件，须在 API 服务器上配置以下标志：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
<th>示例</th>
<th>必需？</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>--oidc-issuer-url</code></td>
<td>允许 API 服务器发现公开的签名密钥的服务的 URL。只接受模式为 <code>https://</code> 的 URL。此值通常设置为服务的发现 URL，不含路径。例如："https://accounts.google.com" 或 "https://login.salesforce.com"。此 URL 应指向 .well-known/openid-configuration 下一层的路径。</td>
<td>如果发现 URL 是 <code>https://accounts.google.com/.well-known/openid-configuration</code>，则此值应为 <code>https://accounts.google.com</code></td>
<td>是</td>
</tr>
<tr>
<td><code>--oidc-client-id</code></td>
<td>所有令牌都应发放给此客户 ID。</td>
<td>kubernetes</td>
<td>是</td>
</tr>
<tr>
<td><code>--oidc-username-claim</code></td>
<td>用作用户名的 JWT 申领（JWT Claim）。默认情况下使用 <code>sub</code> 值，即最终用户的一个唯一的标识符。管理员也可以选择其他申领，例如 <code>email</code> 或者 <code>name</code>，取决于所用的身份服务。不过，除了 <code>email</code> 之外的申领都会被添加令牌发放者的 URL 作为前缀，以免与其他插件产生命名冲突。</td>
<td>sub</td>
<td>否</td>
</tr>
<tr>
<td><code>--oidc-username-prefix</code></td>
<td>要添加到用户名申领之前的前缀，用来避免与现有用户名发生冲突（例如：<code>system:</code> 用户）。例如，此标志值为 <code>oidc:</code> 时将创建形如 <code>oidc:jane.doe</code> 的用户名。如果此标志未设置，且 <code>--oidc-username-claim</code> 标志值不是 <code>email</code>，则默认前缀为 <code>&lt;令牌发放者的 URL>#</code>，其中 <code>&lt;令牌发放者 URL ></code> 的值取自 <code>--oidc-issuer-url</code> 标志的设定。此标志值为 <code>-</code> 时，意味着禁止添加用户名前缀。</td>
<td><code>oidc:</code></td>
<td>否</td>
</tr>
<tr>
<td><code>--oidc-groups-claim</code></td>
<td>用作用户组名的 JWT 申领。如果所指定的申领确实存在，则其值必须是一个字符串数组。</td>
<td>groups</td>
<td>否</td>
</tr>
<tr>
<td><code>--oidc-groups-prefix</code></td>
<td>添加到组申领的前缀，用来避免与现有用户组名（如：<code>system:</code> 组）发生冲突。例如，此标志值为 <code>oidc:</code> 时，所得到的用户组名形如 <code>oidc:engineering</code> 和 <code>oidc:infra</code>。</td>
<td><code>oidc:</code></td>
<td>否</td>
</tr>
<tr>
<td><code>--oidc-required-claim</code></td>
<td>取值为一个 key=value 偶对，意为 ID 令牌中必须存在的申领。如果设置了此标志，则 ID 令牌会被检查以确定是否包含取值匹配的申领。此标志可多次重复，以指定多个申领。</td>
<td><code>claim=value</code></td>
<td>否</td>
</tr>
<tr>
<td><code>--oidc-ca-file</code></td>
<td>指向一个 CA 证书的路径，该 CA 负责对你的身份服务的 Web 证书提供签名。默认值为宿主系统的根 CA。</td>
<td><code>/etc/kubernetes/ssl/kc-ca.pem</code></td>
<td>否</td>
</tr>
</tbody>
</table>
<p>很重要的一点是，API 服务器并非一个 OAuth2 客户端，相反，它只能被配置为
信任某一个令牌发放者。这使得使用公共服务（如 Google）的用户可以不信任发放给
第三方的凭据。
如果管理员希望使用多个 OAuth 客户端，他们应该研究一下那些支持 <code>azp</code>
（Authorized Party，被授权方）申领的服务。
<code>azp</code> 是一种允许某客户端代替另一客户端发放令牌的机制。</p>
<p>Kubernetes 并未提供 OpenID Connect 的身份服务。
你可以使用现有的公共的 OpenID Connect 身份服务（例如 Google 或者
<a href=https://connect2id.com/products/nimbus-oauth-openid-connect-sdk/openid-connect-providers>其他服务</a>）。
或者，你也可以选择自己运行一个身份服务，例如
CoreOS <a href=https://github.com/coreos/dex>dex</a>、
<a href=https://github.com/keycloak/keycloak>Keycloak</a>、
CloudFoundry <a href=https://github.com/cloudfoundry/uaa>UAA</a> 或者
Tremolo Security 的 <a href=https://openunison.github.io/>OpenUnison</a>。</p>
<p>要在 Kubernetes 环境中使用某身份服务，该服务必须：</p>
<ol>
<li>支持 <a href=https://openid.net/specs/openid-connect-discovery-1_0.html>OpenID connect 发现</a>；
但事实上并非所有服务都具备此能力</li>
<li>运行 TLS 协议且所使用的加密组件都未过时</li>
<li>拥有由 CA 签名的证书（即使 CA 不是商业 CA 或者是自签名的 CA 也可以）</li>
</ol>
<p>关于上述第三条需求，即要求具备 CA 签名的证书，有一些额外的注意事项。
如果你部署了自己的身份服务，而不是使用云厂商（如 Google 或 Microsoft）所提供的服务，
你必须对身份服务的 Web 服务器证书进行签名，签名所用证书的 <code>CA</code> 标志要设置为
<code>TRUE</code>，即使用的是自签名证书。这是因为 GoLang 的 TLS 客户端实现对证书验证
标准方面有非常严格的要求。如果你手头没有现成的 CA 证书，可以使用 CoreOS
团队所开发的<a href=https://github.com/dexidp/dex/blob/master/examples/k8s/gencert.sh>这个脚本</a>
来创建一个简单的 CA 和被签了名的证书与密钥对。
或者你也可以使用
<a href=https://raw.githubusercontent.com/TremoloSecurity/openunison-qs-kubernetes/master/src/main/bash/makessl.sh>这个类似的脚本</a>，
生成一个合法期更长、密钥尺寸更大的 SHA256 证书。</p>
<p>特定系统的安装指令：</p>
<ul>
<li><a href=https://docs.cloudfoundry.org/concepts/architecture/uaa.html>UAA</a></li>
<li><a href=https://dexidp.io/docs/kubernetes/>Dex</a></li>
<li><a href=https://www.tremolosecurity.com/orchestra-k8s/>OpenUnison</a></li>
</ul>
<h4 id=using-kubectl>使用 kubectl </h4>
<h5 id=选项一-oidc-身份认证组件>选项一 - OIDC 身份认证组件</h5>
<p>第一种方案是使用 kubectl 的 <code>oidc</code> 身份认证组件，该组件将 <code>id_token</code> 设置
为所有请求的持有者令牌，并且在令牌过期时自动刷新。在你登录到你的身份服务之后，
可以使用 kubectl 来添加你的 <code>id_token</code>、<code>refresh_token</code>、<code>client_id</code> 和
<code>client_secret</code>，以配置该插件。</p>
<p>如果服务在其刷新令牌响应中不包含 <code>id_token</code>，则此插件无法支持该服务。
这时你应该考虑下面的选项二。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl config set-credentials USER_NAME <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>   --auth-provider<span style=color:#666>=</span>oidc <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>   --auth-provider-arg<span style=color:#666>=</span>idp-issuer-url<span style=color:#666>=(</span> issuer url <span style=color:#666>)</span> <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>   --auth-provider-arg<span style=color:#666>=</span>client-id<span style=color:#666>=(</span> your client id <span style=color:#666>)</span> <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>   --auth-provider-arg<span style=color:#666>=</span>client-secret<span style=color:#666>=(</span> your client secret <span style=color:#666>)</span> <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>   --auth-provider-arg<span style=color:#666>=</span>refresh-token<span style=color:#666>=(</span> your refresh token <span style=color:#666>)</span> <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>   --auth-provider-arg<span style=color:#666>=</span>idp-certificate-authority<span style=color:#666>=(</span> path to your ca certificate <span style=color:#666>)</span> <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>   --auth-provider-arg<span style=color:#666>=</span>id-token<span style=color:#666>=(</span> your id_token <span style=color:#666>)</span>
</code></pre></div>
<p>作为示例，在完成对你的身份服务的身份认证之后，运行下面的命令：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl config set-credentials mmosley  <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>        --auth-provider<span style=color:#666>=</span>oidc  <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>        --auth-provider-arg<span style=color:#666>=</span>idp-issuer-url<span style=color:#666>=</span>https://oidcidp.tremolo.lan:8443/auth/idp/OidcIdP  <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>        --auth-provider-arg<span style=color:#666>=</span>client-id<span style=color:#666>=</span>kubernetes  <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>        --auth-provider-arg<span style=color:#666>=</span>client-secret<span style=color:#666>=</span>1db158f6-177d-4d9c-8a8b-d36869918ec5  <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>        --auth-provider-arg<span style=color:#666>=</span>refresh-token<span style=color:#666>=</span>q1bKLFOyUiosTfawzA93TzZIDzH2TNa2SMm0zEiPKTUwME6BkEo6Sql5yUWVBSWpKUGphaWpxSVAfekBOZbBhaEW+VlFUeVRGcluyVF5JT4+haZmPsluFoFu5XkpXk5BXqHega4GAXlF+ma+vmYpFcHe5eZR+slBFpZKtQA<span style=color:#666>=</span> <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>        --auth-provider-arg<span style=color:#666>=</span>idp-certificate-authority<span style=color:#666>=</span>/root/ca.pem <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>        --auth-provider-arg<span style=color:#666>=</span>id-token<span style=color:#666>=</span>eyJraWQiOiJDTj1vaWRjaWRwLnRyZW1vbG8ubGFuLCBPVT1EZW1vLCBPPVRybWVvbG8gU2VjdXJpdHksIEw9QXJsaW5ndG9uLCBTVD1WaXJnaW5pYSwgQz1VUy1DTj1rdWJlLWNhLTEyMDIxNDc5MjEwMzYwNzMyMTUyIiwiYWxnIjoiUlMyNTYifQ.eyJpc3MiOiJodHRwczovL29pZGNpZHAudHJlbW9sby5sYW46ODQ0My9hdXRoL2lkcC9PaWRjSWRQIiwiYXVkIjoia3ViZXJuZXRlcyIsImV4cCI6MTQ4MzU0OTUxMSwianRpIjoiMm96US15TXdFcHV4WDlHZUhQdy1hZyIsImlhdCI6MTQ4MzU0OTQ1MSwibmJmIjoxNDgzNTQ5MzMxLCJzdWIiOiI0YWViMzdiYS1iNjQ1LTQ4ZmQtYWIzMC0xYTAxZWU0MWUyMTgifQ.w6p4J_6qQ1HzTG9nrEOrubxIMb9K5hzcMPxc9IxPx2K4xO9l-oFiUw93daH3m5pluP6K7eOE6txBuRVfEcpJSwlelsOsW8gb8VJcnzMS9EnZpeA0tW_p-mnkFc3VcfyXuhe5R3G7aa5d8uHv70yJ9Y3-UhjiN9EhpMdfPAoEB9fYKKkJRzF7utTTIPGrSaSU6d2pcpfYKaxIwePzEkT4DfcQthoZdy9ucNvvLoi1DIC-UocFD8HLs8LYKEqSxQvOcvnThbObJ9af71EwmuE21fO5KzMW20KtAeget1gnldOosPtz1G5EwvaQ401-RPQzPGMVBld0_zMCAwZttJ4knw
</code></pre></div>
<p>此操作会生成以下配置：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>users</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mmosley<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>user</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>auth-provider</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>config</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>client-id</span>:<span style=color:#bbb> </span>kubernetes<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>client-secret</span>:<span style=color:#bbb> </span>1db158f6-177d-4d9c-8a8b-d36869918ec5<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>id-token</span>:<span style=color:#bbb> </span>eyJraWQiOiJDTj1vaWRjaWRwLnRyZW1vbG8ubGFuLCBPVT1EZW1vLCBPPVRybWVvbG8gU2VjdXJpdHksIEw9QXJsaW5ndG9uLCBTVD1WaXJnaW5pYSwgQz1VUy1DTj1rdWJlLWNhLTEyMDIxNDc5MjEwMzYwNzMyMTUyIiwiYWxnIjoiUlMyNTYifQ.eyJpc3MiOiJodHRwczovL29pZGNpZHAudHJlbW9sby5sYW46ODQ0My9hdXRoL2lkcC9PaWRjSWRQIiwiYXVkIjoia3ViZXJuZXRlcyIsImV4cCI6MTQ4MzU0OTUxMSwianRpIjoiMm96US15TXdFcHV4WDlHZUhQdy1hZyIsImlhdCI6MTQ4MzU0OTQ1MSwibmJmIjoxNDgzNTQ5MzMxLCJzdWIiOiI0YWViMzdiYS1iNjQ1LTQ4ZmQtYWIzMC0xYTAxZWU0MWUyMTgifQ.w6p4J_6qQ1HzTG9nrEOrubxIMb9K5hzcMPxc9IxPx2K4xO9l-oFiUw93daH3m5pluP6K7eOE6txBuRVfEcpJSwlelsOsW8gb8VJcnzMS9EnZpeA0tW_p-mnkFc3VcfyXuhe5R3G7aa5d8uHv70yJ9Y3-UhjiN9EhpMdfPAoEB9fYKKkJRzF7utTTIPGrSaSU6d2pcpfYKaxIwePzEkT4DfcQthoZdy9ucNvvLoi1DIC-UocFD8HLs8LYKEqSxQvOcvnThbObJ9af71EwmuE21fO5KzMW20KtAeget1gnldOosPtz1G5EwvaQ401-RPQzPGMVBld0_zMCAwZttJ4knw<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>idp-certificate-authority</span>:<span style=color:#bbb> </span>/root/ca.pem<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>idp-issuer-url</span>:<span style=color:#bbb> </span>https://oidcidp.tremolo.lan:8443/auth/idp/OidcIdP<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>refresh-token</span>:<span style=color:#bbb> </span>q1bKLFOyUiosTfawzA93TzZIDzH2TNa2SMm0zEiPKTUwME6BkEo6Sql5yUWVBSWpKUGphaWpxSVAfekBOZbBhaEW+VlFUeVRGcluyVF5JT4+haZmPsluFoFu5XkpXk5BXq<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>oidc<span style=color:#bbb>
</span></code></pre></div>
<p>当你的 <code>id_token</code> 过期时，<code>kubectl</code> 会尝试使用你的 <code>refresh_token</code> 来刷新你的
<code>id_token</code>，并且在 <code>.kube/config</code> 文件的 <code>client_secret</code> 中存放 <code>refresh_token</code>
和 <code>id_token</code> 的新值。</p>
<h5 id=选项二-使用-token-选项>选项二 - 使用 <code>--token</code> 选项</h5>
<p><code>kubectl</code> 命令允许你使用 <code>--token</code> 选项传递一个令牌。
你可以将 <code>id_token</code> 的内容复制粘贴过来，作为此标志的取值：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl --token<span style=color:#666>=</span>eyJhbGciOiJSUzI1NiJ9.eyJpc3MiOiJodHRwczovL21sYi50cmVtb2xvLmxhbjo4MDQzL2F1dGgvaWRwL29pZGMiLCJhdWQiOiJrdWJlcm5ldGVzIiwiZXhwIjoxNDc0NTk2NjY5LCJqdGkiOiI2RDUzNXoxUEpFNjJOR3QxaWVyYm9RIiwiaWF0IjoxNDc0NTk2MzY5LCJuYmYiOjE0NzQ1OTYyNDksInN1YiI6Im13aW5kdSIsInVzZXJfcm9sZSI6WyJ1c2VycyIsIm5ldy1uYW1lc3BhY2Utdmlld2VyIl0sImVtYWlsIjoibXdpbmR1QG5vbW9yZWplZGkuY29tIn0.f2As579n9VNoaKzoF-dOQGmXkFKf1FMyNV0-va_B63jn-_n9LGSCca_6IVMP8pO-Zb4KvRqGyTP0r3HkHxYy5c81AnIh8ijarruczl-TK_yF5akjSTHFZD-0gRzlevBDiH8Q79NAr-ky0P4iIXS8lY9Vnjch5MF74Zx0c3alKJHJUnnpjIACByfF2SCaYzbWFMUNat-K1PaUk5-ujMBG7yYnr95xD-63n8CO8teGUAAEMx6zRjzfhnhbzX-ajwZLGwGUBT4WqjMs70-6a7_8gZmLZb2az1cZynkFRj2BaCkVT3A2RrjeEwZEtGXlMqKJ1_I2ulrOVsYx01_yD35-rw get nodes
</code></pre></div>
<h3 id=webhook-token-authentication>Webhook 令牌身份认证 </h3>
<p>Webhook 身份认证是一种用来验证持有者令牌的回调机制。</p>
<ul>
<li><code>--authentication-token-webhook-config-file</code> 指向一个配置文件，其中描述
如何访问远程的 Webhook 服务。</li>
<li><code>--authentication-token-webhook-cache-ttl</code> 用来设定身份认证决定的缓存时间。
默认时长为 2 分钟。</li>
</ul>
<p>配置文件使用 <a href=/zh/docs/concepts/configuration/organize-cluster-access-kubeconfig/>kubeconfig</a>
文件的格式。文件中，<code>clusters</code> 指代远程服务，<code>users</code> 指代远程 API 服务
Webhook。下面是一个例子：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#080;font-style:italic># Kubernetes API 版本</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># API 对象类别</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Config<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># clusters 指代远程服务</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>clusters</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>name-of-remote-authn-service<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>cluster</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>certificate-authority</span>:<span style=color:#bbb> </span>/path/to/ca.pem        <span style=color:#bbb> </span><span style=color:#080;font-style:italic># 用来验证远程服务的 CA</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>server</span>:<span style=color:#bbb> </span>https://authn.example.com/authenticate<span style=color:#bbb> </span><span style=color:#080;font-style:italic># 要查询的远程服务 URL。生产环境中建议使用 &#39;https&#39;。</span><span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># users 指代 API 服务的 Webhook 配置</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>users</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>name-of-api-server<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>user</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>client-certificate</span>:<span style=color:#bbb> </span>/path/to/cert.pem<span style=color:#bbb> </span><span style=color:#080;font-style:italic># Webhook 插件要使用的证书</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>client-key</span>:<span style=color:#bbb> </span>/path/to/key.pem         <span style=color:#bbb> </span><span style=color:#080;font-style:italic># 与证书匹配的密钥</span><span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># kubeconfig 文件需要一个上下文（Context），此上下文用于本 API 服务器</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>current-context</span>:<span style=color:#bbb> </span>webhook<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>contexts</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>context</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>cluster</span>:<span style=color:#bbb> </span>name-of-remote-authn-service<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>user</span>:<span style=color:#bbb> </span>name-of-api-sever<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>webhook<span style=color:#bbb>
</span></code></pre></div>
<p>当客户端尝试在 API 服务器上使用持有者令牌完成身份认证（
如<a href=#putting-a-bearer-token-in-a-request>前</a>所述）时，
身份认证 Webhook 会用 POST 请求发送一个 JSON 序列化的对象到远程服务。
该对象是 <code>authentication.k8s.io/v1beta1</code> 组的 <code>TokenReview</code> 对象，
其中包含持有者令牌。
Kubernetes 不会强制请求提供此 HTTP 头部。</p>
<p>要注意的是，Webhook API 对象和其他 Kubernetes API 对象一样，也要受到同一
<a href=/zh/docs/concepts/overview/kubernetes-api/>版本兼容规则</a>约束。
实现者要了解对 Beta 阶段对象的兼容性承诺，并检查请求的 <code>apiVersion</code> 字段，
以确保数据结构能够正常反序列化解析。此外，API 服务器必须启用
<code>authentication.k8s.io/v1beta1</code> API 扩展组
（<code>--runtime-config=authentication.k8s.io/v1beta1=true</code>）。</p>
<p>POST 请求的 Body 部分将是如下格式：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
  <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;authentication.k8s.io/v1beta1&#34;</span>,
  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;TokenReview&#34;</span>,
  <span style=color:green;font-weight:700>&#34;spec&#34;</span>: {
    <span style=color:green;font-weight:700>&#34;token&#34;</span>: <span style=color:#b44>&#34;&lt;持有者令牌&gt;&#34;</span>
  }
}
</code></pre></div>
<p>远程服务应该会填充请求的 <code>status</code> 字段，以标明登录操作是否成功。
响应的 Body 中的 <code>spec</code> 字段会被忽略，因此可以省略。
如果持有者令牌验证成功，应该返回如下所示的响应：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
  <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;authentication.k8s.io/v1beta1&#34;</span>,
  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;TokenReview&#34;</span>,
  <span style=color:green;font-weight:700>&#34;status&#34;</span>: {
    <span style=color:green;font-weight:700>&#34;authenticated&#34;</span>: <span style=color:#a2f;font-weight:700>true</span>,
    <span style=color:green;font-weight:700>&#34;user&#34;</span>: {
      <span style=color:green;font-weight:700>&#34;username&#34;</span>: <span style=color:#b44>&#34;janedoe@example.com&#34;</span>,
      <span style=color:green;font-weight:700>&#34;uid&#34;</span>: <span style=color:#b44>&#34;42&#34;</span>,
      <span style=color:green;font-weight:700>&#34;groups&#34;</span>: [
        <span style=color:#b44>&#34;developers&#34;</span>,
        <span style=color:#b44>&#34;qa&#34;</span>
      ],
      <span style=color:green;font-weight:700>&#34;extra&#34;</span>: {
        <span style=color:green;font-weight:700>&#34;extrafield1&#34;</span>: [
          <span style=color:#b44>&#34;extravalue1&#34;</span>,
          <span style=color:#b44>&#34;extravalue2&#34;</span>
        ]
      }
    }
  }
}
</code></pre></div>
<p>而不成功的请求会返回：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
  <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;authentication.k8s.io/v1beta1&#34;</span>,
  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;TokenReview&#34;</span>,
  <span style=color:green;font-weight:700>&#34;status&#34;</span>: {
    <span style=color:green;font-weight:700>&#34;authenticated&#34;</span>: <span style=color:#a2f;font-weight:700>false</span>
  }
}
</code></pre></div>
<p>HTTP 状态码可用来提供进一步的错误语境信息。</p>
<h3 id=authenticating-proxy>身份认证代理 </h3>
<p>API 服务器可以配置成从请求的头部字段值（如 <code>X-Remote-User</code>）中辩识用户。
这一设计是用来与某身份认证代理一起使用 API 服务器，代理负责设置请求的头部字段值。</p>
<ul>
<li><code>--requestheader-username-headers</code> 必需字段，大小写不敏感。用来设置要获得用户身份所要检查的头部字段名称列表（有序）。第一个包含数值的字段会被用来提取用户名。</li>
<li><code>--requestheader-group-headers</code> 可选字段，在 Kubernetes 1.6 版本以后支持，大小写不敏感。
建议设置为 "X-Remote-Group"。用来指定一组头部字段名称列表，以供检查用户所属的组名称。
所找到的全部头部字段的取值都会被用作用户组名。</li>
<li><code>--requestheader-extra-headers-prefix</code> 可选字段，在 Kubernetes 1.6 版本以后支持，大小写不敏感。
建议设置为 "X-Remote-Extra-"。用来设置一个头部字段的前缀字符串，API 服务器会基于所给
前缀来查找与用户有关的一些额外信息。这些额外信息通常用于所配置的鉴权插件。
API 服务器会将与所给前缀匹配的头部字段过滤出来，去掉其前缀部分，将剩余部分
转换为小写字符串并在必要时执行<a href=https://tools.ietf.org/html/rfc3986#section-2.1>百分号解码</a>
后，构造新的附加信息字段键名。原来的头部字段值直接作为附加信息字段的值。</li>
</ul>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 在 1.13.3 版本之前（包括 1.10.7、1.9.11），附加字段的键名只能包含
<a href=https://tools.ietf.org/html/rfc7230#section-3.2.6>HTTP 头部标签的合法字符</a>。
</div>
<p>例如，使用下面的配置：</p>
<pre><code>--requestheader-username-headers=X-Remote-User
--requestheader-group-headers=X-Remote-Group
--requestheader-extra-headers-prefix=X-Remote-Extra-
</code></pre>
<p>针对所收到的如下请求：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-http data-lang=http><span style=color:#00a000>GET</span> <span style=color:#00f;font-weight:700>/</span> <span style=color:#a2f;font-weight:700>HTTP</span><span style=color:#666>/</span><span style=color:#666>1.1</span>
X-Remote-User<span style=color:#666>:</span> fido
X-Remote-Group<span style=color:#666>:</span> dogs
X-Remote-Group<span style=color:#666>:</span> dachshunds
X-Remote-Extra-Acme.com%2Fproject<span style=color:#666>:</span> some-project
X-Remote-Extra-Scopes<span style=color:#666>:</span> openid
X-Remote-Extra-Scopes<span style=color:#666>:</span> profile
</code></pre></div>
<p>会生成下面的用户信息：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>fido<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>groups</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- dogs<span style=color:#bbb>
</span><span style=color:#bbb></span>- dachshunds<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>extra</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>acme.com/project</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- some-project<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>scopes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- openid<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- profile<span style=color:#bbb>
</span></code></pre></div>
<p>为了防范头部信息侦听，在请求中的头部字段被检视之前，
身份认证代理需要向 API 服务器提供一份合法的客户端证书，
供后者使用所给的 CA 来执行验证。
警告：<em>不要</em> 在不同的上下文中复用 CA 证书，除非你清楚这样做的风险是什么以及
应如何保护 CA 用法的机制。</p>
<ul>
<li><code>--requestheader-client-ca-file</code> 必需字段，给出 PEM 编码的证书包。
在检查请求的头部字段以提取用户名信息之前，必须提供一个合法的客户端证书，
且该证书要能够被所给文件中的机构所验证。</li>
<li><code>--requestheader-allowed-names</code> 可选字段，用来给出一组公共名称（CN）。
如果此标志被设置，则在检视请求中的头部以提取用户信息之前，必须提供
包含此列表中所给的 CN 名的、合法的客户端证书。</li>
</ul>
<h2 id=anonymous-requests>匿名请求 </h2>
<p>启用匿名请求支持之后，如果请求没有被已配置的其他身份认证方法拒绝，则被视作
匿名请求（Anonymous Requests）。这类请求获得用户名 <code>system:anonymous</code> 和
对应的用户组 <code>system:unauthenticated</code>。</p>
<p>例如，在一个配置了令牌身份认证且启用了匿名访问的服务器上，如果请求提供了非法的
持有者令牌，则会返回 <code>401 Unauthorized</code> 错误。
如果请求没有提供持有者令牌，则被视为匿名请求。</p>
<p>在 1.5.1-1.5.x 版本中，匿名访问默认情况下是被禁用的，可以通过为 API 服务器设定
<code>--anonymous-auth=true</code> 来启用。</p>
<p>在 1.6 及之后版本中，如果所使用的鉴权模式不是 <code>AlwaysAllow</code>，则匿名访问默认是被启用的。
从 1.6 版本开始，ABAC 和 RBAC 鉴权模块要求对 <code>system:anonymous</code> 用户或者
<code>system:unauthenticated</code> 用户组执行显式的权限判定，所以之前的为 <code>*</code> 用户或
<code>*</code> 用户组赋予访问权限的策略规则都不再包含匿名用户。</p>
<h2 id=user-impersonation>用户伪装 </h2>
<p>一个用户可以通过伪装（Impersonation）头部字段来以另一个用户的身份执行操作。
使用这一能力，你可以手动重载请求被身份认证所识别出来的用户信息。
例如，管理员可以使用这一功能特性来临时伪装成另一个用户，查看请求是否被拒绝，
从而调试鉴权策略中的问题，</p>
<p>带伪装的请求首先会被身份认证识别为发出请求的用户，之后会切换到使用被伪装的用户
的用户信息。</p>
<ul>
<li>用户发起 API 调用时 <em>同时</em> 提供自身的凭据和伪装头部字段信息</li>
<li>API 服务器对用户执行身份认证</li>
<li>API 服务器确认通过认证的用户具有伪装特权</li>
<li>请求用户的信息被替换成伪装字段的值</li>
<li>评估请求，鉴权组件针对所伪装的用户信息执行操作</li>
</ul>
<p>以下 HTTP 头部字段可用来执行伪装请求：</p>
<ul>
<li><code>Impersonate-User</code>：要伪装成的用户名</li>
<li><code>Impersonate-Group</code>：要伪装成的用户组名。可以多次指定以设置多个用户组。
可选字段；要求 "Impersonate-User" 必须被设置。</li>
<li><code>Impersonate-Extra-&lt;附加名称></code>：一个动态的头部字段，用来设置与用户相关的附加字段。
此字段可选；要求 "Impersonate-User" 被设置。为了能够以一致的形式保留，
<code>&lt;附加名称></code>部分必须是小写字符，如果有任何字符不是
<a href=https://tools.ietf.org/html/rfc7230#section-3.2.6>合法的 HTTP 头部标签字符</a>，
则必须是 utf8 字符，且转换为<a href=https://tools.ietf.org/html/rfc3986#section-2.1>百分号编码</a>。</li>
<li><code>Impersonate-Uid</code>：一个唯一标识符，用来表示所伪装的用户。此头部可选。
如果设置，则要求 "Impersonate-User" 也存在。
Kubernetes 对此字符串没有格式要求。</li>
</ul>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 在 1.11.3 版本之前（以及 1.10.7、1.9.11），<code>&lt;附加名称></code> 只能包含
合法的 HTTP 标签字符。
</div>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong>
<p><code>Impersonate-Uid</code> 仅在 1.22.0 及更高版本中可用。
</div>
<p>伪装带有用户组的用户时，所使用的伪装头部字段示例：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-http data-lang=http><span>Impersonate-User: jane.doe@example.com
</span><span>Impersonate-Group: developers
</span><span>Impersonate-Group: admins
</span></code></pre></div>
<p>伪装带有 UID 和附加字段的用户时，所使用的伪装头部字段示例：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-http data-lang=http><span>Impersonate-User: jane.doe@example.com
</span><span>Impersonate-Group: developers
</span><span>Impersonate-Group: admins
</span><span>Impersonate-Extra-dn: cn=jane,ou=engineers,dc=example,dc=com
</span><span>Impersonate-Extra-acme.com%2Fproject: some-project
</span><span>Impersonate-Extra-scopes: view
</span><span>Impersonate-Extra-scopes: development
</span></code></pre></div>
<p>在使用 <code>kubectl</code> 时，可以使用 <code>--as</code> 标志来配置 <code>Impersonate-User</code> 头部字段值，
使用 <code>--as-group</code> 标志配置 <code>Impersonate-Group</code> 头部字段值。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl drain mynode
</code></pre></div><pre><code class=language-none data-lang=none>Error from server (Forbidden): User &quot;clark&quot; cannot get nodes at the cluster scope. (get nodes mynode)
</code></pre>
<p>设置 <code>--as</code> 和 <code>--as-group</code> 标志：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl drain mynode --as<span style=color:#666>=</span>superman --as-group<span style=color:#666>=</span>system:masters
</code></pre></div><pre><code class=language-none data-lang=none>node/mynode cordoned
node/mynode drained
</code></pre><div class="alert alert-info note callout" role=alert>
<strong>Note:</strong>
<p><code>kubectl</code> 不能对附加字段或 UID 执行伪装。
</div>
<p>若要伪装成某个用户、某个组、用户标识符（UID））或者设置附加字段，
执行伪装操作的用户必须具有对所伪装的类别（“user”、“group”、“uid” 等）执行 “impersonate”
动词操作的能力。
对于启用了 RBAC 鉴权插件的集群，下面的 ClusterRole 封装了设置用户和组伪装字段所需的规则：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>impersonator<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;users&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;groups&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;serviceaccounts&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;impersonate&#34;</span>]<span style=color:#bbb>
</span></code></pre></div>
<p>为了执行伪装，附加字段和所伪装的 UID 都位于 "authorization.k8s.io" <code>apiGroup</code> 中。
附加字段会被作为 <code>userextras</code> 资源的子资源来执行权限评估。
如果要允许用户为附加字段 “scopes” 和 UID 设置伪装头部，该用户需要被授予以下角色：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>scopes-and-uid-impersonator<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># 可以设置 &#34;Impersonate-Extra-scopes&#34; 和 &#34;Impersonate-Uid&#34; 头部</span><span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;authentication.k8s.io&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;userextras/scopes&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;uids&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;impersonate&#34;</span>]<span style=color:#bbb>
</span></code></pre></div>
<p>你也可以通过约束资源可能对应的 <code>resourceNames</code> 限制伪装头部的取值：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>limited-impersonator<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># 可以伪装成用户 &#34;jane.doe@example.com&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;users&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;impersonate&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resourceNames</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;jane.doe@example.com&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># 可以伪装成用户组 &#34;developers&#34; 和 &#34;admins&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;groups&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;impersonate&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resourceNames</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;developers&#34;</span>,<span style=color:#b44>&#34;admins&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># 可以将附加字段 &#34;scopes&#34; 伪装成 &#34;view&#34; 和 &#34;development&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;authentication.k8s.io&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;userextras/scopes&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;impersonate&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resourceNames</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;view&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;development&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># 可以伪装 UID &#34;06f6ce97-e2c5-4ab8-7ba5-7654dd08d52b&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;authentication.k8s.io&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;uids&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;impersonate&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resourceNames</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;06f6ce97-e2c5-4ab8-7ba5-7654dd08d52b&#34;</span>]<span style=color:#bbb>
</span></code></pre></div>
<h2 id=client-go-credential-plugins>client-go 凭据插件 </h2>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.22 [stable]</code>
</div>
<p><code>k8s.io/client-go</code> 及使用它的工具（如 <code>kubectl</code> 和 <code>kubelet</code>）可以执行某个外部
命令来获得用户的凭据信息。</p>
<p>这一特性的目的是便于客户端与 <code>k8s.io/client-go</code> 并不支持的身份认证协议（LDAP、
Kerberos、OAuth2、SAML 等）继承。
插件实现特定于协议的逻辑，之后返回不透明的凭据以供使用。
几乎所有的凭据插件使用场景中都需要在服务器端存在一个支持
<a href=#webhook-token-authentication>Webhook 令牌身份认证组件</a>的模块，
负责解析客户端插件所生成的凭据格式。</p>
<h3 id=example-use-case>示例应用场景 </h3>
<p>在一个假想的应用场景中，某组织运行这一个外部的服务，能够将特定用户的已签名的
令牌转换成 LDAP 凭据。此服务还能够对
<a href=#webhook-token-authentication>Webhook 令牌身份认证组件</a>的请求做出响应以
验证所提供的令牌。用户需要在自己的工作站上安装一个凭据插件。</p>
<p>要对 API 服务器认证身份时：</p>
<ul>
<li>用户发出 <code>kubectl</code> 命令。</li>
<li>凭据插件提示用户输入 LDAP 凭据，并与外部服务交互，获得令牌。</li>
<li>凭据插件将令牌返回该 client-go，后者将其用作持有者令牌提交给 API 服务器。</li>
<li>API 服务器使用<a href=#webhook-token-authentication>Webhook 令牌身份认证组件</a>向
外部服务发出 <code>TokenReview</code> 请求。</li>
<li>外部服务检查令牌上的签名，返回用户的用户名和用户组信息。</li>
</ul>
<h3 id=configuration>配置 </h3>
<p>凭据插件通过 <a href=/zh/docs/tasks/access-application-cluster/configure-access-multiple-clusters/>kubectl 配置文件</a>
来作为 user 字段的一部分设置。</p>
<ul class="nav nav-tabs" id=exec-plugin-kubeconfig-example-1 role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#exec-plugin-kubeconfig-example-1-0 role=tab aria-controls=exec-plugin-kubeconfig-example-1-0 aria-selected=true>client.authentication.k8s.io/v1</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#exec-plugin-kubeconfig-example-1-1 role=tab aria-controls=exec-plugin-kubeconfig-example-1-1>client.authentication.k8s.io/v1beta1</a></li></ul>
<div class=tab-content id=exec-plugin-kubeconfig-example-1><div id=exec-plugin-kubeconfig-example-1-0 class="tab-pane show active" role=tabpanel aria-labelledby=exec-plugin-kubeconfig-example-1-0>
<p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Config<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>users</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-user<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>user</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>exec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 要执行的命令。必需。</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;example-client-go-exec-plugin&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 解析 ExecCredentials 资源时使用的 API 版本。必需。</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic>#</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 插件返回的 API 版本必需与这里列出的版本匹配。</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic>#</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 要与支持多个版本的工具（如 client.authentication.k8sio/v1alpha1）集成，</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 可以设置一个环境变量或者向工具传递一个参数标明 exec 插件所期望的版本，</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 或者从 KUBERNETES_EXEC_INFO 环境变量的 ExecCredential 对象中读取版本信息。</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;client.authentication.k8s.io/v1&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 执行此插件时要设置的环境变量。可选字段。</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;FOO&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;bar&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 执行插件时要传递的参数。可选字段。</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:#b44>&#34;arg1&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:#b44>&#34;arg2&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 当可执行文件不存在时显示给用户的文本。可选的。</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>installHint</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span><span style=color:#b44;font-style:italic>        需要 example-client-go-exec-plugin 来在当前集群上执行身份认证。可以通过以下命令安装：
</span><span style=color:#b44;font-style:italic>
</span><span style=color:#b44;font-style:italic>        MacOS: brew install example-client-go-exec-plugin
</span><span style=color:#b44;font-style:italic>
</span><span style=color:#b44;font-style:italic>        Ubuntu: apt-get install example-client-go-exec-plugin
</span><span style=color:#b44;font-style:italic>
</span><span style=color:#b44;font-style:italic>        Fedora: dnf install example-client-go-exec-plugin
</span><span style=color:#b44;font-style:italic>
</span><span style=color:#b44;font-style:italic>        ...</span><span style=color:#bbb>        
</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 是否使用 KUBERNETES_EXEC_INFO 环境变量的一部分向这个 exec 插件</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 提供集群信息（可能包含非常大的 CA 数据）</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>provideClusterInfo</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># Exec 插件与标准输入 I/O 数据流之间的协议。如果协议无法满足，</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 则插件无法运行并会返回错误信息。合法的值包括 &#34;Never&#34; （Exec 插件从不使用标准输入），</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># &#34;IfAvailable&#34; （Exec 插件希望在可以的情况下使用标准输入），</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 或者 &#34;Always&#34; （Exec 插件需要使用标准输入才能工作）。必需字段。</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>interactiveMode</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>clusters</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-cluster<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>cluster</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>server</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;https://172.17.4.100:6443&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>certificate-authority</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/etc/kubernetes/ca.pem&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>extensions</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>client.authentication.k8s.io/exec<span style=color:#bbb> </span><span style=color:#080;font-style:italic># 为每个集群 exec 配置保留的扩展名</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>extension</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>arbitrary</span>:<span style=color:#bbb> </span>config<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>this</span>:<span style=color:#bbb> </span>在设置 provideClusterInfo 时可通过环境变量 KUBERNETES_EXEC_INFO 指定<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>you</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;can&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;put&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;anything&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;here&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>contexts</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-cluster<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>context</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>cluster</span>:<span style=color:#bbb> </span>my-cluster<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>user</span>:<span style=color:#bbb> </span>my-user<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>current-context</span>:<span style=color:#bbb> </span>my-cluster<span style=color:#bbb>
</span></code></pre></div></div>
<div id=exec-plugin-kubeconfig-example-1-1 class=tab-pane role=tabpanel aria-labelledby=exec-plugin-kubeconfig-example-1-1>
<p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Config<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>users</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-user<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>user</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>exec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 要执行的命令。必需。</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;example-client-go-exec-plugin&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 解析 ExecCredentials 资源时使用的 API 版本。必需。</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic>#</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 插件返回的 API 版本必需与这里列出的版本匹配。</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic>#</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 要与支持多个版本的工具（如 client.authentication.k8sio/v1alpha1）集成，</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 可以设置一个环境变量或者向工具传递一个参数标明 exec 插件所期望的版本，</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 或者从 KUBERNETES_EXEC_INFO 环境变量的 ExecCredential 对象中读取版本信息。</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;client.authentication.k8s.io/v1&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 执行此插件时要设置的环境变量。可选字段。</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;FOO&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;bar&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 执行插件时要传递的参数。可选字段。</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:#b44>&#34;arg1&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:#b44>&#34;arg2&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 当可执行文件不存在时显示给用户的文本。可选的。</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>installHint</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span><span style=color:#b44;font-style:italic>        需要 example-client-go-exec-plugin 来在当前集群上执行身份认证。可以通过以下命令安装：
</span><span style=color:#b44;font-style:italic>
</span><span style=color:#b44;font-style:italic>        MacOS: brew install example-client-go-exec-plugin
</span><span style=color:#b44;font-style:italic>
</span><span style=color:#b44;font-style:italic>        Ubuntu: apt-get install example-client-go-exec-plugin
</span><span style=color:#b44;font-style:italic>
</span><span style=color:#b44;font-style:italic>        Fedora: dnf install example-client-go-exec-plugin
</span><span style=color:#b44;font-style:italic>
</span><span style=color:#b44;font-style:italic>        ...</span><span style=color:#bbb>        
</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 是否使用 KUBERNETES_EXEC_INFO 环境变量的一部分向这个 exec 插件</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 提供集群信息（可能包含非常大的 CA 数据）</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>provideClusterInfo</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># Exec 插件与标准输入 I/O 数据流之间的协议。如果协议无法满足，</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 则插件无法运行并会返回错误信息。合法的值包括 &#34;Never&#34; （Exec 插件从不使用标准输入），</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># &#34;IfAvailable&#34; （Exec 插件希望在可以的情况下使用标准输入），</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 或者 &#34;Always&#34; （Exec 插件需要使用标准输入才能工作）。可选字段。</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 默认值为 &#34;IfAvailable&#34;。</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>interactiveMode</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>clusters</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-cluster<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>cluster</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>server</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;https://172.17.4.100:6443&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>certificate-authority</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/etc/kubernetes/ca.pem&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>extensions</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>client.authentication.k8s.io/exec<span style=color:#bbb> </span><span style=color:#080;font-style:italic># 为每个集群 exec 配置保留的扩展名</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>extension</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>arbitrary</span>:<span style=color:#bbb> </span>config<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>this</span>:<span style=color:#bbb> </span>在设置 provideClusterInfo 时可通过环境变量 KUBERNETES_EXEC_INFO 指定<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>you</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;can&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;put&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;anything&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;here&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>contexts</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-cluster<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>context</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>cluster</span>:<span style=color:#bbb> </span>my-cluster<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>user</span>:<span style=color:#bbb> </span>my-user<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>current-context</span>:<span style=color:#bbb> </span>my-cluster<span style=color:#bbb>
</span></code></pre></div></div></div>
<p>解析相对命令路径时，kubectl 将其视为与配置文件比较而言的相对路径。
如果 KUBECONFIG 被设置为 <code>/home/jane/kubeconfig</code>，而 exec 命令为
<code>./bin/example-client-go-exec-plugin</code>，则要执行的可执行文件为
<code>/home/jane/bin/example-client-go-exec-plugin</code>。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-user<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>user</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>exec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 对 kubeconfig 目录而言的相对路径</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;./bin/example-client-go-exec-plugin&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;client.authentication.k8s.io/v1&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>interactiveMode</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
</span></code></pre></div>
<h3 id=input-and-output-formats>输出和输出格式 </h3>
<p>所执行的命令会在 <code>stdout</code> 打印 <code>ExecCredential</code> 对象。
<code>k8s.io/client-go</code> 使用 <code>status</code> 中返回的凭据信息向 Kubernetes API 服务器执行身份认证。
所执行的命令会通过环境变量 <code>KUBERNETES_EXEC_INFO</code> 收到一个 <code>ExecCredential</code> 对象作为其输入。
此输入中包含类似于所返回的 <code>ExecCredential</code> 对象的预期 API 版本，
以及是否插件可以使用 <code>stdin</code> 与用户交互这类信息。</p>
<p>在交互式会话（即，某终端）中运行时，<code>stdin</code> 是直接暴露给插件使用的。
插件应该使用来自 <code>KUBERNETES_EXEC_INFO</code> 环境变量的 <code>ExecCredential</code>
输入对象中的 <code>spec.interactive</code> 字段来确定是否提供了 <code>stdin</code>。
插件的 <code>stdin</code> 需求（即，为了能够让插件成功运行，是否 <code>stdin</code> 是可选的、
必须提供的或者从不会被使用的）是通过
<a href=/zh/docs/concepts/configuration/organize-cluster-access-kubeconfig/>kubeconfig</a>
中的 <code>user.exec.interactiveMode</code> 来声明的（参见下面的表格了解合法值）。
字段 <code>user.exec.interactiveMode</code> 在 <code>client.authentication.k8s.io/v1beta1</code>
中是可选的，在 <code>client.authentication.k8s.io/v1</code> 中是必需的。</p>
<table><caption style=display:none>interactiveMode 取值</caption>
<thead>
<tr>
<th><code>interactiveMode</code> 取值</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Never</code></td>
<td>此 exec 插件从不需要使用标准输入，因此如论是否有标准输入提供给用户输入，该 exec 插件都能运行。</td>
</tr>
<tr>
<td><code>IfAvailable</code></td>
<td>此 exec 插件希望在标准输入可用的情况下使用标准输入，但在标准输入不存在时也可运行。因此，无论是否存在给用户提供输入的标准输入，此 exec 插件都会运行。如果存在供用户输入的标准输入，则该标准输入会被提供给 exec 插件。</td>
</tr>
<tr>
<td><code>Always</code></td>
<td>此 exec 插件需要标准输入才能正常运行，因此只有存在供用户输入的标准输入时，此 exec 插件才会运行。如果不存在供用户输入的标准输入，则 exec 插件无法运行，并且 exec 插件的执行者会因此返回错误信息。</td>
</tr>
</tbody>
</table>
<p>与使用持有者令牌凭据，插件在 <a href=/zh/docs/reference/config-api/client-authentication.v1beta1/#client-authentication-k8s-io-v1beta1-ExecCredential><code>ExecCredential</code></a>
的状态中返回一个令牌：</p>
<ul class="nav nav-tabs" id=exec-plugin-execcredential-example-1 role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#exec-plugin-execcredential-example-1-0 role=tab aria-controls=exec-plugin-execcredential-example-1-0 aria-selected=true>client.authentication.k8s.io/v1</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#exec-plugin-execcredential-example-1-1 role=tab aria-controls=exec-plugin-execcredential-example-1-1>client.authentication.k8s.io/v1beta1</a></li></ul>
<div class=tab-content id=exec-plugin-execcredential-example-1><div id=exec-plugin-execcredential-example-1-0 class="tab-pane show active" role=tabpanel aria-labelledby=exec-plugin-execcredential-example-1-0>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
  <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;client.authentication.k8s.io/v1&#34;</span>,
  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;ExecCredential&#34;</span>,
  <span style=color:green;font-weight:700>&#34;status&#34;</span>: {
    <span style=color:green;font-weight:700>&#34;token&#34;</span>: <span style=color:#b44>&#34;my-bearer-token&#34;</span>
  }
}
</code></pre></div></div>
<div id=exec-plugin-execcredential-example-1-1 class=tab-pane role=tabpanel aria-labelledby=exec-plugin-execcredential-example-1-1>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
  <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;client.authentication.k8s.io/v1beta1&#34;</span>,
  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;ExecCredential&#34;</span>,
  <span style=color:green;font-weight:700>&#34;status&#34;</span>: {
    <span style=color:green;font-weight:700>&#34;token&#34;</span>: <span style=color:#b44>&#34;my-bearer-token&#34;</span>
  }
}
</code></pre></div></div></div>
<p>另一种方案是，返回 PEM 编码的客户端证书和密钥，以便执行 TLS 客户端身份认证。
如果插件在后续调用中返回了不同的证书或密钥，<code>k8s.io/client-go</code>
会终止其与服务器的连接，从而强制执行新的 TLS 握手过程。</p>
<p>如果指定了这种方式，则 <code>clientKeyData</code> 和 <code>clientCertificateData</code> 字段都必需存在。</p>
<p><code>clientCertificateData</code> 字段可能包含一些要发送给服务器的中间证书（Intermediate
Certificates）。</p>
<ul class="nav nav-tabs" id=exec-plugin-execcredential-example-2 role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#exec-plugin-execcredential-example-2-0 role=tab aria-controls=exec-plugin-execcredential-example-2-0 aria-selected=true>client.authentication.k8s.io/v1</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#exec-plugin-execcredential-example-2-1 role=tab aria-controls=exec-plugin-execcredential-example-2-1>client.authentication.k8s.io/v1beta1</a></li></ul>
<div class=tab-content id=exec-plugin-execcredential-example-2><div id=exec-plugin-execcredential-example-2-0 class="tab-pane show active" role=tabpanel aria-labelledby=exec-plugin-execcredential-example-2-0>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
  <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;client.authentication.k8s.io/v1&#34;</span>,
  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;ExecCredential&#34;</span>,
  <span style=color:green;font-weight:700>&#34;status&#34;</span>: {
    <span style=color:green;font-weight:700>&#34;clientCertificateData&#34;</span>: <span style=color:#b44>&#34;-----BEGIN CERTIFICATE-----\n...\n-----END CERTIFICATE-----&#34;</span>,
    <span style=color:green;font-weight:700>&#34;clientKeyData&#34;</span>: <span style=color:#b44>&#34;-----BEGIN RSA PRIVATE KEY-----\n...\n-----END RSA PRIVATE KEY-----&#34;</span>
  }
}
</code></pre></div></div>
<div id=exec-plugin-execcredential-example-2-1 class=tab-pane role=tabpanel aria-labelledby=exec-plugin-execcredential-example-2-1>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
  <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;client.authentication.k8s.io/v1beta1&#34;</span>,
  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;ExecCredential&#34;</span>,
  <span style=color:green;font-weight:700>&#34;status&#34;</span>: {
    <span style=color:green;font-weight:700>&#34;clientCertificateData&#34;</span>: <span style=color:#b44>&#34;-----BEGIN CERTIFICATE-----\n...\n-----END CERTIFICATE-----&#34;</span>,
    <span style=color:green;font-weight:700>&#34;clientKeyData&#34;</span>: <span style=color:#b44>&#34;-----BEGIN RSA PRIVATE KEY-----\n...\n-----END RSA PRIVATE KEY-----&#34;</span>
  }
}
</code></pre></div></div></div>
<p>作为一种可选方案，响应中还可以包含以
<a href=https://datatracker.ietf.org/doc/html/rfc3339>RFC 3339</a>
时间戳格式给出的证书到期时间。
证书到期时间的有无会有如下影响：</p>
<ul>
<li>如果响应中包含了到期时间，持有者令牌和 TLS 凭据会被缓存，直到到期期限到来、
或者服务器返回 401 HTTP 状态码，或者进程退出。</li>
<li>如果未指定到期时间，则持有者令牌和 TLS 凭据会被缓存，直到服务器返回 401
HTTP 状态码或者进程退出。</li>
</ul>
<ul class="nav nav-tabs" id=exec-plugin-execcredential-example-3 role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#exec-plugin-execcredential-example-3-0 role=tab aria-controls=exec-plugin-execcredential-example-3-0 aria-selected=true>client.authentication.k8s.io/v1</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#exec-plugin-execcredential-example-3-1 role=tab aria-controls=exec-plugin-execcredential-example-3-1>client.authentication.k8s.io/v1beta1</a></li></ul>
<div class=tab-content id=exec-plugin-execcredential-example-3><div id=exec-plugin-execcredential-example-3-0 class="tab-pane show active" role=tabpanel aria-labelledby=exec-plugin-execcredential-example-3-0>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
  <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;client.authentication.k8s.io/v1&#34;</span>,
  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;ExecCredential&#34;</span>,
  <span style=color:green;font-weight:700>&#34;status&#34;</span>: {
    <span style=color:green;font-weight:700>&#34;token&#34;</span>: <span style=color:#b44>&#34;my-bearer-token&#34;</span>,
    <span style=color:green;font-weight:700>&#34;expirationTimestamp&#34;</span>: <span style=color:#b44>&#34;2018-03-05T17:30:20-08:00&#34;</span>
  }
}
</code></pre></div></div>
<div id=exec-plugin-execcredential-example-3-1 class=tab-pane role=tabpanel aria-labelledby=exec-plugin-execcredential-example-3-1>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
  <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;client.authentication.k8s.io/v1beta1&#34;</span>,
  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;ExecCredential&#34;</span>,
  <span style=color:green;font-weight:700>&#34;status&#34;</span>: {
    <span style=color:green;font-weight:700>&#34;token&#34;</span>: <span style=color:#b44>&#34;my-bearer-token&#34;</span>,
    <span style=color:green;font-weight:700>&#34;expirationTimestamp&#34;</span>: <span style=color:#b44>&#34;2018-03-05T17:30:20-08:00&#34;</span>
  }
}
</code></pre></div></div></div>
<p>为了让 exec 插件能够获得特定与集群的信息，可以在
<a href=/zh/docs/concepts/configuration/organize-cluster-access-kubeconfig/>kubeconfig</a>
中的 <code>user.exec</code> 设置 <code>provideClusterInfo</code>。
这一特定于集群的信息就会通过 <code>KUBERNETES_EXEC_INFO</code> 环境变量传递给插件。
此环境变量中的信息可以用来执行特定于集群的凭据获取逻辑。
下面的 <code>ExecCredential</code> 清单描述的是一个示例集群信息。</p>
<ul class="nav nav-tabs" id=exec-plugin-execcredential-example-4 role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#exec-plugin-execcredential-example-4-0 role=tab aria-controls=exec-plugin-execcredential-example-4-0 aria-selected=true>client.authentication.k8s.io/v1</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#exec-plugin-execcredential-example-4-1 role=tab aria-controls=exec-plugin-execcredential-example-4-1>client.authentication.k8s.io/v1beta1</a></li></ul>
<div class=tab-content id=exec-plugin-execcredential-example-4><div id=exec-plugin-execcredential-example-4-0 class="tab-pane show active" role=tabpanel aria-labelledby=exec-plugin-execcredential-example-4-0>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
  <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;client.authentication.k8s.io/v1&#34;</span>,
  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;ExecCredential&#34;</span>,
  <span style=color:green;font-weight:700>&#34;spec&#34;</span>: {
    <span style=color:green;font-weight:700>&#34;cluster&#34;</span>: {
      <span style=color:green;font-weight:700>&#34;server&#34;</span>: <span style=color:#b44>&#34;https://172.17.4.100:6443&#34;</span>,
      <span style=color:green;font-weight:700>&#34;certificate-authority-data&#34;</span>: <span style=color:#b44>&#34;LS0t...&#34;</span>,
      <span style=color:green;font-weight:700>&#34;config&#34;</span>: {
        <span style=color:green;font-weight:700>&#34;arbitrary&#34;</span>: <span style=color:#b44>&#34;config&#34;</span>,
        <span style=color:green;font-weight:700>&#34;this&#34;</span>: <span style=color:#b44>&#34;可以在设置 provideClusterInfo 时通过 KUBERNETES_EXEC_INFO 环境变量提供&#34;</span>,
        <span style=color:green;font-weight:700>&#34;you&#34;</span>: [<span style=color:#b44>&#34;can&#34;</span>, <span style=color:#b44>&#34;put&#34;</span>, <span style=color:#b44>&#34;anything&#34;</span>, <span style=color:#b44>&#34;here&#34;</span>]
      }
    },
    <span style=color:green;font-weight:700>&#34;interactive&#34;</span>: <span style=color:#a2f;font-weight:700>true</span>
  }
}
</code></pre></div></div>
<div id=exec-plugin-execcredential-example-4-1 class=tab-pane role=tabpanel aria-labelledby=exec-plugin-execcredential-example-4-1>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
  <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;client.authentication.k8s.io/v1beta1&#34;</span>,
  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;ExecCredential&#34;</span>,
  <span style=color:green;font-weight:700>&#34;spec&#34;</span>: {
    <span style=color:green;font-weight:700>&#34;cluster&#34;</span>: {
      <span style=color:green;font-weight:700>&#34;server&#34;</span>: <span style=color:#b44>&#34;https://172.17.4.100:6443&#34;</span>,
      <span style=color:green;font-weight:700>&#34;certificate-authority-data&#34;</span>: <span style=color:#b44>&#34;LS0t...&#34;</span>,
      <span style=color:green;font-weight:700>&#34;config&#34;</span>: {
        <span style=color:green;font-weight:700>&#34;arbitrary&#34;</span>: <span style=color:#b44>&#34;config&#34;</span>,
        <span style=color:green;font-weight:700>&#34;this&#34;</span>: <span style=color:#b44>&#34;可以在设置 provideClusterInfo 时通过 KUBERNETES_EXEC_INFO 环境变量提供&#34;</span>,
        <span style=color:green;font-weight:700>&#34;you&#34;</span>: [<span style=color:#b44>&#34;can&#34;</span>, <span style=color:#b44>&#34;put&#34;</span>, <span style=color:#b44>&#34;anything&#34;</span>, <span style=color:#b44>&#34;here&#34;</span>]
      }
    },
    <span style=color:green;font-weight:700>&#34;interactive&#34;</span>: <span style=color:#a2f;font-weight:700>true</span>
  }
}
</code></pre></div></div></div>
<h2 id=what-s-next>What's next</h2>
<ul>
<li>阅读<a href=/zh/docs/reference/config-api/client-authentication.v1beta1/>客户端认证参考文档 (v1beta1)</a></li>
<li>阅读<a href=/zh/docs/reference/config-api/client-authentication.v1/>客户端认证参考文档 (v1)</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-de45b6ca7419a0e308044425b2ac52bb>3.2 - 使用启动引导令牌（Bootstrap Tokens）认证</h1>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.18 [stable]</code>
</div>
<p>启动引导令牌是一种简单的持有者令牌（Bearer Token），这种令牌是在新建集群
或者在现有集群中添加新节点时使用的。
它被设计成能够支持 <a href=/zh/docs/reference/setup-tools/kubeadm/><code>kubeadm</code></a>，
但是也可以被用在其他的案例中以便用户在不使用 <code>kubeadm</code> 的情况下启动集群。
它也被设计成可以通过 RBAC 策略，结合
<a href=/zh/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/>Kubelet TLS 启动引导</a>
系统进行工作。</p>
<p>启动引导令牌被定义成一个特定类型的 Secret（<code>bootstrap.kubernetes.io/token</code>），
并存在于 <code>kube-system</code> 名字空间中。
这些 Secret 会被 API 服务器上的启动引导认证组件（Bootstrap Authenticator）读取。
控制器管理器中的控制器 TokenCleaner 能够删除过期的令牌。
这些令牌也被用来在节点发现的过程中会使用的一个特殊的 ConfigMap 对象。
BootstrapSigner 控制器也会使用这一 ConfigMap。</p>
<h2 id=令牌格式>令牌格式</h2>
<p>启动引导令牌使用 <code>abcdef.0123456789abcdef</code> 的形式。
更加规范地说，它们必须符合正则表达式 <code>[a-z0-9]{6}\.[a-z0-9]{16}</code>。</p>
<p>令牌的第一部分是 “Token ID”，它是一种公开信息，用于引用令牌并确保不会
泄露认证所使用的秘密信息。
第二部分是“令牌秘密（Token Secret）”，它应该被共享给受信的第三方。</p>
<h2 id=启用启动引导令牌>启用启动引导令牌</h2>
<h2 id=enabling-bootstrap-token-authentication>启用启动引导令牌身份认证 </h2>
<p>启动引导令牌认证组件可以通过 API 服务器上的如下标志启用：</p>
<pre><code>--enable-bootstrap-token-auth
</code></pre>
<p>启动引导令牌被启用后，可以作为持有者令牌的凭据，用于 API 服务器请求的身份认证。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-http data-lang=http><span>Authorization: Bearer 07401b.f395accd246ae52d
</span></code></pre></div>
<p>令牌认证为用户名 <code>system:bootstrap:&lt;token id></code> 并且是组 <code>system:bootstrappers</code>
的成员。额外的组信息可以通过令牌的 Secret 来设置。</p>
<p>过期的令牌可以通过启用控制器管理器中的 <code>tokencleaner</code> 控制器来删除。</p>
<h2 id=bootstrap-token-secret-format>启动引导令牌的 Secret 格式 </h2>
<p>每个合法的令牌背后对应着 <code>kube-system</code> 名字空间中的某个 Secret 对象。
你可以从
<a href=https://github.com/kubernetes/community/blob/master/contributors/design-proposals/cluster-lifecycle/bootstrap-discovery.md>这里</a>
找到完整设计文档。</p>
<p>这是 Secret 看起来的样子。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># name 必须是 &#34;bootstrap-token-&lt;token id&gt;&#34; 格式的</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>bootstrap-token-07401b<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>kube-system<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># type 必须是 &#39;bootstrap.kubernetes.io/token&#39;</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>bootstrap.kubernetes.io/token<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>stringData</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 供人阅读的描述，可选。</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>description</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;The default bootstrap token generated by &#39;kubeadm init&#39;.&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 令牌 ID 和秘密信息，必需。</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>token-id</span>:<span style=color:#bbb> </span>07401b<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>token-secret</span>:<span style=color:#bbb> </span>base64(f395accd246ae52d)<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 可选的过期时间字段</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>expiration</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2017-03-10T03:22:11Z&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 允许的用法</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>usage-bootstrap-authentication</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>usage-bootstrap-signing</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 令牌要认证为的额外组，必须以 &#34;system:bootstrappers:&#34; 开头</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>auth-extra-groups</span>:<span style=color:#bbb> </span>system:bootstrappers:worker,system:bootstrappers:ingress<span style=color:#bbb>
</span></code></pre></div>
<p>Secret 的类型必须是 <code>bootstrap.kubernetes.io/token</code>，而且名字必须是 <code>bootstrap-token-&lt;token id></code>。
令牌必须存在于 <code>kube-system</code> 名字空间中。</p>
<p><code>usage-bootstrap-*</code> 成员表明这个 Secret 的用途。启用时，值必须设置为 <code>true</code>。</p>
<ul>
<li><code>usage-bootstrap-authentication</code> 表示令牌可以作为持有者令牌用于 API 服务器的身份认证。</li>
<li><code>usage-bootstrap-signing</code> 表示令牌可被用于 <code>cluster-info</code> ConfigMap 的签名，
就像下面描述的那样。</li>
</ul>
<p><code>expiration</code> 字段控制令牌的失效期。过期的令牌在用于身份认证时会被拒绝，在用于
ConfigMap 签名时会被忽略。
过期时间值是遵循 RFC3339 进行编码的 UTC 时间。
启用 TokenCleaner 控制器会自动删除过期的令牌。</p>
<h2 id=token-management-with-kubeadm>使用 <code>kubeadm</code> 管理令牌 </h2>
<p>你可以使用 <code>kubeadm</code> 工具管理运行中集群上的令牌。
参见 <a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-token/>kubeadm token 文档</a>
以了解详细信息。</p>
<h3 id=configmap-signing>ConfigMap 签名 </h3>
<p>除了身份认证，令牌还可以用于签名 ConfigMap。
这一用法发生在集群启动过程的早期，在客户端信任 API 服务器之前。
被签名的 ConfigMap 可以被共享令牌完成身份认证。</p>
<p>通过在控制器管理器上启用 <code>bootstrapsigner</code> 控制器可以启用 ConfigMap 签名特性。</p>
<pre><code>--controllers=*,bootstrapsigner
</code></pre>
<p>被签名的 ConfigMap 是 <code>kube-public</code> 名字空间中的 <code>cluster-info</code>。
典型的工作流中，客户端在未经认证和忽略 TLS 报错的状态下读取这个 ConfigMap。
通过检查 ConfigMap 中嵌入的签名校验 ConfigMap 的载荷。</p>
<p>ConfigMap 会是这个样子的：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cluster-info<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>kube-public<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>jws-kubeconfig-07401b</span>:<span style=color:#bbb> </span>eyJhbGciOiJIUzI1NiIsImtpZCI6IjA3NDAxYiJ9..tYEfbo6zDNo40MQE07aZcQX2m3EB2rO3NuXtxVMYm9U<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>kubeconfig</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span><span style=color:#b44;font-style:italic>    apiVersion: v1
</span><span style=color:#b44;font-style:italic>    clusters:
</span><span style=color:#b44;font-style:italic>    - cluster:
</span><span style=color:#b44;font-style:italic>        certificate-authority-data: &lt;非常长的证书数据&gt;
</span><span style=color:#b44;font-style:italic>        server: https://10.138.0.2:6443
</span><span style=color:#b44;font-style:italic>      name: &#34;&#34;
</span><span style=color:#b44;font-style:italic>    contexts: []
</span><span style=color:#b44;font-style:italic>    current-context: &#34;&#34;
</span><span style=color:#b44;font-style:italic>    kind: Config
</span><span style=color:#b44;font-style:italic>    preferences: {}
</span><span style=color:#b44;font-style:italic>    users: []</span><span style=color:#bbb>    
</span></code></pre></div>
<p>ConfigMap 的 <code>kubeconfig</code> 成员是一个填好了集群信息的配置文件。
这里主要交换的信息是 <code>certificate-authority-data</code>。在将来可能会有扩展。</p>
<p>签名是一个使用 “detached” 模式生成的 JWS 签名。
为了检验签名，用户应该按照 JWS 规则（base64 编码且丢掉结尾的 <code>=</code>）对
<code>kubeconfig</code> 的载荷进行编码。完成编码的载荷会被插入到两个句点中间，形成完整的
JWS。你可以使用完整的令牌（比如 <code>07401b.f395accd246ae52d</code>）作为共享密钥，
通过 <code>HS256</code> 方式 (HMAC-SHA256) 对 JWS 进行校验。
用户 <em>必须</em> 确保使用了 HS256。</p>
<div class="alert alert-danger warning callout" role=alert>
<strong>Warning:</strong>
<p>任何拥有了启动引导令牌的主体都可以为该令牌生成一个合法的签名。
当使用 ConfigMap 签名时，非常不建议针对很多客户使用相同的令牌，因为某个被攻击的
客户可能对另一个一来签名来开启 TLS 信任的客户发起中间人攻击。
</div>
<p>参考 <a href=/zh/docs/reference/setup-tools/kubeadm/implementation-details/>kubeadm 实现细节</a>
了解更多信息。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-3d0c14d1e3cfade38febc343cd044c73>3.3 - 证书签名请求</h1>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.19 [stable]</code>
</div>
<p>证书 API 支持
<a href=https://www.itu.int/rec/T-REC-X.509>X.509</a>
的自动化配置，
它为 Kubernetes API 的客户端提供一个编程接口，
用于从证书颁发机构（CA）请求并获取 X.509
<a class=glossary-tooltip title="证书是个安全加密文件，用来确认对 Kubernetes 集群访问的合法性。" data-toggle=tooltip data-placement=top href=/zh/docs/tasks/tls/managing-tls-in-a-cluster/ target=_blank aria-label=证书>证书</a>。</p>
<p>CertificateSigningRequest（CSR）资源用来向指定的签名者申请证书签名，
在最终签名之前，申请可能被批准，也可能被拒绝。</p>
<h2 id=request-signing-process>请求签名流程</h2>
<p>CertificateSigningRequest 资源类型允许客户使用它申请发放 X.509 证书。
CertificateSigningRequest 对象 在 <code>spec.request</code> 中包含一个 PEM 编码的 PKCS#10 签名请求。
CertificateSigningRequest 使用 <code>spec.signerName</code> 字段标示 <em>签名者</em>（请求的接收方）。
注意，<code>spec.signerName</code> 在 <code>certificates.k8s.io/v1</code> 之后的 API 版本是必填项。
在 Kubernetes v1.22 和以后的版本，客户可以可选地设置 <code>spec.expirationSeconds</code>
字段来为颁发的证书设定一个特定的有效期。该字段的最小有效值是 <code>600</code>，也就是 10 分钟。</p>
<p>创建完成的 CertificateSigningRequest，要先通过批准，然后才能签名。
根据所选的签名者，CertificateSigningRequest 可能会被
<a class=glossary-tooltip title="控制器通过 apiserver 监控集群的公共状态，并致力于将当前状态转变为期望的状态。" data-toggle=tooltip data-placement=top href=/zh/docs/concepts/architecture/controller/ target=_blank aria-label=控制器>控制器</a>自动批准。
否则，就必须人工批准，
人工批准可以使用 REST API（或 go 客户端），也可以执行 <code>kubectl certificate approve</code> 命令。
同样，CertificateSigningRequest 也可能被驳回，
这就相当于通知了指定的签名者，这个证书不能签名。</p>
<p>对于已批准的证书，下一步是签名。
对应的签名控制器首先验证签名条件是否满足，然后才创建证书。
签名控制器然后更新 CertificateSigningRequest，
将新证书保存到现有 CertificateSigningRequest 对象的 <code>status.certificate</code> 字段中。
此时，字段 <code>status.certificate</code> 要么为空，要么包含一个用 PEM 编码的 X.509 证书。
直到签名完成前，CertificateSigningRequest 的字段 <code>status.certificate</code> 都为空。</p>
<p>一旦 <code>status.certificate</code> 字段完成填充，请求既算完成，
客户端现在可以从 CertificateSigningRequest 资源中获取已签名的证书的 PEM 数据。
当然如果不满足签名条件，签名者可以拒签。</p>
<p>为了减少集群中遗留的过时的 CertificateSigningRequest 资源的数量，
一个垃圾收集控制器将会周期性地运行。
此垃圾收集器会清除在一段时间内没有改变过状态的 CertificateSigningRequests：</p>
<ul>
<li>已批准的请求：1小时后自动删除</li>
<li>已拒绝的请求：1小时后自动删除</li>
<li>已失败的请求：1小时后自动删除</li>
<li>挂起的请求：24小时后自动删除</li>
<li>所有请求：在颁发的证书过期后自动删除</li>
</ul>
<h2 id=signers>签名者</h2>
<p>也可以指定自定义 signerName。
所有签名者都应该提供自己工作方式的信息，
以便客户端可以预期到他们的 CSR 将发生什么。
此类信息包括：</p>
<ol>
<li><strong>信任分发</strong>：信任（CA 证书包）是如何分发的。</li>
<li><strong>许可的主体</strong>：当一个受限制的主体（subject）发送请求时，相应的限制和应对手段。</li>
<li><strong>许可的 x509 扩展</strong>：包括 IP subjectAltNames、DNS subjectAltNames、
Email subjectAltNames、URI subjectAltNames 等，请求一个受限制的扩展项时的应对手段。</li>
<li><strong>许可的密钥用途/扩展的密钥用途</strong>：当用途和签名者在 CSR 中指定的用途不同时，
相应的限制和应对手段。</li>
<li><strong>过期时间/证书有效期</strong>：过期时间由签名者确定、由管理员配置、还是由 CSR <code>spec.expirationSeconds</code> 字段指定等，
以及签名者决定的过期时间与 CSR <code>spec.expirationSeconds</code> 字段不同时的应对手段。</li>
<li><strong>允许/不允许 CA 位</strong>：当 CSR 包含一个签名者并不允许的 CA 证书的请求时，相应的应对手段。</li>
</ol>
<p>一般来说，当 CSR 被批准通过，且证书被签名后，<code>status.certificate</code> 字段
将包含一个 PEM 编码的 X.509 证书。
有些签名者在 <code>status.certificate</code> 字段中存储多个证书。
在这种情况下，签名者的说明文档应当指明附加证书的含义。
例如，这是要在 TLS 握手时提供的证书和中继证书。</p>
<p>PKCS#10 签名请求格式并没有一种标准的方法去设置证书的过期时间或者生命期。
因此，证书的过期时间或者生命期必须通过 CSR 对象的 <code>spec.expirationSeconds</code> 字段来设置。
当 <code>spec.expirationSeconds</code> 没有被指定时，内置的签名者默认使用 <code>ClusterSigningDuration</code> 配置选项
（kube-controller-manager 的命令行选项 <code>--cluster-signing-duration</code>），该选项的默认值设为 1 年。
当 <code>spec.expirationSeconds</code> 被指定时，<code>spec.expirationSeconds</code> 和 <code>ClusterSigningDuration</code>
中的最小值会被使用。</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong>
<p><code>spec.expirationSeconds</code> 字段是在 Kubernetes v1.22 中加入的。早期的 Kubernetes 版本并不认识该字段。
v1.22 版本之前的 Kubernetes API 服务器会在创建对象的时候忽略该字段。
</div>
<h3 id=kubernetes-signers>Kubernetes 签名者</h3>
<p>Kubernetes提供了内置的签名者，每个签名者都有一个众所周知的 <code>signerName</code>:</p>
<ol>
<li><code>kubernetes.io/kube-apiserver-client</code>：签名的证书将被 API 服务器视为客户证书。
<a class=glossary-tooltip title=主节点上运行控制器的组件。 data-toggle=tooltip data-placement=top href=/docs/reference/generated/kube-controller-manager/ target=_blank aria-label=kube-controller-manager>kube-controller-manager</a> 不会自动批准它。
<ol>
<li>信任分发：签名的证书将被 API 服务器视为客户端证书。CA 证书包不通过任何其他方式分发。</li>
<li>许可的主体：没有主体限制，但审核人和签名者可以选择不批准或不签署。
某些主体，比如集群管理员级别的用户或组因部署和安装方式不同而不同，
所以批准和签署之前需要进行额外仔细审查。
用来限制 <code>system:masters</code> 的 CertificateSubjectRestriction 准入插件默认处于启用状态，
但它通常不是集群中唯一的集群管理员主体。</li>
<li>许可的 x509 扩展：允许 subjectAltName 和 key usage 扩展，弃用其他扩展。</li>
<li>许可的密钥用途：必须包含 <code>["client auth"]</code>，但不能包含
<code>["digital signature", "key encipherment", "client auth"]</code> 之外的键。</li>
<li>过期时间/证书有效期：对于 kube-controller-manager 实现的签名者，
设置为 <code>--cluster-signing-duration</code> 选项和 CSR 对象的 <code>spec.expirationSeconds</code> 字段（如有设置该字段）中的最小值。</li>
<li>允许/不允许 CA 位：不允许。</li>
</ol>
</li>
</ol>
<ol start=2>
<li>
<p><code>kubernetes.io/kube-apiserver-client-kubelet</code>: 签名的证书将被 kube-apiserver 视为客户证书。
<a class=glossary-tooltip title=主节点上运行控制器的组件。 data-toggle=tooltip data-placement=top href=/docs/reference/generated/kube-controller-manager/ target=_blank aria-label=kube-controller-manager>kube-controller-manager</a> 可以自动批准它。</p>
<ol>
<li>信任分发：签名的证书将被 API 服务器视为客户端证书。CA 证书包不通过任何其他方式分发。</li>
<li>许可的主体：组织名必须是 <code>["system:nodes"]</code>，用户名以 "<code>system:node:</code>" 开头</li>
<li>许可的 x509 扩展：允许 key usage 扩展，禁用 subjectAltName 扩展，并删除其他扩展。</li>
<li>许可的密钥用途：必须是 <code>["key encipherment", "digital signature", "client auth"]</code></li>
<li>过期时间/证书有效期：对于 kube-controller-manager 实现的签名者，
设置为 <code>--cluster-signing-duration</code> 选项和 CSR 对象的 <code>spec.expirationSeconds</code> 字段（如有设置该字段）中的最小值。</li>
<li>允许/不允许 CA 位：不允许。</li>
</ol>
</li>
</ol>
<ol start=3>
<li><code>kubernetes.io/kubelet-serving</code>: 签名服务证书，该服务证书被 API 服务器视为有效的 kubelet 服务证书，
但没有其他保证。<a class=glossary-tooltip title=主节点上运行控制器的组件。 data-toggle=tooltip data-placement=top href=/docs/reference/generated/kube-controller-manager/ target=_blank aria-label=kube-controller-manager>kube-controller-manager</a> 不会自动批准它。
<ol>
<li>信任分发：签名的证书必须被 kube-apiserver 认可，可有效的中止 kubelet 连接。CA 证书包不通过任何其他方式分发。</li>
<li>许可的主体：组织名必须是 <code>["system:nodes"]</code>，用户名以 "<code>system:node:</code>" 开头</li>
<li>许可的 x509 扩展：允许 key usage、DNSName/IPAddress subjectAltName 等扩展，
禁止 EmailAddress、URI subjectAltName 等扩展，并丢弃其他扩展。
至少有一个 DNS 或 IP 的 SubjectAltName 存在。</li>
<li>许可的密钥用途：必须是 <code>["key encipherment", "digital signature", "server auth"]</code></li>
<li>过期时间/证书有效期：对于 kube-controller-manager 实现的签名者，
设置为 <code>--cluster-signing-duration</code> 选项和 CSR 对象的 <code>spec.expirationSeconds</code> 字段（如有设置该字段）中的最小值。</li>
<li>允许/不允许 CA 位：不允许。</li>
</ol>
</li>
</ol>
<ol start=4>
<li><code>kubernetes.io/legacy-unknown</code>: 不保证信任。Kubernetes 的一些第三方发行版可能会使用它签署的客户端证书。
稳定版的 CertificateSigningRequest API（<code>certificates.k8s.io/v1</code> 以及之后的版本）不允许将
<code>signerName</code> 设置为 <code>kubernetes.io/legacy-unknown</code>。
<a class=glossary-tooltip title=主节点上运行控制器的组件。 data-toggle=tooltip data-placement=top href=/docs/reference/generated/kube-controller-manager/ target=_blank aria-label=kube-controller-manager>kube-controller-manager</a> 不会自动批准这类请求。
<ol>
<li>信任分发：没有。这个签名者在 Kubernetes 集群中没有标准的信任或分发。</li>
<li>许可的主体：全部。</li>
<li>许可的 x509 扩展：允许 subjectAltName 和 key usage 等扩展，并弃用其他扩展。</li>
<li>许可的密钥用途：全部。</li>
<li>过期时间/证书有效期：对于 kube-controller-manager 实现的签名者，
设置为 <code>--cluster-signing-duration</code> 选项和 CSR 对象的 <code>spec.expirationSeconds</code> 字段（如有设置该字段）中的最小值。</li>
<li>允许/不允许 CA 位 - 不允许。</li>
</ol>
</li>
</ol>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong>
<p>注意：所有这些故障仅在 kube-controller-manager 日志中报告。
</div>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong>
<p><code>spec.expirationSeconds</code> 字段是在 Kubernetes v1.22 中加入的。早期的 Kubernetes 版本并不认识该字段。
v1.22 版本之前的 Kubernetes API 服务器会在创建对象的时候忽略该字段。
</div>
<p>对于这些签名者，信任的分发发生在带外（out of band）。上述信任之外的任何信任都是完全巧合的。
例如，一些发行版可能会将 <code>kubernetes.io/legacy-unknown</code> 作为 kube-apiserver 的客户端证书，
但这个做法并不标准。
这些用途都没有以任何方式涉及到 ServiceAccount 中的 Secrets <code>.data[ca.crt]</code>。
此 CA 证书包只保证使用默认的服务（<code>kubernetes.default.svc</code>）来验证到 API 服务器的连接。</p>
<h2 id=authorization>鉴权</h2>
<p>授权创建 CertificateSigningRequest 和检索 CertificateSigningRequest:</p>
<ul>
<li>verbs（动词）: <code>create</code>、<code>get</code>、<code>list</code>、<code>watch</code>,
group（组）：<code>certificates.k8s.io</code>，
resources：<code>certificatesigningrequests</code></li>
</ul>
<p>例如：</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/access/certificate-signing-request/clusterrole-create.yaml download=access/certificate-signing-request/clusterrole-create.yaml><code>access/certificate-signing-request/clusterrole-create.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('access-certificate-signing-request-clusterrole-create-yaml')" title="Copy access/certificate-signing-request/clusterrole-create.yaml to clipboard">
</img>
</div>
<div class=includecode id=access-certificate-signing-request-clusterrole-create-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>csr-creator<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- certificates.k8s.io<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- certificatesigningrequests<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- create<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- get<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- list<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- watch<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>授权批准 CertificateSigningRequest：</p>
<ul>
<li>verbs（动词）: <code>get</code>、<code>list</code>、<code>watch</code>，
group（组）：<code>certificates.k8s.io</code>，
resources（资源）：<code>certificatesigningrequests</code></li>
<li>verbs（动词）: <code>update</code>，
group（组）：<code>certificates.k8s.io</code>，
resources（资源）：<code>certificatesigningrequests/approval</code></li>
<li>verbs（动词）：<code>approve</code>，
group（组）：<code>certificates.k8s.io</code>，
resources（资源）：<code>signers</code>，
resourceName：<code>&lt;signerNameDomain>/&lt;signerNamePath></code> 或 <code>&lt;signerNameDomain>/*</code></li>
</ul>
<p>例如：</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/access/certificate-signing-request/clusterrole-approve.yaml download=access/certificate-signing-request/clusterrole-approve.yaml><code>access/certificate-signing-request/clusterrole-approve.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('access-certificate-signing-request-clusterrole-approve-yaml')" title="Copy access/certificate-signing-request/clusterrole-approve.yaml to clipboard">
</img>
</div>
<div class=includecode id=access-certificate-signing-request-clusterrole-approve-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>csr-approver<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- certificates.k8s.io<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- certificatesigningrequests<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- get<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- list<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- watch<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- certificates.k8s.io<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- certificatesigningrequests/approval<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- update<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- certificates.k8s.io<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- signers<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resourceNames</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- example.com/my-signer-name<span style=color:#bbb> </span><span style=color:#080;font-style:italic># example.com/* can be used to authorize for all signers in the &#39;example.com&#39; domain</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- approve<span style=color:#bbb>
</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>授权签名 CertificateSigningRequest：</p>
<ul>
<li>verbs（动词）：<code>get</code>、<code>list</code>、<code>watch</code>，
group（组）：<code>certificates.k8s.io</code>，
resources（资源）：<code>certificatesigningrequests</code></li>
<li>verbs（动词）：<code>update</code>，
group（组）：<code>certificates.k8s.io</code>，
resources（资源）：<code>certificatesigningrequests/status</code></li>
<li>verbs（动词）：<code>sign</code>，
group（组）：<code>certificates.k8s.io</code>，
resources（资源）：<code>signers</code>，
resourceName：<code>&lt;signerNameDomain>/&lt;signerNamePath></code> 或 <code>&lt;signerNameDomain>/*</code></li>
</ul>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/access/certificate-signing-request/clusterrole-sign.yaml download=access/certificate-signing-request/clusterrole-sign.yaml><code>access/certificate-signing-request/clusterrole-sign.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('access-certificate-signing-request-clusterrole-sign-yaml')" title="Copy access/certificate-signing-request/clusterrole-sign.yaml to clipboard">
</img>
</div>
<div class=includecode id=access-certificate-signing-request-clusterrole-sign-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>csr-signer<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- certificates.k8s.io<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- certificatesigningrequests<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- get<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- list<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- watch<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- certificates.k8s.io<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- certificatesigningrequests/status<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- update<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- certificates.k8s.io<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- signers<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resourceNames</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- example.com/my-signer-name<span style=color:#bbb> </span><span style=color:#080;font-style:italic># example.com/* can be used to authorize for all signers in the &#39;example.com&#39; domain</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- sign<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<h2 id=normal-user>普通用户</h2>
<p>为了让普通用户能够通过认证并调用 API，需要执行几个步骤。
首先，该用户必须拥有 Kubernetes 集群签发的证书，
然后将该证书提供给 Kubernetes API。</p>
<h3 id=create-private-key>创建私钥</h3>
<p>下面的脚本展示了如何生成 PKI 私钥和 CSR。
设置 CSR 的 CN 和 O 属性很重要。CN 是用户名，O 是该用户归属的组。
你可以参考 <a href=/zh/docs/reference/access-authn-authz/rbac/>RBAC</a> 了解标准组的信息。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>openssl genrsa -out myuser.key <span style=color:#666>2048</span>
openssl req -new -key myuser.key -out myuser.csr
</code></pre></div>
<h3 id=create-certificatesigningrequest>创建 CertificateSigningRequest</h3>
<p>创建一个 CertificateSigningRequest，并通过 kubectl 将其提交到 Kubernetes 集群。
下面是生成 CertificateSigningRequest 的脚本。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>cat <span style=color:#b44>&lt;&lt;EOF | kubectl apply -f -
</span><span style=color:#b44>apiVersion: certificates.k8s.io/v1
</span><span style=color:#b44>kind: CertificateSigningRequest
</span><span style=color:#b44>metadata:
</span><span style=color:#b44>  name: myuser
</span><span style=color:#b44>spec:
</span><span style=color:#b44>  request: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURSBSRVFVRVNULS0tLS0KTUlJQ1ZqQ0NBVDRDQVFBd0VURVBNQTBHQTFVRUF3d0dZVzVuWld4aE1JSUJJakFOQmdrcWhraUc5dzBCQVFFRgpBQU9DQVE4QU1JSUJDZ0tDQVFFQTByczhJTHRHdTYxakx2dHhWTTJSVlRWMDNHWlJTWWw0dWluVWo4RElaWjBOCnR2MUZtRVFSd3VoaUZsOFEzcWl0Qm0wMUFSMkNJVXBGd2ZzSjZ4MXF3ckJzVkhZbGlBNVhwRVpZM3ExcGswSDQKM3Z3aGJlK1o2MVNrVHF5SVBYUUwrTWM5T1Nsbm0xb0R2N0NtSkZNMUlMRVI3QTVGZnZKOEdFRjJ6dHBoaUlFMwpub1dtdHNZb3JuT2wzc2lHQ2ZGZzR4Zmd4eW8ybmlneFNVekl1bXNnVm9PM2ttT0x1RVF6cXpkakJ3TFJXbWlECklmMXBMWnoyalVnald4UkhCM1gyWnVVV1d1T09PZnpXM01LaE8ybHEvZi9DdS8wYk83c0x0MCt3U2ZMSU91TFcKcW90blZtRmxMMytqTy82WDNDKzBERHk5aUtwbXJjVDBnWGZLemE1dHJRSURBUUFCb0FBd0RRWUpLb1pJaHZjTgpBUUVMQlFBRGdnRUJBR05WdmVIOGR4ZzNvK21VeVRkbmFjVmQ1N24zSkExdnZEU1JWREkyQTZ1eXN3ZFp1L1BVCkkwZXpZWFV0RVNnSk1IRmQycVVNMjNuNVJsSXJ3R0xuUXFISUh5VStWWHhsdnZsRnpNOVpEWllSTmU3QlJvYXgKQVlEdUI5STZXT3FYbkFvczFqRmxNUG5NbFpqdU5kSGxpT1BjTU1oNndLaTZzZFhpVStHYTJ2RUVLY01jSVUyRgpvU2djUWdMYTk0aEpacGk3ZnNMdm1OQUxoT045UHdNMGM1dVJVejV4T0dGMUtCbWRSeEgvbUNOS2JKYjFRQm1HCkkwYitEUEdaTktXTU0xMzhIQXdoV0tkNjVoVHdYOWl4V3ZHMkh4TG1WQzg0L1BHT0tWQW9FNkpsYWFHdTlQVmkKdjlOSjVaZlZrcXdCd0hKbzZXdk9xVlA3SVFjZmg3d0drWm89Ci0tLS0tRU5EIENFUlRJRklDQVRFIFJFUVVFU1QtLS0tLQo=
</span><span style=color:#b44>  signerName: kubernetes.io/kube-apiserver-client
</span><span style=color:#b44>  expirationSeconds: 86400  # one day
</span><span style=color:#b44>  usages:
</span><span style=color:#b44>  - client auth
</span><span style=color:#b44>EOF</span>
</code></pre></div>
<p>需要注意的几点:</p>
<ul>
<li><code>usage</code> 字段必须是 '<code>client auth</code>'</li>
<li><code>expirationSeconds</code> 可以设置为更长（例如 <code>864000</code> 是十天）或者更短（例如 <code>3600</code> 是一个小时）</li>
<li><code>request</code> 字段是 CSR 文件内容的 base64 编码值。
要得到该值，可以执行命令 <code>cat myuser.csr | base64 | tr -d "\n"</code>。</li>
</ul>
<h3 id=approve-certificate-signing-request>批准证书签名请求</h3>
<p>使用 kubectl 创建 CSR 并批准。</p>
<p>获取 CSR 列表：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get csr
</code></pre></div>
<p>批准 CSR：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl certificate approve myuser
</code></pre></div>
<h3 id=get-the-certificate>取得证书</h3>
<p>从 CSR 取得证书：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get csr/myuser -o yaml
</code></pre></div>
<p>证书的内容使用 base64 编码，存放在字段 <code>status.certificate</code>。</p>
<p>从 CertificateSigningRequest 导出颁发的证书。</p>
<pre><code>kubectl get csr myuser -o jsonpath='{.status.certificate}'| base64 -d &gt; myuser.crt
</code></pre>
<h3 id=create-role-and-role-binding>创建角色和角色绑定</h3>
<p>创建了证书之后，为了让这个用户能访问 Kubernetes 集群资源，现在就要创建
Role 和 RoleBinding 了。</p>
<p>下面是为这个新用户创建 Role 的示例命令：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create role developer --verb<span style=color:#666>=</span>create --verb<span style=color:#666>=</span>get --verb<span style=color:#666>=</span>list --verb<span style=color:#666>=</span>update --verb<span style=color:#666>=</span>delete --resource<span style=color:#666>=</span>pods
</code></pre></div>
<p>下面是为这个新用户创建 RoleBinding 的示例命令：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create rolebinding developer-binding-myuser --role<span style=color:#666>=</span>developer --user<span style=color:#666>=</span>myuser
</code></pre></div>
<h3 id=add-to-kubeconfig>添加到 kubeconfig </h3>
<p>最后一步是将这个用户添加到 kubeconfig 文件。
我们假设私钥和证书文件存放在 “/home/vagrant/work/” 目录中。</p>
<p>首先，我们需要添加新的凭据：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl config set-credentials myuser --client-key<span style=color:#666>=</span>myuser.key --client-certificate<span style=color:#666>=</span>myuser.crt --embed-certs<span style=color:#666>=</span><span style=color:#a2f>true</span>

</code></pre></div>
<p>然后，你需要添加上下文：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl config set-context myuser --cluster<span style=color:#666>=</span>kubernetes --user<span style=color:#666>=</span>myuser
</code></pre></div>
<p>来测试一下，把上下文切换为 <code>myuser</code>：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl config use-context myuser
</code></pre></div>
<h2 id=approval-rejection>批准和驳回</h2>
<h3 id=approval-rejection-control-plane>控制平面的自动化批准</h3>
<p>kube-controller-manager 内建了一个证书批准者，其 signerName 为
<code>kubernetes.io/kube-apiserver-client-kubelet</code>，
该批准者将 CSR 上用于节点凭据的各种权限委托给权威认证机构。
kube-controller-manager 将 SubjectAccessReview 资源发送（POST）到 API 服务器，
以便检验批准证书的授权。</p>
<h3 id=approval-rejection-kubectl>使用 <code>kubectl</code> 批准或驳回 </h3>
<p>Kubernetes 管理员（拥有足够的权限）可以手工批准（或驳回）CertificateSigningRequests，
此操作使用 <code>kubectl certificate approve</code> 和 <code>kubectl certificate deny</code> 命令实现。</p>
<p>使用 kubectl 批准一个 CSR：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl certificate approve &lt;certificate-signing-request-name&gt;
</code></pre></div>
<p>同样地，驳回一个 CSR：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl certificate deny &lt;certificate-signing-request-name&gt;
</code></pre></div>
<h3 id=approval-rejection-api-client>使用 Kubernetes API 批准或驳回 </h3>
<p>REST API 的用户可以通过向待批准的 CSR 的 <code>approval</code> 子资源提交更新请求来批准 CSR。
例如，你可以编写一个
<a class=glossary-tooltip title=一种用于管理自定义资源的专用控制器 data-toggle=tooltip data-placement=top href=/zh/docs/concepts/extend-kubernetes/operator/ target=_blank aria-label=operator>operator</a>
来监视特定类型的 CSR，然后发送一个更新来批准它。</p>
<p>当你发出批准或驳回的指令时，根据你期望的状态来选择设置 <code>Approved</code> 或 <code>Denied</code>。</p>
<p>批准（<code>Approved</code>） 的 CSR：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>certificates.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>CertificateSigningRequest<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>conditions</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>lastUpdateTime</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2020-02-08T11:37:35Z&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>lastTransitionTime</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2020-02-08T11:37:35Z&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>message</span>:<span style=color:#bbb> </span>Approved by my custom approver controller<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>reason</span>:<span style=color:#bbb> </span>ApprovedByMyPolicy<span style=color:#bbb> </span><span style=color:#080;font-style:italic># You can set this to any string</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Approved<span style=color:#bbb>
</span></code></pre></div>
<p>驳回（<code>Denied</code>）的 CSR：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>certificates.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>CertificateSigningRequest<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>conditions</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>lastUpdateTime</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2020-02-08T11:37:35Z&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>lastTransitionTime</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2020-02-08T11:37:35Z&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>message</span>:<span style=color:#bbb> </span>Denied by my custom approver controller<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>reason</span>:<span style=color:#bbb> </span>DeniedByMyPolicy<span style=color:#bbb> </span><span style=color:#080;font-style:italic># You can set this to any string</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Denied<span style=color:#bbb>
</span></code></pre></div>
<p><code>status.conditions.reason</code> 字段通常设置为一个首字母大写的对机器友好的原因码;
这是一个命名约定，但你也可以随你的个人喜好设置。
如果你想添加一个供人类使用的注释，那就用 <code>status.conditions.message</code> 字段。</p>
<h2 id=signing>签名 </h2>
<h3 id=signer-control-plane>控制平面签名者 </h3>
<p>Kubernetes 控制平面实现了每一个
<a href=/zh/docs/reference/access-authn-authz/certificate-signing-requests/#kubernetes-signers>Kubernetes 签名者</a>，
每个签名者的实现都是 kube-controller-manager 的一部分。</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 在Kubernetes v1.18 之前，
kube-controller-manager 签名所有标记为 approved 的 CSR。
</div>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong>
<p><code>spec.expirationSeconds</code> 字段是在 Kubernetes v1.22 中加入的。早期的 Kubernetes 版本并不认识该字段。
v1.22 版本之前的 Kubernetes API 服务器会在创建对象的时候忽略该字段。
</div>
<h3 id=signer-api>基于 API 的签名者 </h3>
<p>REST API 的用户可以通过向待签名的 CSR 的 <code>status</code> 子资源提交更新请求来对 CSR 进行签名。</p>
<p>作为这个请求的一部分， <code>status.certificate</code> 字段应设置为已签名的证书。
此字段可包含一个或多个 PEM 编码的证书。</p>
<p>所有的 PEM 块必须具备 "CERTIFICATE" 标签，且不包含文件头，且编码的数据必须是
<a href=https://tools.ietf.org/html/rfc5280#section-4.1>RFC5280 第 4 节</a>
中描述的 BER 编码的 ASN.1 证书结构。</p>
<pre><code>-----BEGIN CERTIFICATE-----
MIIDgjCCAmqgAwIBAgIUC1N1EJ4Qnsd322BhDPRwmg3b/oAwDQYJKoZIhvcNAQEL
BQAwXDELMAkGA1UEBhMCeHgxCjAIBgNVBAgMAXgxCjAIBgNVBAcMAXgxCjAIBgNV
BAoMAXgxCjAIBgNVBAsMAXgxCzAJBgNVBAMMAmNhMRAwDgYJKoZIhvcNAQkBFgF4
MB4XDTIwMDcwNjIyMDcwMFoXDTI1MDcwNTIyMDcwMFowNzEVMBMGA1UEChMMc3lz
dGVtOm5vZGVzMR4wHAYDVQQDExVzeXN0ZW06bm9kZToxMjcuMC4wLjEwggEiMA0G
CSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDne5X2eQ1JcLZkKvhzCR4Hxl9+ZmU3
+e1zfOywLdoQxrPi+o4hVsUH3q0y52BMa7u1yehHDRSaq9u62cmi5ekgXhXHzGmm
kmW5n0itRECv3SFsSm2DSghRKf0mm6iTYHWDHzUXKdm9lPPWoSOxoR5oqOsm3JEh
Q7Et13wrvTJqBMJo1GTwQuF+HYOku0NF/DLqbZIcpI08yQKyrBgYz2uO51/oNp8a
sTCsV4OUfyHhx2BBLUo4g4SptHFySTBwlpRWBnSjZPOhmN74JcpTLB4J5f4iEeA7
2QytZfADckG4wVkhH3C2EJUmRtFIBVirwDn39GXkSGlnvnMgF3uLZ6zNAgMBAAGj
YTBfMA4GA1UdDwEB/wQEAwIFoDATBgNVHSUEDDAKBggrBgEFBQcDAjAMBgNVHRMB
Af8EAjAAMB0GA1UdDgQWBBTREl2hW54lkQBDeVCcd2f2VSlB1DALBgNVHREEBDAC
ggAwDQYJKoZIhvcNAQELBQADggEBABpZjuIKTq8pCaX8dMEGPWtAykgLsTcD2jYr
L0/TCrqmuaaliUa42jQTt2OVsVP/L8ofFunj/KjpQU0bvKJPLMRKtmxbhXuQCQi1
qCRkp8o93mHvEz3mTUN+D1cfQ2fpsBENLnpS0F4G/JyY2Vrh19/X8+mImMEK5eOy
o0BMby7byUj98WmcUvNCiXbC6F45QTmkwEhMqWns0JZQY+/XeDhEcg+lJvz9Eyo2
aGgPsye1o3DpyXnyfJWAWMhOz7cikS5X2adesbgI86PhEHBXPIJ1v13ZdfCExmdd
M1fLPhLyR54fGaY+7/X8P9AZzPefAkwizeXwe9ii6/a08vWoiE4=
-----END CERTIFICATE-----
</code></pre>
<p>非 PEM 内容可能会出现在证书 PEM 块前后的位置，且未经验证，
以允许使用 RFC7468 第5.2节 中描述的解释性文本。</p>
<p>当使用 JSON 或 YAML 格式时，此字段是 base-64 编码。
包含上述示例证书的 CertificateSigningRequest 如下所示：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>certificates.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>CertificateSigningRequest<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>certificate</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JS...&#34;</span><span style=color:#bbb>
</span></code></pre></div><h2 id=what-s-next>What's next</h2>
<ul>
<li>参阅 <a href=/zh/docs/tasks/tls/managing-tls-in-a-cluster/>管理集群中的 TLS 认证</a></li>
<li>查看 kube-controller-manager 中<a href=https://github.com/kubernetes/kubernetes/blob/32ec6c212ec9415f604ffc1f4c1f29b782968ff1/pkg/controller/certificates/signer/cfssl_signer.go>签名者</a>部分的源代码</li>
<li>查看 kube-controller-manager 中<a href=https://github.com/kubernetes/kubernetes/blob/32ec6c212ec9415f604ffc1f4c1f29b782968ff1/pkg/controller/certificates/approver/sarapprove.go>批准者</a>部分的源代码</li>
<li>有关 X.509 本身的详细信息，请参阅 <a href=https://tools.ietf.org/html/rfc5280#section-3.1>RFC 5280</a> 第3.1节</li>
<li>有关 PKCS#10 证书签名请求语法的信息，请参阅 <a href=https://tools.ietf.org/html/rfc2986>RFC 2986</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-518807b9b00bda46d7c7e6e0b17c18f8>3.4 - 使用准入控制器</h1>
<p>此页面概述了准入控制器。</p>
<h2 id=什么是准入控制插件>什么是准入控制插件？</h2>
<p>准入控制器是一段代码，它会在请求通过认证和授权之后、对象被持久化之前拦截到达 API
服务器的请求。控制器由下面的<a href=#what-does-each-admission-controller-do>列表</a>组成，
并编译进 <code>kube-apiserver</code> 二进制文件，并且只能由集群管理员配置。
在该列表中，有两个特殊的控制器：MutatingAdmissionWebhook 和 ValidatingAdmissionWebhook。
它们根据 API 中的配置，分别执行变更和验证
<a href=/zh/docs/reference/access-authn-authz/extensible-admission-controllers/#admission-webhooks>准入控制 webhook</a>。</p>
<p>准入控制器可以执行 “验证（Validating）” 和/或 “变更（Mutating）” 操作。
变更（mutating）控制器可以根据被其接受的请求修改相关对象；验证（validating）控制器则不行。</p>
<p>准入控制器限制创建、删除、修改对象或连接到代理的请求，不限制读取对象的请求。</p>
<p>准入控制过程分为两个阶段。第一阶段，运行变更准入控制器。第二阶段，运行验证准入控制器。
再次提醒，某些控制器既是变更准入控制器又是验证准入控制器。</p>
<p>如果任何一个阶段的任何控制器拒绝了该请求，则整个请求将立即被拒绝，并向终端用户返回一个错误。</p>
<p>最后，除了对对象进行变更外，准入控制器还可以有其它作用：将相关资源作为请求处理的一部分进行变更。
增加使用配额就是一个典型的示例，说明了这样做的必要性。
此类用法都需要相应的回收或回调过程，因为任一准入控制器都无法确定某个请求能否通过所有其它准入控制器。</p>
<h2 id=为什么需要准入控制器>为什么需要准入控制器？</h2>
<p>Kubernetes 的许多高级功能都要求启用一个准入控制器，以便正确地支持该特性。
因此，没有正确配置准入控制器的 Kubernetes API 服务器是不完整的，它无法支持你期望的所有特性。</p>
<h2 id=如何启用一个准入控制器>如何启用一个准入控制器？</h2>
<p>Kubernetes API 服务器的 <code>enable-admission-plugins</code> 标志接受一个用于在集群修改对象之前
调用的（以逗号分隔的）准入控制插件顺序列表。</p>
<p>例如，下面的命令就启用了 <code>NamespaceLifecycle</code> 和 <code>LimitRanger</code> 准入控制插件：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kube-apiserver --enable-admission-plugins<span style=color:#666>=</span>NamespaceLifecycle,LimitRanger ...
</code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>Note:</strong>
<p>根据你 Kubernetes 集群的部署方式以及 API 服务器的启动方式的不同，你可能需要以不同的方式应用设置。
例如，如果将 API 服务器部署为 systemd 服务，你可能需要修改 systemd 单元文件；
如果以自托管方式部署 Kubernetes，你可能需要修改 API 服务器的清单文件。
</div>
<h2 id=怎么关闭准入控制器>怎么关闭准入控制器？</h2>
<p>Kubernetes API 服务器的 <code>disable-admission-plugins</code> 标志，会将传入的（以逗号分隔的）
准入控制插件列表禁用，即使是默认启用的插件也会被禁用。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kube-apiserver --disable-admission-plugins<span style=color:#666>=</span>PodNodeSelector,AlwaysDeny ...
</code></pre></div>
<h2 id=哪些插件是默认启用的>哪些插件是默认启用的？</h2>
<p>下面的命令可以查看哪些插件是默认启用的：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kube-apiserver -h | grep enable-admission-plugins
</code></pre></div>
<p>在目前版本中，它们是：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>CertificateApproval, CertificateSigning, CertificateSubjectRestriction, DefaultIngressClass, DefaultStorageClass, DefaultTolerationSeconds, LimitRanger, MutatingAdmissionWebhook, NamespaceLifecycle, PersistentVolumeClaimResize, Priority, ResourceQuota, RuntimeClass, ServiceAccount, StorageObjectInUseProtection, TaintNodesByCondition, ValidatingAdmissionWebhook
</code></pre></div>
<h2 id=每个准入控制器的作用是什么>每个准入控制器的作用是什么？</h2>
<h3 id=alwaysadmit>AlwaysAdmit</h3>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.13 [deprecated]</code>
</div>
<p>该准入控制器会允许所有的 pod 接入集群。已废弃，因为它的行为根本就和没有准入控制器一样。</p>
<h3 id=alwaysdeny>AlwaysDeny</h3>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.13 [deprecated]</code>
</div>
<p>拒绝所有的请求。由于它没有实际意义，已废弃。</p>
<h3 id=alwayspullimages>AlwaysPullImages</h3>
<p>该准入控制器会修改每一个新创建的 Pod 的镜像拉取策略为 Always 。
这在多租户集群中是有用的，这样用户就可以放心，他们的私有镜像只能被那些有凭证的人使用。
如果没有这个准入控制器，一旦镜像被拉取到节点上，任何用户的 Pod 都可以通过已了解到的镜像
的名称（假设 Pod 被调度到正确的节点上）来使用它，而不需要对镜像进行任何授权检查。
当启用这个准入控制器时，总是在启动容器之前拉取镜像，这意味着需要有效的凭证。</p>
<h3 id=certificateapproval>CertificateApproval</h3>
<p>此准入控制器获取“审批” CertificateSigningRequest 资源的请求并执行额外的授权检查，
以确保审批请求的用户有权限审批 <code>spec.signerName</code> 请求 CertificateSigningRequest 资源的证书请求。</p>
<p>有关对证书签名请求资源执行不同操作所需权限的详细信息，
请参阅<a href=/zh/docs/reference/access-authn-authz/certificate-signing-requests/>证书签名请求</a></p>
<h3 id=certificatesigning>CertificateSigning</h3>
<p>此准入控制器获取 CertificateSigningRequest 资源的 <code>status.certificate</code> 字段更新请求并执行额外的授权检查，
以确保签发证书的用户有权限为 <code>spec.signerName</code> 请求 CertificateSigningRequest 资源的证书请求<code>签发</code>证书。</p>
<p>有关对证书签名请求资源执行不同操作所需权限的详细信息，
请参阅<a href=/zh/docs/reference/access-authn-authz/certificate-signing-requests/>证书签名请求</a></p>
<h3 id=certificatesubjectrestrictions>CertificateSubjectRestrictions</h3>
<p>此准入控制器获取具有 <code>kubernetes.io/kube-apiserver-client</code> 的 <code>spec.signerName</code> 的
CertificateSigningRequest 资源创建请求，
它拒绝任何包含了 <code>system:masters</code> 一个“组”（或者“组织”）的请求。</p>
<h3 id=defaultingressclass>DefaultIngressClass</h3>
<p>该准入控制器监测没有请求任何特定 Ingress 类的 <code>Ingress</code> 对象的创建，并自动向其添加默认 Ingress 类。
这样，没有任何特殊 Ingress 类需求的用户根本不需要关心它们，它们将获得默认 Ingress 类。</p>
<p>当未配置默认 Ingress 类时，此准入控制器不执行任何操作。如果将多个 Ingress 类标记为默认 Ingress 类，
它将拒绝任何创建 <code>Ingress</code> 的操作，并显示错误。
要修复此错误，管理员必须重新检查其 <code>IngressClass</code> 对象，并仅将其中一个标记为默认（通过注解
"ingressclass.kubernetes.io/is-default-class"）。
此准入控制器会忽略所有 <code>Ingress</code> 更新操作，仅响应创建操作。</p>
<p>关于 Ingress 类以及如何将 Ingress 类标记为默认的更多信息，请参见
<a href=/zh/docs/concepts/services-networking/ingress/>ingress</a>。</p>
<h3 id=defaultstorageclass>DefaultStorageClass</h3>
<p>该准入控制器监测没有请求任何特定存储类的 <code>PersistentVolumeClaim</code> 对象的创建，
并自动向其添加默认存储类。
这样，没有任何特殊存储类需求的用户根本不需要关心它们，它们将获得默认存储类。</p>
<p>当未配置默认存储类时，此准入控制器不执行任何操作。如果将多个存储类标记为默认存储类，
它将拒绝任何创建 <code>PersistentVolumeClaim</code> 的操作，并显示错误。
要修复此错误，管理员必须重新访问其 <code>StorageClass</code> 对象，并仅将其中一个标记为默认。
此准入控制器会忽略所有 <code>PersistentVolumeClaim</code> 更新操作，仅响应创建操作。</p>
<p>关于持久化卷和存储类，以及如何将存储类标记为默认，请参见
<a href=/zh/docs/concepts/storage/persistent-volumes/>持久化卷</a>。</p>
<h3 id=defaulttolerationseconds>DefaultTolerationSeconds</h3>
<p>该准入控制器基于 k8s-apiserver 输入参数 <code>default-not-ready-toleration-seconds</code> 和
<code>default-unreachable-toleration-seconds</code> 为 Pod 设置默认的容忍度，以容忍 <code>notready:NoExecute</code> 和
<code>unreachable:NoExecute</code> 污点。
（如果 Pod 尚未容忍 <code>node.kubernetes.io/not-ready：NoExecute</code> 和
<code>node.kubernetes.io/unreachable：NoExecute</code> 污点的话）
<code>default-not-ready-toleration-seconds</code> 和 <code>default-unreachable-toleration-seconds</code> 的默认值是 5 分钟。</p>
<h3 id=denyescalatingexec>DenyEscalatingExec</h3>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.13 [deprecated]</code>
</div>
<p>该准入控制器将拒绝在由于拥有升级特权，而具备访问宿主机能力的 Pod 中执行 exec 和
attach 命令。这包括在特权模式运行的 Pod，可以访问主机 IPC 名字空间的 Pod，
和访问主机 PID 名字空间的 Pod 。</p>
<p>DenyExecOnPrivileged 准入插件已被废弃。</p>
<p>建议使用基于策略的准入插件（例如 <a href=#podsecuritypolicy>PodSecurityPolicy</a> 和自定义准入插件），
该插件可以针对特定用户或名字空间，还可以防止创建权限过高的 Pod。</p>
<h3 id=denyexeconprivileged>DenyExecOnPrivileged</h3>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.13 [deprecated]</code>
</div>
<p>如果一个 pod 拥有一个特权容器，该准入控制器将拦截所有在该 pod 中执行 exec 命令的请求。</p>
<p>此功能已合并至 <a href=#denyescalatingexec>DenyEscalatingExec</a>。
而 DenyExecOnPrivileged 准入插件已被废弃。</p>
<p>建议使用基于策略的准入插件（例如 <a href=#podsecuritypolicy>PodSecurityPolicy</a> 和自定义准入插件），
该插件可以针对特定用户或名字空间，还可以防止创建权限过高的 Pod。</p>
<h3 id=denyserviceexternalips>DenyServiceExternalIPs</h3>
<p>该准入控制器拒绝 <code>Service</code> 字段 <code>externalIPs</code> 的所有新规使用。 此功能非常强大（允许网络流量拦截），
并且无法很好地受策略控制。 启用后，群集用户将无法创建使用 <code>externalIPs</code> 的新服务，也无法在现有
<code>Service</code> 对象上向 <code>externalIPs</code> 添加新值。 <code>externalIPs</code> 的现有使用不受影响，用户可以从现有
<code>Service</code> 对象上的 <code>externalIPs</code> 中删除值。</p>
<p>大多数用户根本不需要此功能，集群管理员应考虑将其禁用。
确实需要使用此功能的集群应考虑使用一些自定义策略来管理其的使用。</p>
<h3 id=eventratelimit>EventRateLimit</h3>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.13 [alpha]</code>
</div>
<p>该准入控制器缓解了事件请求淹没 API 服务器的问题。集群管理员可以通过以下方式指定事件速率限制：</p>
<ul>
<li>启用 <code>EventRateLimit</code> 准入控制器；</li>
<li>从文件中引用 <code>EventRateLimit</code> 配置文件，并提供给 API 服务器命令的
<code>--admission-control-config-file</code> 标志：</li>
</ul>
<ul class="nav nav-tabs" id=eventratelimit-example role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#eventratelimit-example-0 role=tab aria-controls=eventratelimit-example-0 aria-selected=true>apiserver.config.k8s.io/v1</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#eventratelimit-example-1 role=tab aria-controls=eventratelimit-example-1>apiserver.k8s.io/v1alpha1</a></li></ul>
<div class=tab-content id=eventratelimit-example><div id=eventratelimit-example-0 class="tab-pane show active" role=tabpanel aria-labelledby=eventratelimit-example-0>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apiserver.config.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>AdmissionConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>plugins</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>EventRateLimit<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>eventconfig.yaml<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></code></pre></div></div>
<div id=eventratelimit-example-1 class=tab-pane role=tabpanel aria-labelledby=eventratelimit-example-1>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#080;font-style:italic># Deprecated in v1.17 in favor of apiserver.config.k8s.io/v1</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apiserver.k8s.io/v1alpha1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>AdmissionConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>plugins</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>EventRateLimit<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>eventconfig.yaml<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></code></pre></div></div></div>
<p>可以在配置中指定四种类型的限制：</p>
<ul>
<li><code>Server</code>: API 服务器收到的所有事件请求共享一个桶。</li>
<li><code>Namespace</code>: 每个名字空间都有一个专用的桶。</li>
<li><code>User</code>: 给每个用户都分配一个桶。</li>
<li><code>SourceAndObject</code>: 根据事件的源和涉及对象的每种组合分配桶。</li>
</ul>
<p>下面是一个配置示例 <code>eventconfig.yaml</code>：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>eventratelimit.admission.k8s.io/v1alpha1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Configuration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Namespace<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>qps</span>:<span style=color:#bbb> </span><span style=color:#666>50</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>burst</span>:<span style=color:#bbb> </span><span style=color:#666>100</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>cacheSize</span>:<span style=color:#bbb> </span><span style=color:#666>2000</span><span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>User<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>qps</span>:<span style=color:#bbb> </span><span style=color:#666>10</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>burst</span>:<span style=color:#bbb> </span><span style=color:#666>50</span><span style=color:#bbb>
</span></code></pre></div>
<p>详情请参见
<a href=https://git.k8s.io/community/contributors/design-proposals/api-machinery/admission_control_event_rate_limit.md>事件速率限制提案</a>。</p>
<h3 id=extendedresourcetoleration>ExtendedResourceToleration</h3>
<p>该插件有助于创建可扩展资源的专用节点。
如果运营商想创建可扩展资源的专用节点（如 GPU、FPGA 等），
那他们应该以扩展资源名称作为键名，
<a href=/zh/docs/concepts/scheduling-eviction/taint-and-toleration/>为节点设置污点</a>。
如果启用了该准入控制器，会将此类污点的容忍自动添加到请求扩展资源的 Pod 中，
用户不必再手动添加这些容忍。</p>
<h3 id=imagepolicywebhook>ImagePolicyWebhook</h3>
<p>ImagePolicyWebhook 准入控制器允许使用一个后端的 webhook 做出准入决策。</p>
<h4 id=配置文件格式>配置文件格式</h4>
<p>ImagePolicyWebhook 使用配置文件来为后端行为设置配置选项。该文件可以是 JSON 或 YAML，
并具有以下格式:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>imagePolicy</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>kubeConfigFile</span>:<span style=color:#bbb> </span>/path/to/kubeconfig/for/backend<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 以秒计的时长，控制批准请求的缓存时间</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>allowTTL</span>:<span style=color:#bbb> </span><span style=color:#666>50</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 以秒计的时长，控制拒绝请求的缓存时间</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>denyTTL</span>:<span style=color:#bbb> </span><span style=color:#666>50</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 以毫秒计的时长，控制重试间隔</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>retryBackoff</span>:<span style=color:#bbb> </span><span style=color:#666>500</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 确定 Webhook 后端失效时的行为</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>defaultAllow</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></code></pre></div>
<p>从文件中引用 ImagePolicyWebhook 的配置文件，并将其提供给 API 服务器命令标志
<code>--admission-control-config-file</code>：</p>
<ul class="nav nav-tabs" id=imagepolicywebhook-example1 role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#imagepolicywebhook-example1-0 role=tab aria-controls=imagepolicywebhook-example1-0 aria-selected=true>apiserver.config.k8s.io/v1</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#imagepolicywebhook-example1-1 role=tab aria-controls=imagepolicywebhook-example1-1>apiserver.k8s.io/v1alpha1</a></li></ul>
<div class=tab-content id=imagepolicywebhook-example1><div id=imagepolicywebhook-example1-0 class="tab-pane show active" role=tabpanel aria-labelledby=imagepolicywebhook-example1-0>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apiserver.config.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>AdmissionConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>plugins</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>ImagePolicyWebhook<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>imagepolicyconfig.yaml<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></code></pre></div></div>
<div id=imagepolicywebhook-example1-1 class=tab-pane role=tabpanel aria-labelledby=imagepolicywebhook-example1-1>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#080;font-style:italic># v1.17 中已废弃以鼓励使用 apiserver.config.k8s.io/v1</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apiserver.k8s.io/v1alpha1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>AdmissionConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>plugins</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>ImagePolicyWebhook<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>imagepolicyconfig.yaml<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></code></pre></div></div></div>
<p>或者，你也可以直接将配置嵌入到文件中：</p>
<ul class="nav nav-tabs" id=imagepolicywebhook-example2 role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#imagepolicywebhook-example2-0 role=tab aria-controls=imagepolicywebhook-example2-0 aria-selected=true>apiserver.config.k8s.io/v1</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#imagepolicywebhook-example2-1 role=tab aria-controls=imagepolicywebhook-example2-1>apiserver.k8s.io/v1alpha1</a></li></ul>
<div class=tab-content id=imagepolicywebhook-example2><div id=imagepolicywebhook-example2-0 class="tab-pane show active" role=tabpanel aria-labelledby=imagepolicywebhook-example2-0>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apiserver.config.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>AdmissionConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>plugins</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>ImagePolicyWebhook<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>configuration</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>imagePolicy</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>kubeConfigFile</span>:<span style=color:#bbb> </span>&lt;kubeconfig 文件路径&gt;<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>allowTTL</span>:<span style=color:#bbb> </span><span style=color:#666>50</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>denyTTL</span>:<span style=color:#bbb> </span><span style=color:#666>50</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>retryBackoff</span>:<span style=color:#bbb> </span><span style=color:#666>500</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>defaultAllow</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></code></pre></div></div>
<div id=imagepolicywebhook-example2-1 class=tab-pane role=tabpanel aria-labelledby=imagepolicywebhook-example2-1>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#080;font-style:italic># v1.17 中已废弃以鼓励使用 apiserver.config.k8s.io/v1</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apiserver.k8s.io/v1alpha1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>AdmissionConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>plugins</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>ImagePolicyWebhook<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>configuration</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>imagePolicy</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>kubeConfigFile</span>:<span style=color:#bbb> </span>&lt;kubeconfig 文件路径&gt;<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>allowTTL</span>:<span style=color:#bbb> </span><span style=color:#666>50</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>denyTTL</span>:<span style=color:#bbb> </span><span style=color:#666>50</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>retryBackoff</span>:<span style=color:#bbb> </span><span style=color:#666>500</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>defaultAllow</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></code></pre></div></div></div>
<p>ImagePolicyWebhook 的配置文件必须引用
<a href=/zh/docs/tasks/access-application-cluster/configure-access-multiple-clusters/>kubeconfig</a>
格式的文件；该文件设置了到后端的连接参数。
要求后端使用 TLS 进行通信。</p>
<p>kubeconfig 文件的 cluster 字段需要指向远端服务，user 字段需要包含已返回的授权者。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#080;font-style:italic># clusters 指的是远程服务。</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>clusters</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>name-of-remote-imagepolicy-service<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>cluster</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>certificate-authority</span>:<span style=color:#bbb> </span>/path/to/ca.pem   <span style=color:#bbb> </span><span style=color:#080;font-style:italic># CA 用于验证远程服务</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>server</span>:<span style=color:#bbb> </span>https://images.example.com/policy<span style=color:#bbb> </span><span style=color:#080;font-style:italic># 要查询的远程服务的 URL。必须是 &#39;https&#39; 。</span><span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># users 指的是 API 服务器的 Webhook 配置。</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>users</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>name-of-api-server<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>user</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>client-certificate</span>:<span style=color:#bbb> </span>/path/to/cert.pem<span style=color:#bbb> </span><span style=color:#080;font-style:italic># webhook 准入控制器使用的证书</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>client-key</span>:<span style=color:#bbb> </span>/path/to/key.pem         <span style=color:#bbb> </span><span style=color:#080;font-style:italic># 证书匹配的密钥</span><span style=color:#bbb>
</span></code></pre></div>
<p>关于 HTTP 配置的更多信息，请参阅
<a href=/zh/docs/tasks/access-application-cluster/configure-access-multiple-clusters/>kubeconfig</a>
文档。</p>
<h4 id=请求载荷>请求载荷</h4>
<p>当面对一个准入决策时，API 服务器发送一个描述操作的 JSON 序列化的
<code>imagepolicy.k8s.io/v1alpha1</code> <code>ImageReview</code> 对象。
该对象包含描述被审核容器的字段，以及所有匹配 <code>*.image-policy.k8s.io/*</code> 的
Pod 注解。</p>
<p>注意，Webhook API 对象与其他 Kubernetes API 对象一样受制于相同的版本控制兼容性规则。
实现者应该知道对 alpha 对象的更宽松的兼容性，并检查请求的 "apiVersion" 字段，
以确保正确的反序列化。
此外，API 服务器必须启用 <code>imagepolicy.k8s.io/v1alpha1</code> API 扩展组
（<code>--runtime-config=imagepolicy.k8s.io/v1alpha1=true</code>）。</p>
<p>请求载荷示例：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
  <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>:<span style=color:#b44>&#34;imagepolicy.k8s.io/v1alpha1&#34;</span>,
  <span style=color:green;font-weight:700>&#34;kind&#34;</span>:<span style=color:#b44>&#34;ImageReview&#34;</span>,
  <span style=color:green;font-weight:700>&#34;spec&#34;</span>:{
    <span style=color:green;font-weight:700>&#34;containers&#34;</span>:[
      {
        <span style=color:green;font-weight:700>&#34;image&#34;</span>:<span style=color:#b44>&#34;myrepo/myimage:v1&#34;</span>
      },
      {
        <span style=color:green;font-weight:700>&#34;image&#34;</span>:<span style=color:#b44>&#34;myrepo/myimage@sha256:beb6bd6a68f114c1dc2ea4b28db81bdf91de202a9014972bec5e4d9171d90ed&#34;</span>
      }
    ],
    <span style=color:green;font-weight:700>&#34;annotations&#34;</span>:{
      <span style=color:green;font-weight:700>&#34;mycluster.image-policy.k8s.io/ticket-1234&#34;</span>: <span style=color:#b44>&#34;break-glass&#34;</span>
    },
    <span style=color:green;font-weight:700>&#34;namespace&#34;</span>:<span style=color:#b44>&#34;mynamespace&#34;</span>
  }
}
</code></pre></div>
<p>远程服务将填充请求的 <code>ImageReviewStatus</code> 字段，并返回允许或不允许访问的响应。
响应体的 "spec" 字段会被忽略，并且可以省略。一个允许访问应答会返回：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
  <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;imagepolicy.k8s.io/v1alpha1&#34;</span>,
  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;ImageReview&#34;</span>,
  <span style=color:green;font-weight:700>&#34;status&#34;</span>: {
    <span style=color:green;font-weight:700>&#34;allowed&#34;</span>: <span style=color:#a2f;font-weight:700>true</span>
  }
}
</code></pre></div>
<p>若不允许访问，服务将返回：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
  <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;imagepolicy.k8s.io/v1alpha1&#34;</span>,
  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;ImageReview&#34;</span>,
  <span style=color:green;font-weight:700>&#34;status&#34;</span>: {
    <span style=color:green;font-weight:700>&#34;allowed&#34;</span>: <span style=color:#a2f;font-weight:700>false</span>,
    <span style=color:green;font-weight:700>&#34;reason&#34;</span>: <span style=color:#b44>&#34;image currently blacklisted&#34;</span>
  }
}
</code></pre></div>
<p>更多的文档，请参阅 <code>imagepolicy.v1alpha1</code> API 对象和
<code>plugin/pkg/admission/imagepolicy/admission.go</code>。</p>
<h4 id=使用注解进行扩展>使用注解进行扩展</h4>
<p>一个 Pod 中匹配 <code>*.image-policy.k8s.io/*</code> 的注解都会被发送给 Webhook。
这样做使得了解后端镜像策略的用户可以向它发送额外的信息，并为不同的后端实现
接收不同的信息。</p>
<p>你可以在这里输入的信息有：</p>
<ul>
<li>在紧急情况下，请求 "break glass" 覆盖一个策略。</li>
<li>从一个记录了 break-glass 的请求的 ticket 系统得到的一个 ticket 号码。</li>
<li>向策略服务器提供一个提示，用于提供镜像的 imageID，以方便它进行查找。</li>
</ul>
<p>在任何情况下，注解都是由用户提供的，并不会被 Kubernetes 以任何方式进行验证。
在将来，如果一个注解确定将被广泛使用，它可能会被提升为 ImageReviewSpec 的一个命名字段。</p>
<h3 id=limitpodhardantiaffinitytopology>LimitPodHardAntiAffinityTopology</h3>
<p>该准入控制器拒绝（定义了 <code>AntiAffinity</code> 拓扑键的）任何 Pod
（<code>requiredDuringSchedulingRequiredDuringExecution</code> 中的
<code>kubernetes.io/hostname</code> 除外）。</p>
<h3 id=limitranger>LimitRanger</h3>
<p>该准入控制器会观察传入的请求，并确保它不会违反 <code>Namespace</code> 中 <code>LimitRange</code>
对象枚举的任何约束。
如果你在 Kubernetes 部署中使用了 <code>LimitRange</code> 对象，则必须使用此准入控制器来
执行这些约束。
LimitRanger 还可以用于将默认资源请求应用到没有指定任何内容的 Pod；
当前，默认的 LimitRanger 对 <code>default</code> 名字空间中的所有 Pod 都应用了
0.1 CPU 的需求。</p>
<p>请查看
<a href=https://git.k8s.io/community/contributors/design-proposals/resource-management/admission_control_limit_range.md>limitRange 设计文档</a>
和 <a href=/zh/docs/tasks/administer-cluster/manage-resources/memory-default-namespace/>LimitRange 例子</a>
以了解更多细节。</p>
<h3 id=mutatingadmissionwebhook>MutatingAdmissionWebhook</h3>
<p>该准入控制器调用任何与请求匹配的变更 Webhook。匹配的 Webhook 将被串行调用。
每一个 Webhook 都可以根据需要修改对象。</p>
<p><code>MutatingAdmissionWebhook</code>，顾名思义，仅在变更阶段运行。</p>
<p>如果由此准入控制器调用的 Webhook 有副作用（如降低配额），
则它 <em>必须</em> 具有协调系统，因为不能保证后续的 Webhook 和验证准入控制器都会允许完成请求。</p>
<p>如果你禁用了 MutatingAdmissionWebhook，那么还必须使用 <code>--runtime-config</code> 标志禁止
<code>admissionregistration.k8s.io/v1</code> 组/版本中的 <code>MutatingWebhookConfiguration</code>
对象（版本 >=1.9 时，这两个对象都是默认启用的）。</p>
<h4 id=谨慎编写和安装变更-webhook>谨慎编写和安装变更 webhook</h4>
<ul>
<li>当用户尝试创建的对象与返回的对象不同时，用户可能会感到困惑。</li>
<li>当它们回读的对象与尝试创建的对象不同，内建的控制环可能会出问题。
<ul>
<li>与覆盖原始请求中设置的字段相比，使用原始请求未设置的字段会引起问题的可能性较小。
应尽量避免前面那种方式。</li>
</ul>
</li>
<li>内建资源和第三方资源的控制回路未来可能会受到破坏性的更改，使现在运行良好的 Webhook
无法再正常运行。即使完成了 Webhook API 安装，也不代表会为该 webhook 提供无限期的支持。</li>
</ul>
<h3 id=namespaceautoprovision>NamespaceAutoProvision</h3>
<p>该准入控制器会检查名字空间资源上的所有传入请求，并检查所引用的名字空间是否确实存在。
如果找不到，它将创建一个名字空间。
此准入控制器对于不想要求名字空间必须先创建后使用的集群部署中很有用。</p>
<h3 id=namespaceexists>NamespaceExists</h3>
<p>该准入控制器检查除 <code>Namespace</code> 以外的名字空间作用域资源上的所有请求。
如果请求引用的名字空间不存在，则拒绝该请求。</p>
<h3 id=namespacelifecycle>NamespaceLifecycle</h3>
<p>该准入控制器禁止在一个正在被终止的 <code>Namespace</code> 中创建新对象，并确保
使用不存在的 <code>Namespace</code> 的请求被拒绝。
该准入控制器还会禁止删除三个系统保留的名字空间，即 <code>default</code>、
<code>kube-system</code> 和 <code>kube-public</code>。</p>
<p>删除 <code>Namespace</code> 会触发删除该名字空间中所有对象（Pod、Service 等）的一系列操作。
为了确保这个过程的完整性，我们强烈建议启用这个准入控制器。</p>
<h3 id=noderestriction>NodeRestriction</h3>
<p>该准入控制器限制了 kubelet 可以修改的 <code>Node</code> 和 <code>Pod</code> 对象。
为了受到这个准入控制器的限制，kubelet 必须使用在 <code>system:nodes</code> 组中的凭证，
并使用 <code>system:node:&lt;nodeName></code> 形式的用户名。
这样，kubelet 只可修改自己的 <code>Node</code> API 对象，只能修改绑定到节点本身的 Pod 对象。</p>
<p>在 Kubernetes 1.11+ 的版本中，不允许 kubelet 从 <code>Node</code> API 对象中更新或删除污点。</p>
<p>在 Kubernetes 1.13+ 的版本中，<code>NodeRestriction</code> 准入插件可防止 kubelet 删除
<code>Node</code> API 对象，并对 <code>kubernetes.io/</code> 或 <code>k8s.io/</code> 前缀标签的 kubelet
强制进行如下修改：</p>
<ul>
<li><strong>防止</strong> kubelet 添加/删除/更新带有 <code>node-restriction.kubernetes.io/</code> 前缀的标签。
保留此前缀的标签，供管理员用来标记 Node 对象以隔离工作负载，并且不允许 kubelet
修改带有该前缀的标签。</li>
<li><strong>允许</strong> kubelet 添加/删除/更新这些和这些前缀的标签：
<ul>
<li><code>kubernetes.io/hostname</code></li>
<li><code>kubernetes.io/arch</code></li>
<li><code>kubernetes.io/os</code></li>
<li><code>beta.kubernetes.io/instance-type</code></li>
<li><code>node.kubernetes.io/instance-type</code></li>
<li><code>failure-domain.beta.kubernetes.io/region</code> （已弃用）</li>
<li><code>failure-domain.beta.kubernetes.io/zone</code> (已弃用）</li>
<li><code>topology.kubernetes.io/region</code></li>
<li><code>topology.kubernetes.io/zone</code></li>
<li><code>kubelet.kubernetes.io/</code>-prefixed labels</li>
<li><code>node.kubernetes.io/</code>-prefixed labels</li>
</ul>
</li>
</ul>
<p>kubelet 保留 <code>kubernetes.io</code> 或 <code>k8s.io</code> 前缀的所有标签，并且将来可能会被
<code>NodeRestriction</code> 准入插件允许或禁止。</p>
<p>将来的版本可能会增加其他限制，以确保 kubelet 具有正常运行所需的最小权限集。</p>
<h3 id=ownerreferencespermissionenforcement>OwnerReferencesPermissionEnforcement</h3>
<p>该准入控制器保护对 <code>metadata.ownerReferences</code> 对象的访问，以便只有对该对象具有
“删除” 权限的用户才能对其进行更改。
该准入控制器还保护对 <code>metadata.ownerReferences[x].blockOwnerDeletion</code> 对象的访问，
以便只有对所引用的 <strong>属主（owner）</strong> 的 <code>finalizers</code> 子资源具有 “更新”
权限的用户才能对其进行更改。</p>
<h3 id=persistentvolumeclaimresize>PersistentVolumeClaimResize</h3>
<p>该准入控制器检查传入的 <code>PersistentVolumeClaim</code> 调整大小请求，对其执行额外的验证操作。</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong>
<p>对调整卷大小的支持是一种 Beta 特性。作为集群管理员，你必须确保特性门控 <code>ExpandPersistentVolumes</code>
设置为 <code>true</code> 才能启用调整大小。
</div>
<p>启用 <code>ExpandPersistentVolumes</code> 特性门控之后，建议将 <code>PersistentVolumeClaimResize</code>
准入控制器也启用。除非 PVC 的 <code>StorageClass</code> 明确地将 <code>allowVolumeExpansion</code> 设置为
<code>true</code> 来显式启用调整大小。否则，默认情况下该准入控制器会阻止所有对 PVC 大小的调整。</p>
<p>例如：由以下 <code>StorageClass</code> 创建的所有 <code>PersistentVolumeClaim</code> 都支持卷容量扩充：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>storage.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StorageClass<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>gluster-vol-default<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>provisioner</span>:<span style=color:#bbb> </span>kubernetes.io/glusterfs<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>parameters</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resturl</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;http://192.168.10.100:8080&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restuser</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>secretNamespace</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>secretName</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>allowVolumeExpansion</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></code></pre></div>
<p>关于持久化卷申领的更多信息，请参见
<a href=/zh/docs/concepts/storage/persistent-volumes/#persistentvolumeclaims>PersistentVolumeClaims</a>。</p>
<h3 id=persistentvolumelabel>PersistentVolumeLabel</h3>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.13 [deprecated]</code>
</div>
<p>该准入控制器会自动将区（region）或区域（zone）标签附加到由云提供商（如 GCE、AWS）
定义的 PersistentVolume。这有助于确保 Pod 和 PersistentVolume 位于相同的区或区域。
如果准入控制器不支持为 PersistentVolumes 自动添加标签，那你可能需要手动添加标签，
以防止 Pod 挂载其他区域的卷。
PersistentVolumeLabel 已被废弃，标记持久卷已由
<a href=/zh/docs/tasks/administer-cluster/running-cloud-controller/>云管理控制器</a>接管。
从 1.11 开始，默认情况下禁用此准入控制器。</p>
<h3 id=podnodeselector>PodNodeSelector</h3>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.5 [alpha]</code>
</div>
<p>该准入控制器通过读取名字空间注解和全局配置，来为名字空间中可以使用的节点选择器
设置默认值并实施限制。</p>
<h4 id=配置文件格式-1>配置文件格式</h4>
<p><code>PodNodeSelector</code> 使用配置文件来设置后端行为的选项。
请注意，配置文件格式将在将来某个版本中改为版本化文件。
该文件可以是 JSON 或 YAML，格式如下：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>podNodeSelectorPluginConfig</span>:<span style=color:#bbb>
</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>clusterDefaultNodeSelector</span>:<span style=color:#bbb> </span>name-of-node-selector<span style=color:#bbb>
</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>namespace1</span>:<span style=color:#bbb> </span>name-of-node-selector<span style=color:#bbb>
</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>namespace2</span>:<span style=color:#bbb> </span>name-of-node-selector<span style=color:#bbb>
</span></code></pre></div>
<p>基于提供给 API 服务器命令行标志 <code>--admission-control-config-file</code> 的文件名，
从文件中引用 <code>PodNodeSelector</code> 配置文件：</p>
<ul class="nav nav-tabs" id=podnodeselector-example1 role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#podnodeselector-example1-0 role=tab aria-controls=podnodeselector-example1-0 aria-selected=true>apiserver.config.k8s.io/v1</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#podnodeselector-example1-1 role=tab aria-controls=podnodeselector-example1-1>apiserver.k8s.io/v1alpha1</a></li></ul>
<div class=tab-content id=podnodeselector-example1><div id=podnodeselector-example1-0 class="tab-pane show active" role=tabpanel aria-labelledby=podnodeselector-example1-0>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apiserver.config.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>AdmissionConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>plugins</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>PodNodeSelector<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>podnodeselector.yaml<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></code></pre></div></div>
<div id=podnodeselector-example1-1 class=tab-pane role=tabpanel aria-labelledby=podnodeselector-example1-1>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#080;font-style:italic># 在 v1.17 中废弃，以鼓励使用 apiserver.config.k8s.io/v1</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apiserver.k8s.io/v1alpha1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>AdmissionConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>plugins</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>PodNodeSelector<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>podnodeselector.yaml<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></code></pre></div></div></div>
<h4 id=配置注解格式>配置注解格式</h4>
<p><code>PodNodeSelector</code> 使用键为 <code>scheduler.alpha.kubernetes.io/node-selector</code> 的注解
为名字空间设置节点选择算符。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Namespace<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>scheduler.alpha.kubernetes.io/node-selector</span>:<span style=color:#bbb> </span>name-of-node-selector<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>namespace3<span style=color:#bbb>
</span></code></pre></div>
<h4 id=内部行为>内部行为</h4>
<p>该准入控制器行为如下：</p>
<ol>
<li>如果 <code>Namespace</code> 的注解带有键 <code>scheduler.alpha.kubernetes.io/node-selector</code>，
则将其值用作节点选择算符。</li>
<li>如果名字空间缺少此类注解，则使用 <code>PodNodeSelector</code> 插件配置文件中定义的
<code>clusterDefaultNodeSelector</code> 作为节点选择算符。</li>
<li>评估 Pod 节点选择算符和名字空间节点选择算符是否存在冲突。存在冲突将导致拒绝。</li>
<li>评估 Pod 节点选择算符和特定于名字空间的被允许的选择算符所定义的插件配置文件是否存在冲突。
存在冲突将导致拒绝。</li>
</ol>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong>
<p>PodNodeSelector 允许 Pod 强制在特定标签的节点上运行。
另请参阅 PodTolerationRestriction 准入插件，该插件可防止 Pod 在特定污点的节点上运行。
</div>
<h3 id=podsecurity>PodSecurity</h3>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.23 [beta]</code>
</div>
<p>这是下节已被废弃的 <a href=#podsecuritypolicy>PodSecurityPolicy</a> 准入控制器的替代品。
此准入控制器负责在创建和修改 Pod 时根据请求的安全上下文和
<a href=/zh/docs/concepts/security/pod-security-standards/>Pod 安全标准</a>
来确定是否可以执行请求。</p>
<p>更多信息请参阅 <a href=/zh/docs/concepts/security/pod-security-admission/>Pod 安全性准入控制器</a>。</p>
<h3 id=podsecuritypolicy>PodSecurityPolicy</h3>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.21 [deprecated]</code>
</div>
<p>此准入控制器负责在创建和修改 Pod 时根据请求的安全上下文和可用的 Pod
安全策略确定是否可以执行请求。</p>
<p>查看 <a href=/zh/docs/concepts/security/pod-security-policy/>Pod 安全策略文档</a>
了解更多细节。</p>
<h3 id=podtolerationrestriction>PodTolerationRestriction</h3>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.7 [alpha]</code>
</div>
<p>准入控制器 PodTolerationRestriction 检查 Pod 的容忍度与其名字空间的容忍度之间
是否存在冲突。如果存在冲突，则拒绝 Pod 请求。
然后，它将名字空间的容忍度合并到 Pod 的容忍度中，之后根据名字空间的容忍度
白名单检查所得到的容忍度结果。如果检查成功，则将接受 Pod 请求，否则拒绝该请求。</p>
<p>如果 Pod 的名字空间没有任何关联的默认容忍度或容忍度白名单，则使用集群级别的
默认容忍度或容忍度白名单（如果有的话）。</p>
<p>名字空间的容忍度通过注解健 <code>scheduler.alpha.kubernetes.io/defaultTolerations</code>
来设置。可接受的容忍度可以通过 <code>scheduler.alpha.kubernetes.io/tolerationsWhitelist</code>
注解键来添加。</p>
<p>名字空间注解的示例：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Namespace<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>apps-that-need-nodes-exclusively<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>scheduler.alpha.kubernetes.io/defaultTolerations</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;[{&#34;operator&#34;: &#34;Exists&#34;, &#34;effect&#34;: &#34;NoSchedule&#34;, &#34;key&#34;: &#34;dedicated-node&#34;}]&#39;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>scheduler.alpha.kubernetes.io/tolerationsWhitelist</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;[{&#34;operator&#34;: &#34;Exists&#34;, &#34;effect&#34;: &#34;NoSchedule&#34;, &#34;key&#34;: &#34;dedicated-node&#34;}]&#39;</span><span style=color:#bbb>
</span></code></pre></div>
<h3 id=priority>优先级</h3>
<p>优先级准入控制器使用 <code>priorityClassName</code> 字段并用整型值填充优先级。
如果找不到优先级，则拒绝 Pod。</p>
<h3 id=resourcequota>ResourceQuota</h3>
<p>该准入控制器会监测传入的请求，并确保它不违反任何一个 <code>Namespace</code> 中的 <code>ResourceQuota</code>
对象中枚举出来的约束。
如果你在 Kubernetes 部署中使用了 <code>ResourceQuota</code>，你必须使用这个准入控制器来强制
执行配额限制。</p>
<p>请查看
<a href=https://git.k8s.io/community/contributors/design-proposals/admission_control_resource_quota.md>resourceQuota 设计文档</a>和 <a href=/zh/docs/concepts/policy/resource-quotas/>Resource Quota 例子</a>
了解更多细节。</p>
<h3 id=runtimeclass>RuntimeClass</h3>
<p>+
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.20 [stable]</code>
</div>
</p>
<p>如果你开启 <code>PodOverhead</code>
<a href=/zh/docs/reference/command-line-tools-reference/feature-gates/>特性门控</a>,
并且通过 <a href=/zh/docs/concepts/scheduling-eviction/pod-overhead/>Pod 开销</a>
配置来定义一个 RuntimeClass，这个准入控制器会检查新的 Pod。
当启用的时候，这个准入控制器会拒绝任何 overhead 字段已经设置的 Pod。
对于配置了 RuntimeClass 并在其 <code>.spec</code> 中选定 RuntimeClass 的 Pod，
此准入控制器会根据相应 RuntimeClass 中定义的值为 Pod 设置 <code>.spec.overhead</code>。</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> Pod 的 <code>.spec.overhead</code> 字段和 RuntimeClass 的 <code>.overhead</code> 字段均为处于 beta 版本。
如果你未启用 <code>PodOverhead</code> 特性门控，则所有 Pod 均被视为未设置 <code>.spec.overhead</code>。
</div>
<p>详情请参见 <a href=/zh/docs/concepts/scheduling-eviction/pod-overhead/>Pod 开销</a>。</p>
<h3 id=securitycontextdeny>SecurityContextDeny</h3>
<p>该准入控制器将拒绝任何试图设置特定提升
<a href=/zh/docs/tasks/configure-pod-container/security-context/>SecurityContext</a>
字段的 Pod，正如任务
<a href=/zh/docs/tasks/configure-pod-container/security-context/>为 Pod 或 Container 配置安全上下文</a>
中所展示的那样。
如果集群没有使用 <a href=/zh/docs/concepts/security/pod-security-admission/>Pod 安全性准入</a>、
<a href=/zh/docs/concepts/security/pod-security-policy/>PodSecurityPolicies</a>，
也没有任何外部执行机制，那么你可以使用此准入控制器来限制安全上下文所能获取的值集。</p>
<p>有关限制 Pod 权限的更多内容，请参阅
<a href=/zh/docs/concepts/security/pod-security-standards/>Pod 安全标准</a>。</p>
<h3 id=serviceaccount>ServiceAccount</h3>
<p>此准入控制器实现了
<a href=/zh/docs/tasks/configure-pod-container/configure-service-account/>ServiceAccount</a>
的自动化。
如果你打算使用 Kubernetes 的 ServiceAccount 对象，我们强烈建议你使用这个准入控制器。</p>
<h3 id=storageobjectinuseprotection>StorageObjectInUseProtection</h3>
<p><code>StorageObjectInUseProtection</code> 插件将 <code>kubernetes.io/pvc-protection</code> 或
<code>kubernetes.io/pv-protection</code> finalizers 添加到新创建的持久化卷声明（PVC）
或持久化卷（PV）中。
如果用户尝试删除 PVC/PV，除非 PVC/PV 的保护控制器移除 finalizers，否则
PVC/PV 不会被删除。
有关更多详细信息，请参考
<a href=/zh/docs/concepts/storage/persistent-volumes/#storage-object-in-use-protection>保护使用中的存储对象</a>。</p>
<h3 id=taintnodesbycondition>TaintNodesByCondition</h3>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.17 [stable]</code>
</div>
<p>该准入控制器为新创建的节点添加 <code>NotReady</code> 和 <code>NoSchedule</code>
<a class=glossary-tooltip title="污点是一种一个核心对象，包含三个必需的属性：key、value 和 effect。 污点会阻止在节点或节点组上调度 Pod。" data-toggle=tooltip data-placement=top href=/zh/docs/concepts/scheduling-eviction/taint-and-toleration/ target=_blank aria-label=污点>污点</a>。
这些污点能够避免一些竞态条件的发生，这类静态条件可能导致 Pod 在更新节点污点以准确
反映其所报告状况之前，就被调度到新节点上。</p>
<h3 id=validatingadmissionwebhook>ValidatingAdmissionWebhook</h3>
<p>该准入控制器调用与请求匹配的所有验证 Webhook。
匹配的 Webhook 将被并行调用。如果其中任何一个拒绝请求，则整个请求将失败。
该准入控制器仅在验证（Validating）阶段运行；与 <code>MutatingAdmissionWebhook</code> 准入控制器
所调用的 Webhook 相反，它调用的 Webhook 应该不会使对象出现变更。</p>
<p>如果以此方式调用的 Webhook 有其它作用（如，降低配额），则它必须具有协调机制。
这是因为无法保证后续的 Webhook 或其他有效的准入控制器都允许请求完成。</p>
<p>如果你禁用了 ValidatingAdmissionWebhook，还必须通过 <code>--runtime-config</code> 标志来禁用
<code>admissionregistration.k8s.io/v1</code> 组/版本中的 <code>ValidatingWebhookConfiguration</code>
对象（默认情况下在 1.9 版和更高版本中均处于启用状态）。</p>
<h2 id=有推荐的准入控制器吗>有推荐的准入控制器吗？</h2>
<p>有。推荐使用的准入控制器默认情况下都处于启用状态
（请查看<a href=/zh/docs/reference/command-line-tools-reference/kube-apiserver/#options>这里</a>）。
因此，你无需显式指定它们。
你可以使用 <code>--enable-admission-plugins</code> 标志（ <strong>顺序不重要</strong> ）来启用默认设置以外的其他准入控制器。</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong>
<p><code>--admission-control</code> 在 1.10 中已废弃，由 <code>--enable-admission-plugins</code> 取代。
</div>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-d04751f776f1faa6a82bbb7f0a200950>3.5 - 动态准入控制</h1>
<p>除了<a href=/zh/docs/reference/access-authn-authz/admission-controllers/>内置的 admission 插件</a>，
准入插件可以作为扩展独立开发，并以运行时所配置的 Webhook 的形式运行。
此页面描述了如何构建、配置、使用和监视准入 Webhook。</p>
<h2 id=什么是准入-webhook>什么是准入 Webhook？</h2>
<p>准入 Webhook 是一种用于接收准入请求并对其进行处理的 HTTP 回调机制。
可以定义两种类型的准入 webhook，即
<a href=/zh/docs/reference/access-authn-authz/admission-controllers/#validatingadmissionwebhook>验证性质的准入 Webhook</a> 和
<a href=/zh/docs/reference/access-authn-authz/admission-controllers/#mutatingadmissionwebhook>修改性质的准入 Webhook</a>。
修改性质的准入 Webhook 会先被调用。它们可以更改发送到 API
服务器的对象以执行自定义的设置默认值操作。</p>
<p>在完成了所有对象修改并且 API 服务器也验证了所传入的对象之后，
验证性质的 Webhook 会被调用，并通过拒绝请求的方式来强制实施自定义的策略。</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 如果准入 Webhook 需要保证它们所看到的是对象的最终状态以实施某种策略。
则应使用验证性质的准入 Webhook，因为对象被修改性质 Webhook 看到之后仍然可能被修改。
</div>
<h3 id=尝试准入-webhook>尝试准入 Webhook</h3>
<p>准入 Webhook 本质上是集群控制平面的一部分。你应该非常谨慎地编写和部署它们。
如果你打算编写或者部署生产级准入 webhook，请阅读<a href=/zh/docs/reference/access-authn-authz/extensible-admission-controllers/#write-an-admission-webhook-server>用户指南</a>以获取相关说明。
在下文中，我们将介绍如何快速试验准入 Webhook。</p>
<h3 id=prerequisites>先决条件</h3>
<ul>
<li>
<p>确保 Kubernetes 集群版本至少为 v1.16（以便使用 <code>admissionregistration.k8s.io/v1</code> API） 或者 v1.9 （以便使用 <code>admissionregistration.k8s.io/v1beta1</code> API）。</p>
</li>
<li>
<p>确保启用 MutatingAdmissionWebhook 和 ValidatingAdmissionWebhook 控制器。
<a href=/zh/docs/reference/access-authn-authz/admission-controllers/#is-there-a-recommended-set-of-admission-controllers-to-use>这里</a>
是一组推荐的 admission 控制器，通常可以启用。</p>
</li>
<li>
<p>确保启用了 <code>admissionregistration.k8s.io/v1beta1</code> API。</p>
</li>
</ul>
<h3 id=编写一个准入-webhook-服务器>编写一个准入 Webhook 服务器</h3>
<p>请参阅 Kubernetes e2e 测试中的
<a href=https://github.com/kubernetes/kubernetes/blob/release-1.21/test/images/agnhost/webhook/main.go>admission webhook 服务器</a>
的实现。webhook 处理由 apiserver 发送的 <code>AdmissionReview</code> 请求，并且将其决定
作为 <code>AdmissionReview</code> 对象以相同版本发送回去。</p>
<p>有关发送到 webhook 的数据的详细信息，请参阅 <a href=#request>webhook 请求</a>。</p>
<p>要获取来自 webhook 的预期数据，请参阅 <a href=#response>webhook 响应</a>。</p>
<p>示例准入 Webhook 服务器置 <code>ClientAuth</code> 字段为
<a href=https://github.com/kubernetes/kubernetes/blob/v1.22.0/test/images/agnhost/webhook/config.go#L38-L39>空</a>，
默认为 <code>NoClientCert</code> 。这意味着 webhook 服务器不会验证客户端的身份，认为其是 apiservers。
如果你需要双向 TLS 或其他方式来验证客户端，请参阅
如何<a href=#authenticate-apiservers>对 apiservers 进行身份认证</a>。</p>
<h3 id=部署准入-webhook-服务>部署准入 Webhook 服务</h3>
<p>e2e 测试中的 webhook 服务器通过
<a href=/docs/reference/generated/kubernetes-api/v1.23/#deployment-v1-apps>deployment API</a>
部署在 Kubernetes 集群中。该测试还将创建一个
<a href=/docs/reference/generated/kubernetes-api/v1.23/#service-v1-core>service</a>
作为 webhook 服务器的前端。参见
<a href=https://github.com/kubernetes/kubernetes/blob/v1.22.0/test/e2e/apimachinery/webhook.go#L748>相关代码</a>。</p>
<p>你也可以在集群外部署 webhook。这样做需要相应地更新你的 webhook 配置。</p>
<h3 id=即时配置准入-webhook>即时配置准入 Webhook</h3>
<p>你可以通过
<a href=/docs/reference/generated/kubernetes-api/v1.23/#validatingwebhookconfiguration-v1-admissionregistration-k8s-io>ValidatingWebhookConfiguration</a>
或者
<a href=/docs/reference/generated/kubernetes-api/v1.23/#mutatingwebhookconfiguration-v1-admissionregistration-k8s-io>MutatingWebhookConfiguration</a> 动态配置哪些资源要被哪些准入 Webhook 处理。</p>
<p>以下是一个 <code>ValidatingWebhookConfiguration</code> 示例，mutating webhook 配置与此类似。有关每个配置字段的详细信息，请参阅 <a href=#webhook-configuration>webhook 配置</a> 部分。</p>
<ul class="nav nav-tabs" id=validatingwebhookconfiguration-example-1 role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#validatingwebhookconfiguration-example-1-0 role=tab aria-controls=validatingwebhookconfiguration-example-1-0 aria-selected=true>admissionregistration.k8s.io/v1</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#validatingwebhookconfiguration-example-1-1 role=tab aria-controls=validatingwebhookconfiguration-example-1-1>admissionregistration.k8s.io/v1beta1</a></li></ul>
<div class=tab-content id=validatingwebhookconfiguration-example-1><div id=validatingwebhookconfiguration-example-1-0 class="tab-pane show active" role=tabpanel aria-labelledby=validatingwebhookconfiguration-example-1-0>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>admissionregistration.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ValidatingWebhookConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;pod-policy.example.com&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>webhooks</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;pod-policy.example.com&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>   </span>[<span style=color:#b44>&#34;&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiVersions</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;v1&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>operations</span>:<span style=color:#bbb>  </span>[<span style=color:#b44>&#34;CREATE&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>   </span>[<span style=color:#b44>&#34;pods&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>scope</span>:<span style=color:#bbb>       </span><span style=color:#b44>&#34;Namespaced&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>clientConfig</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>service</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;example-namespace&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;example-service&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>caBundle</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;Ci0tLS0tQk...&lt;base64-encoded PEM bundle containing the CA that signed the webhook&#39;s serving certificate&gt;...tLS0K&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>admissionReviewVersions</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;v1&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;v1beta1&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>sideEffects</span>:<span style=color:#bbb> </span>None<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>timeoutSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>5</span><span style=color:#bbb>
</span></code></pre></div></div>
<div id=validatingwebhookconfiguration-example-1-1 class=tab-pane role=tabpanel aria-labelledby=validatingwebhookconfiguration-example-1-1>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#080;font-style:italic># 1.16 中被淘汰，推荐使用 admissionregistration.k8s.io/v1</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>admissionregistration.k8s.io/v1beta1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ValidatingWebhookConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;pod-policy.example.com&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>webhooks</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;pod-policy.example.com&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>   </span>[<span style=color:#b44>&#34;&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiVersions</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;v1&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>operations</span>:<span style=color:#bbb>  </span>[<span style=color:#b44>&#34;CREATE&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>   </span>[<span style=color:#b44>&#34;pods&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>scope</span>:<span style=color:#bbb>       </span><span style=color:#b44>&#34;Namespaced&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>clientConfig</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>service</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;example-namespace&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;example-service&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>caBundle</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;Ci0tLS0tQk...&lt;base64-encoded PEM bundle containing the CA that signed the webhook&#39;s serving certificate&gt;...tLS0K&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>admissionReviewVersions</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;v1beta1&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>timeoutSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>5</span><span style=color:#bbb>
</span></code></pre></div></div></div>
<p>scope 字段指定是仅集群范围的资源（Cluster）还是名字空间范围的资源资源（Namespaced）将与此规则匹配。<code>*</code> 表示没有范围限制。</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 当使用 <code>clientConfig.service</code> 时，服务器证书必须对 <code>&lt;svc_name>.&lt;svc_namespace>.svc</code> 有效。
</div>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 对于使用 <code>admissionregistration.k8s.io/v1</code> 创建的 webhook 而言，其 webhook 调用的默认超时是 10 秒；
对于使用 <code>admissionregistration.k8s.io/v1beta1</code> 创建的 webhook 而言，其默认超时是 30 秒。
从 kubernetes 1.14 开始，可以设置超时。建议对 webhooks 设置较短的超时时间。
如果 webhook 调用超时，则根据 webhook 的失败策略处理请求。
</div>
<p>当 apiserver 收到与 <code>rules</code> 相匹配的请求时，apiserver 按照 <code>clientConfig</code> 中指定的方式向 webhook 发送一个 <code>admissionReview</code> 请求。</p>
<p>创建 webhook 配置后，系统将花费几秒钟使新配置生效。</p>
<h3 id=authenticate-apiservers>对 apiservers 进行身份认证</h3>
<p>如果你的 webhook 需要身份验证，则可以将 apiserver 配置为使用基本身份验证、持有者令牌或证书来向 webhook 提供身份证明。完成此配置需要三个步骤。</p>
<ul>
<li>
<p>启动 apiserver 时，通过 <code>--admission-control-config-file</code> 参数指定准入控制配置文件的位置。</p>
</li>
<li>
<p>在准入控制配置文件中，指定 MutatingAdmissionWebhook 控制器和 ValidatingAdmissionWebhook 控制器应该读取凭据的位置。
凭证存储在 kubeConfig 文件中（是​​的，与 kubectl 使用的模式相同），因此字段名称为 <code>kubeConfigFile</code>。
以下是一个准入控制配置文件示例：</p>
</li>
</ul>
<ul class="nav nav-tabs" id=admissionconfiguration-example1 role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#admissionconfiguration-example1-0 role=tab aria-controls=admissionconfiguration-example1-0 aria-selected=true>apiserver.config.k8s.io/v1</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#admissionconfiguration-example1-1 role=tab aria-controls=admissionconfiguration-example1-1>apiserver.k8s.io/v1alpha1</a></li></ul>
<div class=tab-content id=admissionconfiguration-example1><div id=admissionconfiguration-example1-0 class="tab-pane show active" role=tabpanel aria-labelledby=admissionconfiguration-example1-0>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apiserver.config.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>AdmissionConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>plugins</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>ValidatingAdmissionWebhook<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>configuration</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apiserver.config.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>WebhookAdmissionConfiguration<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubeConfigFile</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&lt;path-to-kubeconfig-file&gt;&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>MutatingAdmissionWebhook<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>configuration</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apiserver.config.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>WebhookAdmissionConfiguration<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubeConfigFile</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&lt;path-to-kubeconfig-file&gt;&#34;</span><span style=color:#bbb>
</span></code></pre></div></div>
<div id=admissionconfiguration-example1-1 class=tab-pane role=tabpanel aria-labelledby=admissionconfiguration-example1-1>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#080;font-style:italic># 1.17 中被淘汰，推荐使用 apiserver.config.k8s.io/v1</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apiserver.k8s.io/v1alpha1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>AdmissionConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>plugins</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>ValidatingAdmissionWebhook<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>configuration</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 1.17 中被淘汰，推荐使用 apiserver.config.k8s.io/v1，kind = WebhookAdmissionConfiguration</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apiserver.config.k8s.io/v1alpha1<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>WebhookAdmission<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubeConfigFile</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&lt;path-to-kubeconfig-file&gt;&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>MutatingAdmissionWebhook<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>configuration</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 1.17 中被淘汰，推荐使用 apiserver.config.k8s.io/v1，kind = WebhookAdmissionConfiguration</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apiserver.config.k8s.io/v1alpha1<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>WebhookAdmission<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubeConfigFile</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&lt;path-to-kubeconfig-file&gt;&#34;</span><span style=color:#bbb>
</span></code></pre></div></div></div>
<p>有关 <code>AdmissionConfiguration</code> 的更多信息，请参见
<a href=/docs/reference/config-api/apiserver-webhookadmission.v1/>AdmissionConfiguration (v1) reference</a>。
有关每个配置字段的详细信息，请参见 <a href=#webhook-%E9%85%8D%E7%BD%AE>webhook 配置</a>部分。</p>
<ul>
<li>
<p>在 kubeConfig 文件中，提供证书凭据：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Config<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>users</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># 名称应设置为服务的 DNS 名称或配置了 Webhook 的 URL 的主机名（包括端口）。</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># 如果将非 443 端口用于服务，则在配置 1.16+ API 服务器时，该端口必须包含在名称中。</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic>#</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># 对于配置在默认端口（443）上与服务对话的 Webhook，请指定服务的 DNS 名称：</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># - name: webhook1.ns1.svc</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic>#   user: ...</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic>#</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># 对于配置在非默认端口（例如 8443）上与服务对话的 Webhook，请在 1.16+ 中指定服务的 DNS 名称和端口：</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># - name: webhook1.ns1.svc:8443</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic>#   user: ...</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># 并可以选择仅使用服务的 DNS 名称来创建第二节，以与 1.15 API 服务器版本兼容：</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># - name: webhook1.ns1.svc</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic>#   user: ...</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic>#</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># 对于配置为使用 URL 的 webhook，请匹配在 webhook 的 URL 中指定的主机（和端口）。</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># 带有 `url: https://www.example.com` 的 webhook：</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># - name: www.example.com</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic>#   user: ...</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic>#</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># 带有 `url: https://www.example.com:443` 的 webhook：</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># - name: www.example.com:443</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic>#   user: ...</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic>#</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># 带有 `url: https://www.example.com:8443` 的 webhook：</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># - name: www.example.com:8443</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic>#   user: ...</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic>#</span><span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;webhook1.ns1.svc&#39;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>user</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>client-certificate-data</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&lt;pem encoded certificate&gt;&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>client-key-data</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&lt;pem encoded key&gt;&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># `name` 支持使用 * 通配符匹配前缀段。</span><span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;*.webhook-company.org&#39;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>user</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>password</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&lt;password&gt;&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>username</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&lt;name&gt;&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># &#39;*&#39; 是默认匹配项。</span><span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;*&#39;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>user</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>token</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&lt;token&gt;&#34;</span><span style=color:#bbb>
</span></code></pre></div></li>
</ul>
<p>当然，你需要设置 webhook 服务器来处理这些身份验证。</p>
<h3 id=request>请求</h3>
<p>Webhook 发送 POST 请求时，请设置 <code>Content-Type: application/json</code> 并对 <code>admission.k8s.io</code> API 组中的 <code>AdmissionReview</code> 对象进行序列化，将所得到的 JSON 作为请求的主体。</p>
<p>Webhook 可以在配置中的 <code>admissionReviewVersions</code> 字段指定可接受的 <code>AdmissionReview</code> 对象版本：</p>
<ul class="nav nav-tabs" id=validatingwebhookconfiguration-admissionreviewversions role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#validatingwebhookconfiguration-admissionreviewversions-0 role=tab aria-controls=validatingwebhookconfiguration-admissionreviewversions-0 aria-selected=true>admissionregistration.k8s.io/v1</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#validatingwebhookconfiguration-admissionreviewversions-1 role=tab aria-controls=validatingwebhookconfiguration-admissionreviewversions-1>admissionregistration.k8s.io/v1beta1</a></li></ul>
<div class=tab-content id=validatingwebhookconfiguration-admissionreviewversions><div id=validatingwebhookconfiguration-admissionreviewversions-0 class="tab-pane show active" role=tabpanel aria-labelledby=validatingwebhookconfiguration-admissionreviewversions-0>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>admissionregistration.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ValidatingWebhookConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>webhooks</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-webhook.example.com<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>admissionReviewVersions</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;v1&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;v1beta1&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></code></pre></div>
<p>创建 <code>admissionregistration.k8s.io/v1</code> webhook 配置时，<code>admissionReviewVersions</code> 是必填字段。
Webhook 必须支持至少一个当前和以前的 apiserver 都可以解析的 <code>AdmissionReview</code> 版本。</p>
</div>
<div id=validatingwebhookconfiguration-admissionreviewversions-1 class=tab-pane role=tabpanel aria-labelledby=validatingwebhookconfiguration-admissionreviewversions-1>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#080;font-style:italic># v1.16 中被淘汰，推荐使用 admissionregistration.k8s.io/v1</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>admissionregistration.k8s.io/v1beta1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ValidatingWebhookConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>webhooks</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-webhook.example.com<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>admissionReviewVersions</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;v1beta1&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></code></pre></div>
<p>如果未指定 <code>admissionReviewVersions</code>，则创建 <code>admissionregistration.k8s.io/v1beta1</code> Webhook 配置时的默认值为 <code>v1beta1</code>。</p>
</div></div>
<p>API 服务器将发送的是 <code>admissionReviewVersions</code> 列表中所支持的第一个 <code>AdmissionReview</code> 版本。如果 API 服务器不支持列表中的任何版本，则不允许创建配置。</p>
<p>如果 API 服务器遇到以前创建的 Webhook 配置，并且不支持该 API 服务器知道如何发送的任何 <code>AdmissionReview</code> 版本，则调用 Webhook 的尝试将失败，并依据<a href=#failure-policy>失败策略</a>进行处理。</p>
<p>此示例显示了 <code>AdmissionReview</code> 对象中包含的数据，该数据用于请求更新 <code>apps/v1</code> <code>Deployment</code> 的 <code>scale</code> 子资源：</p>
<ul class="nav nav-tabs" id=admissionreview-request role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#admissionreview-request-0 role=tab aria-controls=admissionreview-request-0 aria-selected=true>admission.k8s.io/v1</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#admissionreview-request-1 role=tab aria-controls=admissionreview-request-1>admission.k8s.io/v1beta1</a></li></ul>
<div class=tab-content id=admissionreview-request><div id=admissionreview-request-0 class="tab-pane show active" role=tabpanel aria-labelledby=admissionreview-request-0>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>{<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>&#34;apiVersion&#34;: </span><span style=color:#b44>&#34;admission.k8s.io/v1&#34;</span>,<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>&#34;kind&#34;: </span><span style=color:#b44>&#34;AdmissionReview&#34;</span>,<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>&#34;request&#34;: </span>{<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 唯一标识此准入回调的随机 uid</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;uid&#34;: </span><span style=color:#b44>&#34;705ab4f5-6393-11e8-b7cc-42010a800002&#34;</span>,<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 传入完全正确的 group/version/kind 对象</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;kind&#34;: </span>{<span style=color:#b44>&#34;group&#34;</span>:<span style=color:#b44>&#34;autoscaling&#34;</span>,<span style=color:#b44>&#34;version&#34;</span>:<span style=color:#b44>&#34;v1&#34;</span>,<span style=color:#b44>&#34;kind&#34;</span>:<span style=color:#b44>&#34;Scale&#34;</span>},<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 修改 resource 的完全正确的的 group/version/kind</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;resource&#34;: </span>{<span style=color:#b44>&#34;group&#34;</span>:<span style=color:#b44>&#34;apps&#34;</span>,<span style=color:#b44>&#34;version&#34;</span>:<span style=color:#b44>&#34;v1&#34;</span>,<span style=color:#b44>&#34;resource&#34;</span>:<span style=color:#b44>&#34;deployments&#34;</span>},<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># subResource（如果请求是针对 subResource 的）</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;subResource&#34;: </span><span style=color:#b44>&#34;scale&#34;</span>,<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 在对 API 服务器的原始请求中，传入对象的标准 group/version/kind</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 仅当 webhook 指定 `matchPolicy: Equivalent` 且将对 API 服务器的原始请求转换为 webhook 注册的版本时，这才与 `kind` 不同。</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;requestKind&#34;: </span>{<span style=color:#b44>&#34;group&#34;</span>:<span style=color:#b44>&#34;autoscaling&#34;</span>,<span style=color:#b44>&#34;version&#34;</span>:<span style=color:#b44>&#34;v1&#34;</span>,<span style=color:#b44>&#34;kind&#34;</span>:<span style=color:#b44>&#34;Scale&#34;</span>},<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 在对 API 服务器的原始请求中正在修改的资源的标准 group/version/kind</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 仅当 webhook 指定了 `matchPolicy：Equivalent` 并且将对 API 服务器的原始请求转换为 webhook 注册的版本时，这才与 `resource` 不同。</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;requestResource&#34;: </span>{<span style=color:#b44>&#34;group&#34;</span>:<span style=color:#b44>&#34;apps&#34;</span>,<span style=color:#b44>&#34;version&#34;</span>:<span style=color:#b44>&#34;v1&#34;</span>,<span style=color:#b44>&#34;resource&#34;</span>:<span style=color:#b44>&#34;deployments&#34;</span>},<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># subResource（如果请求是针对 subResource 的）</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 仅当 webhook 指定了 `matchPolicy：Equivalent` 并且将对 API 服务器的原始请求转换为该 webhook 注册的版本时，这才与 `subResource` 不同。</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;requestSubResource&#34;: </span><span style=color:#b44>&#34;scale&#34;</span>,<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 被修改资源的名称</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;name&#34;: </span><span style=color:#b44>&#34;my-deployment&#34;</span>,<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 如果资源是属于名字空间（或者是名字空间对象），则这是被修改的资源的名字空间</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;namespace&#34;: </span><span style=color:#b44>&#34;my-namespace&#34;</span>,<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 操作可以是 CREATE、UPDATE、DELETE 或 CONNECT</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;operation&#34;: </span><span style=color:#b44>&#34;UPDATE&#34;</span>,<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;userInfo&#34;: </span>{<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 向 API 服务器发出请求的经过身份验证的用户的用户名</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>&#34;username&#34;: </span><span style=color:#b44>&#34;admin&#34;</span>,<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 向 API 服务器发出请求的经过身份验证的用户的 UID</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>&#34;uid&#34;: </span><span style=color:#b44>&#34;014fbff9a07c&#34;</span>,<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 向 API 服务器发出请求的经过身份验证的用户的组成员身份</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>&#34;groups&#34;: </span>[<span style=color:#b44>&#34;system:authenticated&#34;</span>,<span style=color:#b44>&#34;my-admin-group&#34;</span>],<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 向 API 服务器发出请求的用户相关的任意附加信息</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 该字段由 API 服务器身份验证层填充，并且如果 webhook 执行了任何 SubjectAccessReview 检查，则应将其包括在内。</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>&#34;extra&#34;: </span>{<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#b44>&#34;some-key&#34;</span>:[<span style=color:#b44>&#34;some-value1&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;some-value2&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>      </span>}<span style=color:#bbb>
</span><span style=color:#bbb>    </span>},<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># object 是被接纳的新对象。</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 对于 DELETE 操作，它为 null。</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;object&#34;: </span>{<span style=color:#b44>&#34;apiVersion&#34;</span>:<span style=color:#b44>&#34;autoscaling/v1&#34;</span>,<span style=color:#b44>&#34;kind&#34;</span>:<span style=color:#b44>&#34;Scale&#34;</span>,...},<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># oldObject 是现有对象。</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 对于 CREATE 和 CONNECT 操作，它为 null。</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;oldObject&#34;: </span>{<span style=color:#b44>&#34;apiVersion&#34;</span>:<span style=color:#b44>&#34;autoscaling/v1&#34;</span>,<span style=color:#b44>&#34;kind&#34;</span>:<span style=color:#b44>&#34;Scale&#34;</span>,...},<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># options 包含要接受的操作的选项，例如 meta.k8s.io/v CreateOptions、UpdateOptions 或 DeleteOptions。</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 对于 CONNECT 操作，它为 null。</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;options&#34;: </span>{<span style=color:#b44>&#34;apiVersion&#34;</span>:<span style=color:#b44>&#34;meta.k8s.io/v1&#34;</span>,<span style=color:#b44>&#34;kind&#34;</span>:<span style=color:#b44>&#34;UpdateOptions&#34;</span>,...},<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># dryRun 表示 API 请求正在以 `dryrun` 模式运行，并且将不会保留。</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 带有副作用的 Webhook 应该避免在 dryRun 为 true 时激活这些副作用。</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 有关更多详细信息，请参见 http://k8s.io/docs/reference/using-api/api-concepts/#make-a-dry-run-request</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;dryRun&#34;: </span><span style=color:#a2f;font-weight:700>false</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span>}<span style=color:#bbb>
</span><span style=color:#bbb></span>}<span style=color:#bbb>
</span></code></pre></div></div>
<div id=admissionreview-request-1 class=tab-pane role=tabpanel aria-labelledby=admissionreview-request-1>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>{<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># v1.16 中被废弃，推荐使用 admission.k8s.io/v1</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>&#34;apiVersion&#34;: </span><span style=color:#b44>&#34;admission.k8s.io/v1beta1&#34;</span>,<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>&#34;kind&#34;: </span><span style=color:#b44>&#34;AdmissionReview&#34;</span>,<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>&#34;request&#34;: </span>{<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 唯一标识此准入回调的随机 uid</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;uid&#34;: </span><span style=color:#b44>&#34;705ab4f5-6393-11e8-b7cc-42010a800002&#34;</span>,<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 传入完全正确的 group/version/kind 对象</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;kind&#34;: </span>{<span style=color:#b44>&#34;group&#34;</span>:<span style=color:#b44>&#34;autoscaling&#34;</span>,<span style=color:#b44>&#34;version&#34;</span>:<span style=color:#b44>&#34;v1&#34;</span>,<span style=color:#b44>&#34;kind&#34;</span>:<span style=color:#b44>&#34;Scale&#34;</span>},<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 修改 resource 的完全正确的的 group/version/kind</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;resource&#34;: </span>{<span style=color:#b44>&#34;group&#34;</span>:<span style=color:#b44>&#34;apps&#34;</span>,<span style=color:#b44>&#34;version&#34;</span>:<span style=color:#b44>&#34;v1&#34;</span>,<span style=color:#b44>&#34;resource&#34;</span>:<span style=color:#b44>&#34;deployments&#34;</span>},<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># subResource（如果请求是针对 subResource 的）</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;subResource&#34;: </span><span style=color:#b44>&#34;scale&#34;</span>,<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 在对 API 服务器的原始请求中，传入对象的标准 group/version/kind。</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 仅当 Webhook 指定了 `matchPolicy：Equivalent` 并且将对 API 服务器的原始请求转换为该 Webhook 注册的版本时，这与 `kind` 不同。</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 仅由 v1.15+ API 服务器发送。</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;requestKind&#34;: </span>{<span style=color:#b44>&#34;group&#34;</span>:<span style=color:#b44>&#34;autoscaling&#34;</span>,<span style=color:#b44>&#34;version&#34;</span>:<span style=color:#b44>&#34;v1&#34;</span>,<span style=color:#b44>&#34;kind&#34;</span>:<span style=color:#b44>&#34;Scale&#34;</span>},<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 在对 API 服务器的原始请求中正在修改的资源的标准 group/version/kind</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 仅当 webhook 指定了 `matchPolicy：Equivalent` 并且将对 API 服务器的原始请求转换为 webhook 注册的版本时，这才与 `resource` 不同。</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 仅由 v1.15+ API 服务器发送。</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;requestResource&#34;: </span>{<span style=color:#b44>&#34;group&#34;</span>:<span style=color:#b44>&#34;apps&#34;</span>,<span style=color:#b44>&#34;version&#34;</span>:<span style=color:#b44>&#34;v1&#34;</span>,<span style=color:#b44>&#34;resource&#34;</span>:<span style=color:#b44>&#34;deployments&#34;</span>},<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># subResource（如果请求是针对 subResource 的）</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 仅当 webhook 指定了 `matchPolicy：Equivalent` 并且将对 API 服务器的原始请求转换为该 webhook 注册的版本时，这才与 `subResource` 不同。</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 仅由 v1.15+ API 服务器发送。</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;requestSubResource&#34;: </span><span style=color:#b44>&#34;scale&#34;</span>,<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 被修改资源的名称</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;name&#34;: </span><span style=color:#b44>&#34;my-deployment&#34;</span>,<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 如果资源是属于名字空间（或者是名字空间对象），则这是被修改的资源的名字空间</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;namespace&#34;: </span><span style=color:#b44>&#34;my-namespace&#34;</span>,<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 操作可以是 CREATE、UPDATE、DELETE 或 CONNECT</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;operation&#34;: </span><span style=color:#b44>&#34;UPDATE&#34;</span>,<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;userInfo&#34;: </span>{<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 向 API 服务器发出请求的经过身份验证的用户的用户名</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>&#34;username&#34;: </span><span style=color:#b44>&#34;admin&#34;</span>,<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 向 API 服务器发出请求的经过身份验证的用户的 UID</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>&#34;uid&#34;: </span><span style=color:#b44>&#34;014fbff9a07c&#34;</span>,<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 向 API 服务器发出请求的经过身份验证的用户的组成员身份</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>&#34;groups&#34;: </span>[<span style=color:#b44>&#34;system:authenticated&#34;</span>,<span style=color:#b44>&#34;my-admin-group&#34;</span>],<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 向 API 服务器发出请求的用户相关的任意附加信息</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 该字段由 API 服务器身份验证层填充，并且如果 webhook 执行了任何 SubjectAccessReview 检查，则应将其包括在内。</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>&#34;extra&#34;: </span>{<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#b44>&#34;some-key&#34;</span>:[<span style=color:#b44>&#34;some-value1&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;some-value2&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>      </span>}<span style=color:#bbb>
</span><span style=color:#bbb>    </span>},<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># object 是被接纳的新对象。</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 对于 DELETE 操作，它为 null。</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;object&#34;: </span>{<span style=color:#b44>&#34;apiVersion&#34;</span>:<span style=color:#b44>&#34;autoscaling/v1&#34;</span>,<span style=color:#b44>&#34;kind&#34;</span>:<span style=color:#b44>&#34;Scale&#34;</span>,...},<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># oldObject 是现有对象。</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 对于 CREATE 和 CONNECT 操作（对于 v1.15.0 之前版本的 API 服务器中的 DELETE 操作），它为 null。</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;oldObject&#34;: </span>{<span style=color:#b44>&#34;apiVersion&#34;</span>:<span style=color:#b44>&#34;autoscaling/v1&#34;</span>,<span style=color:#b44>&#34;kind&#34;</span>:<span style=color:#b44>&#34;Scale&#34;</span>,...},<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># options 包含要接受的操作的选项，例如 meta.k8s.io/v CreateOptions、UpdateOptions 或 DeleteOptions。</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 对于 CONNECT 操作，它为 null。</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 仅由 v1.15+ API 服务器发送。</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;options&#34;: </span>{<span style=color:#b44>&#34;apiVersion&#34;</span>:<span style=color:#b44>&#34;meta.k8s.io/v1&#34;</span>,<span style=color:#b44>&#34;kind&#34;</span>:<span style=color:#b44>&#34;UpdateOptions&#34;</span>,...},<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># dryRun 表示 API 请求正在以 `dryrun` 模式运行，并且将不会保留。</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 带有副作用的 Webhook 应该避免在 dryRun 为 true 时激活这些副作用。</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 有关更多详细信息，请参见 http://k8s.io/docs/reference/using-api/api-concepts/#make-a-dry-run-request</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;dryRun&#34;: </span><span style=color:#a2f;font-weight:700>false</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span>}<span style=color:#bbb>
</span><span style=color:#bbb></span>}<span style=color:#bbb>
</span></code></pre></div></div></div>
<h3 id=response>响应</h3>
<p>Webhook 使用 HTTP 200 状态码、<code>Content-Type: application/json</code> 和一个包含 <code>AdmissionReview</code> 对象的 JSON 序列化格式来发送响应。该 <code>AdmissionReview</code> 对象与发送的版本相同，且其中包含的 <code>response</code> 字段已被有效填充。</p>
<p><code>response</code> 至少必须包含以下字段：</p>
<ul>
<li><code>uid</code>，从发送到 webhook 的 <code>request.uid</code> 中复制而来</li>
<li><code>allowed</code>，设置为 <code>true</code> 或 <code>false</code></li>
</ul>
<p>Webhook 允许请求的最简单响应示例：</p>
<ul class="nav nav-tabs" id=admissionreview-response-allow role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#admissionreview-response-allow-0 role=tab aria-controls=admissionreview-response-allow-0 aria-selected=true>admission.k8s.io/v1</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#admissionreview-response-allow-1 role=tab aria-controls=admissionreview-response-allow-1>admission.k8s.io/v1beta1</a></li></ul>
<div class=tab-content id=admissionreview-response-allow><div id=admissionreview-response-allow-0 class="tab-pane show active" role=tabpanel aria-labelledby=admissionreview-response-allow-0>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
  <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;admission.k8s.io/v1&#34;</span>,
  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;AdmissionReview&#34;</span>,
  <span style=color:green;font-weight:700>&#34;response&#34;</span>: {
    <span style=color:green;font-weight:700>&#34;uid&#34;</span>: <span style=color:#b44>&#34;&lt;value from request.uid&gt;&#34;</span>,
    <span style=color:green;font-weight:700>&#34;allowed&#34;</span>: <span style=color:#a2f;font-weight:700>true</span>
  }
}
</code></pre></div></div>
<div id=admissionreview-response-allow-1 class=tab-pane role=tabpanel aria-labelledby=admissionreview-response-allow-1>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
  <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;admission.k8s.io/v1beta1&#34;</span>,
  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;AdmissionReview&#34;</span>,
  <span style=color:green;font-weight:700>&#34;response&#34;</span>: {
    <span style=color:green;font-weight:700>&#34;uid&#34;</span>: <span style=color:#b44>&#34;&lt;value from request.uid&gt;&#34;</span>,
    <span style=color:green;font-weight:700>&#34;allowed&#34;</span>: <span style=color:#a2f;font-weight:700>true</span>
  }
}
</code></pre></div></div></div>
<p>Webhook 禁止请求的最简单响应示例：</p>
<ul class="nav nav-tabs" id=admissionreview-response-forbid-minimal role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#admissionreview-response-forbid-minimal-0 role=tab aria-controls=admissionreview-response-forbid-minimal-0 aria-selected=true>admission.k8s.io/v1</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#admissionreview-response-forbid-minimal-1 role=tab aria-controls=admissionreview-response-forbid-minimal-1>admission.k8s.io/v1beta1</a></li></ul>
<div class=tab-content id=admissionreview-response-forbid-minimal><div id=admissionreview-response-forbid-minimal-0 class="tab-pane show active" role=tabpanel aria-labelledby=admissionreview-response-forbid-minimal-0>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
  <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;admission.k8s.io/v1&#34;</span>,
  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;AdmissionReview&#34;</span>,
  <span style=color:green;font-weight:700>&#34;response&#34;</span>: {
    <span style=color:green;font-weight:700>&#34;uid&#34;</span>: <span style=color:#b44>&#34;&lt;value from request.uid&gt;&#34;</span>,
    <span style=color:green;font-weight:700>&#34;allowed&#34;</span>: <span style=color:#a2f;font-weight:700>false</span>
  }
}
</code></pre></div></div>
<div id=admissionreview-response-forbid-minimal-1 class=tab-pane role=tabpanel aria-labelledby=admissionreview-response-forbid-minimal-1>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
  <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;admission.k8s.io/v1beta1&#34;</span>,
  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;AdmissionReview&#34;</span>,
  <span style=color:green;font-weight:700>&#34;response&#34;</span>: {
    <span style=color:green;font-weight:700>&#34;uid&#34;</span>: <span style=color:#b44>&#34;&lt;value from request.uid&gt;&#34;</span>,
    <span style=color:green;font-weight:700>&#34;allowed&#34;</span>: <span style=color:#a2f;font-weight:700>false</span>
  }
}
</code></pre></div></div></div>
<p>当拒绝请求时，Webhook 可以使用 <code>status</code> 字段自定义 http 响应码和返回给用户的消息。
有关状态类型的详细信息，请参见
<a href=/docs/reference/generated/kubernetes-api/v1.23/#status-v1-meta>API 文档</a>。
禁止请求的响应示例，它定制了向用户显示的 HTTP 状态码和消息：</p>
<ul class="nav nav-tabs" id=admissionreview-response-forbid-details role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#admissionreview-response-forbid-details-0 role=tab aria-controls=admissionreview-response-forbid-details-0 aria-selected=true>admission.k8s.io/v1</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#admissionreview-response-forbid-details-1 role=tab aria-controls=admissionreview-response-forbid-details-1>admission.k8s.io/v1beta1</a></li></ul>
<div class=tab-content id=admissionreview-response-forbid-details><div id=admissionreview-response-forbid-details-0 class="tab-pane show active" role=tabpanel aria-labelledby=admissionreview-response-forbid-details-0>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
  <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;admission.k8s.io/v1&#34;</span>,
  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;AdmissionReview&#34;</span>,
  <span style=color:green;font-weight:700>&#34;response&#34;</span>: {
    <span style=color:green;font-weight:700>&#34;uid&#34;</span>: <span style=color:#b44>&#34;&lt;value from request.uid&gt;&#34;</span>,
    <span style=color:green;font-weight:700>&#34;allowed&#34;</span>: <span style=color:#a2f;font-weight:700>false</span>,
    <span style=color:green;font-weight:700>&#34;status&#34;</span>: {
      <span style=color:green;font-weight:700>&#34;code&#34;</span>: <span style=color:#666>403</span>,
      <span style=color:green;font-weight:700>&#34;message&#34;</span>: <span style=color:#b44>&#34;You cannot do this because it is Tuesday and your name starts with A&#34;</span>
    }
  }
}
</code></pre></div></div>
<div id=admissionreview-response-forbid-details-1 class=tab-pane role=tabpanel aria-labelledby=admissionreview-response-forbid-details-1>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
  <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;admission.k8s.io/v1beta1&#34;</span>,
  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;AdmissionReview&#34;</span>,
  <span style=color:green;font-weight:700>&#34;response&#34;</span>: {
    <span style=color:green;font-weight:700>&#34;uid&#34;</span>: <span style=color:#b44>&#34;&lt;value from request.uid&gt;&#34;</span>,
    <span style=color:green;font-weight:700>&#34;allowed&#34;</span>: <span style=color:#a2f;font-weight:700>false</span>,
    <span style=color:green;font-weight:700>&#34;status&#34;</span>: {
      <span style=color:green;font-weight:700>&#34;code&#34;</span>: <span style=color:#666>403</span>,
      <span style=color:green;font-weight:700>&#34;message&#34;</span>: <span style=color:#b44>&#34;You cannot do this because it is Tuesday and your name starts with A&#34;</span>
    }
  }
}
</code></pre></div></div></div>
<p>当允许请求时，mutating准入 Webhook 也可以选择修改传入的对象。
这是通过在响应中使用 <code>patch</code> 和 <code>patchType</code> 字段来完成的。
当前唯一支持的 <code>patchType</code> 是 <code>JSONPatch</code>。
有关更多详细信息，请参见 <a href=https://jsonpatch.com/>JSON patch</a>。
对于 <code>patchType: JSONPatch</code>，<code>patch</code> 字段包含一个以 base64 编码的 JSON patch 操作数组。</p>
<p>例如，设置 <code>spec.replicas</code> 的单个补丁操作将是
<code>[{"op": "add", "path": "/spec/replicas", "value": 3}]</code>。</p>
<p>如果以 Base64 形式编码，结果将是
<code>W3sib3AiOiAiYWRkIiwgInBhdGgiOiAiL3NwZWMvcmVwbGljYXMiLCAidmFsdWUiOiAzfV0=</code></p>
<p>因此，添加该标签的 webhook 响应为：
<ul class="nav nav-tabs" id=admissionreview-response-modify role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#admissionreview-response-modify-0 role=tab aria-controls=admissionreview-response-modify-0 aria-selected=true>admission.k8s.io/v1</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#admissionreview-response-modify-1 role=tab aria-controls=admissionreview-response-modify-1>admission.k8s.io/v1beta1</a></li></ul>
<div class=tab-content id=admissionreview-response-modify><div id=admissionreview-response-modify-0 class="tab-pane show active" role=tabpanel aria-labelledby=admissionreview-response-modify-0>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
  <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;admission.k8s.io/v1&#34;</span>,
  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;AdmissionReview&#34;</span>,
  <span style=color:green;font-weight:700>&#34;response&#34;</span>: {
    <span style=color:green;font-weight:700>&#34;uid&#34;</span>: <span style=color:#b44>&#34;&lt;value from request.uid&gt;&#34;</span>,
    <span style=color:green;font-weight:700>&#34;allowed&#34;</span>: <span style=color:#a2f;font-weight:700>true</span>,
    <span style=color:green;font-weight:700>&#34;patchType&#34;</span>: <span style=color:#b44>&#34;JSONPatch&#34;</span>,
    <span style=color:green;font-weight:700>&#34;patch&#34;</span>: <span style=color:#b44>&#34;W3sib3AiOiAiYWRkIiwgInBhdGgiOiAiL3NwZWMvcmVwbGljYXMiLCAidmFsdWUiOiAzfV0=&#34;</span>
  }
}
</code></pre></div></div>
<div id=admissionreview-response-modify-1 class=tab-pane role=tabpanel aria-labelledby=admissionreview-response-modify-1>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
  <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;admission.k8s.io/v1beta1&#34;</span>,
  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;AdmissionReview&#34;</span>,
  <span style=color:green;font-weight:700>&#34;response&#34;</span>: {
    <span style=color:green;font-weight:700>&#34;uid&#34;</span>: <span style=color:#b44>&#34;&lt;value from request.uid&gt;&#34;</span>,
    <span style=color:green;font-weight:700>&#34;allowed&#34;</span>: <span style=color:#a2f;font-weight:700>true</span>,
    <span style=color:green;font-weight:700>&#34;patchType&#34;</span>: <span style=color:#b44>&#34;JSONPatch&#34;</span>,
    <span style=color:green;font-weight:700>&#34;patch&#34;</span>: <span style=color:#b44>&#34;W3sib3AiOiAiYWRkIiwgInBhdGgiOiAiL3NwZWMvcmVwbGljYXMiLCAidmFsdWUiOiAzfV0=&#34;</span>
  }
}
</code></pre></div></div></div>
</p>
<h2 id=webhook-configuration>Webhook 配置</h2>
<p>要注册准入 Webhook，请创建 <code>MutatingWebhookConfiguration</code> 或
<code>ValidatingWebhookConfiguration</code> API 对象。</p>
<p>每种配置可以包含一个或多个 Webhook。如果在单个配置中指定了多个
Webhook，则应为每个 webhook 赋予一个唯一的名称。
这在 <code>admissionregistration.k8s.io/v1</code> 中是必需的，但是在使用
<code>admissionregistration.k8s.io/v1beta1</code> 时强烈建议使用，
以使生成的审核日志和指标更易于与活动配置相匹配。</p>
<p>每个 Webhook 定义以下内容。</p>
<h3 id=matching-requests-rules>匹配请求-规则</h3>
<p>每个 webhook 必须指定用于确定是否应将对 apiserver 的请求发送到 webhook 的规则列表。
每个规则都指定一个或多个 operations、apiGroups、apiVersions 和 resources 以及资源的 scope：</p>
<ul>
<li><code>operations</code> 列出一个或多个要匹配的操作。
可以是 <code>CREATE</code>、<code>UPDATE</code>、<code>DELETE</code>、<code>CONNECT</code> 或 <code>*</code> 以匹配所有内容。</li>
<li><code>apiGroups</code> 列出了一个或多个要匹配的 API 组。<code>""</code> 是核心 API 组。<code>"*"</code> 匹配所有 API 组。</li>
<li><code>apiVersions</code> 列出了一个或多个要匹配的 API 版本。<code>"*"</code> 匹配所有 API 版本。</li>
<li><code>resources</code> 列出了一个或多个要匹配的资源。
<ul>
<li><code>"*"</code> 匹配所有资源，但不包括子资源。</li>
<li><code>"*/*"</code> 匹配所有资源，包括子资源。</li>
<li><code>"pods/*"</code> 匹配 pod 的所有子资源。</li>
<li><code>"*/status"</code> 匹配所有 status 子资源。</li>
</ul>
</li>
<li><code>scope</code> 指定要匹配的范围。有效值为 <code>"Cluster"</code>、<code>"Namespaced"</code> 和 <code>"*"</code>。
子资源匹配其父资源的范围。在 Kubernetes v1.14+ 版本中才被支持。
默认值为 <code>"*"</code>，对应 1.14 版本之前的行为。
<ul>
<li><code>"Cluster"</code> 表示只有集群作用域的资源才能匹配此规则（API 对象 Namespace 是集群作用域的）。</li>
<li><code>"Namespaced"</code> 意味着仅具有名字空间的资源才符合此规则。</li>
<li><code>"*"</code> 表示没有范围限制。</li>
</ul>
</li>
</ul>
<p>如果传入请求与任何 Webhook 规则的指定操作、组、版本、资源和范围匹配，则该请求将发送到 Webhook。</p>
<p>以下是可用于指定应拦截哪些资源的规则的其他示例。</p>
<p>匹配针对 <code>apps/v1</code> 和 <code>apps/v1beta1</code> 组中 <code>deployments</code> 和 <code>replicasets</code>
资源的 <code>CREATE</code> 或 <code>UPDATE</code> 请求：</p>
<ul class="nav nav-tabs" id=validatingwebhookconfiguration-rules-1 role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#validatingwebhookconfiguration-rules-1-0 role=tab aria-controls=validatingwebhookconfiguration-rules-1-0 aria-selected=true>admissionregistration.k8s.io/v1</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#validatingwebhookconfiguration-rules-1-1 role=tab aria-controls=validatingwebhookconfiguration-rules-1-1>admissionregistration.k8s.io/v1beta1</a></li></ul>
<div class=tab-content id=validatingwebhookconfiguration-rules-1><div id=validatingwebhookconfiguration-rules-1-0 class="tab-pane show active" role=tabpanel aria-labelledby=validatingwebhookconfiguration-rules-1-0>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>admissionregistration.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ValidatingWebhookConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>webhooks</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-webhook.example.com<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>operations</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;CREATE&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;UPDATE&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;apps&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiVersions</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;v1&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;v1beta1&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;deployments&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;replicasets&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>scope</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;Namespaced&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></code></pre></div></div>
<div id=validatingwebhookconfiguration-rules-1-1 class=tab-pane role=tabpanel aria-labelledby=validatingwebhookconfiguration-rules-1-1>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#080;font-style:italic># v1.16 中被废弃，推荐使用 admissionregistration.k8s.io/v1</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>admissionregistration.k8s.io/v1beta1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ValidatingWebhookConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>webhooks</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-webhook.example.com<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>operations</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;CREATE&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;UPDATE&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;apps&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiVersions</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;v1&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;v1beta1&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;deployments&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;replicasets&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>scope</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;Namespaced&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></code></pre></div></div></div>
<p>匹配所有 API 组和版本中的所有资源（但不包括子资源）的创建请求：</p>
<ul class="nav nav-tabs" id=validatingwebhookconfiguration-rules-2 role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#validatingwebhookconfiguration-rules-2-0 role=tab aria-controls=validatingwebhookconfiguration-rules-2-0 aria-selected=true>admissionregistration.k8s.io/v1</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#validatingwebhookconfiguration-rules-2-1 role=tab aria-controls=validatingwebhookconfiguration-rules-2-1>admissionregistration.k8s.io/v1beta1</a></li></ul>
<div class=tab-content id=validatingwebhookconfiguration-rules-2><div id=validatingwebhookconfiguration-rules-2-0 class="tab-pane show active" role=tabpanel aria-labelledby=validatingwebhookconfiguration-rules-2-0>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>admissionregistration.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ValidatingWebhookConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>webhooks</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-webhook.example.com<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>operations</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;CREATE&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;*&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiVersions</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;*&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;*&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>scope</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;*&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></code></pre></div></div>
<div id=validatingwebhookconfiguration-rules-2-1 class=tab-pane role=tabpanel aria-labelledby=validatingwebhookconfiguration-rules-2-1>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#080;font-style:italic># v1.16 中被废弃，推荐使用 admissionregistration.k8s.io/v1</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>admissionregistration.k8s.io/v1beta1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ValidatingWebhookConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>webhooks</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-webhook.example.com<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>operations</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;CREATE&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;*&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiVersions</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;*&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;*&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>scope</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;*&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></code></pre></div></div></div>
<p>匹配所有 API 组和版本中所有 <code>status</code> 子资源的更新请求：</p>
<ul class="nav nav-tabs" id=validatingwebhookconfiguration-rules-2 role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#validatingwebhookconfiguration-rules-2-0 role=tab aria-controls=validatingwebhookconfiguration-rules-2-0 aria-selected=true>admissionregistration.k8s.io/v1</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#validatingwebhookconfiguration-rules-2-1 role=tab aria-controls=validatingwebhookconfiguration-rules-2-1>admissionregistration.k8s.io/v1beta1</a></li></ul>
<div class=tab-content id=validatingwebhookconfiguration-rules-2><div id=validatingwebhookconfiguration-rules-2-0 class="tab-pane show active" role=tabpanel aria-labelledby=validatingwebhookconfiguration-rules-2-0>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>admissionregistration.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ValidatingWebhookConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>webhooks</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-webhook.example.com<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>operations</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;UPDATE&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;*&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiVersions</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;*&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;*/status&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>scope</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;*&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></code></pre></div></div>
<div id=validatingwebhookconfiguration-rules-2-1 class=tab-pane role=tabpanel aria-labelledby=validatingwebhookconfiguration-rules-2-1>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#080;font-style:italic># v1.16 中被废弃，推荐使用 admissionregistration.k8s.io/v1</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>admissionregistration.k8s.io/v1beta1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ValidatingWebhookConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>webhooks</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-webhook.example.com<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>operations</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;UPDATE&#34;</span>]<span style=color:#bbb> 
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;*&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiVersions</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;*&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;*/status&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>scope</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;*&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></code></pre></div></div></div>
<h3 id=matching-requests-objectselector>匹配请求：objectSelector</h3>
<p>在版本 v1.15+ 中, 通过指定 <code>objectSelector</code>，Webhook 能够根据
可能发送的对象的标签来限制哪些请求被拦截。
如果指定，则将对 <code>objectSelector</code> 和可能发送到 Webhook 的 object 和 oldObject
进行评估。如果两个对象之一与选择器匹配，则认为该请求已匹配。</p>
<p>空对象（对于创建操作而言为 oldObject，对于删除操作而言为 newObject），
或不能带标签的对象（例如 <code>DeploymentRollback</code> 或 <code>PodProxyOptions</code> 对象）
被认为不匹配。</p>
<p>仅当选择使用 webhook 时才使用对象选择器，因为最终用户可以通过设置标签来
跳过准入 Webhook。</p>
<p>这个例子展示了一个 mutating webhook，它将匹配带有标签 <code>foo:bar</code> 的任何资源的
<code>CREATE</code> 的操作：</p>
<ul class="nav nav-tabs" id=objectselector-example role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#objectselector-example-0 role=tab aria-controls=objectselector-example-0 aria-selected=true>admissionregistration.k8s.io/v1</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#objectselector-example-1 role=tab aria-controls=objectselector-example-1>admissionregistration.k8s.io/v1beta1</a></li></ul>
<div class=tab-content id=objectselector-example><div id=objectselector-example-0 class="tab-pane show active" role=tabpanel aria-labelledby=objectselector-example-0>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>admissionregistration.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>MutatingWebhookConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>webhooks</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-webhook.example.com<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>objectSelector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>foo</span>:<span style=color:#bbb> </span>bar<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>operations</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;CREATE&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;*&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiVersions</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;*&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;*&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>scope</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;*&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></code></pre></div></div>
<div id=objectselector-example-1 class=tab-pane role=tabpanel aria-labelledby=objectselector-example-1>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#080;font-style:italic># v1.16 中被废弃，推荐使用 admissionregistration.k8s.io/v1</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>admissionregistration.k8s.io/v1beta1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>MutatingWebhookConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>webhooks</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-webhook.example.com<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>objectSelector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>foo</span>:<span style=color:#bbb> </span>bar<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>operations</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;CREATE&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;*&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiVersions</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;*&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;*&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>scope</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;*&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></code></pre></div></div></div>
<p>有关标签选择器的更多示例，请参见<a href=/zh/docs/concepts/overview/working-with-objects/labels>标签</a>。</p>
<h3 id=matching-requests-namespaceselector>匹配请求：namespaceSelector</h3>
<p>通过指定 <code>namespaceSelector</code>，Webhook 可以根据具有名字空间的资源所处的
名字空间的标签来选择拦截哪些资源的操作。</p>
<p><code>namespaceSelector</code> 根据名字空间的标签是否匹配选择器，决定是否针对具名字空间的资源
（或 Namespace 对象）的请求运行 webhook。
如果对象是除 Namespace 以外的集群范围的资源，则 <code>namespaceSelector</code> 标签无效。</p>
<p>本例给出的修改性质的 Webhook 将匹配到对名字空间中具名字空间的资源的 <code>CREATE</code> 请求，
前提是这些资源不含值为 "0" 或 "1" 的 "runlevel" 标签：</p>
<ul class="nav nav-tabs" id=mutatingwebhookconfiguration-namespaceselector-1 role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#mutatingwebhookconfiguration-namespaceselector-1-0 role=tab aria-controls=mutatingwebhookconfiguration-namespaceselector-1-0 aria-selected=true>admissionregistration.k8s.io/v1</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#mutatingwebhookconfiguration-namespaceselector-1-1 role=tab aria-controls=mutatingwebhookconfiguration-namespaceselector-1-1>admissionregistration.k8s.io/v1beta1</a></li></ul>
<div class=tab-content id=mutatingwebhookconfiguration-namespaceselector-1><div id=mutatingwebhookconfiguration-namespaceselector-1-0 class="tab-pane show active" role=tabpanel aria-labelledby=mutatingwebhookconfiguration-namespaceselector-1-0>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>admissionregistration.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>MutatingWebhookConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>webhooks</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-webhook.example.com<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespaceSelector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>runlevel<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span>NotIn<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>values</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;0&#34;</span>,<span style=color:#b44>&#34;1&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>operations</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;CREATE&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;*&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiVersions</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;*&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;*&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>scope</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;Namespaced&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></code></pre></div></div>
<div id=mutatingwebhookconfiguration-namespaceselector-1-1 class=tab-pane role=tabpanel aria-labelledby=mutatingwebhookconfiguration-namespaceselector-1-1>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#080;font-style:italic># v1.16 中被废弃，推荐使用 admissionregistration.k8s.io/v1</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>admissionregistration.k8s.io/v1beta1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>MutatingWebhookConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>webhooks</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-webhook.example.com<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespaceSelector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>runlevel<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span>NotIn<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>values</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;0&#34;</span>,<span style=color:#b44>&#34;1&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>operations</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;CREATE&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;*&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiVersions</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;*&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;*&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>scope</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;Namespaced&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></code></pre></div></div></div>
<p>此示例显示了一个验证性质的 Webhook，它将匹配到对某名字空间中的任何具名字空间的资源的
<code>CREATE</code> 请求，前提是该名字空间具有值为 "prod" 或 "staging" 的 "environment" 标签：</p>
<ul class="nav nav-tabs" id=validatingwebhookconfiguration-namespaceselector-2 role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#validatingwebhookconfiguration-namespaceselector-2-0 role=tab aria-controls=validatingwebhookconfiguration-namespaceselector-2-0 aria-selected=true>admissionregistration.k8s.io/v1</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#validatingwebhookconfiguration-namespaceselector-2-1 role=tab aria-controls=validatingwebhookconfiguration-namespaceselector-2-1>admissionregistration.k8s.io/v1beta1</a></li></ul>
<div class=tab-content id=validatingwebhookconfiguration-namespaceselector-2><div id=validatingwebhookconfiguration-namespaceselector-2-0 class="tab-pane show active" role=tabpanel aria-labelledby=validatingwebhookconfiguration-namespaceselector-2-0>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>admissionregistration.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ValidatingWebhookConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>webhooks</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-webhook.example.com<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespaceSelector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>environment<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span>In<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>values</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;prod&#34;</span>,<span style=color:#b44>&#34;staging&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>operations</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;CREATE&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;*&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiVersions</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;*&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;*&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>scope</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;Namespaced&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></code></pre></div></div>
<div id=validatingwebhookconfiguration-namespaceselector-2-1 class=tab-pane role=tabpanel aria-labelledby=validatingwebhookconfiguration-namespaceselector-2-1>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#080;font-style:italic># v1.16 中被废弃，推荐使用 admissionregistration.k8s.io/v1</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>admissionregistration.k8s.io/v1beta1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ValidatingWebhookConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>webhooks</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-webhook.example.com<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespaceSelector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>environment<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span>In<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>values</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;prod&#34;</span>,<span style=color:#b44>&#34;staging&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>operations</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;CREATE&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;*&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiVersions</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;*&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;*&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>scope</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;Namespaced&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></code></pre></div></div></div>
<p>有关标签选择器的更多示例，请参见
<a href=/zh/docs/concepts/overview/working-with-objects/labels>标签</a>。</p>
<h3 id=matching-requests-matchpolicy>匹配请求：matchPolicy</h3>
<p>API 服务器可以通过多个 API 组或版本来提供对象。
例如，Kubernetes API 服务器允许通过 <code>extensions/v1beta1</code>、<code>apps/v1beta1</code>、
<code>apps/v1beta2</code> 和 <code>apps/v1</code> API 创建和修改 <code>Deployment</code> 对象。</p>
<p>例如，如果一个 webhook 仅为某些 API 组/版本指定了规则（例如
<code>apiGroups:["apps"], apiVersions:["v1","v1beta1"]</code>），而修改资源的请求
是通过另一个 API 组/版本（例如 <code>extensions/v1beta1</code>）发出的，
该请求将不会被发送到 Webhook。</p>
<p>在 v1.15+ 中，<code>matchPolicy</code> 允许 webhook 定义如何使用其 <code>rules</code> 匹配传入的请求。
允许的值为 <code>Exact</code> 或 <code>Equivalent</code>。</p>
<ul>
<li><code>Exact</code> 表示仅当请求与指定规则完全匹配时才应拦截该请求。</li>
<li><code>Equivalent</code> 表示如果某个请求意在修改 <code>rules</code> 中列出的资源，
即使该请求是通过其他 API 组或版本发起，也应拦截该请求。</li>
</ul>
<p>在上面给出的示例中，仅为 <code>apps/v1</code> 注册的 webhook 可以使用 <code>matchPolicy</code>：</p>
<ul>
<li><code>matchPolicy: Exact</code> 表示不会将 <code>extensions/v1beta1</code> 请求发送到 Webhook</li>
<li><code>matchPolicy:Equivalent</code> 表示将 <code>extensions/v1beta1</code> 请求发送到 webhook
（将对象转换为 webhook 指定的版本：<code>apps/v1</code>）</li>
</ul>
<p>建议指定 <code>Equivalent</code>，确保升级后启用 API 服务器中资源的新版本时，
Webhook 继续拦截他们期望的资源。</p>
<p>当 API 服务器停止提供某资源时，该资源不再被视为等同于该资源的其他仍在提供服务的版本。
例如，<code>extensions/v1beta1</code> 中的 Deployment 已被废弃，计划在 v1.16 中默认停止使用。
在这种情况下，带有 <code>apiGroups:["extensions"], apiVersions:["v1beta1"], resources: ["deployments"]</code>
规则的 Webhook 将不再拦截通过 <code>apps/v1</code> API 来创建 Deployment 的请求。
["deployments"] 规则将不再拦截通过 <code>apps/v1</code> API 创建的部署。</p>
<p>此示例显示了一个验证性质的 Webhook，该 Webhook 拦截对 Deployment 的修改（无论 API 组或版本是什么），
始终会发送一个 <code>apps/v1</code> 版本的 Deployment 对象：</p>
<ul class="nav nav-tabs" id=validatingwebhookconfiguration-matchpolicy role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#validatingwebhookconfiguration-matchpolicy-0 role=tab aria-controls=validatingwebhookconfiguration-matchpolicy-0 aria-selected=true>admissionregistration.k8s.io/v1</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#validatingwebhookconfiguration-matchpolicy-1 role=tab aria-controls=validatingwebhookconfiguration-matchpolicy-1>admissionregistration.k8s.io/v1beta1</a></li></ul>
<div class=tab-content id=validatingwebhookconfiguration-matchpolicy><div id=validatingwebhookconfiguration-matchpolicy-0 class="tab-pane show active" role=tabpanel aria-labelledby=validatingwebhookconfiguration-matchpolicy-0>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>admissionregistration.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ValidatingWebhookConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>webhooks</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-webhook.example.com<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>matchPolicy</span>:<span style=color:#bbb> </span>Equivalent<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>operations</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;CREATE&#34;</span>,<span style=color:#b44>&#34;UPDATE&#34;</span>,<span style=color:#b44>&#34;DELETE&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;apps&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiVersions</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;v1&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;deployments&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>scope</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;Namespaced&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></code></pre></div>
<p>使用 <code>admissionregistration.k8s.io/v1</code> 创建的 admission webhhok 默认为 <code>Equivalent</code>。</p>
</div>
<div id=validatingwebhookconfiguration-matchpolicy-1 class=tab-pane role=tabpanel aria-labelledby=validatingwebhookconfiguration-matchpolicy-1>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#080;font-style:italic># v1.16 中被废弃，推荐使用 admissionregistration.k8s.io/v1</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>admissionregistration.k8s.io/v1beta1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ValidatingWebhookConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>webhooks</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-webhook.example.com<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>matchPolicy</span>:<span style=color:#bbb> </span>Equivalent<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>operations</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;CREATE&#34;</span>,<span style=color:#b44>&#34;UPDATE&#34;</span>,<span style=color:#b44>&#34;DELETE&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;apps&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiVersions</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;v1&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;deployments&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>scope</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;Namespaced&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></code></pre></div>
<p>使用 <code>admissionregistration.k8s.io/v1beta1</code> 创建的准入 Webhook 默认为 <code>Exact</code>。</p>
</div></div>
<h3 id=调用-webhook>调用 Webhook</h3>
<p>API 服务器确定请求应发送到 webhook 后，它需要知道如何调用 webhook。
此信息在 webhook 配置的 <code>clientConfig</code> 节中指定。</p>
<p>Webhook 可以通过 URL 或服务引用来调用，并且可以选择包含自定义 CA 包，以用于验证 TLS 连接。</p>
<h4 id=url>URL</h4>
<p><code>url</code> 以标准 URL 形式给出 webhook 的位置（<code>scheme://host:port/path</code>）。</p>
<p><code>host</code> 不应引用集群中运行的服务；通过指定 <code>service</code> 字段来使用服务引用。
主机可以通过某些 apiserver 中的外部 DNS 进行解析。
（例如，<code>kube-apiserver</code> 无法解析集群内 DNS，因为这将违反分层规则）。<code>host</code> 也可以是 IP 地址。</p>
<p>请注意，将 <code>localhost</code> 或 <code>127.0.0.1</code> 用作 <code>host</code> 是有风险的，
除非你非常小心地在所有运行 apiserver 的、可能需要对此 webhook
进行调用的主机上运行。这样的安装方式可能不具有可移植性，即很难在新集群中启用。</p>
<p>scheme 必须为 "https"；URL 必须以 "https://" 开头。</p>
<p>使用用户或基本身份验证（例如："user:password@"）是不允许的。
使用片段（"#..."）和查询参数（"?..."）也是不允许的。</p>
<p>这是配置为调用 URL 的修改性质的 Webhook 的示例
（并且期望使用系统信任根证书来验证 TLS 证书，因此不指定 caBundle）：</p>
<ul class="nav nav-tabs" id=mutatingwebhookconfiguration-url role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#mutatingwebhookconfiguration-url-0 role=tab aria-controls=mutatingwebhookconfiguration-url-0 aria-selected=true>admissionregistration.k8s.io/v1</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#mutatingwebhookconfiguration-url-1 role=tab aria-controls=mutatingwebhookconfiguration-url-1>admissionregistration.k8s.io/v1beta1</a></li></ul>
<div class=tab-content id=mutatingwebhookconfiguration-url><div id=mutatingwebhookconfiguration-url-0 class="tab-pane show active" role=tabpanel aria-labelledby=mutatingwebhookconfiguration-url-0>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>admissionregistration.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>MutatingWebhookConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>webhooks</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-webhook.example.com<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>clientConfig</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>url</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;https://my-webhook.example.com:9443/my-webhook-path&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></code></pre></div></div>
<div id=mutatingwebhookconfiguration-url-1 class=tab-pane role=tabpanel aria-labelledby=mutatingwebhookconfiguration-url-1>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#080;font-style:italic># v1.16 中被废弃，推荐使用 admissionregistration.k8s.io/v1</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>admissionregistration.k8s.io/v1beta1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>MutatingWebhookConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>webhooks</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-webhook.example.com<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>clientConfig</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>url</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;https://my-webhook.example.com:9443/my-webhook-path&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></code></pre></div></div></div>
<h4 id=service-reference>服务引用 </h4>
<p><code>clientConfig</code> 内部的 Service 是对该 Webhook 服务的引用。
如果 Webhook 在集群中运行，则应使用 <code>service</code> 而不是 <code>url</code>。
服务的 <code>namespace</code> 和 <code>name</code> 是必需的。
<code>port</code> 是可选的，默认值为 443。<code>path</code> 是可选的，默认为 "/"。</p>
<p>这是一个 mutating Webhook 的示例，该 mutating Webhook 配置为在子路径 "/my-path" 端口
"1234" 上调用服务，并使用自定义 CA 包针对 ServerName
<code>my-service-name.my-service-namespace.svc</code> 验证 TLS 连接：</p>
<ul class="nav nav-tabs" id=mutatingwebhookconfiguration-service role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#mutatingwebhookconfiguration-service-0 role=tab aria-controls=mutatingwebhookconfiguration-service-0 aria-selected=true>admissionregistration.k8s.io/v1</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#mutatingwebhookconfiguration-service-1 role=tab aria-controls=mutatingwebhookconfiguration-service-1>admissionregistration.k8s.io/v1beta1</a></li></ul>
<div class=tab-content id=mutatingwebhookconfiguration-service><div id=mutatingwebhookconfiguration-service-0 class="tab-pane show active" role=tabpanel aria-labelledby=mutatingwebhookconfiguration-service-0>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>admissionregistration.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>MutatingWebhookConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>webhooks</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-webhook.example.com<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>clientConfig</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>caBundle</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;Ci0tLS0tQk...&lt;base64-encoded PEM bundle containing the CA that signed the webhook&#39;s serving certificate&gt;...tLS0K&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>service</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>my-service-namespace<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service-name<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/my-path<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>1234</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></code></pre></div></div>
<div id=mutatingwebhookconfiguration-service-1 class=tab-pane role=tabpanel aria-labelledby=mutatingwebhookconfiguration-service-1>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#080;font-style:italic># v1.16 中被废弃，推荐使用 admissionregistration.k8s.io/v1</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>admissionregistration.k8s.io/v1beta1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>MutatingWebhookConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>webhooks</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-webhook.example.com<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>clientConfig</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>caBundle</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;Ci0tLS0tQk...&lt;base64-encoded PEM bundle containing the CA that signed the webhook&#39;s serving certificate&gt;...tLS0K&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>service</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>my-service-namespace<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service-name<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/my-path<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>1234</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></code></pre></div></div></div>
<h3 id=side-effects>副作用</h3>
<p>Webhook 通常仅对发送给他们的 <code>AdmissionReview</code> 内容进行操作。
但是，某些 Webhook 在处理 admission 请求时会进行带外更改。</p>
<p>进行带外更改的（产生“副作用”的） Webhook 必须具有协调机制（如控制器），
该机制定期确定事物的实际状态，并调整由准入 Webhook 修改的带外数据以反映现实情况。
这是因为对准入 Webhook 的调用不能保证所准入的对象将原样保留，或根本不保留。
以后，webhook 可以修改对象的内容，在写入存储时可能会发生冲突，或者
服务器可以在持久保存对象之前关闭电源。</p>
<p>此外，处理 <code>dryRun: true</code> admission 请求时，具有副作用的 Webhook 必须避免产生副作用。
一个 Webhook 必须明确指出在使用 <code>dryRun</code> 运行时不会有副作用，
否则 <code>dry-run</code> 请求将不会发送到该 Webhook，而 API 请求将会失败。</p>
<p>Webhook 使用 webhook 配置中的 <code>sideEffects</code> 字段显示它们是否有副作用：</p>
<ul>
<li><code>Unknown</code>：有关调用 Webhook 的副作用的信息是不可知的。
如果带有 <code>dryRun：true</code> 的请求将触发对该 Webhook 的调用，则该请求将失败，并且不会调用该 Webhook。</li>
<li><code>None</code>：调用 webhook 没有副作用。</li>
<li><code>Some</code>：调用 webhook 可能会有副作用。
如果请求具有 <code>dry-run</code> 属性将触发对此 Webhook 的调用，
则该请求将会失败，并且不会调用该 Webhook。</li>
<li><code>NoneOnDryRun</code>：调用 webhook 可能会有副作用，但是如果将带有 <code>dryRun: true</code>
属性的请求发送到 webhook，则 webhook 将抑制副作用（该 webhook 可识别 <code>dryRun</code>）。</li>
</ul>
<p>允许值：</p>
<ul>
<li>在 <code>admissionregistration.k8s.io/v1beta1</code> 中，<code>sideEffects</code> 可以设置为
<code>Unknown</code>、<code>None</code>、<code>Some</code> 或者 <code>NoneOnDryRun</code>，并且默认值为 <code>Unknown</code>。</li>
<li>在 <code>admissionregistration.k8s.io/v1</code> 中, <code>sideEffects</code> 必须设置为
<code>None</code> 或者 <code>NoneOnDryRun</code>。</li>
</ul>
<p>这是一个 validating webhook 的示例，表明它对 <code>dryRun: true</code> 请求没有副作用：</p>
<ul class="nav nav-tabs" id=validatingwebhookconfiguration-sideeffects role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#validatingwebhookconfiguration-sideeffects-0 role=tab aria-controls=validatingwebhookconfiguration-sideeffects-0 aria-selected=true>admissionregistration.k8s.io/v1</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#validatingwebhookconfiguration-sideeffects-1 role=tab aria-controls=validatingwebhookconfiguration-sideeffects-1>admissionregistration.k8s.io/v1beta1</a></li></ul>
<div class=tab-content id=validatingwebhookconfiguration-sideeffects><div id=validatingwebhookconfiguration-sideeffects-0 class="tab-pane show active" role=tabpanel aria-labelledby=validatingwebhookconfiguration-sideeffects-0>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>admissionregistration.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ValidatingWebhookConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>webhooks</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-webhook.example.com<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>sideEffects</span>:<span style=color:#bbb> </span>NoneOnDryRun<span style=color:#bbb>
</span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></code></pre></div></div>
<div id=validatingwebhookconfiguration-sideeffects-1 class=tab-pane role=tabpanel aria-labelledby=validatingwebhookconfiguration-sideeffects-1>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#080;font-style:italic># v1.16 中被废弃，推荐使用 admissionregistration.k8s.io/v1</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>admissionregistration.k8s.io/v1beta1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ValidatingWebhookConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>webhooks</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-webhook.example.com<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>sideEffects</span>:<span style=color:#bbb> </span>NoneOnDryRun<span style=color:#bbb>
</span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></code></pre></div></div></div>
<h3 id=timeouts>超时</h3>
<p>由于 Webhook 会增加 API 请求的延迟，因此应尽快完成自身的操作。
<code>timeoutSeconds</code> 用来配置在将调用视为失败之前，允许 API 服务器等待 Webhook 响应的时间长度。</p>
<p>如果超时在 Webhook 响应之前被触发，则基于<a href=#failure-policy>失败策略</a>，将忽略
Webhook 调用或拒绝 API 调用。</p>
<p>超时值必须设置在 1 到 30 秒之间。</p>
<p>这是一个自定义超时设置为 2 秒的 validating Webhook 的示例：</p>
<ul class="nav nav-tabs" id=validatingwebhookconfiguration-timeoutseconds role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#validatingwebhookconfiguration-timeoutseconds-0 role=tab aria-controls=validatingwebhookconfiguration-timeoutseconds-0 aria-selected=true>admissionregistration.k8s.io/v1</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#validatingwebhookconfiguration-timeoutseconds-1 role=tab aria-controls=validatingwebhookconfiguration-timeoutseconds-1>admissionregistration.k8s.io/v1beta1</a></li></ul>
<div class=tab-content id=validatingwebhookconfiguration-timeoutseconds><div id=validatingwebhookconfiguration-timeoutseconds-0 class="tab-pane show active" role=tabpanel aria-labelledby=validatingwebhookconfiguration-timeoutseconds-0>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>admissionregistration.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ValidatingWebhookConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>webhooks</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-webhook.example.com<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>timeoutSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>2</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></code></pre></div>
<p>使用 <code>admissionregistration.k8s.io/v1</code> 创建的准入 Webhook 默认超时为 10 秒。</p>
</div>
<div id=validatingwebhookconfiguration-timeoutseconds-1 class=tab-pane role=tabpanel aria-labelledby=validatingwebhookconfiguration-timeoutseconds-1>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#080;font-style:italic># v1.16 中被废弃，推荐使用 admissionregistration.k8s.io/v1</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>admissionregistration.k8s.io/v1beta1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ValidatingWebhookConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>webhooks</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-webhook.example.com<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>timeoutSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>2</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></code></pre></div>
<p>使用 <code>admissionregistration.k8s.io/v1beta1</code> 创建的准入 Webhook 默认超时为 30 秒。</p>
</div></div>
<h3 id=reinvocation-policy>再调用策略 </h3>
<p>修改性质的准入插件（包括 Webhook）的任何一种排序方式都不会适用于所有情况。
(参见 <a href=https://issue.k8s.io/64333>https://issue.k8s.io/64333</a> 示例)。
修改性质的 Webhook 可以向对象中添加新的子结构（例如向 <code>pod</code> 中添加 <code>container</code>），
已经运行的其他修改插件可能会对这些新结构有影响
（就像在所有容器上设置 <code>imagePullPolicy</code> 一样）。</p>
<p>在 v1.15+ 中，允许修改性质的准入插件感应到其他插件所做的更改，
如果修改性质的 Webhook 修改了一个对象，则会重新运行内置的修改性质的准入插件，
并且修改性质的 Webhook 可以指定 <code>reinvocationPolicy</code> 来控制是否也重新调用它们。</p>
<p>可以将 <code>reinvocationPolicy</code> 设置为 <code>Never</code> 或 <code>IfNeeded</code>。 默认为 <code>Never</code>。</p>
<ul>
<li><code>Never</code>: 在一次准入测试中，不得多次调用 Webhook。</li>
<li><code>IfNeeded</code>: 如果在最初的 Webhook 调用之后被其他对象的插件修改了被接纳的对象，
则可以作为准入测试的一部分再次调用该 webhook。</li>
</ul>
<p>要注意的重要因素有：</p>
<ul>
<li>不能保证附加调用的次数恰好是一。</li>
<li>如果其他调用导致对该对象的进一步修改，则不能保证再次调用 Webhook。</li>
<li>使用此选项的 Webhook 可能会重新排序，以最大程度地减少额外调用的次数。</li>
<li>要在确保所有修改都完成后验证对象，请改用验证性质的 Webhook
（推荐用于有副作用的 Webhook）。</li>
</ul>
<p>这是一个修改性质的 Webhook 的示例，该 Webhook 在以后的准入插件修改对象时被重新调用：</p>
<ul class="nav nav-tabs" id=mutatingwebhookconfiguration-reinvocationpolicy role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#mutatingwebhookconfiguration-reinvocationpolicy-0 role=tab aria-controls=mutatingwebhookconfiguration-reinvocationpolicy-0 aria-selected=true>admissionregistration.k8s.io/v1</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#mutatingwebhookconfiguration-reinvocationpolicy-1 role=tab aria-controls=mutatingwebhookconfiguration-reinvocationpolicy-1>admissionregistration.k8s.io/v1beta1</a></li></ul>
<div class=tab-content id=mutatingwebhookconfiguration-reinvocationpolicy><div id=mutatingwebhookconfiguration-reinvocationpolicy-0 class="tab-pane show active" role=tabpanel aria-labelledby=mutatingwebhookconfiguration-reinvocationpolicy-0>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>admissionregistration.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>MutatingWebhookConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>webhooks</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-webhook.example.com<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>reinvocationPolicy</span>:<span style=color:#bbb> </span>IfNeeded<span style=color:#bbb>
</span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></code></pre></div></div>
<div id=mutatingwebhookconfiguration-reinvocationpolicy-1 class=tab-pane role=tabpanel aria-labelledby=mutatingwebhookconfiguration-reinvocationpolicy-1>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#080;font-style:italic># v1.16 中被废弃，推荐使用 admissionregistration.k8s.io/v1</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>admissionregistration.k8s.io/v1beta1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>MutatingWebhookConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>webhooks</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-webhook.example.com<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>reinvocationPolicy</span>:<span style=color:#bbb> </span>IfNeeded<span style=color:#bbb>
</span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></code></pre></div></div></div>
<p>修改性质的 Webhook 必须具有<a href=#idempotence>幂等</a>性，并且能够成功处理
已被接纳并可能被修改的对象的修改性质的 Webhook。
对于所有修改性质的准入 Webhook 都是如此，因为它们可以在对象中进行的
任何更改可能已经存在于用户提供的对象中，但是对于选择重新调用的 webhook
来说是必不可少的。</p>
<h3 id=failure-policy>失败策略</h3>
<p><code>failurePolicy</code> 定义了如何处理准入 webhook 中无法识别的错误和超时错误。允许的值为 <code>Ignore</code> 或 <code>Fail</code>。</p>
<ul>
<li><code>Ignore</code> 表示调用 webhook 的错误将被忽略并且允许 API 请求继续。</li>
<li><code>Fail</code> 表示调用 webhook 的错误导致准入失败并且 API 请求被拒绝。</li>
</ul>
<p>这是一个修改性质的 webhook，配置为在调用准入 Webhook 遇到错误时拒绝 API 请求：</p>
<ul class="nav nav-tabs" id=mutatingwebhookconfiguration-failurepolicy role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#mutatingwebhookconfiguration-failurepolicy-0 role=tab aria-controls=mutatingwebhookconfiguration-failurepolicy-0 aria-selected=true>admissionregistration.k8s.io/v1</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#mutatingwebhookconfiguration-failurepolicy-1 role=tab aria-controls=mutatingwebhookconfiguration-failurepolicy-1>admissionregistration.k8s.io/v1beta1</a></li></ul>
<div class=tab-content id=mutatingwebhookconfiguration-failurepolicy><div id=mutatingwebhookconfiguration-failurepolicy-0 class="tab-pane show active" role=tabpanel aria-labelledby=mutatingwebhookconfiguration-failurepolicy-0>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>admissionregistration.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>MutatingWebhookConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>webhooks</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-webhook.example.com<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>failurePolicy</span>:<span style=color:#bbb> </span>Fail<span style=color:#bbb>
</span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></code></pre></div>
<p>使用 <code>admissionregistration.k8s.io/v1</code> 创建的准入 Webhook 将
<code>failurePolicy</code> 默认设置为 <code>Fail</code>。</p>
</div>
<div id=mutatingwebhookconfiguration-failurepolicy-1 class=tab-pane role=tabpanel aria-labelledby=mutatingwebhookconfiguration-failurepolicy-1>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#080;font-style:italic># v1.16 中被废弃，推荐使用 admissionregistration.k8s.io/v1</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>admissionregistration.k8s.io/v1beta1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>MutatingWebhookConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>webhooks</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-webhook.example.com<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>failurePolicy</span>:<span style=color:#bbb> </span>Fail<span style=color:#bbb>
</span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></code></pre></div>
<p>使用 <code>admissionregistration.k8s.io/v1beta1</code> 创建的准入 Webhook 将
<code>failurePolicy</code> 默认设置为 <code>Ignore</code>。</p>
</div></div>
<h2 id=monitoring-admission-webhooks>监控 Admission Webhook </h2>
<p>API 服务器提供了监视准入 Webhook 行为的方法。这些监视机制可帮助集群管理员
回答以下问题：</p>
<ol>
<li>哪个修改性质的 webhook 改变了 API 请求中的对象？</li>
<li>修改性质的 Webhook 对对象做了哪些更改？</li>
<li>哪些 webhook 经常拒绝 API 请求？是什么原因拒绝？</li>
</ol>
<h3 id=mutating-webhook-审计注解>Mutating Webhook 审计注解</h3>
<p>有时，了解 API 请求中的哪个修改性质的 Webhook 使对象改变以及该
Webhook 应用了哪些更改很有用。</p>
<p>在 v1.16+ 中，kube-apiserver 针对每个修改性质的 Webhook 调用执行
<a href=/zh/docs/tasks/debug-application-cluster/audit/>审计</a>操作。
每个调用都会生成一个审计注解，记述请求对象是否发生改变，
可选地还可以根据 webhook 的准入响应生成一个注解，记述所应用的修补。
针对给定请求的给定执行阶段，注解被添加到审计事件中，
然后根据特定策略进行预处理并写入后端。</p>
<p>事件的审计级别决定了要记录哪些注解：</p>
<p>在 <code>Metadata</code> 或更高审计级别上，将使用 JSON 负载记录带有键名
<code>mutation.webhook.admission.k8s.io/round_{round idx}_index_{order idx}</code> 的注解，
该注解表示针对给定请求调用了 Webhook，以及该 Webhook 是否更改了对象。</p>
<p>例如，对于正在被重新调用的某 Webhook，所记录的注解如下。
Webhook 在 mutating Webhook 链中排在第三个位置，并且在调用期间未改变请求对象。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#080;font-style:italic># 审计事件相关记录</span><span style=color:#bbb>
</span><span style=color:#bbb></span>{<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;kind&#34;: </span><span style=color:#b44>&#34;Event&#34;</span>,<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;apiVersion&#34;: </span><span style=color:#b44>&#34;audit.k8s.io/v1&#34;</span>,<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;annotations&#34;: </span>{<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>&#34;mutation.webhook.admission.k8s.io/round_1_index_2&#34;: &#34;{\&#34;configuration\&#34;:\&#34;my-mutating-webhook-configuration.example.com\&#34;,\&#34;webhook\&#34;:\&#34;my-webhook.example.com\&#34;,\&#34;mutated\&#34;: </span><span style=color:#a2f;font-weight:700>false</span>}&#34;<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># 其他注解</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span>...<span style=color:#bbb>
</span><span style=color:#bbb>    </span>}<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 其他字段</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span>...<span style=color:#bbb>
</span><span style=color:#bbb></span>}<span style=color:#bbb>
</span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#080;font-style:italic># 反序列化的注解值</span><span style=color:#bbb>
</span><span style=color:#bbb></span>{<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;configuration&#34;: </span><span style=color:#b44>&#34;my-mutating-webhook-configuration.example.com&#34;</span>,<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;webhook&#34;: </span><span style=color:#b44>&#34;my-webhook.example.com&#34;</span>,<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;mutated&#34;: </span><span style=color:#a2f;font-weight:700>false</span><span style=color:#bbb>
</span><span style=color:#bbb></span>}<span style=color:#bbb>
</span></code></pre></div>
<p>对于在第一轮中调用的 Webhook，所记录的注解如下。
Webhook 在 mutating Webhook 链中排在第一位，并在调用期间改变了请求对象。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#080;font-style:italic># 审计事件相关记录</span><span style=color:#bbb>
</span><span style=color:#bbb></span>{<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;kind&#34;: </span><span style=color:#b44>&#34;Event&#34;</span>,<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;apiVersion&#34;: </span><span style=color:#b44>&#34;audit.k8s.io/v1&#34;</span>,<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;annotations&#34;: </span>{<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>&#34;mutation.webhook.admission.k8s.io/round_0_index_0&#34;: &#34;{\&#34;configuration\&#34;:\&#34;my-mutating-webhook-configuration.example.com\&#34;,\&#34;webhook\&#34;:\&#34;my-webhook-always-mutate.example.com\&#34;,\&#34;mutated\&#34;: </span><span style=color:#a2f;font-weight:700>true</span>}&#34;<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># 其他注解</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span>...<span style=color:#bbb>
</span><span style=color:#bbb>    </span>}<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 其他字段</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span>...<span style=color:#bbb>
</span><span style=color:#bbb></span>}<span style=color:#bbb>
</span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#080;font-style:italic># 反序列化的注解值</span><span style=color:#bbb>
</span><span style=color:#bbb></span>{<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;configuration&#34;: </span><span style=color:#b44>&#34;my-mutating-webhook-configuration.example.com&#34;</span>,<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;webhook&#34;: </span><span style=color:#b44>&#34;my-webhook-always-mutate.example.com&#34;</span>,<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;mutated&#34;: </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb></span>}<span style=color:#bbb>
</span></code></pre></div>
<p>在 <code>Request</code> 或更高审计级别上，将使用 JSON 负载记录带有键名为
<code>patch.webhook.admission.k8s.io/round_{round idx}_index_{order idx}</code> 的注解，
该注解表明针对给定请求调用了 Webhook 以及应用于请求对象之上的修改。</p>
<p>例如，以下是针对正在被重新调用的某 Webhook 所记录的注解。
Webhook 在修改性质的 Webhook 链中排在第四，并在其响应中包含一个 JSON 补丁，
该补丁已被应用于请求对象。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#080;font-style:italic># 审计事件相关记录</span><span style=color:#bbb>
</span><span style=color:#bbb></span>{<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;kind&#34;: </span><span style=color:#b44>&#34;Event&#34;</span>,<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;apiVersion&#34;: </span><span style=color:#b44>&#34;audit.k8s.io/v1&#34;</span>,<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;annotations&#34;: </span>{<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>&#34;patch.webhook.admission.k8s.io/round_1_index_3&#34;: </span><span style=color:#b44>&#34;{\&#34;configuration\&#34;:\&#34;my-other-mutating-webhook-configuration.example.com\&#34;,\&#34;webhook\&#34;:\&#34;my-webhook-always-mutate.example.com\&#34;,\&#34;patch\&#34;:[{\&#34;op\&#34;:\&#34;add\&#34;,\&#34;path\&#34;:\&#34;/data/mutation-stage\&#34;,\&#34;value\&#34;:\&#34;yes\&#34;}],\&#34;patchType\&#34;:\&#34;JSONPatch\&#34;}&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># 其他注解</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span>...<span style=color:#bbb>
</span><span style=color:#bbb>    </span>}<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 其他字段</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span>...<span style=color:#bbb>
</span><span style=color:#bbb></span>}<span style=color:#bbb>
</span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#080;font-style:italic># 反序列化的注解值</span><span style=color:#bbb>
</span><span style=color:#bbb></span>{<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;configuration&#34;: </span><span style=color:#b44>&#34;my-other-mutating-webhook-configuration.example.com&#34;</span>,<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;webhook&#34;: </span><span style=color:#b44>&#34;my-webhook-always-mutate.example.com&#34;</span>,<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;patchType&#34;: </span><span style=color:#b44>&#34;JSONPatch&#34;</span>,<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;patch&#34;: </span>[<span style=color:#bbb>
</span><span style=color:#bbb>        </span>{<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>&#34;op&#34;: </span><span style=color:#b44>&#34;add&#34;</span>,<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>&#34;path&#34;: </span><span style=color:#b44>&#34;/data/mutation-stage&#34;</span>,<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>&#34;value&#34;: </span><span style=color:#b44>&#34;yes&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span>}<span style=color:#bbb>
</span><span style=color:#bbb>    </span>]<span style=color:#bbb>
</span><span style=color:#bbb></span>}<span style=color:#bbb>
</span></code></pre></div>
<h3 id=准入-webhook-度量值>准入 Webhook 度量值</h3>
<p>Kube-apiserver 从 <code>/metrics</code> 端点公开 Prometheus 指标，这些指标可用于监控和诊断
apiserver 状态。以下指标记录了与准入 Webhook 相关的状态。</p>
<h4 id=apiserver-准入-webhook-拒绝次数>apiserver 准入 Webhook 拒绝次数</h4>
<p>有时，了解哪些准入 Webhook 经常拒绝 API 请求以及拒绝的原因是很有用的。</p>
<p>在 v1.16+ 中，kube-apiserver 提供了 Prometheus 计数器度量值，记录
准入 Webhook 的拒绝次数。
度量值的标签给出了 Webhook 拒绝该请求的原因：</p>
<ul>
<li><code>name</code>：拒绝请求 Webhook 的名称。</li>
<li><code>operation</code>：请求的操作类型可以是 <code>CREATE</code>、<code>UPDATE</code>、<code>DELETE</code> 和 <code>CONNECT</code> 其中之一。</li>
<li><code>type</code>：Admission webhook 类型，可以是 <code>admit</code> 和 <code>validating</code> 其中之一。</li>
<li><code>error_type</code>：标识在 webhook 调用期间是否发生了错误并且导致了拒绝。其值可以是以下之一：
<ul>
<li><code>calling_webhook_error</code>：发生了来自准入 Webhook 的无法识别的错误或超时错误，
并且 webhook 的 <a href=#failure-policy>失败策略</a> 设置为 <code>Fail</code>。</li>
<li><code>no_error</code>：未发生错误。Webhook 在准入响应中以 <code>allowed: false</code> 值拒绝了请求。
度量标签 <code>rejection_code</code> 记录了在准入响应中设置的 <code>.status.code</code>。</li>
<li><code>apiserver_internal_error</code>：apiserver 发生内部错误。</li>
</ul>
</li>
<li><code>rejection_code</code>：当 Webhook 拒绝请求时，在准入响应中设置的 HTTP 状态码。</li>
</ul>
<p>拒绝计数指标示例：</p>
<pre><code># HELP apiserver_admission_webhook_rejection_count [ALPHA] Admission webhook rejection count, identified by name and broken out for each admission type (validating or admit) and operation. Additional labels specify an error type (calling_webhook_error or apiserver_internal_error if an error occurred; no_error otherwise) and optionally a non-zero rejection code if the webhook rejects the request with an HTTP status code (honored by the apiserver when the code is greater or equal to 400). Codes greater than 600 are truncated to 600, to keep the metrics cardinality bounded.
# TYPE apiserver_admission_webhook_rejection_count counter
apiserver_admission_webhook_rejection_count{error_type=&quot;calling_webhook_error&quot;,name=&quot;always-timeout-webhook.example.com&quot;,operation=&quot;CREATE&quot;,rejection_code=&quot;0&quot;,type=&quot;validating&quot;} 1
apiserver_admission_webhook_rejection_count{error_type=&quot;calling_webhook_error&quot;,name=&quot;invalid-admission-response-webhook.example.com&quot;,operation=&quot;CREATE&quot;,rejection_code=&quot;0&quot;,type=&quot;validating&quot;} 1
apiserver_admission_webhook_rejection_count{error_type=&quot;no_error&quot;,name=&quot;deny-unwanted-configmap-data.example.com&quot;,operation=&quot;CREATE&quot;,rejection_code=&quot;400&quot;,type=&quot;validating&quot;} 13
</code></pre>
<h2 id=最佳实践和警告>最佳实践和警告</h2>
<h3 id=idempotence>幂等性 </h3>
<p>幂等的修改性质的准入 Webhook 能够成功处理已经被它接纳甚或修改的对象。
即使多次执行该准入测试，也不会产生与初次执行结果相异的结果。</p>
<h4 id=幂等-mutating-admission-webhook-的示例>幂等 mutating admission Webhook 的示例：</h4>
<ol>
<li>对于 <code>CREATE</code> Pod 请求，将 Pod 的字段 <code>.spec.securityContext.runAsNonRoot</code>
设置为 true，以实施安全最佳实践。</li>
<li>对于 <code>CREATE</code> Pod 请求，如果未设置容器的字段
<code>.spec.containers[].resources.limits</code>，设置默认资源限制值。</li>
<li>对于 <code>CREATE</code> pod 请求，如果 Pod 中不存在名为 <code>foo-sidecar</code> 的边车容器，
向 Pod 注入一个 <code>foo-sidecar</code> 容器。</li>
</ol>
<p>在上述情况下，可以安全地重新调用 Webhook，或接受已经设置了字段的对象。</p>
<h4 id=非幂等-mutating-admission-webhook-的示例>非幂等 mutating admission Webhook 的示例：</h4>
<ol>
<li>对于 <code>CREATE</code> pod 请求，注入名称为 <code>foo-sidecar</code> 并带有当前时间戳的
边车容器（例如 <code>foo-sidecar-19700101-000000</code>）。</li>
<li>对于 <code>CREATE/UPDATE</code> pod 请求，如果容器已设置标签 <code>"env"</code> 则拒绝，
否则将 <code>"env": "prod"</code> 标签添加到容器。</li>
<li>对于 <code>CREATE</code> pod 请求，盲目地添加一个名为 <code>foo-sidecar</code> 的边车容器，
而未查看 Pod 中是否已经有 <code>foo-sidecar</code> 容器。</li>
</ol>
<p>在上述第一种情况下，重新调用该 Webhook 可能导致同一个 Sidecar 容器
多次注入到 Pod 中，而且每次使用不同的容器名称。
类似地，如果 Sidecar 已存在于用户提供的 Pod 中，则 Webhook 可能注入重复的容器。</p>
<p>在上述第二种情况下，重新调用 Webhook 将导致 Webhook 自身输出失败。</p>
<p>在上述第三种情况下，重新调用 Webhook 将导致 Pod 规范中的容器重复，
从而使请求无效并被 API 服务器拒绝。</p>
<h3 id=拦截对象的所有版本>拦截对象的所有版本</h3>
<p>建议通过将 <code>.webhooks[].matchPolicy</code> 设置为 <code>Equivalent</code>，
以确保准入 Webhooks 始终拦截对象的所有版本。
建议准入 Webhooks 应该更偏向注册资源的稳定版本。
如果无法拦截对象的所有版本，可能会导致准入策略未再某些版本的请求上执行。
有关示例，请参见<a href=#matching-requests-matchpolicy>匹配请求：matchPolicy</a>。</p>
<h3 id=availability>可用性 </h3>
<p>建议准入 webhook 尽快完成执行（时长通常是毫秒级），因为它们会增加 API 请求的延迟。
建议对 Webhook 使用较小的超时值。有关更多详细信息，请参见<a href=#timeouts>超时</a>。</p>
<p>建议 Admission Webhook 应该采用某种形式的负载均衡机制，以提供高可用性和高性能。
如果集群中正在运行 Webhook，则可以在服务后面运行多个 Webhook 后端，以利用该服务支持的负载均衡。</p>
<h3 id=确保看到对象的最终状态>确保看到对象的最终状态</h3>
<p>如果某准入 Webhook 需要保证自己能够看到对象的最终状态以实施策略，
则应该使用一个验证性质的 webhook，
因为可以通过 mutating Webhook 看到对象后对其进行修改。</p>
<p>例如，一个修改性质的准入Webhook 被配置为在每个 <code>CREATE</code> Pod 请求中
注入一个名称为 "foo-sidecar" 的 sidecar 容器。</p>
<p>如果<em>必须</em>存在边车容器，则还应配置一个验证性质的准入 Webhook 以拦截
<code>CREATE</code> Pod 请求，并验证要创建的对象中是否存在具有预期配置的名称为
"foo-sidecar" 的容器。</p>
<h3 id=避免自托管的-webhooks-中出现死锁>避免自托管的 Webhooks 中出现死锁</h3>
<p>如果集群内的 Webhook 配置能够拦截启动其自己的 Pod 所需的资源，
则该 Webhook 可能导致其自身部署时发生死锁。</p>
<p>例如，某修改性质的准入 Webhook 配置为仅当 Pod 中设置了某个标签
（例如 <code>"env": "prod"</code>）时，才接受 <code>CREATE</code> Pod 请求。
Webhook 服务器在未设置 <code>"env"</code> 标签的 Deployment 中运行。当运行 Webhook 服务器的
容器的节点运行不正常时，Webhook 部署尝试将容器重新调度到另一个节点。
但是，由于未设置 <code>"env"</code> 标签，因此请求将被现有的 Webhook 服务器拒绝，并且调度迁移不会发生。</p>
<p>建议使用 <a href=#matching-requests-namespaceselector>namespaceSelector</a> 排除
Webhook 所在的名字空间。</p>
<h3 id=side-effects>副作用 </h3>
<p>建议准入 Webhook 应尽可能避免副作用，这意味着该准入 webhook 仅对发送给他们的
<code>AdmissionReview</code> 的内容起作用，并且不要进行额外更改。
如果 Webhook 没有任何副作用，则 <code>.webhooks[].sideEffects</code> 字段应设置为
<code>None</code>。</p>
<p>如果在准入执行期间存在副作用，则应在处理 <code>dryRun</code> 为 <code>true</code> 的 <code>AdmissionReview</code>
对象时避免产生副作用，并且其 <code>.webhooks[].sideEffects</code> 字段应设置为
<code>NoneOnDryRun</code>。更多详细信息，请参见<a href=#side-effects>副作用</a>。</p>
<h3 id=避免对-kube-system-名字空间进行操作>避免对 kube-system 名字空间进行操作</h3>
<p><code>kube-system</code> 名字空间包含由 Kubernetes 系统创建的对象，
例如用于控制平面组件的服务账号，诸如 <code>kube-dns</code> 之类的 Pod 等。
意外更改或拒绝 <code>kube-system</code> 名字空间中的请求可能会导致控制平面组件
停止运行或者导致未知行为发生。
如果你的准入 Webhook 不想修改 Kubernetes 控制平面的行为，请使用
<a href=#matching-requests-namespaceselector><code>namespaceSelector</code></a> 避免
拦截 <code>kube-system</code> 名字空间。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-bea207258f3576b8ec7444a20d498e1d>3.6 - 管理服务账号</h1>
<p>这是一篇针对服务账号的集群管理员指南。你应该熟悉
<a href=/zh/docs/tasks/configure-pod-container/configure-service-account/>配置 Kubernetes 服务账号</a>。</p>
<p>对鉴权和用户账号的支持已在规划中，当前并不完备。
为了更好地描述服务账号，有时这些不完善的特性也会被提及。</p>
<h2 id=user-accounts-versus-service-accounts>用户账号与服务账号 </h2>
<p>Kubernetes 区分用户账号和服务账号的概念，主要基于以下原因：</p>
<ul>
<li>用户账号是针对人而言的。 服务账号是针对运行在 Pod 中的进程而言的。</li>
<li>用户账号是全局性的。其名称跨集群中名字空间唯一的。服务账号是名字空间作用域的。</li>
<li>通常情况下，集群的用户账号可能会从企业数据库进行同步，其创建需要特殊权限，
并且涉及到复杂的业务流程。
服务账号创建有意做得更轻量，允许集群用户为了具体的任务创建服务账号
以遵从权限最小化原则。</li>
<li>对人员和服务账号审计所考虑的因素可能不同。</li>
<li>针对复杂系统的配置包可能包含系统组件相关的各种服务账号的定义。因为服务账号
的创建约束不多并且有名字空间域的名称，这种配置是很轻量的。</li>
</ul>
<h2 id=service-account-automation>服务账号的自动化 </h2>
<p>三个独立组件协作完成服务账号相关的自动化：</p>
<ul>
<li><code>ServiceAccount</code> 准入控制器</li>
<li>Token 控制器</li>
<li><code>ServiceAccount</code> 控制器</li>
</ul>
<h3 id=serviceaccount-admission-controller>ServiceAccount 准入控制器 </h3>
<p>对 Pod 的改动通过一个被称为
<a href=/zh/docs/reference/access-authn-authz/admission-controllers/>准入控制器</a>
的插件来实现。它是 API 服务器的一部分。
当 Pod 被创建或更新时，它会同步地修改 Pod。
如果该插件处于激活状态（在大多数发行版中都是默认激活的），当 Pod 被创建
或更新时它会进行以下操作：</p>
<ol>
<li>如果该 Pod 没有设置 <code>ServiceAccount</code>，将其 <code>ServiceAccount</code> 设为 <code>default</code>。</li>
<li>保证 Pod 所引用的 <code>ServiceAccount</code> 确实存在，否则拒绝该 Pod。</li>
<li>如果服务账号的 <code>automountServiceAccountToken</code> 或 Pod 的
<code>automountServiceAccountToken</code> 都未显式设置为 <code>false</code>，则为 Pod 创建一个
<code>volume</code>，在其中包含用来访问 API 的令牌。</li>
<li>如果前一步中为服务账号令牌创建了卷，则为 Pod 中的每个容器添加一个
<code>volumeSource</code>，挂载在其 <code>/var/run/secrets/kubernetes.io/serviceaccount</code>
目录下。</li>
<li>如果 Pod 不包含 <code>imagePullSecrets</code> 设置，将 <code>ServiceAccount</code> 所引用
的服务账号中的 <code>imagePullSecrets</code> 信息添加到 Pod 中。</li>
</ol>
<h4 id=bound-service-account-token-volume>绑定的服务账号令牌卷 </h4>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.22 [stable]</code>
</div>
<p>ServiceAccount 准入控制器将添加如下投射卷，而不是为令牌控制器
所生成的不过期的服务账号令牌而创建的基于 Secret 的卷。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>kube-api-access-&lt;随机后缀&gt;<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>projected</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>defaultMode</span>:<span style=color:#bbb> </span><span style=color:#666>420</span><span style=color:#bbb> </span><span style=color:#080;font-style:italic># 0644</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>sources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>serviceAccountToken</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>expirationSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>3607</span><span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>token<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>configMap</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>items</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>ca.crt<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>ca.crt<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>kube-root-ca.crt<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>downwardAPI</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>items</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span>- <span style=color:green;font-weight:700>fieldRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>                </span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb>                </span><span style=color:green;font-weight:700>fieldPath</span>:<span style=color:#bbb> </span>metadata.namespace<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>namespace<span style=color:#bbb>
</span></code></pre></div>
<p>此投射卷有三个数据源：</p>
<ol>
<li>通过 TokenRequest API 从 kube-apiserver 处获得的 ServiceAccountToken。
这一令牌默认会在一个小时之后或者 Pod 被删除时过期。
该令牌绑定到 Pod 实例上，并将 kube-apiserver 作为其受众（audience）。</li>
<li>包含用来验证与 kube-apiserver 连接的 CA 证书包的 ConfigMap 对象。
这一特性依赖于 <code>RootCAConfigMap</code> 特性门控。该特性被启用时，
控制面会公开一个名为 <code>kube-root-ca.crt</code> 的 ConfigMap 给所有名字空间。
<code>RootCAConfigMap</code> 在 1.21 版本中进入 GA 状态，默认被启用，
该特性门控会在 1.22 版本中从 <code>--feature-gate</code> 参数中删除。</li>
<li>引用 Pod 名字空间的一个 DownwardAPI。</li>
</ol>
<p>参阅<a href=/zh/docs/tasks/configure-pod-container/configure-projected-volume-storage/>投射卷</a>
了解进一步的细节。</p>
<h3 id=token-controller>Token 控制器 </h3>
<p>TokenController 作为 <code>kube-controller-manager</code> 的一部分运行，以异步的形式工作。
其职责包括：</p>
<ul>
<li>监测 ServiceAccount 的创建并创建相应的服务账号令牌 Secret 以允许访问 API。</li>
<li>监测 ServiceAccount 的删除并删除所有相应的服务账号令牌 Secret。</li>
<li>监测服务账号令牌 Secret 的添加，保证相应的 ServiceAccount 存在，如有需要，
向 Secret 中添加令牌。</li>
<li>监测服务账号令牌 Secret 的删除，如有需要，从相应的 ServiceAccount 中移除引用。</li>
</ul>
<p>你必须通过 <code>--service-account-private-key-file</code> 标志为 <code>kube-controller-manager</code>
的令牌控制器传入一个服务账号私钥文件。该私钥用于为所生成的服务账号令牌签名。
同样地，你需要通过 <code>--service-account-key-file</code> 标志将对应的公钥通知给
kube-apiserver。公钥用于在身份认证过程中校验令牌。</p>
<h4 id=to-create-additional-api-tokens>创建额外的 API 令牌 </h4>
<p>控制器中有专门的循环来保证每个 ServiceAccount 都存在对应的包含 API 令牌的 Secret。
当需要为 ServiceAccount 创建额外的 API 令牌时，可以创建一个类型为
<code>kubernetes.io/service-account-token</code> 的 Secret，并在其注解中引用对应的
ServiceAccount。控制器会生成令牌并更新该 Secret：</p>
<p>下面是这种 Secret 的一个示例配置：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysecretname<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubernetes.io/service-account.name</span>:<span style=color:#bbb> </span>myserviceaccount<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>kubernetes.io/service-account-token<span style=color:#bbb>
</span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create -f ./secret.json
kubectl describe secret mysecretname
</code></pre></div>
<h4 id=删除-废止服务账号令牌-secret>删除/废止服务账号令牌 Secret</h4>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete secret mysecretname
</code></pre></div>
<h3 id=serviceaccount-controller>服务账号控制器 </h3>
<p>服务账号控制器管理各名字空间下的 ServiceAccount 对象，并且保证每个活跃的
名字空间下存在一个名为 "default" 的 ServiceAccount。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-342be69d36f174f762c36f4fe11fcb20>3.7 - 鉴权概述</h1>
<p>了解有关 Kubernetes 鉴权的更多信息，包括使用支持的鉴权模块创建策略的详细信息。</p>
<p>在 Kubernetes 中，你必须在鉴权（授予访问权限）之前进行身份验证（登录），有关身份验证的信息，
请参阅<a href=/zh/docs/concepts/security/controlling-access/>访问控制概述</a>.</p>
<p>Kubernetes 期望请求中存在 REST API 常见的属性。
这意味着 Kubernetes 鉴权适用于现有的组织范围或云提供商范围的访问控制系统，
除了 Kubernetes API 之外，它还可以处理其他 API。</p>
<h2 id=确定是允许还是拒绝请求>确定是允许还是拒绝请求</h2>
<p>Kubernetes 使用 API 服务器对 API 请求进行鉴权。
它根据所有策略评估所有请求属性来决定允许或拒绝请求。
一个 API 请求的所有部分都必须被某些策略允许才能继续。
这意味着默认情况下拒绝权限。</p>
<p>（尽管 Kubernetes 使用 API 服务器，但是依赖于特定对象种类的特定字段的访问控制
和策略由准入控制器处理。）</p>
<p>当系统配置了多个鉴权模块时，Kubernetes 将按顺序使用每个模块。
如果任何鉴权模块批准或拒绝请求，则立即返回该决定，并且不会与其他鉴权模块协商。
如果所有模块对请求没有意见，则拒绝该请求。
被拒绝响应返回 HTTP 状态代码 403。</p>
<h2 id=审查你的请求属性>审查你的请求属性</h2>
<p>Kubernetes 仅审查以下 API 请求属性：</p>
<ul>
<li><strong>用户</strong> - 身份验证期间提供的 <code>user</code> 字符串。</li>
<li><strong>组</strong> - 经过身份验证的用户所属的组名列表。</li>
<li><strong>额外信息</strong> - 由身份验证层提供的任意字符串键到字符串值的映射。</li>
<li><strong>API</strong> - 指示请求是否针对 API 资源。</li>
<li><strong>请求路径</strong> - 各种非资源端点的路径，如 <code>/api</code> 或 <code>/healthz</code>。</li>
<li><strong>API 请求动词</strong> - API 动词 <code>get</code>、<code>list</code>、<code>create</code>、<code>update</code>、<code>patch</code>、<code>watch</code>、
<code>proxy</code>、<code>redirect</code>、<code>delete</code> 和 <code>deletecollection</code> 用于资源请求。
要确定资源 API 端点的请求动词，请参阅
<a href=#determine-the-request-verb>确定请求动词</a>。</li>
<li><strong>HTTP 请求动词</strong> - HTTP 动词 <code>get</code>、<code>post</code>、<code>put</code> 和 <code>delete</code> 用于非资源请求。</li>
<li><strong>Resource</strong> - 正在访问的资源的 ID 或名称（仅限资源请求）-
对于使用 <code>get</code>、<code>update</code>、<code>patch</code> 和 <code>delete</code> 动词的资源请求，你必须提供资源名称。</li>
<li><strong>子资源</strong> - 正在访问的子资源（仅限资源请求）。</li>
<li><strong>名字空间</strong> - 正在访问的对象的名称空间（仅适用于名字空间资源请求）。</li>
<li><strong>API 组</strong> - 正在访问的 <a class=glossary-tooltip title="Kubernetes API 中的一组相关路径" data-toggle=tooltip data-placement=top href=/zh/docs/concepts/overview/kubernetes-api/#api-groups-and-versioning target=_blank aria-label="API 组">API 组</a>
（仅限资源请求）。空字符串表示<a href=/zh/docs/reference/using-api/#api-groups>核心 API 组</a>。</li>
</ul>
<h2 id=determine-the-request-verb>确定请求动词 </h2>
<p><strong>非资源请求</strong></p>
<p>对于 <code>/api/v1/...</code> 或 <code>/apis/&lt;group>/&lt;version>/...</code> 之外的端点的请求被
视为“非资源请求（Non-Resource Requests）”，并使用该请求的 HTTP 方法的
小写形式作为其请求动词。
例如，对 <code>/api</code> 或 <code>/healthz</code> 这类端点的 <code>GET</code> 请求将使用 <code>get</code> 作为其动词。</p>
<p><strong>资源请求</strong></p>
<p>要确定对资源 API 端点的请求动词，需要查看所使用的 HTTP 动词以及该请求是针对
单个资源还是一组资源：</p>
<table>
<thead>
<tr>
<th>HTTP 动词</th>
<th>请求动词</th>
</tr>
</thead>
<tbody>
<tr>
<td>POST</td>
<td>create</td>
</tr>
<tr>
<td>GET, HEAD</td>
<td>get （针对单个资源）、list（针对集合）</td>
</tr>
<tr>
<td>PUT</td>
<td>update</td>
</tr>
<tr>
<td>PATCH</td>
<td>patch</td>
</tr>
<tr>
<td>DELETE</td>
<td>delete（针对单个资源）、deletecollection（针对集合）</td>
</tr>
</tbody>
</table>
<p>Kubernetes 有时使用专门的动词以对额外的权限进行鉴权。例如：</p>
<ul>
<li><a href=/zh/docs/concepts/security/pod-security-policy/>PodSecurityPolicy</a>
<ul>
<li><code>policy</code> API 组中 <code>podsecuritypolicies</code> 资源使用 <code>use</code> 动词</li>
</ul>
</li>
<li><a href=/zh/docs/reference/access-authn-authz/rbac/#privilege-escalation-prevention-and-bootstrapping>RBAC</a>
<ul>
<li>对 <code>rbac.authorization.k8s.io</code> API 组中 <code>roles</code> 和 <code>clusterroles</code> 资源的 <code>bind</code>
和 <code>escalate</code> 动词</li>
</ul>
</li>
<li><a href=/zh/docs/reference/access-authn-authz/authentication/>身份认证</a>
<ul>
<li>对核心 API 组中 <code>users</code>、<code>groups</code> 和 <code>serviceaccounts</code> 以及 <code>authentication.k8s.io</code>
API 组中的 <code>userextras</code> 所使用的 <code>impersonate</code> 动词。</li>
</ul>
</li>
</ul>
<h2 id=authorization-modules>鉴权模块 </h2>
<ul>
<li><strong>Node</strong> - 一个专用鉴权组件，根据调度到 kubelet 上运行的 Pod 为 kubelet 授予权限。
了解有关使用节点鉴权模式的更多信息，请参阅<a href=/zh/docs/reference/access-authn-authz/node/>节点鉴权</a>。</li>
<li><strong>ABAC</strong> - 基于属性的访问控制（ABAC）定义了一种访问控制范型，通过使用将属性组合
在一起的策略，将访问权限授予用户。策略可以使用任何类型的属性（用户属性、资源属性、
对象，环境属性等）。要了解有关使用 ABAC 模式的更多信息，请参阅
<a href=/zh/docs/reference/access-authn-authz/abac/>ABAC 模式</a>。</li>
<li><strong>RBAC</strong> - 基于角色的访问控制（RBAC）是一种基于企业内个人用户的角色来管理对
计算机或网络资源的访问的方法。在此上下文中，权限是单个用户执行特定任务的能力，
例如查看、创建或修改文件。要了解有关使用 RBAC 模式的更多信息，请参阅
<a href=/zh/docs/reference/access-authn-authz/rbac/>RBAC 模式</a>。
<ul>
<li>被启用之后，RBAC（基于角色的访问控制）使用 <code>rbac.authorization.k8s.io</code> API 组来
驱动鉴权决策，从而允许管理员通过 Kubernetes API 动态配置权限策略。</li>
<li>要启用 RBAC，请使用 <code>--authorization-mode = RBAC</code> 启动 API 服务器。</li>
</ul>
</li>
<li><strong>Webhook</strong> - WebHook 是一个 HTTP 回调：发生某些事情时调用的 HTTP POST；
通过 HTTP POST 进行简单的事件通知。实现 WebHook 的 Web 应用程序会在发生某些事情时
将消息发布到 URL。要了解有关使用 Webhook 模式的更多信息，请参阅
<a href=/zh/docs/reference/access-authn-authz/webhook/>Webhook 模式</a>。</li>
</ul>
<h4 id=checking-api-access>检查 API 访问 </h4>
<p><code>kubectl</code> 提供 <code>auth can-i</code> 子命令，用于快速查询 API 鉴权。
该命令使用 <code>SelfSubjectAccessReview</code> API 来确定当前用户是否可以执行给定操作，
无论使用何种鉴权模式该命令都可以工作。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl auth can-i create deployments --namespace dev
</code></pre></div>
<p>输出类似于：</p>
<pre><code>yes
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl auth can-i create deployments --namespace prod
</code></pre></div>
<p>输出类似于：</p>
<pre><code>no
</code></pre>
<p>管理员可以将此与
<a href=/zh/docs/reference/access-authn-authz/authentication/#user-impersonation>用户扮演</a>
结合使用，以确定其他用户可以执行的操作。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl auth can-i list secrets --namespace dev --as dave
</code></pre></div>
<p>输出类似于：</p>
<pre><code>no
</code></pre>
<p>类似地，检查名字空间 <code>dev</code> 里的 <code>dev-sa</code> 服务账号是否可以列举名字空间 <code>target</code> 里的 Pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl auth can-i list pods <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>	--namespace target <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>	--as system:serviceaccount:dev:dev-sa
</code></pre></div>
<p>输出类似于：</p>
<pre><code>yes
</code></pre>
<p><code>SelfSubjectAccessReview</code> 是 <code>authorization.k8s.io</code> API 组的一部分，它将 API
服务器鉴权公开给外部服务。该组中的其他资源包括：</p>
<ul>
<li><code>SubjectAccessReview</code> - 对任意用户的访问进行评估，而不仅仅是当前用户。
当鉴权决策被委派给 API 服务器时很有用。例如，kubelet 和扩展 API 服务器使用
它来确定用户对自己的 API 的访问权限。</li>
<li><code>LocalSubjectAccessReview</code> - 与 <code>SubjectAccessReview</code> 类似，但仅限于特定的
名字空间。</li>
<li><code>SelfSubjectRulesReview</code> - 返回用户可在名字空间内执行的操作集的审阅。
用户可以快速汇总自己的访问权限，或者用于 UI 中的隐藏/显示动作。</li>
</ul>
<p>可以通过创建普通的 Kubernetes 资源来查询这些 API，其中返回对象的响应 "status"
字段是查询的结果。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl create -f - -o yaml <span style=color:#b44>&lt;&lt; EOF
</span><span style=color:#b44>apiVersion: authorization.k8s.io/v1
</span><span style=color:#b44>kind: SelfSubjectAccessReview
</span><span style=color:#b44>spec:
</span><span style=color:#b44>  resourceAttributes:
</span><span style=color:#b44>    group: apps
</span><span style=color:#b44>    name: deployments
</span><span style=color:#b44>    verb: create
</span><span style=color:#b44>    namespace: dev
</span><span style=color:#b44>EOF</span>
</code></pre></div>
<p>生成的 <code>SelfSubjectAccessReview</code> 为：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>authorization.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>SelfSubjectAccessReview<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>creationTimestamp</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>null</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resourceAttributes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>group</span>:<span style=color:#bbb> </span>apps<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>deployments<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>dev<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>verb</span>:<span style=color:#bbb> </span>create<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>allowed</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>denied</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>false</span><span style=color:#bbb>
</span></code></pre></div>
<h2 id=为你的鉴权模块设置参数>为你的鉴权模块设置参数</h2>
<p>你必须在策略中包含一个参数标志，以指明你的策略包含哪个鉴权模块：</p>
<p>可以使用的参数有：</p>
<ul>
<li><code>--authorization-mode=ABAC</code> 基于属性的访问控制（ABAC）模式允许你
使用本地文件配置策略。</li>
<li><code>--authorization-mode=RBAC</code> 基于角色的访问控制（RBAC）模式允许你使用
Kubernetes API 创建和存储策略。</li>
<li><code>--authorization-mode=Webhook</code> WebHook 是一种 HTTP 回调模式，允许你使用远程
REST 端点管理鉴权。</li>
<li><code>--authorization-mode=Node</code> 节点鉴权是一种特殊用途的鉴权模式，专门对
kubelet 发出的 API 请求执行鉴权。</li>
<li><code>--authorization-mode=AlwaysDeny</code> 该标志阻止所有请求。仅将此标志用于测试。</li>
<li><code>--authorization-mode=AlwaysAllow</code> 此标志允许所有请求。仅在你不需要 API 请求
的鉴权时才使用此标志。</li>
</ul>
<p>你可以选择多个鉴权模块。模块按顺序检查，以便较靠前的模块具有更高的优先级来允许
或拒绝请求。</p>
<h2 id=privilege-escalation-via-pod-creation>通过创建或编辑工作负载提升权限</h2>
<p>能够在名字空间中创建或者编辑 Pod 的用户，
无论是直接操作还是通过<a href=/zh/docs/concepts/architecture/controller/>控制器</a>（例如，一个 Operator）来操作，
都可以提升他们在该名字空间内的权限。</p>
<div class="alert alert-warning caution callout" role=alert>
<strong>Caution:</strong>
<p>系统管理员在授予对工作负载的创建或编辑的权限时要小心。
关于这些权限如何被误用的详细信息请参阅
<a href=#escalation-paths>提升途径</a>
</div>
<h3 id=escalation-paths>提升途径</h3>
<ul>
<li>挂载该名字空间内的任意 Secret
<ul>
<li>可以用来访问其他工作负载专用的 Secret</li>
<li>可以用来获取权限更高的服务账号的令牌</li>
</ul>
</li>
<li>使用该名字空间内的任意服务账号
<ul>
<li>可以用另一个工作负载的身份来访问 Kubernetes API（伪装）</li>
<li>可以执行该服务账号的任意特权操作</li>
</ul>
</li>
<li>挂载该名字空间里其他工作负载专用的 ConfigMap
<ul>
<li>可以用来获取其他工作负载专用的信息，例如数据库主机名。</li>
</ul>
</li>
<li>挂载该名字空间里其他工作负载的卷
<ul>
<li>可以用来获取其他工作负载专用的信息，并且更改它。</li>
</ul>
</li>
</ul>
<div class="alert alert-warning caution callout" role=alert>
<strong>Caution:</strong>
<p>系统管理员在部署改变以上部分的 CRD 的时候要小心。
它们可能会打开权限提升的途径。
在决定你的 RBAC 控制时应该考虑这方面的问题。
</div>
<h2 id=what-s-next>What's next</h2>
<ul>
<li>要了解有关身份验证的更多信息，请参阅
<a href=/zh/docs/concepts/security/controlling-access/>控制对 Kubernetes API 的访问</a>
中的 <strong>身份验证</strong> 部分。</li>
<li>要了解有关准入控制的更多信息，请参阅
<a href=/zh/docs/reference/access-authn-authz/admission-controllers/>使用准入控制器</a>。</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-954776b47f2d90515f375623a0ce98e1>3.8 - 使用 RBAC 鉴权</h1>
<p>基于角色（Role）的访问控制（RBAC）是一种基于组织中用户的角色来调节控制对
计算机或网络资源的访问的方法。</p>
<p>RBAC 鉴权机制使用 <code>rbac.authorization.k8s.io</code>
<a class=glossary-tooltip title="Kubernetes API 中的一组相关路径" data-toggle=tooltip data-placement=top href=/zh/docs/concepts/overview/kubernetes-api/#api-groups-and-versioning target=_blank aria-label="API 组">API 组</a>
来驱动鉴权决定，允许你通过 Kubernetes API 动态配置策略。</p>
<p>要启用 RBAC，在启动 <a class=glossary-tooltip title="提供 Kubernetes API 服务的控制面组件。" data-toggle=tooltip data-placement=top href=/zh/docs/reference/command-line-tools-reference/kube-apiserver/ target=_blank aria-label="API 服务器">API 服务器</a>
时将 <code>--authorization-mode</code> 参数设置为一个逗号分隔的列表并确保其中包含 <code>RBAC</code>。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kube-apiserver --authorization-mode<span style=color:#666>=</span>Example,RBAC --&lt;其他选项&gt; --&lt;其他选项&gt;
</code></pre></div>
<h2 id=api-overview>API 对象 </h2>
<p>RBAC API 声明了四种 Kubernetes 对象：<em>Role</em>、<em>ClusterRole</em>、<em>RoleBinding</em> 和
<em>ClusterRoleBinding</em>。你可以像使用其他 Kubernetes 对象一样，
通过类似 <code>kubectl</code> 这类工具
<a href=/zh/docs/concepts/overview/working-with-objects/kubernetes-objects/#understanding-kubernetes-objects>描述对象</a>,
或修补对象。</p>
<div class="alert alert-warning caution callout" role=alert>
<strong>Caution:</strong>
<p>这些对象在设计时即实施了一些访问限制。如果你在学习过程中对集群做了更改，请参考
<a href=#privilege-escalation-prevention-and-bootstrapping>避免特权提升和引导</a>
一节，以了解这些限制会以怎样的方式阻止你做出修改。
</div>
<h3 id=role-and-clusterole>Role 和 ClusterRole </h3>
<p>RBAC 的 <em>Role</em> 或 <em>ClusterRole</em> 中包含一组代表相关权限的规则。
这些权限是纯粹累加的（不存在拒绝某操作的规则）。</p>
<p>Role 总是用来在某个<a class=glossary-tooltip title="名字空间是 Kubernetes 用来支持隔离单个集群中的资源组的一种抽象。" data-toggle=tooltip data-placement=top href=/zh/docs/concepts/overview/working-with-objects/namespaces/ target=_blank aria-label=名字空间>名字空间</a>
内设置访问权限；在你创建 Role 时，你必须指定该 Role 所属的名字空间。</p>
<p>与之相对，ClusterRole 则是一个集群作用域的资源。这两种资源的名字不同（Role 和
ClusterRole）是因为 Kubernetes 对象要么是名字空间作用域的，要么是集群作用域的，
不可两者兼具。</p>
<p>ClusterRole 有若干用法。你可以用它来：</p>
<ol>
<li>定义对某名字空间域对象的访问权限，并将在各个名字空间内完成授权；</li>
<li>为名字空间作用域的对象设置访问权限，并跨所有名字空间执行授权；</li>
<li>为集群作用域的资源定义访问权限。</li>
</ol>
<p>如果你希望在名字空间内定义角色，应该使用 Role；
如果你希望定义集群范围的角色，应该使用 ClusterRole。</p>
<h4 id=role-示例>Role 示例</h4>
<p>下面是一个位于 "default" 名字空间的 Role 的示例，可用来授予对
<a class=glossary-tooltip title="Pod 表示您的集群上一组正在运行的容器。" data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=pods>pods</a> 的读访问权限：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Role<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pod-reader<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;&#34;</span>]<span style=color:#bbb> </span><span style=color:#080;font-style:italic># &#34;&#34; 标明 core API 组</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;pods&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;get&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;watch&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;list&#34;</span>]<span style=color:#bbb>
</span></code></pre></div>
<h3 id=clusterrole-示例>ClusterRole 示例</h3>
<p>ClusterRole 可以和 Role 相同完成授权。
因为 ClusterRole 属于集群范围，所以它也可以为以下资源授予访问权限：</p>
<ul>
<li>
<p>集群范围资源（比如 <a class=glossary-tooltip title="Kubernetes 中的工作机器称作节点。" data-toggle=tooltip data-placement=top href=/zh/docs/concepts/architecture/nodes/ target=_blank aria-label=节点（Node）>节点（Node）</a>）</p>
</li>
<li>
<p>非资源端点（比如 <code>/healthz</code>）</p>
</li>
<li>
<p>跨名字空间访问的名字空间作用域的资源（如 Pods）</p>
<p>比如，你可以使用 ClusterRole 来允许某特定用户执行 <code>kubectl get pods --all-namespaces</code></p>
</li>
</ul>
<p>下面是一个 ClusterRole 的示例，可用来为任一特定名字空间中的
<a class=glossary-tooltip title="Secret 用于存储敏感信息，如密码、 OAuth 令牌和 SSH 密钥。" data-toggle=tooltip data-placement=top href=/zh/docs/concepts/configuration/secret/ target=_blank aria-label=Secret>Secret</a> 授予读访问权限，
或者跨名字空间的访问权限（取决于该角色是如何<a href=#rolebinding-and-clusterrolebinding>绑定</a>的）：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># &#34;namespace&#34; 被忽略，因为 ClusterRoles 不受名字空间限制</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-reader<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 在 HTTP 层面，用来访问 Secret 对象的资源的名称为 &#34;secrets&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;secrets&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;get&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;watch&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;list&#34;</span>]<span style=color:#bbb>
</span></code></pre></div>
<p>Role 或 ClusterRole 对象的名称必须是合法的
<a href=/zh/docs/concepts/overview/working-with-objects/names#path-segment-names>路径区段名称</a>。</p>
<h3 id=rolebinding-and-clusterrolebinding>RoleBinding 和 ClusterRoleBinding </h3>
<p>角色绑定（Role Binding）是将角色中定义的权限赋予一个或者一组用户。
它包含若干 <strong>主体</strong>（用户、组或服务账户）的列表和对这些主体所获得的角色的引用。
RoleBinding 在指定的名字空间中执行授权，而 ClusterRoleBinding 在集群范围执行授权。</p>
<p>一个 RoleBinding 可以引用同一的名字空间中的任何 Role。
或者，一个 RoleBinding 可以引用某 ClusterRole 并将该 ClusterRole 绑定到
RoleBinding 所在的名字空间。
如果你希望将某 ClusterRole 绑定到集群中所有名字空间，你要使用 ClusterRoleBinding。</p>
<p>RoleBinding 或 ClusterRoleBinding 对象的名称必须是合法的
<a href=/zh/docs/concepts/overview/working-with-objects/names#path-segment-names>路径区段名称</a>。</p>
<h4 id=rolebinding-example>RoleBinding 示例 </h4>
<p>下面的例子中的 RoleBinding 将 "pod-reader" Role 授予在 "default" 名字空间中的用户 "jane"。
这样，用户 "jane" 就具有了读取 "default" 名字空间中 pods 的权限。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># 此角色绑定允许 &#34;jane&#34; 读取 &#34;default&#34; 名字空间中的 Pods</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>RoleBinding<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>read-pods<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>subjects</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># 你可以指定不止一个“subject（主体）”</span><span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>User<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>jane<span style=color:#bbb> </span><span style=color:#080;font-style:italic># &#34;name&#34; 是区分大小写的</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>roleRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># &#34;roleRef&#34; 指定与某 Role 或 ClusterRole 的绑定关系</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Role<span style=color:#bbb> </span><span style=color:#080;font-style:italic># 此字段必须是 Role 或 ClusterRole</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pod-reader    <span style=color:#bbb> </span><span style=color:#080;font-style:italic># 此字段必须与你要绑定的 Role 或 ClusterRole 的名称匹配</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span></code></pre></div>
<p>RoleBinding 也可以引用 ClusterRole，以将对应 ClusterRole 中定义的访问权限授予
RoleBinding 所在名字空间的资源。这种引用使得你可以跨整个集群定义一组通用的角色，
之后在多个名字空间中复用。</p>
<p>例如，尽管下面的 RoleBinding 引用的是一个 ClusterRole，"dave"（这里的主体，
区分大小写）只能访问 "development" 名字空间中的 Secrets 对象，因为 RoleBinding
所在的名字空间（由其 metadata 决定）是 "development"。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># 此角色绑定使得用户 &#34;dave&#34; 能够读取 &#34;development&#34; 名字空间中的 Secrets</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># 你需要一个名为 &#34;secret-reader&#34; 的 ClusterRole</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>RoleBinding<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>read-secrets<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># RoleBinding 的名字空间决定了访问权限的授予范围。</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 这里隐含授权仅在 &#34;development&#34; 名字空间内的访问权限。</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>development<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>subjects</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>User<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>dave<span style=color:#bbb> </span><span style=color:#080;font-style:italic># &#39;name&#39; 是区分大小写的</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>roleRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-reader<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span></code></pre></div>
<h4 id=clusterrolebinding-example>ClusterRoleBinding 示例 </h4>
<p>要跨整个集群完成访问权限的授予，你可以使用一个 ClusterRoleBinding。
下面的 ClusterRoleBinding 允许 "manager" 组内的所有用户访问任何名字空间中的
Secrets。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># 此集群角色绑定允许 “manager” 组中的任何人访问任何名字空间中的 secrets</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRoleBinding<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>read-secrets-global<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>subjects</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Group<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>manager<span style=color:#bbb> </span><span style=color:#080;font-style:italic># &#39;name&#39; 是区分大小写的</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>roleRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-reader<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span></code></pre></div>
<p>创建了绑定之后，你不能再修改绑定对象所引用的 Role 或 ClusterRole。
试图改变绑定对象的 <code>roleRef</code> 将导致合法性检查错误。
如果你想要改变现有绑定对象中 <code>roleRef</code> 字段的内容，必须删除重新创建绑定对象。</p>
<p>这种限制有两个主要原因：</p>
<ol>
<li>针对不同角色的绑定是完全不一样的绑定。要求通过删除/重建绑定来更改 <code>roleRef</code>,
这样可以确保要赋予绑定的所有主体会被授予新的角色（而不是在允许或者不小心修改
了 <code>roleRef</code> 的情况下导致所有现有主体未经验证即被授予新角色对应的权限）。</li>
<li>将 <code>roleRef</code> 设置为不可以改变，这使得可以为用户授予对现有绑定对象的 <code>update</code> 权限，
这样可以让他们管理主体列表，同时不能更改被授予这些主体的角色。</li>
</ol>
<p>命令 <code>kubectl auth reconcile</code> 可以创建或者更新包含 RBAC 对象的清单文件，
并且在必要的情况下删除和重新创建绑定对象，以改变所引用的角色。
更多相关信息请参照<a href=#kubectl-auth-reconcile>命令用法和示例</a></p>
<h3 id=referring-to-resources>对资源的引用 </h3>
<p>在 Kubernetes API 中，大多数资源都是使用对象名称的字符串表示来呈现与访问的。
例如，对于 Pod 应使用 "pods"。
RBAC 使用对应 API 端点的 URL 中呈现的名字来引用资源。
有一些 Kubernetes API 涉及 <strong>子资源（subresource）</strong>，例如 Pod 的日志。
对 Pod 日志的请求看起来像这样：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-http data-lang=http><span>GET /api/v1/namespaces/{namespace}/pods/{name}/log
</span></code></pre></div>
<p>在这里，<code>pods</code> 对应名字空间作用域的 Pod 资源，而 <code>log</code> 是 <code>pods</code> 的子资源。
在 RBAC 角色表达子资源时，使用斜线（<code>/</code>）来分隔资源和子资源。
要允许某主体读取 <code>pods</code> 同时访问这些 Pod 的 <code>log</code> 子资源，你可以这么写：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Role<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pod-and-pod-logs-reader<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;pods&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;pods/log&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;get&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;list&#34;</span>]<span style=color:#bbb>
</span></code></pre></div>
<p>对于某些请求，也可以通过 <code>resourceNames</code> 列表按名称引用资源。
在指定时，可以将请求限定为资源的单个实例。
下面的例子中限制可以 "get" 和 "update" 一个名为 <code>my-configmap</code> 的
<a class=glossary-tooltip title="ConfigMap 是一种 API 对象，用来将非机密性的数据保存到键值对中。使用时可以用作环境变量、命令行参数或者存储卷中的配置文件。" data-toggle=tooltip data-placement=top href=/zh/docs/tasks/configure-pod-container/configure-pod-configmap/ target=_blank aria-label=ConfigMap>ConfigMap</a>：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Role<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>configmap-updater<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 在 HTTP 层面，用来访问 ConfigMap 的资源的名称为 &#34;configmaps&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;configmaps&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resourceNames</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;my-configmap&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;update&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;get&#34;</span>]<span style=color:#bbb>
</span></code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>Note:</strong>
<p>你不能使用资源名字来限制 <code>create</code> 或者 <code>deletecollection</code> 请求。
对于 <code>create</code> 请求而言，这是因为在鉴权时可能还不知道新对象的名字。
如果你使用 resourceName 来限制 <code>list</code> 或者 <code>watch</code> 请求，
客户端必须在它们的 <code>list</code> 或者 <code>watch</code> 请求里包含一个与指定的 resourceName 匹配的 <code>metadata.name</code> 字段选择器。
例如，<code>kubectl get configmaps --field-selector=metadata.name=my-configmap</code>
</div>
<h3 id=aggregated-clusterroles>聚合的 ClusterRole </h3>
<p>你可以将若干 ClusterRole <strong>聚合（Aggregate）</strong> 起来，形成一个复合的 ClusterRole。
某个控制器作为集群控制面的一部分会监视带有 <code>aggregationRule</code> 的 ClusterRole
对象集合。<code>aggregationRule</code> 为控制器定义一个标签
<a class=glossary-tooltip title=选择算符允许用户通过标签对一组资源对象进行筛选过滤。 data-toggle=tooltip data-placement=top href=/zh/docs/concepts/overview/working-with-objects/labels/ target=_blank aria-label=选择算符>选择算符</a>供后者匹配
应该组合到当前 ClusterRole 的 <code>roles</code> 字段中的 ClusterRole 对象。</p>
<p>下面是一个聚合 ClusterRole 的示例：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>monitoring<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>aggregationRule</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>clusterRoleSelectors</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>rbac.example.com/aggregate-to-monitoring</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb> </span>[]<span style=color:#bbb> </span><span style=color:#080;font-style:italic># 控制面自动填充这里的规则</span><span style=color:#bbb>
</span></code></pre></div>
<p>如果你创建一个与某个已存在的聚合 ClusterRole 的标签选择算符匹配的 ClusterRole，
这一变化会触发新的规则被添加到聚合 ClusterRole 的操作。
下面的例子中，通过创建一个标签同样为 <code>rbac.example.com/aggregate-to-monitoring: true</code>
的 ClusterRole，新的规则可被添加到 "monitoring" ClusterRole 中。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>monitoring-endpoints<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>rbac.example.com/aggregate-to-monitoring</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># 当你创建 &#34;monitoring-endpoints&#34; ClusterRole 时，</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># 下面的规则会被添加到 &#34;monitoring&#34; ClusterRole 中</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;services&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;endpoints&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;pods&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;get&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;list&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;watch&#34;</span>]<span style=color:#bbb>
</span></code></pre></div>
<p>默认的<a href=#default-roles-and-role-bindings>面向用户的角色</a> 使用 ClusterRole 聚合。
这使得作为集群管理员的你可以为扩展默认规则，包括为定制资源设置规则，
比如通过 CustomResourceDefinitions 或聚合 API 服务器提供的定制资源。</p>
<p>例如，下面的 ClusterRoles 让默认角色 "admin" 和 "edit" 拥有管理自定义资源 "CronTabs" 的权限，
"view" 角色对 CronTab 资源拥有读操作权限。
你可以假定 CronTab 对象在 API 服务器所看到的 URL 中被命名为 <code>"crontabs"</code>。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>aggregate-cron-tabs-edit<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 添加以下权限到默认角色 &#34;admin&#34; 和 &#34;edit&#34; 中</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>rbac.authorization.k8s.io/aggregate-to-admin</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>rbac.authorization.k8s.io/aggregate-to-edit</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;stable.example.com&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;crontabs&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;get&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;list&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;watch&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;create&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;update&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;patch&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;delete&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>aggregate-cron-tabs-view<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 添加以下权限到 &#34;view&#34; 默认角色中</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>rbac.authorization.k8s.io/aggregate-to-view</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;stable.example.com&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;crontabs&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;get&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;list&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;watch&#34;</span>]<span style=color:#bbb>
</span></code></pre></div>
<h4 id=role-examples>Role 示例 </h4>
<p>以下示例均为从 Role 或 ClusterRole 对象中截取出来，我们仅展示其 <code>rules</code> 部分。</p>
<p>允许读取在核心 <a class=glossary-tooltip title="Kubernetes API 中的一组相关路径" data-toggle=tooltip data-placement=top href=/zh/docs/concepts/overview/kubernetes-api/#api-groups-and-versioning target=_blank aria-label="API 组">API 组</a>下的
<code>"Pods"</code>：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 在 HTTP 层面，用来访问 Pod 的资源的名称为 &#34;pods&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;pods&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;get&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;list&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;watch&#34;</span>]<span style=color:#bbb>
</span></code></pre></div>
<p>允许读/写在 <code>"apps"</code> API 组中的 Deployment（在 HTTP 层面，对应
URL 中资源部分为 "deployments"）：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;apps&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;deployments&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;get&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;list&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;watch&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;create&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;update&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;patch&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;delete&#34;</span>]<span style=color:#bbb>
</span></code></pre></div>
<p>允许读取核心 API 组中的 "pods" 和读/写 <code>"batch"</code> API 组中的
"jobs"：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;pods&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;get&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;list&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;watch&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;batch&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;jobs&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;get&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;list&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;watch&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;create&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;update&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;patch&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;delete&#34;</span>]<span style=color:#bbb>
</span></code></pre></div>
<p>允许读取名称为 "my-config" 的 ConfigMap（需要通过 RoleBinding 绑定以
限制为某名字空间中特定的 ConfigMap）：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;configmaps&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resourceNames</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;my-config&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;get&#34;</span>]<span style=color:#bbb>
</span></code></pre></div>
<p>允许读取在核心组中的 "nodes" 资源（因为 <code>Node</code> 是集群作用域的，所以需要
ClusterRole 绑定到 ClusterRoleBinding 才生效）：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;nodes&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;get&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;list&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;watch&#34;</span>]<span style=color:#bbb>
</span></code></pre></div>
<p>允许针对非资源端点 <code>/healthz</code> 和其子路径上发起 GET 和 POST 请求
（必须在 ClusterRole 绑定 ClusterRoleBinding 才生效）：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>nonResourceURLs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;/healthz&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;/healthz/*&#34;</span>]<span style=color:#bbb> </span><span style=color:#080;font-style:italic># nonResourceURL 中的 &#39;*&#39; 是一个全局通配符</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;get&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;post&#34;</span>]<span style=color:#bbb>
</span></code></pre></div>
<h3 id=referring-to-subjects>对主体的引用 </h3>
<p>RoleBinding 或者 ClusterRoleBinding 可绑定角色到某 *主体（Subject）*上。
主体可以是组，用户或者
<a class=glossary-tooltip title="为在 Pod 中运行的进程提供标识。" data-toggle=tooltip data-placement=top href=/zh/docs/tasks/configure-pod-container/configure-service-account/ target=_blank aria-label=服务账户>服务账户</a>。</p>
<p>Kubernetes 用字符串来表示用户名。
用户名可以是普通的用户名，像 "alice"；或者是邮件风格的名称，如 "bob@example.com"，
或者是以字符串形式表达的数字 ID。
你作为 Kubernetes 管理员负责配置
<a href=/zh/docs/reference/access-authn-authz/authentication/>身份认证模块</a>
以便后者能够生成你所期望的格式的用户名。</p>
<div class="alert alert-warning caution callout" role=alert>
<strong>Caution:</strong>
<p>前缀 <code>system:</code> 是 Kubernetes 系统保留的，所以你要确保
所配置的用户名或者组名不能出现上述 <code>system:</code> 前缀。
除了对前缀的限制之外，RBAC 鉴权系统不对用户名格式作任何要求。
</div>
<p>在 Kubernetes 中，鉴权模块提供用户组信息。
与用户名一样，用户组名也用字符串来表示，而且对该字符串没有格式要求，
只是不能使用保留的前缀 <code>system:</code>。</p>
<p><a href=/zh/docs/tasks/configure-pod-container/configure-service-account/>服务账户</a>
的用户名前缀为 <code>system:serviceaccount:</code>，属于前缀为 <code>system:serviceaccounts:</code>
的用户组。</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong>
<ul>
<li><code>system:serviceaccount:</code> （单数）是用于服务账户用户名的前缀；</li>
<li><code>system:serviceaccounts:</code> （复数）是用于服务账户组名的前缀。</li>
</ul>
</div>
<h4 id=role-binding-examples>RoleBinding 示例 </h4>
<p>下面示例是 <code>RoleBinding</code> 中的片段，仅展示其 <code>subjects</code> 的部分。</p>
<p>对于名称为 <code>alice@example.com</code> 的用户：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>subjects</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>User<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;alice@example.com&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span></code></pre></div>
<p>对于名称为 <code>frontend-admins</code> 的用户组：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>subjects</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Group<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;frontend-admins&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span></code></pre></div>
<p>对于 <code>kube-system</code> 名字空间中的默认服务账户：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>subjects</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ServiceAccount<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>kube-system<span style=color:#bbb>
</span></code></pre></div>
<p>对于 "qa" 名称空间中的所有服务账户：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>subjects</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Group<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>system:serviceaccounts:qa<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span></code></pre></div>
<p>对于在任何名字空间中的服务账户：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>subjects</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Group<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>system:serviceaccounts<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span></code></pre></div>
<p>对于所有已经过认证的用户：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>subjects</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Group<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>system:authenticated<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span></code></pre></div>
<p>对于所有未通过认证的用户：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>subjects</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Group<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>system:unauthenticated<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span></code></pre></div>
<p>对于所有用户：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>subjects</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Group<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>system:authenticated<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Group<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>system:unauthenticated<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span></code></pre></div>
<h2 id=默认-roles-和-role-bindings>默认 Roles 和 Role Bindings</h2>
<p>API 服务器创建一组默认的 ClusterRole 和 ClusterRoleBinding 对象。
这其中许多是以 <code>system:</code> 为前缀的，用以标识对应资源是直接由集群控制面管理的。
所有的默认 ClusterRole 和 ClusterRoleBinding 都有
<code>kubernetes.io/bootstrapping=rbac-defaults</code>
标签。</p>
<div class="alert alert-warning caution callout" role=alert>
<strong>Caution:</strong>
<p>在修改名称包含 <code>system:</code> 前缀的 ClusterRole 和 ClusterRoleBinding
时要格外小心。
对这些资源的更改可能导致集群无法继续工作。
</div>
<h3 id=auto-reconciliation>自动协商 </h3>
<p>在每次启动时，API 服务器都会更新默认 ClusterRole 以添加缺失的各种权限，并更新
默认的 ClusterRoleBinding 以增加缺失的各类主体。
这种自动协商机制允许集群去修复一些不小心发生的修改，并且有助于保证角色和角色绑定
在新的发行版本中有权限或主体变更时仍然保持最新。</p>
<p>如果要禁止此功能，请将默认 ClusterRole 以及 ClusterRoleBinding 的
<code>rbac.authorization.kubernetes.io/autoupdate</code> 注解设置成 <code>false</code>。
注意，缺少默认权限和角色绑定主体可能会导致集群无法正常工作。</p>
<p>如果基于 RBAC 的鉴权机制被启用，则自动协商功能默认是被启用的。</p>
<h3 id=discovery-roles>API 发现角色 </h3>
<p>无论是经过身份验证的还是未经过身份验证的用户，默认的角色绑定都授权他们读取被认为
是可安全地公开访问的 API（ 包括 CustomResourceDefinitions）。
如果要禁用匿名的未经过身份验证的用户访问，请在 API 服务器配置中中添加
<code>--anonymous-auth=false</code> 的配置选项。</p>
<p>通过运行命令 <code>kubectl</code> 可以查看这些角色的配置信息:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get clusterroles system:discovery -o yaml
</code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>Note:</strong>
<p>如果你编辑该 ClusterRole，你所作的变更会被 API 服务器在重启时自动覆盖，这是通过
<a href=#auto-reconciliation>自动协商</a>机制完成的。要避免这类覆盖操作，
要么不要手动编辑这些角色，要么禁止自动协商机制。
</div>
<table>
<caption>
Kubernetes RBAC API 发现角色
</caption>
<col width=25%><col width=25%><col>
<thead>
<tr>
<th>默认 ClusterRole</th>
<th>默认 ClusterRoleBinding</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><b>system:basic-user</b></td>
<td><b>system:authenticated</b> 组</td>
<td>
允许用户以只读的方式去访问他们自己的基本信息。在 1.14 版本之前，这个角色在默认情况下也绑定在 <tt>system:unauthenticated</tt> 上。
</td>
</tr>
<tr>
<td><b>system:discovery</b></td>
<td><b>system:authenticated</b> 组</td>
<td>
允许以只读方式访问 API 发现端点，这些端点用来发现和协商 API 级别。
在 1.14 版本之前，这个角色在默认情况下绑定在 <tt>system:unauthenticated</tt> 上。
</td>
</tr>
<tr>
<td><b>system:public-info-viewer</b></td>
<td><b>system:authenticated</b> 和 <b>system:unauthenticated</b> 组</td>
<td>
允许对集群的非敏感信息进行只读访问，它是在 1.14 版本中引入的。
</td>
</tr>
</tbody>
</table>
<h3 id=user-facing-roles>面向用户的角色 </h3>
<p>一些默认的 ClusterRole 不是以前缀 <code>system:</code> 开头的。这些是面向用户的角色。
它们包括超级用户（Super-User）角色（<code>cluster-admin</code>）、
使用 ClusterRoleBinding 在集群范围内完成授权的角色（<code>cluster-status</code>）、
以及使用 RoleBinding 在特定名字空间中授予的角色（<code>admin</code>、<code>edit</code>、<code>view</code>）。</p>
<p>面向用户的 ClusterRole 使用 <a href=#aggregated-clusterroles>ClusterRole 聚合</a>以允许管理员在
这些 ClusterRole 上添加用于定制资源的规则。如果想要添加规则到 <code>admin</code>、<code>edit</code> 或者 <code>view</code>，
可以创建带有以下一个或多个标签的 ClusterRole：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>rbac.authorization.k8s.io/aggregate-to-admin</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>rbac.authorization.k8s.io/aggregate-to-edit</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>rbac.authorization.k8s.io/aggregate-to-view</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span></code></pre></div><table>
<col width=25%><col width=25%><col>
<thead>
<tr>
<th>默认 ClusterRole</th>
<th>默认 ClusterRoleBinding</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><b>cluster-admin</b></td>
<td><b>system:masters</b> 组</td>
<td>
允许超级用户在平台上的任何资源上执行所有操作。
当在 <b>ClusterRoleBinding</b> 中使用时，可以授权对集群中以及所有名字空间中的全部资源进行完全控制。
当在 <b>RoleBinding</b> 中使用时，可以授权控制 RoleBinding 所在名字空间中的所有资源，包括名字空间本身。
</td>
</tr>
<tr>
<td><b>admin</b></td>
<td>无</td>
<td>
允许管理员访问权限，旨在使用 <b>RoleBinding</b> 在名字空间内执行授权。
<p>如果在 <b>RoleBinding</b> 中使用，则可授予对名字空间中的大多数资源的读/写权限，
包括创建角色和角色绑定的能力。
此角色不允许对资源配额或者名字空间本身进行写操作。
此角色也不允许对 Kubernetes v1.22+ 创建的 Endpoints 进行写操作。
更多信息参阅<a href=#write-access-for-endpoints>“Endpoints 写权限”小节</a>。</p>
</td>
</tr>
<tr>
<td><b>edit</b></td>
<td>无</td>
<td>
允许对名字空间的大多数对象进行读/写操作。
<p>它不允许查看或者修改角色或者角色绑定。
不过，此角色可以访问 Secret，以名字空间中任何 ServiceAccount 的身份运行 Pods，
所以可以用来了解名字空间内所有服务账户的 API 访问级别。
此角色也不允许对 Kubernetes v1.22+ 创建的 Endpoints 进行写操作。
更多信息参阅<a href=#write-access-for-endpoints>“Endpoints 写操作”小节</a>。</p>
</td>
</tr>
<tr>
<td><b>view</b></td>
<td>无</td>
<td>
允许对名字空间的大多数对象有只读权限。
它不允许查看角色或角色绑定。
<p>此角色不允许查看 Secrets，因为读取 Secret 的内容意味着可以访问名字空间中
ServiceAccount 的凭据信息，进而允许利用名字空间中任何 ServiceAccount 的
身份访问 API（这是一种特权提升）。</p>
</td>
</tr>
</tbody>
</table>
<h3 id=core-component-roles>核心组件角色 </h3>
<table>
<col width=25%><col width=25%><col>
<thead>
<tr>
<th>默认 ClusterRole</th>
<th>默认 ClusterRoleBinding</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><b>system:kube-scheduler</b></td>
<td><b>system:kube-scheduler</b> 用户</td>
<td>
允许访问 <a class=glossary-tooltip title="控制平面组件，负责监视新创建的、未指定运行节点的 Pod，选择节点让 Pod 在上面运行。" data-toggle=tooltip data-placement=top href=/zh/docs/reference/command-line-tools-reference/kube-scheduler/ target=_blank aria-label=scheduler>scheduler</a>
组件所需要的资源。
</td>
</tr>
<tr>
<td><b>system:volume-scheduler</b></td>
<td><b>system:kube-scheduler</b> 用户</td>
<td>
允许访问 kube-scheduler 组件所需要的卷资源。
</td>
</tr>
<tr>
<td><b>system:kube-controller-manager</b></td>
<td><b>system:kube-controller-manager</b> 用户</td>
<td>
允许访问<a class=glossary-tooltip title=主节点上运行控制器的组件。 data-toggle=tooltip data-placement=top href=/docs/reference/generated/kube-controller-manager/ target=_blank aria-label=控制器管理器>控制器管理器</a>
组件所需要的资源。
各个控制回路所需要的权限在<a href=#controller-roles>控制器角色</a> 详述。
</td>
</tr>
<tr>
<td><b>system:node</b></td>
<td>无</td>
<td>
允许访问 kubelet 所需要的资源，<b>包括对所有 Secret 的读操作和对所有 Pod 状态对象的写操作。</b>
<p>你应该使用 <a href=/zh/docs/reference/access-authn-authz/node/>Node 鉴权组件</a> 和
<a href=/zh/docs/reference/access-authn-authz/admission-controllers/#noderestriction>NodeRestriction 准入插件</a>
而不是 <tt>system:node</tt> 角色。同时基于 kubelet 上调度执行的 Pod 来授权
kubelet 对 API 的访问。</p>
<p><tt>system:node</tt> 角色的意义仅是为了与从 v1.8 之前版本升级而来的集群兼容。</p>
</td>
</tr>
<tr>
<td><b>system:node-proxier</b></td>
<td><b>system:kube-proxy</b> 用户</td>
<td>允许访问 <a class=glossary-tooltip title="kube-proxy 是集群中每个节点上运行的网络代理。" data-toggle=tooltip data-placement=top href=/zh/docs/reference/command-line-tools-reference/kube-proxy/ target=_blank aria-label=kube-proxy>kube-proxy</a>
组件所需要的资源。</td>
</tr>
</tbody>
</table>
<h3 id=other-component-roles>其他组件角色 </h3>
<table>
<col width=25%><col width=25%><col>
<thead>
<tr>
<th>默认 ClusterRole</th>
<th>默认 ClusterRoleBinding</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><b>system:auth-delegator</b></td>
<td>无</td>
<td>
允许将身份认证和鉴权检查操作外包出去。
这种角色通常用在插件式 API 服务器上，以实现统一的身份认证和鉴权。
</td>
</tr>
<tr>
<td><b>system:heapster</b></td>
<td>无</td>
<td>
为 <a href=https://github.com/kubernetes/heapster>Heapster</a> 组件（已弃用）定义的角色。
</td>
</tr>
<tr>
<td><b>system:kube-aggregator</b></td>
<td>无</td>
<td>为 <a href=https://github.com/kubernetes/kube-aggregator>kube-aggregator</a> 组件定义的角色。</td>
</tr>
<tr>
<td><b>system:kube-dns</b></td>
<td>
在 <b>kube-system</b> 名字空间中的 <b>kube-dns</b> 服务账户</td>
<td>为 <a href=/docs/concepts/services-networking/dns-pod-service/>kube-dns</a> 组件定义的角色。
</td>
</tr>
<tr>
<td><b>system:kubelet-api-admin</b></td>
<td>无</td>
<td>
允许 kubelet API 的完全访问权限。
</td>
</tr>
<tr>
<td><b>system:node-bootstrapper</b></td>
<td>无</td>
<td>
允许访问执行
<a href=/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/>kubelet TLS 启动引导</a>
所需要的资源。
</td>
</tr>
<tr>
<td><b>system:node-problem-detector</b></td>
<td>无</td>
<td>
为 <a href=https://github.com/kubernetes/node-problem-detector>node-problem-detector</a> 组件定义的角色。
</td>
</tr>
<tr>
<td><b>system:persistent-volume-provisioner</b></td>
<td>无</td>
<td>
允许访问大部分
<a href=/zh/docs/concepts/storage/persistent-volumes/#dynamic>动态卷驱动
</a>
所需要的资源。</td>
</tr>
<tr>
<td><b>system:monitoring</b></td>
<td><b>system:monitoring</b> 组</td>
<td>
允许对控制平面监控端点的读取访问（例如：<a class=glossary-tooltip title="提供 Kubernetes API 服务的控制面组件。" data-toggle=tooltip data-placement=top href=/zh/docs/reference/command-line-tools-reference/kube-apiserver/ target=_blank aria-label=kube-apiserver>kube-apiserver</a>
存活和就绪端点（<tt>/healthz</tt>、<tt>/livez</tt>、<tt>/readyz</tt>），
各个健康检查端点（<tt>/healthz/*</tt>、<tt>/livez/*</tt>、<tt>/readyz/*</tt>）和 <tt>/metrics</tt>）。
请注意，各个运行状况检查端点和度量标准端点可能会公开敏感信息。
</td>
</tr>
</tbody>
</table>
<h3 id=controller-roles>内置控制器的角色 </h3>
<p>Kubernetes <a class=glossary-tooltip title=主节点上运行控制器的组件。 data-toggle=tooltip data-placement=top href=/docs/reference/generated/kube-controller-manager/ target=_blank aria-label=控制器管理器>控制器管理器</a>
运行内建于 Kubernetes 控制面的<a class=glossary-tooltip title="控制器通过 apiserver 监控集群的公共状态，并致力于将当前状态转变为期望的状态。" data-toggle=tooltip data-placement=top href=/zh/docs/concepts/architecture/controller/ target=_blank aria-label=控制器>控制器</a>。
当使用 <code>--use-service-account-credentials</code> 参数启动时, kube-controller-manager
使用单独的服务账户来启动每个控制器。
每个内置控制器都有相应的、前缀为 <code>system:controller:</code> 的角色。
如果控制管理器启动时未设置 <code>--use-service-account-credentials</code>，
它使用自己的身份凭据来运行所有的控制器，该身份必须被授予所有相关的角色。
这些角色包括:</p>
<ul>
<li><code>system:controller:attachdetach-controller</code></li>
<li><code>system:controller:certificate-controller</code></li>
<li><code>system:controller:clusterrole-aggregation-controller</code></li>
<li><code>system:controller:cronjob-controller</code></li>
<li><code>system:controller:daemon-set-controller</code></li>
<li><code>system:controller:deployment-controller</code></li>
<li><code>system:controller:disruption-controller</code></li>
<li><code>system:controller:endpoint-controller</code></li>
<li><code>system:controller:expand-controller</code></li>
<li><code>system:controller:generic-garbage-collector</code></li>
<li><code>system:controller:horizontal-pod-autoscaler</code></li>
<li><code>system:controller:job-controller</code></li>
<li><code>system:controller:namespace-controller</code></li>
<li><code>system:controller:node-controller</code></li>
<li><code>system:controller:persistent-volume-binder</code></li>
<li><code>system:controller:pod-garbage-collector</code></li>
<li><code>system:controller:pv-protection-controller</code></li>
<li><code>system:controller:pvc-protection-controller</code></li>
<li><code>system:controller:replicaset-controller</code></li>
<li><code>system:controller:replication-controller</code></li>
<li><code>system:controller:resourcequota-controller</code></li>
<li><code>system:controller:root-ca-cert-publisher</code></li>
<li><code>system:controller:route-controller</code></li>
<li><code>system:controller:service-account-controller</code></li>
<li><code>system:controller:service-controller</code></li>
<li><code>system:controller:statefulset-controller</code></li>
<li><code>system:controller:ttl-controller</code></li>
</ul>
<h2 id=初始化与预防权限提升>初始化与预防权限提升</h2>
<p>RBAC API 会阻止用户通过编辑角色或者角色绑定来提升权限。
由于这一点是在 API 级别实现的，所以在 RBAC 鉴权组件未启用的状态下依然可以正常工作。</p>
<h3 id=对角色创建或更新的限制>对角色创建或更新的限制</h3>
<p>只有在符合下列条件之一的情况下，你才能创建/更新角色:</p>
<ol>
<li>你已经拥有角色中包含的所有权限，且其作用域与正被修改的对象作用域相同。
（对 ClusterRole 而言意味着集群范围，对 Role 而言意味着相同名字空间或者集群范围）。</li>
<li>你被显式授权在 <code>rbac.authorization.k8s.io</code> API 组中的 <code>roles</code> 或 <code>clusterroles</code> 资源
使用 <code>escalate</code> 动词。</li>
</ol>
<p>例如，如果 <code>user-1</code> 没有列举集群范围所有 Secret 的权限，他将不能创建包含该权限的 ClusterRole。
若要允许用户创建/更新角色：</p>
<ol>
<li>根据需要赋予他们一个角色，允许他们根据需要创建/更新 Role 或者 ClusterRole 对象。</li>
<li>授予他们在所创建/更新角色中包含特殊权限的权限:
<ul>
<li>隐式地为他们授权（如果它们试图创建或者更改 Role 或 ClusterRole 的权限，
但自身没有被授予相应权限，API 请求将被禁止）。</li>
<li>通过允许他们在 Role 或 ClusterRole 资源上执行 <code>escalate</code> 动作显式完成授权。
这里的 <code>roles</code> 和 <code>clusterroles</code> 资源包含在 <code>rbac.authorization.k8s.io</code> API 组中。</li>
</ul>
</li>
</ol>
<h3 id=对角色绑定创建或更新的限制>对角色绑定创建或更新的限制</h3>
<p>只有你已经具有了所引用的角色中包含的全部权限时，或者你被授权在所引用的角色上执行 <code>bind</code>
动词时，你才可以创建或更新角色绑定。这里的权限与角色绑定的作用域相同。
例如，如果用户 <code>user-1</code> 没有列举集群范围所有 Secret 的能力，则他不可以创建
ClusterRoleBinding 引用授予该许可权限的角色。
如要允许用户创建或更新角色绑定：</p>
<ol>
<li>赋予他们一个角色，使得他们能够根据需要创建或更新 RoleBinding 或 ClusterRoleBinding
对象。</li>
<li>授予他们绑定某特定角色所需要的许可权限：
<ul>
<li>隐式授权下，可以将角色中包含的许可权限授予他们；</li>
<li>显式授权下，可以授权他们在特定 Role （或 ClusterRole）上执行 <code>bind</code> 动词的权限。</li>
</ul>
</li>
</ol>
<p>例如，下面的 ClusterRole 和 RoleBinding 将允许用户 <code>user-1</code> 把名字空间 <code>user-1-namespace</code>
中的 <code>admin</code>、<code>edit</code> 和 <code>view</code> 角色赋予其他用户：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>role-grantor<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;rbac.authorization.k8s.io&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;rolebindings&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;create&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;rbac.authorization.k8s.io&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;clusterroles&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;bind&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 忽略 resourceNames 意味着允许绑定任何 ClusterRole</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resourceNames</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;admin&#34;</span>,<span style=color:#b44>&#34;edit&#34;</span>,<span style=color:#b44>&#34;view&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>RoleBinding<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>role-grantor-binding<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>user-1-namespace<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>roleRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>role-grantor<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>subjects</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>User<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>user-1<span style=color:#bbb>
</span></code></pre></div>
<p>当启动引导第一个角色和角色绑定时，需要为初始用户授予他们尚未拥有的权限。
对初始角色和角色绑定进行初始化时需要：</p>
<ul>
<li>使用用户组为 <code>system:masters</code> 的凭据，该用户组由默认绑定关联到 <code>cluster-admin</code>
这个超级用户角色。</li>
<li>如果你的 API 服务器启动时启用了不安全端口（使用 <code>--insecure-port</code>）, 你也可以通过
该端口调用 API ，这样的操作会绕过身份验证或鉴权。</li>
</ul>
<h2 id=一些命令行工具>一些命令行工具</h2>
<h3 id=kubectl-create-role><code>kubectl create role</code></h3>
<p>创建 Role 对象，定义在某一名字空间中的权限。例如:</p>
<ul>
<li>
<p>创建名称为 "pod-reader" 的 Role 对象，允许用户对 Pods 执行 <code>get</code>、<code>watch</code> 和 <code>list</code> 操作：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create role pod-reader --verb<span style=color:#666>=</span>get --verb<span style=color:#666>=</span>list --verb<span style=color:#666>=</span>watch --resource<span style=color:#666>=</span>pods
</code></pre></div></li>
</ul>
<ul>
<li>
<p>创建名称为 "pod-reader" 的 Role 对象并指定 <code>resourceNames</code>：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create role pod-reader --verb<span style=color:#666>=</span>get --resource<span style=color:#666>=</span>pods --resource-name<span style=color:#666>=</span>readablepod --resource-name<span style=color:#666>=</span>anotherpod
</code></pre></div></li>
</ul>
<ul>
<li>
<p>创建名为 "foo" 的 Role 对象并指定 <code>apiGroups</code>：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create role foo --verb<span style=color:#666>=</span>get,list,watch --resource<span style=color:#666>=</span>replicasets.apps
</code></pre></div></li>
</ul>
<ul>
<li>
<p>创建名为 "foo" 的 Role 对象并指定子资源权限:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create role foo --verb<span style=color:#666>=</span>get,list,watch --resource<span style=color:#666>=</span>pods,pods/status
</code></pre></div></li>
</ul>
<ul>
<li>
<p>创建名为 "my-component-lease-holder" 的 Role 对象，使其具有对特定名称的
资源执行 get/update 的权限：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create role my-component-lease-holder --verb<span style=color:#666>=</span>get,list,watch,update --resource<span style=color:#666>=</span>lease --resource-name<span style=color:#666>=</span>my-component
</code></pre></div></li>
</ul>
<h3 id=kubectl-create-clusterrole><code>kubectl create clusterrole</code></h3>
<p>创建 ClusterRole 对象。例如：</p>
<ul>
<li>
<p>创建名称为 "pod-reader" 的 ClusterRole<code>对象，允许用户对 Pods 对象执行 </code>get<code>、</code>watch<code>和</code>list` 操作：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create clusterrole pod-reader --verb<span style=color:#666>=</span>get,list,watch --resource<span style=color:#666>=</span>pods
</code></pre></div></li>
</ul>
<ul>
<li>
<p>创建名为 "pod-reader" 的 ClusterRole 对象并指定 <code>resourceNames</code>：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create clusterrole pod-reader --verb<span style=color:#666>=</span>get --resource<span style=color:#666>=</span>pods --resource-name<span style=color:#666>=</span>readablepod --resource-name<span style=color:#666>=</span>anotherpod
</code></pre></div></li>
</ul>
<ul>
<li>
<p>创建名为 "foo" 的 ClusterRole 对象并指定 <code>apiGroups</code>：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create clusterrole foo --verb<span style=color:#666>=</span>get,list,watch --resource<span style=color:#666>=</span>replicasets.apps
</code></pre></div></li>
</ul>
<ul>
<li>
<p>创建名为 "foo" 的 ClusterRole 对象并指定子资源:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create clusterrole foo --verb<span style=color:#666>=</span>get,list,watch --resource<span style=color:#666>=</span>pods,pods/status
</code></pre></div></li>
</ul>
<ul>
<li>
<p>创建名为 "foo" 的 ClusterRole 对象并指定 <code>nonResourceURL</code>：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create clusterrole <span style=color:#b44>&#34;foo&#34;</span> --verb<span style=color:#666>=</span>get --non-resource-url<span style=color:#666>=</span>/logs/*
</code></pre></div></li>
</ul>
<ul>
<li>
<p>创建名为 "monitoring" 的 ClusterRole 对象并指定 <code>aggregationRule</code>：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create clusterrole monitoring --aggregation-rule<span style=color:#666>=</span><span style=color:#b44>&#34;rbac.example.com/aggregate-to-monitoring=true&#34;</span>
</code></pre></div></li>
</ul>
<h3 id=kubectl-create-rolebinding><code>kubectl create rolebinding</code></h3>
<p>在特定的名字空间中对 <code>Role</code> 或 <code>ClusterRole</code> 授权。例如：</p>
<ul>
<li>
<p>在名字空间 "acme" 中，将名为 <code>admin</code> 的 ClusterRole 中的权限授予名称 "bob" 的用户:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create rolebinding bob-admin-binding --clusterrole<span style=color:#666>=</span>admin --user<span style=color:#666>=</span>bob --namespace<span style=color:#666>=</span>acme
</code></pre></div></li>
</ul>
<ul>
<li>
<p>在名字空间 "acme" 中，将名为 <code>view</code> 的 ClusterRole 中的权限授予名字空间 "acme"
中名为 <code>myapp</code> 的服务账户：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create rolebinding myapp-view-binding --clusterrole<span style=color:#666>=</span>view --serviceaccount<span style=color:#666>=</span>acme:myapp --namespace<span style=color:#666>=</span>acme
</code></pre></div></li>
</ul>
<ul>
<li>
<p>在名字空间 "acme" 中，将名为 <code>view</code> 的 ClusterRole 对象中的权限授予名字空间
"myappnamespace" 中名称为 <code>myapp</code> 的服务账户：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create rolebinding myappnamespace-myapp-view-binding --clusterrole<span style=color:#666>=</span>view --serviceaccount<span style=color:#666>=</span>myappnamespace:myapp --namespace<span style=color:#666>=</span>acme
</code></pre></div></li>
</ul>
<h3 id=kubectl-create-clusterrolebinding><code>kubectl create clusterrolebinding</code></h3>
<p>在整个集群（所有名字空间）中用 ClusterRole 授权。例如：</p>
<ul>
<li>
<p>在整个集群范围，将名为 <code>cluster-admin</code> 的 ClusterRole 中定义的权限授予名为
"root" 用户：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create clusterrolebinding root-cluster-admin-binding --clusterrole<span style=color:#666>=</span>cluster-admin --user<span style=color:#666>=</span>root
</code></pre></div></li>
</ul>
<ul>
<li>
<p>在整个集群范围内，将名为 <code>system:node-proxier</code> 的 ClusterRole 的权限授予名为
"system:kube-proxy" 的用户：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create clusterrolebinding kube-proxy-binding --clusterrole<span style=color:#666>=</span>system:node-proxier --user<span style=color:#666>=</span>system:kube-proxy
</code></pre></div></li>
</ul>
<ul>
<li>
<p>在整个集群范围内，将名为 <code>view</code> 的 ClusterRole 中定义的权限授予 "acme" 名字空间中
名为 "myapp" 的服务账户：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create clusterrolebinding myapp-view-binding --clusterrole<span style=color:#666>=</span>view --serviceaccount<span style=color:#666>=</span>acme:myapp
</code></pre></div></li>
</ul>
<h3 id=kubectl-auth-reconcile><code>kubectl auth reconcile</code></h3>
<p>使用清单文件来创建或者更新 <code>rbac.authorization.k8s.io/v1</code> API 对象。</p>
<p>尚不存在的对象会被创建，如果对应的名字空间也不存在，必要的话也会被创建。
已经存在的角色会被更新，使之包含输入对象中所给的权限。如果指定了
<code>--remove-extra-permissions</code>，可以删除额外的权限。</p>
<p>已经存在的绑定也会被更新，使之包含输入对象中所给的主体。如果指定了
<code>--remove-extra-permissions</code>，则可以删除多余的主体。</p>
<p>例如:</p>
<ul>
<li>
<p>测试应用 RBAC 对象的清单文件，显示将要进行的更改：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl auth reconcile -f my-rbac-rules.yaml --dry-run
</code></pre></div></li>
</ul>
<ul>
<li>
<p>应用 RBAC 对象的清单文件，保留角色中的额外权限和绑定中的其他主体：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl auth reconcile -f my-rbac-rules.yaml
</code></pre></div></li>
</ul>
<ul>
<li>
<p>应用 RBAC 对象的清单文件, 删除角色中的额外权限和绑定中的其他主体：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl auth reconcile -f my-rbac-rules.yaml --remove-extra-subjects --remove-extra-permissions
</code></pre></div></li>
</ul>
<p>查看 CLI 帮助获取详细的用法。</p>
<h2 id=service-account-permissions>服务账户权限 </h2>
<p>默认的 RBAC 策略为控制面组件、节点和控制器授予权限。
但是不会对 <code>kube-system</code> 名字空间之外的服务账户授予权限。
（除了授予所有已认证用户的发现权限）</p>
<p>这使得你可以根据需要向特定服务账户授予特定权限。
细粒度的角色绑定可带来更好的安全性，但需要更多精力管理。
粗粒度的授权可能导致服务账户被授予不必要的 API 访问权限（甚至导致潜在的权限提升），
但更易于管理。</p>
<p>按从最安全到最不安全的顺序，存在以下方法：</p>
<ol>
<li>
<p>为特定应用的服务账户授予角色（最佳实践）</p>
<p>这要求应用在其 Pod 规约中指定 <code>serviceAccountName</code>，
并额外创建服务账户（包括通过 API、应用程序清单、<code>kubectl create serviceaccount</code> 等）。</p>
<p>例如，在名字空间 "my-namespace" 中授予服务账户 "my-sa" 只读权限：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create rolebinding my-sa-view <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --clusterrole<span style=color:#666>=</span>view <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --serviceaccount<span style=color:#666>=</span>my-namespace:my-sa <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --namespace<span style=color:#666>=</span>my-namespace
</code></pre></div></li>
</ol>
<ol start=2>
<li>
<p>将角色授予某名字空间中的 "default" 服务账户</p>
<p>如果某应用没有指定 <code>serviceAccountName</code>，那么它将使用 "default" 服务账户。</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> "default" 服务账户所具有的权限会被授予给名字空间中所有未指定
<code>serviceAccountName</code> 的 Pod。
</div>
<p>例如，在名字空间 "my-namespace" 中授予服务账户 "default" 只读权限：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create rolebinding default-view <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --clusterrole<span style=color:#666>=</span>view <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --serviceaccount<span style=color:#666>=</span>my-namespace:default <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --namespace<span style=color:#666>=</span>my-namespace
</code></pre></div>
<p>许多<a href=/zh/docs/concepts/cluster-administration/addons/>插件组件</a> 在 <code>kube-system</code>
名字空间以 "default" 服务账户运行。
要允许这些插件组件以超级用户权限运行，需要将集群的 <code>cluster-admin</code> 权限授予
<code>kube-system</code> 名字空间中的 "default" 服务账户。</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 启用这一配置意味着在 <code>kube-system</code> 名字空间中包含以超级用户账号来访问 API
的 Secrets。
</div>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create clusterrolebinding add-on-cluster-admin <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --clusterrole<span style=color:#666>=</span>cluster-admin <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --serviceaccount<span style=color:#666>=</span>kube-system:default
</code></pre></div></li>
</ol>
<ol start=3>
<li>
<p>将角色授予名字空间中所有服务账户</p>
<p>如果你想要名字空间中所有应用都具有某角色，无论它们使用的什么服务账户，
可以将角色授予该名字空间的服务账户组。</p>
<p>例如，在名字空间 "my-namespace" 中的只读权限授予该名字空间中的所有服务账户：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create rolebinding serviceaccounts-view <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --clusterrole<span style=color:#666>=</span>view <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --group<span style=color:#666>=</span>system:serviceaccounts:my-namespace <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --namespace<span style=color:#666>=</span>my-namespace
</code></pre></div></li>
</ol>
<ol start=4>
<li>
<p>在集群范围内为所有服务账户授予一个受限角色（不鼓励）</p>
<p>如果你不想管理每一个名字空间的权限，你可以向所有的服务账户授予集群范围的角色。</p>
<p>例如，为集群范围的所有服务账户授予跨所有名字空间的只读权限：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create clusterrolebinding serviceaccounts-view <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --clusterrole<span style=color:#666>=</span>view <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --group<span style=color:#666>=</span>system:serviceaccounts
</code></pre></div></li>
</ol>
<ol start=5>
<li>
<p>授予超级用户访问权限给集群范围内的所有服务帐户（强烈不鼓励）</p>
<p>如果你不关心如何区分权限，你可以将超级用户访问权限授予所有服务账户。</p>
<div class="alert alert-danger warning callout" role=alert>
<strong>Warning:</strong> 这样做会允许所有应用都对你的集群拥有完全的访问权限，并将允许所有能够读取
Secret（或创建 Pod）的用户对你的集群有完全的访问权限。
</div>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create clusterrolebinding serviceaccounts-cluster-admin <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --clusterrole<span style=color:#666>=</span>cluster-admin <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --group<span style=color:#666>=</span>system:serviceaccounts
</code></pre></div></li>
</ol>
<h2 id=write-access-for-endpoints>Endpoints 写权限</h2>
<p>在 Kubernetes v1.22 之前版本创建的集群里，
"edit" 和 "admin" 聚合角色包含对 Endpoints 的写权限。
作为 <a href=https://github.com/kubernetes/kubernetes/issues/103675>CVE-2021-25740</a> 的缓解措施，
此访问权限不包含在 Kubernetes 1.22 以及更高版本集群的聚合角色里。</p>
<p>升级到 Kubernetes v1.22 版本的现有集群不会包括此变化。
<a href=https://github.com/kubernetes/kubernetes/issues/103675>CVE 公告</a>
包含了在现有集群里限制此访问权限的指引。</p>
<p>如果你希望在新集群的聚合角色里保留此访问权限，你可以创建下面的 ClusterRole：</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/zh/examples/access/endpoints-aggregated.yaml download=access/endpoints-aggregated.yaml><code>access/endpoints-aggregated.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('access-endpoints-aggregated-yaml')" title="Copy access/endpoints-aggregated.yaml to clipboard">
</img>
</div>
<div class=includecode id=access-endpoints-aggregated-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubernetes.io/description</span>:<span style=color:#bbb> </span>|-<span style=color:#b44;font-style:italic>
</span><span style=color:#b44;font-style:italic>      Add endpoints write permissions to the edit and admin roles. This was
</span><span style=color:#b44;font-style:italic>      removed by default in 1.22 because of CVE-2021-25740. See
</span><span style=color:#b44;font-style:italic>      https://issue.k8s.io/103675. This can allow writers to direct LoadBalancer
</span><span style=color:#b44;font-style:italic>      or Ingress implementations to expose backend IPs that would not otherwise
</span><span style=color:#b44;font-style:italic>      be accessible, and can circumvent network policies or security controls
</span><span style=color:#b44;font-style:italic>      intended to prevent/isolate access to those backends.</span><span style=color:#bbb>      
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>rbac.authorization.k8s.io/aggregate-to-edit</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>custom:aggregate-to-edit:endpoints<span style=color:#bbb> </span><span style=color:#080;font-style:italic># you can change this if you wish</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;endpoints&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;create&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;delete&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;deletecollection&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;patch&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;update&#34;</span>]<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<h2 id=从-abac-升级>从 ABAC 升级</h2>
<p>原来运行较老版本 Kubernetes 的集群通常会使用限制宽松的 ABAC 策略，
包括授予所有服务帐户全权访问 API 的能力。</p>
<p>默认的 RBAC 策略为控制面组件、节点和控制器等授予有限的权限，但不会为
<code>kube-system</code> 名字空间外的服务账户授权
（除了授予所有认证用户的发现权限之外）。</p>
<p>这样做虽然安全得多，但可能会干扰期望自动获得 API 权限的现有工作负载。
这里有两种方法来完成这种转换:</p>
<h3 id=parallel-authorizers>并行鉴权 </h3>
<p>同时运行 RBAC 和 ABAC 鉴权模式, 并指定包含
<a href=/zh/docs/reference/access-authn-authz/abac/#policy-file-format>现有的 ABAC 策略</a>
的策略文件：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>--authorization-mode<span style=color:#666>=</span>RBAC,ABAC --authorization-policy-file<span style=color:#666>=</span>mypolicy.json
</code></pre></div>
<p>关于命令行中的第一个选项：如果早期的鉴权组件，例如 Node，拒绝了某个请求，则
RBAC 鉴权组件尝试对该 API 请求鉴权。如果 RBAC 也拒绝了该 API 请求，则运行 ABAC
鉴权组件。这意味着被 RBAC 或 ABAC 策略所允许的任何请求都是被允许的请求。</p>
<p>如果 API 服务器启动时，RBAC 组件的日志级别为 5 或更高（<code>--vmodule=rbac*=5</code> 或 <code>--v=5</code>），
你可以在 API 服务器的日志中看到 RBAC 的细节 （前缀 <code>RBAC:</code>）
你可以使用这些信息来确定需要将哪些角色授予哪些用户、组或服务帐户。</p>
<p>一旦你<a href=#service-account-permissions>将角色授予服务账户</a> ，工作负载运行时
在服务器日志中没有出现 RBAC 拒绝消息，就可以删除 ABAC 鉴权器。</p>
<h3 id=permissive-rbac-permissions>宽松的 RBAC 权限 </h3>
<p>你可以使用 RBAC 角色绑定在多个场合使用宽松的策略。</p>
<div class="alert alert-danger warning callout" role=alert>
<strong>Warning:</strong>
<p>下面的策略允许 <strong>所有</strong> 服务帐户充当集群管理员。
容器中运行的所有应用程序都会自动收到服务帐户的凭据，可以对 API 执行任何操作，
包括查看 Secrets 和修改权限。这一策略是不被推荐的。
</div>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create clusterrolebinding permissive-binding <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --clusterrole<span style=color:#666>=</span>cluster-admin <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --user<span style=color:#666>=</span>admin <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --user<span style=color:#666>=</span>kubelet <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --group<span style=color:#666>=</span>system:serviceaccounts
</code></pre></div>
<p>在你完成到 RBAC 的迁移后，应该调整集群的访问控制，确保相关的策略满足你的信息安全需求。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-9cbb97d4d9f08d67931a1baae4e6519c>3.9 - 使用 Node 鉴权</h1>
<p>节点鉴权是一种特殊用途的鉴权模式，专门对 kubelet 发出的 API 请求进行鉴权。</p>
<h2 id=概述>概述</h2>
<p>节点鉴权器允许 kubelet 执行 API 操作。包括：</p>
<p>读取操作：</p>
<ul>
<li>services</li>
<li>endpoints</li>
<li>nodes</li>
<li>pods</li>
<li>secrets、configmaps、pvcs 以及绑定到 kubelet 节点的与 pod 相关的持久卷</li>
</ul>
<p>写入操作：</p>
<ul>
<li>节点和节点状态（启用 <code>NodeRestriction</code> 准入插件以限制 kubelet 只能修改自己的节点）</li>
<li>Pod 和 Pod 状态 (启用 <code>NodeRestriction</code> 准入插件以限制 kubelet 只能修改绑定到自身的 Pod)</li>
<li>事件</li>
</ul>
<p>鉴权相关操作：</p>
<ul>
<li>对于基于 TLS 的启动引导过程时使用的
<a href=/zh/docs/reference/access-authn-authz/certificate-signing-requests/>certificationsigningrequests API</a>
的读/写权限</li>
<li>为委派的身份验证/授权检查创建 TokenReview 和 SubjectAccessReview 的能力</li>
</ul>
<p>在将来的版本中，节点鉴权器可能会添加或删除权限，以确保 kubelet 具有正确操作所需的最小权限集。</p>
<p>为了获得节点鉴权器的授权，kubelet 必须使用一个凭证以表示它在 <code>system:nodes</code> 组中，用户名为 <code>system:node:&lt;nodeName></code>。
上述的组名和用户名格式要与 <a href=/zh/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/>kubelet TLS 启动引导</a>过程中为每个 kubelet 创建的标识相匹配。</p>
<p>要启用节点授权器，请使用 <code>--authorization-mode = Node</code> 启动 apiserver。</p>
<p>要限制 kubelet 具有写入权限的 API 对象，请使用 <code>--enable-admission-plugins=...,NodeRestriction,...</code> 启动 apiserver，从而启用 <a href=/zh/docs/reference/access-authn-authz/admission-controllers#NodeRestriction>NodeRestriction</a> 准入插件。</p>
<h2 id=迁移考虑因素>迁移考虑因素</h2>
<h3 id=在-system-nodes-组之外的-kubelet>在 <code>system:nodes</code> 组之外的 Kubelet</h3>
<p><code>system:nodes</code> 组之外的 kubelet 不会被 <code>Node</code> 鉴权模式授权，并且需要继续通过当前授权它们的机制来授权。
节点准入插件不会限制来自这些 kubelet 的请求。</p>
<h3 id=具有无差别用户名的-kubelet>具有无差别用户名的 Kubelet</h3>
<p>在一些部署中，kubelet 具有 <code>system:nodes</code> 组的凭证，但是无法给出它们所关联的节点的标识，因为它们没有 <code>system:node:...</code> 格式的用户名。
这些 kubelet 不会被 <code>Node</code> 授权模式授权，并且需要继续通过当前授权它们的任何机制来授权。</p>
<p>因为默认的节点标识符实现不会把它当作节点身份标识，<code>NodeRestriction</code> 准入插件会忽略来自这些 kubelet 的请求。</p>
<h3 id=相对于以前使用-rbac-的版本的更新>相对于以前使用 RBAC 的版本的更新</h3>
<p>升级的 1.7 之前的使用 <a href=/zh/docs/reference/access-authn-authz/rbac/>RBAC</a> 的集群将继续按原样运行，因为 <code>system:nodes</code> 组绑定已经存在。</p>
<p>如果集群管理员希望开始使用 <code>Node</code> 鉴权器和 <code>NodeRestriction</code> 准入插件来限制节点对 API 的访问，这一需求可以通过下列操作来完成且不会影响已部署的应用：</p>
<ol>
<li>启用 <code>Node</code> 鉴权模式 (<code>--authorization-mode=Node,RBAC</code>) 和 <code>NodeRestriction</code> 准入插件</li>
<li>确保所有 kubelet 的凭据符合组/用户名要求</li>
<li>审核 apiserver 日志以确保 <code>Node</code> 鉴权器不会拒绝来自 kubelet 的请求（日志中没有持续的 <code>NODE DENY</code> 消息）</li>
<li>删除 <code>system:node</code> 集群角色绑定</li>
</ol>
<h3 id=rbac-节点权限>RBAC 节点权限</h3>
<p>在 1.6 版本中，当使用 <a href=/zh/docs/reference/access-authn-authz/rbac/>RBAC 鉴权模式</a> 时，<code>system:nodes</code> 集群角色会被自动绑定到 <code>system:node</code> 组。</p>
<p>在 1.7 版本中，不再推荐将 <code>system:nodes</code> 组自动绑定到 <code>system:node</code> 角色，因为节点鉴权器通过对 secret 和 configmap 访问的额外限制完成了相同的任务。
如果同时启用了 <code>Node</code> 和 <code>RBAC</code> 授权模式，1.7 版本则不会创建 <code>system:nodes</code> 组到 <code>system:node</code> 角色的自动绑定。</p>
<p>在 1.8 版本中，绑定将根本不会被创建。</p>
<p>使用 RBAC 时，将继续创建 <code>system:node</code> 集群角色，以便与将其他用户或组绑定到该角色的部署方法兼容。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-215c25173044b8f97e9b0494b0c7e53f>3.10 - Webhook 模式</h1>
<p>WebHook 是一种 HTTP 回调：某些条件下触发的 HTTP POST 请求；通过 HTTP POST 发送的简单事件通知。一个基于 web 应用实现的 WebHook 会在特定事件发生时把消息发送给特定的 URL。</p>
<p>具体来说，当在判断用户权限时，<code>Webhook</code> 模式会使 Kubernetes 查询外部的 REST 服务。</p>
<h2 id=配置文件格式>配置文件格式</h2>
<p><code>Webhook</code> 模式需要一个 HTTP 配置文件，通过 <code>--authorization-webhook-config-file=SOME_FILENAME</code> 的参数声明。</p>
<p>配置文件的格式使用 <a href=/zh/docs/tasks/access-application-cluster/configure-access-multiple-clusters/>kubeconfig</a>。在文件中，"users" 代表着 API 服务器的 webhook，而 "cluster" 代表着远程服务。</p>
<p>使用 HTTPS 客户端认证的配置例子：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#080;font-style:italic># Kubernetes API 版本</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># API 对象种类</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Config<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># clusters 代表远程服务。</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>clusters</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>name-of-remote-authz-service<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>cluster</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 对远程服务进行身份认证的 CA。</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>certificate-authority</span>:<span style=color:#bbb> </span>/path/to/ca.pem<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 远程服务的查询 URL。必须使用 &#39;https&#39;。</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>server</span>:<span style=color:#bbb> </span>https://authz.example.com/authorize<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># users 代表 API 服务器的 webhook 配置</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>users</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>name-of-api-server<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>user</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>client-certificate</span>:<span style=color:#bbb> </span>/path/to/cert.pem<span style=color:#bbb> </span><span style=color:#080;font-style:italic># webhook plugin 使用 cert</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>client-key</span>:<span style=color:#bbb> </span>/path/to/key.pem         <span style=color:#bbb> </span><span style=color:#080;font-style:italic># cert 所对应的 key</span><span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># kubeconfig 文件必须有 context。需要提供一个给 API 服务器。</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>current-context</span>:<span style=color:#bbb> </span>webhook<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>contexts</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>context</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>cluster</span>:<span style=color:#bbb> </span>name-of-remote-authz-service<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>user</span>:<span style=color:#bbb> </span>name-of-api-server<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>webhook<span style=color:#bbb>
</span></code></pre></div>
<h2 id=请求载荷>请求载荷</h2>
<p>在做认证决策时，API 服务器会 POST 一个 JSON 序列化的 <code>authorization.k8s.io/v1beta1</code> <code>SubjectAccessReview</code> 对象来描述这个动作。这个对象包含了描述用户请求的字段，同时也包含了需要被访问资源或请求特征的具体信息。</p>
<p>需要注意的是 webhook API 对象与其他 Kubernetes API 对象一样都同样都服从<a href=/zh/docs/concepts/overview/kubernetes-api/>版本兼容规则</a>。实施人员应该了解 beta 对象的更宽松的兼容性承诺，同时确认请求的 "apiVersion" 字段能被正确地反序列化。此外，API 服务器还必须启用 <code>authorization.k8s.io/v1beta1</code> API 扩展组 (<code>--runtime-config=authorization.k8s.io/v1beta1=true</code>)。</p>
<p>一个请求内容的例子：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
  <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;authorization.k8s.io/v1beta1&#34;</span>,
  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;SubjectAccessReview&#34;</span>,
  <span style=color:green;font-weight:700>&#34;spec&#34;</span>: {
    <span style=color:green;font-weight:700>&#34;resourceAttributes&#34;</span>: {
      <span style=color:green;font-weight:700>&#34;namespace&#34;</span>: <span style=color:#b44>&#34;kittensandponies&#34;</span>,
      <span style=color:green;font-weight:700>&#34;verb&#34;</span>: <span style=color:#b44>&#34;get&#34;</span>,
      <span style=color:green;font-weight:700>&#34;group&#34;</span>: <span style=color:#b44>&#34;unicorn.example.org&#34;</span>,
      <span style=color:green;font-weight:700>&#34;resource&#34;</span>: <span style=color:#b44>&#34;pods&#34;</span>
    },
    <span style=color:green;font-weight:700>&#34;user&#34;</span>: <span style=color:#b44>&#34;jane&#34;</span>,
    <span style=color:green;font-weight:700>&#34;group&#34;</span>: [
      <span style=color:#b44>&#34;group1&#34;</span>,
      <span style=color:#b44>&#34;group2&#34;</span>
    ]
  }
}
</code></pre></div>
<p>期待远程服务填充请求的 <code>status</code> 字段并响应允许或禁止访问。响应主体的 <code>spec</code> 字段被忽略，可以省略。允许的响应将返回:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
  <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;authorization.k8s.io/v1beta1&#34;</span>,
  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;SubjectAccessReview&#34;</span>,
  <span style=color:green;font-weight:700>&#34;status&#34;</span>: {
    <span style=color:green;font-weight:700>&#34;allowed&#34;</span>: <span style=color:#a2f;font-weight:700>true</span>
  }
}
</code></pre></div>
<p>为了禁止访问，有两种方法。</p>
<p>在大多数情况下，第一种方法是首选方法，它指示授权 webhook 不允许或对请求"无意见"，但是，如果配置了其他授权者，则可以给他们机会允许请求。如果没有其他授权者，或者没有一个授权者，则该请求被禁止。webhook 将返回:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
  <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;authorization.k8s.io/v1beta1&#34;</span>,
  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;SubjectAccessReview&#34;</span>,
  <span style=color:green;font-weight:700>&#34;status&#34;</span>: {
    <span style=color:green;font-weight:700>&#34;allowed&#34;</span>: <span style=color:#a2f;font-weight:700>false</span>,
    <span style=color:green;font-weight:700>&#34;reason&#34;</span>: <span style=color:#b44>&#34;user does not have read access to the namespace&#34;</span>
  }
}
</code></pre></div>
<p>第二种方法立即拒绝其他配置的授权者进行短路评估。仅应由对集群的完整授权者配置有详细了解的 webhook 使用。webhook 将返回:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
  <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;authorization.k8s.io/v1beta1&#34;</span>,
  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;SubjectAccessReview&#34;</span>,
  <span style=color:green;font-weight:700>&#34;status&#34;</span>: {
    <span style=color:green;font-weight:700>&#34;allowed&#34;</span>: <span style=color:#a2f;font-weight:700>false</span>,
    <span style=color:green;font-weight:700>&#34;denied&#34;</span>: <span style=color:#a2f;font-weight:700>true</span>,
    <span style=color:green;font-weight:700>&#34;reason&#34;</span>: <span style=color:#b44>&#34;user does not have read access to the namespace&#34;</span>
  }
}
</code></pre></div>
<p>对于非资源的路径访问是这么发送的:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
  <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;authorization.k8s.io/v1beta1&#34;</span>,
  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;SubjectAccessReview&#34;</span>,
  <span style=color:green;font-weight:700>&#34;spec&#34;</span>: {
    <span style=color:green;font-weight:700>&#34;nonResourceAttributes&#34;</span>: {
      <span style=color:green;font-weight:700>&#34;path&#34;</span>: <span style=color:#b44>&#34;/debug&#34;</span>,
      <span style=color:green;font-weight:700>&#34;verb&#34;</span>: <span style=color:#b44>&#34;get&#34;</span>
    },
    <span style=color:green;font-weight:700>&#34;user&#34;</span>: <span style=color:#b44>&#34;jane&#34;</span>,
    <span style=color:green;font-weight:700>&#34;group&#34;</span>: [
      <span style=color:#b44>&#34;group1&#34;</span>,
      <span style=color:#b44>&#34;group2&#34;</span>
    ]
  }
}
</code></pre></div>
<p>非资源类的路径包括：<code>/api</code>, <code>/apis</code>, <code>/metrics</code>, <code>/resetMetrics</code>,
<code>/logs</code>, <code>/debug</code>, <code>/healthz</code>, <code>/swagger-ui/</code>, <code>/swaggerapi/</code>, <code>/ui</code>, 和
<code>/version</code>。客户端需要访问 <code>/api</code>, <code>/api/*</code>, <code>/apis</code>, <code>/apis/*</code>, 和 <code>/version</code> 以便
能发现服务器上有什么资源和版本。对于其他非资源类的路径访问在没有 REST API 访问限制的情况下拒绝。</p>
<p>更多信息可以参考 authorization.v1beta1 API 对象和 <a href=https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/apiserver/plugin/pkg/authorizer/webhook/webhook.go>webhook.go</a>。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-643e4cec52a8577e9454649bdaac84d0>3.11 - 从 PodSecurityPolicy 映射到 Pod 安全性标准</h1>
<p>下面的表格列举了<a href=/zh/docs/concepts/policy/pod-security-policy/>PodSecurityPolicy</a>
对象上的配置参数，这些字段是否会变更或检查 Pod 配置，以及这些配置值如何映射到
<a href=/zh/docs/concepts/security/pod-security-standards/>Pod 安全性标准（Pod Security Standards）</a>
之上。</p>
<p>对于每个可应用的参数，表格中给出了
<a href=/zh/docs/concepts/security/pod-security-standards/#baseline>Baseline</a> 和
<a href=/zh/docs/concepts/security/pod-security-standards/#restricted>Restricted</a>
配置下可接受的取值。
对这两种配置而言不可接受的取值均归入
<a href=/zh/docs/concepts/security/pod-security-standards/#priveleged>Privileged</a>
配置下。“无意见”意味着对所有 Pod 安全性标准而言所有取值都可接受。</p>
<p>如果想要了解如何一步步完成迁移，可参阅
<a href=/zh/docs/tasks/configure-pod-container/migrate-from-psp/>从 PodSecurityPolicy 迁移到内置的 PodSecurity 准入控制器</a>。</p>
<h2 id=podsecuritypolicy-spec>PodSecurityPolicy 规约 </h2>
<p>下面表格中所列举的字段是 <code>PodSecurityPolicySpec</code> 的一部分，是通过 <code>.spec</code>
字段路径来设置的。</p>
<table class=no-word-break>
<caption style=display:none>从 PodSecurityPolicySpec 字段映射到 Pod Security 标准</caption>
<tbody>
<tr>
<th><code>PodSecurityPolicySpec</code></th>
<th>类型</th>
<th>Pod 安全性标准中对应设置</th>
</tr>
<tr>
<td><code>privileged</code></td>
<td>检查性质</td>
<td><b>Baseline & Restricted</b>: <code>false</code> / 未定义 / nil</td>
</tr>
<tr>
<td><code>defaultAddCapabilities</code></td>
<td>更改性质 & 检查性质</td>
<td>需求满足下面的 <code>allallowedCapabilities</code></td>
</tr>
<tr>
<td><code>allowedCapabilities</code></td>
<td>检查性质</td>
<td>
<p><b>Baseline</b>：下面各项的子集</p>
<ul>
<li><code>AUDIT_WRITE</code></li>
<li><code>CHOWN</code></li>
<li><code>DAC_OVERRIDE</code></li>
<li><code>FOWNER</code></li>
<li><code>FSETID</code></li>
<li><code>KILL</code></li>
<li><code>MKNOD</code></li>
<li><code>NET_BIND_SERVICE</code></li>
<li><code>SETFCAP</code></li>
<li><code>SETGID</code></li>
<li><code>SETPCAP</code></li>
<li><code>SETUID</code></li>
<li><code>SYS_CHROOT</code></li>
</ul>
<p><b>Restricted</b>：空 / 未定义 / nil 或<i>仅</i>包含 <code>NET_BIND_SERVICE</code> 的列表</p>
</td>
</tr>
<tr>
<td><code>requiredDropCapabilities</code></td>
<td>更改性质 & 检查性质</td>
<td>
<p><b>Baseline</b>：无意见</p>
<p><b>Restricted</b>：必须包含 <code>ALL</code></p>
</td>
</tr>
<tr>
<td><code>volumes</code></td>
<td>检查性质</td>
<td>
<p><b>Baseline</b>除下列取值之外的任何值</p>
<ul>
<li><code>hostPath</code></li>
<li><code>*</code></li>
</ul>
<p><b>Restricted</b>：下列取值的子集</p>
<ul>
<li><code>configMap</code></li>
<li><code>csi</code></li>
<li><code>downwardAPI</code></li>
<li><code>emptyDir</code></li>
<li><code>ephemeral</code></li>
<li><code>persistentVolumeClaim</code></li>
<li><code>projected</code></li>
<li><code>secret</code></li>
</ul>
</td>
</tr>
<tr>
<td><code>hostNetwork</code></td>
<td>检查性质</td>
<td><b>Baseline & Restricted</b>：<code>false</code> / 未定义 / nil</td>
</tr>
<tr>
<td><code>hostPorts</code></td>
<td>检查性质</td>
<td><b>Baseline & Restricted</b>：未定义 / nil / 空</td>
</tr>
<tr>
<td><code>hostPID</code></td>
<td>检查性质</td>
<td><b>Baseline & Restricted</b>：<code>false</code> / 未定义 / nil</td>
</tr>
<tr>
<td><code>hostIPC</code></td>
<td>检查性质</td>
<td><b>Baseline & Restricted</b>：<code>false</code> / 未定义 / nil</td>
</tr>
<tr>
<td><code>seLinux</code></td>
<td>更改性质 & 检查性质</td>
<td>
<p><b>Baseline & Restricted</b>：
<code>seLinux.rule</code> 为 <code>MustRunAs</code>，且 <code>options</code> 如下：
</p>
<ul>
<li><code>user</code> 未设置（<code>""</code> / 未定义 / nil）</li>
<li><code>role</code> 未设置（<code>""</code> / 未定义 / nil）</li>
<li><code>type</code> 未设置或者取值为 <code>container_t</code>、<code>container_init_t</code> 或 <code>container_kvm_t</code> 之一</li>
<li><code>level</code> 是任何取值</li>
</ul>
</td>
</tr>
<tr>
<td><code>runAsUser</code></td>
<td>变更性质 & 检查性质</td>
<td>
<p><b>Baseline</b>：任何取值</p>
<p><b>Restricted</b>：<code>rule</code> 是 <code>MustRunAsNonRoot</code></p>
</td>
</tr>
<tr>
<td><code>runAsGroup</code></td>
<td>变更性质（MustRunAs）& 检查性质</td>
<td>
<i>无意见</i>
</td>
</tr>
<tr>
<td><code>supplementalGroups</code></td>
<td>变更性质 & 检查性质</td>
<td>
<i>无意见</i>
</td>
</tr>
<tr>
<td><code>fsGroup</code></td>
<td>变更性质 & 验证性质</td>
<td>
<i>无意见</i>
</td>
</tr>
<tr>
<td><code>readOnlyRootFilesystem</code></td>
<td>变更性质 & 检查性质</td>
<td>
<i>无意见</i>
</td>
</tr>
<tr>
<td><code>defaultAllowPrivilegeEscalation</code></td>
<td>变更性质</td>
<td>
<i>无意见（非变更性质）</i>
</td>
</tr>
<tr>
<td><code>allowPrivilegeEscalation</code></td>
<td>变更性质 & 检查性质</td>
<td>
<p><i>只有设置为 <code>false</code> 时才执行变更动作</i></p>
<p><b>Baseline</b>：无意见</p>
<p><b>Restricted</b>：<code>false</code></p>
</td>
</tr>
<tr>
<td><code>allowedHostPaths</code></td>
<td>检查性质</td>
<td><i>无意见（volumes 优先）</i></td>
</tr>
<tr>
<td><code>allowedFlexVolumes</code></td>
<td>检查性质</td>
<td><i>无意见（volumes 优先）</i></td>
</tr>
<tr>
<td><code>allowedCSIDrivers</code></td>
<td>检查性质</td>
<td><i>无意见（volumes 优先）</i></td>
</tr>
<tr>
<td><code>allowedUnsafeSysctls</code></td>
<td>检查性质</td>
<td><b>Baseline & Restricted</b>：未定义 / nil / 空</td>
</tr>
<tr>
<td><code>forbiddenSysctls</code></td>
<td>检查性质</td>
<td><i>无意见</i></td>
</tr>
<tr>
<td><code>allowedProcMountTypes</code><br><i>(alpha feature)</i></td>
<td>检查性质</td>
<td><b>Baseline & Restricted</b>：<code>["Default"]</code> 或者未定义 / nil / 空</td>
</tr>
<tr>
<td><code>runtimeClass</code><br><code>&nbsp;.defaultRuntimeClassName</code></td>
<td>变更性质</td>
<td><i>无意见</i></td>
</tr>
<tr>
<td><code>runtimeClass</code><br><code>&nbsp;.allowedRuntimeClassNames</code></td>
<td>检查性质</td>
<td><i>无意见</i></td>
</tr>
</tbody>
</table>
<h2 id=podsecuritypolicy-annotations>PodSecurityPolicy 注解 </h2>
<p>下面表格中所列举的<a href=/zh/docs/concepts/overview/working-with-objects/annotations/>注解</a>
可以通过 <code>.metadata.annotations</code> 设置到 PodSecurityPolicy 对象之上。</p>
<table class=no-word-break>
<caption style=display:none>将 PodSecurityPolicy 注解映射到 Pod 安全性标准</caption>
<tbody>
<tr>
<th><code>PSP 注解</code></th>
<th>类型</th>
<th>Pod 安全性标准中对应设置</th>
</tr>
<tr>
<td><code>seccomp.security.alpha.kubernetes.io</code><br><code>/defaultProfileName</code></td>
<td>变更性质</td>
<td><i>无意见</i></td>
</tr>
<tr>
<td><code>seccomp.security.alpha.kubernetes.io</code><br><code>/allowedProfileNames</code></td>
<td>检查性质</td>
<td>
<p><b>Baseline</b>：<code>"runtime/default,"</code> <i>（其中尾部的逗号允许取消设置）</i></p>
<p><b>Restricted</b>：<code>"runtime/default"</code> <i>（没有尾部逗号）</i></p>
<p><i><code>localhost/*</code> 取值对于 Baseline 和 Restricted 都是可接受的</i></p>
</td>
</tr>
<tr>
<td><code>apparmor.security.beta.kubernetes.io</code><br><code>/defaultProfileName</code></td>
<td>变更性质</td>
<td><i>无意见</i></td>
</tr>
<tr>
<td><code>apparmor.security.beta.kubernetes.io</code><br><code>/allowedProfileNames</code></td>
<td>检查性质</td>
<td>
<p><b>Baseline</b>：<code>"runtime/default,"</code> <i>（其中尾部的逗号允许取消设置）</i></p>
<p><b>Restricted</b>：<code>"runtime/default"</code> <i>（没有尾部逗号）</i></p>
<p><i><code>localhost/*</code> 取值对于 Baseline 和 Restricted 都是可接受的</i></p>
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-a5bdc757c01991e5e6ab1a82b90639ea>3.12 - 使用 ABAC 鉴权</h1>
<p>基于属性的访问控制（Attribute-based access control - ABAC）定义了访问控制范例，其中通过使用将属性组合在一起的策略来向用户授予访问权限。</p>
<h2 id=策略文件格式>策略文件格式</h2>
<p>基于 <code>ABAC</code> 模式，可以这样指定策略文件 <code>--authorization-policy-file=SOME_FILENAME</code>。</p>
<p>此文件格式是 <a href=https://jsonlines.org/>JSON Lines</a>，不应存在外层的列表或映射，每行应只有一个映射。</p>
<p>每一行都是一个策略对象，策略对象是具有以下属性的映射：</p>
<ul>
<li>版本控制属性：
<ul>
<li><code>apiVersion</code>，字符串类型：有效值为<code>abac.authorization.kubernetes.io/v1beta1</code>，允许对策略格式进行版本控制和转换。</li>
<li><code>kind</code>，字符串类型：有效值为 <code>Policy</code>，允许对策略格式进行版本控制和转换。</li>
</ul>
</li>
<li><code>spec</code> 配置为具有以下映射的属性：
<ul>
<li>主体匹配属性：
<ul>
<li><code>user</code>，字符串类型；来自 <code>--token-auth-file</code> 的用户字符串，如果你指定 <code>user</code>，它必须与验证用户的用户名匹配。</li>
<li><code>group</code>，字符串类型；如果指定 <code>group</code>，它必须与经过身份验证的用户的一个组匹配，<code>system:authenticated</code>匹配所有经过身份验证的请求。<code>system:unauthenticated</code>匹配所有未经过身份验证的请求。</li>
</ul>
</li>
</ul>
</li>
<li>资源匹配属性：
<ul>
<li><code>apiGroup</code>，字符串类型；一个 API 组。
<ul>
<li>例： <code>apps</code>, <code>networking.k8s.io</code></li>
<li>通配符：<code>*</code>匹配所有 API 组。</li>
</ul>
</li>
<li><code>namespace</code>，字符串类型；一个命名空间。
<ul>
<li>例如：<code>kube-system</code></li>
<li>通配符：<code>*</code>匹配所有资源请求。</li>
</ul>
</li>
<li><code>resource</code>，字符串类型；资源类型。
<ul>
<li>例：<code>pods</code>, <code>deployments</code></li>
<li>通配符：<code>*</code>匹配所有资源请求。</li>
</ul>
</li>
</ul>
</li>
<li>非资源匹配属性：
<ul>
<li><code>nonResourcePath</code>，字符串类型；非资源请求路径。
<ul>
<li>例如：<code>/version</code>或 <code>/apis</code></li>
<li>通配符：
<ul>
<li><code>*</code> 匹配所有非资源请求。</li>
<li><code>/foo/*</code> 匹配 <code>/foo/</code> 的所有子路径。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><code>readonly</code>，键入布尔值，如果为 true，则表示该策略仅适用于 get、list 和 watch 操作。</li>
</ul>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong>
<p>属性未设置等效于属性被设置为对应类型的零值( 例如空字符串、0、false)，然而，出于可读性考虑，应尽量选择不设置这类属性。</p>
<p>在将来，策略可能以 JSON 格式表示，并通过 REST 界面进行管理。</p>
</div>
<h2 id=鉴权算法>鉴权算法</h2>
<p>请求具有与策略对象的属性对应的属性。</p>
<p>当接收到请求时，确定属性。未知属性设置为其类型的零值（例如：空字符串，0，false）。</p>
<p>设置为 <code>"*"</code> 的属性将匹配相应属性的任何值。</p>
<p>检查属性的元组，以匹配策略文件中的每个策略。如果至少有一行匹配请求属性，则请求被鉴权（但仍可能无法通过稍后的合法性检查）。</p>
<p>要允许任何经过身份验证的用户执行某些操作，请将策略组属性设置为 <code>"system:authenticated"</code>。</p>
<p>要允许任何未经身份验证的用户执行某些操作，请将策略组属性设置为 <code>"system:authentication"</code>。</p>
<p>要允许用户执行任何操作，请使用 apiGroup，命名空间，
资源和 nonResourcePath 属性设置为 <code>"*"</code> 的策略。</p>
<p>要允许用户执行任何操作，请使用设置为 <code>"*"</code> 的 apiGroup，namespace，resource 和 nonResourcePath 属性编写策略。</p>
<h2 id=kubectl>Kubectl</h2>
<p>Kubectl 使用 api-server 的 <code>/api</code> 和 <code>/apis</code> 端点来发现服务资源类型，并使用位于 <code>/openapi/v2</code> 的模式信息来验证通过创建/更新操作发送到 API 的对象。</p>
<p>当使用 ABAC 鉴权时，这些特殊资源必须显式地通过策略中的 <code>nonResourcePath</code> 属性暴露出来（参见下面的 <a href=#examples>示例</a>）：</p>
<ul>
<li><code>/api</code>，<code>/api/*</code>，<code>/apis</code>和 <code>/apis/*</code> 用于 API 版本协商。</li>
<li><code>/version</code> 通过 <code>kubectl version</code> 检索服务器版本。</li>
<li><code>/swaggerapi/*</code> 用于创建 / 更新操作。</li>
</ul>
<p>要检查涉及到特定 kubectl 操作的 HTTP 调用，您可以调整详细程度：
kubectl --v=8 version</p>
<h2 id=examples>例子</h2>
<ol>
<li>
<p>Alice 可以对所有资源做任何事情：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{<span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;abac.authorization.kubernetes.io/v1beta1&#34;</span>, <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;Policy&#34;</span>, <span style=color:green;font-weight:700>&#34;spec&#34;</span>: {<span style=color:green;font-weight:700>&#34;user&#34;</span>: <span style=color:#b44>&#34;alice&#34;</span>, <span style=color:green;font-weight:700>&#34;namespace&#34;</span>: <span style=color:#b44>&#34;*&#34;</span>, <span style=color:green;font-weight:700>&#34;resource&#34;</span>: <span style=color:#b44>&#34;*&#34;</span>, <span style=color:green;font-weight:700>&#34;apiGroup&#34;</span>: <span style=color:#b44>&#34;*&#34;</span>}}
</code></pre></div></li>
<li>
<p>Kubelet 可以读取任何 pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{<span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;abac.authorization.kubernetes.io/v1beta1&#34;</span>, <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;Policy&#34;</span>, <span style=color:green;font-weight:700>&#34;spec&#34;</span>: {<span style=color:green;font-weight:700>&#34;user&#34;</span>: <span style=color:#b44>&#34;kubelet&#34;</span>, <span style=color:green;font-weight:700>&#34;namespace&#34;</span>: <span style=color:#b44>&#34;*&#34;</span>, <span style=color:green;font-weight:700>&#34;resource&#34;</span>: <span style=color:#b44>&#34;pods&#34;</span>, <span style=color:green;font-weight:700>&#34;readonly&#34;</span>: <span style=color:#a2f;font-weight:700>true</span>}}
</code></pre></div></li>
<li>
<p>Kubelet 可以读写事件：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{<span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;abac.authorization.kubernetes.io/v1beta1&#34;</span>, <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;Policy&#34;</span>, <span style=color:green;font-weight:700>&#34;spec&#34;</span>: {<span style=color:green;font-weight:700>&#34;user&#34;</span>: <span style=color:#b44>&#34;kubelet&#34;</span>, <span style=color:green;font-weight:700>&#34;namespace&#34;</span>: <span style=color:#b44>&#34;*&#34;</span>, <span style=color:green;font-weight:700>&#34;resource&#34;</span>: <span style=color:#b44>&#34;events&#34;</span>}}
</code></pre></div></li>
</ol>
<ol start=4>
<li>
<p>Bob 可以在命名空间 <code>projectCaribou</code> 中读取 pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{<span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;abac.authorization.kubernetes.io/v1beta1&#34;</span>, <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;Policy&#34;</span>, <span style=color:green;font-weight:700>&#34;spec&#34;</span>: {<span style=color:green;font-weight:700>&#34;user&#34;</span>: <span style=color:#b44>&#34;bob&#34;</span>, <span style=color:green;font-weight:700>&#34;namespace&#34;</span>: <span style=color:#b44>&#34;projectCaribou&#34;</span>, <span style=color:green;font-weight:700>&#34;resource&#34;</span>: <span style=color:#b44>&#34;pods&#34;</span>, <span style=color:green;font-weight:700>&#34;readonly&#34;</span>: <span style=color:#a2f;font-weight:700>true</span>}}
</code></pre></div></li>
<li>
<p>任何人都可以对所有非资源路径进行只读请求：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{<span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;abac.authorization.kubernetes.io/v1beta1&#34;</span>, <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;Policy&#34;</span>, <span style=color:green;font-weight:700>&#34;spec&#34;</span>: {<span style=color:green;font-weight:700>&#34;group&#34;</span>: <span style=color:#b44>&#34;system:authenticated&#34;</span>, <span style=color:green;font-weight:700>&#34;readonly&#34;</span>: <span style=color:#a2f;font-weight:700>true</span>, <span style=color:green;font-weight:700>&#34;nonResourcePath&#34;</span>: <span style=color:#b44>&#34;*&#34;</span>}}
{<span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;abac.authorization.kubernetes.io/v1beta1&#34;</span>, <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;Policy&#34;</span>, <span style=color:green;font-weight:700>&#34;spec&#34;</span>: {<span style=color:green;font-weight:700>&#34;group&#34;</span>: <span style=color:#b44>&#34;system:unauthenticated&#34;</span>, <span style=color:green;font-weight:700>&#34;readonly&#34;</span>: <span style=color:#a2f;font-weight:700>true</span>, <span style=color:green;font-weight:700>&#34;nonResourcePath&#34;</span>: <span style=color:#b44>&#34;*&#34;</span>}}
</code></pre></div></li>
</ol>
<p><a href=https://releases.k8s.io/v1.23.17/pkg/auth/authorizer/abac/example_policy_file.jsonl>完整文件示例</a></p>
<h2 id=服务帐户的快速说明>服务帐户的快速说明</h2>
<p>服务帐户自动生成用户。用户名是根据命名约定生成的：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>system:serviceaccount:&lt;namespace&gt;:&lt;serviceaccountname&gt;
</code></pre></div>
<p>创建新的命名空间也会导致创建一个新的服务帐户：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>system:serviceaccount:&lt;namespace&gt;:default
</code></pre></div><p>例如，如果要将 API 的 kube-system 完整权限中的默认服务帐户授予，则可以将此行添加到策略文件中：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{<span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>:<span style=color:#b44>&#34;abac.authorization.kubernetes.io/v1beta1&#34;</span>,<span style=color:green;font-weight:700>&#34;kind&#34;</span>:<span style=color:#b44>&#34;Policy&#34;</span>,<span style=color:green;font-weight:700>&#34;spec&#34;</span>:{<span style=color:green;font-weight:700>&#34;user&#34;</span>:<span style=color:#b44>&#34;system:serviceaccount:kube-system:default&#34;</span>,<span style=color:green;font-weight:700>&#34;namespace&#34;</span>:<span style=color:#b44>&#34;*&#34;</span>,<span style=color:green;font-weight:700>&#34;resource&#34;</span>:<span style=color:#b44>&#34;*&#34;</span>,<span style=color:green;font-weight:700>&#34;apiGroup&#34;</span>:<span style=color:#b44>&#34;*&#34;</span>}}
</code></pre></div><p>需要重新启动 apiserver 以获取新的策略行。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-e7512a333ae98d32429d24b2290eb15a>4 - 众所周知的标签、注解和污点</h1>
<p>Kubernetes 将所有标签和注解保留在 kubernetes.io Namespace中。</p>
<p>本文档既可作为值的参考，也可作为分配值的协调点。</p>
<h2 id=api-对象上使用的标签-注解和污点>API 对象上使用的标签、注解和污点</h2>
<h3 id=app-kubernetes-io-component>app.kubernetes.io/component</h3>
<p>例子: <code>app.kubernetes.io/component=database</code></p>
<p>用于: 所有对象</p>
<p>架构中的组件。</p>
<p><a href=/zh/docs/concepts/overview/working-with-objects/common-labels/#labels>推荐标签</a>之一。</p>
<h3 id=app-kubernetes-io-created-by>app.kubernetes.io/created-by</h3>
<p>示例：<code>app.kubernetes.io/created-by=controller-manager</code></p>
<p>用于：所有对象</p>
<p>创建此资源的控制器/用户。</p>
<p><a href=/zh/docs/concepts/overview/working-with-objects/common-labels/#labels>推荐标签</a>之一。</p>
<h3 id=app-kubernetes-io-instance>app.kubernetes.io/instance</h3>
<p>示例：<code>app.kubernetes.io/instance=mysql-abcxzy</code></p>
<p>用于：所有对象</p>
<p>标识应用实例的唯一名称。</p>
<p><a href=/zh/docs/concepts/overview/working-with-objects/common-labels/#labels>推荐标签</a>之一。</p>
<h3 id=app-kubernetes-io-managed-by>app.kubernetes.io/managed-by</h3>
<p>示例：<code>app.kubernetes.io/managed-by=helm</code></p>
<p>用于：所有对象</p>
<p>用于管理应用操作的工具。</p>
<p><a href=/zh/docs/concepts/overview/working-with-objects/common-labels/#labels>推荐标签</a>之一。</p>
<h3 id=app-kubernetes-io-name>app.kubernetes.io/name</h3>
<p>示例：<code>app.kubernetes.io/name=mysql</code></p>
<p>用于：所有对象</p>
<p>应用的名称。</p>
<p><a href=/zh/docs/concepts/overview/working-with-objects/common-labels/#labels>推荐标签</a>之一。</p>
<h3 id=app-kubernetes-io-part-of>app.kubernetes.io/part-of</h3>
<p>示例：<code>app.kubernetes.io/part-of=wordpress</code></p>
<p>用于：所有对象</p>
<p>此应用所属的更高级别应用的名称。</p>
<p><a href=/zh/docs/concepts/overview/working-with-objects/common-labels/#labels>推荐标签</a>之一。</p>
<h3 id=app-kubernetes-io-version>app.kubernetes.io/version</h3>
<p>示例：<code>app.kubernetes.io/version="5.7.21"</code></p>
<p>用于：所有对象</p>
<p>应用的当前版本（例如，语义版本、修订哈希等）。</p>
<p><a href=/zh/docs/concepts/overview/working-with-objects/common-labels/#labels>推荐标签</a>之一。</p>
<h3 id=kubernetes-io-arch>kubernetes.io/arch</h3>
<p>例子：<code>kubernetes.io/arch=amd64</code></p>
<p>用于：Node</p>
<p>Kubelet 使用 Go 定义的 <code>runtime.GOARCH</code> 填充它。 如果你混合使用 ARM 和 X86 节点，这会很方便。</p>
<h3 id=kubernetes-io-os>kubernetes.io/os</h3>
<p>例子：<code>kubernetes.io/os=linux</code></p>
<p>用于：Node</p>
<p>Kubelet 使用 Go 定义的 <code>runtime.GOOS</code> 填充它。如果你在集群中混合使用操作系统（例如：混合 Linux 和 Windows 节点），这会很方便。</p>
<h3 id=kubernetes-io-metadata-name>kubernetes.io/metadata.name</h3>
<p>例子：<code>kubernetes.io/metadata.name=mynamespace</code></p>
<p>用于：Namespace</p>
<p>Kubernetes API 服务器（<a class=glossary-tooltip title="控制平面是指容器编排层，它暴露 API 和接口来定义、部署容器和管理容器的生命周期。" data-toggle=tooltip data-placement=top href="/zh/docs/reference/glossary/?all=true#term-control-plane" target=_blank aria-label=控制平面>控制平面</a> 的一部分）在所有 Namespace 上设置此标签。
标签值被设置 Namespace 的名称。你无法更改此标签的值。</p>
<p>如果你想使用标签<a class=glossary-tooltip title=选择算符允许用户通过标签对一组资源对象进行筛选过滤。 data-toggle=tooltip data-placement=top href=/zh/docs/concepts/overview/working-with-objects/labels/ target=_blank aria-label=选择器>选择器</a>定位特定 Namespace，这很有用。</p>
<h3 id=beta-kubernetes-io-arch>beta.kubernetes.io/arch (已弃用)</h3>
<p>此标签已被弃用。请改用<code>kubernetes.io/arch</code>。</p>
<h3 id=beta-kubernetes-io-os>beta.kubernetes.io/os (已弃用)</h3>
<p>此标签已被弃用。请改用<code>kubernetes.io/os</code>。</p>
<h3 id=kubernetesiohostname>kubernetes.io/hostname</h3>
<p>例子：<code>kubernetes.io/hostname=ip-172-20-114-199.ec2.internal</code></p>
<p>用于：Node</p>
<p>Kubelet 使用主机名填充此标签。请注意，可以通过将 <code>--hostname-override</code> 标志传递给 <code>kubelet</code> 来替代“实际”主机名。</p>
<p>此标签也用作拓扑层次结构的一部分。 有关详细信息，请参阅 <a href=#topologykubernetesiozone>topology.kubernetes.io/zone</a>。</p>
<h3 id=change-cause>kubernetes.io/change-cause</h3>
<p>例子：<code>kubernetes.io/change-cause=kubectl edit --record deployment foo</code></p>
<p>用于：所有对象</p>
<p>此注解是对某些事物发生变更的原因的最佳猜测。</p>
<p>将 <code>--record</code> 添加到可能会更改对象的 <code>kubectl</code> 命令时会填充它。</p>
<h3 id=description>kubernetes.io/description</h3>
<p>例子：<code>kubernetes.io/description: "Description of K8s object."</code></p>
<p>用于：所有对象</p>
<p>此注解用于描述给定对象的特定行为。</p>
<h3 id=enforce-mountable-secrets>kubernetes.io/enforce-mountable-secrets</h3>
<p>例子：<code>kubernetes.io/enforce-mountable-secrets: "true"</code></p>
<p>用于：ServiceAccount</p>
<p>此注解的值必须为 <strong>true</strong> 才能生效。此注解表示作为此服务帐户运行的 Pod 只能引用在服务帐户的 <code>secrets</code> 字段中指定的 Secret API 对象。</p>
<h3 id=pod-deletion-cost>controller.kubernetes.io/pod-deletion-cost</h3>
<p>例子：<code>controller.kubernetes.io/pod-deletion-cost=10</code></p>
<p>用于：Pod</p>
<p>该注解用于设置 <a href=/docs/concepts/workloads/controllers/replicaset/#pod-deletion-cost>Pod 删除成本</a>允许用户影响 ReplicaSet 缩减顺序。注解解析为 <code>int32</code> 类型。</p>
<h3 id=kubernetes-io-ingress-bandwidth>kubernetes.io/ingress-bandwidth</h3>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 入站流量控制注解是一项实验性功能。
如果要启用流量控制支持，必须将<code>bandwidth</code>插件添加到 CNI 配置文件（默认为<code>/etc/cni/net.d</code>）
并确保二进制文件包含在你的 CNI bin 目录中（默认为<code>/opt/cni/bin</code>）。
</div>
<p>示例：<code>kubernetes.io/ingress-bandwidth: 10M</code></p>
<p>用于：Pod</p>
<p>你可以对 Pod 应用服务质量流量控制并有效限制其可用带宽。
入站流量（到 Pod）通过控制排队的数据包来处理，以有效地处理数据。
要限制 Pod 的带宽，请编写对象定义 JSON 文件并使用 <code>kubernetes.io/ingress-bandwidth</code>
注解指定数据流量速度。 用于指定入站的速率单位是每秒，
作为<a href=/zh/docs/reference/kubernetes-api/common-definitions/quantity/>量纲（Quantity）</a>。
例如，<code>10M</code>表示每秒 10 兆比特。</p>
<h3 id=kubernetes-io-egress-bandwidth>kubernetes.io/egress-bandwidth</h3>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 出站流量控制注解是一项实验性功能。
如果要启用流量控制支持，必须将<code>bandwidth</code>插件添加到 CNI 配置文件（默认为<code>/etc/cni/net.d</code>）
并确保二进制文件包含在你的 CNI bin 目录中（默认为<code>/opt/cni/bin</code>）。
</div>
<p>示例：<code>kubernetes.io/egress-bandwidth: 10M</code></p>
<p>用于：Pod</p>
<p>出站流量（来自 pod）由策略控制，策略只是丢弃超过配置速率的数据包。
你为一个 Pod 所设置的限制不会影响其他 Pod 的带宽。
要限制 Pod 的带宽，请编写对象定义 JSON 文件并使用 <code>kubernetes.io/egress-bandwidth</code> 注解指定数据流量速度。
用于指定出站的速率单位是每秒比特数，
以<a href=/zh/docs/reference/kubernetes-api/common-definitions/quantity/>量纲（Quantity）</a>的形式给出。
例如，<code>10M</code> 表示每秒 10 兆比特。</p>
<h3 id=beta-kubernetes-io-instance-type>beta.kubernetes.io/instance-type (已弃用)</h3>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 从 v1.17 开始，此标签已弃用，取而代之的是 <a href=#nodekubernetesioinstance-type>node.kubernetes.io/instance-type</a>。
</div>
<h3 id=nodekubernetesioinstance-type>node.kubernetes.io/instance-type</h3>
<p>例子：<code>node.kubernetes.io/instance-type=m3.medium</code></p>
<p>用于：Node</p>
<p>Kubelet 使用 <code>cloudprovider</code> 定义的实例类型填充它。
仅当你使用 <code>cloudprovider</code> 时才会设置此项。如果你希望将某些工作负载定位到某些实例类型，则此设置非常方便，但通常你希望依靠 Kubernetes 调度程序来执行基于资源的调度。
你应该基于属性而不是实例类型来调度（例如：需要 GPU，而不是需要 <code>g2.2xlarge</code>）。</p>
<h3 id=failure-domainbetakubernetesioregion>failure-domain.beta.kubernetes.io/region (已弃用)</h3>
<p>请参阅 <a href=#topologykubernetesioregion>topology.kubernetes.io/region</a>。</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 从 v1.17 开始，此标签已弃用，取而代之的是 <a href=#topologykubernetesioregion>topology.kubernetes.io/region</a>。
</div>
<h3 id=failure-domainbetakubernetesiozone>failure-domain.beta.kubernetes.io/zone (已弃用)</h3>
<p>请参阅 <a href=#topologykubernetesiozone>topology.kubernetes.io/zone</a>。</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 从 v1.17 开始，此标签已弃用，取而代之的是 <a href=#topologykubernetesiozone>topology.kubernetes.io/zone</a>。
</div>
<h3 id=statefulsetkubernetesiopod-name>statefulset.kubernetes.io/pod-name</h3>
<p>例子：<code>statefulset.kubernetes.io/pod-name=mystatefulset-7</code></p>
<p>当 StatefulSet 控制器为 StatefulSet 创建 Pod 时，控制平面会在该 Pod 上设置此标签。标签的值是正在创建的 Pod 的名称。</p>
<p>有关详细信息，请参阅 StatefulSet 主题中的 <a href=/docs/concepts/workloads/controllers/statefulset/#pod-name-label>Pod 名称标签</a>。</p>
<h3 id=topologykubernetesioregion>topology.kubernetes.io/region</h3>
<p>例子：<code>topology.kubernetes.io/region=us-east-1</code></p>
<p>请参阅 <a href=#topologykubernetesiozone>topology.kubernetes.io/zone</a>。</p>
<h3 id=topologykubernetesiozone>topology.kubernetes.io/zone</h3>
<p>例子：<code>topology.kubernetes.io/zone=us-east-1c</code></p>
<p>用于：Node、PersistentVolume</p>
<p>在 Node 上：<code>kubelet</code> 或外部 <code>cloud-controller-manager</code> 使用 <code>cloudprovider</code> 提供的信息填充它。仅当你使用 <code>cloudprovider</code> 时才会设置此项。
但是，如果它在你的拓扑中有意义，你应该考虑在 Node 上设置它。</p>
<p>在 PersistentVolume 上：拓扑感知卷配置器将自动在 <code>PersistentVolume</code> 上设置 Node 亲和性约束。</p>
<p>一个 Zone 代表一个逻辑故障域。 Kubernetes 集群通常跨越多个 Zone 以提高可用性。虽然 Zone 的确切定义留给基础设施实现，
但 Zone 的常见属性包括 Zone 内非常低的网络延迟、 Zone 内的免费网络流量以及与其他 Zone 的故障独立性。
例如，一个 Zone 内的 Node 可能共享一个网络交换机，但不同 Zone 中的 Node 无法共享交换机。</p>
<p>一个 Region 代表一个更大的域，由一个或多个 Zone 组成。Kubernetes 集群跨多个 Region 并不常见，虽然 Zone 或 Region 的确切定义留给基础设施实现，
但 Region 的共同属性包括它们之间的网络延迟比它们内部更高，它们之间的网络流量成本非零，以及与其他 Zone 或 Region 的故障独立性。
例如，一个 Region 内的 Node 可能共享电力基础设施（例如 UPS 或发电机），但不同 Region 的 Node 通常不会共享电力基础设施。</p>
<p>Kubernetes 对 Zone 和 Region 的结构做了一些假设：</p>
<ol>
<li>
<p>Zone 和 Region 是分层的： Zone 是 Region 的严格子集，没有 Zone 可以在两个 Region 中；</p>
</li>
<li>
<p>Zone 名称跨 Region 是唯一的；例如， Region “africa-east-1” 可能由 Zone “africa-east-1a” 和 “africa-east-1b” 组成。</p>
</li>
</ol>
<p>你可以大胆假设拓扑标签不会改变。尽管严格地讲标签是可变的，但节点的用户可以假设给定
节点只能通过销毁和重新创建才能完成 Zone 间移动。</p>
<p>Kubernetes 可以通过多种方式使用这些信息。例如，调度程序会自动尝试将 ReplicaSet 中的 Pod
分布在单 Zone 集群中的多个节点上（以便减少节点故障的影响，请参阅 <a href=#kubernetesiohostname>kubernetes.io/hostname</a>）。
对于多 Zone 集群，这种分布行为也适用于 Zone（以减少 Zone 故障的影响）。
Zone 级别的 Pod 分布是通过 <em>SelectorSpreadPriority</em> 实现的。</p>
<p><em>SelectorSpreadPriority</em> 是一个尽力而为的放置机制。如果集群中的 Zone 是异构的
（例如：节点数量不同、节点类型不同或 Pod 资源需求有别等），这种放置机制可能会让你的
Pod 无法实现跨 Zone 均匀分布。
如果需要，你可以使用同质 Zone（节点数量和类型均相同）来减少不均匀分布的可能性。</p>
<p>调度程序还将（通过 <em>VolumeZonePredicate</em> 条件）确保申领给定卷的 Pod 仅被放置在与该卷相同的 Zone 中。
卷不能跨 Zone 挂接。</p>
<p>你应该考虑手动添加标签（或添加对 <code>PersistentVolumeLabel</code> 的支持）。
基于 <code>PersistentVolumeLabel</code> ，调度程序可以防止 Pod 挂载来自其他 Zone 的卷。如果你的基础架构没有此限制，则不需要将 Zone 标签添加到卷上。</p>
<h3 id=volume-beta-kubernetes-io-storage-provisioner>volume.beta.kubernetes.io/storage-provisioner (已弃用)</h3>
<p>例子：<code>volume.beta.kubernetes.io/storage-provisioner: k8s.io/minikube-hostpath</code></p>
<p>用于：PersistentVolumeClaim</p>
<p>此注解已被弃用。</p>
<h3 id=volume-kubernetes-io-storage-provisioner>volume.kubernetes.io/storage-provisioner</h3>
<p>用于：PersistentVolumeClaim</p>
<p>此注解将被添加到根据需要动态制备的 PVC 上。</p>
<h3 id=nodekubernetesiowindows-build>node.kubernetes.io/windows-build</h3>
<p>例子：<code>node.kubernetes.io/windows-build=10.0.17763</code></p>
<p>用于：Node</p>
<p>当 kubelet 在 Microsoft Windows 上运行时，它会自动标记其所在节点以记录所使用的 Windows Server 的版本。</p>
<p>标签的值采用 “MajorVersion.MinorVersion.BuildNumber” 格式。</p>
<h3 id=servicekubernetesioheadless>service.kubernetes.io/headless</h3>
<p>例子：<code>service.kubernetes.io/headless=""</code></p>
<p>用于：Service</p>
<p>当拥有的 Service 是无头类型时，控制平面将此标签添加到 Endpoints 对象。</p>
<h3 id=kubernetesioservice-name>kubernetes.io/service-name</h3>
<p>例子：<code>kubernetes.io/service-name="nginx"</code></p>
<p>用于：Service</p>
<p>Kubernetes 使用这个标签来区分多个服务。目前仅用于 <code>ELB</code> （弹性负载均衡器）。</p>
<h3 id=endpointslicekubernetesiomanaged-by>endpointslice.kubernetes.io/managed-by</h3>
<p>例子：<code>endpointslice.kubernetes.io/managed-by="controller"</code></p>
<p>用于：EndpointSlice</p>
<p>用于标示管理 EndpointSlice 的控制器或实体。该标签旨在使不同的 EndpointSlice
对象能够由同一集群内的不同控制器或实体管理。</p>
<h3 id=endpointslicekubernetesioskip-mirror>endpointslice.kubernetes.io/skip-mirror</h3>
<p>例子：<code>endpointslice.kubernetes.io/skip-mirror="true"</code></p>
<p>用于：Endpoints</p>
<p>可以在 Endpoints 资源上将此标签设置为 <code>"true"</code>，以指示 EndpointSliceMirroring
控制器不应使用 EndpointSlice 镜像此 Endpoints 资源。</p>
<h3 id=servicekubernetesioservice-proxy-name>service.kubernetes.io/service-proxy-name</h3>
<p>例子：<code>service.kubernetes.io/service-proxy-name="foo-bar"</code></p>
<p>用于：Service</p>
<p>kube-proxy 自定义代理会使用这个标签，它将服务控制委托给自定义代理。</p>
<h3 id=experimental-windows-kubernetes-io-isolation-type>experimental.windows.kubernetes.io/isolation-type (已弃用)</h3>
<p>例子：<code>experimental.windows.kubernetes.io/isolation-type: "hyperv"</code></p>
<p>用于：Pod</p>
<p>注解用于运行具有 Hyper-V 隔离的 Windows 容器。要使用 Hyper-V 隔离功能并创建 Hyper-V
隔离容器，kubelet 启动时应该需要设置特性门控 HyperVContainer=true。</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 你只能在具有单个容器的 Pod 上设置此注解。
从 v1.20 开始，此注解已弃用。1.21 中删除了实验性 Hyper-V 支持。
</div>
<h3 id=ingressclass-kubernetes-io-is-default-class>ingressclass.kubernetes.io/is-default-class</h3>
<p>例子：<code>ingressclass.kubernetes.io/is-default-class: "true"</code></p>
<p>用于：IngressClass</p>
<p>当单个 IngressClass 资源将此注解设置为 <code>"true"</code>时，新的未指定 Ingress 类的 Ingress
资源将被设置为此默认类。</p>
<h3 id=kubernetes-io-ingress-class>kubernetes.io/ingress.class (已弃用)</h3>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 从 v1.18 开始，不推荐使用此注解以鼓励使用 <code>spec.ingressClassName</code>。
</div>
<h3 id=storageclass-kubernetes-io-is-default-class>storageclass.kubernetes.io/is-default-class</h3>
<p>例子：<code>storageclass.kubernetes.io/is-default-class=true</code></p>
<p>用于：StorageClass</p>
<p>当单个 StorageClass 资源将此注解设置为 <code>"true"</code> 时，新的未指定存储类的 PersistentVolumeClaim
资源将被设置为此默认类。</p>
<h3 id=alpha-kubernetes-io-provided-node-ip>alpha.kubernetes.io/provided-node-ip</h3>
<p>例子：<code>alpha.kubernetes.io/provided-node-ip: "10.0.0.1"</code></p>
<p>用于：Node</p>
<p>kubelet 可以在 Node 上设置此注解来表示其配置的 IPv4 地址。</p>
<p>当使用“外部”云驱动启动时，kubelet 会在 Node 上设置此注解以表示从命令行标志 ( <code>--node-ip</code> ) 设置的 IP 地址。
云控制器管理器通过云驱动验证此 IP 是否有效。</p>
<h3 id=batch-kubernetes-io-job-completion-index>batch.kubernetes.io/job-completion-index</h3>
<p>例子：<code>batch.kubernetes.io/job-completion-index: "3"</code></p>
<p>用于：Pod</p>
<p>kube-controller-manager 中的 Job 控制器为使用 Indexed
<a href=/zh/docs/concepts/workloads/controllers/job/#completion-mode>完成模式</a>创建的 Pod
设置此注解。</p>
<h3 id=kubectl-kubernetes-io-default-container>kubectl.kubernetes.io/default-container</h3>
<p>例子：<code>kubectl.kubernetes.io/default-container: "front-end-app"</code></p>
<p>此注解的值是此 Pod 的默认容器名称。例如，未指定 <code>-c</code> 或 <code>--container</code> 标志时执行
<code>kubectl logs</code> 或 <code>kubectl exec</code> 命令将使用此默认容器。</p>
<h3 id=endpoints-kubernetes-io-over-capacity>endpoints.kubernetes.io/over-capacity</h3>
<p>例子：<code>endpoints.kubernetes.io/over-capacity:truncated</code></p>
<p>用于：Endpoints</p>
<p>在 Kubernetes 集群 v1.22（或更高版本）中，如果 Endpoints 资源超过 1000 个，Endpoints
控制器会将此注解添加到 Endpoints 资源。
注解表示 Endpoints 资源已超出容量，并且已将 Endpoints 数截断为 1000。</p>
<h3 id=batch-kubernetes-io-job-tracking>batch.kubernetes.io/job-tracking</h3>
<p>例子：<code>batch.kubernetes.io/job-tracking: ""</code></p>
<p>用于：Job</p>
<p>Job 上存在此注解表明控制平面正在<a href=/zh/docs/concepts/workloads/controllers/job/#job-tracking-with-finalizers>使用 Finalizer 追踪 Job</a>。
你 <strong>不</strong> 可以手动添加或删除此注解。</p>
<h3 id=scheduleralphakubernetesio-preferavoidpods>scheduler.alpha.kubernetes.io/preferAvoidPods (deprecated)</h3>
<p>用于：Node</p>
<p>此注解需要启用 <a href=/zh/docs/reference/scheduling/config/#scheduling-plugins>NodePreferAvoidPods 调度插件</a>。
该插件自 Kubernetes 1.22 起已被弃用。
请改用<a href=/zh/docs/concepts/scheduling-eviction/taint-and-toleration/>污点和容忍度</a>。</p>
<p><strong>下面列出的污点总是在 Node 上使用</strong></p>
<h3 id=node-kubernetes-io-not-ready>node.kubernetes.io/not-ready</h3>
<p>例子：<code>node.kubernetes.io/not-ready:NoExecute</code></p>
<p>Node 控制器通过监控 Node 的健康状况来检测 Node 是否准备就绪，并相应地添加或删除此污点。</p>
<h3 id=node-kubernetes-io-unreachable>node.kubernetes.io/unreachable</h3>
<p>例子：<code>node.kubernetes.io/unreachable:NoExecute</code></p>
<p>Node 控制器将此污点添加到对应<a href=/zh/docs/concepts/architecture/nodes/#condition>节点状况</a> <code>Ready</code>
为 <code>Unknown</code> 的 Node 上。</p>
<h3 id=node-kubernetes-io-unschedulable>node.kubernetes.io/unschedulable</h3>
<p>例子：<code>node.kubernetes.io/unschedulable:NoSchedule</code></p>
<p>在初始化 Node 期间，为避免竞争条件，此污点将被添加到 Node 上。</p>
<h3 id=node-kubernetes-io-memory-pressure>node.kubernetes.io/memory-pressure</h3>
<p>例子：<code>node.kubernetes.io/memory-pressure:NoSchedule</code></p>
<p>kubelet 根据在 Node 上观察到的 <code>memory.available</code> 和 <code>allocatableMemory.available</code> 检测内存压力。
然后将观察到的值与可以在 kubelet 上设置的相应阈值进行比较，以确定是否应添加/删除 Node 状况和污点。</p>
<h3 id=node-kubernetes-io-disk-pressure>node.kubernetes.io/disk-pressure</h3>
<p>例子：<code>node.kubernetes.io/disk-pressure:NoSchedule</code></p>
<p>kubelet 根据在 Node 上观察到的 <code>imagefs.available</code>、<code>imagefs.inodesFree</code>、<code>nodefs.available</code> 和 <code>nodefs.inodesFree</code>（仅限 Linux ）检测磁盘压力。
然后将观察到的值与可以在 kubelet 上设置的相应阈值进行比较，以确定是否应添加/删除 Node 状况和污点。</p>
<h3 id=node-kubernetes-io-network-unavailable>node.kubernetes.io/network-unavailable</h3>
<p>例子：<code>node.kubernetes.io/network-unavailable:NoSchedule</code></p>
<p>当使用的云驱动指示需要额外的网络配置时，此注解最初由 kubelet 设置。
只有云上的路由被正确地配置了，此污点才会被云驱动移除</p>
<h3 id=node-kubernetes-io-pid-pressure>node.kubernetes.io/pid-pressure</h3>
<p>例子：<code>node.kubernetes.io/pid-pressure:NoSchedule</code></p>
<p>kubelet 检查 <code>/proc/sys/kernel/pid_max</code> 大小的 D 值和 Kubernetes 在 Node 上消耗的 PID，
以获取可用 PID 数量，并将其作为 <code>pid.available</code> 指标值。
然后该指标与在 kubelet 上设置的相应阈值进行比较，以确定是否应该添加/删除 Node 状况和污点。</p>
<h3 id=node-cloudprovider-kubernetes-io-shutdown>node.cloudprovider.kubernetes.io/uninitialized</h3>
<p>例子：<code>node.cloudprovider.kubernetes.io/uninitialized:NoSchedule</code></p>
<p>在使用“外部”云驱动启动 kubelet 时，在 Node 上设置此污点以将其标记为不可用，直到来自
cloud-controller-manager 的控制器初始化此 Node，然后移除污点。</p>
<h3 id=node-cloudprovider-kubernetes-io-shutdown>node.cloudprovider.kubernetes.io/shutdown</h3>
<p>例子：<code>node.cloudprovider.kubernetes.io/shutdown:NoSchedule</code></p>
<p>如果 Node 处于云驱动所指定的关闭状态，则 Node 会相应地被设置污点，对应的污点和效果为
<code>node.cloudprovider.kubernetes.io/shutdown</code> 和 <code>NoSchedule</code>。</p>
<h3 id=pod-security-kubernetes-io-enforce>pod-security.kubernetes.io/enforce</h3>
<p>例子：<code>pod-security.kubernetes.io/enforce: baseline</code></p>
<p>用于：Namespace</p>
<p>值<strong>必须</strong>是 <code>privileged</code>、<code>baseline</code> 或 <code>restricted</code> 之一，它们对应于
<a href=/zh/docs/concepts/security/pod-security-standards>Pod 安全标准</a> 级别。
特别地，<code>enforce</code> 标签 <strong>禁止</strong> 在带标签的 Namespace 中创建任何不符合指示级别要求的 Pod。</p>
<p>请请参阅<a href=/zh/docs/concepts/security/pod-security-admission>在名字空间级别实施 Pod 安全性</a>了解更多信息。</p>
<h3 id=pod-security-kubernetes-io-enforce-version>pod-security.kubernetes.io/enforce-version</h3>
<p>例子：<code>pod-security.kubernetes.io/enforce-version: 1.27</code></p>
<p>用于：Namespace</p>
<p>值<strong>必须</strong>是 <code>latest</code> 或格式为 <code>v&lt;MAJOR>.&lt;MINOR></code> 的有效 Kubernetes 版本。
此注解决定了在验证提交的 Pod 时要应用的 <a href=/zh/docs/concepts/security/pod-security-standards>Pod 安全标准</a>策略的版本。</p>
<p>请参阅<a href=/zh/docs/concepts/security/pod-security-admission>在名字空间级别实施 Pod 安全性</a>了解更多信息。</p>
<h3 id=pod-security-kubernetes-io-audit>pod-security.kubernetes.io/audit</h3>
<p>例子：<code>pod-security.kubernetes.io/audit: baseline</code></p>
<p>用于：Namespace</p>
<p>值<strong>必须</strong>是与 <a href=/zh/docs/concepts/security/pod-security-standards>Pod 安全标准</a> 级别相对应的
<code>privileged</code>、<code>baseline</code> 或 <code>restricted</code> 之一。
具体来说，<code>audit</code> 标签不会阻止在带标签的 Namespace 中创建不符合指示级别要求的 Pod，
但会向该 Pod 添加审计注解。</p>
<p>请参阅<a href=/zh/docs/concepts/security/pod-security-admission>在名字空间级别实施 Pod 安全性</a>了解更多信息。</p>
<h3 id=pod-security-kubernetes-io-audit-version>pod-security.kubernetes.io/audit-version</h3>
<p>例子：<code>pod-security.kubernetes.io/audit-version: 1.27</code></p>
<p>用于：Namespace</p>
<p>值<strong>必须</strong>是 <code>latest</code> 或格式为 <code>v&lt;MAJOR>.&lt;MINOR></code> 的有效 Kubernetes 版本。
此注解决定了在验证提交的 Pod 时要应用的 <a href=/zh/docs/concepts/security/pod-security-standards>Pod 安全标准</a>策略的版本。</p>
<p>请参阅<a href=/zh/docs/concepts/security/pod-security-admission>在名字空间级别实施 Pod 安全性</a>了解更多信息。</p>
<h3 id=pod-security-kubernetes-io-warn>pod-security.kubernetes.io/warn</h3>
<p>例子：<code>pod-security.kubernetes.io/warn: baseline</code></p>
<p>用于：Namespace</p>
<p>值<strong>必须</strong>是与 <a href=/zh/docs/concepts/security/pod-security-standards>Pod 安全标准</a>级别相对应的
<code>privileged</code>、<code>baseline</code> 或 <code>restricted</code> 之一。特别地，
<code>warn</code> 标签不会阻止在带标签的 Namespace 中创建不符合指示级别概述要求的 Pod，但会在这样做后向用户返回警告。
请注意，在创建或更新包含 Pod 模板的对象时也会显示警告，例如 Deployment、Jobs、StatefulSets 等。</p>
<p>请参阅<a href=/zh/docs/concepts/security/pod-security-admission>在名字空间级别实施 Pod 安全性</a>了解更多信息。</p>
<h3 id=pod-security-kubernetes-io-warn-version>pod-security.kubernetes.io/warn-version</h3>
<p>例子：<code>pod-security.kubernetes.io/warn-version: 1.27</code></p>
<p>用于：Namespace</p>
<p>值<strong>必须</strong>是 <code>latest</code> 或格式为 <code>v&lt;MAJOR>.&lt;MINOR></code> 的有效 Kubernetes 版本。
此注解决定了在验证提交的 Pod 时要应用的 <a href=/zh/docs/concepts/security/pod-security-standards>Pod 安全标准</a>策略的版本。
请注意，在创建或更新包含 Pod 模板的对象时也会显示警告，
例如 Deployment、Jobs、StatefulSets 等。</p>
<p>请参阅<a href=/zh/docs/concepts/security/pod-security-admission>在名字空间级别实施 Pod 安全性</a>了解更多信息。</p>
<h3 id=seccomp-security-alpha-kubernetes-io-pod>seccomp.security.alpha.kubernetes.io/pod (已弃用)</h3>
<p>此注解自 Kubernetes v1.19 起已被弃用，将在 v1.25 中失效。
要为 Pod 指定安全设置，请在 Pod 规范中包含 <code>securityContext</code> 字段。
Pod 的 <code>.spec</code> 中的 <a href=/zh/docs/reference/kubernetes-api/workload-resources/pod-v1/#security-context><code>securityContext</code></a>
字段定义了 Pod 级别的安全属性。
你<a href=/zh/docs/tasks/configure-pod-container/security-context/#set-the-security-context-for-a-pod>为 Pod 设置安全上下文</a> 时，
你所给出的设置适用于该 Pod 中的所有容器。</p>
<h3 id=container-seccomp-security-alpha-kubernetes-io>container.seccomp.security.alpha.kubernetes.io/[NAME]</h3>
<p>此注解自 Kubernetes v1.19 起已被弃用，将在 v1.25 中失效。
教程<a href=/zh/docs/tutorials/clusters/seccomp/>使用 seccomp 限制容器的系统调用</a>将引导你完成将
seccomp 配置文件应用于 Pod 或其容器的步骤。
该教程介绍了在 Kubernetes 中配置 seccomp 的支持机制，基于在 Pod 的 <code>.spec</code> 中设置 <code>securityContext</code>。</p>
<h2 id=annonations-used-for-audit>用于审计的注解 </h2>
<ul>
<li><a href=/zh/docs/reference/labels-annotations-taints/audit-annotations/#authorization-k8s-io-decision><code>authorization.k8s.io/decision</code></a></li>
<li><a href=/zh/docs/reference/labels-annotations-taints/audit-annotations/#authorization-k8s-io-reason><code>authorization.k8s.io/reason</code></a></li>
<li><a href=/zh/docs/reference/labels-annotations-taints/audit-annotations/#pod-security-kubernetes-io-audit-violations><code>pod-security.kubernetes.io/audit-violations</code></a></li>
<li><a href=/zh/zh/docs/reference/labels-annotations-taints/audit-annotations/#pod-security-kubernetes-io-enforce-policy><code>pod-security.kubernetes.io/enforce-policy</code></a></li>
<li><a href=/zh/docs/reference/labels-annotations-taints/audit-annotations/#pod-security-kubernetes-io-exempt><code>pod-security.kubernetes.io/exempt</code></a></li>
</ul>
<p>在<a href=/zh/docs/reference/labels-annotations-taints/audit-annotations/>审计注解</a>页面上查看更多详细信息。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-0adf63217075ed2dc0a3030d9673e75e>4.1 - 审计注解</h1>
<p>该页面作为 kubernetes.io 名字空间的审计注解的参考。这些注解适用于 API 组 <code>audit.k8s.io</code> 中的 <code>Event</code> 对象。</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> Kubernetes API 中不使用以下注解。当你在集群中<a href=/zh/docs/tasks/debug-application-cluster/audit/>启用审计</a>时，
审计事件数据将使用 API 组 <code>audit.k8s.io</code> 中的 <code>Event</code> 写入。
注解适用于审计事件。审计事件不同于<a href=/zh/docs/reference/kubernetes-api/cluster-resources/event-v1/>事件 API </a>
（API 组 <code>events.k8s.io</code>）中的对象。
</div>
<h2 id=pod-security-kubernetes-io-exempt>pod-security.kubernetes.io/exempt</h2>
<p>例子：<code>pod-security.kubernetes.io/exempt: namespace</code></p>
<p>值<strong>必须</strong>是对应于 <a href=/zh/docs/concepts/security/pod-security-admission/#exemptions>Pod 安全豁免</a>维度的
<code>user</code>、<code>namespace</code> 或 <code>runtimeClass</code> 之一。
此注解指示 PodSecurity 基于哪个维度的强制豁免执行。</p>
<h2 id=pod-security-kubernetes-io-enforce-policy>pod-security.kubernetes.io/enforce-policy</h2>
<p>例子：<code>pod-security.kubernetes.io/enforce-policy: restricted:latest</code></p>
<p>值<strong>必须</strong>是对应于 <a href=/zh/docs/concepts/security/pod-security-standards>Pod 安全标准</a> 级别的
<code>privileged:&lt;版本></code>、<code>baseline:&lt;版本></code>、<code>restricted:&lt;版本></code>，
关联的版本<strong>必须</strong>是 <code>latest</code> 或格式为 <code>v&lt;MAJOR>.&lt;MINOR></code> 的有效 Kubernetes 版本。
此注解通知有关在 PodSecurity 准入期间允许或拒绝 Pod 的执行级别。</p>
<p>有关详细信息，请参阅 <a href=/zh/docs/concepts/security/pod-security-standards/>Pod 安全标准</a>。</p>
<h2 id=pod-security-kubernetes-io-audit-violations>pod-security.kubernetes.io/audit-violations</h2>
<p>例子：<code>pod-security.kubernetes.io/audit-violations: would violate PodSecurity "restricted:latest": allowPrivilegeEscalation != false (container "example" must set securityContext.allowPrivilegeEscalation=false), ...</code></p>
<p>注解值给出审计策略违规的详细说明，它包含所违反的 <a href=/zh/docs/concepts/security/pod-security-standards/>Pod 安全标准</a>级别以及
PodSecurity 执行中违反的特定策略及对应字段。</p>
<p>有关详细信息，请参阅 <a href=/zh/docs/concepts/security/pod-security-standards/>Pod 安全标准</a>。</p>
<h2 id=authorization-k8s-io-decision>authorization.k8s.io/decision</h2>
<p>例子：<code>authorization.k8s.io/decision: "forbid"</code></p>
<p>此注解在 Kubernetes 审计日志中表示请求是否获得授权。</p>
<p>有关详细信息，请参阅<a href=/zh/docs/tasks/debug-application-cluster/audit/>审计</a>。</p>
<h2 id=authorization-k8s-io-reason>authorization.k8s.io/reason</h2>
<p>例子：<code>authorization.k8s.io/reason: "Human-readable reason for the decision"</code></p>
<p>此注解给出了 Kubernetes 审计日志中 <a href=#authorization-k8s-io-decision>decision</a> 的原因。</p>
<p>有关详细信息，请参阅<a href=/zh/docs/tasks/debug-application-cluster/audit/>审计</a>。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-60a16da3955f1de774f1f8dd756f2251>5 - Kubernetes API</h1>
<p>Kubernetes API 是通过 RESTful 接口提供 Kubernetes 功能服务并负责集群状态存储的应用程序。</p>
<p>Kubernetes 资源和"意向记录"都是作为 API 对象储存的，并可以通过调用 RESTful 风格的 API 进行修改。
API 允许以声明方式管理配置。
用户可以直接和 Kubernetes API 交互，也可以通过 <code>kubectl</code> 这样的工具进行交互。
核心的 Kubernetes API 是很灵活的，可以扩展以支持定制资源。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-5037aed176781855678f89b4c21626ac>5.1 - 工作负载资源</h1>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-54e55c546ba2153921dc8b78bafd699e>5.2 - Service 资源</h1>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-ef67581d88f69ea15be11159c033f33b>5.3 - 配置和存储资源</h1>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-6a5e06a0dc59d104938425c049f2f29b>5.4 - 身份认证资源</h1>
</div>
<div class=td-content>
<h1 id=pg-4140627880f82c11a5e16b3c4043cfdb>5.4.1 - TokenReview</h1>
<div class=lead>TokenReview 尝试通过验证令牌来确认已知用户。</div>
<p><code>apiVersion: authentication.k8s.io/v1</code></p>
<p><code>import "k8s.io/api/authentication/v1"</code></p>
<h2 id=TokenReview>TokenReview</h2>
<p>TokenReview 尝试通过验证令牌来确认已知用户。
注意：TokenReview 请求可能会被 kube-apiserver 中的 webhook 令牌验证器插件缓存。</p>
<hr>
<ul>
<li>
<p><strong>apiVersion</strong>: authentication.k8s.io/v1</p>
</li>
<li>
<p><strong>kind</strong>: TokenReview</p>
</li>
<li>
<p><strong>metadata</strong> (<a href=https://kubernetes.io/zh/docs/reference/kubernetes-api/common-definitions/object-meta/#ObjectMeta>ObjectMeta</a>)</p>
<p>标准对象的元数据，更多信息：https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata</p>
</li>
<li>
<p><strong>spec</strong> (<a href=https://kubernetes.io/zh/docs/reference/kubernetes-api/authentication-resources/token-review-v1/#TokenReviewSpec>TokenReviewSpec</a>), required</p>
<p>spec 保存有关正在评估的请求的信息</p>
</li>
<li>
<p><strong>status</strong> (<a href=https://kubernetes.io/zh/docs/reference/kubernetes-api/authentication-resources/token-review-v1/#TokenReviewStatus>TokenReviewStatus</a>)</p>
<p>status 由服务器填写，指示请求是否可以通过身份验证。</p>
</li>
</ul>
<h2 id=TokenReviewSpec>TokenReviewSpec</h2>
<p>TokenReviewPec 是对令牌身份验证请求的描述。</p>
<hr>
<ul>
<li>
<p><strong>audiences</strong> ([]string)</p>
<p>audiences 是带有令牌的资源服务器标识为受众的标识符列表。
受众感知令牌身份验证器将验证令牌是否适用于此列表中的至少一个受众。
如果未提供受众，受众将默认为 Kubernetes API 服务器的受众。</p>
</li>
<li>
<p><strong>token</strong> (string)</p>
<p>token 是不透明的持有者令牌（Bearer Token）。</p>
</li>
</ul>
<h2 id=TokenReviewStatus>TokenReviewStatus</h2>
<p>TokenReviewStatus 是令牌认证请求的结果。</p>
<hr>
<ul>
<li>
<p><strong>audiences</strong> ([]string)</p>
<p>audiences 是身份验证者选择的与 TokenReview 和令牌兼容的受众标识符。 标识符是
TokenReviewSpec 受众和令牌受众的交集中的任何标识符。 设置 spec.audiences
字段的 TokenReview API 的客户端应验证在 status.audiences 字段中返回了兼容的受众标识符，
以确保 TokenReview 服务器能够识别受众。 如果 TokenReview
返回一个空的 status.audience 字段，其中 status.authenticated 为 “true”，
则该令牌对 Kubernetes API 服务器的受众有效。</p>
</li>
<li>
<p><strong>authenticated</strong> (boolean)</p>
<p>authenticated 表示令牌与已知用户相关联。</p>
</li>
<li>
<p><strong>error</strong> (string)</p>
<p>error 表示无法检查令牌</p>
</li>
<li>
<p><strong>user</strong> (UserInfo)</p>
<p>user 是与提供的令牌关联的 UserInfo。</p>
<p><a name=UserInfo></a>
&lt;--
<em>UserInfo holds the information about the user needed to implement the user.Info interface.</em>
-->
<strong>UserInfo 保存实现 user.Info 接口所需的用户信息</strong></p>
<ul>
<li>
<p><strong>user.extra</strong> (map[string][]string)</p>
</li>
</ul>
<p>验证者提供的任何附加信息。</p>
<ul>
<li>
<p><strong>user.groups</strong> ([]string)</p>
</li>
</ul>
<p>此用户所属的组的名称。</p>
<ul>
<li>
<p><strong>user.uid</strong> (string)</p>
</li>
</ul>
<p>跨时间标识此用户的唯一值。如果删除此用户并添加另一个同名用户，他们将拥有不同的 UID。</p>
<ul>
<li>
<p><strong>user.username</strong> (string)</p>
</li>
</ul>
<p>在所有活动用户中唯一标识此用户的名称。</p>
</li>
</ul>
<h2 id=Operations>操作</h2>
<hr>
<h3 id=create-创建一个tokenreview><code>create</code> 创建一个TokenReview</h3>
<h4 id=http-请求>HTTP 请求</h4>
<p>POST /apis/authentication.k8s.io/v1/tokenreviews</p>
<h4 id=参数>参数</h4>
<ul>
<li>
<p><strong>body</strong>: <a href=https://kubernetes.io/zh/docs/reference/kubernetes-api/authentication-resources/token-review-v1/#TokenReview>TokenReview</a>, 必需</p>
</li>
<li>
<p><strong>dryRun</strong> (<em>in query</em>): string</p>
<p><a href=https://kubernetes.io/zh/docs/reference/kubernetes-api/common-parameters/common-parameters/#dryRun>dryRun</a></p>
</li>
<li>
<p><strong>fieldManager</strong> (<em>in query</em>): string</p>
<p><a href=https://kubernetes.io/zh/docs/reference/kubernetes-api/common-parameters/common-parameters/#fieldManager>fieldManager</a></p>
</li>
<li>
<p><strong>fieldValidation</strong> (<em>in query</em>): string</p>
<p><a href=https://kubernetes.io/zh/docs/reference/kubernetes-api/common-parameters/common-parameters/#fieldValidation>fieldValidation</a></p>
</li>
<li>
<p><strong>pretty</strong> (<em>in query</em>): string</p>
<p><a href=https://kubernetes.io/zh/docs/reference/kubernetes-api/common-parameters/common-parameters/#pretty>pretty</a></p>
</li>
</ul>
<h4 id=响应>响应</h4>
<p>200 (<a href=https://kubernetes.io/zh/docs/reference/kubernetes-api/authentication-resources/token-review-v1/#TokenReview>TokenReview</a>): OK</p>
<p>201 (<a href=https://kubernetes.io/zh/docs/reference/kubernetes-api/authentication-resources/token-review-v1/#TokenReview>TokenReview</a>): Created</p>
<p>202 (<a href=https://kubernetes.io/zh/docs/reference/kubernetes-api/authentication-resources/token-review-v1/#TokenReview>TokenReview</a>): Accepted</p>
<p>401: Unauthorized</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-5362c9a7583eca653d4a705ba4e460ff>5.5 - 鉴权资源</h1>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-d8857a338d5c6dc04752576100c946d9>5.6 - 策略资源</h1>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-020d8f776dea9802131630c210dc4c0a>5.7 - 扩展资源</h1>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-692a25c0f0c88fc9b8c1e82cd0b0ee9e>5.8 - 集群资源</h1>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-0a260d85a5da2504fce8c56b77c45024>5.9 - 公共定义</h1>
</div>
<div class=td-content>
<h1 id=pg-9eba5edb3c1d93f9a74827e3a71014dd>5.9.1 - 删除选项</h1>
<div class=lead>删除 API 对象时可能会提供删除选项。</div>
<p><code>import "k8s.io/apimachinery/pkg/apis/meta/v1"</code></p>
<p>删除 API 对象时可能会提供 DeleteOptions。</p>
<hr>
<ul>
<li>
<p><strong>apiVersion</strong> (string)</p>
<p><code>APIVersion</code> 定义对象表示的版本化模式。
服务器应将已识别的模式转换为最新的内部值，并可能拒绝无法识别的值。
更多信息：https ://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources</p>
</li>
</ul>
<ul>
<li>
<p><strong>dryRun</strong> ([]string)</p>
<p>该值如果存在，则表示不应保留修改。
无效或无法识别的 <code>dryRun</code> 指令将导致错误响应并且不会进一步处理请求。有效值为：</p>
<ul>
<li><code>All</code>：处理所有试运行阶段（Dry Run Stages）</li>
</ul>
</li>
</ul>
<ul>
<li>
<p><strong>gracePeriodSeconds</strong> (int64)</p>
<p>表示对象被删除之前的持续时间（以秒为单位）。
值必须是非负整数。零值表示立即删除。如果此值为 <code>nil</code>，则将使用指定类型的默认宽限期。如果未指定，则为每个对象的默认值。</p>
</li>
</ul>
<ul>
<li>
<p><strong>kind</strong> (string)</p>
<p><code>kind</code> 是一个字符串值，表示此对象代表的 REST 资源。
服务器可以从客户端提交请求的端点推断出此值。此值无法更新，是驼峰的格式。
更多信息：https ://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds 。</p>
</li>
</ul>
<ul>
<li>
<p><strong>orphanDependents</strong> (boolean)</p>
<p>已弃用：该字段将在 1.7 中弃用，请使用 <code>propagationPolicy</code> 字段。
该字段表示依赖对象是否应该是孤儿。如果为 true/false，对象的 finalizers 列表中会被添加上或者移除掉 “orphan” 终结器（Finalizer）。
可以设置此字段或者设置 <code>propagationPolicy</code> 字段，但不能同时设置以上两个字段。</p>
</li>
</ul>
<ul>
<li>
<p><strong>preconditions</strong> (Preconditions)</p>
<p>先决条件必须在执行删除之前完成。如果无法满足这些条件，将返回 409（冲突）状态。</p>
<p><a name=Preconditions></a>
<em>执行操作（更新、删除等）之前必须满足先决条件。</em></p>
<ul>
<li>
<p><strong>preconditions.resourceVersion</strong> (string)</p>
<p>指定目标资源版本（resourceVersion）。</p>
</li>
<li>
<p><strong>preconditions.uid</strong> (string)</p>
<p>指定目标 UID.</p>
</li>
</ul>
</li>
</ul>
<ul>
<li>
<p><strong>propagationPolicy</strong> (string)</p>
<p>表示是否以及如何执行垃圾收集。可以设置此字段或 <code>orphanDependents</code> 字段，但不能同时设置二者。
默认策略由 <code>metadata.finalizers</code> 中现有终结器（Finalizer）集合和特定资源的默认策略决定。
可接受的值为： <code>Orphan</code> - 令依赖对象成为孤儿对象；<code>Background</code> - 允许垃圾收集器在后台删除依赖项；<code>Foreground</code> - 一个级联策略，前台删除所有依赖项。</p>
</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-26234b02eb0546f7a178da9c373cb197>5.9.2 - 标签选择器</h1>
<div class=lead>标签选择器是对一组资源的标签查询。</div>
<p><code>import "k8s.io/apimachinery/pkg/apis/meta/v1"</code></p>
<p>标签选择器是对一组资源的标签查询。</p>
<p><code>matchLabels</code> 和 <code>matchExpressions</code> 的结果按逻辑与的关系组合。一个 <code>empty</code> 标签选择器匹配所有对象。一个 <code>null</code> 标签选择器不匹配任何对象。</p>
<hr>
<ul>
<li>
<p><strong>matchExpressions</strong> ([]LabelSelectorRequirement)</p>
<p><code>matchExpressions</code> 是 <code>LabelSelectorRequirement</code> 的列表，这些需求结果按逻辑与的关系来计算。</p>
<p><a name=LabelSelectorRequirement></a>
<em>标签选择器要求是包含值、键和关联键和值的运算符的选择器。</em></p>
<ul>
<li>
<p><strong>matchExpressions.key</strong> (string)， 必填</p>
<p><em>补丁策略: 按照键 <code>key</code> 合并</em></p>
<p><code>key</code> 是选择器应用的标签键.</p>
</li>
</ul>
<ul>
<li>
<p><strong>matchExpressions.operator</strong> (string)，必填</p>
<p>operator 表示键与一组值的关系。有效的运算符包括 <code>In</code>、<code>NotIn</code>、<code>Exists</code> 和 <code>DoesNotExist</code>。</p>
</li>
</ul>
<ul>
<li>
<p><strong>matchExpressions.values</strong> ([]string)</p>
<p><code>values</code> 是一个字符串值数组。如果运算符为 <code>In</code> 或 <code>NotIn</code>，则 <code>values</code> 数组必须为非空。</p>
<p>如果运算符是 <code>Exists</code> 或 <code>DoesNotExist</code>，则 <code>values</code> 数组必须为空。</p>
<p>该数组在战略性补丁（Strategic Merge Patch）期间被替换。</p>
</li>
</ul>
</li>
</ul>
<ul>
<li>
<p><strong>matchLabels</strong> (map[string]string)</p>
<p><code>matchLabels</code> 是 {<code>key</code>,<code>value</code>} 键值对的映射。</p>
<p><code>matchLabels</code> 映射中的单个 {<code>key</code>,<code>value</code>} 键值对相当于 <code>matchExpressions</code> 的一个元素，其键字段为 <code>key</code>，运算符为 <code>In</code>，<code>values</code> 数组仅包含 <code>value</code>。</p>
<p>所表达的需求最终要按逻辑与的关系组合。</p>
</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-dbe3b11fb1cfde0aac65f945d84b11d6>5.9.3 - ListMeta</h1>
<div class=lead>ListMeta 描述了合成资源必须具有的元数据，包括列表和各种状态对象。</div>
<p><code>import "k8s.io/apimachinery/pkg/apis/meta/v1"</code></p>
<p><code>ListMeta</code> 描述了合成资源必须具有的元数据，包括列表和各种状态对象。
一个资源仅能有 <code>{ObjectMeta, ListMeta}</code> 中的一个。</p>
<hr>
<ul>
<li>
<p><strong>continue</strong> (string)</p>
<p>如果用户对返回的条目数量设置了限制，则 <code>continue</code> 可能被设置，表示服务器有更多可用的数据。
该值是不透明的，可用于向提供此列表服务的端点发出另一个请求，以检索下一组可用的对象。
如果服务器配置已更改或时间已过去几分钟，则可能无法继续提供一致的列表。
除非你在错误消息中收到此令牌（token），否则使用此 <code>continue</code> 值时返回的 <code>resourceVersion</code>
字段应该和第一个响应中的值是相同的。</p>
</li>
</ul>
<ul>
<li>
<p><strong>remainingItemCount</strong> (int64)</p>
<p><code>remainingItemCount</code> 是列表中未包含在此列表响应中的后续项目的数量。
如果列表请求包含标签或字段选择器，则剩余项目的数量是未知的，并且在序列化期间该字段将保持未设置和省略。
如果列表是完整的（因为它没有分块或者这是最后一个块），那么就没有剩余的项目，并且在序列化过程中该字段将保持未设置和省略。
早于 v1.15 的服务器不设置此字段。<code>remainingItemCount</code> 的预期用途是<em>估计</em>集合的大小。
客户端不应依赖于设置准确的 <code>remainingItemCount</code>。</p>
</li>
</ul>
<ul>
<li>
<p><strong>resourceVersion</strong> (string)</p>
<p>标识该对象的服务器内部版本的字符串，客户端可以用该字段来确定对象何时被更改。
该值对客户端是不透明的，并且应该原样传回给服务器。该值由系统填充，只读。
更多信息：https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency。</p>
</li>
</ul>
<ul>
<li>
<p><strong>selfLink</strong> (string)</p>
<p>selfLink 表示此对象的 URL，由系统填充，只读。</p>
<p>已弃用。 Kubernetes 将在 1.20 版本中停止传播该字段，并计划在 1.21 版本中删除该字段。</p>
</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-026383e0b43a68744a8b27a82bb4926d>5.9.4 - LocalObjectReference</h1>
<div class=lead>LocalObjectReference 包含足够的信息，可以让你在同一命名空间内找到引用的对象。</div>
<p><code>import "k8s.io/api/core/v1"</code></p>
<p>LocalObjectReference 包含足够的信息，可以让你在同一命名空间（namespace）内找到引用的对象。</p>
<hr>
<ul>
<li>
<p><strong>name</strong> (string)</p>
<p>被引用者的名称。
更多信息: <a href=https://kubernetes.io/zh/docs/concepts/overview/working-with-objects/names/#names>https://kubernetes.io/zh/docs/concepts/overview/working-with-objects/names/#names</a>。</p>
</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-deb2d19043a047688f72480af2f1b1e0>5.9.5 - NodeSelectorRequirement</h1>
<div class=lead>节点选择器是要求包含键、值和关联键和值的运算符的选择器</div>
<p><code>import "k8s.io/api/core/v1"</code></p>
<p>节点选择器是要求包含键、值和关联键和值的运算符的选择器。</p>
<hr>
<ul>
<li>
<p><strong>key</strong> (string), 必选</p>
<p>选择器适用的标签键。</p>
</li>
</ul>
<ul>
<li>
<p><strong>operator</strong> (string), 必选</p>
<p>表示键与一组值的关系的运算符。有效的运算符包括：In、NotIn、Exists、DoesNotExist、Gt 和 Lt。</p>
<p>可选值:</p>
<ul>
<li><code>"DoesNotExist"</code></li>
<li><code>"Exists"</code></li>
<li><code>"Gt"</code></li>
<li><code>"In"</code></li>
<li><code>"Lt"</code></li>
<li><code>"NotIn"</code></li>
</ul>
</li>
</ul>
<ul>
<li>
<p><strong>values</strong> ([]string)</p>
<p>字符串数组。如果运算符为 In 或 NotIn，则数组必须为非空。
如果运算符为 Exists 或 DoesNotExist，则数组必须为空。
如果运算符为 Gt 或 Lt，则数组必须有一个元素，该元素将被译为整数。
该数组在合并计划补丁时将被替换。</p>
</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-47b6e1916665dd55bbeb2b33847653ed>5.9.6 - ObjectFieldSelector</h1>
<div class=lead>ObjectFieldSelector 选择对象的 APIVersioned 字段。</div>
<p><code>import "k8s.io/api/core/v1"</code></p>
<p>ObjectFieldSelector 选择对象的 APIVersioned 字段。</p>
<hr>
<ul>
<li>
<p><strong>fieldPath</strong> (string), 必需的</p>
<p>在指定 API 版本中要选择的字段的路径。</p>
</li>
<li>
<p><strong>apiVersion</strong> (string)</p>
<p><code>fieldPath</code> 写入时所使用的模式版本，默认为 "v1"。</p>
</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-77f040b7d1c00efcedc11902ed78fc08>5.9.7 - ObjectMeta</h1>
<div class=lead>ObjectMeta 是所有持久化资源必须具有的元数据，其中包括用户必须创建的所有对象。</div>
<p><code>import "k8s.io/apimachinery/pkg/apis/meta/v1"</code></p>
<p>ObjectMeta 是所有持久化资源必须具有的元数据，其中包括用户必须创建的所有对象。</p>
<hr>
<ul>
<li>
<p><strong>name</strong> (string)</p>
<p>name 在命名空间内必须是唯一的。创建资源时需要，尽管某些资源可能允许客户端请求自动地生成适当的名称。
名称主要用于创建幂等性和配置定义。无法更新。
更多信息：http://kubernetes.io/docs/user-guide/identifiers#names</p>
</li>
<li>
<p><strong>generateName</strong> (string)</p>
<p>generateName 是一个可选前缀，由服务器使用，<strong>仅在</strong>未提供 name 字段时生成唯一名称。
如果使用此字段，则返回给客户端的名称将与传递的名称不同。该值还将与唯一的后缀组合。
提供的值与 name 字段具有相同的验证规则，并且可能会根据所需的后缀长度被截断，以使该值在服务器上唯一。</p>
<p>如果指定了此字段并且生成的名称存在，则服务器将不会返回 409 ——相反，它将返回 201 Created 或 500，
原因是 ServerTimeout 指示在分配的时间内找不到唯一名称，客户端应重试（可选，在 Retry-After 标头中指定的时间之后）。</p>
<p>仅在未指定 name 时应用。更多信息：https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#idempotency</p>
</li>
<li>
<p><strong>namespace</strong> (string)</p>
<p>namespace 定义了一个值空间，其中每个名称必须唯一。空命名空间相当于 “default” 命名空间，但 “default” 是规范表示。
并非所有对象都需要限定在命名空间中——这些对象的此字段的值将为空。</p>
<p>必须是 DNS_LABEL。无法更新。更多信息：http://kubernetes.io/docs/user-guide/namespaces</p>
</li>
<li>
<p><strong>labels</strong> (map[string]string)</p>
<p>可用于组织和分类（确定范围和选择）对象的字符串键和值的映射。
可以匹配 ReplicationControllers 和 Service 的选择器。更多信息：http://kubernetes.io/docs/user-guide/labels</p>
</li>
<li>
<p><strong>annotations</strong> (map[string]string)</p>
<p>annotations 是一个非结构化的键值映射，存储在资源中，可以由外部工具设置以存储和检索任意元数据。
它们不可查询，在修改对象时应保留。更多信息：http://kubernetes.io/docs/user-guide/annotations</p>
</li>
</ul>
<h3 id=System>系统字段</h3>
<ul>
<li>
<p><strong>finalizers</strong> ([]string)</p>
<p>在从注册表中删除对象之前该字段必须为空。
每个条目都是负责的组件的标识符，各组件将从列表中删除自己对应的条目。
如果对象的 deletionTimestamp 非空，则只能删除此列表中的条目。
终结器可以按任何顺序处理和删除。<strong>没有</strong>按照顺序执行，
因为它引入了终结器卡住的重大风险。finalizers 是一个共享字段，
任何有权限的参与者都可以对其进行重新排序。如果按顺序处理终结器列表，
那么这可能导致列表中第一个负责终结器的组件正在等待列表中靠后负责终结器的组件产生的信号（字段值、外部系统或其他），
从而导致死锁。在没有强制排序的情况下，终结者可以在它们之间自由排序，
并且不容易受到列表中排序更改的影响。</p>
</li>
<li>
<p><strong>managedFields</strong> ([]ManagedFieldsEntry)</p>
<p>managedFields 将 workflow-id 和版本映射到由该工作流管理的字段集。
这主要用于内部管理，用户通常不需要设置或理解该字段。
工作流可以是用户名、控制器名或特定应用路径的名称，如 “ci-cd”。
字段集始终存在于修改对象时工作流使用的版本。</p>
<p><a name=ManagedFieldsEntry></a></p>
<p>ManagedFieldsEntry 是一个 workflow-id，一个 FieldSet，也是该字段集适用的资源的组版本。</p>
<ul>
<li>
<p><strong>managedFields.apiVersion</strong> (string)</p>
<p>apiVersion 定义此字段集适用的资源的版本。
格式是 “group/version”，就像顶级 apiVersion 字段一样。
必须跟踪字段集的版本，因为它不能自动转换。</p>
</li>
<li>
<p><strong>managedFields.fieldsType</strong> (string)</p>
<p>FieldsType 是不同字段格式和版本的鉴别器。
目前只有一个可能的值：“FieldsV1”</p>
</li>
<li>
<p><strong>managedFields.fieldsV1</strong> (FieldsV1)</p>
<p>FieldsV1 包含类型 “FieldsV1” 中描述的第一个 JSON 版本格式。</p>
<p><a name=FieldsV1></a></p>
<p>FieldsV1 以 JSON 格式将一组字段存储在像 Trie 这样的数据结构中。</p>
<p>每个键或是 <code>.</code> 表示字段本身，并且始终映射到一个空集，
或是一个表示子字段或元素的字符串。该字符串将遵循以下四种格式之一：</p>
<ol>
<li><code>f:&lt;name></code>，其中 <code>&lt;name></code> 是结构中字段的名称，或映射中的键</li>
<li><code>v:&lt;value></code>，其中 <code>&lt;value></code> 是列表项的精确 json 格式值</li>
<li><code>i:&lt;index></code>，其中 <code>&lt;index></code> 是列表中项目的位置</li>
<li><code>k:&lt;keys></code>，其中 <code>&lt;keys></code> 是列表项的关键字段到其唯一值的映射
如果一个键映射到一个空的 Fields 值，则该键表示的字段是集合的一部分。</li>
</ol>
<p>确切的格式在 sigs.k8s.io/structured-merge-diff 中定义。</p>
</li>
<li>
<p><strong>managedFields.manager</strong> (string)</p>
<p>manager 是管理这些字段的工作流的标识符。</p>
</li>
<li>
<p><strong>managedFields.operation</strong> (string)</p>
<p>operation 是导致创建此 managedFields 表项的操作类型。
此字段的仅有合法值是 “Apply” 和 “Update”。</p>
</li>
<li>
<p><strong>managedFields.subresource</strong> (string)</p>
<p>subresource 是用于更新该对象的子资源的名称，如果对象是通过主资源更新的，则为空字符串。
该字段的值用于区分管理者，即使他们共享相同的名称。例如，状态更新将不同于使用相同管理者名称的常规更新。
请注意，apiVersion 字段与 subresource 字段无关，它始终对应于主资源的版本。</p>
</li>
<li>
<p><strong>managedFields.time</strong> (Time)</p>
<p>time 是设置这些字段的时间戳。如果 operation 为 “Apply”，则它应始终为空</p>
<p><a name=Time></a></p>
<p>time 是 time.Time 的包装类，支持正确地序列化为 YAML 和 JSON。
为 time 包提供的许多工厂方法提供了包装类。</p>
</li>
</ul>
</li>
<li>
<p><strong>ownerReferences</strong> ([]OwnerReference)</p>
<p>补丁策略：在键 <code>uid</code> 上执行合并操作</p>
<p>此对象所依赖的对象列表。如果列表中的所有对象都已被删除，则该对象将被垃圾回收。
如果此对象由控制器管理，则此列表中的条目将指向此控制器，controller 字段设置为 true。
管理控制器不能超过一个。</p>
<p><a name=OwnerReference></a></p>
<p>OwnerReference 包含足够可以让你识别拥有对象的信息。
拥有对象必须与依赖对象位于同一命名空间中，或者是集群作用域的，因此没有命名空间字段。</p>
<ul>
<li>
<p><strong>ownerReferences.apiVersion</strong> (string)，必选</p>
<p>被引用资源的 API 版本。</p>
</li>
<li>
<p><strong>ownerReferences.kind</strong> (string)，必选</p>
<p>被引用资源的类别。更多信息：https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds</p>
</li>
<li>
<p><strong>ownerReferences.name</strong> (string)，必选</p>
<p>被引用资源的名称。更多信息：http://kubernetes.io/docs/user-guide/identifiers#names</p>
</li>
<li>
<p><strong>ownerReferences.uid</strong> (string)，必选</p>
<p>被引用资源的 uid。更多信息：http://kubernetes.io/docs/user-guide/identifiers#uids</p>
</li>
<li>
<p><strong>ownerReferences.blockOwnerDeletion</strong> (boolean)</p>
<p>如果为 true，<strong>并且</strong>如果所有者具有 “foregroundDeletion” 终结器，
则在删除此引用之前，无法从键值存储中删除所有者。
默认为 false。要设置此字段，用户需要所有者的 “delete” 权限，
否则将返回 422 (Unprocessable Entity)。</p>
</li>
<li>
<p><strong>ownerReferences.controller</strong> (boolean)</p>
<p>如果为 true，则此引用指向管理的控制器。</p>
</li>
</ul>
</li>
</ul>
<h3 id=Read-only>只读字段</h3>
<ul>
<li>
<p><strong>creationTimestamp</strong> (Time)</p>
<p>creationTimestamp 是一个时间戳，表示创建此对象时的服务器时间。
不能保证在单独的操作中按发生前的顺序设置。
客户端不得设置此值。它以 RFC3339 形式表示，并采用 UTC。</p>
<p>由系统填充。只读。列表为空。更多信息：https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata</p>
<p><a name=Time></a></p>
<p>time 是 time.Time 的包装类，支持正确地序列化为 YAML 和 JSON。
为 time 包提供的许多工厂方法提供了包装类。</p>
</li>
<li>
<p><strong>deletionGracePeriodSeconds</strong> (int64)</p>
<p>此对象从系统中删除之前允许正常终止的秒数。
仅当设置了 deletionTimestamp 时才设置。
只能缩短。只读。</p>
</li>
<li>
<p><strong>deletionTimestamp</strong> (Time)</p>
<p>deletionTimestamp 是删除此资源的 RFC 3339 日期和时间。
该字段在用户请求优雅删除时由服务器设置，客户端不能直接设置。
一旦 finalizers 列表为空，该资源预计将在此字段中的时间之后被删除
（不再从资源列表中可见，并且无法通过名称访问）。
只要 finalizers 列表包含项目，就阻止删除。一旦设置了 deletionTimestamp，
该值可能不会被取消设置或在未来进一步设置，尽管它可能会缩短或在此时间之前可能会删除资源。
例如，用户可能要求在 30 秒内删除一个 Pod。
Kubelet 将通过向 Pod 中的容器发送优雅的终止信号来做出反应。
30 秒后，Kubelet 将向容器发送硬终止信号（SIGKILL），
并在清理后从 API 中删除 Pod。在网络存在分区的情况下，
此对象可能在此时间戳之后仍然存在，直到管理员或自动化进程可以确定资源已完全终止。
如果未设置，则未请求优雅删除该对象。</p>
<p>请求优雅删除时由系统填充。只读。更多信息：https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata</p>
<p><a name=Time></a></p>
<p>“Time 是 time.Time 的包装类，支持正确地序列化为 YAML 和 JSON。
为 time 包提供的许多工厂方法提供了包装类。”</p>
</li>
<li>
<p><strong>generation</strong> (int64)</p>
<p>表示期望状态的特定生成的序列号。由系统填充。只读。</p>
</li>
<li>
<p><strong>resourceVersion</strong> (string)</p>
<p>一个不透明的值，表示此对象的内部版本，客户端可以使用该值来确定对象是否已被更改。
可用于乐观并发、变更检测以及对资源或资源集的监听操作。
客户端必须将这些值视为不透明的，且未更改地传回服务器。
它们可能仅对特定资源或一组资源有效。</p>
<p>由系统填充。只读。客户端必须将值视为不透明。
更多信息：https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency</p>
</li>
<li>
<p><strong>selfLink</strong> (string)</p>
<p>selfLink 是表示此对象的 URL。由系统填充。只读。</p>
<p><strong>已弃用</strong>。Kubernetes 将在 1.20 版本中停止传播该字段，并计划在 1.21 版本中删除该字段。</p>
</li>
<li>
<p><strong>uid</strong> (string)</p>
<p>UID 是该对象在时间和空间上的唯一值。它通常由服务器在成功创建资源时生成，并且不允许使用 PUT 操作更改。</p>
<p>由系统填充。只读。更多信息：http://kubernetes.io/docs/user-guide/identifiers#uids</p>
</li>
</ul>
<h3 id=Ignored>忽略字段</h3>
<ul>
<li>
<p><strong>clusterName</strong> (string)</p>
<p>对象所属的集群的名称。这用于区分不同集群中具有相同名称和命名空间的资源。
该字段现在没有在任何地方设置，如果在创建或更新请求中设置，apiserver 将忽略它。</p>
</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-cf854f859540243f660c2798d641498c>5.9.8 - ObjectReference</h1>
<div class=lead>ObjectReference 包含足够的信息，可以让你检查或修改引用的对象。</div>
<p><code>import "k8s.io/api/core/v1"</code></p>
<p>ObjectReference包含足够的信息，允许你检查或修改引用的对象。</p>
<hr>
<ul>
<li>
<p><strong>apiVersion</strong> (string)</p>
<p>被引用者的 API 版本。</p>
</li>
<li>
<p><strong>fieldPath</strong> (string)</p>
<p>如果引用的是对象的某个对象是整个对象，则该字符串而不是应包含的 JSON/Go 字段有效访问语句，
例如<code>desiredState.manifest.containers[ 2 ]</code>。例如，如果对象引用针对的是 Pod 中的一个容器，
此字段取值类似于：<code>spec.containers{name}</code>（<code>name</code>指触发的容器的名称），
或者如果没有指定容器名称，<code>spec.containers[ 2 ]</code>（此Pod中索引为2的容器）。
选择这种只是为了有一些定义好的语法来引用对象的部分。</p>
</li>
<li>
<p><strong>kind</strong> (string)</p>
<p>被引用者的类别（kind）。 更多信息：https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md #types-kinds</p>
</li>
<li>
<p><strong>name</strong> (string)</p>
<p>被引用对象的名称。更多信息：https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names</p>
</li>
<li>
<p><strong>namespace</strong> (string)</p>
<p>被引用对象的名字空间。更多信息：https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/</p>
</li>
<li>
<p><strong>resourceVersion</strong> (string)</p>
<p>被引用对象的特定资源版本（如果有）。更多信息：https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency</p>
</li>
<li>
<p><strong>uid</strong> (string)</p>
<p>被引用对象的UID。更多信息：https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids</p>
</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-1997570a6710a3eaf78270f2e2535167>5.9.9 - Patch</h1>
<div class=lead>提供 Patch 是为了给 Kubernetes PATCH 请求正文提供一个具体的名称和类型。</div>
<p><code>import "k8s.io/apimachinery/pkg/apis/meta/v1"</code></p>
<p>提供 Patch 是为了给 Kubernetes PATCH 请求正文提供一个具体的名称和类型。</p>
<hr>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-51b0e3fdb6e89030bd9e49dbb990918c>5.9.10 - Quantity</h1>
<div class=lead>数量（Quantity）是数字的定点表示。</div>
<p><code>import "k8s.io/apimachinery/pkg/api/resource"</code></p>
<p>数量（Quantity）是数字的定点表示。
除了 String() 和 AsInt64() 的访问接口之外，
它以 JSON 和 YAML形式提供方便的打包和解包方法。</p>
<p>序列化格式如下：</p>
<pre><code>&lt;quantity&gt;        ::= &lt;signedNumber&gt;&lt;suffix&gt;
  (注意 &lt;suffix&gt; 可能为空, 例如 &lt;decimalSI&gt; 的 &quot;&quot; 情形。) &lt;/br&gt;
&lt;digit&gt;           ::= 0 | 1 | ... | 9 &lt;/br&gt;
&lt;digits&gt;          ::= &lt;digit&gt; | &lt;digit&gt;&lt;digits&gt; &lt;/br&gt;
&lt;number&gt;          ::= &lt;digits&gt; | &lt;digits&gt;.&lt;digits&gt; | &lt;digits&gt;. | .&lt;digits&gt; &lt;/br&gt;
&lt;sign&gt;            ::= &quot;+&quot; | &quot;-&quot; &lt;/br&gt;
&lt;signedNumber&gt;    ::= &lt;number&gt; | &lt;sign&gt;&lt;number&gt; &lt;/br&gt;
&lt;suffix&gt;          ::= &lt;binarySI&gt; | &lt;decimalExponent&gt; | &lt;decimalSI&gt; &lt;/br&gt;
&lt;binarySI&gt;        ::= Ki | Mi | Gi | Ti | Pi | Ei 
  (国际单位制度；查阅：http://physics.nist.gov/cuu/Units/binary.html) &lt;/br&gt;
&lt;decimalSI&gt;       ::= m | &quot;&quot; | k | M | G | T | P | E 
  (注意，1024 = 1ki 但 1000 = 1k；我没有选择大写。) &lt;/br&gt;
&lt;decimalExponent&gt; ::= &quot;e&quot; &lt;signedNumber&gt; | &quot;E&quot; &lt;signedNumber&gt; &lt;/br&gt;
</code></pre>
<p>无论使用三种指数形式中哪一种，没有数量可以表示大于 2<sup>63</sup>-1 的数，也不可能超过 3 个小数位。
更大或更精确的数字将被截断或向上取整。（例如：0.1m 将向上取整为 1m。）
如果将来我们需要更大或更小的数量，可能会扩展。</p>
<p>当从字符串解析数量时，它将记住它具有的后缀类型，并且在序列化时将再次使用相同类型。</p>
<p>在序列化之前，数量将以“规范形式”放置。这意味着指数或者后缀将被向上或向下调整（尾数相应增加或减少），并确保：</p>
<ol>
<li>没有精度丢失</li>
<li>不会输出小数数字</li>
<li>指数（或后缀）尽可能大。
除非数量是负数，否则将省略正负号。</li>
</ol>
<p>例如：</p>
<ul>
<li>1.5 将会被序列化成 “1500m”</li>
<li>1.5Gi 将会被序列化成 “1536Mi”</li>
</ul>
<p>请注意，数量永远<strong>不会</strong>在内部以浮点数表示。这是本设计的重中之重。</p>
<p>只要它们格式正确，非规范值仍将解析，但将以其规范形式重新输出。（所以应该总是使用规范形式，否则不要执行 diff 比较。）</p>
<p>这种格式旨在使得很难在不撰写某种特殊处理代码的情况下使用这些数字，进而希望实现者也使用定点实现。</p>
<hr>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-406fd6938a5a3283ee7a816347603389>5.9.11 - ResourceFieldSelector</h1>
<div class=lead>ResourceFieldSelector 表示容器资源（CPU，内存）及其输出格式。</div>
<p><code>import "k8s.io/api/core/v1"</code></p>
<p>ResourceFieldSelector 表示容器资源（CPU，内存）及其输出格式。</p>
<hr>
<ul>
<li>
<p><strong>resource</strong> (string), 必选</p>
<p>必选：选择的资源</p>
</li>
<li>
<p><strong>containerName</strong> (string)</p>
<p>容器名称：对卷必选，对环境变量可选</p>
</li>
<li>
<p><strong>divisor</strong> (<a href=https://kubernetes.io/zh/docs/reference/kubernetes-api/common-definitions/quantity/#Quantity>Quantity</a>)</p>
<p>指定所曝光资源的输出格式，默认值为“1”</p>
</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-b86f72d0a9c9625228b55ff79c154b63>5.9.12 - Status</h1>
<div class=lead>状态（Status）是不返回其他对象的调用的返回值。</div>
<p><code>import "k8s.io/apimachinery/pkg/apis/meta/v1"</code></p>
<p>状态（Status）是不返回其他对象的调用的返回值。</p>
<hr>
<ul>
<li>
<p><strong>apiVersion</strong> (string)</p>
<p>APIVersion 定义对象表示的版本化模式。
服务器应将已识别的模式转换为最新的内部值，并可能拒绝无法识别的值。
更多信息：https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources</p>
</li>
<li>
<p><strong>code</strong> (int32)</p>
<p>此状态的建议 HTTP 返回代码，如果未设置，则为 0。</p>
</li>
<li>
<p><strong>details</strong> (StatusDetails)</p>
<p>与原因（Reason）相关的扩展数据。每个原因都可以定义自己的扩展细节。
此字段是可选的，并且不保证返回的数据符合任何模式，除非由原因类型定义。</p>
<p><a name=StatusDetails></a></p>
<p><em>StatusDetails 是一组附加属性，可以由服务器设置以提供有关响应的附加信息。</em>
<em>状态对象的原因字段定义将设置哪些属性。</em>
<em>客户端必须忽略与每个属性的定义类型不匹配的字段，并且应该假定任何属性可能为空、无效或未定义。</em></p>
<ul>
<li>
<p><strong>details.causes</strong> ([]StatusCause)</p>
<p>Causes 数组包含与 StatusReason 故障相关的更多详细信息。
并非所有 StatusReasons 都可以提供详细的原因。</p>
<p><a name=StatusCause></a></p>
<p><em>StatusCause 提供有关 api.Status 失败的更多信息，包括遇到多个错误的情况。</em></p>
<ul>
<li>
<p><strong>details.causes.field</strong> (string)</p>
<p>导致此错误的资源字段，由其 JSON 序列化命名。
可能包括嵌套属性的点和后缀表示法。数组是从零开始索引的。
由于字段有多个错误，字段可能会在一系列原因中出现多次。可选。</p>
<p>示例：</p>
<ul>
<li>“name”：当前资源上的字段 “name”</li>
<li>“items[0].name”：“items” 中第一个数组条目上的字段 “name”</li>
</ul>
</li>
<li>
<p><strong>details.causes.message</strong> (string)</p>
<p>对错误原因的可读描述。该字段可以按原样呈现给读者。</p>
</li>
<li>
<p><strong>details.causes.reason</strong> (string)</p>
<p>错误原因的机器可读描述。如果此值为空，则没有可用信息。</p>
</li>
</ul>
</li>
<li>
<p><strong>details.group</strong> (string)</p>
<p>与状态 StatusReason 关联的资源的组属性。</p>
</li>
<li>
<p><strong>details.kind</strong> (string)</p>
<p>与状态 StatusReason 关联的资源的种类属性。
在某些操作上可能与请求的资源种类不同。
更多信息：https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds</p>
</li>
<li>
<p><strong>details.name</strong> (string)</p>
<p>与状态 StatusReason 关联的资源的名称属性（当有一个可以描述的名称时）。</p>
</li>
<li>
<p><strong>details.retryAfterSeconds</strong> (int32)</p>
<p>如果指定，则应重试操作前的时间（以秒为单位）。
一些错误可能表明客户端必须采取替代操作——对于这些错误，此字段可能指示在采取替代操作之前等待多长时间。</p>
</li>
<li>
<p><strong>details.uid</strong> (string)</p>
<p>资源的 UID（当有单个可以描述的资源时）。
更多信息：http://kubernetes.io/docs/user-guide/identifiers#uids</p>
</li>
</ul>
</li>
<li>
<p><strong>kind</strong> (string)</p>
<p>Kind 是一个字符串值，表示此对象表示的 REST 资源。
服务器可以从客户端提交请求的端点推断出这一点。
无法更新。驼峰式规则。
更多信息：https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds</p>
</li>
<li>
<p><strong>message</strong> (string)</p>
<p>此操作状态的人类可读描述。</p>
</li>
<li>
<p><strong>metadata</strong> (<a href=https://kubernetes.io/zh/docs/reference/kubernetes-api/common-definitions/list-meta/#ListMeta>ListMeta</a>)</p>
<p>标准列表元数据。
更多信息：https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds</p>
</li>
<li>
<p><strong>reason</strong> (string)</p>
<p>机器可读的说明，说明此操作为何处于“失败”状态。
如果此值为空，则没有可用信息。
Reason 澄清了 HTTP 状态代码，但不会覆盖它。</p>
</li>
<li>
<p><strong>status</strong> (string)</p>
<p>操作状态。“Success”或“Failure” 之一。
更多信息：https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status</p>
</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-ad5a39cd0d4233c0afb2a1daf17b95b3>5.9.13 - TypedLocalObjectReference</h1>
<div class=lead>TypedLocalObjectReference 包含足够的信息，可以让你在同一个名称空间中定位指定类型的引用对象。</div>
<p><code>import "k8s.io/api/core/v1"</code></p>
<p>TypedLocalObjectReference 包含足够的信息，可以让你在同一个名称空间中定位特定类型的引用对象。</p>
<hr>
<ul>
<li>
<p><strong>kind</strong> (string), 必需</p>
<p>Kind 是被引用的资源的类型</p>
</li>
<li>
<p><strong>name</strong> (string), 必需</p>
<p>Name 是被引用的资源的名称</p>
</li>
<li>
<p><strong>apiGroup</strong> (string)</p>
<p>APIGroup 是被引用资源的组。如果不指定 APIGroup，则指定的 Kind 必须在核心 API 组中。对于任何其它第三方类型，都需要 APIGroup。</p>
</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-6fbe4a9bf41cfee30909689bd978c45f>5.10 - 常用参数</h1>
<h2 id=allowWatchBookmarks>allowWatchBookmarks</h2>
<p>allowWatchBookmarks 字段请求类型为 BOOKMARK 的监视事件。
没有实现书签的服务器可能会忽略这个标志，并根据服务器的判断发送书签。
客户端不应该假设书签会在任何特定的时间间隔返回，也不应该假设服务器会在会话期间发送任何书签事件。
如果当前请求不是 watch 请求，则忽略该字段。</p>
<hr>
<h2 id=continue>continue</h2>
<p>当需要从服务器检索更多结果时，应该设置 continue 选项。由于这个值是服务器定义的，
客户端只能使用先前查询结果中具有相同查询参数的 continue 值(continue值除外)，
服务器可能拒绝它识别不到的 continue 值。
如果指定的 continue 值不再有效，无论是由于过期(通常是 5 到 15 分钟)
还是服务器上的配置更改，服务器将响应 "410 ResourceExpired" 错误和一个 continue 令牌。</p>
<p>如果客户端需要一个一致的列表，它必须在没有 continue 字段的情况下重新发起 list 请求。
否则，客户端可能会发送另一个带有 410 错误令牌的 list 请求，服务器将响应从下一个键开始的列表，
但列表数据来自最新的快照，这与之前
的列表结果不一致。第一个列表请求之后的对象创建，修改，或删除的对象将被包含在响应中，
只要他们的键是在“下一个键”之后。</p>
<p>当 watch 字段为 true 时，不支持此字段。客户端可以从服务器返回的最后一个 resourceVersion 值开始监视，就不会错过任何修改。</p>
<hr>
<h2 id=dryRun>dryRun</h2>
<p>表示不应该持久化所请求的修改。无效或无法识别的 dryRun 指令将导致错误响应，
并且服务器不再对请求进行进一步处理。有效值为:</p>
<ul>
<li>All: 将处理所有的演练阶段</li>
</ul>
<hr>
<h2 id=fieldManager>fieldManager</h2>
<p>fieldManager 是与进行这些更改的参与者或实体相关联的名称。
长度小于或128个字符且仅包含可打印字符，如 <a href=https://golang.org/pkg/unicode/#IsPrint>https://golang.org/pkg/unicode/#IsPrint</a> 所定义。</p>
<hr>
<h2 id=fieldSelector>fieldSelector</h2>
<p>根据返回对象的字段限制返回对象列表的选择器。默认为返回所有字段。</p>
<hr>
<h2 id=force>force</h2>
<p>Force 将“强制”应用请求。这意味着用户将重新获得他人拥有的冲突领域。
对于非应用补丁请求，Force 标志必须不设置。</p>
<hr>
<h2 id=gracePeriodSeconds>gracePeriodSeconds</h2>
<p>删除对象前的持续时间(秒数)。值必须为非负整数。取值为 0 表示立即删除。
如果该值为 nil，将使用指定类型的默认宽限期。如果没有指定，默认为每个对象的设置值。0 表示立即删除。</p>
<hr>
<h2 id=labelSelector>labelSelector</h2>
<p>通过标签限制返回对象列表的选择器。默认为返回所有对象。</p>
<hr>
<h2 id=limit>limit</h2>
<p>limit 是一个列表调用返回的最大响应数。如果有更多的条目，服务器会将列表元数据上的
'continue' 字段设置为一个值，该值可以用于相同的初始查询来检索下一组结果。</p>
<p>设置 limit 可能会在所有请求的对象被过滤掉的情况下返回少于请求的条目数量(下限为零)，
并且客户端应该只根据 continue 字段是否存在来确定是否有更多的结果可用。
服务器可能选择不支持 limit 参数，并将返回所有可用的结果。
如果指定了 limit 并且 continue 字段为空，客户端可能会认为没有更多的结果可用。
如果 watch 为 true，则不支持此字段。</p>
<p>服务器保证在使用 continue 时返回的对象将与不带 limit 的列表调用相同，——
也就是说，在发出第一个请求后所创建、修改或删除的对象将不包含在任何后续的继续请求中。</p>
<p>这有时被称为一致性快照，确保使用 limit 的客户端在分块接收非常大的结果的客户端能够看到所有可能的对象。
如果对象在分块列表期间被更新，则返回计算第一个列表结果时存在的对象版本。</p>
<hr>
<h2 id=namespace>namespace</h2>
<p>对象名称和身份验证范围，例如用于团队和项目。</p>
<hr>
<h2 id=pretty>pretty</h2>
<p>如果设置为 'true' ，那么输出是规范的打印。</p>
<hr>
<h2 id=propagationPolicy>propagationPolicy</h2>
<p>该字段决定是否以及如何执行垃圾收集。可以设置此字段或 OrphanDependents，但不能同时设置。
默认策略由 metadata.finalizers 和特定资源的默认策略设置决定。可接受的值是：</p>
<ul>
<li>'Orphan'：孤立依赖项；</li>
<li>'Background'：允许垃圾回收器后台删除依赖；</li>
<li>'Foreground'：一个级联策略，前台删除所有依赖项。</li>
</ul>
<hr>
<h2 id=resourceVersion>resourceVersion</h2>
<p>resourceVersion 对请求所针对的资源版本设置约束。
详情请参见 <a href=https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions>https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions</a>。</p>
<p>默认不设置</p>
<hr>
<h2 id=resourceVersionMatch>resourceVersionMatch</h2>
<p>resourceVersionMatch 字段决定如何将 resourceVersion 应用于列表调用。
强烈建议对设置了 resourceVersion 的列表调用设置 resourceVersion 匹配，
具体请参见 <a href=https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions>https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions</a>。</p>
<p>默认不设置</p>
<hr>
<h2 id=timeoutSeconds>timeoutSeconds</h2>
<p>list/watch 调用的超时秒数。这选项限制调用的持续时间，无论是否有活动。</p>
<hr>
<h2 id=watch>watch</h2>
<p>监视对所述资源的更改，并将其这类变更以添加、更新和删除通知流的形式返回。指定 resourceVersion。</p>
<hr>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-af7c1f9168ec67f957edc504f43faf9a>6 - Kubernetes 问题和安全</h1>
</div>
<div class=td-content>
<h1 id=pg-980c0542a3b195a20cfd4358792e2a38>6.1 - Kubernetes 问题追踪</h1>
<p>要报告安全问题，请遵循
<a href=/zh/docs/reference/issues-security/security/#report-a-vulnerability>Kubernetes 安全问题公开流程</a>。</p>
<p>使用 <a href=https://github.com/kubernetes/kubernetes/issues/>GitHub Issues</a>
跟踪 Kubernetes 编码工作和公开问题。</p>
<ul>
<li><a href="https://github.com/kubernetes/kubernetes/issues?utf8=%E2%9C%93&q=is%3Aissue+label%3Aarea%2Fsecurity+in%3Atitle+CVE">CVE 相关问题</a></li>
</ul>
<p>与安全性相关的公告请发送到
<a href=https://groups.google.com/forum/#!forum/kubernetes-security-announce>kubernetes-security-announce@googlegroups.com</a>
邮件列表。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-1f7dc06f1cc1ea2cdde4480e54d5fb34>6.2 - Kubernetes 安全和信息披露</h1>
<p>本页面介绍 Kubernetes 安全和信息披露相关的内容。</p>
<h2 id=安全公告>安全公告</h2>
<p>加入 <a href=https://groups.google.com/forum/#!forum/kubernetes-security-announce>kubernetes-security-announce</a> 组，以获取关于安全性和主要 API 公告的电子邮件。</p>
<h2 id=报告一个漏洞>报告一个漏洞</h2>
<p>我们非常感谢向 Kubernetes 开源社区报告漏洞的安全研究人员和用户。
所有的报告都由社区志愿者进行彻底调查。</p>
<p>如需报告，请连同安全细节以及预期的<a href=https://git.k8s.io/kubernetes/.github/ISSUE_TEMPLATE/bug-report.md>所有 Kubernetes bug 报告</a>
详细信息电子邮件到<a href=mailto:security@kubernetes.io>security@kubernetes.io</a>列表。</p>
<p>你还可以通过电子邮件向私有 <a href=mailto:security@kubernetes.io>security@kubernetes.io</a>
列表发送电子邮件，邮件中应该包含
<a href=https://github.com/kubernetes/kubernetes/blob/master/.github/ISSUE_TEMPLATE/bug-report.yaml>所有 Kubernetes 错误报告</a>
所需的详细信息。</p>
<p>你可以使用<a href=https://git.k8s.io/security/README.md#product-security-committee-psc>安全响应委员会成员</a>的
GPG 密钥加密你的发往邮件列表的邮件。揭示问题时不需要使用 GPG 来加密。</p>
<h3 id=我应该在什么时候报告漏洞>我应该在什么时候报告漏洞？</h3>
<ul>
<li>你认为在 Kubernetes 中发现了一个潜在的安全漏洞</li>
<li>你不确定漏洞如何影响 Kubernetes</li>
<li>你认为你在 Kubernetes 依赖的另一个项目中发现了一个漏洞</li>
<li>对于具有漏洞报告和披露流程的项目，请直接在该项目处报告</li>
</ul>
<h3 id=我什么时候不应该报告漏洞>我什么时候不应该报告漏洞？</h3>
<ul>
<li>你需要帮助调整 Kubernetes 组件的安全性</li>
<li>你需要帮助应用与安全相关的更新</li>
<li>你的问题与安全无关</li>
</ul>
<h2 id=安全漏洞响应>安全漏洞响应</h2>
<p>每个报告在 3 个工作日内由安全响应委员会成员确认和分析。这将启动<a href=https://git.k8s.io/sig-release/security-release-process-documentation/security-release-process.md#disclosures>安全发布过程</a>。</p>
<p>与安全响应委员会共享的任何漏洞信息都保留在 Kubernetes 项目中，除非有必要修复该问题，否则不会传播到其他项目。</p>
<p>随着安全问题从分类、识别修复、发布计划等方面的进展，我们将不断更新报告。</p>
<h2 id=公开披露时间>公开披露时间</h2>
<p>公开披露日期由 Kubernetes 安全响应委员会和 bug 提交者协商。
我们倾向于在能够为用户提供缓解措施之后尽快完全披露该 bug。</p>
<p>当 bug 或其修复还没有被完全理解，解决方案没有经过良好的测试，或者为了处理供应商协调问题时，延迟披露是合理的。</p>
<p>信息披露的时间范围从即时（尤其是已经公开的）到几周。作为一个基本的约定，我们希望报告日期到披露日期的间隔是 7 天。在设置披露日期时，Kubernetes 产品安全团队拥有最终决定权。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-75e3b4b5f680fdd081dc8af8060a2bf7>7 - 节点参考信息</h1>
</div>
<div class=td-content>
<h1 id=pg-26e96c9d268f9c39dfc525b98f477a12>7.1 - 关于 dockershim 移除和使用兼容 CRI 运行时的外部文章</h1>
<p>这是有关以下内容的文章列表：</p>
<ul>
<li>Kubernetes 弃用和删除 <em>dockershim</em></li>
<li>使用兼容 CRI 的容器运行时</li>
</ul>
<h2 id=首要来源>首要来源</h2>
<ul>
<li>
<p><a href=/blog/2020/12/02/dockershim-faq/>Kubernetes 博客: “Dockershim 弃用常见问题解答”, 2020/12/02</a></p>
</li>
<li>
<p><a href=/zh/docs/tasks/administer-cluster/migrating-from-dockershim/>Kubernetes 文档：“从 dockershim 迁移”</a></p>
</li>
<li>
<p><a href=/zh/docs/setup/production-environment/container-runtimes/>Kubernetes 文档：“容器运行时”</a></p>
</li>
<li>
<p><a href=https://github.com/kubernetes/enhancements/issues/2221>Kubernetes 增强提问: “从 kubelet 中删除 dockershim” (<code>kubernetes/enhancements#2221</code>)</a></p>
</li>
<li>
<p><a href=https://github.com/kubernetes/enhancements/blob/master/keps/sig-node/2221-remove-dockershim/README.md>Kubernetes 增强建议：“KEP-2221: 从 kubelet 中删除 dockershim”</a></p>
</li>
<li>
<p><a href=/blog/2021/11/12/are-you-ready-for-dockershim-removal/>Kubernetes 博客: “移除 Dockershim 即将到来。你准备好了吗？”, 2021/11/12</a></p>
</li>
</ul>
<h2 id=次要来源>次要来源</h2>
<ul>
<li>
<p><a href=https://www.docker.com/blog/what-developers-need-to-know-about-docker-docker-engine-and-kubernetes-v1-20/>Docker.com 博客：“开发人员需要了解的关于 Docker、Docker Engine 和 Kubernetes v1.20 的哪些知识”，2020/12/04</a></p>
</li>
<li>
<p><a href=https://www.tripwire.com/state-of-security/security-data-protection/cloud/how-dockershim-forthcoming-deprecation-affects-your-kubernetes/>Tripwire.com：“Dockershim 即将弃用如何影响你的 Kubernetes”</a></p>
</li>
<li>
<p><a href=https://docs.aws.amazon.com/eks/latest/userguide/dockershim-deprecation.html>Amazon EKS 文档：“Dockershim 弃用”</a></p>
</li>
<li>
<p><a href=https://youtu.be/fl7_4hjT52g>YouTube 上的 “Google 开源”频道：“与 Google 一起学习 Kubernetes - 从 Dockershim 迁移到 Containerd”</a></p>
</li>
<li>
<p><a href=https://www.mirantis.com/blog/the-future-of-dockershim-is-cri-dockerd/>Mirantis 博客：“Dockershim 的未来是 cri-dockerd”，2021/04/21</a></p>
</li>
<li>
<p><a href=https://github.com/Mirantis/cri-dockerd>Github.com：“Mirantis/cri-dockerd” 仓库</a></p>
</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-5bbbc5163b35431b3bff029ab9ec57d3>8 - 安装工具</h1>
</div>
<div class=td-content>
<h1 id=pg-f351ced098abbb076bc8c4be1053672b>8.1 - Kubeadm</h1>
<img src=/images/kubeadm-stacked-color.png align=right width=150px>
<p>Kubeadm 是一个提供了 <code>kubeadm init</code> 和 <code>kubeadm join</code> 的工具，
作为创建 Kubernetes 集群的 “快捷途径” 的最佳实践。</p>
<p>kubeadm 通过执行必要的操作来启动和运行最小可用集群。
按照设计，它只关注启动引导，而非配置机器。同样的，
安装各种 “锦上添花” 的扩展，例如 Kubernetes Dashboard、
监控方案、以及特定云平台的扩展，都不在讨论范围内。</p>
<p>相反，我们希望在 kubeadm 之上构建更高级别以及更加合规的工具，
理想情况下，使用 kubeadm 作为所有部署工作的基准将会更加易于创建一致性集群。</p>
<h2 id=如何安装>如何安装</h2>
<p>要安装 kubeadm, 请查阅
<a href=/zh/docs/setup/production-environment/tools/kubeadm/install-kubeadm/>安装指南</a>.</p>
<h2 id=what-s-next>What's next</h2>
<ul>
<li><a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-init>kubeadm init</a>
用于搭建控制平面节点</li>
<li><a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-join>kubeadm join</a>
用于搭建工作节点并将其加入到集群中</li>
<li><a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-upgrade>kubeadm upgrade</a>
用于升级 Kubernetes 集群到新版本</li>
<li><a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-config>kubeadm config</a>
如果你使用了 v1.7.x 或更低版本的 kubeadm 版本初始化你的集群，则使用
<code>kubeadm upgrade</code> 来配置你的集群</li>
<li><a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-token>kubeadm token</a>
用于管理 <code>kubeadm join</code> 使用的令牌</li>
<li><a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-reset>kubeadm reset</a>
用于恢复通过 <code>kubeadm init</code> 或者 <code>kubeadm join</code> 命令对节点进行的任何变更</li>
<li><a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-certs>kubeadm certs</a>
用于管理 Kubernetes 证书</li>
<li><a href=/docs/reference/setup-tools/kubeadm/kubeadm-kubeconfig>kubeadm kubeconfig</a>
用于管理 kubeconfig 文件</li>
<li><a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-version>kubeadm version</a>
用于打印 kubeadm 的版本信息</li>
<li><a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-alpha>kubeadm alpha</a>
用于预览一组可用于收集社区反馈的特性</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-36c22b52e8447eb3d2452d4f56fbea9b>8.1.1 - 创建 Kubeadm</h1>
</div>
<div class=td-content>
<h1 id=pg-fd3ad295c1f10bfa333f841bbdffba81>8.1.1.1 - </h1>
<p>kubeadm: 轻松创建一个安全的 Kubernetes 集群</p>
<h3 id=摘要>摘要</h3>
<pre><code>┌──────────────────────────────────────────────────────────┐
│ KUBEADM                                                  │
│ 轻松创建一个安全的 Kubernetes 集群                       │
│                                                          │
│ 给我们反馈意见的地址：                                   │
│ https://github.com/kubernetes/kubeadm/issues             │
└──────────────────────────────────────────────────────────┘
</code></pre>
<p>用途示例：</p>
<p>创建一个有两台机器的集群，包含一个主节点（用来控制集群），和一个工作节点（运行您的工作负载，像 Pod 和 Deployment）。</p>
<pre><code>┌──────────────────────────────────────────────────────────┐
│ 在第一台机器上：                                         │
├──────────────────────────────────────────────────────────┤
│ control-plane# kubeadm init                              │
└──────────────────────────────────────────────────────────┘

┌──────────────────────────────────────────────────────────┐
│ 在第二台机器上：                                         │
├──────────────────────────────────────────────────────────┤
│ worker# kubeadm join &amp;lt;arguments-returned-from-init&amp;gt;│
└──────────────────────────────────────────────────────────┘
</code></pre><p>您可以重复第二步，向集群添加更多机器。</p>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
<p>kubeadm 操作的帮助信息<p>
</td>
</tr>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
<p>[实验] 指向 '真实' 宿主机根文件系统的路径。<p>
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-8df9aba508b2736a6712ef46227eea7d>8.1.1.2 - </h1>
<p>处理 Kubernetes 证书的相关命令</p>
<h3 id=概要>概要</h3>
<p>处理 Kubernetes 证书相关的命令</p>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>certs 命令的帮助</p></td>
</tr>
</tbody>
</table>
<h3 id=继承于父命令的选项>继承于父命令的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>[实验] 到'真实'主机根文件系统的路径。</p></td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-018648dfc6f28bc9b969f45af0563cae>8.1.1.3 - </h1>
<p>生成证书密钥</p>
<h3 id=概要>概要</h3>
<p>该命令将打印出可以与 "init" 命令一起使用的安全的随机生成的证书密钥。</p>
<p>你也可以使用 <code>kubeadm init --upload-certs</code> 而无需指定证书密钥；
命令将为你生成并打印一个证书密钥。</p>
<pre><code>kubeadm certs certificate-key [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
<p>
certificate-key 操作的帮助命令
</p>
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
<p>
[实验] 到 '真实' 主机根文件系统的路径。
</p>
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-4a1ff27cdf01c1c47d034278048e776b>8.1.1.4 - </h1>
<h3 id=概要>概要</h3>
<p>检查 kubeadm 管理的本地 PKI 中证书的到期时间。</p>
<pre><code>kubeadm certs check-expiration [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值: "/etc/kubernetes/pki"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>保存证书的路径</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>kubeadm 配置文件的路径</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>check-expiration 的帮助命令</td>
</tr>
</tbody>
</table>
<h3 id=继承于父命令的选项>继承于父命令的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>[实验] 到'真实'主机根文件系统的路径。</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-5d6b2999153cd86f56329534249fc4ec>8.1.1.5 - </h1>
<p>为运行控制平面所需的所有证书生成密钥和证书签名请求（CSR）。该命令会生成部分 kubeconfig 文件，
其中 "users > user > client-key-data" 字段包含私钥数据，并为每个 kubeconfig
文件创建一个随附的 ".csr" 文件。</p>
<p>此命令设计用于
<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubeadm/kubeadm-certs/#external-ca-mode>Kubeadm 外部 CA 模式</a>。
它生成你可以提交给外部证书颁发机构进行签名的 CSR。</p>
<p>应使用 ".crt" 作为文件扩展名将 PEM 编码的签名证书与密钥文件一起保存。
或者，对于 kubeconfig 文件，PEM 编码的签名证书应使用 base64 编码，
并添加到 "users > user > client-certificate-data" 字段。</p>
<pre><code>kubeadm certs generate-csr [flags]
</code></pre>
<h3 id=示例>示例</h3>
<pre><code># 以下命令将为所有控制平面证书和 kubeconfig 文件生成密钥和 CSR :
kubeadm certs generate-csr --kubeconfig-dir /tmp/etc-k8s --cert-dir /tmp/etc-k8s/pki
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--cert-dir string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>保存证书的路径</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>kubeadm 配置文件的路径。</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>generate-csr 命令的帮助</td>
</tr>
<tr>
<td colspan=2>--kubeconfig-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>保存 kubeconfig 文件的路径。</td>
</tr>
</tbody>
</table>
<h3 id=继承于父命令的选项>继承于父命令的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>[实验] 到'真实'主机根文件系统的路径。</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-adb5eecdc351074cc2e0cc2b1b4f04a8>8.1.1.6 - </h1>
<p>为 Kubernetes 集群更新证书</p>
<h3 id=概要>概要</h3>
<p>此命令并非设计用来单独运行。请参阅可用子命令列表。</p>
<pre><code>kubeadm certs renew [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
<p>
renew 操作的帮助命令
</p>
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
<p>
[实验] 到 '真实' 主机根文件系统的路径。
</p>
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-df4c2dc6cba0be90d8d7de2fca9b87f7>8.1.1.7 - </h1>
<h3 id=概要>概要</h3>
<p>续订 kubeconfig 文件中嵌入的证书，供管理员 和 kubeadm 自身使用。</p>
<p>无论证书的到期日期如何，续订都是无条件进行的；SAN 等额外属性将基于现有文件/证书，因此无需重新提供它们。</p>
<p>默认情况下，续订会尝试使用由 kubeadm 管理的本地 PKI 中的证书机构；作为替代方案，
也可以使用 K8s 证书 API 进行证书续订，或者（作为最后一种选择）生成 CSR 请求。</p>
<p>续订后，为了使更改生效，需要重新启动控制平面组件，并最终重新分发更新的证书，以防证书文件在其他地方使用。</p>
<pre><code>kubeadm certs renew admin.conf [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
保存证书的路径。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--csr-dir string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
CSR 和私钥的输出路径
</td>
</tr>
<tr>
<td colspan=2>--csr-only</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
创建 CSR 而不是生成证书
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
admin.conf 子操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
与集群通信时使用的 kubeconfig 文件。
如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan=2>--use-api</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
使用 Kubernetes 证书 API 续订证书
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-6d6746e8ac1f1602f7dab1056b27e5c2>8.1.1.8 - </h1>
<h3 id=概要>概要</h3>
<p>续订运行控制平面所需的所有已知证书。续订是无条件进行的，与到期日期无关。续订也可以单独运行以进行更多控制。</p>
<pre><code>kubeadm certs renew all [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
存储证书的路径。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--csr-dir string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
输出 CSR 和私钥的路径
</td>
</tr>
<tr>
<td colspan=2>--csr-only</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
创建 CSR 而不是生成证书
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
all 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
与集群通信时使用的 kubeconfig 文件。
如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan=2>--use-api</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
使用 Kubernetes 证书 API 续订证书
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-7449c7fa06f25b967cf531e937b0f4b2>8.1.1.9 - </h1>
<h3 id=概要>概要</h3>
<p>续订 apiserver 用于访问 etcd 的证书。</p>
<p>无论证书的到期日期如何，续订都会无条件地进行；SAN 等额外属性将基于现有文件/证书，因此无需重新提供它们。</p>
<p>默认情况下，续订尝试使用在 kubeadm 所管理的本地 PKI 中的证书颁发机构；作为替代方案，
可以使用 K8s 证书 API 进行证书更新，或者作为最后一个选择来生成 CSR 请求。</p>
<p>续订后，为了使更改生效，需要重新启动控制平面组件，并最终重新分发更新的证书，以防文件在其他地方使用。</p>
<pre><code>kubeadm certs renew apiserver-etcd-client [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
存储证书的路径。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--csr-dir string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
输出 CSR 和私钥的路径
</td>
</tr>
<tr>
<td colspan=2>--csr-only</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
创建 CSR 而不是生成证书
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
apiserver-etcd-client 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
与集群通信时使用的 kubeconfig 文件。
如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan=2>--use-api</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
使用 Kubernetes 证书 API 续订证书
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-b5c6ae77d3be9bd358c68667006cfc18>8.1.1.10 - </h1>
<h3 id=概要>概要</h3>
<p>续订 apiserver 用于连接 kubelet 的证书。</p>
<p>无论证书的到期日期如何，续订都会无条件地进行；SAN 等额外属性将基于现有文件/证书，因此无需重新提供它们。</p>
<p>默认情况下，续订尝试使用位于 kubeadm 所管理的本地 PKI 中的证书颁发机构；作为替代方案，
也可能调用 K8s 证书 API 进行证书更新；亦或者，作为最后一个选择，生成 CSR 请求。</p>
<p>续订后，为了使更改生效，需要重新启动控制平面组件，并最终重新分发更新的证书，以防文件在其他地方使用。</p>
<pre><code>kubeadm certs renew apiserver-kubelet-client [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
存储证书的路径。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--csr-dir string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
输出 CSR 和私钥的路径
</td>
</tr>
<tr>
<td colspan=2>--csr-only</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
创建 CSR 而不是生成证书
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
apiserver-kubelet-client 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
与集群通信时使用的 kubeconfig 文件。
如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan=2>--use-api</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
使用 Kubernetes 证书 API 续订证书
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-4f804e59ec1739e733807d2b591d771f>8.1.1.11 - </h1>
<h3 id=概要>概要</h3>
<p>续订用于提供 Kubernetes API 的证书。</p>
<p>无论证书的到期日期如何，续订都会无条件地进行；SAN 等额外属性将基于现有文件/证书，因此无需重新提供它们。</p>
<p>默认情况下，续订尝试在 kubeadm 管理的本地 PKI 中使用证书颁发机构；作为替代方案，
可以使用 K8s 证书 API 进行证书更新，或者作为最后一个选择来生成 CSR 请求。</p>
<p>续订后，为了使更改生效，需要重新启动控制平面组件，并最终重新分发更新的证书，以防文件在其他地方使用。</p>
<pre><code>kubeadm certs renew apiserver [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
保存证书的路径。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--csr-dir string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
CSR 和私钥的输出路径
</td>
</tr>
<tr>
<td colspan=2>--csr-only</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
创建 CSR 而不是生成证书
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
apiserver 子操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
与集群通信时使用的 kubeconfig 文件。
如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan=2>--use-api</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
使用 Kubernetes 证书 API 续订证书
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-f5cf8caa95834803b133d53c321ab4a9>8.1.1.12 - </h1>
<h3 id=概要>概要</h3>
<p>续订 kubeconfig 文件中嵌入的证书，以供控制器管理器（Controller Manager）使用。</p>
<p>续订无条件地进行，与证书的到期日期无关；SAN 等额外属性将基于现有的文件/证书，因此无需重新提供它们。</p>
<p>默认情况下，续订会尝试使用 kubeadm 管理的本地 PKI 中的证书颁发机构；作为替代方案，
可以使用 K8s 证书 API 进行证书续订；亦或者，作为最后一种选择，生成 CSR 请求。</p>
<p>续订后，为了使更改生效，需要重新启动控制平面组件，并最终重新分发更新的证书，以防文件在其他地方使用。</p>
<pre><code>kubeadm alpha renew controller-manager.conf [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
保存证书的路径。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--csr-dir string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
CSR 和私钥的输出路径
</td>
</tr>
<tr>
<td colspan=2>--csr-only</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
创建 CSR 而不是生成证书
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
controller-manager.conf 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
与集群通信时使用的 kubeconfig 文件。
如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan=2>--use-api</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
使用 Kubernetes 证书 API 续订证书
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-ee770858e2bb767b79d572b4882af656>8.1.1.13 - </h1>
<h3 id=概要>概要</h3>
<p>续订存活态探针的证书，用于对 etcd 执行健康检查。</p>
<p>无论证书的到期日期如何，续订都是无条件进行的；SAN 等额外属性将基于现有文件/证书，因此无需重新提供它们。</p>
<p>默认情况下，续订会尝试使用由 kubeadm 管理的本地 PKI 中的证书机构；作为替代方案，
也可以使用 K8s certificate API 进行证书续订，或者（作为最后一种选择）生成 CSR 请求。</p>
<p>续订后，为了使更改生效，需要重新启动控制平面组件，并最终重新分发更新的证书，以防证书文件在其他地方使用。</p>
<pre><code>kubeadm certs renew etcd-healthcheck-client [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
保存证书的路径。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--csr-dir string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
CSR 和私钥的输出路径
</td>
</tr>
<tr>
<td colspan=2>--csr-only</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
创建 CSR 而不是生成证书
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
etcd-healthcheck-client 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
与集群通信时使用的 kubeconfig 文件。
如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan=2>--use-api</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
使用 Kubernetes 证书 API 续订证书
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-7484bf11b6183f4c329b1f66734cc886>8.1.1.14 - </h1>
<h3 id=概要>概要</h3>
<p>续订 etcd 节点间用来相互通信的证书。</p>
<p>无论证书的到期日期如何，续订都是无条件进行的；SAN 等额外属性将基于现有文件/证书，因此无需重新提供它们。</p>
<p>默认情况下，续订会尝试使用由 kubeadm 管理的本地 PKI 中的证书机构；
作为替代方案，也可以使用 K8s certificate API 进行证书续订，或者（作为最后一种选择）生成 CSR 请求。</p>
<p>续订后，为了使更改生效，需要重新启动控制平面组件，并最终重新分发更新的证书，以防证书文件在其他地方使用。</p>
<pre><code>kubeadm certs renew etcd-peer [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
保存证书的路径。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--csr-dir string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
CSR 和私钥的输出路径
</td>
</tr>
<tr>
<td colspan=2>--csr-only</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
创建 CSR 而不是生成证书
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
etcd-peer 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
与集群通信时使用的 kubeconfig 文件。
如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan=2>--use-api</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
使用 Kubernetes 证书 API 续订证书
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-bf444d915ab856dba693c36294c5427b>8.1.1.15 - </h1>
<h3 id=概要>概要</h3>
<p>续订用于提供 etcd 服务的证书。</p>
<p>续订无条件地进行，与证书的到期日期无关；SAN 等额外属性将基于现有的文件/证书，因此无需重新提供它们。</p>
<p>默认情况下，续订会尝试在 kubeadm 管理的本地 PKI 中使用证书颁发机构；作为替代方案，
可以使用 K8s 证书 API 进行证书续订，或者作为最后一种选择来生成 CSR 请求。</p>
<p>续订后，为了使更改生效，需要重新启动控制平面组件，并最终重新分发更新的证书，以防文件在其他地方使用。</p>
<pre><code>kubeadm certs renew etcd-server [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
保存证书的路径。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--csr-dir string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
CSR 和私钥的输出路径
</td>
</tr>
<tr>
<td colspan=2>--csr-only</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
创建 CSR 而不是生成证书
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
etcd-server 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
与集群通信时使用的 kubeconfig 文件。
如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan=2>--use-api</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
使用 Kubernetes 证书 API 续订证书
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-f5c087e087714c5290b4967dd7924b3b>8.1.1.16 - </h1>
<h3 id=概要>概要</h3>
<p>为前端代理客户端续订证书。</p>
<p>无论证书的到期日期如何，续订都会无条件地进行；SAN 等额外属性将基于现有文件/证书，因此无需重新提供它们。</p>
<p>默认情况下，续订尝试使用位于 kubeadm 所管理的本地 PKI 中的证书颁发机构；作为替代方案，
也可以使用 K8s 证书 API 进行证书续订；亦或者，作为最后一种方案，生成 CSR 请求。</p>
<p>续订后，为了使更改生效，需要重新启动控制平面组件，并最终重新分发更新的证书，以防文件在其他地方使用。</p>
<pre><code>kubeadm certs renew front-proxy-client [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
存储证书的路径。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--csr-dir string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
输出 CSR 和私钥的路径
</td>
</tr>
<tr>
<td colspan=2>--csr-only</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
创建 CSR 而不是生成证书
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
front-proxy-client 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
与集群通信时使用的 kubeconfig 文件。
如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan=2>--use-api</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
使用 Kubernetes 证书 API 续订证书
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-20703ce1c236264ad78cb1ad7244723e>8.1.1.17 - </h1>
<h3 id=概要>概要</h3>
<p>续订 kubeconfig 文件中嵌入的证书，以供调度管理器使用。</p>
<p>续订无条件地进行，与证书的到期日期无关；SAN 等额外属性将基于现有的文件/证书，因此无需重新提供它们。</p>
<p>默认情况下，续订会尝试使用在 kubeadm 所管理的本地 PKI 中的证书颁发机构；作为替代方案，
也可以使用 K8s 证书 API 进行证书续订；亦或者，作为最后一种选择，生成 CSR 请求。</p>
<p>续订后，为了使更改生效，需要重新启动控制平面组件，并最终重新分发更新的证书，以防文件在其他地方使用。</p>
<pre><code>kubeadm certs renew scheduler.conf [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
保存证书的路径。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--csr-dir string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
CSR 和私钥的输出路径
</td>
</tr>
<tr>
<td colspan=2>--csr-only</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
创建 CSR 而不是生成证书
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
scheduler.conf 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
与集群通信时使用的 kubeconfig 文件。
如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan=2>--use-api</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
使用 Kubernetes 证书 API 续订证书
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-49aaa494ef75de67609987a43e5ee520>8.1.1.18 - </h1>
<h3 id=概要>概要</h3>
<p>为指定的 shell（bash 或 zsh）输出 shell 自动补全代码。
必须激活 shell 代码以提供交互式 kubeadm 命令补全。这可以通过加载 .bash_profile 文件完成。</p>
<p>注意: 此功能依赖于 <code>bash-completion</code> 框架。</p>
<p>在 Mac 上使用 homebrew 安装:</p>
<pre><code>brew install bash-completion
</code></pre><p>安装后，必须激活 bash_completion。这可以通过在 .bash_profile 文件中添加下面的命令行来完成</p>
<pre><code>source $(brew --prefix)/etc/bash_completion
</code></pre>
<p>如果在 Linux 上没有安装 bash-completion，请通过您的发行版的包管理器安装 <code>bash-completion</code> 软件包。</p>
<p>zsh 用户注意事项：[1] zsh 自动补全仅在 >=v5.2 及以上版本中支持。</p>
<pre><code>kubeadm completion SHELL [flags]
</code></pre>
<h3 id=示例>示例</h3>
<pre><code># 在 Mac 上使用 homebrew 安装 bash completion
brew install bash-completion
printf &quot;\n# Bash completion support\nsource $(brew --prefix)/etc/bash_completion\n&quot; &gt;&gt; $HOME/.bash_profile
source $HOME/.bash_profile

# 将 bash 版本的 kubeadm 自动补全代码加载到当前 shell 中
source &lt;(kubeadm completion bash)

# 将 bash 自动补全完成代码写入文件并且从 .bash_profile 文件加载它
printf &quot;\n# Kubeadm shell completion\nsource '$HOME/.kube/kubeadm_completion.bash.inc'\n&quot; &gt;&gt; $HOME/.bash_profile
source $HOME/.bash_profile

# 将 zsh 版本的 kubeadm 自动补全代码加载到当前 shell 中
source &lt;(kubeadm completion zsh)
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
completion 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-d63311c16e6468f5a5940aadd902faa7>8.1.1.19 - </h1>
<h3 id=概要>概要</h3>
<p>kube-system 命名空间里有一个名为 "kubeadm-config" 的 ConfigMap，kubeadm 用它来存储有关集群的内部配置。
kubeadm CLI v1.8.0+ 通过一个配置自动创建该 ConfigMap，这个配置是和 'kubeadm init' 共用的。
但是您如果使用 kubeadm v1.7.x 或更低的版本初始化集群，那么必须使用 'config upload' 命令创建该 ConfigMap。
这是必要的操作，目的是使 'kubeadm upgrade' 能够正确地配置升级后的集群。</p>
<pre><code>kubeadm config [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
config 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
用于和集群通信的 kubeconfig 文件。如果它没有被设置，那么 kubeadm 将会搜索一个已经存在于标准路径的 kubeconfig 文件
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-6678a79b85306310066616185153377d>8.1.1.20 - </h1>
<h3 id=概要>概要</h3>
<p>与 kubeadm 使用的容器镜像交互。</p>
<pre><code>kubeadm config images [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
images 的帮助命令
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
用于和集群通信的 kubeconfig 文件。如果它没有被设置，那么 kubeadm 将会搜索一个已经存在于标准路径的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-8f73e208cc67d221165f6294393881a7>8.1.1.21 - </h1>
<h3 id=概要>概要</h3>
<p>打印 kubeadm 要使用的镜像列表。配置文件用于自定义任何镜像或镜像存储库。</p>
<pre><code>kubeadm config images list [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>
--allow-missing-template-keys&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：true
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果设置为 true，则在模板中缺少字段或哈希表的键时忽略模板中的任何错误。
仅适用于 golang 和 jsonpath 输出格式。
</td>
</tr>
<tr>
<td colspan=2>
-o, --experimental-output string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："text"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
输出格式：text|json|yaml|go-template|go-template-file|template|templatefile|jsonpath|jsonpath-as-json|jsonpath-file 其中之一
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--feature-gates string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
一组键值对（key=value），用于描述各种特征。选项是：
<br>Auditing=true|false (ALPHA - 默认=false)
<br>CoreDNS=true|false (默认=true)
<br>DynamicKubeletConfig=true|false (BETA - 默认=false)
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
list 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："k8s.gcr.io"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
选择要从中拉取控制平面镜像的容器仓库
</td>
</tr>
<tr>
<td colspan=2>
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面选择一个特定的 Kubernetes 版本
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
用于和集群通信的 kubeconfig 文件。如果它没有被设置，那么 kubeadm 将会搜索一个已经存在于标准路径的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-9aec3477159c105a46f4479de1c21418>8.1.1.22 - </h1>
<h3 id=概要>概要</h3>
<p>拉取 kubeadm 使用的镜像。</p>
<pre><code>kubeadm config images pull [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--cri-socket string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
要连接的 CRI 套接字的路径。如果为空，则 kubeadm 将尝试自动检测此值；仅当安装了多个 CRI 或具有非标准 CRI 插槽时，才使用此选项。
</td>
</tr>
<tr>
<td colspan=2>--feature-gates string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
一系列键值对（key=value），用于描述各种特征。可选项是：<br>IPv6DualStack=true|false (ALPHA - 默认值=false)
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
pull 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："k8s.gcr.io"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
选择用于拉取控制平面镜像的容器仓库
</td>
</tr>
<tr>
<td colspan=2>
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面选择一个特定的 Kubernetes 版本。
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
用于和集群通信的 kubeconfig 文件。如果它没有被设置，那么 kubeadm 将会搜索一个已经存在于标准路径的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-045e41c28798930e21f77a90c3a90263>8.1.1.23 - </h1>
<h3 id=概要>概要</h3>
<p>此命令允许您在 CLI 工具中将本地旧版本的配置对象转换为最新支持的版本，而无需变更集群中的任何内容。在此版本的 kubeadm 中，支持以下 API 版本：</p>
<ul>
<li>kubeadm.k8s.io/v1beta2</li>
</ul>
<p>因此，无论您在此处传递 --old-config 参数的版本是什么，当写入到 stdout 或 --new-config （如果已指定）时，
都会读取、反序列化、默认、转换、验证和重新序列化 API 对象。</p>
<p>换句话说，如果您将此文件传递给 "kubeadm init"，则该命令的输出就是 kubeadm 实际上在内部读取的内容。</p>
<pre><code>kubeadm config migrate [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
migrate 操作的帮助信息
</td>
</tr>
<tr>
<td colspan=2>--new-config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
使用新的 API 版本生成的 kubeadm 配置文件的路径。这个路径是可选的。如果没有指定，输出将被写到 stdout。
</td>
</tr>
<tr>
<td colspan=2>--old-config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
使用旧 API 版本且应转换的 kubeadm 配置文件的路径。此参数是必需的。
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
用于和集群通信的 kubeconfig 文件。如果未设置，那么 kubeadm 将会搜索一个已经存在于标准路径的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-e7d83478123771ad14f475ee44440303>8.1.1.24 - </h1>
<p>打印配置</p>
<h3 id=概要>概要</h3>
<p>此命令打印子命令所提供的配置信息。
相关细节可参阅: <a href=https://pkg.go.dev/k8s.io/kubernetes/cmd/kubeadm/app/apis/kubeadm#section-directories>https://pkg.go.dev/k8s.io/kubernetes/cmd/kubeadm/app/apis/kubeadm#section-directories</a></p>
<pre><code>kubeadm config print [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>print 命令的帮助信息</p></td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承而来的选项>从父命令继承而来的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>与集群通信时使用的 kubeconfig 文件。如此标志未设置，将在一组标准位置中搜索现有的kubeconfig 文件。</p></td>
</tr>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>[试验性] 指向“真实”宿主根文件系统的路径。</p></td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-57a6b20d9571220989a7a445d4459468>8.1.1.25 - </h1>
<h3 id=概要>概要</h3>
<p>此命令打印对象，例如用于 'kubeadm init' 的默认 init 配置对象。</p>
<p>请注意，Bootstrap Token 字段之类的敏感值已替换为 {"abcdef.0123456789abcdef" "" "nil" &lt;nil> [] []} 之类的占位符值以通过验证，但不执行创建令牌的实际计算。</p>
<pre><code>kubeadm config print init-defaults [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--component-configs stringSlice</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
组件配置 API 对象的逗号分隔列表，打印其默认值。可用值：[KubeProxyConfiguration KubeletConfiguration]。如果未设置此参数，则不会打印任何组件配置。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
init-defaults 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
与集群通信时使用的 kubeconfig 文件。如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-92a2c11eef37937af846b55d9b87a544>8.1.1.26 - </h1>
<h3 id=概要>概要</h3>
<p>此命令打印对象，例如用于 'kubeadm join' 的默认 join 配置对象。</p>
<p>请注意，诸如启动引导令牌字段之类的敏感值已替换为 {"abcdef.0123456789abcdef" "" "nil" &lt;nil> [] []}
之类的占位符值以通过验证，但不执行创建令牌的实际计算。</p>
<pre><code>kubeadm config print join-defaults [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--component-configs stringSlice</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
组件配置 API 对象的逗号分隔列表，打印其默认值。可用值：[KubeProxyConfiguration KubeletConfiguration]。如果未设置此参数，则不会打印任何组件配置。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
join-defaults 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
与集群通信时使用的 kubeconfig 文件。如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-dcfffcaafb438cd650475945ddc129ee>8.1.1.27 - </h1>
<h3 id=概要>概要</h3>
<p>运行此命令来搭建 Kubernetes 控制平面节点。</p>
<p>"init" 命令执行以下阶段：</p>
<pre><code>preflight                    Run pre-flight checks
certs                        Certificate generation
  /ca                          Generate the self-signed Kubernetes CA to provision identities for other Kubernetes components
  /apiserver                   Generate the certificate for serving the Kubernetes API
  /apiserver-kubelet-client    Generate the certificate for the API server to connect to kubelet
  /front-proxy-ca              Generate the self-signed CA to provision identities for front proxy
  /front-proxy-client          Generate the certificate for the front proxy client
  /etcd-ca                     Generate the self-signed CA to provision identities for etcd
  /etcd-server                 Generate the certificate for serving etcd
  /etcd-peer                   Generate the certificate for etcd nodes to communicate with each other
  /etcd-healthcheck-client     Generate the certificate for liveness probes to healthcheck etcd
  /apiserver-etcd-client       Generate the certificate the apiserver uses to access etcd
  /sa                          Generate a private key for signing service account tokens along with its public key
kubeconfig                   Generate all kubeconfig files necessary to establish the control plane and the admin kubeconfig file
  /admin                       Generate a kubeconfig file for the admin to use and for kubeadm itself
  /kubelet                     Generate a kubeconfig file for the kubelet to use *only* for cluster bootstrapping purposes
  /controller-manager          Generate a kubeconfig file for the controller manager to use
  /scheduler                   Generate a kubeconfig file for the scheduler to use
kubelet-start                Write kubelet settings and (re)start the kubelet
control-plane                Generate all static Pod manifest files necessary to establish the control plane
  /apiserver                   Generates the kube-apiserver static Pod manifest
  /controller-manager          Generates the kube-controller-manager static Pod manifest
  /scheduler                   Generates the kube-scheduler static Pod manifest
etcd                         Generate static Pod manifest file for local etcd
  /local                       Generate the static Pod manifest file for a local, single-node local etcd instance
upload-config                Upload the kubeadm and kubelet configuration to a ConfigMap
  /kubeadm                     Upload the kubeadm ClusterConfiguration to a ConfigMap
  /kubelet                     Upload the kubelet component config to a ConfigMap
upload-certs                 Upload certificates to kubeadm-certs
mark-control-plane           Mark a node as a control-plane
bootstrap-token              Generates bootstrap tokens used to join a node to a cluster
kubelet-finalize             Updates settings relevant to the kubelet after TLS bootstrap
  /experimental-cert-rotation  Enable kubelet client certificate rotation
addon                        Install required addons for passing Conformance tests
  /coredns                     Install the CoreDNS addon to a Kubernetes cluster
  /kube-proxy                  Install the kube-proxy addon to a Kubernetes cluster
</code></pre><pre><code>kubeadm init [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
API 服务器所公布的其正在监听的 IP 地址。如果未设置，则使用默认网络接口。
</td>
</tr>
<tr>
<td colspan=2>
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：6443
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
API 服务器绑定的端口。
</td>
</tr>
<tr>
<td colspan=2>--apiserver-cert-extra-sans stringSlice</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
用于 API Server 服务证书的可选附加主题备用名称（SAN）。可以是 IP 地址和 DNS 名称。
</td>
</tr>
<tr>
<td colspan=2>
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
保存和存储证书的路径。
</td>
</tr>
<tr>
<td colspan=2>--certificate-key string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
用于加密 kubeadm-certs Secret 中的控制平面证书的密钥。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--control-plane-endpoint string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面指定一个稳定的 IP 地址或 DNS 名称。
</td>
</tr>
<tr>
<td colspan=2>--cri-socket string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
要连接的 CRI 套接字的路径。如果为空，则 kubeadm 将尝试自动检测此值；仅当安装了多个 CRI 或具有非标准 CRI 插槽时，才使用此选项。
</td>
</tr>
<tr>
<td colspan=2>--dry-run</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
不要应用任何更改；只是输出将要执行的操作。
</td>
</tr>
<tr>
<td colspan=2>--experimental-patches string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
包含名为 "target[suffix][+patchtype].extension" 的文件的目录路径。
例如，"kube-apiserver0+merge.yaml" 或仅仅是 "etcd.json"。
"patchtype" 可以是 "strategic"、"merge" 或 "json" 之一，并且它们与 kubectl 支持的补丁格式匹配。
默认的 "patchtype" 为 "strategic"。 "extension" 必须为 "json" 或 "yaml"。
"suffix" 是一个可选字符串，可用于确定首先按字母顺序应用哪些补丁。
</td>
</tr>
<tr>
<td colspan=2>--feature-gates string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
一组用来描述各种功能特性的键值（key=value）对。选项是：<br>IPv6DualStack=true|false (ALPHA - default=false)
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
init 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>--ignore-preflight-errors stringSlice</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
错误将显示为警告的检查列表；例如：'IsPrivilegedUser,Swap'。取值为 'all' 时将忽略检查中的所有错误。
</td>
</tr>
<tr>
<td colspan=2>
--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："k8s.gcr.io"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
选择用于拉取控制平面镜像的容器仓库
</td>
</tr>
<tr>
<td colspan=2>
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面选择一个特定的 Kubernetes 版本。
</td>
</tr>
<tr>
<td colspan=2>--node-name string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指定节点的名称。
</td>
</tr>
<tr>
<td colspan=2>--pod-network-cidr string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指明 pod 网络可以使用的 IP 地址段。如果设置了这个参数，控制平面将会为每一个节点自动分配 CIDRs。
</td>
</tr>
<tr>
<td colspan=2>
--service-cidr string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："10.96.0.0/12"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为服务的虚拟 IP 地址另外指定 IP 地址段
</td>
</tr>
<tr>
<td colspan=2>
--service-dns-domain string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："cluster.local"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为服务另外指定域名，例如："myorg.internal"。
</td>
</tr>
<tr>
<td colspan=2>--skip-certificate-key-print</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
不要打印用于加密控制平面证书的密钥。
</td>
</tr>
<tr>
<td colspan=2>--skip-phases stringSlice</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
要跳过的阶段列表
</td>
</tr>
<tr>
<td colspan=2>--skip-token-print</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
跳过打印 'kubeadm init' 生成的默认引导令牌。
</td>
</tr>
<tr>
<td colspan=2>--token string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
这个令牌用于建立控制平面节点与工作节点间的双向通信。格式为 [a-z0-9]{6}\.[a-z0-9]{16} - 示例：abcdef.0123456789abcdef
</td>
</tr>
<tr>
<td colspan=2>
--token-ttl duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：24h0m0s
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
令牌被自动删除之前的持续时间（例如 1 s，2 m，3 h）。如果设置为 '0'，则令牌将永不过期
</td>
</tr>
<tr>
<td colspan=2>--upload-certs</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
将控制平面证书上传到 kubeadm-certs Secret。
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-6eaa2624c512051ff2a9cdbc6ee54949>8.1.1.28 - </h1>
<h3 id=概要>概要</h3>
<p>使用此命令可以调用 init 工作流程的单个阶段</p>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
phase 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<h3 id=继承于父命令的选择项>继承于父命令的选择项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-4b7ada30e3923594b2907dcb8b431080>8.1.1.29 - </h1>
<h3 id=概要>概要</h3>
<p>此命令并非设计用来单独运行。请参阅可用子命令列表。</p>
<pre><code>kubeadm init phase addon [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
addon 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<h3 id=继承于父命令的选项>继承于父命令的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-6d1154da2e554de858cf4e7b37c054fa>8.1.1.30 - </h1>
<h3 id=概要>概要</h3>
<p>安装所有插件（addon）</p>
<pre><code>kubeadm init phase addon all [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
API 服务器所公布的其正在监听的 IP 地址。如果未设置，则将使用默认网络接口。
</td>
</tr>
<tr>
<td colspan=2>
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：6443
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
API 服务器绑定的端口。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--control-plane-endpoint string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面指定一个稳定的 IP 地址或 DNS 名称。
</td>
</tr>
<tr>
<td colspan=2>--feature-gates string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
一组键值对（key=value），描述了各种特征。选项包括：<br>IPv6DualStack=true|false (ALPHA - 默认值=false)
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："k8s.gcr.io"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
选择用于拉取控制平面镜像的容器仓库
</td>
</tr>
<tr>
<td colspan=2>
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
与集群通信时使用的 kubeconfig 文件。如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan=2>
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面选择特定的 Kubernetes 版本。
</td>
</tr>
<tr>
<td colspan=2>--pod-network-cidr string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指定 Pod 网络的 IP 地址范围。如果已设置，控制平面将自动为每个节点分配 CIDR。
</td>
</tr>
<tr>
<td colspan=2>
--service-cidr string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："10.96.0.0/12"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为服务 VIP 使用 IP 地址的其他范围。
</td>
</tr>
<tr>
<td colspan=2>
--service-dns-domain string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："cluster.local"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为服务使用其他域名，例如 "myorg.internal"。
</td>
</tr>
</tbody>
</table>
<h3 id=继承于父命令的选项>继承于父命令的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-d3a16914ddc849435ed864163978ddbf>8.1.1.31 - </h1>
<h3 id=概要>概要</h3>
<p>通过 API 服务器安装 CoreDNS 附加组件。请注意，即使 DNS 服务器已部署，在安装 CNI 之前 DNS 服务器不会被调度执行。</p>
<pre><code>kubeadm init phase addon coredns [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--feature-gates string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
一组用来描述各种功能特性的键值（key=value）对。选项是：<br>IPv6DualStack=true|false (ALPHA - 默认值=false)
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
coredns 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："k8s.gcr.io"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
选择用于拉取控制平面镜像的容器仓库
</td>
</tr>
<tr>
<td colspan=2>
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
与集群通信时使用的 kubeconfig 文件。如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan=2>
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面选择特定的 Kubernetes 版本。
</td>
</tr>
<tr>
<td colspan=2>
--service-cidr string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："10.96.0.0/12"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为服务 VIP 选择 IP 地址范围。
</td>
</tr>
<tr>
<td colspan=2>
--service-dns-domain string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："cluster.local"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
服务使用其它的域名，例如："myorg.internal"。
</td>
</tr>
</tbody>
</table>
<h3 id=继承于父命令的选项>继承于父命令的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-8a257337ea78e5d9a0c54aa971eaf991>8.1.1.32 - </h1>
<h3 id=概要>概要</h3>
<p>通过 API 服务器安装 kube-proxy 附加组件。</p>
<pre><code>kubeadm init phase addon kube-proxy [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
API 服务器所公布的其正在监听的 IP 地址。如果未设置，则将使用默认网络接口。
</td>
</tr>
<tr>
<td colspan=2>
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值: 6443
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
API 服务器绑定的端口。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--control-plane-endpoint string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面指定一个稳定的 IP 地址或 DNS 名称。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kube-proxy 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："k8s.gcr.io"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
选择用于拉取控制平面镜像的容器仓库
</td>
</tr>
<tr>
<td colspan=2>
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
与集群通信时使用的 kubeconfig 文件。如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan=2>
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面选择特定的 Kubernetes 版本。
</td>
</tr>
<tr>
<td colspan=2>--pod-network-cidr string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指定 Pod 网络的 IP 地址范围。如果已设置，控制平面将自动为每个节点分配 CIDR。
</td>
</tr>
</tbody>
</table>
<h3 id=继承于父命令的选项>继承于父命令的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-77759011117e7974cbfee9694b6f8801>8.1.1.33 - </h1>
<h3 id=概要>概要</h3>
<p>启动引导令牌（bootstrap token）用于在即将加入集群的节点和控制平面节点之间建立双向信任。</p>
<p>该命令使启动引导令牌（bootstrap token）所需的所有配置生效，然后创建初始令牌。</p>
<pre><code>kubeadm init phase bootstrap-token [flags]
</code></pre>
<h3 id=示例>示例</h3>
<pre><code># 进行所有引导令牌配置，并创建一个初始令牌，功能上与 kubeadm init 生成的令牌等效。
kubeadm init phase bootstrap-token
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
bootstrap-token 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
用于和集群通信的 kubeconfig 文件。如果它没有被设置，那么 kubeadm 将会搜索一个已经存在于标准路径的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan=2>--skip-token-print</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
跳过打印 'kubeadm init' 生成的默认引导令牌。
</td>
</tr>
</tbody>
</table>
<h3 id=继承于父命令的选项>继承于父命令的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-8e1920b2caaa8de839cd3997edca80e9>8.1.1.34 - </h1>
<h3 id=概要>概要</h3>
<p>此命令并非设计用来单独运行。请参阅可用子命令列表。</p>
<pre><code>kubeadm init phase certs [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
certs 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<h3 id=从父指令中继承的选项>从父指令中继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-00aa8c2e4b3b2fd3a4b7986976b7bfda>8.1.1.35 - </h1>
<h3 id=概要>概要</h3>
<p>生成所有证书</p>
<pre><code>kubeadm init phase certs all [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
API 服务器所公布的其正在监听的 IP 地址。如果未设置，将使用默认网络接口。
</td>
</tr>
<tr>
<td colspan=2>--apiserver-cert-extra-sans stringSlice</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
用于 API 服务器服务证书的可选额外替代名称（SAN）。可以同时使用 IP 地址和 DNS 名称。
</td>
</tr>
<tr>
<td colspan=2>
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
证书的存储路径。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--control-plane-endpoint string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面指定一个稳定的 IP 地址或 DNS 名称。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
all 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面选择特定的 Kubernetes 版本。
</td>
</tr>
<tr>
<td colspan=2>
--service-cidr string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："10.96.0.0/12"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
VIP 服务使用其它的 IP 地址范围。
</td>
</tr>
<tr>
<td colspan=2>
--service-dns-domain string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："cluster.local"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
服务使用其它的域名，例如："myorg.internal"。
</td>
</tr>
</tbody>
</table>
<h3 id=继承于父命令的选项>继承于父命令的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-316aa97ee5719be5a723ac1b77c44f5a>8.1.1.36 - </h1>
<h3 id=概要>概要</h3>
<p>生成 apiserver 用于访问 etcd 的证书，并将其保存到 apiserver-etcd-client.cert 和 apiserver-etcd-client.key 文件中。</p>
<p>如果两个文件都已存在，则 kubeadm 将跳过生成步骤，使用现有文件。</p>
<p>Alpha 免责声明：此命令当前为 Alpha 功能。</p>
<pre><code>kubeadm init phase certs apiserver-etcd-client [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
证书的存储路径。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
apiserver-etcd-client 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面指定特定的 Kubernetes 版本。
</td>
</tr>
</tbody>
</table>
<h3 id=继承于父命令的选项>继承于父命令的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-759e85e62b32c0697ab37c214e99a864>8.1.1.37 - </h1>
<h3 id=概要>概要</h3>
<p>生成供 API 服务器连接 kubelet 的证书，并将其保存到 apiserver-kubelet-client.cert 和 apiserver-kubelet-client.key 文件中。</p>
<p>如果两个文件都已存在，则 kubeadm 将跳过生成步骤，使用现有文件。</p>
<p>Alpha 免责声明：此命令当前为 Alpha 功能。</p>
<pre><code>kubeadm init phase certs apiserver-kubelet-client [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
存储证书的路径。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件路径。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
apiserver-kubelet-client 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面指定特定的 Kubernetes 版本。
</td>
</tr>
</tbody>
</table>
<h3 id=继承于父命令的选项>继承于父命令的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 指向宿主机上的 '实际' 根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-2e7091074560abc2a8e7b897cdd8a7b6>8.1.1.38 - </h1>
<h3 id=概要>概要</h3>
<p>生成用于服务 Kubernetes API 的证书，并将其保存到 apiserver.cert 和 apiserver.key 文件中。</p>
<p>默认 SAN 是 kubernetes、kubernetes.default、kubernetes.default.svc、kubernetes.default.svc.cluster.local、10.96.0.1、127.0.0.1。</p>
<p>如果两个文件都已存在，则 kubeadm 将跳过生成步骤，使用现有文件。</p>
<p>Alpha 免责声明：此命令当前为 Alpha 功能。</p>
<pre><code>kubeadm init phase certs apiserver [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
API 服务器所公布的其正在监听的 IP 地址。如果未设置，则使用默认的网络接口。
</td>
</tr>
<tr>
<td colspan=2>--apiserver-cert-extra-sans stringSlice</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
用于 API Server 服务证书的可选附加主体备用名称（SAN）。可以是 IP 地址和 DNS 名称。
</td>
</tr>
<tr>
<td colspan=2>
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
证书的存储路径。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--control-plane-endpoint string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面指定一个稳定的 IP 地址或 DNS 名称。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
apiserver 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面指定特定的 Kubernetes 版本。
</td>
</tr>
<tr>
<td colspan=2>
--service-cidr string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："10.96.0.0/12"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指定服务 VIP 可使用的其他 IP 地址段。
</td>
</tr>
<tr>
<td colspan=2>
--service-dns-domain string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："cluster.local"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为服务使用其他域名，例如 "myorg.internal"。
</td>
</tr>
</tbody>
</table>
<h3 id=继承于父命令的选项>继承于父命令的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-eedb8f5a6ed4cff1dfb1a5d14176b5b3>8.1.1.39 - </h1>
<h3 id=概要>概要</h3>
<p>生成自签名的 Kubernetes CA 以提供其他 Kubernetes 组件的身份，并将其保存到 ca.cert 和 ca.key 文件中。</p>
<p>如果两个文件都已存在，则 kubeadm 将跳过生成步骤，使用现有文件。</p>
<p>Alpha 免责声明：此命令当前为 Alpha 功能。</p>
<pre><code>kubeadm init phase certs ca [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
证书的存储路径。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
ca 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面选择特定的 Kubernetes 版本。
</td>
</tr>
</tbody>
</table>
<h3 id=继承于父命令的选项>继承于父命令的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-c55f2fa6bdaa124b37da090a3ef90902>8.1.1.40 - </h1>
<h3 id=概要>概要</h3>
<p>生成用于为 etcd 设置身份的自签名 CA，并将其保存到 etcd/ca.cert 和 etcd/ca.key 文件中。</p>
<p>如果两个文件都已存在，则 kubeadm 将跳过生成步骤，使用现有文件。</p>
<p>Alpha 免责声明：此命令当前为 Alpha 功能。</p>
<pre><code>kubeadm init phase certs etcd-ca [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
证书的存储路径。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
etcd-ca 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面选择特定的 Kubernetes 版本。
</td>
</tr>
</tbody>
</table>
<h3 id=继承于父命令的选项>继承于父命令的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-10f416336efdcee22d691869e7585b9f>8.1.1.41 - </h1>
<h3 id=概要>概要</h3>
<p>生成用于 etcd 健康检查的活跃性探针的证书，并将其保存到 healthcheck-client.cert 和 etcd/healthcheck-client.key 文件中。</p>
<p>如果两个文件都已存在，则 kubeadm 将跳过生成步骤，使用现有文件。</p>
<p>Alpha 免责声明：此命令当前为 alpha 功能。</p>
<pre><code>kubeadm init phase certs etcd-healthcheck-client [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
证书存储的路径。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
etcd-healthcheck-client 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面选择特定的 Kubernetes 版本。
</td>
</tr>
</tbody>
</table>
<h3 id=继承于父命令的选项>继承于父命令的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-c4b6d149cda7cac896f4374c821b7fc6>8.1.1.42 - </h1>
<h3 id=概要>概要</h3>
<p>生成 etcd 节点相互通信的证书，并将其保存到 etcd/peer.cert 和 etcd/peer.key 文件中。</p>
<p>默认 SAN 为 localhost、127.0.0.1、127.0.0.1、:: 1</p>
<p>如果两个文件都已存在，则 kubeadm 将跳过生成步骤，使用现有文件。</p>
<p>Alpha 免责声明：此命令当前为 alpha 功能。</p>
<pre><code>kubeadm init phase certs etcd-peer [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
保存和存储证书的路径。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
etcd-peer 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面指定特定的 Kubernetes 版本。
</td>
</tr>
</tbody>
</table>
<h3 id=继承于父命令的选项>继承于父命令的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-1db087626f4f368e932df6f12993a5ab>8.1.1.43 - </h1>
<h3 id=概要>概要</h3>
<p>生成用于提供 etcd 服务的证书，并将其保存到 etcd/server.crt 和 etcd/server.key 文件中。</p>
<p>默认 SAN 为 localhost、127.0.0.1、127.0.0.1、:: 1</p>
<p>如果两个文件都已存在，则 kubeadm 将跳过生成步骤，使用现有文件。</p>
<p>Alpha 免责声明：此命令当前为 alpha 功能。</p>
<pre><code>kubeadm init phase certs etcd-server [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
<p>保存和存储证书的路径。<p>
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
<p>kubeadm 配置文件的路径。<p>
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
<p>etcd-server 操作的帮助命令<p>
</td>
</tr>
<tr>
<td colspan=2>
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
<p>为控制平面指定特定的 Kubernetes 版本。<p>
</td>
</tr>
</tbody>
</table>
<h3 id=继承于父命令的选项>继承于父命令的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
<p>[实验] 到 '真实' 主机根文件系统的路径。<p>
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-e85da83e18a50e472eb56320af55768a>8.1.1.44 - </h1>
<h3 id=概要>概要</h3>
<p>生成自签名 CA 来提供前端代理的身份，并将其保存到 front-proxy-ca.cert 和 front-proxy-ca.key 文件中。</p>
<p>如果两个文件都已存在，kubeadm 将跳过生成步骤并将使用现有文件。</p>
<p>Alpha 免责声明：此命令目前是 alpha 阶段。</p>
<pre><code>kubeadm init phase certs front-proxy-ca [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
存储证书的路径。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
front-proxy-ca 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面选择特定的 Kubernetes 版本。
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-eb911bdcb8bb53ceb8b253089ab0d814>8.1.1.45 - </h1>
<h3 id=概要>概要</h3>
<p>为前端代理客户端生成证书，并将其保存到 front-proxy-client.cert 和 front-proxy-client.key 文件中。
如果两个文件都已存在，kubeadm 将跳过生成步骤并将使用现有文件。
Alpha 免责声明：此命令目前是 alpha 阶段。</p>
<pre><code>kubeadm init phase certs front-proxy-client [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认："/etc/kubernetes/pki"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
存储证书的路径。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
front-proxy-client 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面选择特定的 Kubernetes 版本。
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-62c5dc89c39f3ecd6aee57545d12891a>8.1.1.46 - </h1>
<h3 id=概要>概要</h3>
<p>生成用于签名 service account 令牌的私钥及其公钥，并将其保存到 sa.key 和 sa.pub 文件中。如果两个文件都已存在，则 kubeadm 会跳过生成步骤，而将使用现有文件。</p>
<p>Alpha 免责声明：此命令当前为 alpha 阶段。</p>
<pre><code>kubeadm init phase certs sa [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
保存和存储证书的路径。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
sa 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<h3 id=继承于父命令的选项>继承于父命令的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-2a79e12b9455f0ca1a6d5b00a9841249>8.1.1.47 - </h1>
<h3 id=概要>概要</h3>
<p>此命令并非设计用来单独运行。请参阅可用子命令列表。</p>
<pre><code>kubeadm init phase control-plane [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
control-plane 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<h3 id=继承于父命令的选项>继承于父命令的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-a2c8efac328fcf416e558bf167ef417d>8.1.1.48 - </h1>
<h3 id=概要>概要</h3>
<p>生成所有的静态 Pod 清单文件</p>
<pre><code>kubeadm init phase control-plane all [flags]
</code></pre>
<h3 id=示例>示例</h3>
<pre><code># 为控制平面组件生成静态 Pod 清单文件，其功能等效于 kubeadm init 生成的文件。
kubeadm init phase control-plane all

# 使用从某配置文件中读取的选项为生成静态 Pod 清单文件。
kubeadm init phase control-plane all --config config.yaml
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
API 服务器所公布的其正在监听的 IP 地址。如果未设置，将使用默认的网络接口。
</td>
</tr>
<tr>
<td colspan=2>--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：6443</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
API 服务器要绑定的端口。
</td>
</tr>
<tr>
<td colspan=2>--apiserver-extra-args mapStringString</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
形式为 &lt;flagname>=&lt;value> 的一组额外参数，用来传递给 API 服务器，
或者覆盖其默认配置值
</td>
</tr>
<tr>
<td colspan=2>
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
存储证书的路径。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--control-plane-endpoint string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面选择一个稳定的 IP 地址或者 DNS 名称。
</td>
</tr>
<tr>
<td colspan=2>--controller-manager-extra-args mapStringString</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
一组形式为 &lt;flagname>=&lt;value> 的额外参数，用来传递给控制管理器（Controller Manager）
或覆盖其默认设置值
</td>
</tr>
<tr>
<td colspan=2>--experimental-patches string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
包含名为 "target[suffix][+patchtype].extension" 的文件的目录。
例如，"kube-apiserver0+merge.yaml" 或者 "etcd.json"。
"patchtype" 可以是 "strategic"、"merge" 或 "json" 之一，分别与 kubectl
所支持的 patch 格式相匹配。默认的 "patchtype" 是 "strategic"。
"extension" 必须是 "json" 或 "yaml"。
"suffix" 是一个可选的字符串，用来确定按字母顺序排序时首先应用哪些 patch。
</td>
</tr>
<tr>
<td colspan=2>--feature-gates string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
一组用来描述各种特性门控的键值（key=value）对。选项是：
<br>IPv6DualStack=true|false (ALPHA - 默认=false)
<br>PublicKeysECDSA=true|false (ALPHA - 默认=false)
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
all 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："k8s.gcr.io"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
选择用于拉取控制平面镜像的容器仓库
</td>
</tr>
<tr>
<td colspan=2>
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面选择指定的 Kubernetes 版本。
</td>
</tr>
<tr>
<td colspan=2>--pod-network-cidr string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指定 Pod 网络的 IP 地址范围。如果设置了此标志，控制平面将自动地为每个节点分配 CIDR。
</td>
</tr>
<tr>
<td colspan=2>--scheduler-extra-args mapStringString</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
一组形式为 &lt;flagname>=&lt;value> 的额外参数，用来传递给调度器（Scheduler）
或覆盖其默认设置值
<p>传递给调度器（scheduler）一组额外的参数或者以 &lt;flagname>=&lt;value> 形式覆盖其默认值。</p>
</td>
</tr>
<tr>
<td colspan=2>
--service-cidr string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："10.96.0.0/12"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为服务 VIP 选择 IP 地址范围。
</td>
</tr>
</tbody>
</table>
<h3 id=从父指令继承的选项>从父指令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 指向 '真实' 宿主机的根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-d93bd37094201bdefdb3908c9a6c86b3>8.1.1.49 - </h1>
<h3 id=概要>概要</h3>
<p>生成 kube-apiserver 静态 Pod 清单</p>
<pre><code>kubeadm init phase control-plane apiserver [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
API 服务器所公布的其正在监听的 IP 地址。如果未设置，将使用默认网络接口。
</td>
</tr>
<tr>
<td colspan=2>
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值： 6443
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
要绑定到 API 服务器的端口。
</td>
</tr>
<tr>
<td colspan=2>--apiserver-extra-args mapStringString</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
一组 &lt;flagname>=&lt;value> 形式的额外参数，用来传递给 API 服务器
或者覆盖其默认参数配置
</td>
</tr>
<tr>
<td colspan=2>
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
保存和存储证书的路径。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--control-plane-endpoint string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面指定一个稳定的 IP 地址或 DNS 名称。
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
包含名为 "target[suffix][+patchtype].extension" 的文件的目录。
例如，"kube-apiserver0+merge.yaml" 或者 "etcd.json"。
"patchtype" 可以是 "strategic"、"merge" 或 "json" 之一，分别与 kubectl
所支持的 patch 格式相匹配。默认的 "patchtype" 是 "strategic"。
"extension" 必须是 "json" 或 "yaml"。
"suffix" 是一个可选的字符串，用来确定按字母顺序排序时首先应用哪些 patch。
</td>
</tr>
<tr>
<td colspan=2>--feature-gates string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
一组键值对，用于描述各种功能特性的特性门控。选项是：
<br>IPv6DualStack=true|false (ALPHA - 默认=false)
<br>PublicKeysECDSA=true|false (ALPHA - 默认=false)
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
apiserver 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："k8s.gcr.io"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
选择要从中拉取控制平面镜像的容器仓库
</td>
</tr>
<tr>
<td colspan=2>
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面选择特定的 Kubernetes 版本
</td>
</tr>
<tr>
<td colspan=2>
--service-cidr string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："10.96.0.0/12"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指定服务 VIP 使用 IP 地址的其他范围。
</td>
</tr>
</tbody>
</table>
<h3 id=继承于父命令的选项>继承于父命令的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-efa9ae4c92ed1c26dc04bb049db38cec>8.1.1.50 - </h1>
<h3 id=概要>概要</h3>
<p>生成 kube-controller-manager 静态 Pod 清单</p>
<pre><code>kubeadm init phase control-plane controller-manager [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
存储证书的路径。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--controller-manager-extra-args mapStringString</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
一组 &lt;flagname>=&lt; 形式的额外参数，传递给控制器管理器（Controller Manager）
或者覆盖其默认配置值
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
包含名为 "target[suffix][+patchtype].extension" 的文件的目录。
例如，"kube-apiserver0+merge.yaml" 或者 "etcd.json"。
"patchtype" 可以是 "strategic"、"merge" 或 "json" 之一，分别与 kubectl
所支持的 patch 格式相匹配。默认的 "patchtype" 是 "strategic"。
"extension" 必须是 "json" 或 "yaml"。
"suffix" 是一个可选的字符串，用来确定按字母顺序排序时首先应用哪些 patch。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
controller-manager 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："k8s.gcr.io"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
选择要从中拉取控制平面镜像的容器仓库
</td>
</tr>
<tr>
<td colspan=2>
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面选择特定的 Kubernetes 版本。
</td>
</tr>
<tr>
<td colspan=2>--pod-network-cidr string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指定 Pod 网络的 IP 地址范围。如果设置，控制平面将自动为每个节点分配 CIDR。
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-576c00359074987304b3b418cec9a5b1>8.1.1.51 - </h1>
<h3 id=概要>概要</h3>
<p>生成 kube-scheduler 静态 Pod 清单</p>
<pre><code>kubeadm init phase control-plane scheduler [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
存储证书的路径。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--experimental-patches string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
包含名为 "target[suffix][+patchtype].extension" 的文件的目录。
例如，"kube-apiserver0+merge.yaml" 或者 "etcd.json"。
"patchtype" 可以是 "strategic"、"merge" 或 "json" 之一，分别与 kubectl
所支持的 patch 格式相匹配。默认的 "patchtype" 是 "strategic"。
"extension" 必须是 "json" 或 "yaml"。
"suffix" 是一个可选的字符串，用来确定按字母顺序排序时首先应用哪些 patch。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
scheduler 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值:"k8s.gcr.io"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
选择要从中拉取控制平面镜像的容器仓库
</td>
</tr>
<tr>
<td colspan=2>
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面选择特定的 Kubernetes 版本。
</td>
</tr>
<tr>
<td colspan=2>--scheduler-extra-args mapStringString</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
一组 &lt;flagname>=&lt;value> 形式的额外参数，用来传递给调度器
或者覆盖其默认参数配置
</td>
</tr>
</tbody>
</table>
<h3 id=继承于父命令的选项>继承于父命令的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-e6097fe5dd013abd9f356c2566ef7b63>8.1.1.52 - </h1>
<h3 id=概要>概要</h3>
<p>此命令并非设计用来单独运行。请参阅可用子命令列表。</p>
<pre><code>kubeadm init phase etcd [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
etcd 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<h3 id=继承于父命令的选项>继承于父命令的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-5ab65eab2498cc1893af5b3bf8fe08fc>8.1.1.53 - </h1>
<h3 id=概要>概要</h3>
<p>为本地单节点 etcd 实例生成静态 Pod 清单文件</p>
<pre><code>kubeadm init phase etcd local [flags]
</code></pre>
<h3 id=示例>示例</h3>
<pre><code># 为 etcd 生成静态 Pod 清单文件，其功能等效于 kubeadm init 生成的文件。
kubeadm init phase etcd local

# 使用从配置文件读取的选项为 etcd 生成静态 Pod 清单文件。
kubeadm init phase etcd local --config config.yaml
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
存储证书的路径。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--experimental-patches string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
包含名为 "target[suffix][+patchtype].extension" 的文件的目录的路径。
例如，"kube-apiserver0+merge.yaml" 或仅仅是 "etcd.json"。
"patchtype" 可以是 "strategic"、"merge" 或 "json" 之一，并且它们与 kubectl 支持的补丁格式匹配。
默认的 "patchtype" 为 "strategic"。 "extension" 必须为 "json" 或 "yaml"。
"suffix" 是一个可选字符串，可用于确定首先按字母顺序应用哪些补丁。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
local 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："k8s.gcr.io"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
选择要从中拉取控制平面镜像的容器仓库
</td>
</tr>
</tbody>
</table>
<h3 id=继承于父命令的选项>继承于父命令的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-fcb78718510a9d3027d1bb9d379c0c17>8.1.1.54 - </h1>
<h3 id=概要>概要</h3>
<p>此命令并非设计用来单独运行。请阅读可用子命令列表。</p>
<pre><code>kubeadm init phase kubeconfig [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeconfig 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-a0e1457f667eb757f82f8c42901aa6c5>8.1.1.55 - </h1>
<h3 id=概要>概要</h3>
<p>为管理员和 kubeadm 本身生成 kubeconfig 文件，并将其保存到 admin.conf 文件中。</p>
<pre><code>kubeadm init phase kubeconfig admin [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
API 服务器所公布的其正在监听的 IP 地址。如果未设置，则使用默认的网络接口。
</td>
</tr>
<tr>
<td colspan=2>
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：6443
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
要绑定到 API 服务器的端口。
</td>
</tr>
<tr>
<td colspan=2>
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
保存和存储证书的路径。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--control-plane-endpoint string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面指定一个稳定的 IP 地址或 DNS 名称。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
admin 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--kubeconfig-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeconfig 文件的保存路径。
</td>
</tr>
<tr>
<td colspan=2>
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面指定特定的 Kubernetes 版本。
</td>
</tr>
</tbody>
</table>
<h3 id=继承于父命令的选项>继承于父命令的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-59e362bf565041872395d165e99eafc1>8.1.1.56 - </h1>
<h3 id=概要>概要</h3>
<p>生成所有 kubeconfig 文件</p>
<pre><code>kubeadm init phase kubeconfig all [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
API 服务器所公布的其正在监听的 IP 地址。如果没有设置，将使用默认的网络接口。
</td>
</tr>
<tr>
<td colspan=2>
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：6443
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
要绑定到 API 服务器的端口。
</td>
</tr>
<tr>
<td colspan=2>
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
保存和存储证书的路径。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--control-plane-endpoint string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面指定一个稳定的 IP 地址或 DNS 名称。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
all 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--kubeconfig-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeconfig 文件的保存路径。
</td>
</tr>
<tr>
<td colspan=2>
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面指定特定的 Kubernetes 版本。
</td>
</tr>
<tr>
<td colspan=2>--node-name string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指定节点名称。
</td>
</tr>
</tbody>
</table>
<h3 id=继承于父命令的选项>继承于父命令的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-2a5040747a02ae2b2326c9901f1725d3>8.1.1.57 - </h1>
<h3 id=概要>概要</h3>
<p>生成控制器管理器要使用的 kubeconfig 文件，并保存到 controller-manager.conf 文件中。</p>
<pre><code>kubeadm init phase kubeconfig controller-manager [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
API 服务器所公布的其正在监听的 IP 地址。如果未设置，则使用默认的网络接口。
</td>
</tr>
<tr>
<td colspan=2>
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：6443
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
要绑定到 API 服务器的端口。
</td>
</tr>
<tr>
<td colspan=2>
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
保存和存储证书的路径。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--control-plane-endpoint string</td>
</tr>
</tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面指定一个稳定的 IP 地址或 DNS 名称。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
controller-manager 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--kubeconfig-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeconfig 文件的保存路径。
</td>
</tr>
<tr>
<td colspan=2>
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面指定特定的 Kubernetes 版本。
</td>
</tr>
</tbody>
</table>
<h3 id=继承于父命令的选项>继承于父命令的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs 字符串</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-043bd19497eefb77a6ed30a4d704fe7c>8.1.1.58 - </h1>
<h3 id=概要>概要</h3>
<p>生成 kubelet 要使用的 kubeconfig 文件，并将其保存到 kubelet.conf 文件。</p>
<p>请注意，该操作目的是<em>仅</em>应用于引导集群。在控制平面启动之后，应该从 CSR API 请求所有 kubelet 凭据。</p>
<pre><code>kubeadm init phase kubeconfig kubelet [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
API 服务器所公布的其正在监听的 IP 地址。如果未设置，则使用默认的网络接口。
</td>
</tr>
<tr>
<td colspan=2>
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：6443
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
要绑定到 API 服务器的端口。
</td>
</tr>
<tr>
<td colspan=2>
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
保存和存储证书的路径。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--control-plane-endpoint string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面指定一个稳定的 IP 地址或 DNS 名称。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubelet 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--kubeconfig-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeconfig 文件的保存路径。
</td>
</tr>
<tr>
<td colspan=2>
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面选择特定的 Kubernetes 版本。
</td>
</tr>
<tr>
<td colspan=2>--node-name string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指定节点的名称。
</td>
</tr>
</tbody>
</table>
<h3 id=继承于父命令的选项>继承于父命令的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-bffb0d67824e75ade7232d09754b9718>8.1.1.59 - </h1>
<h3 id=概要>概要</h3>
<p>生成调度器（scheduler）要使用的 kubeconfig 文件，并保存到 scheduler.conf 文件中。</p>
<pre><code>kubeadm init phase kubeconfig scheduler [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
API 服务器所公布的其正在监听的 IP 地址。如果未设置，则使用默认的网络接口。
</td>
</tr>
<tr>
<td colspan=2>
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：6443
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
要绑定到 API 服务器的端口。
</td>
</tr>
<tr>
<td colspan=2>
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
保存和存储证书的路径。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--control-plane-endpoint string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面指定一个稳定的 IP 地址或 DNS 名称。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
scheduler 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--kubeconfig-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeconfig 文件的保存路径。
</td>
</tr>
<tr>
<td colspan=2>
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面指定特定的 Kubernetes 版本。
</td>
</tr>
</tbody>
</table>
<h3 id=继承于父命令的选项>继承于父命令的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-a37b5872c572c71775e389df50fca215>8.1.1.60 - </h1>
<p>TLS 引导后更新与 kubelet 相关的设置</p>
<pre><code>kubeadm init phase kubelet-finalize [flags]
</code></pre>
<h3 id=示例>示例</h3>
<pre><code>  # 在 TLS 引导后更新与 kubelet 相关的设置
  kubeadm init phase kubelet-finalize all --config
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>kubelet-finalize 操作的帮助命令</td>
</tr>
</tbody>
</table>
<h3 id=继承于父命令的选项>继承于父命令的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>[实验] 到'真实'主机根文件系统的路径。</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-3f49598c499c3356d89d98fdc8c8ad79>8.1.1.61 - </h1>
<p>运行所有 kubelet-finalize 阶段</p>
<pre><code>kubeadm init phase kubelet-finalize all [flags]
</code></pre>
<h3 id=示例>示例</h3>
<pre><code>  # 在 TLS 引导后更新与 kubelet 相关的设置
  kubeadm init phase kubelet-finalize all --config
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值: "/etc/kubernetes/pki"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>保存和存储证书的路径。</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>kubeadm 配置文件的路径。</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>all 操作的帮助命令</td>
</tr>
</tbody>
</table>
<h3 id=继承于父命令的选项>继承于父命令的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>[实验] 到'真实'主机根文件系统的路径。</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-7d68ac74e5301f789ddd2e25dd36218e>8.1.1.62 - </h1>
<p>启用 kubelet 客户端证书轮换</p>
<pre><code>kubeadm init phase kubelet-finalize experimental-cert-rotation [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>保存和存储证书的路径。</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>kubeadm 配置文件的路径。</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>experimental-cert-rotation 操作的帮助命令</td>
</tr>
</tbody>
</table>
<h3 id=继承于父命令的选项>继承于父命令的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>[实验] 到'真实'主机根文件系统的路径。</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-e7c1ae3d905d9b6854216e26651955cd>8.1.1.63 - </h1>
<h3 id=概要>概要</h3>
<p>使用 kubelet 配置文件编写一个文件，并使用特定节点的 kubelet 设置编写一个环境文件，然后（重新）启动 kubelet。</p>
<pre><code>kubeadm init phase kubelet-start [flags]
</code></pre>
<h3 id=示例>示例</h3>
<pre><code># 从 InitConfiguration 文件中写入带有 kubelet 参数的动态环境文件。
kubeadm init phase kubelet-start --config config.yaml
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--cri-socket string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
连接到 CRI 套接字的路径。如果为空，则 kubeadm 将尝试自动检测该值；仅当安装了多个 CRI 或具有非标准 CRI 套接字时，才使用此选项。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubelet-start 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>--node-name string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指定节点名称。
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-967a98823c19c8338bfc0e1338a20fb1>8.1.1.64 - </h1>
<h3 id=概要>概要</h3>
<p>标记 Node 节点为控制平面节点</p>
<pre><code>kubeadm init phase mark-control-plane [flags]
</code></pre>
<h3 id=示例>示例</h3>
<pre><code># 将控制平面标签和污点应用于当前节点，其功能等效于 kubeadm init执行的操作。
kubeadm init phase mark-control-plane --config config.yml

# 将控制平面标签和污点应用于特定节点
kubeadm init phase mark-control-plane --node-name myNode
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
mark-control-plane 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>--node-name string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指定节点名称。
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs 字符串</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-b5838cc93a3fdb37b61afd201a71edd9>8.1.1.65 - </h1>
<h3 id=概要>概要</h3>
<p>运行 kubeadm init 前的启动检查。</p>
<pre><code>kubeadm init phase preflight [flags]
</code></pre>
<h3 id=案例>案例</h3>
<pre><code># 使用配置文件对 kubeadm init 进行启动检查。
kubeadm init phase preflight --config kubeadm-config.yml
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
preflight 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>--ignore-preflight-errors stringSlice</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
错误将显示为警告的检查列表：例如：'IsPrivilegedUser,Swap'。取值为 'all' 时将忽略检查中的所有错误。
</td>
</tr>
</tbody>
</table>
<h3 id=继承于父命令的选项>继承于父命令的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-f54c84a0fdada369a87b2ced6ccfc38f>8.1.1.66 - </h1>
<h3 id=概要>概要</h3>
<p>此命令并非设计用来单独运行。请参阅可用子命令列表。</p>
<pre><code>kubeadm init phase upload-certs [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--certificate-key string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
用于加密 kubeadm-certs Secret 中的控制平面证书的密钥。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
upload-certs 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
用来与集群通信的 kubeconfig 文件。
如果此标志未设置，则可以在一组标准的位置搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan=2>--skip-certificate-key-print</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
不要打印输出用于加密控制平面证书的密钥。
</td>
</tr>
<tr>
<td colspan=2>--upload-certs</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
将控制平面证书上传到 kubeadm-certs Secret。
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-0d96e214c09a8f014e984a6b980522b3>8.1.1.67 - </h1>
<h3 id=概要>概要</h3>
<p>此命令并非设计用来单独运行。请参阅可用的子命令列表。</p>
<pre><code>kubeadm init phase upload-config [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
upload-config 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令中继承的选项>从父命令中继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-48afa88840a20edf1ad613c18480d4fc>8.1.1.68 - </h1>
<h3 id=概要>概要</h3>
<p>将所有配置上传到 ConfigMap</p>
<pre><code>kubeadm init phase upload-config all [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
all 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
与集群通信时使用的 kubeconfig 文件。如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-14da359f76a0f36af507d289dd4a5050>8.1.1.69 - </h1>
<h3 id=概要>概要</h3>
<p>将 kubeadm ClusterConfiguration 上传到 kube-system 命名空间中名为 kubeadm-config 的 ConfigMap 中。
这样就可以正确配置系统组件，并在升级时提供无缝的用户体验。</p>
<p>另外，可以使用 kubeadm 配置。</p>
<pre><code>kubeadm init phase upload-config kubeadm [flags]
</code></pre>
<h3 id=示例>示例</h3>
<pre><code># 上传集群配置
kubeadm init phase upload-config --config=myConfig.yaml
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
与集群通信时使用的 kubeconfig 文件。如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-3fda282409b804a14879b9c65c035797>8.1.1.70 - </h1>
<h3 id=概要>概要</h3>
<p>将从 kubeadm InitConfiguration 对象提取的 kubelet 配置上传到集群中 kubelet-config-1.X 形式的
ConfigMap，其中 X 是当前（API 服务器）Kubernetes 版本的次要版本。</p>
<pre><code>kubeadm init phase upload-config kubelet [flags]
</code></pre>
<h3 id=示例>示例</h3>
<pre><code># 将 kubelet 配置从 kubeadm 配置文件上传到集群中的 ConfigMap。
kubeadm init phase upload-config kubelet --config kubeadm.yaml
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
到 kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubelet 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
与集群通信时使用的 kubeconfig 文件。如果未设置该标签，则可以通过一组标准路径来寻找已有的 kubeconfig 文件。
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-e044e6c69c2b1512c8d89430e0400771>8.1.1.71 - </h1>
<h3 id=摘要>摘要</h3>
<p>当节点加入 kubeadm 初始化的集群时，我们需要建立双向信任。
这个过程可以分解为发现（让待加入节点信任 Kubernetes 控制平面节点）和 TLS 引导（让Kubernetes 控制平面节点信任待加入节点）两个部分。</p>
<p>有两种主要的发现方案。
第一种方法是使用共享令牌和 API 服务器的 IP 地址。
第二种是提供一个文件 - 标准 kubeconfig 文件的一个子集。
该文件可以是本地文件，也可以通过 HTTPS URL 下载。
格式是 <code>kubeadm join --discovery-token abcdef.1234567890abcdef 1.2.3.4:6443</code>、<code>kubeadm join--discovery-file path/to/file.conf</code> 或者<code>kubeadm join --discovery-file https://url/file.conf</code>。
只能使用其中一种。
如果发现信息是从 URL 加载的，必须使用 HTTPS。
此外，在这种情况下，主机安装的 CA 包用于验证连接。</p>
<p>如果使用共享令牌进行发现，还应该传递 --discovery-token-ca-cert-hash 参数来验证 Kubernetes 控制平面节点提供的根证书颁发机构（CA）的公钥。
此参数的值指定为 "&lt;hash-type>:&lt;hex-encoded-value>"，其中支持的哈希类型为 "sha256"。哈希是通过 Subject Public Key Info（SPKI）对象的字节计算的（如 RFC7469）。
这个值可以从 "kubeadm init" 的输出中获得，或者可以使用标准工具进行计算。
可以多次重复 --discovery-token-ca-cert-hash 参数以允许多个公钥。</p>
<p>如果无法提前知道 CA 公钥哈希，则可以通过 --discovery-token-unsafe-skip-ca-verification 参数禁用此验证。
这削弱了kubeadm 安全模型，因为其他节点可能会模仿 Kubernetes 控制平面节点。</p>
<p>TLS 引导机制也通过共享令牌驱动。
这用于向 Kubernetes 控制平面节点进行临时的身份验证，以提交本地创建的密钥对的证书签名请求（CSR）。
默认情况下，kubeadm 将设置 Kubernetes 控制平面节点自动批准这些签名请求。
这个令牌通过 --tls-bootstrap-token abcdef.1234567890abcdef 参数传入。</p>
<p>通常两个部分会使用相同的令牌。
在这种情况下可以使用 --token 参数，而不是单独指定每个令牌。</p>
<p>"join [api-server-endpoint]" 命令执行下列阶段：</p>
<pre><code>preflight              Run join pre-flight checks
control-plane-prepare  Prepare the machine for serving a control plane
  /download-certs        [EXPERIMENTAL] Download certificates shared among control-plane nodes from the kubeadm-certs Secret
  /certs                 Generate the certificates for the new control plane components
  /kubeconfig            Generate the kubeconfig for the new control plane components
  /control-plane         Generate the manifests for the new control plane components
kubelet-start          Write kubelet settings, certificates and (re)start the kubelet
control-plane-join     Join a machine as a control plane instance
  /etcd                  Add a new local etcd member
  /update-status         Register the new control-plane node into the ClusterStatus maintained in the kubeadm-config ConfigMap
  /mark-control-plane    Mark a node as a control-plane
</code></pre><pre><code>kubeadm join [api-server-endpoint] [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果该节点托管一个新的控制平面实例，则 API 服务器将公布其正在侦听的 IP 地址。如果未设置，则使用默认网络接口。
</td>
</tr>
<tr>
<td colspan=2>
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值: 6443
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果节点应该托管新的控制平面实例，则为 API 服务器要绑定的端口。
</td>
</tr>
<tr>
<td colspan=2>--certificate-key string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
使用此密钥可以解密由 init 上传的证书 secret。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--control-plane</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
在此节点上创建一个新的控制平面实例
</td>
</tr>
<tr>
<td colspan=2>--cri-socket string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
要连接的 CRI 套接字的路径。如果为空，则 kubeadm 将尝试自动检测此值；仅当安装了多个 CRI 或具有非标准 CRI 插槽时，才使用此选项。
</td>
</tr>
<tr>
<td colspan=2>--discovery-file string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对于基于文件的发现，给出用于加载集群信息的文件或者 URL。
</td>
</tr>
<tr>
<td colspan=2>--discovery-token string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对于基于令牌的发现，该令牌用于验证从 API 服务器获取的集群信息。
</td>
</tr>
<tr>
<td colspan=2>--discovery-token-ca-cert-hash stringSlice</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对基于令牌的发现，验证根 CA 公钥是否与此哈希匹配 (格式: "&lt;type>:&lt;value>")。
</td>
</tr>
<tr>
<td colspan=2>--discovery-token-unsafe-skip-ca-verification</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对于基于令牌的发现，允许在未关联 --discovery-token-ca-cert-hash 参数的情况下添加节点。
</td>
</tr>
<tr>
<td colspan=2>--experimental-patches string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
包含名为 "target[suffix][+patchtype].extension" 的文件的目录的路径。
例如，"kube-apiserver0+merge.yaml" 或仅仅是 "etcd.json"。
"patchtype" 可以是 "strategic"、"merge" 或 "json" 之一，并且它们与 kubectl 支持的补丁格式匹配。
默认的 "patchtype" 为 "strategic"。 "extension" 必须为 "json" 或 "yaml"。
"suffix" 是一个可选字符串，可用于确定首先按字母顺序应用哪些补丁。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
join 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>--ignore-preflight-errors stringSlice</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
错误将显示为警告的检查列表；例如：'IsPrivilegedUser,Swap'。取值为 'all' 时将忽略检查中的所有错误。
</td>
</tr>
<tr>
<td colspan=2>--node-name string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指定节点的名称
</td>
</tr>
<tr>
<td colspan=2>--skip-phases stringSlice</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
要跳过的阶段列表
</td>
</tr>
<tr>
<td colspan=2>--tls-bootstrap-token string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指定在加入节点时用于临时通过 Kubernetes 控制平面进行身份验证的令牌。
</td>
</tr>
<tr>
<td colspan=2>--token string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果未提供这些值，则将它们用于 discovery-token 令牌和 tls-bootstrap 令牌。
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-9f968809f867b76728697577492429e8>8.1.1.72 - </h1>
<h3 id=概要>概要</h3>
<p>使用此命令来调用 <code>join</code> 工作流程的某个阶段</p>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
phase 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令中继承的选项>从父命令中继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-c3c506c1683aed34398a34ab66d609da>8.1.1.73 - </h1>
<h3 id=概要>概要</h3>
<p>添加作为控制平面实例的机器</p>
<pre><code>kubeadm join phase control-plane-join [flags]
</code></pre>
<h3 id=示例>示例</h3>
<pre><code># 将机器作为控制平面实例加入
kubeadm join phase control-plane-join all
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
control-plane-join 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令中继承的选项>从父命令中继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-2c1a5a4405dca745ef50b4e86f5977c7>8.1.1.74 - </h1>
<h3 id=概要>概要</h3>
<p>添加作为控制平面实例的机器</p>
<pre><code>kubeadm join phase control-plane-join all [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果该节点托管一个新的控制平面实例，则 API 服务器将公布其正在侦听的 IP 地址。如果未设置，则使用默认网络接口。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--experimental-control-plane</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
在此节点上创建一个新的控制平面实例
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
all 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>--node-name string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指定节点名称。
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-003aaef561d065ecdaeb2c325b6b9253>8.1.1.75 - </h1>
<h3 id=概要>概要</h3>
<p>添加新的本地 etcd 成员</p>
<pre><code>kubeadm join phase control-plane-join etcd [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果该节点托管一个新的控制平面实例，则 API 服务器将公布其正在侦听的 IP 地址。如果未设置，则使用默认网络接口。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--control-plane</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
在此节点上创建一个新的控制平面实例
</td>
</tr>
<tr>
<td colspan=2>--experimental-patches string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
包含名为 "target[suffix][+patchtype].extension" 的文件的目录的路径。
例如，"kube-apiserver0+merge.yaml" 或仅仅是 "etcd.json"。
"patchtype" 可以是"strategic"、"merge" 或 "json" 之一，并且它们与 kubectl 支持的补丁格式匹配。
默认的 "patchtype" 为 "strategic"。 "extension" 必须为 "json" 或 "yaml"。
"suffix" 是一个可选字符串，可用于确定首先按字母顺序应用哪些补丁。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
etcd 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>--node-name string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指定节点的名称
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令中继承的选项>从父命令中继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-535f050663a6d8db3a61df2b19a0714b>8.1.1.76 - </h1>
<h3 id=概要>概要</h3>
<p>将 Node 节点标记为控制平面节点</p>
<pre><code>kubeadm join phase control-plane-join mark-control-plane [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--control-plane</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
在此节点上创建一个新的控制平面实例
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
mark-control-plane 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>--node-name string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指定节点的名称
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令中继承的选项>从父命令中继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-2f0a684baffe3cdf830c16693412f8e0>8.1.1.77 - </h1>
<h2 id=概要>概要</h2>
<p>将新的控制平面节点注册到 kubeadm-config ConfigMap 维护的 ClusterStatus 中</p>
<pre><code>kubeadm join phase control-plane-join update-status [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果该节点托管一个新的控制平面实例，则 API 服务器将公布其正在侦听的 IP 地址。如果未设置，则使用默认网络接口。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--control-plane</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
在此节点上创建一个新的控制平面实例
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
update-status 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>--node-name string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指定节点名称。
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令中继承的选项>从父命令中继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-aba528e06c437710b269f4e41f854fdd>8.1.1.78 - </h1>
<h3 id=概要>概要</h3>
<p>准备为控制平面服务的机器</p>
<pre><code>kubeadm join phase control-plane-prepare [flags]
</code></pre>
<h3 id=示例>示例</h3>
<pre><code># 准备为控制平面服务的机器
kubeadm join phase control-plane-prepare all
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
control-plane-prepare 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令中继承的选项>从父命令中继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-1d7987a759cd1519def4d433710cdff1>8.1.1.79 - </h1>
<h3 id=概要>概要</h3>
<p>准备为控制平面服务的机器</p>
<pre><code>kubeadm join phase control-plane-prepare all [api-server-endpoint] [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果该节点托管一个新的控制平面实例，则 API 服务器将公布其正在侦听的 IP 地址。如果未设置，则使用默认网络接口。
</td>
</tr>
<tr>
<td colspan=2>
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：6443
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果该节点托管一个新的控制平面实例，则为 API 服务器要绑定的端口。
</td>
</tr>
<tr>
<td colspan=2>--certificate-key string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
使用此密钥解密由 init 上传的证书 secrets。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--control-plane</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
在此节点上创建一个新的控制平面实例
</td>
</tr>
<tr>
<td colspan=2>--discovery-file string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对于基于文件的发现，给出用于加载集群信息的文件或者 URL。
</td>
</tr>
<tr>
<td colspan=2>--discovery-token string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对于基于令牌的发现，该令牌用于验证从 API 服务器获取的集群信息。
</td>
</tr>
<tr>
<td colspan=2>--discovery-token-ca-cert-hash stringSlice</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对于基于令牌的发现，请验证根 CA 公钥是否匹配此哈希值（格式："&lt;type>:&lt;value>"）。
</td>
</tr>
<tr>
<td colspan=2>--discovery-token-unsafe-skip-ca-verification</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对于基于令牌的发现，允许在未关联 --discovery-token-ca-cert-hash 参数的情况下添加节点。
</td>
</tr>
<tr>
<td colspan=2>--experimental-patches string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
包含名为 "target[suffix][+patchtype].extension" 的文件的目录的路径。
例如，"kube-apiserver0+merge.yaml" 或仅仅是 "etcd.json"。
"patchtype" 可以是 "strategic"、"merge" 或 "json" 之一，并且它们与 kubectl 支持的补丁格式匹配。
默认的 "patchtype" 为 "strategic"。 "extension" 必须为 "json" 或 "yaml"。
"suffix" 是一个可选字符串，可用于确定首先按字母顺序应用哪些补丁。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
all 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>--node-name string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指定节点名称。
</td>
</tr>
<tr>
<td colspan=2>--tls-bootstrap-token string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指定在加入节点时用于临时通过 Kubernetes 控制平面进行身份验证的令牌。
</td>
</tr>
<tr>
<td colspan=2>--token string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果未提供这些值，则将它们用于 discovery-token 令牌和 tls-bootstrap 令牌。
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-33216a69b333c330cb8b305a119abc7c>8.1.1.80 - </h1>
<h3 id=概要>概要</h3>
<p>为新的控制平面组件生成证书</p>
<pre><code>kubeadm join phase control-plane-prepare certs [api-server-endpoint] [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果该节点托管一个新的控制平面实例，则 API 服务器将公布其正在侦听的 IP 地址。如果未设置，则使用默认网络接口。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--control-plane</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
在此节点上创建一个新的控制平面实例
</td>
</tr>
<tr>
<td colspan=2>--discovery-file string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对于基于文件的发现，给出用于加载集群信息的文件或者 URL。
</td>
</tr>
<tr>
<td colspan=2>--discovery-token string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对于基于令牌的发现，该令牌用于验证从 API 服务器获取的集群信息。
</td>
</tr>
<tr>
<td colspan=2>--discovery-token-ca-cert-hash stringSlice</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对于基于令牌的发现，请验证根 CA 公钥是否匹配此哈希值（格式："&lt;type>:&lt;value>"）。
</td>
</tr>
<tr>
<td colspan=2>--discovery-token-unsafe-skip-ca-verification</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对于基于令牌的发现，允许在未关联 --discovery-token-ca-cert-hash 参数的情况下添加节点。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
certs 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>--node-name string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指定节点名称。
</td>
</tr>
<tr>
<td colspan=2>--tls-bootstrap-token string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指定在加入节点时用于临时通过 Kubernetes 控制平面进行身份验证的令牌。
</td>
</tr>
<tr>
<td colspan=2>--token string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果未提供这些值，则将它们用于 discovery-token 令牌和 tls-bootstrap 令牌。
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-53abd743076fc859067264f3e8e676e0>8.1.1.81 - </h1>
<h3 id=概要>概要</h3>
<p>为新的控制平面组件生成清单（manifest）</p>
<pre><code>kubeadm join phase control-plane-prepare control-plane [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对于将要托管新的控制平面实例的节点，指定 API 服务器将公布的其正在侦听的 IP 地址。如果未设置，则使用默认网络接口。
</td>
</tr>
<tr>
<td colspan=2>
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：6443
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
针对将要托管新的控制平面实例的节点，设置 API 服务器要绑定的端口。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--control-plane</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
在此节点上创建一个新的控制平面实例
</td>
</tr>
<tr>
<td colspan=2>--experimental-patches string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
包含名为 "target[suffix][+patchtype].extension" 的文件的目录的路径。
例如，"kube-apiserver0+merge.yaml" 或仅仅是 "etcd.json"。
"patchtype" 可以是 "strategic"、"merge" 或 "json" 之一，并且它们与 kubectl 支持的补丁格式匹配。
默认的 "patchtype" 为 "strategic"。 "extension" 必须为 "json" 或 "yaml"。
"suffix" 是一个可选字符串，可用于确定首先按字母顺序应用哪些补丁。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
control-plane 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令中继承的选项>从父命令中继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-3a08eb202d572e417768a942ad24c59f>8.1.1.82 - </h1>
<h3 id=概要>概要</h3>
<p>[实验]从 kubeadm-certs Secret 下载控制平面节点之间共享的证书</p>
<pre><code>kubeadm join phase control-plane-prepare download-certs [api-server-endpoint] [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--certificate-key string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
使用此密钥可以解密由 init 上传的证书 secret。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--control-plane</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
在此节点上创建一个新的控制平面实例
</td>
</tr>
<tr>
<td colspan=2>--discovery-file string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对于基于文件的发现，给出用于加载集群信息的文件或者 URL。
</td>
</tr>
<tr>
<td colspan=2>--discovery-token string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对于基于令牌的发现，该令牌用于验证从 API 服务器获取的集群信息。
</td>
</tr>
<tr>
<td colspan=2>--discovery-token-ca-cert-hash stringSlice</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对于基于令牌的发现，请验证根 CA 公钥是否匹配此哈希值（格式："&lt;type>:&lt;value>"）。
</td>
</tr>
<tr>
<td colspan=2>--discovery-token-unsafe-skip-ca-verification</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对于基于令牌的发现，允许在未关联 --discovery-token-ca-cert-hash 参数的情况下添加节点。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeconfig 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>--tls-bootstrap-token string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指定在加入节点时用于临时通过 Kubernetes 控制平面进行身份验证的令牌。
</td>
</tr>
<tr>
<td colspan=2>--token string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果未提供这些值，则将它们用于 discovery-token 令牌和 tls-bootstrap 令牌。
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令中继承的选项>从父命令中继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-11ed4820a6c3b411d9c4b87163cf0ae7>8.1.1.83 - </h1>
<h3 id=概要>概要</h3>
<p>为新的控制平面组件生成 kubeconfig</p>
<pre><code>kubeadm join phase control-plane-prepare kubeconfig [api-server-endpoint] [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--certificate-key string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
使用此密钥可以解密由 init 上传的证书 secret。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--control-plane</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
在此节点上创建一个新的控制平面实例
</td>
</tr>
<tr>
<td colspan=2>--discovery-file string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对于基于文件的发现，给出用于加载集群信息的文件或者 URL。
</td>
</tr>
<tr>
<td colspan=2>--discovery-token string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对于基于令牌的发现，该令牌用于验证从 API 服务器获取的集群信息。
</td>
</tr>
<tr>
<td colspan=2>--discovery-token-ca-cert-hash stringSlice</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对于基于令牌的发现，请验证根 CA 公钥是否匹配此哈希值（格式："&lt;type>:&lt;value>"）。
</td>
</tr>
<tr>
<td colspan=2>--discovery-token-unsafe-skip-ca-verification</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对于基于令牌的发现，允许在未关联 --discovery-token-ca-cert-hash 参数的情况下添加节点。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeconfig 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>--tls-bootstrap-token string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指定在加入节点时用于临时通过 Kubernetes 控制平面进行身份验证的令牌。
</td>
</tr>
<tr>
<td colspan=2>--token string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果未提供这些值，则将它们用于 discovery-token 令牌和 tls-bootstrap 令牌。
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令中继承的选项>从父命令中继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-e81c9d9320242b5ed4b063beea6696f8>8.1.1.84 - </h1>
<h3 id=概要>概要</h3>
<p>生成一个包含 KubeletConfiguration 的文件和一个包含特定于节点的 kubelet 配置的环境文件，然后（重新）启动 kubelet。</p>
<pre><code>kubeadm join phase kubelet-start [api-server-endpoint] [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--cri-socket string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
提供给 CRI 套接字建立连接的路径。如果为空，则 kubeadm 将尝试自动检测该值；仅当安装了多个 CRI 或具有非标准 CRI 套接字时，才使用此选项。
</td>
</tr>
<tr>
<td colspan=2>--discovery-file string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
For file-based discovery, a file or URL from which to load cluster information.
对于基于文件的发现，给出用于加载集群信息的文件或者 URL。
</td>
</tr>
<tr>
<td colspan=2>--discovery-token string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对于基于令牌的发现，该令牌用于验证从 API 服务器获取的集群信息。
</td>
</tr>
<tr>
<td colspan=2>--discovery-token-ca-cert-hash stringSlice</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对于基于令牌的发现，验证根 CA 公钥是否匹配此哈希值（格式："&lt;type>:&lt;value>"）。
</td>
</tr>
<tr>
<td colspan=2>--discovery-token-unsafe-skip-ca-verification</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对于基于令牌的发现，允许在未关联 --discovery-token-ca-cert-hash 参数的情况下添加节点。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubelet-start 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>--node-name string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指定节点名称。
</td>
</tr>
<tr>
<td colspan=2>--tls-bootstrap-token string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指定在加入节点时用于临时通过 Kubernetes 控制平面进行身份验证的令牌。
</td>
</tr>
<tr>
<td colspan=2>--token string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果未提供这些值，则将它们用于 discovery-token 令牌和 tls-bootstrap 令牌。
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-47f2d404188d6eb1fbf6fffd7fba4e48>8.1.1.85 - </h1>
<h3 id=概要>概要</h3>
<p>运行 kubeadm join 命令添加节点前检查。</p>
<pre><code>kubeadm join phase preflight [api-server-endpoint] [flags]
</code></pre>
<h3 id=示例>示例</h3>
<pre><code># 使用配置文件运行 kubeadm join 命令添加节点前检查。
kubeadm join phase preflight --config kubeadm-config.yml
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对于将要托管新的控制平面实例的节点，指定 API 服务器将公布的其正在侦听的 IP 地址。如果未设置，则使用默认网络接口。
</td>
</tr>
<tr>
<td colspan=2>
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：6443
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
针对将要托管新的控制平面实例的节点，设置 API 服务器要绑定的端口。
</td>
</tr>
<tr>
<td colspan=2>--certificate-key string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
使用此密钥可以解密由 `init` 操作上传的证书 secret。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--control-plane</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
在此节点上创建一个新的控制平面实例
</td>
</tr>
<tr>
<td colspan=2>--cri-socket string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
提供给 CRI 套接字建立连接的路径。如果为空，则 kubeadm 将尝试自动检测该值；仅当安装了多个 CRI 或具有非标准 CRI 套接字时，才使用此选项。
</td>
</tr>
<tr>
<td colspan=2>--discovery-file string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对于基于文件的发现，给出用于加载集群信息的文件或者 URL。
</td>
</tr>
<tr>
<td colspan=2>--discovery-token string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对于基于令牌的发现，该令牌用于验证从 API 服务器获取的集群信息。
</td>
</tr>
<tr>
<td colspan=2>--discovery-token-ca-cert-hash stringSlice</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对于基于令牌的发现，验证根 CA 公钥是否匹配此哈希值（格式："&lt;type>:&lt;value>"）。
</td>
</tr>
<tr>
<td colspan=2>--discovery-token-unsafe-skip-ca-verification</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对于基于令牌的发现，允许在未关联 --discovery-token-ca-cert-hash 参数的情况下添加节点。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
preflight 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>--ignore-preflight-errors stringSlice</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
错误将显示为警告的检查列表；例如：'IsPrivilegedUser,Swap'。取值为 'all' 时将忽略检查中的所有错误。
</td>
</tr>
<tr>
<td colspan=2>--node-name string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指定节点名称。
</td>
</tr>
<tr>
<td colspan=2>--tls-bootstrap-token string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指定在加入节点时用于临时通过 Kubernetes 控制平面进行身份验证的令牌。
</td>
</tr>
<tr>
<td colspan=2>--token string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果未提供这些值，则将它们用于 discovery-token 令牌和 tls-bootstrap 令牌。
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-257824537b4c6c6b33249aa786461156>8.1.1.86 - </h1>
<p>Kubeconfig 文件工具。</p>
<h3 id=概要>概要</h3>
<p>kubeconfig 文件工具。</p>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeconfig 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-e10faf6f940de61052258af59e036518>8.1.1.87 - </h1>
<p>为其他用户输出一个 kubeconfig 文件。</p>
<h3 id=概要>概要</h3>
<p>为其他用户输出一个 kubeconfig 文件。</p>
<pre><code>kubeadm alpha kubeconfig user [flags]
</code></pre>
<h3 id=示例>示例</h3>
<pre><code># 使用名为 bar 的 kubeadm 配置文件为名为 foo 的另一用户输出 kubeconfig 文件
kubeadm kubeconfig user --client-name=foo --config=bar
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--client-name string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
用户名。如果生成客户端证书，则用作其 CN。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指向 kubeadm 配置文件的路径
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
user 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>--org strings</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
客户端证书的组织。如果创建客户端证书，此值将用作其 O 字段值。
</td>
</tr>
<tr>
<td colspan=2>--token string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
应该用此令牌做为 kubeconfig 的身份验证机制，而不是客户端证书
</td>
</tr>
<tr>
<td colspan=2>--validity-period duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: 8760h0m0s</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
<p>
客户证书的合法期限。所设置值为相对当前时间的偏移。
</p></td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 指向 '真实' 宿主机的根目录。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-a46a193f2322aa88cb3b2de2447b0461>8.1.1.88 - </h1>
<h3 id=概要>概要</h3>
<p>尽最大努力还原通过 'kubeadm init' 或者 'kubeadm join' 操作对主机所做的更改</p>
<p>"reset" 命令执行以下阶段：</p>
<pre><code>preflight              Run reset pre-flight checks
update-cluster-status  Remove this node from the ClusterStatus object.
remove-etcd-member     Remove a local etcd member.
cleanup-node           Run cleanup node.
</code></pre><pre><code>kubeadm reset [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
存储证书的目录路径。如果已指定，则需要清空此目录。
</td>
</tr>
<tr>
<td colspan=2>--cri-socket string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
要连接的 CRI 套接字的路径。如果为空，则 kubeadm 将尝试自动检测此值；仅当安装了多个CRI 或具有非标准 CRI 插槽时，才使用此选项。
</td>
</tr>
<tr>
<td colspan=2>-f, --force</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
在不提示确认的情况下重置节点。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
reset 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>--ignore-preflight-errors stringSlice</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
错误将显示为警告的检查列表；例如：'IsPrivilegedUser,Swap'。取值为 'all' 时将忽略检查中的所有错误。
</td>
</tr>
<tr>
<td colspan=2>
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
与集群通信时使用的 kubeconfig 文件。如果未设置该标志，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan=2>--skip-phases stringSlice</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
要跳过的阶段列表
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-f5b27d7bd0eeed918f8635c68d220dc5>8.1.1.89 - </h1>
<h3 id=概要>概要</h3>
<p>使用此命令来调用 <code>reset</code> 工作流程的某个阶段</p>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
phase 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-370e9ffda66b4c48dfa54ea37c3aad21>8.1.1.90 - </h1>
<h3 id=概要>概要</h3>
<p>执行 cleanup node（清理节点）操作。</p>
<pre><code>kubeadm reset phase cleanup-node [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
存储证书的目录路径。如果已指定，则需要清空此目录。
</td>
</tr>
<tr>
<td colspan=2>--cri-socket string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
要连接的 CRI 套接字的路径。如果为空，则 kubeadm 将尝试自动检测此值；仅当安装了多个CRI 或具有非标准 CRI 插槽时，才使用此选项。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
cleanup-node 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-6bd27042c883aa5c498647d37762392c>8.1.1.91 - </h1>
<h3 id=概要>概要</h3>
<p>kubeadm reset（重置）前运行启动前检查。</p>
<pre><code>kubeadm reset phase preflight [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>-f, --force</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
在不提示确认的情况下重置节点。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
preflight 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>--ignore-preflight-errors stringSlice</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
错误将显示为警告的检查列表；例如：'IsPrivilegedUser,Swap'。取值为 'all' 时将忽略检查中的所有错误。
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-3a000435e1cca0be398b44b487f530c8>8.1.1.92 - </h1>
<h3 id=概要>概要</h3>
<p>上传关于当前状态的配置，以便 'kubeadm upgrade' 以后可以知道如何配置升级后的集群。</p>
<pre><code>kubeadm config upload [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>upload 操作的帮助信息</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值： "/etc/kubernetes/admin.conf"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>用于和集群通信的 KubeConfig 文件。如果它没有被设置，那么 kubeadm 将会搜索一个已经存在于标准路径的 KubeConfig 文件。</td>
</tr>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>[实验] 到'真实'主机根文件系统的路径。</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-97fbe97ca22de377e7fbf2517e0451b6>8.1.1.93 - </h1>
<h3 id=概要>概要</h3>
<p>如果该节点是控制平面节点，从 ClusterStatus 对象中删除该节点。</p>
<pre><code>kubeadm reset phase update-cluster-status [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
update-cluster-status 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-bee6749065a369c2ab5b311eb43c40ba>8.1.1.94 - </h1>
<h3 id=概要>概要</h3>
<p>此命令管理引导令牌（bootstrap token）。它是可选的，仅适用于高级用例。</p>
<p>简而言之，引导令牌（bootstrap token）用于在客户端和服务器之间建立双向信任。
当客户端（例如，即将加入集群的节点）需要时，可以使用引导令牌相信正在与之通信的服务器。
然后可以使用具有 “签名” 的引导令牌。</p>
<p>引导令牌还可以作为一种允许对 API 服务器进行短期身份验证的方法（令牌用作 API 服务器信任客户端的方式），例如用于执行 TLS 引导程序。</p>
<p>引导令牌准确来说是什么？</p>
<ul>
<li>它是位于 kube-system 命名空间中类型为 “bootstrap.kubernetes.io/token” 的一个 Secret。</li>
<li>引导令牌的格式必须为 “[a-z0-9]{6}.[a-z0-9]{16}”，前一部分是公共令牌 ID，而后者是令牌秘钥，必须在任何情况下都保密！</li>
<li>必须将 Secret 的名称命名为 “bootstrap-token-(token-id)”。</li>
</ul>
<p>您可以在此处阅读有关引导令牌（bootstrap token）的更多信息：
/docs/admin/bootstrap-tokens/</p>
<pre><code>kubeadm token [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--dry-run</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
是否启用 `dry-run` 模式
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
token 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
与集群通信时使用的 kubeconfig 文件。如果未设置，则搜索一组标准位置以查找现有 kubeconfig 文件。
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-bdd9680ec894593d17f782d5e5665fd4>8.1.1.95 - </h1>
<h3 id=概要>概要</h3>
<p>这个命令将为你创建一个引导令牌。
您可以设置此令牌的用途，"有效时间" 和可选的人性化的描述。</p>
<p>这里的 [token] 是指将要生成的实际令牌。
该令牌应该是一个通过安全机制生成的随机令牌，形式为 "[a-z0-9]{6}.[a-z0-9]{16}"。
如果没有给出 [token]，kubeadm 将生成一个随机令牌。</p>
<pre><code>kubeadm token create [token]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--description string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
针对令牌用途的人性化的描述。
</td>
</tr>
<tr>
<td colspan=2>
--groups stringSlice&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：[system:bootstrappers:kubeadm:default-node-token]
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
此令牌用于身份验证时将进行身份验证的其他组。必须匹配 "\\Asystem:bootstrappers:[a-z0-9:-]{0,255}[a-z0-9]\\z"
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
create 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>--print-join-command</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
不仅仅打印令牌，而是打印使用令牌加入集群所需的完整 'kubeadm join' 参数。
</td>
</tr>
<tr>
<td colspan=2>
--ttl duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：24h0m0s
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
令牌有效时间，超过该时间令牌被自动删除。(例如： 1s, 2m, 3h)。如果设置为 '0'，令牌将永远不过期。
</td>
</tr>
<tr>
<td colspan=2>
--usages stringSlice&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：[signing,authentication]
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
描述可以使用此令牌的方式。你可以多次使用 `--usages` 或者提供一个以逗号分隔的选项列表。合法选项有: [signing,authentication]
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--dry-run</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
是否启用 `dry-run` 运行模式
</td>
</tr>
<tr>
<td colspan=2>
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
用于和集群通信的 KubeConfig 文件。如果它没有被设置，那么 kubeadm 将会搜索一个已经存在于标准路径的 KubeConfig 文件。
</td>
</tr>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-1d005baad1a1e217d7ae0210fec96c3f>8.1.1.96 - </h1>
<h3 id=概要>概要</h3>
<p>这个命令将为你删除指定的引导令牌列表。</p>
<p><code>[token-value]</code> 是要删除的 "[a-z0-9]{6}.[a-z0-9]{16}" 形式的完整令牌或者是 "[a-z0-9]{6}" 形式的的令牌 ID。</p>
<pre><code>kubeadm token delete [token-value] ...
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
delete 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--dry-run</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
是否启用 `dry-run` 运行模式
</td>
</tr>
<tr>
<td colspan=2>
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
用于和集群通信的 KubeConfig 文件。如果它没有被设置，那么 kubeadm 将会搜索一个已经存在于标准路径的 KubeConfig 文件。
</td>
</tr>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-c79d11d27bed54caac743c93e0b2fb24>8.1.1.97 - </h1>
<h3 id=概要>概要</h3>
<p>此命令将打印一个随机生成的可以被 "init" 和 "join" 命令使用的引导令牌。
您不必使用此命令来生成令牌。你可以自己设定，只要格式符合 "[a-z0-9]{6}.[a-z0-9]{16}"。这个命令提供是为了方便生成规定格式的令牌。
您也可以使用 "kubeadm init" 并且不指定令牌，该命令会生成一个令牌并打印出来。</p>
<pre><code>kubeadm token generate [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
generate 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--dry-run</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
是否启用 `dry-run` 运行模式</td>
</tr>
<tr>
<td colspan=2>
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
用于和集群通信的 KubeConfig 文件。如果它没有被设置，那么 kubeadm 将会搜索一个已经存在于标准路径的 KubeConfig 文件。
</td>
</tr>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-ba78e64c325e4131dd741235e2a1b2c0>8.1.1.98 - </h1>
<h3 id=概要>概要</h3>
<p>此命令将为您列出所有的引导令牌。</p>
<pre><code>kubeadm token list [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>
--allow-missing-template-keys&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：true
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果设置为 true，则在模板中缺少字段或哈希表的键时忽略模板中的任何错误。
仅适用于 golang 和 jsonpath 输出格式。
</td>
</tr>
<tr>
<td colspan=2>
-o, --experimental-output string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："text"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
输出格式：text|json|yaml|go-template|go-template-file|template|templatefile|jsonpath|jsonpath-as-json|jsonpath-file 其中之一
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
list 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--dry-run</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
是否启用 `dry-run` 模式
</td>
</tr>
<tr>
<td colspan=2>
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
用于和集群通信的 kubeconfig 文件。如果它没有被设置，那么 kubeadm 将会搜索一个已经存在于标准路径的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-872d33f1fbc83cb2f0bf89b4bd545174>8.1.1.99 - </h1>
<p>此命令能将集群平滑升级到新版本</p>
<h3 id=概要>概要</h3>
<p>此命令能将集群平滑升级到新版本</p>
<pre><code>kubeadm upgrade [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
<p>upgrade 操作的帮助命令<p>
</td>
</tr>
</tbody>
</table>
<h3 id=继承于父命令的选项>继承于父命令的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
<p>[实验] 指向 '真实' 宿主机根文件系统的路径。<p>
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-7d8c1710684742ca940f580674225d9d>8.1.1.100 - </h1>
<h3 id=概要>概要</h3>
<p>将 Kubernetes 集群升级到指定版本</p>
<pre><code>kubeadm upgrade apply [version]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--allow-experimental-upgrades</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
显示 Kubernetes 的不稳定版本作为升级替代方案，并允许升级到 Kubernetes 的 alpha/beta 或 RC 版本。
</td>
</tr>
<tr>
<td colspan=2>--allow-release-candidate-upgrades</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
显示 Kubernetes 的候选版本作为升级替代方案，并允许升级到 Kubernetes 的 RC 版本。
</td>
</tr>
<tr>
<td colspan=2>--certificate-renewal&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: true</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
执行升级期间更改的组件所使用的证书的更新。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--dry-run</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
不要更改任何状态，只输出要执行的操作。
</td>
</tr>
<tr>
<td colspan=2>
--etcd-upgrade&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值: true
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
执行 etcd 的升级。
</td>
</tr>
<tr>
<td colspan=2>--experimental-patches string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
包含名为 "target[suffix][+patchtype].extension" 的文件的目录的路径。
例如，"kube-apiserver0+merge.yaml" 或仅仅是 "etcd.json"。
"patchtype" 可以是 "strategic"、"merge" 或 "json" 之一，并且它们与 kubectl 支持的补丁格式匹配。
默认的 "patchtype" 为 "strategic"。 "extension" 必须为 "json" 或 "yaml"。
"suffix" 是一个可选字符串，可用于确定首先按字母顺序应用哪些补丁。
</td>
</tr>
<tr>
<td colspan=2>--feature-gates string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
一组键值对，用于描述各种功能。选项包括：
<br>IPv6DualStack=true|false (ALPHA - 默认=false)
<br>PublicKeysECDSA=true|false (ALPHA - 默认=false)
</td>
</tr>
<tr>
<td colspan=2>-f, --force</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
强制升级，但可能无法满足某些要求。这也意味着非交互模式。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
apply 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>--ignore-preflight-errors stringSlice</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
错误将显示为警告的检查列表；例如：'IsPrivilegedUser,Swap'。取值为 'all' 时将忽略检查中的所有错误。
</td>
</tr>
<tr>
<td colspan=2>
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
与集群通信时使用的 kubeconfig 文件。如果未设置标志，则在相关目录下搜索以查找现有 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan=2>--print-config</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指定是否应打印将在升级中使用的配置文件。
</td>
</tr>
<tr>
<td colspan=2>-y, --yes</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
执行升级，不提示确认（非交互模式）。
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-28dcf20d89c7bb1c8e7a3873d7703d5d>8.1.1.101 - </h1>
<h3 id=概述>概述</h3>
<p>显示哪些差异将被应用于现有的静态 pod 资源清单。参考: kubeadm upgrade apply --dry-run</p>
<pre><code>kubeadm upgrade diff [version] [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--api-server-manifest string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/manifests/kube-apiserver.yaml"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>API服务器清单的路径</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>kubeadm 配置文件的路径</td>
</tr>
<tr>
<td colspan=2>-c, --context-lines int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：3</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>差异中有多少行上下文</td>
</tr>
<tr>
<td colspan=2>--controller-manager-manifest string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值： "/etc/kubernetes/manifests/kube-controller-manager.yaml"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>控制器清单的路径</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>帮助</td>
</tr>
<tr>
<td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>与集群通信时使用的 kubeconfig 文件，如果标志是未设置，则可以在一组标准位置中搜索现有的 kubeconfig 文件。</td>
</tr>
<tr>
<td colspan=2>--scheduler-manifest string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/manifests/kube-scheduler.yaml"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>调度程序清单的路径</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>[EXPERIMENTAL] “真实”主机根文件系统的路径。</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-f869b6331e40c6f9eb01314f96d3113e>8.1.1.102 - </h1>
<h3 id=概要>概要</h3>
<p>升级集群中某个节点的命令</p>
<p>"node" 命令执行以下阶段：</p>
<pre><code>preflight       执行节点升级前检查
control-plane   如果存在的话，升级部署在该节点上的管理面实例
kubelet-config  更新该节点上的 kubelet 配置
</code></pre><pre><code>kubeadm upgrade node [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--certificate-renewal</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对升级期间变化的组件所使用的证书执行更新。
</td>
</tr>
<tr>
<td colspan=2>--dry-run</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
不更改任何状态，只输出将要执行的操作。
</td>
</tr>
<tr>
<td colspan=2>--etcd-upgrade&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值: true</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
执行 etcd 的升级。
</td>
</tr>
<tr>
<td colspan=2>--experimental-patches string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
包含名为 "target[suffix][+patchtype].extension" 的文件的目录的路径。
例如，"kube-apiserver0+merge.yaml" 或仅仅是 "etcd.json"。
"patchtype" 可以是 "strategic"、"merge" 或 "json" 之一，并且它们与 kubectl 支持的补丁格式匹配。
默认的 "patchtype" 为 "strategic"。 "extension" 必须为 "json" 或 "yaml"。
"suffix" 是一个可选字符串，可用于确定首先按字母顺序应用哪些补丁。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
node 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值: "/etc/kubernetes/admin.conf"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
用于与集群交互的 kubeconfig 文件。如果参数未指定，将从一系列标准位置检索存在的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan=2>--kubelet-version string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
升级后 *期望的* kubelet 配置版本。如未指定，将使用 kubeadm-config ConfigMap 中的 KubernetesVersion
</td>
</tr>
<tr>
<td colspan=2>--skip-phases stringSlice</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
要跳过的阶段的列表
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-19a94d2f7649959b218952cef00729f4>8.1.1.103 - </h1>
<h3 id=概要>概要</h3>
<p>使用此命令调用 node 工作流的某个阶段</p>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
phase 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-b22d3ed181fb7f926ae2081f8fc8c14d>8.1.1.104 - </h1>
<h3 id=概要>概要</h3>
<p>升级部署在此节点上的控制平面实例，如果有的话</p>
<pre><code>kubeadm upgrade node phase control-plane [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--certificate-renewal</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>更新在升级期间变更的组件使用的证书。</td>
</tr>
<tr>
<td colspan=2>--dry-run</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>不改变任何状态，只输出将要执行的动作。</td>
</tr>
<tr>
<td colspan=2>--etcd-upgrade&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值: true</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>执行 etcd 的升级。</td>
</tr>
<tr>
<td colspan=2>--experimental-patches string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
包含名为 "target[suffix][+patchtype].extension" 的文件的目录的路径。
例如，"kube-apiserver0+merge.yaml" 或仅仅是 "etcd.json"。
"patchtype" 可以是 "strategic"、"merge" 或 "json" 之一，并且它们与 kubectl 支持的补丁格式匹配。
默认的 "patchtype" 为 "strategic"。 "extension" 必须为 "json" 或 "yaml"。
"suffix" 是一个可选字符串，可用于确定首先按字母顺序应用哪些补丁。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>control-plane 的帮助信息</td>
</tr>
<tr>
<td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值: "/etc/kubernetes/admin.conf"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>用于和集群通信的 KubeConfig 文件。如果它没有被设置，那么 kubeadm 将会搜索一个已经存在于标准路径的 KubeConfig 文件。</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>[实验] 到'真实'主机根文件系统的路径。</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-ae1ea74c2c21b25a3c1eacdaf549274b>8.1.1.105 - </h1>
<p>从群集中 "kubelet-config-1.X" 的 ConfigMap 下载 kubelet 配置，其中 X 是kubelet 的次要版本。
kubeadm 使用 --kubelet-version 参数来确定所需的 kubelet 版本。</p>
<pre><code>kubeadm upgrade node phase kubelet-config [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--dry-run</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>不改变任何状态，只输出将要执行的操作</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>配置操作的帮助信息</td>
</tr>
<tr>
<td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值： "/etc/kubernetes/kubelet.conf"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>用于和集群通信的 KubeConfig 文件。如果它没有被设置，那么 kubeadm 将会搜索一个已经存在于标准路径的 KubeConfig 文件。</td>
</tr>
<tr>
<td colspan=2>--kubelet-version string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>升级后的 kubelet 的*期望*版本。</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>[实验] 到'真实'主机根文件系统的路径。</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-633020ef232bc34f60c82153578a6c9b>8.1.1.106 - </h1>
<p>执行 kubeadm 升级节点的预检。</p>
<pre><code>kubeadm upgrade node phase preflight [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>preflight 操作的帮助命令</td>
</tr>
<tr>
<td colspan=2>--ignore-preflight-errors stringSlice</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>错误将显示为警告的检查清单。示例：'IsPrivilegedUser,Swap'。值为'all'表示忽略所有检查的错误。</td>
</tr>
</tbody>
</table>
<h3 id=继承于父命令的选项>继承于父命令的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>[实验] 到'真实'主机根文件系统的路径。</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-e938edeb3d824f9b364de617a1f10a93>8.1.1.107 - </h1>
<h3 id=概述>概述</h3>
<p>检查可升级到哪些版本，并验证您当前的集群是否可升级。 要跳过互联网检查，请传递可选的 [version] 参数</p>
<pre><code>kubeadm upgrade plan [version] [flags]
</code></pre><h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--allow-experimental-upgrades</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>显示不稳定版本的 Kubernetes 作为升级替代方案，并允许升级到 Kubernetes 的 Alpha/Beta/发行候选版本。</td>
</tr>
<tr>
<td colspan=2>--allow-release-candidate-upgrades</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>显示 Kubernetes 的发行候选版本作为升级选择，并允许升级到 Kubernetes 的发行候选版本。</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>配置文件的路径。</td>
</tr>
<tr>
<td colspan=2>--feature-gates string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>一组描述各种特征特性门控的键值对。选项有：IPv6DualStack=true|false (ALPHA - default=false) PublicKeysECDSA=true|false (ALPHA - default=false)</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>帮助</td>
</tr>
<tr>
<td colspan=2>--ignore-preflight-errors stringSlice</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>检查清单，其错误将显示为警告。 例如：“IsPrivilegedUser，Swap”。 值 “all” 忽略所有检查的错误。</td>
</tr>
<tr>
<td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>与集群通信时使用的 kubeconfig 文件。 如果标志为未设置，则可以在一组标准位置中搜索现有的 kubeconfig 文件。</td>
</tr>
<tr>
<td colspan=2>--print-config</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>指定是否打印将在升级中使用的配置文件。</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>[EXPERIMENTAL] “真实”主机根文件系统的路径。</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-aa9f718186487df2ab6885cae45f5d37>8.1.1.108 - </h1>
<h3 id=概要>概要</h3>
<p>打印 kubeadm 的版本</p>
<pre><code>kubeadm version [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
version 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>-o, --output string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
输出格式；可用的选项有 'yaml', 'json' 和 'short'
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-60d816e74ec8e0301cc484b19d7694e6>8.1.1.109 - </h1>
<p>此目录下的所有文件都是从其他仓库自动生成的。 <strong>不要人工编辑它们。 您必须在上游仓库中编辑它们</strong></p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-82b2fcf985bae77dcb754387a9fcc64f>8.1.2 - kubeadm init</h1>
<p>此命令初始化一个 Kubernetes 控制平面节点。</p>
<h3 id=概要>概要</h3>
<p>运行此命令来搭建 Kubernetes 控制平面节点。</p>
<p>"init" 命令执行以下阶段：</p>
<pre><code>preflight                    Run pre-flight checks
certs                        Certificate generation
  /ca                          Generate the self-signed Kubernetes CA to provision identities for other Kubernetes components
  /apiserver                   Generate the certificate for serving the Kubernetes API
  /apiserver-kubelet-client    Generate the certificate for the API server to connect to kubelet
  /front-proxy-ca              Generate the self-signed CA to provision identities for front proxy
  /front-proxy-client          Generate the certificate for the front proxy client
  /etcd-ca                     Generate the self-signed CA to provision identities for etcd
  /etcd-server                 Generate the certificate for serving etcd
  /etcd-peer                   Generate the certificate for etcd nodes to communicate with each other
  /etcd-healthcheck-client     Generate the certificate for liveness probes to healthcheck etcd
  /apiserver-etcd-client       Generate the certificate the apiserver uses to access etcd
  /sa                          Generate a private key for signing service account tokens along with its public key
kubeconfig                   Generate all kubeconfig files necessary to establish the control plane and the admin kubeconfig file
  /admin                       Generate a kubeconfig file for the admin to use and for kubeadm itself
  /kubelet                     Generate a kubeconfig file for the kubelet to use *only* for cluster bootstrapping purposes
  /controller-manager          Generate a kubeconfig file for the controller manager to use
  /scheduler                   Generate a kubeconfig file for the scheduler to use
kubelet-start                Write kubelet settings and (re)start the kubelet
control-plane                Generate all static Pod manifest files necessary to establish the control plane
  /apiserver                   Generates the kube-apiserver static Pod manifest
  /controller-manager          Generates the kube-controller-manager static Pod manifest
  /scheduler                   Generates the kube-scheduler static Pod manifest
etcd                         Generate static Pod manifest file for local etcd
  /local                       Generate the static Pod manifest file for a local, single-node local etcd instance
upload-config                Upload the kubeadm and kubelet configuration to a ConfigMap
  /kubeadm                     Upload the kubeadm ClusterConfiguration to a ConfigMap
  /kubelet                     Upload the kubelet component config to a ConfigMap
upload-certs                 Upload certificates to kubeadm-certs
mark-control-plane           Mark a node as a control-plane
bootstrap-token              Generates bootstrap tokens used to join a node to a cluster
kubelet-finalize             Updates settings relevant to the kubelet after TLS bootstrap
  /experimental-cert-rotation  Enable kubelet client certificate rotation
addon                        Install required addons for passing Conformance tests
  /coredns                     Install the CoreDNS addon to a Kubernetes cluster
  /kube-proxy                  Install the kube-proxy addon to a Kubernetes cluster
</code></pre><pre><code>kubeadm init [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
API 服务器所公布的其正在监听的 IP 地址。如果未设置，则使用默认网络接口。
</td>
</tr>
<tr>
<td colspan=2>
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：6443
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
API 服务器绑定的端口。
</td>
</tr>
<tr>
<td colspan=2>--apiserver-cert-extra-sans stringSlice</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
用于 API Server 服务证书的可选附加主题备用名称（SAN）。可以是 IP 地址和 DNS 名称。
</td>
</tr>
<tr>
<td colspan=2>
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
保存和存储证书的路径。
</td>
</tr>
<tr>
<td colspan=2>--certificate-key string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
用于加密 kubeadm-certs Secret 中的控制平面证书的密钥。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--control-plane-endpoint string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面指定一个稳定的 IP 地址或 DNS 名称。
</td>
</tr>
<tr>
<td colspan=2>--cri-socket string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
要连接的 CRI 套接字的路径。如果为空，则 kubeadm 将尝试自动检测此值；仅当安装了多个 CRI 或具有非标准 CRI 插槽时，才使用此选项。
</td>
</tr>
<tr>
<td colspan=2>--dry-run</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
不要应用任何更改；只是输出将要执行的操作。
</td>
</tr>
<tr>
<td colspan=2>--experimental-patches string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
包含名为 "target[suffix][+patchtype].extension" 的文件的目录路径。
例如，"kube-apiserver0+merge.yaml" 或仅仅是 "etcd.json"。
"patchtype" 可以是 "strategic"、"merge" 或 "json" 之一，并且它们与 kubectl 支持的补丁格式匹配。
默认的 "patchtype" 为 "strategic"。 "extension" 必须为 "json" 或 "yaml"。
"suffix" 是一个可选字符串，可用于确定首先按字母顺序应用哪些补丁。
</td>
</tr>
<tr>
<td colspan=2>--feature-gates string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
一组用来描述各种功能特性的键值（key=value）对。选项是：<br>IPv6DualStack=true|false (ALPHA - default=false)
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
init 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>--ignore-preflight-errors stringSlice</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
错误将显示为警告的检查列表；例如：'IsPrivilegedUser,Swap'。取值为 'all' 时将忽略检查中的所有错误。
</td>
</tr>
<tr>
<td colspan=2>
--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："k8s.gcr.io"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
选择用于拉取控制平面镜像的容器仓库
</td>
</tr>
<tr>
<td colspan=2>
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面选择一个特定的 Kubernetes 版本。
</td>
</tr>
<tr>
<td colspan=2>--node-name string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指定节点的名称。
</td>
</tr>
<tr>
<td colspan=2>--pod-network-cidr string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指明 pod 网络可以使用的 IP 地址段。如果设置了这个参数，控制平面将会为每一个节点自动分配 CIDRs。
</td>
</tr>
<tr>
<td colspan=2>
--service-cidr string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："10.96.0.0/12"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为服务的虚拟 IP 地址另外指定 IP 地址段
</td>
</tr>
<tr>
<td colspan=2>
--service-dns-domain string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："cluster.local"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为服务另外指定域名，例如："myorg.internal"。
</td>
</tr>
<tr>
<td colspan=2>--skip-certificate-key-print</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
不要打印用于加密控制平面证书的密钥。
</td>
</tr>
<tr>
<td colspan=2>--skip-phases stringSlice</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
要跳过的阶段列表
</td>
</tr>
<tr>
<td colspan=2>--skip-token-print</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
跳过打印 'kubeadm init' 生成的默认引导令牌。
</td>
</tr>
<tr>
<td colspan=2>--token string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
这个令牌用于建立控制平面节点与工作节点间的双向通信。格式为 [a-z0-9]{6}\.[a-z0-9]{16} - 示例：abcdef.0123456789abcdef
</td>
</tr>
<tr>
<td colspan=2>
--token-ttl duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：24h0m0s
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
令牌被自动删除之前的持续时间（例如 1 s，2 m，3 h）。如果设置为 '0'，则令牌将永不过期
</td>
</tr>
<tr>
<td colspan=2>--upload-certs</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
将控制平面证书上传到 kubeadm-certs Secret。
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
<h3 id=init-workflow>Init 命令的工作流程</h3>
<p><code>kubeadm init</code> 命令通过执行下列步骤来启动一个 Kubernetes 控制平面节点。</p>
<ol>
<li>在做出变更前运行一系列的预检项来验证系统状态。一些检查项目仅仅触发警告，
其它的则会被视为错误并且退出 kubeadm，除非问题得到解决或者用户指定了
<code>--ignore-preflight-errors=&lt;错误列表></code> 参数。</li>
</ol>
<ol start=2>
<li>生成一个自签名的 CA 证书来为集群中的每一个组件建立身份标识。
用户可以通过将其放入 <code>--cert-dir</code> 配置的证书目录中（默认为 <code>/etc/kubernetes/pki</code>）
来提供他们自己的 CA 证书以及/或者密钥。
APIServer 证书将为任何 <code>--apiserver-cert-extra-sans</code> 参数值提供附加的 SAN 条目，必要时将其小写。</li>
</ol>
<ol start=3>
<li>将 kubeconfig 文件写入 <code>/etc/kubernetes/</code> 目录以便 kubelet、控制器管理器和调度器用来连接到
API 服务器，它们每一个都有自己的身份标识，同时生成一个名为 <code>admin.conf</code> 的独立的 kubeconfig
文件，用于管理操作。</li>
</ol>
<ol start=4>
<li>
<p>为 API 服务器、控制器管理器和调度器生成静态 Pod 的清单文件。假使没有提供一个外部的 etcd
服务的话，也会为 etcd 生成一份额外的静态 Pod 清单文件。</p>
<p>静态 Pod 的清单文件被写入到 <code>/etc/kubernetes/manifests</code> 目录;
kubelet 会监视这个目录以便在系统启动的时候创建 Pod。</p>
<p>一旦控制平面的 Pod 都运行起来， <code>kubeadm init</code> 的工作流程就继续往下执行。</p>
</li>
</ol>
<ol start=5>
<li>对控制平面节点应用标签和污点标记以便不会在它上面运行其它的工作负载。</li>
</ol>
<ol start=6>
<li>生成令牌，将来其他节点可使用该令牌向控制平面注册自己。
如 <a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-token/>kubeadm token</a> 文档所述，
用户可以选择通过 <code>--token</code> 提供令牌。</li>
</ol>
<ol start=7>
<li>
<p>为了使得节点能够遵照<a href=/zh/docs/reference/access-authn-authz/bootstrap-tokens/>启动引导令牌</a>
和 <a href=/zh/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/>TLS 启动引导</a>
这两份文档中描述的机制加入到集群中，kubeadm 会执行所有的必要配置：</p>
<ul>
<li>
<p>创建一个 ConfigMap 提供添加集群节点所需的信息，并为该 ConfigMap 设置相关的 RBAC 访问规则。</p>
</li>
<li>
<p>允许启动引导令牌访问 CSR 签名 API。</p>
</li>
<li>
<p>配置自动签发新的 CSR 请求。</p>
</li>
</ul>
<p>更多相关信息，请查看 <a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-join/>kubeadm join</a>。</p>
</li>
</ol>
<ol start=8>
<li>
<p>通过 API 服务器安装一个 DNS 服务器 (CoreDNS) 和 kube-proxy 附加组件。
在 Kubernetes 版本 1.11 和更高版本中，CoreDNS 是默认的 DNS 服务器。
请注意，尽管已部署 DNS 服务器，但直到安装 CNI 时才调度它。</p>
<div class="alert alert-danger warning callout" role=alert>
<strong>Warning:</strong> 从 v1.18 开始，在 kubeadm 中使用 kube-dns 的支持已被废弃，并已在 v1.21 版本中删除。
</div>
</li>
</ol>
<h3 id=init-phases>在 kubeadm 中使用 init phases</h3>
<p>Kubeadm 允许你使用 <code>kubeadm init phase</code> 命令分阶段创建控制平面节点。</p>
<p>要查看阶段和子阶段的有序列表，可以调用 <code>kubeadm init --help</code>。
该列表将位于帮助屏幕的顶部，每个阶段旁边都有一个描述。
注意，通过调用 <code>kubeadm init</code>，所有阶段和子阶段都将按照此确切顺序执行。</p>
<p>某些阶段具有唯一的标志，因此，如果要查看可用选项的列表，请添加 <code>--help</code>，例如：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>sudo kubeadm init phase control-plane controller-manager --help
</code></pre></div>
<p>你也可以使用 <code>--help</code> 查看特定父阶段的子阶段列表：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>sudo kubeadm init phase control-plane --help
</code></pre></div>
<p><code>kubeadm init</code> 还公开了一个名为 <code>--skip-phases</code> 的参数，该参数可用于跳过某些阶段。
参数接受阶段名称列表，并且这些名称可以从上面的有序列表中获取。</p>
<p>例如：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>sudo kubeadm init phase control-plane all --config<span style=color:#666>=</span>configfile.yaml
sudo kubeadm init phase etcd <span style=color:#a2f>local</span> --config<span style=color:#666>=</span>configfile.yaml
<span style=color:#080;font-style:italic># 你现在可以修改控制平面和 etcd 清单文件</span>
sudo kubeadm init --skip-phases<span style=color:#666>=</span>control-plane,etcd --config<span style=color:#666>=</span>configfile.yaml
</code></pre></div>
<p>该示例将执行的操作是基于 <code>configfile.yaml</code> 中的配置在 <code>/etc/kubernetes/manifests</code>
中写入控制平面和 etcd 的清单文件。
这允许你修改文件，然后使用 <code>--skip-phases</code> 跳过这些阶段。
通过调用最后一个命令，你将使用自定义清单文件创建一个控制平面节点。</p>
<h3 id=config-file>结合一份配置文件来使用 kubeadm init</h3>
<div class="alert alert-warning caution callout" role=alert>
<strong>Caution:</strong> 配置文件的功能仍然处于 alpha 状态并且在将来的版本中可能会改变。
</div>
<p>通过一份配置文件而不是使用命令行参数来配置 <code>kubeadm init</code> 命令是可能的，
但是一些更加高级的功能只能够通过配置文件设定。
这份配置文件通过 <code>--config</code> 选项参数指定的，
它必须包含 <code>ClusterConfiguration</code> 结构，并可能包含更多由 <code>---\n</code> 分隔的结构。
在某些情况下，可能不允许将 <code>--config</code> 与其他标志混合使用。</p>
<p>可以使用 <a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-config/>kubeadm config print</a>
命令打印出默认配置。</p>
<p>如果你的配置没有使用最新版本，
<strong>推荐</strong>使用 <a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-config/>kubeadm config migrate</a>
命令进行迁移。</p>
<p>有关配置的字段和用法的更多信息，
你可以访问 API 参考页面并从
<a href=https://pkg.go.dev/k8s.io/kubernetes/cmd/kubeadm/app/apis/kubeadm#section-directories>列表</a>
中选择一个版本。</p>
<h3 id=kube-proxy>添加 kube-proxy 参数</h3>
<p>kubeadm 配置中有关 kube-proxy 的说明请查看：</p>
<ul>
<li><a href=/zh/docs/reference/config-api/kube-proxy-config.v1alpha1/>kube-proxy 参考</a></li>
</ul>
<p>使用 kubeadm 启用 IPVS 模式的说明请查看：</p>
<ul>
<li><a href=https://github.com/kubernetes/kubernetes/blob/master/pkg/proxy/ipvs/README.md>IPVS</a></li>
</ul>
<h3 id=control-plane-flags>向控制平面组件传递自定义的命令行参数</h3>
<p>有关向控制平面组件传递命令行参数的说明请查看：
<a href=/zh/docs/setup/production-environment/tools/kubeadm/control-plane-flags/>控制平面命令行参数</a></p>
<h3 id=custom-images>使用自定义的镜像</h3>
<p>默认情况下, kubeadm 会从 <code>k8s.gcr.io</code> 仓库拉取镜像。如果请求的 Kubernetes 版本是 CI 标签
（例如 <code>ci/latest</code>），则使用 <code>gcr.io/k8s-staging-ci-images</code>。</p>
<p>你可以通过使用<a href=#config-file>带有配置文件的 kubeadm</a> 来重写此操作。</p>
<p>允许的自定义功能有：</p>
<ul>
<li>使用其他的 <code>imageRepository</code> 来代替 <code>k8s.gcr.io</code>。</li>
<li>将 <code>useHyperKubeImage</code> 设置为 <code>true</code>，使用 HyperKube 镜像。</li>
<li>为 etcd 或 DNS 附件提供特定的 <code>imageRepository</code> 和 <code>imageTag</code>。</li>
</ul>
<p>请注意配置文件中的配置项 <code>kubernetesVersion</code> 或者命令行参数 <code>--kubernetes-version</code>
会影响到镜像的版本。</p>
<h3 id=将控制平面证书上传到集群>将控制平面证书上传到集群</h3>
<p>通过将参数 <code>--upload-certs</code> 添加到 <code>kubeadm init</code>，你可以将控制平面证书临时上传到集群中的 Secret。
请注意，此 Secret 将在 2 小时后自动过期。证书使用 32 字节密钥加密，可以使用 <code>--certificate-key</code> 指定。
通过将 <code>--control-plane</code> 和 <code>--certificate-key</code> 传递给 <code>kubeadm join</code>，
可以在添加其他控制平面节点时使用相同的密钥下载证书。</p>
<p>以下阶段命令可用于证书到期后重新上传证书：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubeadm init phase upload-certs --upload-certs --certificate-key<span style=color:#666>=</span>SOME_VALUE --config<span style=color:#666>=</span>SOME_YAML_FILE
</code></pre></div>
<p>如果未将参数 <code>--certificate-key</code> 传递给 <code>kubeadm init</code> 和 <code>kubeadm init phase upload-certs</code>，
则会自动生成一个新密钥。</p>
<p>以下命令可用于按需生成新密钥：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubeadm certs certificate-key
</code></pre></div>
<h3 id=使用-kubeadm-管理证书>使用 kubeadm 管理证书</h3>
<p>有关使用 kubeadm 进行证书管理的详细信息，请参阅
<a href=/zh/docs/tasks/administer-cluster/kubeadm/kubeadm-certs/>使用 kubeadm 进行证书管理</a>。
该文档包括有关使用外部 CA，自定义证书和证书更新的信息。</p>
<h3 id=kubelet-drop-in>管理 kubeadm 为 kubelet 提供的 systemd 配置文件</h3>
<p><code>kubeadm</code> 包自带了关于 <code>systemd</code> 如何运行 <code>kubelet</code> 的配置文件。
请注意 <code>kubeadm</code> 客户端命令行工具永远不会修改这份 <code>systemd</code> 配置文件。
这份 <code>systemd</code> 配置文件属于 kubeadm DEB/RPM 包。</p>
<p>有关更多信息，请阅读
<a href=/zh/docs/setup/production-environment/tools/kubeadm/kubelet-integration/#the-kubelet-drop-in-file-for-systemd>管理 systemd 的 kubeadm 内嵌文件</a>。</p>
<h3 id=结合-cri-运行时使用-kubeadm>结合 CRI 运行时使用 kubeadm</h3>
<p>默认情况下，kubeadm 尝试检测你的容器运行环境。有关此检测的更多详细信息，请参见
<a href=/zh/docs/setup/production-environment/tools/kubeadm/install-kubeadm/#installing-runtime>kubeadm CRI 安装指南</a>。</p>
<h3 id=设置节点的名称>设置节点的名称</h3>
<p>默认情况下, <code>kubeadm</code> 基于机器的主机地址分配一个节点名称。你可以使用 <code>--node-name</code> 参数覆盖此设置。
此标识将合适的
<a href=/zh/docs/reference/command-line-tools-reference/kubelet/#options><code>--hostname-override</code></a>
值传递给 kubelet。</p>
<h3 id=在没有互联网连接的情况下运行-kubeadm>在没有互联网连接的情况下运行 kubeadm</h3>
<p>要在没有互联网连接的情况下运行 kubeadm，你必须提前拉取所需的控制平面镜像。</p>
<p>你可以使用 <code>kubeadm config images</code> 子命令列出并拉取镜像：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubeadm config images list
kubeadm config images pull
</code></pre></div>
<p>kubeadm 需要的所有镜像，例如 <code>k8s.gcr.io/kube-*</code>、<code>k8s.gcr.io/etcd</code> 和 <code>k8s.gcr.io/pause</code>
都支持多种架构。</p>
<h3 id=kubeadm-自动化>kubeadm 自动化</h3>
<p>除了像文档 <a href=/zh/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/>kubeadm 基础教程</a>
中所描述的那样，将从 <code>kubeadm init</code> 取得的令牌复制到每个节点，
你还可以并行地分发令牌以实现简单自动化。
要实现自动化，你必须知道控制平面节点启动后将拥有的 IP 地址，或使用 DNS 名称或负载均衡器的地址。</p>
<ol>
<li>
<p>生成一个令牌。这个令牌必须具有以下格式：<code>&lt; 6 个字符的字符串>.&lt; 16 个字符的字符串></code>。
更加正式的说法是，它必须符合以下正则表达式：<code>[a-z0-9]{6}\.[a-z0-9]{16}</code>。</p>
<p>kubeadm 可以为你生成一个令牌：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubeadm token generate
</code></pre></div></li>
</ol>
<ol start=2>
<li>使用这个令牌同时启动控制平面节点和工作节点。它们一旦运行起来应该就会互相寻找对方并且建立集群。
同样的 <code>--token</code> 参数可以同时用于 <code>kubeadm init</code> 和 <code>kubeadm join</code> 命令。</li>
</ol>
<ol start=3>
<li>
<p>当加入其他控制平面节点时，可以对 <code>--certificate-key</code> 执行类似的操作。可以使用以下方式生成密钥：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubeadm certs certificate-key
</code></pre></div></li>
</ol>
<p>一旦集群启动起来，你就可以从控制平面节点的 <code>/etc/kubernetes/admin.conf</code> 文件获取管理凭证，
并使用这个凭证同集群通信。</p>
<p>注意这种搭建集群的方式在安全保证上会有一些宽松，因为这种方式不允许使用 <code>--discovery-token-ca-cert-hash</code>
来验证根 CA 的哈希值（因为当配置节点的时候，它还没有被生成）。
更多信息请参阅 <a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-join/>kubeadm join</a> 文档。</p>
<h2 id=what-s-next>What's next</h2>
<ul>
<li>进一步阅读了解 <a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-init-phase/>kubeadm init phase</a></li>
<li><a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-join/>kubeadm join</a>
启动一个 Kubernetes 工作节点并且将其加入到集群</li>
<li><a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-upgrade/>kubeadm upgrade</a>
将 Kubernetes 集群升级到新版本</li>
<li><a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-reset/>kubeadm reset</a>
恢复 <code>kubeadm init</code> 或 <code>kubeadm join</code> 命令对节点所作的变更</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-2a2b5f34806b4b1bd2c12682ac170d68>8.1.3 - kubeadm join</h1>
<p>此命令用来初始化 Kubernetes 工作节点并将其加入集群。</p>
<h3 id=摘要>摘要</h3>
<p>当节点加入 kubeadm 初始化的集群时，我们需要建立双向信任。
这个过程可以分解为发现（让待加入节点信任 Kubernetes 控制平面节点）和 TLS 引导（让Kubernetes 控制平面节点信任待加入节点）两个部分。</p>
<p>有两种主要的发现方案。
第一种方法是使用共享令牌和 API 服务器的 IP 地址。
第二种是提供一个文件 - 标准 kubeconfig 文件的一个子集。
该文件可以是本地文件，也可以通过 HTTPS URL 下载。
格式是 <code>kubeadm join --discovery-token abcdef.1234567890abcdef 1.2.3.4:6443</code>、<code>kubeadm join--discovery-file path/to/file.conf</code> 或者<code>kubeadm join --discovery-file https://url/file.conf</code>。
只能使用其中一种。
如果发现信息是从 URL 加载的，必须使用 HTTPS。
此外，在这种情况下，主机安装的 CA 包用于验证连接。</p>
<p>如果使用共享令牌进行发现，还应该传递 --discovery-token-ca-cert-hash 参数来验证 Kubernetes 控制平面节点提供的根证书颁发机构（CA）的公钥。
此参数的值指定为 "&lt;hash-type>:&lt;hex-encoded-value>"，其中支持的哈希类型为 "sha256"。哈希是通过 Subject Public Key Info（SPKI）对象的字节计算的（如 RFC7469）。
这个值可以从 "kubeadm init" 的输出中获得，或者可以使用标准工具进行计算。
可以多次重复 --discovery-token-ca-cert-hash 参数以允许多个公钥。</p>
<p>如果无法提前知道 CA 公钥哈希，则可以通过 --discovery-token-unsafe-skip-ca-verification 参数禁用此验证。
这削弱了kubeadm 安全模型，因为其他节点可能会模仿 Kubernetes 控制平面节点。</p>
<p>TLS 引导机制也通过共享令牌驱动。
这用于向 Kubernetes 控制平面节点进行临时的身份验证，以提交本地创建的密钥对的证书签名请求（CSR）。
默认情况下，kubeadm 将设置 Kubernetes 控制平面节点自动批准这些签名请求。
这个令牌通过 --tls-bootstrap-token abcdef.1234567890abcdef 参数传入。</p>
<p>通常两个部分会使用相同的令牌。
在这种情况下可以使用 --token 参数，而不是单独指定每个令牌。</p>
<p>"join [api-server-endpoint]" 命令执行下列阶段：</p>
<pre><code>preflight              Run join pre-flight checks
control-plane-prepare  Prepare the machine for serving a control plane
  /download-certs        [EXPERIMENTAL] Download certificates shared among control-plane nodes from the kubeadm-certs Secret
  /certs                 Generate the certificates for the new control plane components
  /kubeconfig            Generate the kubeconfig for the new control plane components
  /control-plane         Generate the manifests for the new control plane components
kubelet-start          Write kubelet settings, certificates and (re)start the kubelet
control-plane-join     Join a machine as a control plane instance
  /etcd                  Add a new local etcd member
  /update-status         Register the new control-plane node into the ClusterStatus maintained in the kubeadm-config ConfigMap
  /mark-control-plane    Mark a node as a control-plane
</code></pre><pre><code>kubeadm join [api-server-endpoint] [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果该节点托管一个新的控制平面实例，则 API 服务器将公布其正在侦听的 IP 地址。如果未设置，则使用默认网络接口。
</td>
</tr>
<tr>
<td colspan=2>
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值: 6443
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果节点应该托管新的控制平面实例，则为 API 服务器要绑定的端口。
</td>
</tr>
<tr>
<td colspan=2>--certificate-key string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
使用此密钥可以解密由 init 上传的证书 secret。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--control-plane</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
在此节点上创建一个新的控制平面实例
</td>
</tr>
<tr>
<td colspan=2>--cri-socket string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
要连接的 CRI 套接字的路径。如果为空，则 kubeadm 将尝试自动检测此值；仅当安装了多个 CRI 或具有非标准 CRI 插槽时，才使用此选项。
</td>
</tr>
<tr>
<td colspan=2>--discovery-file string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对于基于文件的发现，给出用于加载集群信息的文件或者 URL。
</td>
</tr>
<tr>
<td colspan=2>--discovery-token string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对于基于令牌的发现，该令牌用于验证从 API 服务器获取的集群信息。
</td>
</tr>
<tr>
<td colspan=2>--discovery-token-ca-cert-hash stringSlice</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对基于令牌的发现，验证根 CA 公钥是否与此哈希匹配 (格式: "&lt;type>:&lt;value>")。
</td>
</tr>
<tr>
<td colspan=2>--discovery-token-unsafe-skip-ca-verification</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对于基于令牌的发现，允许在未关联 --discovery-token-ca-cert-hash 参数的情况下添加节点。
</td>
</tr>
<tr>
<td colspan=2>--experimental-patches string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
包含名为 "target[suffix][+patchtype].extension" 的文件的目录的路径。
例如，"kube-apiserver0+merge.yaml" 或仅仅是 "etcd.json"。
"patchtype" 可以是 "strategic"、"merge" 或 "json" 之一，并且它们与 kubectl 支持的补丁格式匹配。
默认的 "patchtype" 为 "strategic"。 "extension" 必须为 "json" 或 "yaml"。
"suffix" 是一个可选字符串，可用于确定首先按字母顺序应用哪些补丁。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
join 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>--ignore-preflight-errors stringSlice</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
错误将显示为警告的检查列表；例如：'IsPrivilegedUser,Swap'。取值为 'all' 时将忽略检查中的所有错误。
</td>
</tr>
<tr>
<td colspan=2>--node-name string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指定节点的名称
</td>
</tr>
<tr>
<td colspan=2>--skip-phases stringSlice</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
要跳过的阶段列表
</td>
</tr>
<tr>
<td colspan=2>--tls-bootstrap-token string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指定在加入节点时用于临时通过 Kubernetes 控制平面进行身份验证的令牌。
</td>
</tr>
<tr>
<td colspan=2>--token string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果未提供这些值，则将它们用于 discovery-token 令牌和 tls-bootstrap 令牌。
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
<h3 id=join-workflow>join 工作流</h3>
<p><code>kubeadm join</code> 初始化 Kubernetes 工作节点并将其加入集群。
该操作过程包含下面几个步骤：</p>
<ol>
<li>kubeadm 从 API 服务器下载必要的集群信息。
默认情况下，它使用引导令牌和 CA 密钥哈希来验证数据的真实性。
也可以通过文件或 URL 直接发现根 CA。</li>
</ol>
<ol start=2>
<li>
<p>一旦知道集群信息，kubelet 就可以开始 TLS 引导过程。</p>
<p>TLS 引导程序使用共享令牌与 Kubernetes API 服务器进行临时的身份验证，以提交证书签名请求 (CSR)；
默认情况下，控制平面自动对该 CSR 请求进行签名。</p>
</li>
</ol>
<ol start=3>
<li>最后，kubeadm 配置本地 kubelet 使用分配给节点的确定标识连接到 API 服务器。</li>
</ol>
<p>对于控制平面节点，执行额外的步骤：</p>
<ol>
<li>
<p>从集群下载控制平面节点之间共享的证书（如果用户明确要求）。</p>
</li>
<li>
<p>生成控制平面组件清单、证书和 kubeconfig。</p>
</li>
<li>
<p>添加新的本地 etcd 成员。</p>
</li>
</ol>
<h3 id=join-phases>使用 kubeadm 的 join phase 命令</h3>
<p>Kubeadm 允许你使用 <code>kubeadm join phase</code> 分阶段将节点加入集群。</p>
<p>要查看阶段和子阶段的有序列表，可以调用 <code>kubeadm join --help</code>。
该列表将位于帮助屏幕的顶部，每个阶段旁边都有一个描述。
注意，通过调用 <code>kubeadm join</code>，所有阶段和子阶段都将按照此确切顺序执行。</p>
<p>有些阶段具有唯一的标志，因此，如果要查看可用选项列表，请添加 <code>--help</code>，例如：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubeadm join phase kubelet-start --help
</code></pre></div>
<p>类似于 <a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-init/#init-phases>kubeadm init phase</a>命令，
<code>kubeadm join phase</code> 允许你使用 <code>--skip-phases</code> 标志跳过阶段列表。</p>
<p>例如：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>sudo kubeadm join --skip-phases<span style=color:#666>=</span>preflight --config<span style=color:#666>=</span>config.yaml
</code></pre></div>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.22 [beta]</code>
</div>
<p>或者，你可以使用 <code>JoinConfiguration</code> 中的 <code>skipPhases</code> 字段。</p>
<h3 id=发现要信任的集群-ca>发现要信任的集群 CA</h3>
<p>Kubeadm 的发现有几个选项，每个选项都有安全性上的优缺点。
适合你的环境的正确方法取决于节点是如何准备的以及你对网络的安全性期望
和节点的生命周期特点。</p>
<h4 id=带-ca-锁定模式的基于令牌的发现>带 CA 锁定模式的基于令牌的发现</h4>
<p>这是 Kubernetes 1.8 及以上版本中的默认模式。
在这种模式下，kubeadm 下载集群配置（包括根CA）并使用令牌验证它，
并且会验证根 CA 的公钥与所提供的哈希是否匹配，
以及 API 服务器证书在根 CA 下是否有效。</p>
<p>CA 键哈希格式为 <code>sha256:&lt;hex_encoded_hash></code>。
默认情况下，在 <code>kubeadm init</code> 最后打印的 <code>kubeadm join</code> 命令
或者 <code>kubeadm token create --print-join-command</code> 的输出信息中返回哈希值。
它使用标准格式 (请参考 <a href=https://tools.ietf.org/html/rfc7469#section-2.4>RFC7469</a>)
并且也能通过第三方工具或者制备系统进行计算。
例如，使用 OpenSSL CLI：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>openssl x509 -pubkey -in /etc/kubernetes/pki/ca.crt | openssl rsa -pubin -outform der 2&gt;/dev/null | openssl dgst -sha256 -hex | sed <span style=color:#b44>&#39;s/^.* //&#39;</span>
</code></pre></div>
<p><strong><code>kubeadm join</code> 命令示例</strong></p>
<p>对于工作节点：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubeadm join --discovery-token abcdef.1234567890abcdef --discovery-token-ca-cert-hash sha256:1234..cdef 1.2.3.4:6443
</code></pre></div>
<p>对于控制面节点：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubeadm join --discovery-token abcdef.1234567890abcdef --discovery-token-ca-cert-hash sha256:1234..cdef --control-plane 1.2.3.4:6443
</code></pre></div>
<p>如果使用 <code>--upload-certs</code> 调用 <code>kubeadm init</code> 命令，
你也可以对控制平面节点调用带 <code>--certificate-key</code> 参数的 <code>join</code> 命令，
将证书复制到该节点。</p>
<p><strong>优势：</strong></p>
<ul>
<li>
<p>允许引导节点安全地发现主节点的信任根，即使其他工作节点或网络受到损害。</p>
</li>
<li>
<p>方便手动执行，因为所需的所有信息都可放到一个 <code>kubeadm join</code> 命令中。</p>
</li>
</ul>
<p><strong>劣势：</strong></p>
<ul>
<li>CA 哈希通常在主节点被提供之前是不知道的，这使得构建使用 kubeadm 的自动化配置工具更加困难。
通过预先生成CA，你可以解除这个限制。</li>
</ul>
<h4 id=无-ca-锁定模式的基于令牌的发现>无 CA 锁定模式的基于令牌的发现</h4>
<p>_这是 Kubernetes 1.7 和早期版本_中的默认设置；使用时要注意一些重要的补充说明。
此模式仅依赖于对称令牌来签名(HMAC-SHA256)发现信息，这些发现信息为主节点建立信任根。
在 Kubernetes 1.8 及以上版本中仍然可以使用 <code>--discovery-token-unsafe-skip-ca-verification</code>
参数，但是如果可能的话，你应该考虑使用一种其他模式。</p>
<p><strong><code>kubeadm join</code> 命令示例</strong></p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubeadm join --token abcdef.1234567890abcdef --discovery-token-unsafe-skip-ca-verification 1.2.3.4:6443
</code></pre></div>
<p><strong>优势</strong></p>
<ul>
<li>
<p>仍然可以防止许多网络级攻击。</p>
</li>
<li>
<p>可以提前生成令牌并与主节点和工作节点共享，这样主节点和工作节点就可以并行引导而无需协调。
这允许它在许多配置场景中使用。</p>
</li>
</ul>
<p><strong>劣势</strong></p>
<ul>
<li>如果攻击者能够通过某些漏洞窃取引导令牌，那么他们可以使用该令牌（连同网络级访问）
为其它处于引导过程中的节点提供假冒的主节点。
在你的环境中，这可能是一个适当的折衷方法，也可能不是。</li>
</ul>
<h4 id=基于-https-或文件发现>基于 HTTPS 或文件发现</h4>
<p>这种方案提供了一种带外方式在主节点和引导节点之间建立信任根。
如果使用 kubeadm 构建自动配置，请考虑使用此模式。
发现文件的格式为常规的 Kubernetes
<a href=/zh/docs/tasks/access-application-cluster/configure-access-multiple-clusters/>kubeconfig</a> 文件。</p>
<p>如果发现文件不包含凭据，则将使用 TLS 发现令牌。</p>
<p><strong><code>kubeadm join</code> 命令示例：</strong></p>
<ul>
<li>
<p><code>kubeadm join --discovery-file path/to/file.conf</code> （本地文件）</p>
</li>
<li>
<p><code>kubeadm join --discovery-file https://url/file.conf</code> (远程 HTTPS URL)</p>
</li>
</ul>
<p><strong>优势：</strong></p>
<ul>
<li>允许引导节点安全地发现主节点的信任根，即使网络或其他工作节点受到损害。</li>
</ul>
<p><strong>劣势：</strong></p>
<ul>
<li>要求你有某种方法将发现信息从主节点传送到引导节点。
例如，这可以通过云提供商或驱动工具实现。
该文件中的信息不是加密的，而是需要 HTTPS 或等效文件来保证其完整性。</li>
</ul>
<h3 id=securing-more>确保你的安装更加安全</h3>
<p>Kubeadm 的默认值可能不适用于所有人。
本节说明如何以牺牲可用性为代价来加强 kubeadm 安装。</p>
<h4 id=关闭节点客户端证书的自动批准>关闭节点客户端证书的自动批准</h4>
<p>默认情况下，Kubernetes 启用了 CSR 自动批准器，如果在身份验证时使用启动引导令牌，
它会批准对 kubelet 的任何客户端证书的请求。
如果不希望集群自动批准kubelet客户端证书，可以通过执行以下命令关闭它：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete clusterrolebinding kubeadm:node-autoapprove-bootstrap
</code></pre></div>
<p>关闭后，<code>kubeadm join</code> 操作将会被阻塞，直到管理员已经手动批准了在途中的 CSR 才会继续：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get csr
</code></pre></div>
<p>输出类似于：</p>
<pre><code>NAME                                                   AGE       REQUESTOR                 CONDITION
node-csr-c69HXe7aYcqkS1bKmH4faEnHAWxn6i2bHZ2mD04jZyQ   18s       system:bootstrap:878f07   Pending
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl certificate approve node-csr-c69HXe7aYcqkS1bKmH4faEnHAWxn6i2bHZ2mD04jZyQ
</code></pre></div>
<p>输出类似于：</p>
<pre><code>certificatesigningrequest &quot;node-csr-c69HXe7aYcqkS1bKmH4faEnHAWxn6i2bHZ2mD04jZyQ&quot; approved
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get csr
</code></pre></div>
<p>输出类似于：</p>
<pre><code>NAME                                                   AGE       REQUESTOR                 CONDITION
node-csr-c69HXe7aYcqkS1bKmH4faEnHAWxn6i2bHZ2mD04jZyQ   1m        system:bootstrap:878f07   Approved,Issued
</code></pre>
<p>这迫使工作流只有在运行了 kubectl 证书批准后，kubeadm join 才能成功。</p>
<h4 id=关闭对集群信息-configmap-的公开访问>关闭对集群信息 ConfigMap 的公开访问</h4>
<p>为了实现使用令牌作为唯一验证信息的加入工作流，默认情况下会公开带有验证主节点标识
所需数据的 ConfigMap。
虽然此 ConfigMap 中没有私有数据，但一些用户可能希望无论如何都关闭它。
这样做需要禁用 <code>kubeadm join</code> 工作流的 <code>--discovery-token</code> 参数。
以下是实现步骤：</p>
<ul>
<li>从 API 服务器获取 <code>cluster-info</code> 文件：</li>
</ul>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl -n kube-public get cm cluster-info -o yaml | grep <span style=color:#b44>&#34;kubeconfig:&#34;</span> -A11 | grep <span style=color:#b44>&#34;apiVersion&#34;</span> -A10 | sed <span style=color:#b44>&#34;s/    //&#34;</span> | tee cluster-info.yaml
</code></pre></div>
<p>输出类似于：</p>
<pre><code>apiVersion: v1
kind: Config
clusters:
- cluster:
    certificate-authority-data: &lt;ca-cert&gt;
    server: https://&lt;ip&gt;:&lt;port&gt;
  name: &quot;&quot;
contexts: []
current-context: &quot;&quot;
preferences: {}
users: []
</code></pre>
<ul>
<li>
<p>使用 <code>cluster-info.yaml</code> 文件作为 <code>kubeadm join --discovery-file</code> 参数。</p>
</li>
<li>
<p>关闭 <code>cluster-info</code> ConfigMap 的公开访问：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl -n kube-public delete rolebinding kubeadm:bootstrap-signer-clusterinfo
</code></pre></div></li>
</ul>
<p>这些命令应该在执行 <code>kubeadm init</code> 之后、在<code>kubeadm join</code> 之前执行。</p>
<h3 id=使用带有配置文件的-kubeadm-join>使用带有配置文件的 kubeadm join</h3>
<div class="alert alert-warning caution callout" role=alert>
<strong>Caution:</strong>
<p>配置文件目前是 alpha 功能，在将来的版本中可能会变动。
</div>
<p>可以用配置文件替代命令行参数的方法配置 <code>kubeadm join</code>，一些高级功能也只有在使用配置文件时才可选用。
该文件通过 <code>--config</code> 参数来传递，并且文件中必须包含 <code>JoinConfiguration</code> 结构。
在某些情况下，不允许将 <code>--config</code> 与其他标志混合使用。</p>
<p>使用 <a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-config/>kubeadm config print</a>
命令可以打印默认配置。</p>
<p>如果你的配置没有使用最新版本，
<strong>推荐</strong>使用 <a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-config/>kubeadm config migrate</a>
命令转换。</p>
<p>有关配置的字段和用法的更多信息，你可以导航到我们的
<a href=/zh/docs/reference/config-api/kubeadm-config.v1beta3/>API 参考页</a>。</p>
<h2 id=what-s-next>What's next</h2>
<ul>
<li><a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-init/>kubeadm init</a>
初始化 Kubernetes 主节点</li>
<li><a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-token/>kubeadm token</a>
管理 <code>kubeadm join</code> 的令牌</li>
<li><a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-reset/>kubeadm reset</a>
将 <code>kubeadm init</code> 或 <code>kubeadm join</code> 对主机的更改恢复到之前状态</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-2c20539d9fabf5982e2dd931742714bd>8.1.4 - kubeadm upgrade</h1>
<p><code>kubeadm upgrade</code> 是一个对用户友好的命令，它将复杂的升级逻辑包装在一个命令后面，支持升级的规划和实际执行。</p>
<h2 id=kubeadm-upgrade-指南>kubeadm upgrade 指南</h2>
<p><a href=/zh/docs/tasks/administer-cluster/kubeadm/kubeadm-upgrade/>本文档</a>概述
使用 kubeadm 执行升级的步骤。
与 kubeadm 旧版本相关的文档，请参阅 Kubernetes 网站的旧版文档。</p>
<p>你可以使用 <code>kubeadm upgrade diff</code> 来查看将应用于静态 Pod 清单的更改。</p>
<p>在 Kubernetes v1.15.0 和更高版本中，<code>kubeadm upgrade apply</code> 和 <code>kubeadm upgrade node</code>
也将自动续订该节点上的 kubeadm 托管证书，包括存储在 kubeconfig 文件中的证书。
要选择退出，可以传递参数 <code>--certificate-renewal=false</code>。
有关证书续订的更多详细信息请参见<a href=/zh/docs/tasks/administer-cluster/kubeadm/kubeadm-certs>证书管理文档</a>。</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong>
<p><code>kubeadm upgrade apply</code> 和 <code>kubeadm upgrade plan</code> 命令都具有遗留的 <code>--config</code> 标志，
可以在执行特定控制平面节点的规划或升级时重新配置集群。
请注意，升级工作流不是为这种情况而设计的，并且有意外结果的报告。
</div>
<h2 id=cmd-upgrade-plan>kubeadm upgrade plan</h2>
<h3 id=概述>概述</h3>
<p>检查可升级到哪些版本，并验证您当前的集群是否可升级。 要跳过互联网检查，请传递可选的 [version] 参数</p>
<pre><code>kubeadm upgrade plan [version] [flags]
</code></pre><h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--allow-experimental-upgrades</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>显示不稳定版本的 Kubernetes 作为升级替代方案，并允许升级到 Kubernetes 的 Alpha/Beta/发行候选版本。</td>
</tr>
<tr>
<td colspan=2>--allow-release-candidate-upgrades</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>显示 Kubernetes 的发行候选版本作为升级选择，并允许升级到 Kubernetes 的发行候选版本。</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>配置文件的路径。</td>
</tr>
<tr>
<td colspan=2>--feature-gates string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>一组描述各种特征特性门控的键值对。选项有：IPv6DualStack=true|false (ALPHA - default=false) PublicKeysECDSA=true|false (ALPHA - default=false)</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>帮助</td>
</tr>
<tr>
<td colspan=2>--ignore-preflight-errors stringSlice</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>检查清单，其错误将显示为警告。 例如：“IsPrivilegedUser，Swap”。 值 “all” 忽略所有检查的错误。</td>
</tr>
<tr>
<td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>与集群通信时使用的 kubeconfig 文件。 如果标志为未设置，则可以在一组标准位置中搜索现有的 kubeconfig 文件。</td>
</tr>
<tr>
<td colspan=2>--print-config</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>指定是否打印将在升级中使用的配置文件。</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>[EXPERIMENTAL] “真实”主机根文件系统的路径。</td>
</tr>
</tbody>
</table>
<h2 id=cmd-upgrade-apply>kubeadm upgrade apply </h2>
<h3 id=概要>概要</h3>
<p>将 Kubernetes 集群升级到指定版本</p>
<pre><code>kubeadm upgrade apply [version]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--allow-experimental-upgrades</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
显示 Kubernetes 的不稳定版本作为升级替代方案，并允许升级到 Kubernetes 的 alpha/beta 或 RC 版本。
</td>
</tr>
<tr>
<td colspan=2>--allow-release-candidate-upgrades</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
显示 Kubernetes 的候选版本作为升级替代方案，并允许升级到 Kubernetes 的 RC 版本。
</td>
</tr>
<tr>
<td colspan=2>--certificate-renewal&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: true</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
执行升级期间更改的组件所使用的证书的更新。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--dry-run</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
不要更改任何状态，只输出要执行的操作。
</td>
</tr>
<tr>
<td colspan=2>
--etcd-upgrade&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值: true
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
执行 etcd 的升级。
</td>
</tr>
<tr>
<td colspan=2>--experimental-patches string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
包含名为 "target[suffix][+patchtype].extension" 的文件的目录的路径。
例如，"kube-apiserver0+merge.yaml" 或仅仅是 "etcd.json"。
"patchtype" 可以是 "strategic"、"merge" 或 "json" 之一，并且它们与 kubectl 支持的补丁格式匹配。
默认的 "patchtype" 为 "strategic"。 "extension" 必须为 "json" 或 "yaml"。
"suffix" 是一个可选字符串，可用于确定首先按字母顺序应用哪些补丁。
</td>
</tr>
<tr>
<td colspan=2>--feature-gates string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
一组键值对，用于描述各种功能。选项包括：
<br>IPv6DualStack=true|false (ALPHA - 默认=false)
<br>PublicKeysECDSA=true|false (ALPHA - 默认=false)
</td>
</tr>
<tr>
<td colspan=2>-f, --force</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
强制升级，但可能无法满足某些要求。这也意味着非交互模式。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
apply 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>--ignore-preflight-errors stringSlice</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
错误将显示为警告的检查列表；例如：'IsPrivilegedUser,Swap'。取值为 'all' 时将忽略检查中的所有错误。
</td>
</tr>
<tr>
<td colspan=2>
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
与集群通信时使用的 kubeconfig 文件。如果未设置标志，则在相关目录下搜索以查找现有 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan=2>--print-config</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指定是否应打印将在升级中使用的配置文件。
</td>
</tr>
<tr>
<td colspan=2>-y, --yes</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
执行升级，不提示确认（非交互模式）。
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
<h2 id=cmd-upgrade-diff>kubeadm upgrade diff</h2>
<h3 id=概述>概述</h3>
<p>显示哪些差异将被应用于现有的静态 pod 资源清单。参考: kubeadm upgrade apply --dry-run</p>
<pre><code>kubeadm upgrade diff [version] [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--api-server-manifest string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/manifests/kube-apiserver.yaml"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>API服务器清单的路径</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>kubeadm 配置文件的路径</td>
</tr>
<tr>
<td colspan=2>-c, --context-lines int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：3</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>差异中有多少行上下文</td>
</tr>
<tr>
<td colspan=2>--controller-manager-manifest string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值： "/etc/kubernetes/manifests/kube-controller-manager.yaml"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>控制器清单的路径</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>帮助</td>
</tr>
<tr>
<td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>与集群通信时使用的 kubeconfig 文件，如果标志是未设置，则可以在一组标准位置中搜索现有的 kubeconfig 文件。</td>
</tr>
<tr>
<td colspan=2>--scheduler-manifest string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/manifests/kube-scheduler.yaml"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>调度程序清单的路径</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>[EXPERIMENTAL] “真实”主机根文件系统的路径。</td>
</tr>
</tbody>
</table>
<h2 id=cmd-upgrade-node>kubeadm upgrade node</h2>
<h3 id=概要>概要</h3>
<p>升级集群中某个节点的命令</p>
<p>"node" 命令执行以下阶段：</p>
<pre><code>preflight       执行节点升级前检查
control-plane   如果存在的话，升级部署在该节点上的管理面实例
kubelet-config  更新该节点上的 kubelet 配置
</code></pre><pre><code>kubeadm upgrade node [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--certificate-renewal</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对升级期间变化的组件所使用的证书执行更新。
</td>
</tr>
<tr>
<td colspan=2>--dry-run</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
不更改任何状态，只输出将要执行的操作。
</td>
</tr>
<tr>
<td colspan=2>--etcd-upgrade&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值: true</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
执行 etcd 的升级。
</td>
</tr>
<tr>
<td colspan=2>--experimental-patches string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
包含名为 "target[suffix][+patchtype].extension" 的文件的目录的路径。
例如，"kube-apiserver0+merge.yaml" 或仅仅是 "etcd.json"。
"patchtype" 可以是 "strategic"、"merge" 或 "json" 之一，并且它们与 kubectl 支持的补丁格式匹配。
默认的 "patchtype" 为 "strategic"。 "extension" 必须为 "json" 或 "yaml"。
"suffix" 是一个可选字符串，可用于确定首先按字母顺序应用哪些补丁。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
node 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值: "/etc/kubernetes/admin.conf"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
用于与集群交互的 kubeconfig 文件。如果参数未指定，将从一系列标准位置检索存在的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan=2>--kubelet-version string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
升级后 *期望的* kubelet 配置版本。如未指定，将使用 kubeadm-config ConfigMap 中的 KubernetesVersion
</td>
</tr>
<tr>
<td colspan=2>--skip-phases stringSlice</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
要跳过的阶段的列表
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
<h2 id=what-s-next>What's next</h2>
<ul>
<li>如果你使用 kubeadm v1.7.x 或更低版本初始化集群，则可以参考
<a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-config/>kubeadm 配置</a>
配置集群用于 <code>kubeadm upgrade</code>。</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-5042dc49c5348b3674d3878f37f7670b>8.1.5 - kubeadm config</h1>
<p>在 <code>kubeadm init</code> 执行期间，kubeadm 将 <code>ClusterConfiguration</code> 对象上传
到你的集群的 <code>kube-system</code> 名字空间下名为 <code>kubeadm-config</code> 的 ConfigMap 对象中。
然后在 <code>kubeadm join</code>、<code>kubeadm reset</code> 和 <code>kubeadm upgrade</code> 执行期间读取此配置。
要查看此 ConfigMap，请调用 <code>kubeadm config view</code>。</p>
<p>你可以使用 <code>kubeadm config print</code> 命令打印默认配置，
并使用 <code>kubeadm config migrate</code> 命令将旧版本的配置转化成新版本。
<code>kubeadm config images list</code> 和 <code>kubeadm config images pull</code>
命令可以用来列出并拉取 kubeadm 所需的镜像。</p>
<p>更多信息请浏览<a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-init/#config-file>使用带配置文件的 kubeadm init</a>
或<a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-join/#config-file>使用带配置文件的 kubeadm join</a>.</p>
<p>你也可以在使用 <code>kubeadm init</code> 命令时配置若干 kubelet 配置选项。
这些选项对于集群中所有节点而言都是相同的。
参阅<a href=/zh/docs/setup/production-environment/tools/kubeadm/kubelet-integration/>使用 kubeadm 来配置集群中的各个 kubelet</a>
了解详细信息。</p>
<p>在 Kubernetes v1.13.0 及更高版本中，要列出/拉取 kube-dns 镜像而不是 CoreDNS 镜像，
必须使用<a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-init-phase/#cmd-phase-addon>这里</a>
所描述的 <code>--config</code> 方法。</p>
<h2 id=cmd-config-from-file>kubeadm config upload from-file</h2>
<h2 id=cmd-config-view>kubeadm config print</h2>
<p>打印配置</p>
<h3 id=概要>概要</h3>
<p>此命令打印子命令所提供的配置信息。
相关细节可参阅: <a href=https://pkg.go.dev/k8s.io/kubernetes/cmd/kubeadm/app/apis/kubeadm#section-directories>https://pkg.go.dev/k8s.io/kubernetes/cmd/kubeadm/app/apis/kubeadm#section-directories</a></p>
<pre><code>kubeadm config print [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>print 命令的帮助信息</p></td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承而来的选项>从父命令继承而来的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>与集群通信时使用的 kubeconfig 文件。如此标志未设置，将在一组标准位置中搜索现有的kubeconfig 文件。</p></td>
</tr>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>[试验性] 指向“真实”宿主根文件系统的路径。</p></td>
</tr>
</tbody>
</table>
<h2 id=cmd-config-print-init-defaults>kubeadm config print init-defaults</h2>
<h3 id=概要>概要</h3>
<p>此命令打印对象，例如用于 'kubeadm init' 的默认 init 配置对象。</p>
<p>请注意，Bootstrap Token 字段之类的敏感值已替换为 {"abcdef.0123456789abcdef" "" "nil" &lt;nil> [] []} 之类的占位符值以通过验证，但不执行创建令牌的实际计算。</p>
<pre><code>kubeadm config print init-defaults [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--component-configs stringSlice</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
组件配置 API 对象的逗号分隔列表，打印其默认值。可用值：[KubeProxyConfiguration KubeletConfiguration]。如果未设置此参数，则不会打印任何组件配置。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
init-defaults 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
与集群通信时使用的 kubeconfig 文件。如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
<h2 id=cmd-config-print-join-defaults>kubeadm config print join-defaults</h2>
<h3 id=概要>概要</h3>
<p>此命令打印对象，例如用于 'kubeadm join' 的默认 join 配置对象。</p>
<p>请注意，诸如启动引导令牌字段之类的敏感值已替换为 {"abcdef.0123456789abcdef" "" "nil" &lt;nil> [] []}
之类的占位符值以通过验证，但不执行创建令牌的实际计算。</p>
<pre><code>kubeadm config print join-defaults [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--component-configs stringSlice</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
组件配置 API 对象的逗号分隔列表，打印其默认值。可用值：[KubeProxyConfiguration KubeletConfiguration]。如果未设置此参数，则不会打印任何组件配置。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
join-defaults 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
与集群通信时使用的 kubeconfig 文件。如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
<h2 id=cmd-config-migrate>kubeadm config migrate</h2>
<h3 id=概要>概要</h3>
<p>此命令允许您在 CLI 工具中将本地旧版本的配置对象转换为最新支持的版本，而无需变更集群中的任何内容。在此版本的 kubeadm 中，支持以下 API 版本：</p>
<ul>
<li>kubeadm.k8s.io/v1beta2</li>
</ul>
<p>因此，无论您在此处传递 --old-config 参数的版本是什么，当写入到 stdout 或 --new-config （如果已指定）时，
都会读取、反序列化、默认、转换、验证和重新序列化 API 对象。</p>
<p>换句话说，如果您将此文件传递给 "kubeadm init"，则该命令的输出就是 kubeadm 实际上在内部读取的内容。</p>
<pre><code>kubeadm config migrate [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
migrate 操作的帮助信息
</td>
</tr>
<tr>
<td colspan=2>--new-config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
使用新的 API 版本生成的 kubeadm 配置文件的路径。这个路径是可选的。如果没有指定，输出将被写到 stdout。
</td>
</tr>
<tr>
<td colspan=2>--old-config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
使用旧 API 版本且应转换的 kubeadm 配置文件的路径。此参数是必需的。
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
用于和集群通信的 kubeconfig 文件。如果未设置，那么 kubeadm 将会搜索一个已经存在于标准路径的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
<h2 id=cmd-config-images-list>kubeadm config images list</h2>
<h3 id=概要>概要</h3>
<p>打印 kubeadm 要使用的镜像列表。配置文件用于自定义任何镜像或镜像存储库。</p>
<pre><code>kubeadm config images list [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>
--allow-missing-template-keys&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：true
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果设置为 true，则在模板中缺少字段或哈希表的键时忽略模板中的任何错误。
仅适用于 golang 和 jsonpath 输出格式。
</td>
</tr>
<tr>
<td colspan=2>
-o, --experimental-output string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："text"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
输出格式：text|json|yaml|go-template|go-template-file|template|templatefile|jsonpath|jsonpath-as-json|jsonpath-file 其中之一
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--feature-gates string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
一组键值对（key=value），用于描述各种特征。选项是：
<br>Auditing=true|false (ALPHA - 默认=false)
<br>CoreDNS=true|false (默认=true)
<br>DynamicKubeletConfig=true|false (BETA - 默认=false)
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
list 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："k8s.gcr.io"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
选择要从中拉取控制平面镜像的容器仓库
</td>
</tr>
<tr>
<td colspan=2>
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面选择一个特定的 Kubernetes 版本
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
用于和集群通信的 kubeconfig 文件。如果它没有被设置，那么 kubeadm 将会搜索一个已经存在于标准路径的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
<h2 id=cmd-config-images-pull>kubeadm config images pull</h2>
<h3 id=概要>概要</h3>
<p>拉取 kubeadm 使用的镜像。</p>
<pre><code>kubeadm config images pull [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--cri-socket string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
要连接的 CRI 套接字的路径。如果为空，则 kubeadm 将尝试自动检测此值；仅当安装了多个 CRI 或具有非标准 CRI 插槽时，才使用此选项。
</td>
</tr>
<tr>
<td colspan=2>--feature-gates string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
一系列键值对（key=value），用于描述各种特征。可选项是：<br>IPv6DualStack=true|false (ALPHA - 默认值=false)
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
pull 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："k8s.gcr.io"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
选择用于拉取控制平面镜像的容器仓库
</td>
</tr>
<tr>
<td colspan=2>
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面选择一个特定的 Kubernetes 版本。
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
用于和集群通信的 kubeconfig 文件。如果它没有被设置，那么 kubeadm 将会搜索一个已经存在于标准路径的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
<h2 id=what-s-next>What's next</h2>
<ul>
<li><a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-upgrade/>kubeadm upgrade</a>
将 Kubernetes 集群升级到更新版本 [kubeadm upgrade]</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-6eb5bc1e7114609930a76c683cc27c2b>8.1.6 - kubeadm reset</h1>
<p>该命令尽力还原由 <code>kubeadm init</code> 或 <code>kubeadm join</code> 所做的更改。</p>
<h3 id=概要>概要</h3>
<p>尽最大努力还原通过 'kubeadm init' 或者 'kubeadm join' 操作对主机所做的更改</p>
<p>"reset" 命令执行以下阶段：</p>
<pre><code>preflight              Run reset pre-flight checks
update-cluster-status  Remove this node from the ClusterStatus object.
remove-etcd-member     Remove a local etcd member.
cleanup-node           Run cleanup node.
</code></pre><pre><code>kubeadm reset [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
存储证书的目录路径。如果已指定，则需要清空此目录。
</td>
</tr>
<tr>
<td colspan=2>--cri-socket string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
要连接的 CRI 套接字的路径。如果为空，则 kubeadm 将尝试自动检测此值；仅当安装了多个CRI 或具有非标准 CRI 插槽时，才使用此选项。
</td>
</tr>
<tr>
<td colspan=2>-f, --force</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
在不提示确认的情况下重置节点。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
reset 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>--ignore-preflight-errors stringSlice</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
错误将显示为警告的检查列表；例如：'IsPrivilegedUser,Swap'。取值为 'all' 时将忽略检查中的所有错误。
</td>
</tr>
<tr>
<td colspan=2>
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
与集群通信时使用的 kubeconfig 文件。如果未设置该标志，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan=2>--skip-phases stringSlice</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
要跳过的阶段列表
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
<h3 id=reset-workflow>Reset 工作流程</h3>
<p><code>kubeadm reset</code> 负责从使用 <code>kubeadm init</code> 或 <code>kubeadm join</code> 命令创建的文件中清除节点本地文件系统。
对于控制平面节点，<code>reset</code> 还从 etcd 集群中删除该节点的本地 etcd Stacked 部署的成员。</p>
<p><code>kubeadm reset phase</code> 可用于执行上述工作流程的各个阶段。
要跳过阶段列表，你可以使用 <code>--skip-phases</code> 参数，该参数的工作方式类似于 <code>kubeadm join</code> 和 <code>kubeadm init</code> 阶段运行器。</p>
<h3 id=外部-etcd-清理>外部 etcd 清理</h3>
<p>如果使用了外部 etcd，<code>kubeadm reset</code> 将不会删除任何 etcd 中的数据。这意味着，如果再次使用相同的 etcd 端点运行 <code>kubeadm init</code>，你将看到先前集群的状态。</p>
<p>要清理 etcd 中的数据，建议你使用 etcdctl 这样的客户端，例如：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>etcdctl del <span style=color:#b44>&#34;&#34;</span> --prefix
</code></pre></div>
<p>更多详情请参考 <a href=https://github.com/coreos/etcd/tree/master/etcdctl>etcd 文档</a>。</p>
<h2 id=what-s-next>What's next</h2>
<ul>
<li>参考 <a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-init/>kubeadm init</a> 来初始化 Kubernetes 主节点。</li>
<li>参考 <a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-join/>kubeadm join</a> 来初始化 Kubernetes 工作节点并加入集群。</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-516f4705fb2f5f62c76c7742772726a3>8.1.7 - kubeadm token</h1>
<p>如<a href=/zh/docs/reference/access-authn-authz/bootstrap-tokens/>使用引导令牌进行身份验证</a>所描述的，引导令牌用于在即将加入集群的节点和主节点间建立双向认证。</p>
<p><code>kubeadm init</code> 创建了一个有效期为 24 小时的令牌，下面的命令允许你管理令牌，也可以创建和管理新的令牌。</p>
<h2 id=cmd-token-create>kubeadm token create</h2>
<h3 id=概要>概要</h3>
<p>这个命令将为你创建一个引导令牌。
您可以设置此令牌的用途，"有效时间" 和可选的人性化的描述。</p>
<p>这里的 [token] 是指将要生成的实际令牌。
该令牌应该是一个通过安全机制生成的随机令牌，形式为 "[a-z0-9]{6}.[a-z0-9]{16}"。
如果没有给出 [token]，kubeadm 将生成一个随机令牌。</p>
<pre><code>kubeadm token create [token]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--description string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
针对令牌用途的人性化的描述。
</td>
</tr>
<tr>
<td colspan=2>
--groups stringSlice&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：[system:bootstrappers:kubeadm:default-node-token]
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
此令牌用于身份验证时将进行身份验证的其他组。必须匹配 "\\Asystem:bootstrappers:[a-z0-9:-]{0,255}[a-z0-9]\\z"
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
create 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>--print-join-command</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
不仅仅打印令牌，而是打印使用令牌加入集群所需的完整 'kubeadm join' 参数。
</td>
</tr>
<tr>
<td colspan=2>
--ttl duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：24h0m0s
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
令牌有效时间，超过该时间令牌被自动删除。(例如： 1s, 2m, 3h)。如果设置为 '0'，令牌将永远不过期。
</td>
</tr>
<tr>
<td colspan=2>
--usages stringSlice&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：[signing,authentication]
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
描述可以使用此令牌的方式。你可以多次使用 `--usages` 或者提供一个以逗号分隔的选项列表。合法选项有: [signing,authentication]
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--dry-run</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
是否启用 `dry-run` 运行模式
</td>
</tr>
<tr>
<td colspan=2>
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
用于和集群通信的 KubeConfig 文件。如果它没有被设置，那么 kubeadm 将会搜索一个已经存在于标准路径的 KubeConfig 文件。
</td>
</tr>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
<h2 id=cmd-token-delete>kubeadm token delete</h2>
<h3 id=概要>概要</h3>
<p>这个命令将为你删除指定的引导令牌列表。</p>
<p><code>[token-value]</code> 是要删除的 "[a-z0-9]{6}.[a-z0-9]{16}" 形式的完整令牌或者是 "[a-z0-9]{6}" 形式的的令牌 ID。</p>
<pre><code>kubeadm token delete [token-value] ...
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
delete 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--dry-run</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
是否启用 `dry-run` 运行模式
</td>
</tr>
<tr>
<td colspan=2>
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
用于和集群通信的 KubeConfig 文件。如果它没有被设置，那么 kubeadm 将会搜索一个已经存在于标准路径的 KubeConfig 文件。
</td>
</tr>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
<h2 id=cmd-token-generate>kubeadm token generate</h2>
<h3 id=概要>概要</h3>
<p>此命令将打印一个随机生成的可以被 "init" 和 "join" 命令使用的引导令牌。
您不必使用此命令来生成令牌。你可以自己设定，只要格式符合 "[a-z0-9]{6}.[a-z0-9]{16}"。这个命令提供是为了方便生成规定格式的令牌。
您也可以使用 "kubeadm init" 并且不指定令牌，该命令会生成一个令牌并打印出来。</p>
<pre><code>kubeadm token generate [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
generate 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--dry-run</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
是否启用 `dry-run` 运行模式</td>
</tr>
<tr>
<td colspan=2>
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
用于和集群通信的 KubeConfig 文件。如果它没有被设置，那么 kubeadm 将会搜索一个已经存在于标准路径的 KubeConfig 文件。
</td>
</tr>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
<h2 id=cmd-token-list>kubeadm token list</h2>
<h3 id=概要>概要</h3>
<p>此命令将为您列出所有的引导令牌。</p>
<pre><code>kubeadm token list [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>
--allow-missing-template-keys&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：true
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果设置为 true，则在模板中缺少字段或哈希表的键时忽略模板中的任何错误。
仅适用于 golang 和 jsonpath 输出格式。
</td>
</tr>
<tr>
<td colspan=2>
-o, --experimental-output string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："text"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
输出格式：text|json|yaml|go-template|go-template-file|template|templatefile|jsonpath|jsonpath-as-json|jsonpath-file 其中之一
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
list 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--dry-run</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
是否启用 `dry-run` 模式
</td>
</tr>
<tr>
<td colspan=2>
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
用于和集群通信的 kubeconfig 文件。如果它没有被设置，那么 kubeadm 将会搜索一个已经存在于标准路径的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
<h2 id=what-s-next>What's next</h2>
<ul>
<li><a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-join/>kubeadm join</a> 引导 Kubernetes 工作节点并将其加入集群</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-34c4af6f36d969ed08ba840e7fb64c6d>8.1.8 - kubeadm version</h1>
<p>此命令用来输出 kubeadm 的版本。</p>
<h3 id=概要>概要</h3>
<p>打印 kubeadm 的版本</p>
<pre><code>kubeadm version [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
version 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>-o, --output string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
输出格式；可用的选项有 'yaml', 'json' 和 'short'
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-92a39c69c3689119dd5fa12886cb73a3>8.1.9 - kubeadm alpha</h1>
<div class="alert alert-warning caution callout" role=alert>
<strong>Caution:</strong>
<p><code>kubeadm alpha</code> 提供了一组可用于收集社区反馈的预览性质功能。
请试用这些功能并给我们提供反馈！
</div>
<p>目前在 <code>kubeadm alpha</code> 之下没有试验性质的命令。</p>
<h2 id=what-s-next>What's next</h2>
<ul>
<li>用来启动引导 Kubernetes 控制平面节点的
<a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-init/>kubeadm init</a>
命令</li>
<li>用来将节点连接到集群的
<a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-join/>kubeadm join</a>
命令</li>
<li>用来还原 <code>kubeadm init</code> 或 <code>kubeadm join</code> 操作对主机所做的任何更改的
<a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-reset/>kubeadm reset</a>
命令</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-6a1fed09235bbf3644c804339928f10e>8.1.10 - kubeadm certs</h1>
<p><code>kubeadm certs</code> 提供管理证书的工具。关于如何使用这些命令的细节，可参见
<a href=/zh/docs/tasks/administer-cluster/kubeadm/kubeadm-certs/>使用 kubeadm 管理证书</a>。</p>
<h2 id=cmd-certs>kubeadm certs</h2>
<p>用来操作 Kubernetes 证书的一组命令。</p>
<ul class="nav nav-tabs" id=tab-certs role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tab-certs-0 role=tab aria-controls=tab-certs-0 aria-selected=true>概览</a></li>
</ul>
<div class=tab-content id=tab-certs><div id=tab-certs-0 class="tab-pane show active" role=tabpanel aria-labelledby=tab-certs-0>
<p>
<p>处理 Kubernetes 证书的相关命令</p>
<h3 id=概要>概要</h3>
<p>处理 Kubernetes 证书相关的命令</p>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>certs 命令的帮助</p></td>
</tr>
</tbody>
</table>
<h3 id=继承于父命令的选项>继承于父命令的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>[实验] 到'真实'主机根文件系统的路径。</p></td>
</tr>
</tbody>
</table>
</div></div>
<h2 id=cmd-certs-renew>kubeadm certs renew</h2>
<p>你可以使用 <code>all</code> 子命令来续订所有 Kubernetes 证书，也可以选择性地续订部分证书。
更多的相关细节，可参见
<a href=/zh/docs/tasks/administer-cluster/kubeadm/kubeadm-certs/#manual-certificate-renewal>手动续订证书</a>。</p>
<ul class="nav nav-tabs" id=tab-certs-renew role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tab-certs-renew-0 role=tab aria-controls=tab-certs-renew-0 aria-selected=true>renew</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tab-certs-renew-1 role=tab aria-controls=tab-certs-renew-1>all</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tab-certs-renew-2 role=tab aria-controls=tab-certs-renew-2>admin.conf</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tab-certs-renew-3 role=tab aria-controls=tab-certs-renew-3>apiserver-etcd-client</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tab-certs-renew-4 role=tab aria-controls=tab-certs-renew-4>apiserver-kubelet-client</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tab-certs-renew-5 role=tab aria-controls=tab-certs-renew-5>apiserver</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tab-certs-renew-6 role=tab aria-controls=tab-certs-renew-6>controller-manager.conf</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tab-certs-renew-7 role=tab aria-controls=tab-certs-renew-7>etcd-healthcheck-client</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tab-certs-renew-8 role=tab aria-controls=tab-certs-renew-8>etcd-peer</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tab-certs-renew-9 role=tab aria-controls=tab-certs-renew-9>etcd-server</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tab-certs-renew-10 role=tab aria-controls=tab-certs-renew-10>front-proxy-client</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tab-certs-renew-11 role=tab aria-controls=tab-certs-renew-11>scheduler.conf</a></li></ul>
<div class=tab-content id=tab-certs-renew><div id=tab-certs-renew-0 class="tab-pane show active" role=tabpanel aria-labelledby=tab-certs-renew-0>
<p>
<p>为 Kubernetes 集群更新证书</p>
<h3 id=概要>概要</h3>
<p>此命令并非设计用来单独运行。请参阅可用子命令列表。</p>
<pre><code>kubeadm certs renew [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
<p>
renew 操作的帮助命令
</p>
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
<p>
[实验] 到 '真实' 主机根文件系统的路径。
</p>
</td>
</tr>
</tbody>
</table>
</div>
<div id=tab-certs-renew-1 class=tab-pane role=tabpanel aria-labelledby=tab-certs-renew-1>
<p><h3 id=概要>概要</h3>
<p>续订运行控制平面所需的所有已知证书。续订是无条件进行的，与到期日期无关。续订也可以单独运行以进行更多控制。</p>
<pre><code>kubeadm certs renew all [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
存储证书的路径。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--csr-dir string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
输出 CSR 和私钥的路径
</td>
</tr>
<tr>
<td colspan=2>--csr-only</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
创建 CSR 而不是生成证书
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
all 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
与集群通信时使用的 kubeconfig 文件。
如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan=2>--use-api</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
使用 Kubernetes 证书 API 续订证书
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div id=tab-certs-renew-2 class=tab-pane role=tabpanel aria-labelledby=tab-certs-renew-2>
<p><h3 id=概要>概要</h3>
<p>续订 kubeconfig 文件中嵌入的证书，供管理员 和 kubeadm 自身使用。</p>
<p>无论证书的到期日期如何，续订都是无条件进行的；SAN 等额外属性将基于现有文件/证书，因此无需重新提供它们。</p>
<p>默认情况下，续订会尝试使用由 kubeadm 管理的本地 PKI 中的证书机构；作为替代方案，
也可以使用 K8s 证书 API 进行证书续订，或者（作为最后一种选择）生成 CSR 请求。</p>
<p>续订后，为了使更改生效，需要重新启动控制平面组件，并最终重新分发更新的证书，以防证书文件在其他地方使用。</p>
<pre><code>kubeadm certs renew admin.conf [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
保存证书的路径。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--csr-dir string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
CSR 和私钥的输出路径
</td>
</tr>
<tr>
<td colspan=2>--csr-only</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
创建 CSR 而不是生成证书
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
admin.conf 子操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
与集群通信时使用的 kubeconfig 文件。
如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan=2>--use-api</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
使用 Kubernetes 证书 API 续订证书
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div id=tab-certs-renew-3 class=tab-pane role=tabpanel aria-labelledby=tab-certs-renew-3>
<p><h3 id=概要>概要</h3>
<p>续订 apiserver 用于访问 etcd 的证书。</p>
<p>无论证书的到期日期如何，续订都会无条件地进行；SAN 等额外属性将基于现有文件/证书，因此无需重新提供它们。</p>
<p>默认情况下，续订尝试使用在 kubeadm 所管理的本地 PKI 中的证书颁发机构；作为替代方案，
可以使用 K8s 证书 API 进行证书更新，或者作为最后一个选择来生成 CSR 请求。</p>
<p>续订后，为了使更改生效，需要重新启动控制平面组件，并最终重新分发更新的证书，以防文件在其他地方使用。</p>
<pre><code>kubeadm certs renew apiserver-etcd-client [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
存储证书的路径。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--csr-dir string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
输出 CSR 和私钥的路径
</td>
</tr>
<tr>
<td colspan=2>--csr-only</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
创建 CSR 而不是生成证书
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
apiserver-etcd-client 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
与集群通信时使用的 kubeconfig 文件。
如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan=2>--use-api</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
使用 Kubernetes 证书 API 续订证书
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div id=tab-certs-renew-4 class=tab-pane role=tabpanel aria-labelledby=tab-certs-renew-4>
<p><h3 id=概要>概要</h3>
<p>续订 apiserver 用于连接 kubelet 的证书。</p>
<p>无论证书的到期日期如何，续订都会无条件地进行；SAN 等额外属性将基于现有文件/证书，因此无需重新提供它们。</p>
<p>默认情况下，续订尝试使用位于 kubeadm 所管理的本地 PKI 中的证书颁发机构；作为替代方案，
也可能调用 K8s 证书 API 进行证书更新；亦或者，作为最后一个选择，生成 CSR 请求。</p>
<p>续订后，为了使更改生效，需要重新启动控制平面组件，并最终重新分发更新的证书，以防文件在其他地方使用。</p>
<pre><code>kubeadm certs renew apiserver-kubelet-client [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
存储证书的路径。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--csr-dir string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
输出 CSR 和私钥的路径
</td>
</tr>
<tr>
<td colspan=2>--csr-only</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
创建 CSR 而不是生成证书
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
apiserver-kubelet-client 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
与集群通信时使用的 kubeconfig 文件。
如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan=2>--use-api</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
使用 Kubernetes 证书 API 续订证书
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div id=tab-certs-renew-5 class=tab-pane role=tabpanel aria-labelledby=tab-certs-renew-5>
<p><h3 id=概要>概要</h3>
<p>续订用于提供 Kubernetes API 的证书。</p>
<p>无论证书的到期日期如何，续订都会无条件地进行；SAN 等额外属性将基于现有文件/证书，因此无需重新提供它们。</p>
<p>默认情况下，续订尝试在 kubeadm 管理的本地 PKI 中使用证书颁发机构；作为替代方案，
可以使用 K8s 证书 API 进行证书更新，或者作为最后一个选择来生成 CSR 请求。</p>
<p>续订后，为了使更改生效，需要重新启动控制平面组件，并最终重新分发更新的证书，以防文件在其他地方使用。</p>
<pre><code>kubeadm certs renew apiserver [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
保存证书的路径。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--csr-dir string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
CSR 和私钥的输出路径
</td>
</tr>
<tr>
<td colspan=2>--csr-only</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
创建 CSR 而不是生成证书
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
apiserver 子操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
与集群通信时使用的 kubeconfig 文件。
如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan=2>--use-api</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
使用 Kubernetes 证书 API 续订证书
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div id=tab-certs-renew-6 class=tab-pane role=tabpanel aria-labelledby=tab-certs-renew-6>
<p><h3 id=概要>概要</h3>
<p>续订 kubeconfig 文件中嵌入的证书，以供控制器管理器（Controller Manager）使用。</p>
<p>续订无条件地进行，与证书的到期日期无关；SAN 等额外属性将基于现有的文件/证书，因此无需重新提供它们。</p>
<p>默认情况下，续订会尝试使用 kubeadm 管理的本地 PKI 中的证书颁发机构；作为替代方案，
可以使用 K8s 证书 API 进行证书续订；亦或者，作为最后一种选择，生成 CSR 请求。</p>
<p>续订后，为了使更改生效，需要重新启动控制平面组件，并最终重新分发更新的证书，以防文件在其他地方使用。</p>
<pre><code>kubeadm alpha renew controller-manager.conf [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
保存证书的路径。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--csr-dir string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
CSR 和私钥的输出路径
</td>
</tr>
<tr>
<td colspan=2>--csr-only</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
创建 CSR 而不是生成证书
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
controller-manager.conf 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
与集群通信时使用的 kubeconfig 文件。
如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan=2>--use-api</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
使用 Kubernetes 证书 API 续订证书
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div id=tab-certs-renew-7 class=tab-pane role=tabpanel aria-labelledby=tab-certs-renew-7>
<p><h3 id=概要>概要</h3>
<p>续订存活态探针的证书，用于对 etcd 执行健康检查。</p>
<p>无论证书的到期日期如何，续订都是无条件进行的；SAN 等额外属性将基于现有文件/证书，因此无需重新提供它们。</p>
<p>默认情况下，续订会尝试使用由 kubeadm 管理的本地 PKI 中的证书机构；作为替代方案，
也可以使用 K8s certificate API 进行证书续订，或者（作为最后一种选择）生成 CSR 请求。</p>
<p>续订后，为了使更改生效，需要重新启动控制平面组件，并最终重新分发更新的证书，以防证书文件在其他地方使用。</p>
<pre><code>kubeadm certs renew etcd-healthcheck-client [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
保存证书的路径。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--csr-dir string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
CSR 和私钥的输出路径
</td>
</tr>
<tr>
<td colspan=2>--csr-only</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
创建 CSR 而不是生成证书
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
etcd-healthcheck-client 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
与集群通信时使用的 kubeconfig 文件。
如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan=2>--use-api</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
使用 Kubernetes 证书 API 续订证书
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div id=tab-certs-renew-8 class=tab-pane role=tabpanel aria-labelledby=tab-certs-renew-8>
<p><h3 id=概要>概要</h3>
<p>续订 etcd 节点间用来相互通信的证书。</p>
<p>无论证书的到期日期如何，续订都是无条件进行的；SAN 等额外属性将基于现有文件/证书，因此无需重新提供它们。</p>
<p>默认情况下，续订会尝试使用由 kubeadm 管理的本地 PKI 中的证书机构；
作为替代方案，也可以使用 K8s certificate API 进行证书续订，或者（作为最后一种选择）生成 CSR 请求。</p>
<p>续订后，为了使更改生效，需要重新启动控制平面组件，并最终重新分发更新的证书，以防证书文件在其他地方使用。</p>
<pre><code>kubeadm certs renew etcd-peer [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
保存证书的路径。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--csr-dir string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
CSR 和私钥的输出路径
</td>
</tr>
<tr>
<td colspan=2>--csr-only</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
创建 CSR 而不是生成证书
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
etcd-peer 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
与集群通信时使用的 kubeconfig 文件。
如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan=2>--use-api</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
使用 Kubernetes 证书 API 续订证书
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div id=tab-certs-renew-9 class=tab-pane role=tabpanel aria-labelledby=tab-certs-renew-9>
<p><h3 id=概要>概要</h3>
<p>续订用于提供 etcd 服务的证书。</p>
<p>续订无条件地进行，与证书的到期日期无关；SAN 等额外属性将基于现有的文件/证书，因此无需重新提供它们。</p>
<p>默认情况下，续订会尝试在 kubeadm 管理的本地 PKI 中使用证书颁发机构；作为替代方案，
可以使用 K8s 证书 API 进行证书续订，或者作为最后一种选择来生成 CSR 请求。</p>
<p>续订后，为了使更改生效，需要重新启动控制平面组件，并最终重新分发更新的证书，以防文件在其他地方使用。</p>
<pre><code>kubeadm certs renew etcd-server [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
保存证书的路径。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--csr-dir string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
CSR 和私钥的输出路径
</td>
</tr>
<tr>
<td colspan=2>--csr-only</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
创建 CSR 而不是生成证书
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
etcd-server 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
与集群通信时使用的 kubeconfig 文件。
如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan=2>--use-api</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
使用 Kubernetes 证书 API 续订证书
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div id=tab-certs-renew-10 class=tab-pane role=tabpanel aria-labelledby=tab-certs-renew-10>
<p><h3 id=概要>概要</h3>
<p>为前端代理客户端续订证书。</p>
<p>无论证书的到期日期如何，续订都会无条件地进行；SAN 等额外属性将基于现有文件/证书，因此无需重新提供它们。</p>
<p>默认情况下，续订尝试使用位于 kubeadm 所管理的本地 PKI 中的证书颁发机构；作为替代方案，
也可以使用 K8s 证书 API 进行证书续订；亦或者，作为最后一种方案，生成 CSR 请求。</p>
<p>续订后，为了使更改生效，需要重新启动控制平面组件，并最终重新分发更新的证书，以防文件在其他地方使用。</p>
<pre><code>kubeadm certs renew front-proxy-client [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
存储证书的路径。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--csr-dir string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
输出 CSR 和私钥的路径
</td>
</tr>
<tr>
<td colspan=2>--csr-only</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
创建 CSR 而不是生成证书
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
front-proxy-client 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
与集群通信时使用的 kubeconfig 文件。
如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan=2>--use-api</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
使用 Kubernetes 证书 API 续订证书
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div id=tab-certs-renew-11 class=tab-pane role=tabpanel aria-labelledby=tab-certs-renew-11>
<p><h3 id=概要>概要</h3>
<p>续订 kubeconfig 文件中嵌入的证书，以供调度管理器使用。</p>
<p>续订无条件地进行，与证书的到期日期无关；SAN 等额外属性将基于现有的文件/证书，因此无需重新提供它们。</p>
<p>默认情况下，续订会尝试使用在 kubeadm 所管理的本地 PKI 中的证书颁发机构；作为替代方案，
也可以使用 K8s 证书 API 进行证书续订；亦或者，作为最后一种选择，生成 CSR 请求。</p>
<p>续订后，为了使更改生效，需要重新启动控制平面组件，并最终重新分发更新的证书，以防文件在其他地方使用。</p>
<pre><code>kubeadm certs renew scheduler.conf [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
保存证书的路径。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--csr-dir string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
CSR 和私钥的输出路径
</td>
</tr>
<tr>
<td colspan=2>--csr-only</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
创建 CSR 而不是生成证书
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
scheduler.conf 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
与集群通信时使用的 kubeconfig 文件。
如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan=2>--use-api</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
使用 Kubernetes 证书 API 续订证书
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div></div>
<h2 id=cmd-certs-certificate-key>kubeadm certs certificate-key</h2>
<p>此命令可用来生成一个新的控制面证书密钥。密钥可以作为 <code>--certificate-key</code>
标志的取值传递给 <a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-init><code>kubeadm init</code></a>
和 <a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-join><code>kubeadm join</code></a>
命令，从而在添加新的控制面节点时能够自动完成证书复制。</p>
<ul class="nav nav-tabs" id=tab-certs-certificate-key role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tab-certs-certificate-key-0 role=tab aria-controls=tab-certs-certificate-key-0 aria-selected=true>certificate-key</a></li>
</ul>
<div class=tab-content id=tab-certs-certificate-key><div id=tab-certs-certificate-key-0 class="tab-pane show active" role=tabpanel aria-labelledby=tab-certs-certificate-key-0>
<p>
<p>生成证书密钥</p>
<h3 id=概要>概要</h3>
<p>该命令将打印出可以与 "init" 命令一起使用的安全的随机生成的证书密钥。</p>
<p>你也可以使用 <code>kubeadm init --upload-certs</code> 而无需指定证书密钥；
命令将为你生成并打印一个证书密钥。</p>
<pre><code>kubeadm certs certificate-key [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
<p>
certificate-key 操作的帮助命令
</p>
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
<p>
[实验] 到 '真实' 主机根文件系统的路径。
</p>
</td>
</tr>
</tbody>
</table>
</div></div>
<h2 id=cmd-certs-check-expiration>kubeadm certs check-expiration</h2>
<p>此命令检查 kubeadm 所管理的本地 PKI 中的证书是否以及何时过期。
更多的相关细节，可参见
<a href=/zh/docs/tasks/administer-cluster/kubeadm/kubeadm-certs/#check-certificate-expiration>检查证书过期</a>。</p>
<ul class="nav nav-tabs" id=tab-certs-check-expiration role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tab-certs-check-expiration-0 role=tab aria-controls=tab-certs-check-expiration-0 aria-selected=true>check-expiration</a></li>
</ul>
<div class=tab-content id=tab-certs-check-expiration><div id=tab-certs-check-expiration-0 class="tab-pane show active" role=tabpanel aria-labelledby=tab-certs-check-expiration-0>
<p><h3 id=概要>概要</h3>
<p>检查 kubeadm 管理的本地 PKI 中证书的到期时间。</p>
<pre><code>kubeadm certs check-expiration [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值: "/etc/kubernetes/pki"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>保存证书的路径</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>kubeadm 配置文件的路径</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>check-expiration 的帮助命令</td>
</tr>
</tbody>
</table>
<h3 id=继承于父命令的选项>继承于父命令的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>[实验] 到'真实'主机根文件系统的路径。</td>
</tr>
</tbody>
</table>
</div></div>
<h2 id=cmd-certs-generate-csr>kubeadm certs generate-csr</h2>
<p>此命令可用来为所有控制面证书和 kubeconfig 文件生成密钥和 CSR（签名请求）。
用户可以根据自身需要选择 CA 为 CSR 签名。</p>
<ul class="nav nav-tabs" id=tab-certs-generate-csr role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tab-certs-generate-csr-0 role=tab aria-controls=tab-certs-generate-csr-0 aria-selected=true>generate-csr</a></li>
</ul>
<div class=tab-content id=tab-certs-generate-csr><div id=tab-certs-generate-csr-0 class="tab-pane show active" role=tabpanel aria-labelledby=tab-certs-generate-csr-0>
<p><p>为运行控制平面所需的所有证书生成密钥和证书签名请求（CSR）。该命令会生成部分 kubeconfig 文件，
其中 "users > user > client-key-data" 字段包含私钥数据，并为每个 kubeconfig
文件创建一个随附的 ".csr" 文件。</p>
<p>此命令设计用于
<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubeadm/kubeadm-certs/#external-ca-mode>Kubeadm 外部 CA 模式</a>。
它生成你可以提交给外部证书颁发机构进行签名的 CSR。</p>
<p>应使用 ".crt" 作为文件扩展名将 PEM 编码的签名证书与密钥文件一起保存。
或者，对于 kubeconfig 文件，PEM 编码的签名证书应使用 base64 编码，
并添加到 "users > user > client-certificate-data" 字段。</p>
<pre><code>kubeadm certs generate-csr [flags]
</code></pre>
<h3 id=示例>示例</h3>
<pre><code># 以下命令将为所有控制平面证书和 kubeconfig 文件生成密钥和 CSR :
kubeadm certs generate-csr --kubeconfig-dir /tmp/etc-k8s --cert-dir /tmp/etc-k8s/pki
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--cert-dir string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>保存证书的路径</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>kubeadm 配置文件的路径。</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>generate-csr 命令的帮助</td>
</tr>
<tr>
<td colspan=2>--kubeconfig-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>保存 kubeconfig 文件的路径。</td>
</tr>
</tbody>
</table>
<h3 id=继承于父命令的选项>继承于父命令的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>[实验] 到'真实'主机根文件系统的路径。</td>
</tr>
</tbody>
</table>
</div></div>
<h2 id=what-s-next>What's next</h2>
<ul>
<li>用来启动引导 Kubernetes 控制面节点的
<a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-init/>kubeadm init</a>
命令</li>
<li>用来将节点连接到集群的
<a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-join/>kubeadm join</a>
命令</li>
<li>用来回滚 <code>kubeadm init</code> 或 <code>kubeadm join</code> 对当前主机所做修改的
<a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-reset/>kubeadm reset</a>
命令</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-fbe8dcd222ce5795a5c325670a26b067>8.1.11 - kubeadm init phase</h1>
<p><code>kubeadm init phase</code> 能确保调用引导过程的原子步骤。
因此，如果希望自定义应用，则可以让 kubeadm 做一些工作，然后填补空白。</p>
<p><code>kubeadm init phase</code> 与 <a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-init/#init-workflow>kubeadm init 工作流</a>
一致，后台都使用相同的代码。</p>
<h2 id=cmd-phase-preflight>kubeadm init phase preflight</h2>
<p>使用此命令可以在控制平面节点上执行启动前检查。</p>
<ul class="nav nav-tabs" id=tab-preflight role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tab-preflight-0 role=tab aria-controls=tab-preflight-0 aria-selected=true>preflight</a></li>
</ul>
<div class=tab-content id=tab-preflight><div id=tab-preflight-0 class="tab-pane show active" role=tabpanel aria-labelledby=tab-preflight-0>
<p><h3 id=概要>概要</h3>
<p>运行 kubeadm init 前的启动检查。</p>
<pre><code>kubeadm init phase preflight [flags]
</code></pre>
<h3 id=案例>案例</h3>
<pre><code># 使用配置文件对 kubeadm init 进行启动检查。
kubeadm init phase preflight --config kubeadm-config.yml
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
preflight 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>--ignore-preflight-errors stringSlice</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
错误将显示为警告的检查列表：例如：'IsPrivilegedUser,Swap'。取值为 'all' 时将忽略检查中的所有错误。
</td>
</tr>
</tbody>
</table>
<h3 id=继承于父命令的选项>继承于父命令的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div></div>
<h2 id=cmd-phase-kubelet-start>kubeadm init phase kubelet-start</h2>
<p>此阶段将检查 kubelet 配置文件和环境文件，然后启动 kubelet。</p>
<ul class="nav nav-tabs" id=tab-kubelet-start role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tab-kubelet-start-0 role=tab aria-controls=tab-kubelet-start-0 aria-selected=true>kubelet-start</a></li>
</ul>
<div class=tab-content id=tab-kubelet-start><div id=tab-kubelet-start-0 class="tab-pane show active" role=tabpanel aria-labelledby=tab-kubelet-start-0>
<p><h3 id=概要>概要</h3>
<p>使用 kubelet 配置文件编写一个文件，并使用特定节点的 kubelet 设置编写一个环境文件，然后（重新）启动 kubelet。</p>
<pre><code>kubeadm init phase kubelet-start [flags]
</code></pre>
<h3 id=示例>示例</h3>
<pre><code># 从 InitConfiguration 文件中写入带有 kubelet 参数的动态环境文件。
kubeadm init phase kubelet-start --config config.yaml
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--cri-socket string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
连接到 CRI 套接字的路径。如果为空，则 kubeadm 将尝试自动检测该值；仅当安装了多个 CRI 或具有非标准 CRI 套接字时，才使用此选项。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubelet-start 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>--node-name string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指定节点名称。
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div></div>
<h2 id=cmd-phase-certs>kubeadm init phase certs</h2>
<p>该阶段可用于创建 kubeadm 所需的所有证书。</p>
<ul class="nav nav-tabs" id=tab-certs role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tab-certs-0 role=tab aria-controls=tab-certs-0 aria-selected=true>certs</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tab-certs-1 role=tab aria-controls=tab-certs-1>all</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tab-certs-2 role=tab aria-controls=tab-certs-2>ca</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tab-certs-3 role=tab aria-controls=tab-certs-3>apiserver</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tab-certs-4 role=tab aria-controls=tab-certs-4>apiserver-kubelet-client</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tab-certs-5 role=tab aria-controls=tab-certs-5>front-proxy-ca</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tab-certs-6 role=tab aria-controls=tab-certs-6>front-proxy-client</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tab-certs-7 role=tab aria-controls=tab-certs-7>etcd-ca</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tab-certs-8 role=tab aria-controls=tab-certs-8>etcd-server</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tab-certs-9 role=tab aria-controls=tab-certs-9>etcd-peer</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tab-certs-10 role=tab aria-controls=tab-certs-10>healthcheck-client</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tab-certs-11 role=tab aria-controls=tab-certs-11>apiserver-etcd-client</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tab-certs-12 role=tab aria-controls=tab-certs-12>sa</a></li></ul>
<div class=tab-content id=tab-certs><div id=tab-certs-0 class="tab-pane show active" role=tabpanel aria-labelledby=tab-certs-0>
<p><h3 id=概要>概要</h3>
<p>此命令并非设计用来单独运行。请参阅可用子命令列表。</p>
<pre><code>kubeadm init phase certs [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
certs 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<h3 id=从父指令中继承的选项>从父指令中继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div id=tab-certs-1 class=tab-pane role=tabpanel aria-labelledby=tab-certs-1>
<p><h3 id=概要>概要</h3>
<p>生成所有证书</p>
<pre><code>kubeadm init phase certs all [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
API 服务器所公布的其正在监听的 IP 地址。如果未设置，将使用默认网络接口。
</td>
</tr>
<tr>
<td colspan=2>--apiserver-cert-extra-sans stringSlice</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
用于 API 服务器服务证书的可选额外替代名称（SAN）。可以同时使用 IP 地址和 DNS 名称。
</td>
</tr>
<tr>
<td colspan=2>
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
证书的存储路径。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--control-plane-endpoint string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面指定一个稳定的 IP 地址或 DNS 名称。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
all 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面选择特定的 Kubernetes 版本。
</td>
</tr>
<tr>
<td colspan=2>
--service-cidr string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："10.96.0.0/12"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
VIP 服务使用其它的 IP 地址范围。
</td>
</tr>
<tr>
<td colspan=2>
--service-dns-domain string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："cluster.local"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
服务使用其它的域名，例如："myorg.internal"。
</td>
</tr>
</tbody>
</table>
<h3 id=继承于父命令的选项>继承于父命令的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div id=tab-certs-2 class=tab-pane role=tabpanel aria-labelledby=tab-certs-2>
<p><h3 id=概要>概要</h3>
<p>生成自签名的 Kubernetes CA 以提供其他 Kubernetes 组件的身份，并将其保存到 ca.cert 和 ca.key 文件中。</p>
<p>如果两个文件都已存在，则 kubeadm 将跳过生成步骤，使用现有文件。</p>
<p>Alpha 免责声明：此命令当前为 Alpha 功能。</p>
<pre><code>kubeadm init phase certs ca [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
证书的存储路径。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
ca 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面选择特定的 Kubernetes 版本。
</td>
</tr>
</tbody>
</table>
<h3 id=继承于父命令的选项>继承于父命令的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</td>
</tr>
</tbody>
</table>
</div>
<div id=tab-certs-3 class=tab-pane role=tabpanel aria-labelledby=tab-certs-3>
<p><h3 id=概要>概要</h3>
<p>生成用于服务 Kubernetes API 的证书，并将其保存到 apiserver.cert 和 apiserver.key 文件中。</p>
<p>默认 SAN 是 kubernetes、kubernetes.default、kubernetes.default.svc、kubernetes.default.svc.cluster.local、10.96.0.1、127.0.0.1。</p>
<p>如果两个文件都已存在，则 kubeadm 将跳过生成步骤，使用现有文件。</p>
<p>Alpha 免责声明：此命令当前为 Alpha 功能。</p>
<pre><code>kubeadm init phase certs apiserver [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
API 服务器所公布的其正在监听的 IP 地址。如果未设置，则使用默认的网络接口。
</td>
</tr>
<tr>
<td colspan=2>--apiserver-cert-extra-sans stringSlice</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
用于 API Server 服务证书的可选附加主体备用名称（SAN）。可以是 IP 地址和 DNS 名称。
</td>
</tr>
<tr>
<td colspan=2>
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
证书的存储路径。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--control-plane-endpoint string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面指定一个稳定的 IP 地址或 DNS 名称。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
apiserver 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面指定特定的 Kubernetes 版本。
</td>
</tr>
<tr>
<td colspan=2>
--service-cidr string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："10.96.0.0/12"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指定服务 VIP 可使用的其他 IP 地址段。
</td>
</tr>
<tr>
<td colspan=2>
--service-dns-domain string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："cluster.local"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为服务使用其他域名，例如 "myorg.internal"。
</td>
</tr>
</tbody>
</table>
<h3 id=继承于父命令的选项>继承于父命令的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div id=tab-certs-4 class=tab-pane role=tabpanel aria-labelledby=tab-certs-4>
<p><h3 id=概要>概要</h3>
<p>生成供 API 服务器连接 kubelet 的证书，并将其保存到 apiserver-kubelet-client.cert 和 apiserver-kubelet-client.key 文件中。</p>
<p>如果两个文件都已存在，则 kubeadm 将跳过生成步骤，使用现有文件。</p>
<p>Alpha 免责声明：此命令当前为 Alpha 功能。</p>
<pre><code>kubeadm init phase certs apiserver-kubelet-client [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
存储证书的路径。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件路径。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
apiserver-kubelet-client 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面指定特定的 Kubernetes 版本。
</td>
</tr>
</tbody>
</table>
<h3 id=继承于父命令的选项>继承于父命令的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 指向宿主机上的 '实际' 根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div id=tab-certs-5 class=tab-pane role=tabpanel aria-labelledby=tab-certs-5>
<p><h3 id=概要>概要</h3>
<p>生成自签名 CA 来提供前端代理的身份，并将其保存到 front-proxy-ca.cert 和 front-proxy-ca.key 文件中。</p>
<p>如果两个文件都已存在，kubeadm 将跳过生成步骤并将使用现有文件。</p>
<p>Alpha 免责声明：此命令目前是 alpha 阶段。</p>
<pre><code>kubeadm init phase certs front-proxy-ca [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
存储证书的路径。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
front-proxy-ca 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面选择特定的 Kubernetes 版本。
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div id=tab-certs-6 class=tab-pane role=tabpanel aria-labelledby=tab-certs-6>
<p><h3 id=概要>概要</h3>
<p>为前端代理客户端生成证书，并将其保存到 front-proxy-client.cert 和 front-proxy-client.key 文件中。
如果两个文件都已存在，kubeadm 将跳过生成步骤并将使用现有文件。
Alpha 免责声明：此命令目前是 alpha 阶段。</p>
<pre><code>kubeadm init phase certs front-proxy-client [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认："/etc/kubernetes/pki"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
存储证书的路径。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
front-proxy-client 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面选择特定的 Kubernetes 版本。
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div id=tab-certs-7 class=tab-pane role=tabpanel aria-labelledby=tab-certs-7>
<p><h3 id=概要>概要</h3>
<p>生成用于为 etcd 设置身份的自签名 CA，并将其保存到 etcd/ca.cert 和 etcd/ca.key 文件中。</p>
<p>如果两个文件都已存在，则 kubeadm 将跳过生成步骤，使用现有文件。</p>
<p>Alpha 免责声明：此命令当前为 Alpha 功能。</p>
<pre><code>kubeadm init phase certs etcd-ca [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
证书的存储路径。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
etcd-ca 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面选择特定的 Kubernetes 版本。
</td>
</tr>
</tbody>
</table>
<h3 id=继承于父命令的选项>继承于父命令的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div id=tab-certs-8 class=tab-pane role=tabpanel aria-labelledby=tab-certs-8>
<p><h3 id=概要>概要</h3>
<p>生成用于提供 etcd 服务的证书，并将其保存到 etcd/server.crt 和 etcd/server.key 文件中。</p>
<p>默认 SAN 为 localhost、127.0.0.1、127.0.0.1、:: 1</p>
<p>如果两个文件都已存在，则 kubeadm 将跳过生成步骤，使用现有文件。</p>
<p>Alpha 免责声明：此命令当前为 alpha 功能。</p>
<pre><code>kubeadm init phase certs etcd-server [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
<p>保存和存储证书的路径。<p>
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
<p>kubeadm 配置文件的路径。<p>
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
<p>etcd-server 操作的帮助命令<p>
</td>
</tr>
<tr>
<td colspan=2>
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
<p>为控制平面指定特定的 Kubernetes 版本。<p>
</td>
</tr>
</tbody>
</table>
<h3 id=继承于父命令的选项>继承于父命令的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
<p>[实验] 到 '真实' 主机根文件系统的路径。<p>
</td>
</tr>
</tbody>
</table>
</div>
<div id=tab-certs-9 class=tab-pane role=tabpanel aria-labelledby=tab-certs-9>
<p><h3 id=概要>概要</h3>
<p>生成 etcd 节点相互通信的证书，并将其保存到 etcd/peer.cert 和 etcd/peer.key 文件中。</p>
<p>默认 SAN 为 localhost、127.0.0.1、127.0.0.1、:: 1</p>
<p>如果两个文件都已存在，则 kubeadm 将跳过生成步骤，使用现有文件。</p>
<p>Alpha 免责声明：此命令当前为 alpha 功能。</p>
<pre><code>kubeadm init phase certs etcd-peer [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
保存和存储证书的路径。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
etcd-peer 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面指定特定的 Kubernetes 版本。
</td>
</tr>
</tbody>
</table>
<h3 id=继承于父命令的选项>继承于父命令的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div id=tab-certs-10 class=tab-pane role=tabpanel aria-labelledby=tab-certs-10>
<p><h3 id=概要>概要</h3>
<p>生成用于 etcd 健康检查的活跃性探针的证书，并将其保存到 healthcheck-client.cert 和 etcd/healthcheck-client.key 文件中。</p>
<p>如果两个文件都已存在，则 kubeadm 将跳过生成步骤，使用现有文件。</p>
<p>Alpha 免责声明：此命令当前为 alpha 功能。</p>
<pre><code>kubeadm init phase certs etcd-healthcheck-client [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
证书存储的路径。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
etcd-healthcheck-client 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面选择特定的 Kubernetes 版本。
</td>
</tr>
</tbody>
</table>
<h3 id=继承于父命令的选项>继承于父命令的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div id=tab-certs-11 class=tab-pane role=tabpanel aria-labelledby=tab-certs-11>
<p><h3 id=概要>概要</h3>
<p>生成 apiserver 用于访问 etcd 的证书，并将其保存到 apiserver-etcd-client.cert 和 apiserver-etcd-client.key 文件中。</p>
<p>如果两个文件都已存在，则 kubeadm 将跳过生成步骤，使用现有文件。</p>
<p>Alpha 免责声明：此命令当前为 Alpha 功能。</p>
<pre><code>kubeadm init phase certs apiserver-etcd-client [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
证书的存储路径。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
apiserver-etcd-client 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面指定特定的 Kubernetes 版本。
</td>
</tr>
</tbody>
</table>
<h3 id=继承于父命令的选项>继承于父命令的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div id=tab-certs-12 class=tab-pane role=tabpanel aria-labelledby=tab-certs-12>
<p><h3 id=概要>概要</h3>
<p>生成用于签名 service account 令牌的私钥及其公钥，并将其保存到 sa.key 和 sa.pub 文件中。如果两个文件都已存在，则 kubeadm 会跳过生成步骤，而将使用现有文件。</p>
<p>Alpha 免责声明：此命令当前为 alpha 阶段。</p>
<pre><code>kubeadm init phase certs sa [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
保存和存储证书的路径。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
sa 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<h3 id=继承于父命令的选项>继承于父命令的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div></div>
<h2 id=cmd-phase-kubeconfig>kubeadm init phase kubeconfig</h2>
<p>可以通过调用 <code>all</code> 子命令来创建所有必需的 kubeconfig 文件，或者分别调用它们。</p>
<ul class="nav nav-tabs" id=tab-kubeconfig role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tab-kubeconfig-0 role=tab aria-controls=tab-kubeconfig-0 aria-selected=true>kubeconfig</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tab-kubeconfig-1 role=tab aria-controls=tab-kubeconfig-1>all</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tab-kubeconfig-2 role=tab aria-controls=tab-kubeconfig-2>admin</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tab-kubeconfig-3 role=tab aria-controls=tab-kubeconfig-3>kubelet</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tab-kubeconfig-4 role=tab aria-controls=tab-kubeconfig-4>controller-manager</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tab-kubeconfig-5 role=tab aria-controls=tab-kubeconfig-5>scheduler</a></li></ul>
<div class=tab-content id=tab-kubeconfig><div id=tab-kubeconfig-0 class="tab-pane show active" role=tabpanel aria-labelledby=tab-kubeconfig-0>
<p><h3 id=概要>概要</h3>
<p>此命令并非设计用来单独运行。请阅读可用子命令列表。</p>
<pre><code>kubeadm init phase kubeconfig [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeconfig 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div id=tab-kubeconfig-1 class=tab-pane role=tabpanel aria-labelledby=tab-kubeconfig-1>
<p><h3 id=概要>概要</h3>
<p>生成所有 kubeconfig 文件</p>
<pre><code>kubeadm init phase kubeconfig all [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
API 服务器所公布的其正在监听的 IP 地址。如果没有设置，将使用默认的网络接口。
</td>
</tr>
<tr>
<td colspan=2>
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：6443
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
要绑定到 API 服务器的端口。
</td>
</tr>
<tr>
<td colspan=2>
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
保存和存储证书的路径。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--control-plane-endpoint string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面指定一个稳定的 IP 地址或 DNS 名称。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
all 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--kubeconfig-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeconfig 文件的保存路径。
</td>
</tr>
<tr>
<td colspan=2>
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面指定特定的 Kubernetes 版本。
</td>
</tr>
<tr>
<td colspan=2>--node-name string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指定节点名称。
</td>
</tr>
</tbody>
</table>
<h3 id=继承于父命令的选项>继承于父命令的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div id=tab-kubeconfig-2 class=tab-pane role=tabpanel aria-labelledby=tab-kubeconfig-2>
<p><h3 id=概要>概要</h3>
<p>为管理员和 kubeadm 本身生成 kubeconfig 文件，并将其保存到 admin.conf 文件中。</p>
<pre><code>kubeadm init phase kubeconfig admin [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
API 服务器所公布的其正在监听的 IP 地址。如果未设置，则使用默认的网络接口。
</td>
</tr>
<tr>
<td colspan=2>
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：6443
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
要绑定到 API 服务器的端口。
</td>
</tr>
<tr>
<td colspan=2>
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
保存和存储证书的路径。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--control-plane-endpoint string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面指定一个稳定的 IP 地址或 DNS 名称。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
admin 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--kubeconfig-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeconfig 文件的保存路径。
</td>
</tr>
<tr>
<td colspan=2>
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面指定特定的 Kubernetes 版本。
</td>
</tr>
</tbody>
</table>
<h3 id=继承于父命令的选项>继承于父命令的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div id=tab-kubeconfig-3 class=tab-pane role=tabpanel aria-labelledby=tab-kubeconfig-3>
<p><h3 id=概要>概要</h3>
<p>生成 kubelet 要使用的 kubeconfig 文件，并将其保存到 kubelet.conf 文件。</p>
<p>请注意，该操作目的是<em>仅</em>应用于引导集群。在控制平面启动之后，应该从 CSR API 请求所有 kubelet 凭据。</p>
<pre><code>kubeadm init phase kubeconfig kubelet [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
API 服务器所公布的其正在监听的 IP 地址。如果未设置，则使用默认的网络接口。
</td>
</tr>
<tr>
<td colspan=2>
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：6443
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
要绑定到 API 服务器的端口。
</td>
</tr>
<tr>
<td colspan=2>
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
保存和存储证书的路径。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--control-plane-endpoint string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面指定一个稳定的 IP 地址或 DNS 名称。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubelet 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--kubeconfig-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeconfig 文件的保存路径。
</td>
</tr>
<tr>
<td colspan=2>
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面选择特定的 Kubernetes 版本。
</td>
</tr>
<tr>
<td colspan=2>--node-name string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指定节点的名称。
</td>
</tr>
</tbody>
</table>
<h3 id=继承于父命令的选项>继承于父命令的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div id=tab-kubeconfig-4 class=tab-pane role=tabpanel aria-labelledby=tab-kubeconfig-4>
<p><h3 id=概要>概要</h3>
<p>生成控制器管理器要使用的 kubeconfig 文件，并保存到 controller-manager.conf 文件中。</p>
<pre><code>kubeadm init phase kubeconfig controller-manager [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
API 服务器所公布的其正在监听的 IP 地址。如果未设置，则使用默认的网络接口。
</td>
</tr>
<tr>
<td colspan=2>
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：6443
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
要绑定到 API 服务器的端口。
</td>
</tr>
<tr>
<td colspan=2>
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
保存和存储证书的路径。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--control-plane-endpoint string</td>
</tr>
</tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面指定一个稳定的 IP 地址或 DNS 名称。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
controller-manager 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--kubeconfig-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeconfig 文件的保存路径。
</td>
</tr>
<tr>
<td colspan=2>
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面指定特定的 Kubernetes 版本。
</td>
</tr>
</tbody>
</table>
<h3 id=继承于父命令的选项>继承于父命令的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs 字符串</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div id=tab-kubeconfig-5 class=tab-pane role=tabpanel aria-labelledby=tab-kubeconfig-5>
<p><h3 id=概要>概要</h3>
<p>生成调度器（scheduler）要使用的 kubeconfig 文件，并保存到 scheduler.conf 文件中。</p>
<pre><code>kubeadm init phase kubeconfig scheduler [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
API 服务器所公布的其正在监听的 IP 地址。如果未设置，则使用默认的网络接口。
</td>
</tr>
<tr>
<td colspan=2>
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：6443
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
要绑定到 API 服务器的端口。
</td>
</tr>
<tr>
<td colspan=2>
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
保存和存储证书的路径。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--control-plane-endpoint string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面指定一个稳定的 IP 地址或 DNS 名称。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
scheduler 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--kubeconfig-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeconfig 文件的保存路径。
</td>
</tr>
<tr>
<td colspan=2>
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面指定特定的 Kubernetes 版本。
</td>
</tr>
</tbody>
</table>
<h3 id=继承于父命令的选项>继承于父命令的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div></div>
<h2 id=cmd-phase-control-plane>kubeadm init phase control-plane</h2>
<p>使用此阶段，可以为控制平面组件创建所有必需的静态 Pod 文件。</p>
<ul class="nav nav-tabs" id=tab-control-plane role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tab-control-plane-0 role=tab aria-controls=tab-control-plane-0 aria-selected=true>control-plane</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tab-control-plane-1 role=tab aria-controls=tab-control-plane-1>all</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tab-control-plane-2 role=tab aria-controls=tab-control-plane-2>apiserver</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tab-control-plane-3 role=tab aria-controls=tab-control-plane-3>controller-manager</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tab-control-plane-4 role=tab aria-controls=tab-control-plane-4>scheduler</a></li></ul>
<div class=tab-content id=tab-control-plane><div id=tab-control-plane-0 class="tab-pane show active" role=tabpanel aria-labelledby=tab-control-plane-0>
<p><h3 id=概要>概要</h3>
<p>此命令并非设计用来单独运行。请参阅可用子命令列表。</p>
<pre><code>kubeadm init phase control-plane [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
control-plane 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<h3 id=继承于父命令的选项>继承于父命令的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</td>
</tr>
</tbody>
</table>
</div>
<div id=tab-control-plane-1 class=tab-pane role=tabpanel aria-labelledby=tab-control-plane-1>
<p><h3 id=概要>概要</h3>
<p>生成所有的静态 Pod 清单文件</p>
<pre><code>kubeadm init phase control-plane all [flags]
</code></pre>
<h3 id=示例>示例</h3>
<pre><code># 为控制平面组件生成静态 Pod 清单文件，其功能等效于 kubeadm init 生成的文件。
kubeadm init phase control-plane all

# 使用从某配置文件中读取的选项为生成静态 Pod 清单文件。
kubeadm init phase control-plane all --config config.yaml
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
API 服务器所公布的其正在监听的 IP 地址。如果未设置，将使用默认的网络接口。
</td>
</tr>
<tr>
<td colspan=2>--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：6443</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
API 服务器要绑定的端口。
</td>
</tr>
<tr>
<td colspan=2>--apiserver-extra-args mapStringString</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
形式为 &lt;flagname>=&lt;value> 的一组额外参数，用来传递给 API 服务器，
或者覆盖其默认配置值
</td>
</tr>
<tr>
<td colspan=2>
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
存储证书的路径。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--control-plane-endpoint string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面选择一个稳定的 IP 地址或者 DNS 名称。
</td>
</tr>
<tr>
<td colspan=2>--controller-manager-extra-args mapStringString</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
一组形式为 &lt;flagname>=&lt;value> 的额外参数，用来传递给控制管理器（Controller Manager）
或覆盖其默认设置值
</td>
</tr>
<tr>
<td colspan=2>--experimental-patches string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
包含名为 "target[suffix][+patchtype].extension" 的文件的目录。
例如，"kube-apiserver0+merge.yaml" 或者 "etcd.json"。
"patchtype" 可以是 "strategic"、"merge" 或 "json" 之一，分别与 kubectl
所支持的 patch 格式相匹配。默认的 "patchtype" 是 "strategic"。
"extension" 必须是 "json" 或 "yaml"。
"suffix" 是一个可选的字符串，用来确定按字母顺序排序时首先应用哪些 patch。
</td>
</tr>
<tr>
<td colspan=2>--feature-gates string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
一组用来描述各种特性门控的键值（key=value）对。选项是：
<br>IPv6DualStack=true|false (ALPHA - 默认=false)
<br>PublicKeysECDSA=true|false (ALPHA - 默认=false)
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
all 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："k8s.gcr.io"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
选择用于拉取控制平面镜像的容器仓库
</td>
</tr>
<tr>
<td colspan=2>
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面选择指定的 Kubernetes 版本。
</td>
</tr>
<tr>
<td colspan=2>--pod-network-cidr string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指定 Pod 网络的 IP 地址范围。如果设置了此标志，控制平面将自动地为每个节点分配 CIDR。
</td>
</tr>
<tr>
<td colspan=2>--scheduler-extra-args mapStringString</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
一组形式为 &lt;flagname>=&lt;value> 的额外参数，用来传递给调度器（Scheduler）
或覆盖其默认设置值
<p>传递给调度器（scheduler）一组额外的参数或者以 &lt;flagname>=&lt;value> 形式覆盖其默认值。</p>
</td>
</tr>
<tr>
<td colspan=2>
--service-cidr string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："10.96.0.0/12"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为服务 VIP 选择 IP 地址范围。
</td>
</tr>
</tbody>
</table>
<h3 id=从父指令继承的选项>从父指令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 指向 '真实' 宿主机的根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div id=tab-control-plane-2 class=tab-pane role=tabpanel aria-labelledby=tab-control-plane-2>
<p><h3 id=概要>概要</h3>
<p>生成 kube-apiserver 静态 Pod 清单</p>
<pre><code>kubeadm init phase control-plane apiserver [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
API 服务器所公布的其正在监听的 IP 地址。如果未设置，将使用默认网络接口。
</td>
</tr>
<tr>
<td colspan=2>
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值： 6443
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
要绑定到 API 服务器的端口。
</td>
</tr>
<tr>
<td colspan=2>--apiserver-extra-args mapStringString</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
一组 &lt;flagname>=&lt;value> 形式的额外参数，用来传递给 API 服务器
或者覆盖其默认参数配置
</td>
</tr>
<tr>
<td colspan=2>
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
保存和存储证书的路径。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--control-plane-endpoint string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面指定一个稳定的 IP 地址或 DNS 名称。
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
包含名为 "target[suffix][+patchtype].extension" 的文件的目录。
例如，"kube-apiserver0+merge.yaml" 或者 "etcd.json"。
"patchtype" 可以是 "strategic"、"merge" 或 "json" 之一，分别与 kubectl
所支持的 patch 格式相匹配。默认的 "patchtype" 是 "strategic"。
"extension" 必须是 "json" 或 "yaml"。
"suffix" 是一个可选的字符串，用来确定按字母顺序排序时首先应用哪些 patch。
</td>
</tr>
<tr>
<td colspan=2>--feature-gates string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
一组键值对，用于描述各种功能特性的特性门控。选项是：
<br>IPv6DualStack=true|false (ALPHA - 默认=false)
<br>PublicKeysECDSA=true|false (ALPHA - 默认=false)
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
apiserver 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："k8s.gcr.io"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
选择要从中拉取控制平面镜像的容器仓库
</td>
</tr>
<tr>
<td colspan=2>
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面选择特定的 Kubernetes 版本
</td>
</tr>
<tr>
<td colspan=2>
--service-cidr string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："10.96.0.0/12"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指定服务 VIP 使用 IP 地址的其他范围。
</td>
</tr>
</tbody>
</table>
<h3 id=继承于父命令的选项>继承于父命令的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统路径。
</td>
</tr>
</tbody>
</table>
</div>
<div id=tab-control-plane-3 class=tab-pane role=tabpanel aria-labelledby=tab-control-plane-3>
<p><h3 id=概要>概要</h3>
<p>生成 kube-controller-manager 静态 Pod 清单</p>
<pre><code>kubeadm init phase control-plane controller-manager [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
存储证书的路径。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--controller-manager-extra-args mapStringString</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
一组 &lt;flagname>=&lt; 形式的额外参数，传递给控制器管理器（Controller Manager）
或者覆盖其默认配置值
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
包含名为 "target[suffix][+patchtype].extension" 的文件的目录。
例如，"kube-apiserver0+merge.yaml" 或者 "etcd.json"。
"patchtype" 可以是 "strategic"、"merge" 或 "json" 之一，分别与 kubectl
所支持的 patch 格式相匹配。默认的 "patchtype" 是 "strategic"。
"extension" 必须是 "json" 或 "yaml"。
"suffix" 是一个可选的字符串，用来确定按字母顺序排序时首先应用哪些 patch。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
controller-manager 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："k8s.gcr.io"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
选择要从中拉取控制平面镜像的容器仓库
</td>
</tr>
<tr>
<td colspan=2>
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面选择特定的 Kubernetes 版本。
</td>
</tr>
<tr>
<td colspan=2>--pod-network-cidr string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指定 Pod 网络的 IP 地址范围。如果设置，控制平面将自动为每个节点分配 CIDR。
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div id=tab-control-plane-4 class=tab-pane role=tabpanel aria-labelledby=tab-control-plane-4>
<p><h3 id=概要>概要</h3>
<p>生成 kube-scheduler 静态 Pod 清单</p>
<pre><code>kubeadm init phase control-plane scheduler [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
存储证书的路径。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--experimental-patches string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
包含名为 "target[suffix][+patchtype].extension" 的文件的目录。
例如，"kube-apiserver0+merge.yaml" 或者 "etcd.json"。
"patchtype" 可以是 "strategic"、"merge" 或 "json" 之一，分别与 kubectl
所支持的 patch 格式相匹配。默认的 "patchtype" 是 "strategic"。
"extension" 必须是 "json" 或 "yaml"。
"suffix" 是一个可选的字符串，用来确定按字母顺序排序时首先应用哪些 patch。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
scheduler 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值:"k8s.gcr.io"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
选择要从中拉取控制平面镜像的容器仓库
</td>
</tr>
<tr>
<td colspan=2>
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面选择特定的 Kubernetes 版本。
</td>
</tr>
<tr>
<td colspan=2>--scheduler-extra-args mapStringString</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
一组 &lt;flagname>=&lt;value> 形式的额外参数，用来传递给调度器
或者覆盖其默认参数配置
</td>
</tr>
</tbody>
</table>
<h3 id=继承于父命令的选项>继承于父命令的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div></div>
<h2 id=cmd-phase-etcd>kubeadm init phase etcd</h2>
<p>根据静态 Pod 文件，使用以下阶段创建本地 etcd 实例。</p>
<ul class="nav nav-tabs" id=tab-etcd role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tab-etcd-0 role=tab aria-controls=tab-etcd-0 aria-selected=true>etcd</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tab-etcd-1 role=tab aria-controls=tab-etcd-1>local</a></li></ul>
<div class=tab-content id=tab-etcd><div id=tab-etcd-0 class="tab-pane show active" role=tabpanel aria-labelledby=tab-etcd-0>
<p><h3 id=概要>概要</h3>
<p>此命令并非设计用来单独运行。请参阅可用子命令列表。</p>
<pre><code>kubeadm init phase etcd [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
etcd 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<h3 id=继承于父命令的选项>继承于父命令的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div id=tab-etcd-1 class=tab-pane role=tabpanel aria-labelledby=tab-etcd-1>
<p><h3 id=概要>概要</h3>
<p>为本地单节点 etcd 实例生成静态 Pod 清单文件</p>
<pre><code>kubeadm init phase etcd local [flags]
</code></pre>
<h3 id=示例>示例</h3>
<pre><code># 为 etcd 生成静态 Pod 清单文件，其功能等效于 kubeadm init 生成的文件。
kubeadm init phase etcd local

# 使用从配置文件读取的选项为 etcd 生成静态 Pod 清单文件。
kubeadm init phase etcd local --config config.yaml
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
存储证书的路径。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--experimental-patches string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
包含名为 "target[suffix][+patchtype].extension" 的文件的目录的路径。
例如，"kube-apiserver0+merge.yaml" 或仅仅是 "etcd.json"。
"patchtype" 可以是 "strategic"、"merge" 或 "json" 之一，并且它们与 kubectl 支持的补丁格式匹配。
默认的 "patchtype" 为 "strategic"。 "extension" 必须为 "json" 或 "yaml"。
"suffix" 是一个可选字符串，可用于确定首先按字母顺序应用哪些补丁。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
local 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："k8s.gcr.io"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
选择要从中拉取控制平面镜像的容器仓库
</td>
</tr>
</tbody>
</table>
<h3 id=继承于父命令的选项>继承于父命令的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div></div>
<h2 id=cmd-phase-upload-config>kubeadm init phase upload-config</h2>
<p>可以使用此命令将 kubeadm 配置文件上传到集群。或者使用
<a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-config/>kubeadm config</a>。</p>
<ul class="nav nav-tabs" id=upload-config role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#upload-config-0 role=tab aria-controls=upload-config-0 aria-selected=true>upload-config</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#upload-config-1 role=tab aria-controls=upload-config-1>all</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#upload-config-2 role=tab aria-controls=upload-config-2>kubeadm</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#upload-config-3 role=tab aria-controls=upload-config-3>kubelet</a></li></ul>
<div class=tab-content id=upload-config><div id=upload-config-0 class="tab-pane show active" role=tabpanel aria-labelledby=upload-config-0>
<p><h3 id=概要>概要</h3>
<p>此命令并非设计用来单独运行。请参阅可用的子命令列表。</p>
<pre><code>kubeadm init phase upload-config [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
upload-config 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令中继承的选项>从父命令中继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div id=upload-config-1 class=tab-pane role=tabpanel aria-labelledby=upload-config-1>
<p><h3 id=概要>概要</h3>
<p>将所有配置上传到 ConfigMap</p>
<pre><code>kubeadm init phase upload-config all [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
all 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
与集群通信时使用的 kubeconfig 文件。如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div id=upload-config-2 class=tab-pane role=tabpanel aria-labelledby=upload-config-2>
<p><h3 id=概要>概要</h3>
<p>将 kubeadm ClusterConfiguration 上传到 kube-system 命名空间中名为 kubeadm-config 的 ConfigMap 中。
这样就可以正确配置系统组件，并在升级时提供无缝的用户体验。</p>
<p>另外，可以使用 kubeadm 配置。</p>
<pre><code>kubeadm init phase upload-config kubeadm [flags]
</code></pre>
<h3 id=示例>示例</h3>
<pre><code># 上传集群配置
kubeadm init phase upload-config --config=myConfig.yaml
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
与集群通信时使用的 kubeconfig 文件。如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div id=upload-config-3 class=tab-pane role=tabpanel aria-labelledby=upload-config-3>
<p><h3 id=概要>概要</h3>
<p>将从 kubeadm InitConfiguration 对象提取的 kubelet 配置上传到集群中 kubelet-config-1.X 形式的
ConfigMap，其中 X 是当前（API 服务器）Kubernetes 版本的次要版本。</p>
<pre><code>kubeadm init phase upload-config kubelet [flags]
</code></pre>
<h3 id=示例>示例</h3>
<pre><code># 将 kubelet 配置从 kubeadm 配置文件上传到集群中的 ConfigMap。
kubeadm init phase upload-config kubelet --config kubeadm.yaml
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
到 kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubelet 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
与集群通信时使用的 kubeconfig 文件。如果未设置该标签，则可以通过一组标准路径来寻找已有的 kubeconfig 文件。
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div></div>
<h2 id=cmd-phase-upload-certs>kubeadm init phase upload-certs</h2>
<p>使用以下阶段将控制平面证书上传到集群。默认情况下，证书和加密密钥会在两个小时后过期。</p>
<ul class="nav nav-tabs" id=tab-upload-certs role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tab-upload-certs-0 role=tab aria-controls=tab-upload-certs-0 aria-selected=true>upload-certs</a></li>
</ul>
<div class=tab-content id=tab-upload-certs><div id=tab-upload-certs-0 class="tab-pane show active" role=tabpanel aria-labelledby=tab-upload-certs-0>
<p><h3 id=概要>概要</h3>
<p>此命令并非设计用来单独运行。请参阅可用子命令列表。</p>
<pre><code>kubeadm init phase upload-certs [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--certificate-key string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
用于加密 kubeadm-certs Secret 中的控制平面证书的密钥。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
upload-certs 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
用来与集群通信的 kubeconfig 文件。
如果此标志未设置，则可以在一组标准的位置搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan=2>--skip-certificate-key-print</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
不要打印输出用于加密控制平面证书的密钥。
</td>
</tr>
<tr>
<td colspan=2>--upload-certs</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
将控制平面证书上传到 kubeadm-certs Secret。
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div></div>
<h2 id=cmd-phase-mark-control-plane>kubeadm init phase mark-control-plane</h2>
<p>使用以下阶段来给具有 <code>node-role.kubernetes.io/master=""</code> 键值对的节点
打标签（label）和记录污点（taint）。</p>
<ul class="nav nav-tabs" id=tab-mark-control-plane role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tab-mark-control-plane-0 role=tab aria-controls=tab-mark-control-plane-0 aria-selected=true>mark-control-plane</a></li>
</ul>
<div class=tab-content id=tab-mark-control-plane><div id=tab-mark-control-plane-0 class="tab-pane show active" role=tabpanel aria-labelledby=tab-mark-control-plane-0>
<p><h3 id=概要>概要</h3>
<p>标记 Node 节点为控制平面节点</p>
<pre><code>kubeadm init phase mark-control-plane [flags]
</code></pre>
<h3 id=示例>示例</h3>
<pre><code># 将控制平面标签和污点应用于当前节点，其功能等效于 kubeadm init执行的操作。
kubeadm init phase mark-control-plane --config config.yml

# 将控制平面标签和污点应用于特定节点
kubeadm init phase mark-control-plane --node-name myNode
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
mark-control-plane 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>--node-name string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指定节点名称。
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs 字符串</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div></div>
<h2 id=cmd-phase-bootstrap-token>kubeadm init phase bootstrap-token</h2>
<p>使用以下阶段来配置引导令牌。</p>
<ul class="nav nav-tabs" id=tab-bootstrap-token role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tab-bootstrap-token-0 role=tab aria-controls=tab-bootstrap-token-0 aria-selected=true>bootstrap-token</a></li>
</ul>
<div class=tab-content id=tab-bootstrap-token><div id=tab-bootstrap-token-0 class="tab-pane show active" role=tabpanel aria-labelledby=tab-bootstrap-token-0>
<p><h3 id=概要>概要</h3>
<p>启动引导令牌（bootstrap token）用于在即将加入集群的节点和控制平面节点之间建立双向信任。</p>
<p>该命令使启动引导令牌（bootstrap token）所需的所有配置生效，然后创建初始令牌。</p>
<pre><code>kubeadm init phase bootstrap-token [flags]
</code></pre>
<h3 id=示例>示例</h3>
<pre><code># 进行所有引导令牌配置，并创建一个初始令牌，功能上与 kubeadm init 生成的令牌等效。
kubeadm init phase bootstrap-token
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
bootstrap-token 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
用于和集群通信的 kubeconfig 文件。如果它没有被设置，那么 kubeadm 将会搜索一个已经存在于标准路径的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan=2>--skip-token-print</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
跳过打印 'kubeadm init' 生成的默认引导令牌。
</td>
</tr>
</tbody>
</table>
<h3 id=继承于父命令的选项>继承于父命令的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div></div>
<h2 id=cmd-phase-kubelet-finalize-all>kubeadm init phase kubelet-finalize</h2>
<p>使用以下阶段在 TLS 引导后更新与 kubelet 相关的设置。
你可以使用 <code>all</code> 子命令来运行所有 <code>kubelet-finalize</code> 阶段。</p>
<ul class="nav nav-tabs" id=tab-kubelet-finalize role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tab-kubelet-finalize-0 role=tab aria-controls=tab-kubelet-finalize-0 aria-selected=true>kubelet-finalize</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tab-kubelet-finalize-1 role=tab aria-controls=tab-kubelet-finalize-1>kubelet-finalize-all</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tab-kubelet-finalize-2 role=tab aria-controls=tab-kubelet-finalize-2>kubelet-finalize-cert-rotation</a></li></ul>
<div class=tab-content id=tab-kubelet-finalize><div id=tab-kubelet-finalize-0 class="tab-pane show active" role=tabpanel aria-labelledby=tab-kubelet-finalize-0>
<p><p>TLS 引导后更新与 kubelet 相关的设置</p>
<pre><code>kubeadm init phase kubelet-finalize [flags]
</code></pre>
<h3 id=示例>示例</h3>
<pre><code>  # 在 TLS 引导后更新与 kubelet 相关的设置
  kubeadm init phase kubelet-finalize all --config
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>kubelet-finalize 操作的帮助命令</td>
</tr>
</tbody>
</table>
<h3 id=继承于父命令的选项>继承于父命令的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>[实验] 到'真实'主机根文件系统的路径。</td>
</tr>
</tbody>
</table>
</div>
<div id=tab-kubelet-finalize-1 class=tab-pane role=tabpanel aria-labelledby=tab-kubelet-finalize-1>
<p><p>运行所有 kubelet-finalize 阶段</p>
<pre><code>kubeadm init phase kubelet-finalize all [flags]
</code></pre>
<h3 id=示例>示例</h3>
<pre><code>  # 在 TLS 引导后更新与 kubelet 相关的设置
  kubeadm init phase kubelet-finalize all --config
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值: "/etc/kubernetes/pki"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>保存和存储证书的路径。</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>kubeadm 配置文件的路径。</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>all 操作的帮助命令</td>
</tr>
</tbody>
</table>
<h3 id=继承于父命令的选项>继承于父命令的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>[实验] 到'真实'主机根文件系统的路径。</td>
</tr>
</tbody>
</table>
</div>
<div id=tab-kubelet-finalize-2 class=tab-pane role=tabpanel aria-labelledby=tab-kubelet-finalize-2>
<p><p>启用 kubelet 客户端证书轮换</p>
<pre><code>kubeadm init phase kubelet-finalize experimental-cert-rotation [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>保存和存储证书的路径。</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>kubeadm 配置文件的路径。</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>experimental-cert-rotation 操作的帮助命令</td>
</tr>
</tbody>
</table>
<h3 id=继承于父命令的选项>继承于父命令的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>[实验] 到'真实'主机根文件系统的路径。</td>
</tr>
</tbody>
</table>
</div></div>
<h2 id=cmd-phase-addon>kubeadm init phase addon</h2>
<p>可以使用 <code>all</code> 子命令安装所有可用的插件，或者有选择性地安装它们。</p>
<ul class="nav nav-tabs" id=tab-addon role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tab-addon-0 role=tab aria-controls=tab-addon-0 aria-selected=true>addon</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tab-addon-1 role=tab aria-controls=tab-addon-1>all</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tab-addon-2 role=tab aria-controls=tab-addon-2>coredns</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tab-addon-3 role=tab aria-controls=tab-addon-3>kube-proxy</a></li></ul>
<div class=tab-content id=tab-addon><div id=tab-addon-0 class="tab-pane show active" role=tabpanel aria-labelledby=tab-addon-0>
<p><h3 id=概要>概要</h3>
<p>此命令并非设计用来单独运行。请参阅可用子命令列表。</p>
<pre><code>kubeadm init phase addon [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
addon 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<h3 id=继承于父命令的选项>继承于父命令的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div id=tab-addon-1 class=tab-pane role=tabpanel aria-labelledby=tab-addon-1>
<p><h3 id=概要>概要</h3>
<p>安装所有插件（addon）</p>
<pre><code>kubeadm init phase addon all [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
API 服务器所公布的其正在监听的 IP 地址。如果未设置，则将使用默认网络接口。
</td>
</tr>
<tr>
<td colspan=2>
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：6443
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
API 服务器绑定的端口。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--control-plane-endpoint string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面指定一个稳定的 IP 地址或 DNS 名称。
</td>
</tr>
<tr>
<td colspan=2>--feature-gates string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
一组键值对（key=value），描述了各种特征。选项包括：<br>IPv6DualStack=true|false (ALPHA - 默认值=false)
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："k8s.gcr.io"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
选择用于拉取控制平面镜像的容器仓库
</td>
</tr>
<tr>
<td colspan=2>
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
与集群通信时使用的 kubeconfig 文件。如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan=2>
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面选择特定的 Kubernetes 版本。
</td>
</tr>
<tr>
<td colspan=2>--pod-network-cidr string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指定 Pod 网络的 IP 地址范围。如果已设置，控制平面将自动为每个节点分配 CIDR。
</td>
</tr>
<tr>
<td colspan=2>
--service-cidr string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："10.96.0.0/12"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为服务 VIP 使用 IP 地址的其他范围。
</td>
</tr>
<tr>
<td colspan=2>
--service-dns-domain string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："cluster.local"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为服务使用其他域名，例如 "myorg.internal"。
</td>
</tr>
</tbody>
</table>
<h3 id=继承于父命令的选项>继承于父命令的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div id=tab-addon-2 class=tab-pane role=tabpanel aria-labelledby=tab-addon-2>
<p><h3 id=概要>概要</h3>
<p>通过 API 服务器安装 CoreDNS 附加组件。请注意，即使 DNS 服务器已部署，在安装 CNI 之前 DNS 服务器不会被调度执行。</p>
<pre><code>kubeadm init phase addon coredns [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--feature-gates string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
一组用来描述各种功能特性的键值（key=value）对。选项是：<br>IPv6DualStack=true|false (ALPHA - 默认值=false)
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
coredns 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："k8s.gcr.io"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
选择用于拉取控制平面镜像的容器仓库
</td>
</tr>
<tr>
<td colspan=2>
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
与集群通信时使用的 kubeconfig 文件。如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan=2>
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面选择特定的 Kubernetes 版本。
</td>
</tr>
<tr>
<td colspan=2>
--service-cidr string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："10.96.0.0/12"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为服务 VIP 选择 IP 地址范围。
</td>
</tr>
<tr>
<td colspan=2>
--service-dns-domain string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："cluster.local"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
服务使用其它的域名，例如："myorg.internal"。
</td>
</tr>
</tbody>
</table>
<h3 id=继承于父命令的选项>继承于父命令的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div id=tab-addon-3 class=tab-pane role=tabpanel aria-labelledby=tab-addon-3>
<p><h3 id=概要>概要</h3>
<p>通过 API 服务器安装 kube-proxy 附加组件。</p>
<pre><code>kubeadm init phase addon kube-proxy [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
API 服务器所公布的其正在监听的 IP 地址。如果未设置，则将使用默认网络接口。
</td>
</tr>
<tr>
<td colspan=2>
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值: 6443
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
API 服务器绑定的端口。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--control-plane-endpoint string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面指定一个稳定的 IP 地址或 DNS 名称。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kube-proxy 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："k8s.gcr.io"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
选择用于拉取控制平面镜像的容器仓库
</td>
</tr>
<tr>
<td colspan=2>
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
与集群通信时使用的 kubeconfig 文件。如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan=2>
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面选择特定的 Kubernetes 版本。
</td>
</tr>
<tr>
<td colspan=2>--pod-network-cidr string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指定 Pod 网络的 IP 地址范围。如果已设置，控制平面将自动为每个节点分配 CIDR。
</td>
</tr>
</tbody>
</table>
<h3 id=继承于父命令的选项>继承于父命令的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div></div>
<p>有关 <code>v1beta3</code> 配置中每个字段的更多详细信息，可以访问
<a href=/zh/docs/reference/config-api/kubeadm-config.v1beta3/>API</a>。</p>
<h2 id=what-s-next>What's next</h2>
<ul>
<li><a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-init/>kubeadm init</a>
引导 Kubernetes 控制平面节点</li>
<li><a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-join/>kubeadm join</a>
将节点加入到集群</li>
<li><a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-reset/>kubeadm reset</a>
恢复通过 <code>kubeadm init</code> 或 <code>kubeadm join</code> 操作对主机所做的任何更改</li>
<li><a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-alpha/>kubeadm alpha</a>
尝试实验性功能</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-62a742c564b0b5b7ac12a95e67cc425a>8.1.12 - kubeadm join phase</h1>
<p><code>kubeadm join phase</code> 使你能够调用 <code>join</code> 过程的基本原子步骤。
因此，如果希望执行自定义操作，可以让 kubeadm 做一些工作，然后由用户来补足剩余操作。</p>
<p><code>kubeadm join phase</code> 与
<a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-join/#join-workflow>kubeadm join 工作流程</a>
一致，后台都使用相同的代码。</p>
<h2 id=cmd-join-phase>kubeadm join phase</h2>
<ul class="nav nav-tabs" id=tab-phase role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tab-phase-0 role=tab aria-controls=tab-phase-0 aria-selected=true>phase</a></li>
</ul>
<div class=tab-content id=tab-phase><div id=tab-phase-0 class="tab-pane show active" role=tabpanel aria-labelledby=tab-phase-0>
<p><h3 id=概要>概要</h3>
<p>使用此命令来调用 <code>join</code> 工作流程的某个阶段</p>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
phase 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令中继承的选项>从父命令中继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div></div>
<h2 id=cmd-join-phase-preflight>kubeadm join phase preflight</h2>
<p>使用此命令可以在即将加入集群的节点上执行启动前检查。</p>
<ul class="nav nav-tabs" id=tab-preflight role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tab-preflight-0 role=tab aria-controls=tab-preflight-0 aria-selected=true>preflight</a></li>
</ul>
<div class=tab-content id=tab-preflight><div id=tab-preflight-0 class="tab-pane show active" role=tabpanel aria-labelledby=tab-preflight-0>
<p><h3 id=概要>概要</h3>
<p>运行 kubeadm join 命令添加节点前检查。</p>
<pre><code>kubeadm join phase preflight [api-server-endpoint] [flags]
</code></pre>
<h3 id=示例>示例</h3>
<pre><code># 使用配置文件运行 kubeadm join 命令添加节点前检查。
kubeadm join phase preflight --config kubeadm-config.yml
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对于将要托管新的控制平面实例的节点，指定 API 服务器将公布的其正在侦听的 IP 地址。如果未设置，则使用默认网络接口。
</td>
</tr>
<tr>
<td colspan=2>
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：6443
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
针对将要托管新的控制平面实例的节点，设置 API 服务器要绑定的端口。
</td>
</tr>
<tr>
<td colspan=2>--certificate-key string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
使用此密钥可以解密由 `init` 操作上传的证书 secret。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--control-plane</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
在此节点上创建一个新的控制平面实例
</td>
</tr>
<tr>
<td colspan=2>--cri-socket string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
提供给 CRI 套接字建立连接的路径。如果为空，则 kubeadm 将尝试自动检测该值；仅当安装了多个 CRI 或具有非标准 CRI 套接字时，才使用此选项。
</td>
</tr>
<tr>
<td colspan=2>--discovery-file string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对于基于文件的发现，给出用于加载集群信息的文件或者 URL。
</td>
</tr>
<tr>
<td colspan=2>--discovery-token string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对于基于令牌的发现，该令牌用于验证从 API 服务器获取的集群信息。
</td>
</tr>
<tr>
<td colspan=2>--discovery-token-ca-cert-hash stringSlice</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对于基于令牌的发现，验证根 CA 公钥是否匹配此哈希值（格式："&lt;type>:&lt;value>"）。
</td>
</tr>
<tr>
<td colspan=2>--discovery-token-unsafe-skip-ca-verification</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对于基于令牌的发现，允许在未关联 --discovery-token-ca-cert-hash 参数的情况下添加节点。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
preflight 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>--ignore-preflight-errors stringSlice</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
错误将显示为警告的检查列表；例如：'IsPrivilegedUser,Swap'。取值为 'all' 时将忽略检查中的所有错误。
</td>
</tr>
<tr>
<td colspan=2>--node-name string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指定节点名称。
</td>
</tr>
<tr>
<td colspan=2>--tls-bootstrap-token string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指定在加入节点时用于临时通过 Kubernetes 控制平面进行身份验证的令牌。
</td>
</tr>
<tr>
<td colspan=2>--token string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果未提供这些值，则将它们用于 discovery-token 令牌和 tls-bootstrap 令牌。
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div></div>
<h2 id=cmd-join-phase-control-plane-prepare>kubeadm join phase control-plane-prepare</h2>
<p>使用此阶段，你可以准备一个作为控制平面的节点。</p>
<ul class="nav nav-tabs" id=tab-control-plane-prepare role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tab-control-plane-prepare-0 role=tab aria-controls=tab-control-plane-prepare-0 aria-selected=true>control-plane-prepare</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tab-control-plane-prepare-1 role=tab aria-controls=tab-control-plane-prepare-1>all</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tab-control-plane-prepare-2 role=tab aria-controls=tab-control-plane-prepare-2>download-certs</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tab-control-plane-prepare-3 role=tab aria-controls=tab-control-plane-prepare-3>certs</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tab-control-plane-prepare-4 role=tab aria-controls=tab-control-plane-prepare-4>kubeconfig</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tab-control-plane-prepare-5 role=tab aria-controls=tab-control-plane-prepare-5>control-plane</a></li></ul>
<div class=tab-content id=tab-control-plane-prepare><div id=tab-control-plane-prepare-0 class="tab-pane show active" role=tabpanel aria-labelledby=tab-control-plane-prepare-0>
<p><h3 id=概要>概要</h3>
<p>准备为控制平面服务的机器</p>
<pre><code>kubeadm join phase control-plane-prepare [flags]
</code></pre>
<h3 id=示例>示例</h3>
<pre><code># 准备为控制平面服务的机器
kubeadm join phase control-plane-prepare all
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
control-plane-prepare 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令中继承的选项>从父命令中继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div id=tab-control-plane-prepare-1 class=tab-pane role=tabpanel aria-labelledby=tab-control-plane-prepare-1>
<p><h3 id=概要>概要</h3>
<p>准备为控制平面服务的机器</p>
<pre><code>kubeadm join phase control-plane-prepare all [api-server-endpoint] [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果该节点托管一个新的控制平面实例，则 API 服务器将公布其正在侦听的 IP 地址。如果未设置，则使用默认网络接口。
</td>
</tr>
<tr>
<td colspan=2>
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：6443
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果该节点托管一个新的控制平面实例，则为 API 服务器要绑定的端口。
</td>
</tr>
<tr>
<td colspan=2>--certificate-key string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
使用此密钥解密由 init 上传的证书 secrets。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--control-plane</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
在此节点上创建一个新的控制平面实例
</td>
</tr>
<tr>
<td colspan=2>--discovery-file string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对于基于文件的发现，给出用于加载集群信息的文件或者 URL。
</td>
</tr>
<tr>
<td colspan=2>--discovery-token string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对于基于令牌的发现，该令牌用于验证从 API 服务器获取的集群信息。
</td>
</tr>
<tr>
<td colspan=2>--discovery-token-ca-cert-hash stringSlice</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对于基于令牌的发现，请验证根 CA 公钥是否匹配此哈希值（格式："&lt;type>:&lt;value>"）。
</td>
</tr>
<tr>
<td colspan=2>--discovery-token-unsafe-skip-ca-verification</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对于基于令牌的发现，允许在未关联 --discovery-token-ca-cert-hash 参数的情况下添加节点。
</td>
</tr>
<tr>
<td colspan=2>--experimental-patches string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
包含名为 "target[suffix][+patchtype].extension" 的文件的目录的路径。
例如，"kube-apiserver0+merge.yaml" 或仅仅是 "etcd.json"。
"patchtype" 可以是 "strategic"、"merge" 或 "json" 之一，并且它们与 kubectl 支持的补丁格式匹配。
默认的 "patchtype" 为 "strategic"。 "extension" 必须为 "json" 或 "yaml"。
"suffix" 是一个可选字符串，可用于确定首先按字母顺序应用哪些补丁。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
all 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>--node-name string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指定节点名称。
</td>
</tr>
<tr>
<td colspan=2>--tls-bootstrap-token string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指定在加入节点时用于临时通过 Kubernetes 控制平面进行身份验证的令牌。
</td>
</tr>
<tr>
<td colspan=2>--token string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果未提供这些值，则将它们用于 discovery-token 令牌和 tls-bootstrap 令牌。
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div id=tab-control-plane-prepare-2 class=tab-pane role=tabpanel aria-labelledby=tab-control-plane-prepare-2>
<p><h3 id=概要>概要</h3>
<p>[实验]从 kubeadm-certs Secret 下载控制平面节点之间共享的证书</p>
<pre><code>kubeadm join phase control-plane-prepare download-certs [api-server-endpoint] [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--certificate-key string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
使用此密钥可以解密由 init 上传的证书 secret。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--control-plane</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
在此节点上创建一个新的控制平面实例
</td>
</tr>
<tr>
<td colspan=2>--discovery-file string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对于基于文件的发现，给出用于加载集群信息的文件或者 URL。
</td>
</tr>
<tr>
<td colspan=2>--discovery-token string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对于基于令牌的发现，该令牌用于验证从 API 服务器获取的集群信息。
</td>
</tr>
<tr>
<td colspan=2>--discovery-token-ca-cert-hash stringSlice</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对于基于令牌的发现，请验证根 CA 公钥是否匹配此哈希值（格式："&lt;type>:&lt;value>"）。
</td>
</tr>
<tr>
<td colspan=2>--discovery-token-unsafe-skip-ca-verification</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对于基于令牌的发现，允许在未关联 --discovery-token-ca-cert-hash 参数的情况下添加节点。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeconfig 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>--tls-bootstrap-token string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指定在加入节点时用于临时通过 Kubernetes 控制平面进行身份验证的令牌。
</td>
</tr>
<tr>
<td colspan=2>--token string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果未提供这些值，则将它们用于 discovery-token 令牌和 tls-bootstrap 令牌。
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令中继承的选项>从父命令中继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div id=tab-control-plane-prepare-3 class=tab-pane role=tabpanel aria-labelledby=tab-control-plane-prepare-3>
<p><h3 id=概要>概要</h3>
<p>为新的控制平面组件生成证书</p>
<pre><code>kubeadm join phase control-plane-prepare certs [api-server-endpoint] [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果该节点托管一个新的控制平面实例，则 API 服务器将公布其正在侦听的 IP 地址。如果未设置，则使用默认网络接口。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--control-plane</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
在此节点上创建一个新的控制平面实例
</td>
</tr>
<tr>
<td colspan=2>--discovery-file string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对于基于文件的发现，给出用于加载集群信息的文件或者 URL。
</td>
</tr>
<tr>
<td colspan=2>--discovery-token string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对于基于令牌的发现，该令牌用于验证从 API 服务器获取的集群信息。
</td>
</tr>
<tr>
<td colspan=2>--discovery-token-ca-cert-hash stringSlice</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对于基于令牌的发现，请验证根 CA 公钥是否匹配此哈希值（格式："&lt;type>:&lt;value>"）。
</td>
</tr>
<tr>
<td colspan=2>--discovery-token-unsafe-skip-ca-verification</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对于基于令牌的发现，允许在未关联 --discovery-token-ca-cert-hash 参数的情况下添加节点。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
certs 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>--node-name string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指定节点名称。
</td>
</tr>
<tr>
<td colspan=2>--tls-bootstrap-token string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指定在加入节点时用于临时通过 Kubernetes 控制平面进行身份验证的令牌。
</td>
</tr>
<tr>
<td colspan=2>--token string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果未提供这些值，则将它们用于 discovery-token 令牌和 tls-bootstrap 令牌。
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div id=tab-control-plane-prepare-4 class=tab-pane role=tabpanel aria-labelledby=tab-control-plane-prepare-4>
<p><h3 id=概要>概要</h3>
<p>为新的控制平面组件生成 kubeconfig</p>
<pre><code>kubeadm join phase control-plane-prepare kubeconfig [api-server-endpoint] [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--certificate-key string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
使用此密钥可以解密由 init 上传的证书 secret。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--control-plane</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
在此节点上创建一个新的控制平面实例
</td>
</tr>
<tr>
<td colspan=2>--discovery-file string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对于基于文件的发现，给出用于加载集群信息的文件或者 URL。
</td>
</tr>
<tr>
<td colspan=2>--discovery-token string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对于基于令牌的发现，该令牌用于验证从 API 服务器获取的集群信息。
</td>
</tr>
<tr>
<td colspan=2>--discovery-token-ca-cert-hash stringSlice</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对于基于令牌的发现，请验证根 CA 公钥是否匹配此哈希值（格式："&lt;type>:&lt;value>"）。
</td>
</tr>
<tr>
<td colspan=2>--discovery-token-unsafe-skip-ca-verification</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对于基于令牌的发现，允许在未关联 --discovery-token-ca-cert-hash 参数的情况下添加节点。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeconfig 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>--tls-bootstrap-token string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指定在加入节点时用于临时通过 Kubernetes 控制平面进行身份验证的令牌。
</td>
</tr>
<tr>
<td colspan=2>--token string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果未提供这些值，则将它们用于 discovery-token 令牌和 tls-bootstrap 令牌。
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令中继承的选项>从父命令中继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div id=tab-control-plane-prepare-5 class=tab-pane role=tabpanel aria-labelledby=tab-control-plane-prepare-5>
<p><h3 id=概要>概要</h3>
<p>为新的控制平面组件生成清单（manifest）</p>
<pre><code>kubeadm join phase control-plane-prepare control-plane [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对于将要托管新的控制平面实例的节点，指定 API 服务器将公布的其正在侦听的 IP 地址。如果未设置，则使用默认网络接口。
</td>
</tr>
<tr>
<td colspan=2>
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：6443
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
针对将要托管新的控制平面实例的节点，设置 API 服务器要绑定的端口。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--control-plane</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
在此节点上创建一个新的控制平面实例
</td>
</tr>
<tr>
<td colspan=2>--experimental-patches string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
包含名为 "target[suffix][+patchtype].extension" 的文件的目录的路径。
例如，"kube-apiserver0+merge.yaml" 或仅仅是 "etcd.json"。
"patchtype" 可以是 "strategic"、"merge" 或 "json" 之一，并且它们与 kubectl 支持的补丁格式匹配。
默认的 "patchtype" 为 "strategic"。 "extension" 必须为 "json" 或 "yaml"。
"suffix" 是一个可选字符串，可用于确定首先按字母顺序应用哪些补丁。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
control-plane 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令中继承的选项>从父命令中继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div></div>
<h2 id=cmd-join-phase-kubelet-start>kubeadm join phase kubelet-start</h2>
<p>使用此阶段，你可以配置 kubelet 设置、证书和（重新）启动 kubelet。</p>
<ul class="nav nav-tabs" id=tab-kubelet-start role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tab-kubelet-start-0 role=tab aria-controls=tab-kubelet-start-0 aria-selected=true>kubelet-start</a></li>
</ul>
<div class=tab-content id=tab-kubelet-start><div id=tab-kubelet-start-0 class="tab-pane show active" role=tabpanel aria-labelledby=tab-kubelet-start-0>
<p><h3 id=概要>概要</h3>
<p>生成一个包含 KubeletConfiguration 的文件和一个包含特定于节点的 kubelet 配置的环境文件，然后（重新）启动 kubelet。</p>
<pre><code>kubeadm join phase kubelet-start [api-server-endpoint] [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--cri-socket string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
提供给 CRI 套接字建立连接的路径。如果为空，则 kubeadm 将尝试自动检测该值；仅当安装了多个 CRI 或具有非标准 CRI 套接字时，才使用此选项。
</td>
</tr>
<tr>
<td colspan=2>--discovery-file string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
For file-based discovery, a file or URL from which to load cluster information.
对于基于文件的发现，给出用于加载集群信息的文件或者 URL。
</td>
</tr>
<tr>
<td colspan=2>--discovery-token string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对于基于令牌的发现，该令牌用于验证从 API 服务器获取的集群信息。
</td>
</tr>
<tr>
<td colspan=2>--discovery-token-ca-cert-hash stringSlice</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对于基于令牌的发现，验证根 CA 公钥是否匹配此哈希值（格式："&lt;type>:&lt;value>"）。
</td>
</tr>
<tr>
<td colspan=2>--discovery-token-unsafe-skip-ca-verification</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对于基于令牌的发现，允许在未关联 --discovery-token-ca-cert-hash 参数的情况下添加节点。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubelet-start 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>--node-name string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指定节点名称。
</td>
</tr>
<tr>
<td colspan=2>--tls-bootstrap-token string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指定在加入节点时用于临时通过 Kubernetes 控制平面进行身份验证的令牌。
</td>
</tr>
<tr>
<td colspan=2>--token string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果未提供这些值，则将它们用于 discovery-token 令牌和 tls-bootstrap 令牌。
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div></div>
<h2 id=cmd-join-phase-control-plane-join>kubeadm join phase control-plane-join</h2>
<p>使用此阶段，你可以将节点作为控制平面实例加入。</p>
<ul class="nav nav-tabs" id=tab-control-plane-join role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tab-control-plane-join-0 role=tab aria-controls=tab-control-plane-join-0 aria-selected=true>control-plane-join</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tab-control-plane-join-1 role=tab aria-controls=tab-control-plane-join-1>all</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tab-control-plane-join-2 role=tab aria-controls=tab-control-plane-join-2>etcd</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tab-control-plane-join-3 role=tab aria-controls=tab-control-plane-join-3>update-status</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tab-control-plane-join-4 role=tab aria-controls=tab-control-plane-join-4>mark-control-plane</a></li></ul>
<div class=tab-content id=tab-control-plane-join><div id=tab-control-plane-join-0 class="tab-pane show active" role=tabpanel aria-labelledby=tab-control-plane-join-0>
<p><h3 id=概要>概要</h3>
<p>添加作为控制平面实例的机器</p>
<pre><code>kubeadm join phase control-plane-join [flags]
</code></pre>
<h3 id=示例>示例</h3>
<pre><code># 将机器作为控制平面实例加入
kubeadm join phase control-plane-join all
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
control-plane-join 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令中继承的选项>从父命令中继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div id=tab-control-plane-join-1 class=tab-pane role=tabpanel aria-labelledby=tab-control-plane-join-1>
<p><h3 id=概要>概要</h3>
<p>添加作为控制平面实例的机器</p>
<pre><code>kubeadm join phase control-plane-join all [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果该节点托管一个新的控制平面实例，则 API 服务器将公布其正在侦听的 IP 地址。如果未设置，则使用默认网络接口。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--experimental-control-plane</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
在此节点上创建一个新的控制平面实例
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
all 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>--node-name string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指定节点名称。
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div id=tab-control-plane-join-2 class=tab-pane role=tabpanel aria-labelledby=tab-control-plane-join-2>
<p><h3 id=概要>概要</h3>
<p>添加新的本地 etcd 成员</p>
<pre><code>kubeadm join phase control-plane-join etcd [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果该节点托管一个新的控制平面实例，则 API 服务器将公布其正在侦听的 IP 地址。如果未设置，则使用默认网络接口。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--control-plane</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
在此节点上创建一个新的控制平面实例
</td>
</tr>
<tr>
<td colspan=2>--experimental-patches string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
包含名为 "target[suffix][+patchtype].extension" 的文件的目录的路径。
例如，"kube-apiserver0+merge.yaml" 或仅仅是 "etcd.json"。
"patchtype" 可以是"strategic"、"merge" 或 "json" 之一，并且它们与 kubectl 支持的补丁格式匹配。
默认的 "patchtype" 为 "strategic"。 "extension" 必须为 "json" 或 "yaml"。
"suffix" 是一个可选字符串，可用于确定首先按字母顺序应用哪些补丁。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
etcd 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>--node-name string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指定节点的名称
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令中继承的选项>从父命令中继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div id=tab-control-plane-join-3 class=tab-pane role=tabpanel aria-labelledby=tab-control-plane-join-3>
<p><h2 id=概要>概要</h2>
<p>将新的控制平面节点注册到 kubeadm-config ConfigMap 维护的 ClusterStatus 中</p>
<pre><code>kubeadm join phase control-plane-join update-status [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果该节点托管一个新的控制平面实例，则 API 服务器将公布其正在侦听的 IP 地址。如果未设置，则使用默认网络接口。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--control-plane</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
在此节点上创建一个新的控制平面实例
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
update-status 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>--node-name string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指定节点名称。
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令中继承的选项>从父命令中继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div id=tab-control-plane-join-4 class=tab-pane role=tabpanel aria-labelledby=tab-control-plane-join-4>
<p><h3 id=概要>概要</h3>
<p>将 Node 节点标记为控制平面节点</p>
<pre><code>kubeadm join phase control-plane-join mark-control-plane [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--control-plane</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
在此节点上创建一个新的控制平面实例
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
mark-control-plane 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>--node-name string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指定节点的名称
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令中继承的选项>从父命令中继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div></div>
<h2 id=what-s-next>What's next</h2>
<ul>
<li><a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-init/>kubeadm init</a>
引导 Kubernetes 控制平面节点</li>
<li><a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-join/>kubeadm join</a>
将节点添加到集群</li>
<li><a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-reset/>kubeadm reset</a>
恢复通过 <code>kubeadm init</code> 或 <code>kubeadm join</code> 操作对主机所做的任何更改</li>
<li><a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-alpha/>kubeadm alpha</a>
尝试实验性功能</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-1ab2d643d770ca684548de4ddbc7d8c4>8.1.13 - kubeadm kubeconfig</h1>
<p><code>kubeadm kubeconfig</code> 提供用来管理 kubeconfig 文件的工具。</p>
<p>如果希望查看如何使用 <code>kubeadm kubeconfig user</code> 的示例，请参阅
<a href=/zh/docs/tasks/administer-cluster/kubeadm/kubeadm-certs#kubeconfig-additional-users>为其他用户生成 kubeconfig 文件</a>.</p>
<h2 id=cmd-kubeconfig>kubeadm kubeconfig</h2>
<ul class="nav nav-tabs" id=tab-kubeconfig role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tab-kubeconfig-0 role=tab aria-controls=tab-kubeconfig-0 aria-selected=true>overview</a></li>
</ul>
<div class=tab-content id=tab-kubeconfig><div id=tab-kubeconfig-0 class="tab-pane show active" role=tabpanel aria-labelledby=tab-kubeconfig-0>
<p>
<p>Kubeconfig 文件工具。</p>
<h3 id=概要>概要</h3>
<p>kubeconfig 文件工具。</p>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeconfig 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</td>
</tr>
</tbody>
</table>
</div></div>
<h2 id=cmd-kubeconfig-user>kubeadm kubeconfig user</h2>
<p>此命令可用来为其他用户生成一个 kubeconfig 文件。</p>
<ul class="nav nav-tabs" id=tab-kubeconfig-user role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tab-kubeconfig-user-0 role=tab aria-controls=tab-kubeconfig-user-0 aria-selected=true>user</a></li>
</ul>
<div class=tab-content id=tab-kubeconfig-user><div id=tab-kubeconfig-user-0 class="tab-pane show active" role=tabpanel aria-labelledby=tab-kubeconfig-user-0>
<p>
<p>为其他用户输出一个 kubeconfig 文件。</p>
<h3 id=概要>概要</h3>
<p>为其他用户输出一个 kubeconfig 文件。</p>
<pre><code>kubeadm alpha kubeconfig user [flags]
</code></pre>
<h3 id=示例>示例</h3>
<pre><code># 使用名为 bar 的 kubeadm 配置文件为名为 foo 的另一用户输出 kubeconfig 文件
kubeadm kubeconfig user --client-name=foo --config=bar
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--client-name string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
用户名。如果生成客户端证书，则用作其 CN。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指向 kubeadm 配置文件的路径
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
user 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>--org strings</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
客户端证书的组织。如果创建客户端证书，此值将用作其 O 字段值。
</td>
</tr>
<tr>
<td colspan=2>--token string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
应该用此令牌做为 kubeconfig 的身份验证机制，而不是客户端证书
</td>
</tr>
<tr>
<td colspan=2>--validity-period duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: 8760h0m0s</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
<p>
客户证书的合法期限。所设置值为相对当前时间的偏移。
</p></td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 指向 '真实' 宿主机的根目录。
</td>
</tr>
</tbody>
</table>
</div></div>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-b969d0033ce5d9036463521fb1f150b3>8.1.14 - kubeadm reset phase</h1>
<p><code>kubeadm reset phase</code> 使你能够调用 <code>reset</code> 过程的基本原子步骤。
因此，如果希望执行自定义操作，可以让 kubeadm 做一些工作，然后由用户来补足剩余操作。</p>
<p><code>kubeadm reset phase</code> 与
<a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-reset/#reset-workflow>kubeadm reset 工作流程</a>
一致，后台都使用相同的代码。</p>
<h2 id=cmd-reset-phase>kubeadm reset phase</h2>
<ul class="nav nav-tabs" id=tab-phase role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tab-phase-0 role=tab aria-controls=tab-phase-0 aria-selected=true>phase</a></li>
</ul>
<div class=tab-content id=tab-phase><div id=tab-phase-0 class="tab-pane show active" role=tabpanel aria-labelledby=tab-phase-0>
<p><h3 id=概要>概要</h3>
<p>使用此命令来调用 <code>reset</code> 工作流程的某个阶段</p>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
phase 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div></div>
<h2 id=cmd-reset-phase-preflight>kubeadm reset phase preflight</h2>
<p>使用此阶段，你可以在要重置的节点上执行启动前检查阶段。</p>
<ul class="nav nav-tabs" id=tab-preflight role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tab-preflight-0 role=tab aria-controls=tab-preflight-0 aria-selected=true>preflight</a></li>
</ul>
<div class=tab-content id=tab-preflight><div id=tab-preflight-0 class="tab-pane show active" role=tabpanel aria-labelledby=tab-preflight-0>
<p><h3 id=概要>概要</h3>
<p>kubeadm reset（重置）前运行启动前检查。</p>
<pre><code>kubeadm reset phase preflight [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>-f, --force</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
在不提示确认的情况下重置节点。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
preflight 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>--ignore-preflight-errors stringSlice</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
错误将显示为警告的检查列表；例如：'IsPrivilegedUser,Swap'。取值为 'all' 时将忽略检查中的所有错误。
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div></div>
<h2 id=cmd-reset-phase-remove-etcd-member>kubeadm reset phase remove-etcd-member</h2>
<p>使用此阶段，你可以从 etcd 集群中删除此控制平面节点的 etcd 成员。</p>
<ul class="nav nav-tabs" id=tab-remove-etcd-member role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tab-remove-etcd-member-0 role=tab aria-controls=tab-remove-etcd-member-0 aria-selected=true>remove-etcd-member</a></li>
</ul>
<div class=tab-content id=tab-remove-etcd-member><div id=tab-remove-etcd-member-0 class="tab-pane show active" role=tabpanel aria-labelledby=tab-remove-etcd-member-0>
<p><h3 id=概要>概要</h3>
<p>上传关于当前状态的配置，以便 'kubeadm upgrade' 以后可以知道如何配置升级后的集群。</p>
<pre><code>kubeadm config upload [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>upload 操作的帮助信息</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值： "/etc/kubernetes/admin.conf"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>用于和集群通信的 KubeConfig 文件。如果它没有被设置，那么 kubeadm 将会搜索一个已经存在于标准路径的 KubeConfig 文件。</td>
</tr>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>[实验] 到'真实'主机根文件系统的路径。</td>
</tr>
</tbody>
</table>
</div></div>
<h2 id=cmd-reset-phase-cleanup-node>kubeadm reset phase cleanup-node</h2>
<p>使用此阶段，你可以在此节点上执行清理工作。</p>
<ul class="nav nav-tabs" id=tab-cleanup-node role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tab-cleanup-node-0 role=tab aria-controls=tab-cleanup-node-0 aria-selected=true>cleanup-node</a></li>
</ul>
<div class=tab-content id=tab-cleanup-node><div id=tab-cleanup-node-0 class="tab-pane show active" role=tabpanel aria-labelledby=tab-cleanup-node-0>
<p><h3 id=概要>概要</h3>
<p>执行 cleanup node（清理节点）操作。</p>
<pre><code>kubeadm reset phase cleanup-node [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
存储证书的目录路径。如果已指定，则需要清空此目录。
</td>
</tr>
<tr>
<td colspan=2>--cri-socket string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
要连接的 CRI 套接字的路径。如果为空，则 kubeadm 将尝试自动检测此值；仅当安装了多个CRI 或具有非标准 CRI 插槽时，才使用此选项。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
cleanup-node 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div></div>
<h2 id=what-s-next>What's next</h2>
<ul>
<li><a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-init/>kubeadm init</a>
引导 Kubernetes 控制平面节点</li>
<li><a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-join/>kubeadm join</a>
将节点添加到集群</li>
<li><a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-reset/>kubeadm reset</a>
恢复通过 <code>kubeadm init</code> 或 <code>kubeadm join</code> 操作对主机所做的任何更改</li>
<li><a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-alpha/>kubeadm alpha</a>
尝试实验性功能</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-dfd085b5ab706bd84dda15847dd27f1b>8.1.15 - kubeadm upgrade phase</h1>
<p>在 Kubernetes v1.15.0 版本中，kubeadm 引入了对 <code>kubeadm upgrade node</code> 阶段的初步支持。其他 <code>kubeadm upgrade</code> 子命令如 <code>apply</code> 等阶段将在未来发行版中添加。</p>
<h2 id=cmd-node-phase>kubeadm upgrade node phase</h2>
<p>使用此阶段，可以选择执行辅助控制平面或工作节点升级的单独步骤。请注意，<code>kubeadm upgrade apply</code> 命令仍然必须在主控制平面节点上调用。</p>
<ul class="nav nav-tabs" id=tab-phase role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tab-phase-0 role=tab aria-controls=tab-phase-0 aria-selected=true>phase</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tab-phase-1 role=tab aria-controls=tab-phase-1>preflight</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tab-phase-2 role=tab aria-controls=tab-phase-2>control-plane</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tab-phase-3 role=tab aria-controls=tab-phase-3>kubelet-config</a></li></ul>
<div class=tab-content id=tab-phase><div id=tab-phase-0 class="tab-pane show active" role=tabpanel aria-labelledby=tab-phase-0>
<p><h3 id=概要>概要</h3>
<p>使用此命令调用 node 工作流的某个阶段</p>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
phase 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div id=tab-phase-1 class=tab-pane role=tabpanel aria-labelledby=tab-phase-1>
<p><p>执行 kubeadm 升级节点的预检。</p>
<pre><code>kubeadm upgrade node phase preflight [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>preflight 操作的帮助命令</td>
</tr>
<tr>
<td colspan=2>--ignore-preflight-errors stringSlice</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>错误将显示为警告的检查清单。示例：'IsPrivilegedUser,Swap'。值为'all'表示忽略所有检查的错误。</td>
</tr>
</tbody>
</table>
<h3 id=继承于父命令的选项>继承于父命令的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>[实验] 到'真实'主机根文件系统的路径。</td>
</tr>
</tbody>
</table>
</div>
<div id=tab-phase-2 class=tab-pane role=tabpanel aria-labelledby=tab-phase-2>
<p><h3 id=概要>概要</h3>
<p>升级部署在此节点上的控制平面实例，如果有的话</p>
<pre><code>kubeadm upgrade node phase control-plane [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--certificate-renewal</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>更新在升级期间变更的组件使用的证书。</td>
</tr>
<tr>
<td colspan=2>--dry-run</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>不改变任何状态，只输出将要执行的动作。</td>
</tr>
<tr>
<td colspan=2>--etcd-upgrade&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值: true</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>执行 etcd 的升级。</td>
</tr>
<tr>
<td colspan=2>--experimental-patches string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
包含名为 "target[suffix][+patchtype].extension" 的文件的目录的路径。
例如，"kube-apiserver0+merge.yaml" 或仅仅是 "etcd.json"。
"patchtype" 可以是 "strategic"、"merge" 或 "json" 之一，并且它们与 kubectl 支持的补丁格式匹配。
默认的 "patchtype" 为 "strategic"。 "extension" 必须为 "json" 或 "yaml"。
"suffix" 是一个可选字符串，可用于确定首先按字母顺序应用哪些补丁。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>control-plane 的帮助信息</td>
</tr>
<tr>
<td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值: "/etc/kubernetes/admin.conf"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>用于和集群通信的 KubeConfig 文件。如果它没有被设置，那么 kubeadm 将会搜索一个已经存在于标准路径的 KubeConfig 文件。</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>[实验] 到'真实'主机根文件系统的路径。</td>
</tr>
</tbody>
</table>
</div>
<div id=tab-phase-3 class=tab-pane role=tabpanel aria-labelledby=tab-phase-3>
<p><p>从群集中 "kubelet-config-1.X" 的 ConfigMap 下载 kubelet 配置，其中 X 是kubelet 的次要版本。
kubeadm 使用 --kubelet-version 参数来确定所需的 kubelet 版本。</p>
<pre><code>kubeadm upgrade node phase kubelet-config [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--dry-run</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>不改变任何状态，只输出将要执行的操作</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>配置操作的帮助信息</td>
</tr>
<tr>
<td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值： "/etc/kubernetes/kubelet.conf"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>用于和集群通信的 KubeConfig 文件。如果它没有被设置，那么 kubeadm 将会搜索一个已经存在于标准路径的 KubeConfig 文件。</td>
</tr>
<tr>
<td colspan=2>--kubelet-version string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>升级后的 kubelet 的*期望*版本。</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>[实验] 到'真实'主机根文件系统的路径。</td>
</tr>
</tbody>
</table>
</div></div>
<h2 id=what-s-next>What's next</h2>
<ul>
<li><a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-init/>kubeadm init</a> 引导一个 Kubernetes 控制平面节点</li>
<li><a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-join/>kubeadm join</a> 将节点加入到集群</li>
<li><a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-reset/>kubeadm reset</a> 还原 <code>kubeadm init</code> 或 <code>kubeadm join</code> 命令对主机所做的任何更改</li>
<li><a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-upgrade/>kubeadm upgrade</a> 升级 kubeadm 节点</li>
<li><a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-alpha/>kubeadm alpha</a> 尝试实验性功能</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-455b6412a275b743ee8ad90f35808393>8.1.16 - 实现细节</h1>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.10 [stable]</code>
</div>
<p><code>kubeadm init</code> 和 <code>kubeadm join</code> 结合在一起提供了良好的用户体验，因为从头开始创建实践最佳而配置最基本的 Kubernetes 集群。
但是，kubeadm <em>如何</em> 做到这一点可能并不明显。</p>
<p>本文档提供了更多幕后的详细信息，旨在分享有关 Kubernetes 集群最佳实践的知识。</p>
<h2 id=core-design-principles>核心设计原则 </h2>
<p><code>kubeadm init</code> 和 <code>kubeadm join</code> 设置的集群该是：</p>
<ul>
<li><strong>安全的</strong>：它应采用最新的最佳实践，例如：
<ul>
<li>实施 RBAC 访问控制</li>
<li>使用节点鉴权机制（Node Authorizer）</li>
<li>在控制平面组件之间使用安全通信</li>
<li>在 API 服务器和 kubelet 之间使用安全通信</li>
<li>锁定 kubelet API</li>
<li>锁定对系统组件（例如 kube-proxy 和 CoreDNS）的 API 的访问</li>
<li>锁定启动引导令牌（Bootstrap Token）可以访问的内容</li>
</ul>
</li>
<li><strong>用户友好</strong>：用户只需要运行几个命令即可：
<ul>
<li><code>kubeadm init</code></li>
<li><code>export KUBECONFIG=/etc/kubernetes/admin.conf</code></li>
<li><code>kubectl apply -f &lt;所选网络.yaml></code></li>
<li><code>kubeadm join --token &lt;令牌> &lt;端点>:&lt;端口></code></li>
</ul>
</li>
<li><strong>可扩展的</strong>：
<ul>
<li><em>不</em> 应偏向任何特定的网络提供商。不涉及配置集群网络</li>
<li>应该可以使用配置文件来自定义各种参数</li>
</ul>
</li>
</ul>
<h2 id=constants-and-well-known-values-and-paths>常量以及众所周知的值和路径 </h2>
<p>为了降低复杂性并简化基于 kubeadm 的高级工具的开发，对于众所周知的路径和文件名，
kubeadm 使用了一组有限的常量值。</p>
<p>Kubernetes 目录 <code>/etc/kubernetes</code> 在应用程序中是一个常量，因为在大多数情况下
它显然是给定的路径，并且是最直观的位置；其他路径常量和文件名有：</p>
<ul>
<li><code>/etc/kubernetes/manifests</code> 作为 kubelet 查找静态 Pod 清单的路径。静态 Pod 清单的名称为：
<ul>
<li><code>etcd.yaml</code></li>
<li><code>kube-apiserver.yaml</code></li>
<li><code>kube-controller-manager.yaml</code></li>
<li><code>kube-scheduler.yaml</code></li>
</ul>
</li>
<li><code>/etc/kubernetes/</code> 作为带有控制平面组件身份标识的 kubeconfig 文件的路径。kubeconfig 文件的名称为：
<ul>
<li><code>kubelet.conf</code> (在 TLS 引导时名称为 <code>bootstrap-kubelet.conf</code> )</li>
<li><code>controller-manager.conf</code></li>
<li><code>scheduler.conf</code></li>
<li><code>admin.conf</code> 用于集群管理员和 kubeadm 本身</li>
</ul>
</li>
<li>证书和密钥文件的名称：
<ul>
<li><code>ca.crt</code>, <code>ca.key</code> 用于 Kubernetes 证书颁发机构</li>
<li><code>apiserver.crt</code>, <code>apiserver.key</code> 用于 API 服务器证书</li>
<li><code>apiserver-kubelet-client.crt</code>, <code>apiserver-kubelet-client.key</code>
用于 API 服务器安全地连接到 kubelet 的客户端证书</li>
<li><code>sa.pub</code>, <code>sa.key</code> 用于控制器管理器签署 ServiceAccount 时使用的密钥</li>
<li><code>front-proxy-ca.crt</code>, <code>front-proxy-ca.key</code> 用于前端代理证书颁发机构</li>
<li><code>front-proxy-client.crt</code>, <code>front-proxy-client.key</code> 用于前端代理客户端</li>
</ul>
</li>
</ul>
<h2 id=kubeadm-init-workflow-internal-design>kubeadm init 工作流程内部设计 </h2>
<p><code>kubeadm init</code> <a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-init/#init-workflow>内部工作流程</a>
包含一系列要执行的原子性工作任务，如 <code>kubeadm init</code> 中所述。</p>
<p><a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-init-phase/><code>kubeadm init phase</code></a>
命令允许用户分别调用每个任务，并最终提供可重用且可组合的 API 或工具箱，
其他 Kubernetes 引导工具、任何 IT 自动化工具和高级用户都可以使用它来
创建自定义集群。</p>
<h3 id=preflight-checks>预检 </h3>
<p>Kubeadm 在启动 init 之前执行一组预检，目的是验证先决条件并避免常见的集群启动问题。
用户可以使用 <code>--ignore-preflight-errors</code> 选项跳过特定的预检查或全部检查。</p>
<ul>
<li>[警告] 如果要使用的 Kubernetes 版本（由 <code>--kubernetes-version</code> 标志指定）比 kubeadm CLI
版本至少高一个小版本。</li>
<li>Kubernetes 系统要求：
<ul>
<li>如果在 linux上运行：
<ul>
<li>[错误] 如果内核早于最低要求的版本</li>
<li>[错误] 如果未设置所需的 cgroups 子系统</li>
</ul>
</li>
<li>如果使用 docker：
<ul>
<li>[警告/错误] 如果 Docker 服务不存在、被禁用或未激活。</li>
<li>[错误] 如果 Docker 端点不存在或不起作用</li>
<li>[警告] 如果 docker 版本不在经过验证的 docker 版本列表中</li>
</ul>
</li>
<li>如果使用其他 cri 引擎：
<ul>
<li>[错误] 如果 crictl 套接字未应答</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>[错误] 如果用户不是 root 用户</li>
<li>[错误] 如果机器主机名不是有效的 DNS 子域</li>
<li>[警告] 如果通过网络查找无法访问主机名</li>
<li>[错误] 如果 kubelet 版本低于 kubeadm 支持的最低 kubelet 版本（当前小版本 -1）</li>
<li>[错误] 如果 kubelet 版本比所需的控制平面板版本至少高一个小（不支持的版本偏斜）</li>
<li>[警告] 如果 kubelet 服务不存在或已被禁用</li>
<li>[警告] 如果 firewalld 处于活动状态</li>
<li>[错误] 如果 API ​​服务器绑定的端口或 10250/10251/10252 端口已被占用</li>
<li>[错误] 如果 <code>/etc/kubernetes/manifest</code> 文件夹已经存在并且不为空</li>
<li>[错误] 如果 <code>/proc/sys/net/bridge/bridge-nf-call-iptables</code> 文件不存在或不包含 1</li>
<li>[错误] 如果建议地址是 ipv6，并且 <code>/proc/sys/net/bridge/bridge-nf-call-ip6tables</code> 不存在或不包含 1</li>
<li>[错误] 如果启用了交换分区</li>
<li>[错误] 如果命令路径中没有 <code>conntrack</code>、<code>ip</code>、<code>iptables</code>、<code>mount</code>、<code>nsenter</code> 命令</li>
<li>[警告] 如果命令路径中没有 <code>ebtables</code>、<code>ethtool</code>、<code>socat</code>、<code>tc</code>、<code>touch</code>、<code>crictl</code> 命令</li>
<li>[警告] 如果 API 服务器、控制器管理器、调度程序的其他参数标志包含一些无效选项</li>
<li>[警告] 如果与 https://API.AdvertiseAddress:API.BindPort 的连接通过代理</li>
<li>[警告] 如果服务子网的连接通过代理（仅检查第一个地址）</li>
<li>[警告] 如果 Pod 子网的连接通过代理（仅检查第一个地址）</li>
</ul>
<ul>
<li>如果提供了外部 etcd：
<ul>
<li>[错误] 如果 etcd 版本低于最低要求版本</li>
<li>[错误] 如果指定了 etcd 证书或密钥，但无法找到</li>
</ul>
</li>
<li>如果未提供外部 etcd（因此将安装本地 etcd）：
<ul>
<li>[错误] 如果端口 2379 已被占用</li>
<li>[错误] 如果 Etcd.DataDir 文件夹已经存在并且不为空</li>
</ul>
</li>
<li>如果授权模式为 ABAC：
<ul>
<li>[错误] 如果 abac_policy.json 不存在</li>
</ul>
</li>
<li>如果授权方式为 Webhook
<ul>
<li>[错误] 如果 webhook_authz.conf 不存在</li>
</ul>
</li>
</ul>
<p>请注意：</p>
<ol>
<li>可以使用 <a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-init-phase/#cmd-phase-preflight><code>kubeadm init phase preflight</code></a>
命令单独触发预检。</li>
</ol>
<h3 id=generate-the-necessary-certificate>生成必要的证书 </h3>
<p>Kubeadm 生成用于不同目的的证书和私钥对：</p>
<ul>
<li>
<p>Kubernetes 集群的自签名证书颁发机构会保存到 <code>ca.crt</code> 文件和 <code>ca.key</code> 私钥文件中</p>
</li>
<li>
<p>用于 API 服务器的服务证书，使用 <code>ca.crt</code> 作为 CA 生成，并将证书保存到 <code>apiserver.crt</code>
文件中，私钥保存到 <code>apiserver.key</code> 文件中
该证书应包含以下备用名称：</p>
<ul>
<li>Kubernetes 服务的内部 clusterIP（服务 CIDR 的第一个地址。
例如：如果服务的子网是 <code>10.96.0.0/12</code>，则为 <code>10.96.0.1</code>）</li>
<li>Kubernetes DNS 名称，例如：如果 <code>--service-dns-domain</code> 标志值是 <code>cluster.local</code>，
则为 <code>kubernetes.default.svc.cluster.local</code>；
加上默认的 DNS 名称 <code>kubernetes.default.svc</code>、<code>kubernetes.default</code> 和 <code>kubernetes</code>，</li>
<li>节点名称</li>
<li><code>--apiserver-advertise-address</code></li>
<li>用户指定的其他备用名称</li>
</ul>
</li>
<li>
<p>用于 API 服务器安全连接到 kubelet 的客户端证书，使用 <code>ca.crt</code> 作为 CA 生成，
并保存到 <code>apiserver-kubelet-client.crt</code>，私钥保存到 <code>apiserver-kubelet-client.key</code>
文件中。该证书应该在 <code>system:masters</code> 组织中。</p>
</li>
<li>
<p>用于签名 ServiceAccount 令牌的私钥保存到 <code>sa.key</code> 文件中，公钥保存到 <code>sa.pub</code> 文件中</p>
</li>
<li>
<p>用于前端代理的证书颁发机构保存到 <code>front-proxy-ca.crt</code> 文件中，私钥保存到
<code>front-proxy-ca.key</code> 文件中</p>
</li>
<li>
<p>前端代理客户端的客户端证书，使用 <code>front-proxy-ca.crt</code> 作为 CA 生成，并保存到
<code>front-proxy-client.crt</code> 文件中，私钥保存到 <code>front-proxy-client.key</code> 文件中</p>
</li>
</ul>
<p>证书默认情况下存储在 <code>/etc/kubernetes/pki</code> 中，但是该目录可以使用 <code>--cert-dir</code> 标志进行配置。</p>
<p>请注意：</p>
<ol>
<li>如果证书和私钥对都存在，并且其内容经过评估符合上述规范，将使用现有文件，
并且跳过给定证书的生成阶段。
这意味着用户可以将现有的 CA 复制到 <code>/etc/kubernetes/pki/ca.{crt,key}</code>，
kubeadm 将使用这些文件对其余证书进行签名。
请参阅<a href=/zh/docs/tasks/administer-cluster/kubeadm/kubeadm-certs#custom-certificates>使用自定义证书</a>。</li>
<li>仅对 CA 来说，如果所有其他证书和 kubeconfig 文件都已就位，则可以只提供 <code>ca.crt</code> 文件，
而不提供 <code>ca.key</code> 文件。
kubeadm 能够识别出这种情况并启用 ExternalCA，这也意味着了控制器管理器中的
<code>csrsigner</code> 控制器将不会启动</li>
<li>如果 kubeadm 在
<a href=/zh/docs/tasks/administer-cluster/kubeadm/kubeadm-certs#external-ca-mode>外部 CA 模式</a>
下运行，所有证书必须由用户提供，因为 kubeadm 无法自行生成它们。</li>
<li>如果在 <code>--dry-run</code> 模式下执行 kubeadm，证书文件将写入一个临时文件夹中</li>
<li>可以使用 <a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-init-phase/#cmd-phase-certs><code>kubeadm init phase certs all</code></a>
命令单独生成证书。</li>
</ol>
<h3 id=generate-kubeconfig-files-for-control-plane-components>为控制平面组件生成 kubeconfig 文件 </h3>
<p>Kubeadm 生成具有用于控制平面组件身份标识的 kubeconfig 文件：</p>
<ul>
<li>
<p>供 kubelet 在 TLS 引导期间使用的 kubeconfig 文件 —— <code>/etc/kubernetes/bootstrap-kubelet.conf</code>。
在此文件中，有一个引导令牌或内嵌的客户端证书，向集群表明此节点身份。
此客户端证书应：</p>
<ul>
<li>根据<a href=/zh/docs/reference/access-authn-authz/node/>节点鉴权</a>模块的要求，属于 <code>system:nodes</code> 组织</li>
<li>具有通用名称（CN）：<code>system:node:&lt;小写主机名></code></li>
</ul>
</li>
<li>
<p>控制器管理器的 kubeconfig 文件 —— <code>/etc/kubernetes/controller-manager.conf</code>；
在此文件中嵌入了一个具有控制器管理器身份标识的客户端证书。
此客户端证书应具有 CN：<code>system:kube-controller-manager</code>，
该 CN 由 <a href=/zh/docs/reference/access-authn-authz/rbac/#core-component-roles>RBAC 核心组件角色</a>
默认定义的。</p>
</li>
<li>
<p>调度器的 kubeconfig 文件 —— <code>/etc/kubernetes/scheduler.conf</code>；
此文件中嵌入了具有调度器身份标识的客户端证书。此客户端证书应具有 CN：<code>system:kube-scheduler</code>，
该 CN 由 <a href=/zh/docs/reference/access-authn-authz/rbac/#core-component-roles>RBAC 核心组件角色</a>
默认定义的。</p>
</li>
</ul>
<p>另外，用于 kubeadm 本身和 admin 的 kubeconfig 文件也被生成并保存到
<code>/etc/kubernetes/admin.conf</code> 文件中。
此处的 admin 定义为正在管理集群并希望完全控制集群（<strong>root</strong>）的实际人员。
内嵌的 admin 客户端证书应是 <code>system:masters</code> 组织的成员，
这一组织名由默认的 <a href=/zh/docs/reference/access-authn-authz/rbac/#user-facing-roles>RBAC 面向用户的角色绑定</a>
定义。它还应包括一个 CN。kubeadm 使用 <code>kubernetes-admin</code> CN。</p>
<p>请注意：</p>
<ol>
<li><code>ca.crt</code> 证书内嵌在所有 kubeconfig 文件中。</li>
<li>如果给定的 kubeconfig 文件存在且其内容经过评估符合上述规范，则 kubeadm 将使用现有文件，
并跳过给定 kubeconfig 的生成阶段</li>
<li>如果 kubeadm 以 <a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-init/#external-ca-mode>ExternalCA 模式</a>
运行，则所有必需的 kubeconfig 也必须由用户提供，因为 kubeadm 不能自己生成</li>
<li>如果在 <code>--dry-run</code> 模式下执行 kubeadm，则 kubeconfig 文件将写入一个临时文件夹中</li>
<li>可以使用
<a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-init-phase/#cmd-phase-kubeconfig><code>kubeadm init phase kubeconfig all</code></a>
命令分别生成 kubeconfig 文件。</li>
</ol>
<h3 id=generate-static-pod-manifests-for-control-plane-components>为控制平面组件生成静态 Pod 清单 </h3>
<p>Kubeadm 将用于控制平面组件的静态 Pod 清单文件写入 <code>/etc/kubernetes/manifests</code> 目录。
Kubelet 启动后会监视这个目录以便创建 Pod。</p>
<p>静态 Pod 清单有一些共同的属性：</p>
<ul>
<li>
<p>所有静态 Pod 都部署在 <code>kube-system</code> 名字空间</p>
</li>
<li>
<p>所有静态 Pod 都打上 <code>tier:ontrol-plane</code> 和 <code>component:{组件名称}</code> 标签</p>
</li>
<li>
<p>所有静态 Pod 均使用 <code>system-node-critical</code> 优先级</p>
</li>
<li>
<p>所有静态 Pod 都设置了 <code>hostNetwork:true</code>，使得控制平面在配置网络之前启动；结果导致：</p>
<ul>
<li>控制器管理器和调度器用来调用 API 服务器的地址为 127.0.0.1。</li>
<li>如果使用本地 etcd 服务器，则 <code>etcd-servers</code> 地址将设置为 <code>127.0.0.1:2379</code></li>
</ul>
</li>
<li>
<p>同时为控制器管理器和调度器启用了领导者选举</p>
</li>
<li>
<p>控制器管理器和调度器将引用 kubeconfig 文件及其各自的唯一标识</p>
</li>
<li>
<p>如<a href=/zh/docs/setup/production-environment/tools/kubeadm/control-plane-flags/>将自定义参数传递给控制平面组件</a>
中所述，所有静态 Pod 都会获得用户指定的额外标志</p>
</li>
<li>
<p>所有静态 Pod 都会获得用户指定的额外卷（主机路径）</p>
</li>
</ul>
<p>请注意：</p>
<ol>
<li>所有镜像默认从 k8s.gcr.io 拉取。
关于自定义镜像仓库，请参阅
<a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-init/#custom-images>使用自定义镜像</a>。</li>
<li>如果在 <code>--dry-run</code> 模式下执行 kubeadm，则静态 Pod 文件写入一个临时文件夹中。</li>
<li>可以使用 <a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-init-phase/#cmd-phase-control-plane><code>kubeadm init phase control-plane all</code></a>
命令分别生成主控组件的静态 Pod 清单。</li>
</ol>
<h4 id=api-server>API 服务器 </h4>
<p>API 服务器的静态 Pod 清单会受到用户提供的以下参数的影响:</p>
<ul>
<li>要绑定的 <code>apiserver-advertise-address</code> 和 <code>apiserver-bind-port</code>；
如果未提供，则这些值默认为机器上默认网络接口的 IP 地址和 6443 端口。</li>
<li><code>service-cluster-ip-range</code> 给 service 使用</li>
<li>如果指定了外部 etcd 服务器，则应指定 <code>etcd-servers</code> 地址和相关的 TLS 设置
（<code>etcd-cafile</code>，<code>etcd-certfile</code>，<code>etcd-keyfile</code>）；
如果未提供外部 etcd 服务器，则将使用本地 etcd（通过主机网络）</li>
<li>如果指定了云提供商，则配置相应的 <code>--cloud-provider</code>，如果该路径存在，则配置 <code>--cloud-config</code>
（这是实验性的，是 Alpha 版本，将在以后的版本中删除）</li>
</ul>
<p>无条件设置的其他 API 服务器标志有：</p>
<ul>
<li><code>--insecure-port=0</code> 禁止到 API 服务器不安全的连接</li>
<li><code>--enable-bootstrap-token-auth=true</code> 启用 <code>BootstrapTokenAuthenticator</code> 身份验证模块。
更多细节请参见 <a href=/zh/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/>TLS 引导</a>。</li>
<li><code>--allow-privileged</code> 设为 <code>true</code>（诸如 kube-proxy 这些组件有此要求）</li>
<li><code>--requestheader-client-ca-file</code> 设为 <code>front-proxy-ca.crt</code></li>
</ul>
<ul>
<li><code>--enable-admission-plugins</code> 设为：
<ul>
<li><a href=/zh/docs/reference/access-authn-authz/admission-controllers/#namespacelifecycle><code>NamespaceLifecycle</code></a>
例如，避免删除系统保留的名字空间</li>
<li><a href=/zh/docs/reference/access-authn-authz/admission-controllers/#limitranger><code>LimitRanger</code></a> 和
<a href=/zh/docs/reference/access-authn-authz/admission-controllers/#resourcequota><code>ResourceQuota</code></a>
对名字空间实施限制</li>
<li><a href=/zh/docs/reference/access-authn-authz/admission-controllers/#serviceaccount><code>ServiceAccount</code></a>
实施服务账户自动化</li>
<li><a href=/zh/docs/reference/access-authn-authz/admission-controllers/#persistentvolumelabel><code>PersistentVolumeLabel</code></a>
将区域（Region）或区（Zone）标签附加到由云提供商定义的 PersistentVolumes
（此准入控制器已被弃用并将在以后的版本中删除）。
如果未明确选择使用 <code>gce</code> 或 <code>aws</code> 作为云提供商，则默认情况下，v1.9 以后的版本 kubeadm 都不会部署。</li>
<li><a href=/zh/docs/reference/access-authn-authz/admission-controllers/#defaultstorageclass><code>DefaultStorageClass</code></a>
在 <code>PersistentVolumeClaim</code> 对象上强制使用默认存储类型</li>
<li><a href=/zh/docs/reference/access-authn-authz/admission-controllers/#defaulttolerationseconds><code>DefaultTolerationSeconds</code></a></li>
<li><a href=/zh/docs/reference/access-authn-authz/admission-controllers/#noderestriction><code>NodeRestriction</code></a>
限制 kubelet 可以修改的内容（例如，仅此节点上的 pod）</li>
</ul>
</li>
</ul>
<ul>
<li>
<p><code>--kubelet-preferred-address-types</code> 设为 <code>InternalIP,ExternalIP,Hostname;</code>
这使得在节点的主机名无法解析的环境中，<code>kubectl log</code> 和 API 服务器与 kubelet
的其他通信可以工作</p>
</li>
<li>
<p>使用在前面步骤中生成的证书的标志：</p>
<ul>
<li><code>--client-ca-file</code> 设为 <code>ca.crt</code></li>
<li><code>--tls-cert-file</code> 设为 <code>apiserver.crt</code></li>
<li><code>--tls-private-key-file</code> 设为 <code>apiserver.key</code></li>
<li><code>--kubelet-client-certificate</code> 设为 <code>apiserver-kubelet-client.crt</code></li>
<li><code>--kubelet-client-key</code> 设为 <code>apiserver-kubelet-client.key</code></li>
<li><code>--service-account-key-file</code> 设为 <code>sa.pub</code></li>
<li><code>--requestheader-client-ca-file</code> 设为 <code>front-proxy-ca.crt</code></li>
<li><code>--proxy-client-cert-file</code> 设为 <code>front-proxy-client.crt</code></li>
<li><code>--proxy-client-key-file</code> 设为 <code>front-proxy-client.key</code></li>
</ul>
</li>
<li>
<p>其他用于保护前端代理（
<a href=/zh/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/>API 聚合层</a>）
通信的标志:</p>
<ul>
<li><code>--requestheader-username-headers=X-Remote-User</code></li>
<li><code>--requestheader-group-headers=X-Remote-Group</code></li>
<li><code>--requestheader-extra-headers-prefix=X-Remote-Extra-</code></li>
<li><code>--requestheader-allowed-names=front-proxy-client</code></li>
</ul>
</li>
</ul>
<h4 id=controller-manager>控制器管理器 </h4>
<p>控制器管理器的静态 Pod 清单受用户提供的以下参数的影响:</p>
<ul>
<li>如果调用 kubeadm 时指定了 <code>--pod-network-cidr</code> 参数，则可以通过以下方式启用
某些 CNI 网络插件所需的子网管理器功能：
<ul>
<li>设置 <code>--allocate-node-cidrs=true</code></li>
<li>根据给定 CIDR 设置 <code>--cluster-cidr</code> 和 <code>--node-cidr-mask-size</code> 标志</li>
</ul>
</li>
<li>如果指定了云提供商，则指定相应的 <code>--cloud-provider</code>，如果存在这样的配置文件，
则指定 <code>--cloud-config</code> 路径（此为试验性功能，是 Alpha 版本，将在以后的版本中删除）。</li>
</ul>
<p>其他无条件设置的标志包括：</p>
<ul>
<li>
<p><code>--controllers</code> 为 TLS 引导程序启用所有默认控制器以及 <code>BootstrapSigner</code> 和
<code>TokenCleaner</code> 控制器。详细信息请参阅
<a href=/zh/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/>TLS 引导</a></p>
</li>
<li>
<p><code>--use-service-account-credentials</code> 设为 <code>true</code></p>
</li>
<li>
<p>使用先前步骤中生成的证书的标志：</p>
<p>-<code>--root-ca-file</code> 设为 <code>ca.crt</code></p>
<ul>
<li>如果禁用了 External CA 模式，则 <code>--cluster-signing-cert-file</code> 设为 <code>ca.crt</code>，否则设为 <code>""</code></li>
<li>如果禁用了 External CA 模式，则 <code>--cluster-signing-key-file</code> 设为 <code>ca.key</code>，否则设为 <code>""</code></li>
<li><code>--service-account-private-key-file</code> 设为 <code>sa.key</code></li>
</ul>
</li>
</ul>
<h4 id=scheduler>调度器 </h4>
<p>调度器的静态 Pod 清单不受用户提供的参数的影响。</p>
<h3 id=generate-static-pod-manifest-for-local-etcd>为本地 etcd 生成静态 Pod 清单 </h3>
<p>如果用户指定了外部 etcd，则将跳过此步骤，否则 kubeadm 会生成静态 Pod 清单文件，
以创建在 Pod 中运行的具有以下属性的本地 etcd 实例：</p>
<ul>
<li>在 <code>localhost:2379</code> 上监听并使用 <code>HostNetwork=true</code></li>
<li>将 <code>hostPath</code> 从 <code>dataDir</code> 挂载到主机的文件系统</li>
<li>用户指定的任何其他标志</li>
</ul>
<p>请注意：</p>
<ol>
<li>etcd 镜像默认从 <code>k8s.gcr.io</code> 拉取。有关自定义镜像仓库，请参阅
<a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-init/#custom-images>使用自定义镜像</a>。</li>
<li>如果 kubeadm 以 <code>--dry-run</code> 模式执行，etcd 静态 Pod 清单将写入一个临时文件夹。</li>
<li>可以使用
<a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-init-phase/#cmd-phase-etcd>'kubeadm init phase etcd local'</a>
命令单独为本地 etcd 生成静态 Pod 清单</li>
</ol>
<h3 id=wait-for-the-control-plane-to-come-up>等待控制平面启动 </h3>
<p>kubeadm 等待（最多 4m0s），直到 <code>localhost:6443/healthz</code>（kube-apiserver 存活）返回 <code>ok</code>。
但是为了检测死锁条件，如果 <code>localhost:10255/healthz</code>（kubelet 存活）或
<code>localhost:10255/healthz/syncloop</code>（kubelet 就绪）未能在 40s 和 60s 内未返回 <code>ok</code>，
则 kubeadm 会快速失败。</p>
<p>kubeadm 依靠 kubelet 拉取控制平面镜像并将其作为静态 Pod 正确运行。
控制平面启动后，kubeadm 将完成以下段落中描述的任务。</p>
<h3 id=save-the-kubeadm-clusterConfiguration-in-a-configMap-for-later-reference>将 kubeadm ClusterConfiguration 保存在 ConfigMap 中以供以后参考 </h3>
<p>kubeadm 将传递给 <code>kubeadm init</code> 的配置保存在 <code>kube-system</code> 名字空间下名为
<code>kubeadm-config</code> 的 ConfigMap 中。</p>
<p>这将确保将来执行的 kubeadm 操作（例如 <code>kubeadm upgrade</code>）将能够确定实际/当前集群状态，
并根据该数据做出新的决策。</p>
<p>请注意：</p>
<ol>
<li>在保存 ClusterConfiguration 之前，从配置中删除令牌等敏感信息。</li>
<li>可以使用
<a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-init-phase/#cmd-phase-upload-config><code>kubeadm init phase upload-config</code></a>
命令单独上传主控节点配置。</li>
</ol>
<h3 id=mark-the-node-as-control-plane>将节点标记为控制平面 </h3>
<p>一旦控制平面可用，kubeadm 将执行以下操作：</p>
<ul>
<li>给节点打上 <code>node-role.kubernetes.io/master=""</code> 标签，标记其为控制平面</li>
<li>给节点打上 <code>node-role.kubernetes.io/master:NoSchedule</code> 污点</li>
</ul>
<p>请注意：</p>
<ol>
<li>可以使用 <a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-init-phase/#cmd-phase-mark-control-plane><code>kubeadm init phase mark-control-plane</code></a>
命令单独触发控制平面标记</li>
</ol>
<h3 id=configure-tls-bootstrapping-for-node-joining>为即将加入的节点加入 TLS 启动引导 </h3>
<p>Kubeadm 使用<a href=/zh/docs/reference/access-authn-authz/bootstrap-tokens/>引导令牌认证</a>
将新节点连接到现有集群；
更多的详细信息，请参见
<a href=https://github.com/kubernetes/community/blob/master/contributors/design-proposals/cluster-lifecycle/bootstrap-discovery.md>设计提案</a>。</p>
<p><code>kubeadm init</code> 确保为该过程正确配置了所有内容，这包括以下步骤以及设置 API 服务器
和控制器标志，如前几段所述。</p>
<p>请注意：</p>
<ol>
<li>可以使用
<a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-init-phase/#cmd-phase-bootstrap-token><code>kubeadm init phase bootstrap-token</code></a>
命令配置节点的 TLS 引导，执行以下段落中描述的所有配置步骤；
或者每个步骤都单独触发。</li>
</ol>
<h4 id=create-a-bootstrap-token>创建引导令牌 </h4>
<p><code>kubeadm init</code> 创建第一个引导令牌，该令牌是自动生成的或由用户提供的 <code>--token</code>
标志的值；如引导令牌规范中记录的那样，
令牌应保存在 <code>kube-system</code> 名字空间下名为 <code>bootstrap-token-&lt;令牌-id></code>
的 Secret 中。</p>
<p>请注意：</p>
<ol>
<li>由 <code>kubeadm init</code> 创建的默认令牌将用于在 TLS 引导过程中验证临时用户；
这些用户会成为 <code>system:bootstrappers:kubeadm:default-node-token</code> 组的成员。</li>
<li>令牌的有效期有限，默认为 24 小时（间隔可以通过 <code>-token-ttl</code> 标志进行更改）</li>
<li>可以使用 <a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-token/><code>kubeadm token</code></a>
命令创建其他令牌，这些令牌还提供其他有用的令牌管理功能</li>
</ol>
<h4 id=allow-joining-nodes-to-call-csr-api>允许加入的节点调用 CSR API </h4>
<p>Kubeadm 确保 <code>system:bootstrappers:kubeadm:default-node-token</code> 组中的用户
能够访问证书签名 API。</p>
<p>这是通过在上述组与默认 RBAC 角色 <code>system:node-bootstrapper</code> 之间创建名为
<code>kubeadm:kubelet-bootstrap</code> 的 ClusterRoleBinding 来实现的。</p>
<h4 id=setup-auto-approval-for-new-bootstrap-tokens>为新的引导令牌设置自动批准 </h4>
<p>Kubeadm 确保 csrapprover 控制器自动批准引导令牌的 CSR 请求。</p>
<p>这是通过在 <code>system:bootstrappers:kubeadm:default-node-token</code> 用户组和
<code>system:certificates.k8s.io:certificatesigningrequests:nodeclient</code> 默认角色之间
创建名为 <code>kubeadm:node-autoapprove-bootstrap</code> 的 ClusterRoleBinding 来实现的。</p>
<p>还应创建 <code>system:certificates.k8s.io:certificatesigningrequests:nodeclient</code> 角色，
授予对 <code>/apis/certificates.k8s.io/certificatesigningrequests/nodeclient</code>
执行 POST 的权限。</p>
<h4 id=setup-nodes-certificate-rotation-with-auto-approval>通过自动批准设置节点证书轮换</h4>
<p>Kubeadm 确保节点启用了证书轮换，csrapprover 控制器将自动批准节点的
新证书的 CSR 请求。</p>
<p>这是通过在 <code>system:nodes</code> 组和
<code>system:certificates.k8s.io:certificatesigningrequests:selfnodeclient</code>
默认角色之间创建名为 <code>kubeadm:node-autoapprove-certificate-rotation</code> 的
ClusterRoleBinding 来实现的。</p>
<h4 id=创建公共-cluster-info-configmap>创建公共 cluster-info ConfigMap</h4>
<p>本步骤在 <code>kube-public</code> 名字空间中创建名为 <code>cluster-info</code> 的 ConfigMap。</p>
<p>另外，它创建一个 Role 和一个 RoleBinding，为未经身份验证的用户授予对 ConfigMap
的访问权限（即 RBAC 组 <code>system:unauthenticated</code> 中的用户）。</p>
<p>请注意：</p>
<ol>
<li>对 <code>cluster-info</code> ConfigMap 的访问 <em>不受</em> 速率限制。
如果你把 API 服务器暴露到外网，这可能是一个问题，也可能不是；
这里最坏的情况是 DoS 攻击，攻击者使用 kube-apiserver 能够处理的所有动态请求
来为 <code>cluster-info</code> ConfigMap 提供服务。</li>
</ol>
<h3 id=install-addons>安装插件 </h3>
<p>Kubeadm 通过 API 服务器安装内部 DNS 服务器和 kube-proxy 插件。</p>
<p>请注意：</p>
<ol>
<li>此步骤可以调用
<a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-init-phase/#cmd-phase-addon>'kubeadm init phase addon all'</a>
命令单独执行。</li>
</ol>
<h4 id=proxy>代理 </h4>
<p>在 <code>kube-system</code> 名字空间中创建一个用于 <code>kube-proxy</code> 的 ServiceAccount；
然后以 DaemonSet 的方式部署 kube-proxy：</p>
<ul>
<li>主控节点凭据（<code>ca.crt</code> 和 <code>token</code>）来自 ServiceAccount</li>
<li>API 服务器节点的位置（URL）来自 ConfigMap</li>
<li><code>kube-proxy</code> 的 ServiceAccount 绑定了 <code>system:node-proxier</code> ClusterRole
中的特权</li>
</ul>
<h4 id=dns>DNS</h4>
<ul>
<li>CoreDNS 服务的名称为 <code>kube-dns</code>。这样做是为了防止当用户将集群 DNS 从 kube-dns
切换到 CoreDNS 时出现服务中断。<code>--config</code> 方法在
<a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-init-phase/#cmd-phase-addon>这里</a>
有描述。</li>
<li>在 <code>kube-system</code> 名字空间中创建 CoreDNS 的 ServiceAccount</li>
<li><code>coredns</code> 的 ServiceAccount 绑定了 <code>system:coredns</code> ClusterRole 中的特权</li>
</ul>
<p>在 Kubernetes 1.21 版本中，kubeadm 对 <code>kube-dns</code> 的支持被移除。
你可以在 kubeadm 使用 CoreDNS，即使相关的 Service 名字仍然是 <code>kube-dns</code>。</p>
<h2 id=kubeadm-join-phases-internal-design>kubeadm join 步骤内部设计 </h2>
<p>与 <code>kubeadm init</code> 类似，<code>kubeadm join</code> 内部工作流由一系列待执行的原子工作任务组成。</p>
<p>这分为发现（让该节点信任 Kubernetes 的主控节点）和 TLS 引导
（让 Kubernetes 的主控节点信任该节点）。</p>
<p>请参阅<a href=/zh/docs/reference/access-authn-authz/bootstrap-tokens/>使用引导令牌进行身份验证</a>
或相应的<a href=https://github.com/kubernetes/community/blob/master/contributors/design-proposals/cluster-lifecycle/bootstrap-discovery.md>设计提案</a>。</p>
<h3 id=preflight-checks>预检 </h3>
<p><code>kubeadm</code> 在开始执行之前执行一组预检，目的是验证先决条件，避免常见的集群启动问题。</p>
<p>请注意：</p>
<ol>
<li><code>kubeadm join</code> 预检基本上是 <code>kubeadm init</code> 预检的一个子集</li>
<li>从 1.9 开始，kubeadm 为 CRI 通用的功能提供了更好的支持；在这种情况下，
Docker 特定的控制参数将跳过或替换为 crictl 中与之相似的控制参数。</li>
<li>从 1.9 开始，kubeadm 支持加入在 Windows 上运行的节点；在这种情况下，
将跳过 Linux 特定的控制参数。</li>
<li>在任何情况下，用户都可以通过 <code>--ignore-preflight-errors</code> 选项跳过
特定的预检（或者进而跳过所有预检）。</li>
</ol>
<h3 id=discovery-cluster-info>发现 cluster-info </h3>
<p>主要有两种发现方案。第一种是使用一个共享令牌以及 API 服务器的 IP 地址。
第二种是提供一个文件（它是标准 kubeconfig 文件的子集）。</p>
<h4 id=shared-token-discovery>共享令牌发现 </h4>
<p>如果带 <code>--discovery-token</code> 参数调用 <code>kubeadm join</code>，则使用了令牌发现功能；
在这种情况下，节点基本上从 <code>kube-public</code> 名字空间中的 <code>cluster-info</code> ConfigMap
中检索集群 CA 证书。</p>
<p>为了防止“中间人”攻击，采取了以下步骤：</p>
<ul>
<li>首先，通过不安全连接检索 CA 证书（这是可能的，因为 <code>kubeadm init</code> 授予
<code>system:unauthenticated</code> 的用户对 <code>cluster-info</code> 访问权限）</li>
<li>然后 CA 证书通过以下验证步骤：
<ul>
<li>基本验证：使用令牌 ID 而不是 JWT 签名</li>
<li>公钥验证：使用提供的 <code>--discovery-token-ca-cert-hash</code>。这个值来自 <code>kubeadm init</code> 的输出，
或者可以使用标准工具计算（哈希值是按 RFC7469 中主体公钥信息（SPKI）对象的字节计算的）
<code>--discovery-token-ca-cert-hash</code> 标志可以重复多次，以允许多个公钥。</li>
<li>作为附加验证，通过安全连接检索 CA 证书，然后与初始检索的 CA 进行比较</li>
</ul>
</li>
</ul>
<p>请注意：</p>
<ol>
<li>通过 <code>--discovery-token-unsafe-skip-ca-verification</code> 标志可以跳过公钥验证；
这削弱了 kubeadm 安全模型，因为其他人可能冒充 Kubernetes 主控节点。</li>
</ol>
<h4 id=file-or-https-discovery>文件/HTTPS 发现 </h4>
<p>如果带 <code>--discovery-file</code> 参数调用 <code>kubeadm join</code>，则使用文件发现功能；
该文件可以是本地文件或通过 HTTPS URL 下载；对于 HTTPS，主机安装的 CA 包
用于验证连接。</p>
<p>通过文件发现，集群 CA 证书是文件本身提供；事实上，这个发现文件是一个 kubeconfig 文件，
只设置了 <code>server</code> 和 <code>certificate-authority-data</code> 属性，
如 <a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-join/#file-or-https-based-discovery><code>kubeadm join</code></a>
参考文档中所述，当与集群建立连接时，kubeadm 尝试访问 <code>cluster-info</code> ConfigMap，
如果可用，就使用它。</p>
<h2 id=tls-boostrap>TLS 引导 </h2>
<p>知道集群信息后，kubeadm 将写入文件 <code>bootstrap-kubelet.conf</code>，从而允许 kubelet 执行
TLS 引导。</p>
<p>TLS 引导机制使用共享令牌对 Kubernetes API 服务器进行临时身份验证，以便
为本地创建的密钥对提交证书签名请求（CSR）。</p>
<p>该请求会被自动批准，并且该操作保存 <code>ca.crt</code> 文件和 <code>kubelet.conf</code> 文件，用于
kubelet 加入集群，同时删除 <code>bootstrap-kubelet.conf</code>。</p>
<p>请注意：</p>
<ul>
<li>临时身份验证根据 <code>kubeadm init</code> 过程中保存的令牌进行验证（或者使用 <code>kubeadm token</code>
创建的其他令牌）</li>
<li>临时身份验证解析到 <code>system:bootstrappers:kubeadm:default-node-token</code> 组的一个用户成员，
该成员在 <code>kubeadm init</code> 过程中被授予对 CSR API 的访问权</li>
<li>根据 <code>kubeadm init</code> 过程的配置，自动 CSR 审批由 csrapprover 控制器管理</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-df8ff2190764e70c3de2015e2cb46b14>9 - 端口和协议</h1>
<p>当你在一个有严格网络边界的环境里运行 Kubernetes，例如拥有物理网络防火墙或者拥有公有云中虚拟网络的自有数据中心，了解 Kubernetes 组件使用了哪些端口和协议是非常有用的。</p>
<h2 id=control-plane>控制面 </h2>
<table>
<thead>
<tr>
<th>协议</th>
<th>方向</th>
<th>端口范围</th>
<th>目的</th>
<th>使用者</th>
</tr>
</thead>
<tbody>
<tr>
<td>TCP</td>
<td>入站</td>
<td>6443</td>
<td>Kubernetes API server</td>
<td>所有</td>
</tr>
<tr>
<td>TCP</td>
<td>入站</td>
<td>2379-2380</td>
<td>etcd server client API</td>
<td>kube-apiserver, etcd</td>
</tr>
<tr>
<td>TCP</td>
<td>入站</td>
<td>10250</td>
<td>Kubelet API</td>
<td>自身, 控制面</td>
</tr>
<tr>
<td>TCP</td>
<td>入站</td>
<td>10259</td>
<td>kube-scheduler</td>
<td>自身</td>
</tr>
<tr>
<td>TCP</td>
<td>入站</td>
<td>10257</td>
<td>kube-controller-manager</td>
<td>自身</td>
</tr>
</tbody>
</table>
<p>尽管 etcd 的端口也列举在控制面的部分，但你也可以在外部自己托管 etcd 集群或者自定义端口。</p>
<h2 id=node>工作节点 </h2>
<table>
<thead>
<tr>
<th>协议</th>
<th>方向</th>
<th>端口范围</th>
<th>目的</th>
<th>使用者</th>
</tr>
</thead>
<tbody>
<tr>
<td>TCP</td>
<td>入站</td>
<td>10250</td>
<td>Kubelet API</td>
<td>自身, 控制面</td>
</tr>
<tr>
<td>TCP</td>
<td>入站</td>
<td>30000-32767</td>
<td>NodePort Services†</td>
<td>所有</td>
</tr>
</tbody>
</table>
<p>† <a href=/zh/docs/concepts/services-networking/service/>NodePort Services</a>的默认端口范围。</p>
<p>所有默认端口都可以重新配置。当使用自定义的端口时，你需要打开这些端口来代替这里提到的默认端口。</p>
<p>一个常见的例子是 API 服务器的端口有时会配置为443。或者你也可以使用默认端口，把 API 服务器放到一个监听443 端口的负载均衡器后面，并且路由所有请求到 API 服务器的默认端口。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-03460a7254c6c73eb2a1bb3dd7d25910>10 - kubectl</h1>
</div>
<div class=td-content>
<h1 id=pg-d7ffbf04ffbefb241fd0722423b80f5a>10.1 - kubectl 命令</h1>
<p><a href=/docs/reference/generated/kubectl/kubectl-commands/>kubectl 命令参考</a></p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-f14fe15ecc2d41b5e901ef5e872ca657>10.2 - kubectl 概述</h1>
<p>你可以使用 Kubectl 命令行工具管理 Kubernetes 集群。
<code>kubectl</code> 在 <code>$HOME/.kube</code> 目录中查找一个名为 <code>config</code> 的配置文件。
你可以通过设置 KUBECONFIG 环境变量或设置
<a href=/zh/docs/concepts/configuration/organize-cluster-access-kubeconfig/><code>--kubeconfig</code></a>
参数来指定其它 <a href=/zh/docs/concepts/configuration/organize-cluster-access-kubeconfig/>kubeconfig</a> 文件。</p>
<p>本文概述了 <code>kubectl</code> 语法和命令操作描述，并提供了常见的示例。
有关每个命令的详细信息，包括所有受支持的参数和子命令，
请参阅 <a href=/docs/reference/generated/kubectl/kubectl-commands/>kubectl</a> 参考文档。
有关安装说明，请参见<a href=/zh/docs/tasks/tools/install-kubectl/>安装 kubectl</a> 。</p>
<h2 id=语法>语法</h2>
<p>使用以下语法 <code>kubectl</code> 从终端窗口运行命令：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#666>[</span>command<span style=color:#666>]</span> <span style=color:#666>[</span>TYPE<span style=color:#666>]</span> <span style=color:#666>[</span>NAME<span style=color:#666>]</span> <span style=color:#666>[</span>flags<span style=color:#666>]</span>
</code></pre></div>
<p>其中 <code>command</code>、<code>TYPE</code>、<code>NAME</code> 和 <code>flags</code> 分别是：</p>
<ul>
<li>
<p><code>command</code>：指定要对一个或多个资源执行的操作，例如 <code>create</code>、<code>get</code>、<code>describe</code>、<code>delete</code>。</p>
</li>
<li>
<p><code>TYPE</code>：指定<a href=#%E8%B5%84%E6%BA%90%E7%B1%BB%E5%9E%8B>资源类型</a>。资源类型不区分大小写，
可以指定单数、复数或缩写形式。例如，以下命令输出相同的结果:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod pod1
kubectl get pods pod1
kubectl get po pod1
</code></pre></div></li>
</ul>
<ul>
<li>
<p><code>NAME</code>：指定资源的名称。名称区分大小写。
如果省略名称，则显示所有资源的详细信息 <code>kubectl get pods</code>。</p>
<p>在对多个资源执行操作时，你可以按类型和名称指定每个资源，或指定一个或多个文件：</p>
<ul>
<li>
<p>要按类型和名称指定资源：</p>
<ul>
<li>
<p>要对所有类型相同的资源进行分组，请执行以下操作：<code>TYPE1 name1 name2 name&lt;#></code>。</p>
<p>例子：<code>kubectl get pod example-pod1 example-pod2</code></p>
</li>
<li>
<p>分别指定多个资源类型：<code>TYPE1/name1 TYPE1/name2 TYPE2/name3 TYPE&lt;#>/name&lt;#></code>。</p>
<p>例子：<code>kubectl get pod/example-pod1 replicationcontroller/example-rc1</code></p>
</li>
</ul>
</li>
<li>
<p>用一个或多个文件指定资源：<code>-f file1 -f file2 -f file&lt;#></code></p>
<ul>
<li><a href=/zh/docs/concepts/configuration/overview/#general-configuration-tips>使用 YAML 而不是 JSON</a>
因为 YAML 更容易使用，特别是用于配置文件时。
例子：<code>kubectl get -f ./pod.yaml</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><code>flags</code>: 指定可选的参数。例如，可以使用 <code>-s</code> 或 <code>-server</code> 参数指定
Kubernetes API 服务器的地址和端口。</li>
</ul>
<div class="alert alert-warning caution callout" role=alert>
<strong>Caution:</strong>
<p>从命令行指定的参数会覆盖默认值和任何相应的环境变量。
</div>
<p>如果你需要帮助，从终端窗口运行 <code>kubectl help</code> 。</p>
<h2 id=操作>操作</h2>
<p>下表包含所有 kubectl 操作的简短描述和普通语法：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>语法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>alpha</code></td>
<td><code>kubectl alpha SUBCOMMAND [flags]</code></td>
<td>列出与 alpha 特性对应的可用命令，这些特性在 Kubernetes 集群中默认情况下是不启用的。</td>
</tr>
<tr>
<td><code>annotate</code></td>
<td><code>kubectl annotate (-f FILENAME | TYPE NAME | TYPE/NAME) KEY_1=VAL_1 ... KEY_N=VAL_N [--overwrite] [--all] [--resource-version=version] [flags]</code></td>
<td>添加或更新一个或多个资源的注解。</td>
</tr>
<tr>
<td><code>api-resources</code></td>
<td><code>kubectl api-resources [flags]</code></td>
<td>列出可用的 API 资源。</td>
</tr>
<tr>
<td><code>api-versions</code></td>
<td><code>kubectl api-versions [flags]</code></td>
<td>列出可用的 API 版本。</td>
</tr>
<tr>
<td><code>apply</code></td>
<td><code>kubectl apply -f FILENAME [flags]</code></td>
<td>从文件或 stdin 对资源应用配置更改。</td>
</tr>
<tr>
<td><code>attach</code></td>
<td><code>kubectl attach POD -c CONTAINER [-i] [-t] [flags]</code></td>
<td>附加到正在运行的容器，查看输出流或与容器（stdin）交互。</td>
</tr>
<tr>
<td><code>auth</code></td>
<td><code>kubectl auth [flags] [options]</code></td>
<td>检查授权。</td>
</tr>
<tr>
<td><code>autoscale</code></td>
<td><code>kubectl autoscale (-f FILENAME | TYPE NAME | TYPE/NAME) [--min=MINPODS] --max=MAXPODS [--cpu-percent=CPU] [flags]</code></td>
<td>自动伸缩由副本控制器管理的一组 pod。</td>
</tr>
<tr>
<td><code>certificate</code></td>
<td><code>kubectl certificate SUBCOMMAND [options]</code></td>
<td>修改证书资源。</td>
</tr>
<tr>
<td><code>cluster-info</code></td>
<td><code>kubectl cluster-info [flags]</code></td>
<td>显示有关集群中主服务器和服务的端口信息。</td>
</tr>
<tr>
<td><code>completion</code></td>
<td><code>kubectl completion SHELL [options]</code></td>
<td>为指定的 shell （bash 或 zsh）输出 shell 补齐代码。</td>
</tr>
<tr>
<td><code>config</code></td>
<td><code>kubectl config SUBCOMMAND [flags]</code></td>
<td>修改 kubeconfig 文件。有关详细信息，请参阅各个子命令。</td>
</tr>
<tr>
<td><code>convert</code></td>
<td><code>kubectl convert -f FILENAME [options]</code></td>
<td>在不同的 API 版本之间转换配置文件。配置文件可以是 YAML 或 JSON 格式。</td>
</tr>
<tr>
<td><code>cordon</code></td>
<td><code>kubectl cordon NODE [options]</code></td>
<td>将节点标记为不可调度。</td>
</tr>
<tr>
<td><code>cp</code></td>
<td><code>kubectl cp &lt;file-spec-src> &lt;file-spec-dest> [options]</code></td>
<td>在容器之间复制文件和目录。</td>
</tr>
<tr>
<td><code>create</code></td>
<td><code>kubectl create -f FILENAME [flags]</code></td>
<td>从文件或 stdin 创建一个或多个资源。</td>
</tr>
<tr>
<td><code>delete</code></td>
<td><code>kubectl delete (-f FILENAME | TYPE [NAME | /NAME | -l label | --all]) [flags]</code></td>
<td>从文件、标准输入或指定标签选择器、名称、资源选择器或资源中删除资源。</td>
</tr>
<tr>
<td><code>describe</code></td>
<td><code>kubectl describe (-f FILENAME | TYPE [NAME_PREFIX | /NAME | -l label]) [flags]</code></td>
<td>显示一个或多个资源的详细状态。</td>
</tr>
<tr>
<td><code>diff</code></td>
<td><code>kubectl diff -f FILENAME [flags]</code></td>
<td>将 live 配置和文件或标准输入做对比 (<strong>BETA</strong>)</td>
</tr>
<tr>
<td><code>drain</code></td>
<td><code>kubectl drain NODE [options]</code></td>
<td>腾空节点以准备维护。</td>
</tr>
<tr>
<td><code>edit</code></td>
<td><code>kubectl edit (-f FILENAME | TYPE NAME | TYPE/NAME) [flags]</code></td>
<td>使用默认编辑器编辑和更新服务器上一个或多个资源的定义。</td>
</tr>
<tr>
<td><code>exec</code></td>
<td><code>kubectl exec POD [-c CONTAINER] [-i] [-t] [flags] [-- COMMAND [args...]]</code></td>
<td>对 pod 中的容器执行命令。</td>
</tr>
<tr>
<td><code>explain</code></td>
<td><code>kubectl explain [--recursive=false] [flags]</code></td>
<td>获取多种资源的文档。例如 pod, node, service 等。</td>
</tr>
<tr>
<td><code>expose</code></td>
<td><code>kubectl expose (-f FILENAME | TYPE NAME | TYPE/NAME) [--port=port] [--protocol=TCP|UDP] [--target-port=number-or-name] [--name=name] [--external-ip=external-ip-of-service] [--type=type] [flags]</code></td>
<td>将副本控制器、服务或 pod 作为新的 Kubernetes 服务暴露。</td>
</tr>
<tr>
<td><code>get</code></td>
<td><code>kubectl get (-f FILENAME | TYPE [NAME | /NAME | -l label]) [--watch] [--sort-by=FIELD] [[-o | --output]=OUTPUT_FORMAT] [flags]</code></td>
<td>列出一个或多个资源。</td>
</tr>
<tr>
<td><code>kustomize</code></td>
<td><code>kubectl kustomize &lt;dir> [flags] [options]</code></td>
<td>列出从 kustomization.yaml 文件中的指令生成的一组 API 资源。参数必须是包含文件的目录的路径，或者是 git 存储库 URL，其路径后缀相对于存储库根目录指定了相同的路径。</td>
</tr>
<tr>
<td><code>label</code></td>
<td><code>kubectl label (-f FILENAME | TYPE NAME | TYPE/NAME) KEY_1=VAL_1 ... KEY_N=VAL_N [--overwrite] [--all] [--resource-version=version] [flags]</code></td>
<td>添加或更新一个或多个资源的标签。</td>
</tr>
<tr>
<td><code>logs</code></td>
<td><code>kubectl logs POD [-c CONTAINER] [--follow] [flags]</code></td>
<td>在 pod 中打印容器的日志。</td>
</tr>
<tr>
<td><code>options</code></td>
<td><code>kubectl options</code></td>
<td>全局命令行选项列表，适用于所有命令。</td>
</tr>
<tr>
<td><code>patch</code></td>
<td><code>kubectl patch (-f FILENAME | TYPE NAME | TYPE/NAME) --patch PATCH [flags]</code></td>
<td>使用策略合并 patch 程序更新资源的一个或多个字段。</td>
</tr>
<tr>
<td><code>plugin</code></td>
<td><code>kubectl plugin [flags] [options]</code></td>
<td>提供用于与插件交互的实用程序。</td>
</tr>
<tr>
<td><code>port-forward</code></td>
<td><code>kubectl port-forward POD [LOCAL_PORT:]REMOTE_PORT [...[LOCAL_PORT_N:]REMOTE_PORT_N] [flags]</code></td>
<td>将一个或多个本地端口转发到一个 pod。</td>
</tr>
<tr>
<td><code>proxy</code></td>
<td><code>kubectl proxy [--port=PORT] [--www=static-dir] [--www-prefix=prefix] [--api-prefix=prefix] [flags]</code></td>
<td>运行 Kubernetes API 服务器的代理。</td>
</tr>
<tr>
<td><code>replace</code></td>
<td><code>kubectl replace -f FILENAME</code></td>
<td>从文件或标准输入中替换资源。</td>
</tr>
<tr>
<td><code>rollout</code></td>
<td><code>kubectl rollout SUBCOMMAND [options]</code></td>
<td>管理资源的部署。有效的资源类型包括：Deployments, DaemonSets 和 StatefulSets。</td>
</tr>
<tr>
<td><code>run</code></td>
<td><code>kubectl run NAME --image=image [--env="key=value"] [--port=port] [--dry-run=server | client | none] [--overrides=inline-json] [flags]</code></td>
<td>在集群上运行指定的镜像。</td>
</tr>
<tr>
<td><code>scale</code></td>
<td><code>kubectl scale (-f FILENAME | TYPE NAME | TYPE/NAME) --replicas=COUNT [--resource-version=version] [--current-replicas=count] [flags]</code></td>
<td>更新指定副本控制器的大小。</td>
</tr>
<tr>
<td><code>set</code></td>
<td><code>kubectl set SUBCOMMAND [options]</code></td>
<td>配置应用程序资源。</td>
</tr>
<tr>
<td><code>taint</code></td>
<td><code>kubectl taint NODE NAME KEY_1=VAL_1:TAINT_EFFECT_1 ... KEY_N=VAL_N:TAINT_EFFECT_N [options]</code></td>
<td>更新一个或多个节点上的污点。</td>
</tr>
<tr>
<td><code>top</code></td>
<td><code>kubectl top [flags] [options]</code></td>
<td>显示资源（CPU/内存/存储）的使用情况。</td>
</tr>
<tr>
<td><code>uncordon</code></td>
<td><code>kubectl uncordon NODE [options]</code></td>
<td>将节点标记为可调度。</td>
</tr>
<tr>
<td><code>version</code></td>
<td><code>kubectl version [--client] [flags]</code></td>
<td>显示运行在客户端和服务器上的 Kubernetes 版本。</td>
</tr>
<tr>
<td><code>wait</code></td>
<td><code>kubectl wait ([-f FILENAME] | resource.group/resource.name | resource.group [(-l label | --all)]) [--for=delete|--for condition=available] [options]</code></td>
<td>实验性：等待一种或多种资源的特定条件。</td>
</tr>
</tbody>
</table>
<p>了解更多有关命令操作的信息，请参阅 <a href=/zh/docs/reference/kubectl/kubectl/>kubectl</a> 参考文档。</p>
<h2 id=资源类型>资源类型</h2>
<p>下表列出所有受支持的资源类型及其缩写别名:</p>
<p>(以下输出可以通过 <code>kubectl api-resources</code> 获取，内容以 Kubernetes 1.19.1 版本为准。)</p>
<table>
<thead>
<tr>
<th>资源名</th>
<th>缩写名</th>
<th>API 分组</th>
<th>按命名空间</th>
<th>资源类型</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>bindings</code></td>
<td></td>
<td></td>
<td>true</td>
<td>Binding</td>
</tr>
<tr>
<td><code>componentstatuses</code></td>
<td><code>cs</code></td>
<td></td>
<td>false</td>
<td>ComponentStatus</td>
</tr>
<tr>
<td><code>configmaps</code></td>
<td><code>cm</code></td>
<td></td>
<td>true</td>
<td>ConfigMap</td>
</tr>
<tr>
<td><code>endpoints</code></td>
<td><code>ep</code></td>
<td></td>
<td>true</td>
<td>Endpoints</td>
</tr>
<tr>
<td><code>events</code></td>
<td><code>ev</code></td>
<td></td>
<td>true</td>
<td>Event</td>
</tr>
<tr>
<td><code>limitranges</code></td>
<td><code>limits</code></td>
<td></td>
<td>true</td>
<td>LimitRange</td>
</tr>
<tr>
<td><code>namespaces</code></td>
<td><code>ns</code></td>
<td></td>
<td>false</td>
<td>Namespace</td>
</tr>
<tr>
<td><code>nodes</code></td>
<td><code>no</code></td>
<td></td>
<td>false</td>
<td>Node</td>
</tr>
<tr>
<td><code>persistentvolumeclaims</code></td>
<td><code>pvc</code></td>
<td></td>
<td>true</td>
<td>PersistentVolumeClaim</td>
</tr>
<tr>
<td><code>persistentvolumes</code></td>
<td><code>pv</code></td>
<td></td>
<td>false</td>
<td>PersistentVolume</td>
</tr>
<tr>
<td><code>pods</code></td>
<td><code>po</code></td>
<td></td>
<td>true</td>
<td>Pod</td>
</tr>
<tr>
<td><code>podtemplates</code></td>
<td></td>
<td></td>
<td>true</td>
<td>PodTemplate</td>
</tr>
<tr>
<td><code>replicationcontrollers</code></td>
<td><code>rc</code></td>
<td></td>
<td>true</td>
<td>ReplicationController</td>
</tr>
<tr>
<td><code>resourcequotas</code></td>
<td><code>quota</code></td>
<td></td>
<td>true</td>
<td>ResourceQuota</td>
</tr>
<tr>
<td><code>secrets</code></td>
<td></td>
<td></td>
<td>true</td>
<td>Secret</td>
</tr>
<tr>
<td><code>serviceaccounts</code></td>
<td><code>sa</code></td>
<td></td>
<td>true</td>
<td>ServiceAccount</td>
</tr>
<tr>
<td><code>services</code></td>
<td><code>svc</code></td>
<td></td>
<td>true</td>
<td>Service</td>
</tr>
<tr>
<td><code>mutatingwebhookconfigurations</code></td>
<td></td>
<td>admissionregistration.k8s.io</td>
<td>false</td>
<td>MutatingWebhookConfiguration</td>
</tr>
<tr>
<td><code>validatingwebhookconfigurations</code></td>
<td></td>
<td>admissionregistration.k8s.io</td>
<td>false</td>
<td>ValidatingWebhookConfiguration</td>
</tr>
<tr>
<td><code>customresourcedefinitions</code></td>
<td><code>crd,crds</code></td>
<td>apiextensions.k8s.io</td>
<td>false</td>
<td>CustomResourceDefinition</td>
</tr>
<tr>
<td><code>apiservices</code></td>
<td></td>
<td>apiregistration.k8s.io</td>
<td>false</td>
<td>APIService</td>
</tr>
<tr>
<td><code>controllerrevisions</code></td>
<td></td>
<td>apps</td>
<td>true</td>
<td>ControllerRevision</td>
</tr>
<tr>
<td><code>daemonsets</code></td>
<td><code>ds</code></td>
<td>apps</td>
<td>true</td>
<td>DaemonSet</td>
</tr>
<tr>
<td><code>deployments</code></td>
<td><code>deploy</code></td>
<td>apps</td>
<td>true</td>
<td>Deployment</td>
</tr>
<tr>
<td><code>replicasets</code></td>
<td><code>rs</code></td>
<td>apps</td>
<td>true</td>
<td>ReplicaSet</td>
</tr>
<tr>
<td><code>statefulsets</code></td>
<td><code>sts</code></td>
<td>apps</td>
<td>true</td>
<td>StatefulSet</td>
</tr>
<tr>
<td><code>tokenreviews</code></td>
<td></td>
<td>authentication.k8s.io</td>
<td>false</td>
<td>TokenReview</td>
</tr>
<tr>
<td><code>localsubjectaccessreviews</code></td>
<td></td>
<td>authorization.k8s.io</td>
<td>true</td>
<td>LocalSubjectAccessReview</td>
</tr>
<tr>
<td><code>selfsubjectaccessreviews</code></td>
<td></td>
<td>authorization.k8s.io</td>
<td>false</td>
<td>SelfSubjectAccessReview</td>
</tr>
<tr>
<td><code>selfsubjectrulesreviews</code></td>
<td></td>
<td>authorization.k8s.io</td>
<td>false</td>
<td>SelfSubjectRulesReview</td>
</tr>
<tr>
<td><code>subjectaccessreviews</code></td>
<td></td>
<td>authorization.k8s.io</td>
<td>false</td>
<td>SubjectAccessReview</td>
</tr>
<tr>
<td><code>horizontalpodautoscalers</code></td>
<td><code>hpa</code></td>
<td>autoscaling</td>
<td>true</td>
<td>HorizontalPodAutoscaler</td>
</tr>
<tr>
<td><code>cronjobs</code></td>
<td><code>cj</code></td>
<td>batch</td>
<td>true</td>
<td>CronJob</td>
</tr>
<tr>
<td><code>jobs</code></td>
<td></td>
<td>batch</td>
<td>true</td>
<td>Job</td>
</tr>
<tr>
<td><code>certificatesigningrequests</code></td>
<td><code>csr</code></td>
<td>certificates.k8s.io</td>
<td>false</td>
<td>CertificateSigningRequest</td>
</tr>
<tr>
<td><code>leases</code></td>
<td></td>
<td>coordination.k8s.io</td>
<td>true</td>
<td>Lease</td>
</tr>
<tr>
<td><code>endpointslices</code></td>
<td></td>
<td>discovery.k8s.io</td>
<td>true</td>
<td>EndpointSlice</td>
</tr>
<tr>
<td><code>events</code></td>
<td><code>ev</code></td>
<td>events.k8s.io</td>
<td>true</td>
<td>Event</td>
</tr>
<tr>
<td><code>ingresses</code></td>
<td><code>ing</code></td>
<td>extensions</td>
<td>true</td>
<td>Ingress</td>
</tr>
<tr>
<td><code>flowschemas</code></td>
<td></td>
<td>flowcontrol.apiserver.k8s.io</td>
<td>false</td>
<td>FlowSchema</td>
</tr>
<tr>
<td><code>prioritylevelconfigurations</code></td>
<td></td>
<td>flowcontrol.apiserver.k8s.io</td>
<td>false</td>
<td>PriorityLevelConfiguration</td>
</tr>
<tr>
<td><code>ingressclasses</code></td>
<td></td>
<td>networking.k8s.io</td>
<td>false</td>
<td>IngressClass</td>
</tr>
<tr>
<td><code>ingresses</code></td>
<td><code>ing</code></td>
<td>networking.k8s.io</td>
<td>true</td>
<td>Ingress</td>
</tr>
<tr>
<td><code>networkpolicies</code></td>
<td><code>netpol</code></td>
<td>networking.k8s.io</td>
<td>true</td>
<td>NetworkPolicy</td>
</tr>
<tr>
<td><code>runtimeclasses</code></td>
<td></td>
<td>node.k8s.io</td>
<td>false</td>
<td>RuntimeClass</td>
</tr>
<tr>
<td><code>poddisruptionbudgets</code></td>
<td><code>pdb</code></td>
<td>policy</td>
<td>true</td>
<td>PodDisruptionBudget</td>
</tr>
<tr>
<td><code>podsecuritypolicies</code></td>
<td><code>psp</code></td>
<td>policy</td>
<td>false</td>
<td>PodSecurityPolicy</td>
</tr>
<tr>
<td><code>clusterrolebindings</code></td>
<td></td>
<td>rbac.authorization.k8s.io</td>
<td>false</td>
<td>ClusterRoleBinding</td>
</tr>
<tr>
<td><code>clusterroles</code></td>
<td></td>
<td>rbac.authorization.k8s.io</td>
<td>false</td>
<td>ClusterRole</td>
</tr>
<tr>
<td><code>rolebindings</code></td>
<td></td>
<td>rbac.authorization.k8s.io</td>
<td>true</td>
<td>RoleBinding</td>
</tr>
<tr>
<td><code>roles</code></td>
<td></td>
<td>rbac.authorization.k8s.io</td>
<td>true</td>
<td>Role</td>
</tr>
<tr>
<td><code>priorityclasses</code></td>
<td><code>pc</code></td>
<td>scheduling.k8s.io</td>
<td>false</td>
<td>PriorityClass</td>
</tr>
<tr>
<td><code>csidrivers</code></td>
<td></td>
<td>storage.k8s.io</td>
<td>false</td>
<td>CSIDriver</td>
</tr>
<tr>
<td><code>csinodes</code></td>
<td></td>
<td>storage.k8s.io</td>
<td>false</td>
<td>CSINode</td>
</tr>
<tr>
<td><code>storageclasses</code></td>
<td><code>sc</code></td>
<td>storage.k8s.io</td>
<td>false</td>
<td>StorageClass</td>
</tr>
<tr>
<td><code>volumeattachments</code></td>
<td></td>
<td>storage.k8s.io</td>
<td>false</td>
<td>VolumeAttachment</td>
</tr>
</tbody>
</table>
<h2 id=输出选项>输出选项</h2>
<p>有关如何格式化或排序某些命令的输出的信息，请使用以下部分。有关哪些命令支持各种输出选项的详细信息，请参阅<a href=/zh/docs/reference/kubectl/kubectl/>kubectl</a> 参考文档。</p>
<h3 id=格式化输出>格式化输出</h3>
<p>所有 <code>kubectl</code> 命令的默认输出格式都是人类可读的纯文本格式。要以特定格式向终端窗口输出详细信息，可以将 <code>-o</code> 或 <code>--output</code> 参数添加到受支持的 <code>kubectl</code> 命令中。</p>
<h4 id=语法-1>语法</h4>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#666>[</span>command<span style=color:#666>]</span> <span style=color:#666>[</span>TYPE<span style=color:#666>]</span> <span style=color:#666>[</span>NAME<span style=color:#666>]</span> -o<span style=color:#666>=</span>&lt;output_format&gt;
</code></pre></div>
<p>根据 <code>kubectl</code> 操作，支持以下输出格式：</p>
<table>
<thead>
<tr>
<th>Output format</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>-o custom-columns=&lt;spec></code></td>
<td>使用逗号分隔的<a href=#custom-columns>自定义列</a>列表打印表。</td>
</tr>
<tr>
<td><code>-o custom-columns-file=&lt;filename></code></td>
<td>使用 <code>&lt;filename></code> 文件中的<a href=#custom-columns>自定义列</a>模板打印表。</td>
</tr>
<tr>
<td><code>-o json</code></td>
<td>输出 JSON 格式的 API 对象</td>
</tr>
<tr>
<td><code>-o jsonpath=&lt;template></code></td>
<td>打印 <a href=/zh/docs/reference/kubectl/jsonpath/>jsonpath</a> 表达式定义的字段</td>
</tr>
<tr>
<td><code>-o jsonpath-file=&lt;filename></code></td>
<td>打印 <code>&lt;filename></code> 文件中 <a href=/zh/docs/reference/kubectl/jsonpath/>jsonpath</a> 表达式定义的字段。</td>
</tr>
<tr>
<td><code>-o name</code></td>
<td>仅打印资源名称而不打印任何其他内容。</td>
</tr>
<tr>
<td><code>-o wide</code></td>
<td>以纯文本格式输出，包含任何附加信息。对于 pod 包含节点名。</td>
</tr>
<tr>
<td><code>-o yaml</code></td>
<td>输出 YAML 格式的 API 对象。</td>
</tr>
</tbody>
</table>
<h5 id=示例>示例</h5>
<p>在此示例中，以下命令将单个 pod 的详细信息输出为 YAML 格式的对象：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod web-pod-13je7 -o yaml
</code></pre></div>
<p>请记住：有关每个命令支持哪种输出格式的详细信息，请参阅 <a href=/zh/docs/reference/kubectl/kubectl/>kubectl</a> 参考文档。</p>
<h4 id=自定义列>自定义列</h4>
<p>要定义自定义列并仅将所需的详细信息输出到表中，可以使用该 custom-columns 选项。你可以选择内联定义自定义列或使用模板文件：<code>-o=custom-columns=&lt;spec></code> 或 <code>-o=custom-columns-file=&lt;filename></code>。</p>
<h5 id=示例-1>示例</h5>
<p>内联：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods &lt;pod-name&gt; -o custom-columns<span style=color:#666>=</span>NAME:.metadata.name,RSRC:.metadata.resourceVersion
</code></pre></div>
<p>模板文件：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods &lt;pod-name&gt; -o custom-columns-file<span style=color:#666>=</span>template.txt
</code></pre></div>
<p>其中，<code>template.txt</code> 文件包含：</p>
<pre><code>NAME          RSRC
metadata.name metadata.resourceVersion
</code></pre>
<p>运行任何一个命令的结果类似于:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>NAME           RSRC
submit-queue   <span style=color:#666>610995</span>
</code></pre></div>
<h4 id=server-side-列>Server-side 列</h4>
<p><code>kubectl</code> 支持从服务器接收关于对象的特定列信息。
这意味着对于任何给定的资源，服务器将返回与该资源相关的列和行，以便客户端打印。
通过让服务器封装打印的细节，这允许在针对同一集群使用的客户端之间提供一致的人类可读输出。</p>
<p>此功能默认启用。要禁用它，请将该 <code>--server-print=false</code> 参数添加到 <code>kubectl get</code> 命令中。</p>
<h5 id=例子>例子：</h5>
<p>要打印有关 pod 状态的信息，请使用如下命令：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods &lt;pod-name&gt; --server-print<span style=color:#666>=</span><span style=color:#a2f>false</span>
</code></pre></div>
<p>输出类似于：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>NAME       AGE
pod-name   1m
</code></pre></div>
<h3 id=排序列表对象>排序列表对象</h3>
<p>要将对象排序后输出到终端窗口，可以将 <code>--sort-by</code> 参数添加到支持的 <code>kubectl</code> 命令。通过使用 <code>--sort-by</code> 参数指定任何数字或字符串字段来对对象进行排序。要指定字段，请使用 <a href=/zh/docs/reference/kubectl/jsonpath/>jsonpath</a> 表达式。</p>
<h4 id=语法-2>语法</h4>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#666>[</span>command<span style=color:#666>]</span> <span style=color:#666>[</span>TYPE<span style=color:#666>]</span> <span style=color:#666>[</span>NAME<span style=color:#666>]</span> --sort-by<span style=color:#666>=</span>&lt;jsonpath_exp&gt;
</code></pre></div>
<h5 id=示例-2>示例</h5>
<p>要打印按名称排序的 pod 列表，请运行：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods --sort-by<span style=color:#666>=</span>.metadata.name
</code></pre></div>
<h2 id=示例-常用操作>示例：常用操作</h2>
<p>使用以下示例集来帮助你熟悉运行常用 kubectl 操作：</p>
<p><code>kubectl apply</code> - 以文件或标准输入为准应用或更新资源。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># 使用 example-service.yaml 中的定义创建服务。</span>
kubectl apply -f example-service.yaml

<span style=color:#080;font-style:italic># 使用 example-controller.yaml 中的定义创建 replication controller。</span>
kubectl apply -f example-controller.yaml

<span style=color:#080;font-style:italic># 使用 &lt;directory&gt; 路径下的任意 .yaml, .yml, 或 .json 文件 创建对象。</span>
kubectl apply -f &lt;directory&gt;
</code></pre></div>
<p><code>kubectl get</code> - 列出一个或多个资源。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># 以纯文本输出格式列出所有 pod。</span>
kubectl get pods

<span style=color:#080;font-style:italic># 以纯文本输出格式列出所有 pod，并包含附加信息(如节点名)。</span>
kubectl get pods -o wide

<span style=color:#080;font-style:italic># 以纯文本输出格式列出具有指定名称的副本控制器。提示：你可以使用别名 &#39;rc&#39; 缩短和替换 &#39;replicationcontroller&#39; 资源类型。</span>
kubectl get replicationcontroller &lt;rc-name&gt;

<span style=color:#080;font-style:italic># 以纯文本输出格式列出所有副本控制器和服务。</span>
kubectl get rc,services

<span style=color:#080;font-style:italic># 以纯文本输出格式列出所有守护程序集，包括未初始化的守护程序集。</span>
kubectl get ds --include-uninitialized

<span style=color:#080;font-style:italic># 列出在节点 server01 上运行的所有 pod</span>
kubectl get pods --field-selector<span style=color:#666>=</span>spec.nodeName<span style=color:#666>=</span>server01
</code></pre></div>
<p><code>kubectl describe</code> - 显示一个或多个资源的详细状态，默认情况下包括未初始化的资源。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># 显示名称为 &lt;node-name&gt; 的节点的详细信息。</span>
kubectl describe nodes &lt;node-name&gt;

<span style=color:#080;font-style:italic># 显示名为 &lt;pod-name&gt; 的 pod 的详细信息。</span>
kubectl describe pods/&lt;pod-name&gt;

<span style=color:#080;font-style:italic># 显示由名为 &lt;rc-name&gt; 的副本控制器管理的所有 pod 的详细信息。</span>
<span style=color:#080;font-style:italic># 记住：副本控制器创建的任何 pod 都以复制控制器的名称为前缀。</span>
kubectl describe pods &lt;rc-name&gt;

<span style=color:#080;font-style:italic># 描述所有的 pod，不包括未初始化的 pod</span>
kubectl describe pods
</code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>Note:</strong>
<p><code>kubectl get</code> 命令通常用于检索同一资源类型的一个或多个资源。
它具有丰富的参数，允许你使用 <code>-o</code> 或 <code>--output</code> 参数自定义输出格式。你可以指定 <code>-w</code> 或 <code>--watch</code> 参数以开始观察特定对象的更新。
<code>kubectl describe</code> 命令更侧重于描述指定资源的许多相关方面。它可以调用对 <code>API 服务器</code> 的多个 API 调用来为用户构建视图。
例如，该 <code>kubectl describe node</code> 命令不仅检索有关节点的信息，还检索在其上运行的 pod 的摘要，为节点生成的事件等。
</div>
<p><code>kubectl delete</code> - 从文件、stdin 或指定标签选择器、名称、资源选择器或资源中删除资源。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># 使用 pod.yaml 文件中指定的类型和名称删除 pod。</span>
kubectl delete -f pod.yaml

<span style=color:#080;font-style:italic># 删除所有带有 &#39;&lt;label-key&gt;=&lt;label-value&gt;&#39; 标签的 Pod 和服务。</span>
kubectl delete pods,services -l &lt;label-key&gt;<span style=color:#666>=</span>&lt;label-value&gt;

<span style=color:#080;font-style:italic># 删除所有 pod，包括未初始化的 pod。</span>
kubectl delete pods --all
</code></pre></div>
<p><code>kubectl exec</code> - 对 pod 中的容器执行命令。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># 从 pod &lt;pod-name&gt; 中获取运行 &#39;date&#39; 的输出。默认情况下，输出来自第一个容器。</span>
kubectl <span style=color:#a2f>exec</span> &lt;pod-name&gt; -- date

<span style=color:#080;font-style:italic># 运行输出 &#39;date&#39; 获取在容器的 &lt;container-name&gt; 中 pod &lt;pod-name&gt; 的输出。</span>
kubectl <span style=color:#a2f>exec</span> &lt;pod-name&gt; -c &lt;container-name&gt; -- date

<span style=color:#080;font-style:italic># 获取一个交互 TTY 并运行 /bin/bash &lt;pod-name &gt;。默认情况下，输出来自第一个容器。</span>
kubectl <span style=color:#a2f>exec</span> -ti &lt;pod-name&gt; -- /bin/bash
</code></pre></div>
<p><code>kubectl logs</code> - 打印 Pod 中容器的日志。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># 从 pod 返回日志快照。</span>
kubectl logs &lt;pod-name&gt;

<span style=color:#080;font-style:italic># 从 pod &lt;pod-name&gt; 开始流式传输日志。这类似于 &#39;tail -f&#39; Linux 命令。</span>
kubectl logs -f &lt;pod-name&gt;
</code></pre></div>
<h2 id=示例-创建和使用插件>示例：创建和使用插件</h2>
<p>使用以下示例来帮助你熟悉编写和使用 <code>kubectl</code> 插件：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># 用任何语言创建一个简单的插件，并为生成的可执行文件命名</span>
<span style=color:#080;font-style:italic># 以前缀 &#34;kubectl-&#34; 开始</span>
cat ./kubectl-hello
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080>#!/bin/sh
</span><span style=color:#080></span>
<span style=color:#080;font-style:italic># 这个插件打印单词 &#34;hello world&#34;</span>
<span style=color:#a2f>echo</span> <span style=color:#b44>&#34;hello world&#34;</span>
</code></pre></div><p>这个插件写好了，把它变成可执行的：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>sudo chmod a+x ./kubectl-hello

<span style=color:#080;font-style:italic># 并将其移动到路径中的某个位置</span>
sudo mv ./kubectl-hello /usr/local/bin
sudo chown root:root /usr/local/bin

<span style=color:#080;font-style:italic># 你现在已经创建并&#34;安装了&#34;一个 kubectl 插件。</span>
<span style=color:#080;font-style:italic># 你可以开始使用这个插件，从 kubectl 调用它，就像它是一个常规命令一样</span>
kubectl hello
</code></pre></div><pre><code>hello world
</code></pre>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># 你可以&#34;卸载&#34;一个插件，只需从你的路径中删除它</span>
sudo rm /usr/local/bin/kubectl-hello
</code></pre></div>
<p>为了查看可用的所有 <code>kubectl</code> 插件，你可以使用 <code>kubectl plugin list</code> 子命令：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl plugin list
</code></pre></div>
<p>输出类似于：</p>
<pre><code>The following kubectl-compatible plugins are available:

/usr/local/bin/kubectl-hello
/usr/local/bin/kubectl-foo
/usr/local/bin/kubectl-bar
</code></pre>
<p><code>kubectl plugin list</code>指令也可以向你告警哪些插件被运行，或是被其它插件覆盖了,例如:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>sudo chmod -x /usr/local/bin/kubectl-foo <span style=color:#080;font-style:italic># 删除执行权限</span>
kubectl plugin list
</code></pre></div>
<pre><code>The following kubectl-compatible plugins are available:

/usr/local/bin/kubectl-hello
/usr/local/bin/kubectl-foo
  - warning: /usr/local/bin/kubectl-foo identified as a plugin, but it is not executable
/usr/local/bin/kubectl-bar

error: one plugin warning was found
</code></pre>
<p>你可以将插件视为在现有 kubectl 命令之上构建更复杂功能的一种方法：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>cat ./kubectl-whoami
</code></pre></div>
<p>接下来的几个示例假设你已经将 <code>kubectl-whoami</code> 设置为以下内容:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080>#!/bin/bash
</span><span style=color:#080></span>
<span style=color:#080;font-style:italic>#这个插件利用 `kubectl config` 命令基于当前所选上下文输出当前用户的信息</span>
kubectl config view --template<span style=color:#666>=</span><span style=color:#b44>&#39;{{ range .contexts }}{{ if eq .name &#34;&#39;</span><span style=color:#a2f;font-weight:700>$(</span>kubectl config current-context<span style=color:#a2f;font-weight:700>)</span><span style=color:#b44>&#39;&#34; }}Current user: {{ printf &#34;%s\n&#34; .context.user }}{{ end }}{{ end }}&#39;</span>
</code></pre></div>
<p>运行以上命令将为你提供一个输出，其中包含 KUBECONFIG 文件中当前上下文的用户:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080>#!/bin/bash
</span><span style=color:#080></span><span style=color:#080;font-style:italic># 使文件成为可执行的</span>
sudo chmod +x ./kubectl-whoami

<span style=color:#080;font-style:italic># 然后移动到你的路径中</span>
sudo mv ./kubectl-whoami /usr/local/bin

kubectl whoami
Current user: plugins-user
</code></pre></div>
<p>要了解关于插件的更多信息，请查看<a href=https://github.com/kubernetes/sample-cli-plugin>示例 cli 插件</a>。</p>
<h2 id=what-s-next>What's next</h2>
<ul>
<li>
<p>开始使用 <a href=/docs/reference/generated/kubectl/kubectl-commands/>kubectl</a> 命令。</p>
</li>
<li>
<p>查看更多<a href=https://github.com/kubernetes/sample-cli-plugin>示例 cli 插件</a>。</p>
</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-4d3e62632c189fcc3c1357cd8fb8799c>10.3 - kubectl</h1>
<h2 id=synopsis>Synopsis</h2>
<p>kubectl 管理控制 Kubernetes 集群。</p>
<p>获取更多信息，请访问 <a href=/zh/docs/reference/kubectl/overview/>kubectl 概述</a>。</p>
<pre><code>kubectl [flags]
</code></pre><h2 id=options>Options</h2>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--add-dir-header</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
设置为 true 表示添加文件目录到日志信息头中
</td>
</tr>
<tr>
<td colspan=2>--alsologtostderr</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
表示将日志输出到文件的同时输出到 stderr
</td>
</tr>
<tr>
<td colspan=2>--as string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
以指定用户的身份执行操作
</td>
</tr>
<tr>
<td colspan=2>--as-group stringArray</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
模拟指定的组来执行操作，可以使用这个标志来指定多个组。
</td>
</tr>
<tr>
<td colspan=2>--azure-container-registry-config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
包含 Azure 容器仓库配置信息的文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--cache-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值: "$HOME/.kube/cache"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
默认缓存目录
</td>
</tr>
<tr>
<td colspan=2>--certificate-authority string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指向证书机构的 cert 文件路径
</td>
</tr>
<tr>
<td colspan=2>--client-certificate string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
TLS 使用的客户端证书路径
</td>
</tr>
<tr>
<td colspan=2>--client-key string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
TLS 使用的客户端密钥文件路径
</td>
</tr>
<tr>
<td colspan=2>--cloud-provider-gce-l7lb-src-cidrs cidrs&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值: 130.211.0.0/22,35.191.0.0/16</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
在 GCE 防火墙中开放的 CIDR，用来进行 L7 LB 流量代理和健康检查。
</td>
</tr>
<tr>
<td colspan=2>--cloud-provider-gce-lb-src-cidrs cidrs&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值: 130.211.0.0/22,209.85.152.0/22,209.85.204.0/22,35.191.0.0/16</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
在 GCE 防火墙中开放的 CIDR，用来进行 L4 LB 流量代理和健康检查。
</td>
</tr>
<tr>
<td colspan=2>--cluster string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
要使用的 kubeconfig 集群的名称
</td>
</tr>
<tr>
<td colspan=2>--context string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
要使用的 kubeconfig 上下文的名称
</td>
</tr>
<tr>
<td colspan=2>--default-not-ready-toleration-seconds int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值: 300</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
表示 `notReady` 状态的容忍度秒数：默认情况下，`NoExecute` 被添加到尚未具有此容忍度的每个 Pod 中。
</td>
</tr>
<tr>
<td colspan=2>--default-unreachable-toleration-seconds int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值: 300</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
表示 `unreachable` 状态的容忍度秒数：默认情况下，`NoExecute` 被添加到尚未具有此容忍度的每个 Pod 中。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubectl 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>--insecure-skip-tls-verify</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
设置为 true，则表示不会检查服务器证书的有效性。这样会导致您的 HTTPS 连接不安全。
</td>
</tr>
<tr>
<td colspan=2>--kubeconfig string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
CLI 请求使用的 kubeconfig 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--log-backtrace-at traceLocation&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值: 0</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
当日志机制运行到指定文件的指定行（file:N）时，打印调用堆栈信息
</td>
</tr>
<tr>
<td colspan=2>--log-dir string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果不为空，则将日志文件写入此目录
</td>
</tr>
<tr>
<td colspan=2>--log-file string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果不为空，则将使用此日志文件
</td>
</tr>
<tr>
<td colspan=2>--log-file-max-size uint&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值: 1800</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
定义日志文件的最大尺寸。单位为兆字节。如果值设置为 0，则表示日志文件大小不受限制。
</td>
</tr>
<tr>
<td colspan=2>--log-flush-frequency duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值: 5s</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
两次日志刷新操作之间的最长时间（秒）
</td>
</tr>
<tr>
<td colspan=2>--logtostderr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值: true</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
日志输出到 stderr 而不是文件中
</td>
</tr>
<tr>
<td colspan=2>--match-server-version</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
要求客户端版本和服务端版本相匹配
</td>
</tr>
<tr>
<td colspan=2>-n, --namespace string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果存在，CLI 请求将使用此命名空间
</td>
<tr>
<td colspan=2>--one-output</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果为 true，则只将日志写入初始严重级别（而不是同时写入所有较低的严重级别）。
</td>
</tr>
</tr>
<tr>
<td colspan=2>--password string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
API 服务器进行基本身份验证的密码
</td>
</tr>
<tr>
<td colspan=2>--profile string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值: "none"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
要记录的性能指标的名称。可取 (none|cpu|heap|goroutine|threadcreate|block|mutex) 其中之一。
</td>
</tr>
<tr>
<td colspan=2>--profile-output string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值: "profile.pprof"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
用于转储所记录的性能信息的文件名
</td>
</tr>
<tr>
<td colspan=2>--request-timeout string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值: "0"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
放弃单个服务器请求之前的等待时间，非零值需要包含相应时间单位（例如：1s、2m、3h）。零值则表示不做超时要求。
</td>
</tr>
<tr>
<td colspan=2>-s, --server string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
Kubernetes API 服务器的地址和端口
</td>
</tr>
<tr>
<td colspan=2>--skip-headers</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
设置为 true 则表示跳过在日志消息中出现 header 前缀信息
</td>
</tr>
<tr>
<td colspan=2>--skip-log-headers</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
设置为 true 则表示在打开日志文件时跳过 header 信息
</td>
</tr>
<tr>
<td colspan=2>--stderrthreshold severity&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值: 2</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
等于或高于此阈值的日志将输出到标准错误输出（stderr）
</td>
</tr>
<tr>
<td colspan=2>--token string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
用于对 API 服务器进行身份认证的持有者令牌
</td>
</tr>
<tr>
<td colspan=2>--user string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指定使用 kubeconfig 配置文件中的用户名
</td>
</tr>
<tr>
<td colspan=2>--username string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
用于 API 服务器的基本身份验证的用户名
</td>
</tr>
<tr>
<td colspan=2>-v, --v Level</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指定输出日志的日志详细级别
</td>
</tr>
<tr>
<td colspan=2>--version version[=true]</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
打印 kubectl 版本信息并退出
</td>
</tr>
<tr>
<td colspan=2>--vmodule moduleSpec</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
以逗号分隔的 pattern=N 设置列表，用于过滤文件的日志记录
</td>
</tr>
</tbody>
</table>
<h2 id=environment-variables>Environment variables</h2>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>KUBECONFIG</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubectl 的配置 ("kubeconfig") 文件的路径。默认值: "$HOME/.kube/config"
</td>
</tr>
<tr>
<td colspan=2>KUBECTL_COMMAND_HEADERS</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
设置为 false 时，关闭用于详细说明被调用的 kubectl 命令的额外 HTTP 标头 (Kubernetes 版本为 v1.22 或者更高)
</td>
</tr>
</tbody>
</table>
<h2 id=see-also>See Also</h2>
<ul>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands#annotate>kubectl annotate</a> - 更新资源所关联的注解</li>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands#api-resources>kubectl api-resources</a> - 打印服务器上所支持的 API 资源</li>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands#api-versions>kubectl api-versions</a> - 以“组/版本”的格式输出服务端所支持的 API 版本</li>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands#apply>kubectl apply</a> - 基于文件名或标准输入，将新的配置应用到资源上</li>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands#attach>kubectl attach</a> - 连接到一个正在运行的容器</li>
</ul>
<ul>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands#auth>kubectl auth</a> - 检查授权信息</li>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands#autoscale>kubectl autoscale</a> - 对一个资源对象（Deployment、ReplicaSet 或 ReplicationController ）进行扩缩</li>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands#certificate>kubectl certificate</a> - 修改证书资源</li>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands#cluster-info>kubectl cluster-info</a> - 显示集群信息</li>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands#completion>kubectl completion</a> - 根据已经给出的 Shell（bash 或 zsh），输出 Shell 补全后的代码</li>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands#config>kubectl config</a> - 修改 kubeconfig 配置文件</li>
</ul>
<ul>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands#convert>kubectl convert</a> - 在不同的 API 版本之间转换配置文件</li>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands#cordon>kubectl cordon</a> - 标记节点为不可调度的</li>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands#cp>kubectl cp</a> - 将文件和目录拷入/拷出容器</li>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands#create>kubectl create</a> - 通过文件或标准输入来创建资源</li>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands#debug>kubectl debug</a> - 创建用于排查工作负载和节点故障的调试会话</li>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands#delete>kubectl delete</a> - 通过文件名、标准输入、资源和名字删除资源，或者通过资源和标签选择器来删除资源</li>
</ul>
<ul>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands#describe>kubectl describe</a> - 显示某个资源或某组资源的详细信息</li>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands#diff>kubectl diff</a> - 显示目前版本与将要应用的版本之间的差异</li>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands#drain>kubectl drain</a> - 腾空节点，准备维护</li>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands#edit>kubectl edit</a> - 修改服务器上的某资源</li>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands#exec>kubectl exec</a> - 在容器中执行相关命令</li>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands#explain>kubectl explain</a> - 显示资源文档说明</li>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands#expose>kubectl expose</a> - 给定副本控制器、服务、Deployment 或 Pod，将其暴露为新的 kubernetes Service</li>
</ul>
<ul>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands#get>kubectl get</a> - 显示一个或者多个资源信息</li>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands#kustomize>kubectl kustomize</a> - 从目录或远程 URL 中构建 kustomization</li>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands#label>kubectl label</a> - 更新资源的标签</li>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands#logs>kubectl logs</a> - 输出 pod 中某容器的日志</li>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands#options>kubectl options</a> - 打印所有命令都支持的共有参数列表</li>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands#patch>kubectl patch</a> - 基于策略性合并修补（Stategic Merge Patch）规则更新某资源中的字段</li>
</ul>
<ul>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands#plugin>kubectl plugin</a> - 运行命令行插件</li>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands#port-forward>kubectl port-forward</a> - 将一个或者多个本地端口转发到 pod</li>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands#proxy>kubectl proxy</a> - 运行一个 kubernetes API 服务器代理</li>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands#replace>kubectl replace</a> - 基于文件名或标准输入替换资源</li>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands#rollout>kubectl rollout</a> - 管理资源的上线</li>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands#run>kubectl run</a> - 在集群中使用指定镜像启动容器</li>
</ul>
<ul>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands#scale>kubectl scale</a> - 为一个 Deployment、ReplicaSet 或 ReplicationController 设置一个新的规模尺寸值</li>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands#set>kubectl set</a> - 为对象设置功能特性</li>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands#taint>kubectl taint</a> - 在一个或者多个节点上更新污点配置</li>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands#top>kubectl top</a> - 显示资源（CPU /内存/存储）使用率</li>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands#uncordon>kubectl uncordon</a> - 标记节点为可调度的</li>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands#version>kubectl version</a> - 打印客户端和服务器的版本信息</li>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands#wait>kubectl wait</a> - 实验性：等待一个或多个资源达到某种状态</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-a938176c695852fe70362c29cf615f1c>10.4 - JSONPath 支持</h1>
<p>Kubectl 支持 JSONPath 模板。</p>
<p>JSONPath 模板由 {} 包起来的 JSONPath 表达式组成。Kubectl 使用 JSONPath 表达式来过滤 JSON 对象中的特定字段并格式化输出。除了原始的 JSONPath 模板语法，以下函数和语法也是有效的:</p>
<ol>
<li>使用双引号将 JSONPath 表达式内的文本引起来。</li>
<li>使用 <code>range</code>，<code>end</code> 运算符来迭代列表。</li>
<li>使用负片索引后退列表。负索引不会“环绕”列表，并且只要 <code>-index + listLength> = 0</code> 就有效。</li>
</ol>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong>
<ul>
<li>
<p><code>$</code> 运算符是可选的，因为默认情况下表达式总是从根对象开始。</p>
</li>
<li>
<p>结果对象将作为其 String() 函数输出。</p>
</li>
</ul>
</div>
<p>给定 JSON 输入:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;List&#34;</span>,
  <span style=color:green;font-weight:700>&#34;items&#34;</span>:[
    {
      <span style=color:green;font-weight:700>&#34;kind&#34;</span>:<span style=color:#b44>&#34;None&#34;</span>,
      <span style=color:green;font-weight:700>&#34;metadata&#34;</span>:{<span style=color:green;font-weight:700>&#34;name&#34;</span>:<span style=color:#b44>&#34;127.0.0.1&#34;</span>},
      <span style=color:green;font-weight:700>&#34;status&#34;</span>:{
        <span style=color:green;font-weight:700>&#34;capacity&#34;</span>:{<span style=color:green;font-weight:700>&#34;cpu&#34;</span>:<span style=color:#b44>&#34;4&#34;</span>},
        <span style=color:green;font-weight:700>&#34;addresses&#34;</span>:[{<span style=color:green;font-weight:700>&#34;type&#34;</span>: <span style=color:#b44>&#34;LegacyHostIP&#34;</span>, <span style=color:green;font-weight:700>&#34;address&#34;</span>:<span style=color:#b44>&#34;127.0.0.1&#34;</span>}]
      }
    },
    {
      <span style=color:green;font-weight:700>&#34;kind&#34;</span>:<span style=color:#b44>&#34;None&#34;</span>,
      <span style=color:green;font-weight:700>&#34;metadata&#34;</span>:{<span style=color:green;font-weight:700>&#34;name&#34;</span>:<span style=color:#b44>&#34;127.0.0.2&#34;</span>},
      <span style=color:green;font-weight:700>&#34;status&#34;</span>:{
        <span style=color:green;font-weight:700>&#34;capacity&#34;</span>:{<span style=color:green;font-weight:700>&#34;cpu&#34;</span>:<span style=color:#b44>&#34;8&#34;</span>},
        <span style=color:green;font-weight:700>&#34;addresses&#34;</span>:[
          {<span style=color:green;font-weight:700>&#34;type&#34;</span>: <span style=color:#b44>&#34;LegacyHostIP&#34;</span>, <span style=color:green;font-weight:700>&#34;address&#34;</span>:<span style=color:#b44>&#34;127.0.0.2&#34;</span>},
          {<span style=color:green;font-weight:700>&#34;type&#34;</span>: <span style=color:#b44>&#34;another&#34;</span>, <span style=color:green;font-weight:700>&#34;address&#34;</span>:<span style=color:#b44>&#34;127.0.0.3&#34;</span>}
        ]
      }
    }
  ],
  <span style=color:green;font-weight:700>&#34;users&#34;</span>:[
    {
      <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;myself&#34;</span>,
      <span style=color:green;font-weight:700>&#34;user&#34;</span>: {}
    },
    {
      <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;e2e&#34;</span>,
      <span style=color:green;font-weight:700>&#34;user&#34;</span>: {<span style=color:green;font-weight:700>&#34;username&#34;</span>: <span style=color:#b44>&#34;admin&#34;</span>, <span style=color:green;font-weight:700>&#34;password&#34;</span>: <span style=color:#b44>&#34;secret&#34;</span>}
    }
  ]
}
</code></pre></div>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
<th>示例</th>
<th>结果</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>text</code></td>
<td>纯文本</td>
<td><code>kind is {.kind}</code></td>
<td><code>kind is List</code></td>
</tr>
<tr>
<td><code>@</code></td>
<td>当前对象</td>
<td><code>{@}</code></td>
<td>与输入相同</td>
</tr>
<tr>
<td><code>.</code> or <code>[]</code></td>
<td>子运算符</td>
<td><code>{.kind}</code>, <code>{['kind']}</code> or <code>{['name\.type']}</code></td>
<td><code>List</code></td>
</tr>
<tr>
<td><code>..</code></td>
<td>递归下降</td>
<td><code>{..name}</code></td>
<td><code>127.0.0.1 127.0.0.2 myself e2e</code></td>
</tr>
<tr>
<td><code>*</code></td>
<td>通配符。获取所有对象</td>
<td><code>{.items[*].metadata.name}</code></td>
<td><code>[127.0.0.1 127.0.0.2]</code></td>
</tr>
<tr>
<td><code>[start:end :step]</code></td>
<td>下标运算符</td>
<td><code>{.users[0].name}</code></td>
<td><code>myself</code></td>
</tr>
<tr>
<td><code>[,]</code></td>
<td>并集运算符</td>
<td><code>{.items[*]['metadata.name', 'status.capacity']}</code></td>
<td><code>127.0.0.1 127.0.0.2 map[cpu:4] map[cpu:8]</code></td>
</tr>
<tr>
<td><code>?()</code></td>
<td>过滤</td>
<td><code>{.users[?(@.name=="e2e")].user.password}</code></td>
<td><code>secret</code></td>
</tr>
<tr>
<td><code>range</code>, <code>end</code></td>
<td>迭代列表</td>
<td><code>{range .items[*]}[{.metadata.name}, {.status.capacity}] {end}</code></td>
<td><code>[127.0.0.1, map[cpu:4]] [127.0.0.2, map[cpu:8]]</code></td>
</tr>
<tr>
<td><code>''</code></td>
<td>引用解释执行字符串</td>
<td><code>{range .items[*]}{.metadata.name}{'\t'}{end}</code></td>
<td><code>127.0.0.1 127.0.0.2</code></td>
</tr>
</tbody>
</table>
<p>使用 <code>kubectl</code> 和 JSONPath 表达式的示例:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods -o json
kubectl get pods -o<span style=color:#666>=</span><span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{@}&#39;</span>
kubectl get pods -o<span style=color:#666>=</span><span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.items[0]}&#39;</span>
kubectl get pods -o<span style=color:#666>=</span><span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.items[0].metadata.name}&#39;</span>
kubectl get pods -o<span style=color:#666>=</span><span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#34;{.items[*][&#39;metadata.name&#39;, &#39;status.capacity&#39;]}&#34;</span>
kubectl get pods -o<span style=color:#666>=</span><span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{range .items[*]}{.metadata.name}{&#34;\t&#34;}{.status.startTime}{&#34;\n&#34;}{end}&#39;</span>
</code></pre></div>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> <p>在 Windows 上，对于任何包含空格的 JSONPath 模板，您必须使用双引号（不是上面 bash 所示的单引号）。
反过来，这意味着您必须在模板中的所有文字周围使用单引号或转义的双引号。
例如:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cmd data-lang=cmd>C:<span style=color:#a0a000>\</span><span style=color:#080;font-style:italic>&gt; kubectl get pods -o=jsonpath=&#34;{range .items[*]}{.metadata.name}{&#39;\t&#39;}{.status.startTime}{&#39;\n&#39;}{end}&#34;</span>
C:<span style=color:#a0a000>\</span><span style=color:#080;font-style:italic>&gt; kubectl get pods -o=jsonpath=&#34;{range .items[*]}{.metadata.name}{\&#34;\t\&#34;}{.status.startTime}{\&#34;\n\&#34;}{end}&#34;</span>
</code></pre></div>
</div>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> <p>不支持 JSONPath 正则表达式。如需使用正则表达式进行匹配操作，您可以使用如 <code>jq</code> 之类的工具。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># kubectl 的 JSONpath 输出不支持正则表达式</span>
<span style=color:#080;font-style:italic># 下面的命令不会生效</span>
kubectl get pods -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.items[?(@.metadata.name=~/^test$/)].metadata.name}&#39;</span>

<span style=color:#080;font-style:italic># 下面的命令可以获得所需的结果</span>
kubectl get pods -o json | jq -r <span style=color:#b44>&#39;.items[] | select(.metadata.name | test(&#34;test-&#34;)).spec.containers[].image&#39;</span>
</code></pre></div>
</div>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-8aba901ac13f124e5782b90ddb166ee2>10.5 - kubectl 备忘单</h1>
<p>本页列举了常用的 “kubectl” 命令和标志</p>
<h2 id=kubectl-自动补全>Kubectl 自动补全</h2>
<h3 id=bash>BASH</h3>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#a2f>source</span> &lt;<span style=color:#666>(</span>kubectl completion bash<span style=color:#666>)</span> <span style=color:#080;font-style:italic># 在 bash 中设置当前 shell 的自动补全，要先安装 bash-completion 包。</span>
<span style=color:#a2f>echo</span> <span style=color:#b44>&#34;source &lt;(kubectl completion bash)&#34;</span> &gt;&gt; ~/.bashrc <span style=color:#080;font-style:italic># 在您的 bash shell 中永久的添加自动补全</span>
</code></pre></div><p>您还可以为 <code>kubectl</code> 使用一个速记别名，该别名也可以与 completion 一起使用：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#a2f>alias</span> <span style=color:#b8860b>k</span><span style=color:#666>=</span>kubectl
<span style=color:#a2f>complete</span> -F __start_kubectl k
</code></pre></div><h3 id=zsh>ZSH</h3>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#a2f>source</span> &lt;<span style=color:#666>(</span>kubectl completion zsh<span style=color:#666>)</span>  <span style=color:#080;font-style:italic># 在 zsh 中设置当前 shell 的自动补全</span>
<span style=color:#a2f>echo</span> <span style=color:#b44>&#34;[[ </span><span style=color:#b8860b>$commands</span><span style=color:#b44>[kubectl] ]] &amp;&amp; source &lt;(kubectl completion zsh)&#34;</span> &gt;&gt; ~/.zshrc <span style=color:#080;font-style:italic># 在您的 zsh shell 中永久的添加自动补全</span>
</code></pre></div>
<h2 id=kubectl-上下文和配置>Kubectl 上下文和配置</h2>
<p>设置 <code>kubectl</code> 与哪个 Kubernetes 集群进行通信并修改配置信息。
查看<a href=/zh/docs/tasks/access-application-cluster/configure-access-multiple-clusters/>使用 kubeconfig 跨集群授权访问</a>
文档获取配置文件详细信息。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl config view <span style=color:#080;font-style:italic># 显示合并的 kubeconfig 配置。</span>

<span style=color:#080;font-style:italic># 同时使用多个 kubeconfig 文件并查看合并的配置</span>
<span style=color:#b8860b>KUBECONFIG</span><span style=color:#666>=</span>~/.kube/config:~/.kube/kubconfig2 kubectl config view

<span style=color:#080;font-style:italic># 获取 e2e 用户的密码</span>
kubectl config view -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.users[?(@.name == &#34;e2e&#34;)].user.password}&#39;</span>

kubectl config view -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.users[].name}&#39;</span>    <span style=color:#080;font-style:italic># 显示第一个用户</span>
kubectl config view -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.users[*].name}&#39;</span>   <span style=color:#080;font-style:italic># 获取用户列表</span>
kubectl config get-contexts                          <span style=color:#080;font-style:italic># 显示上下文列表</span>
kubectl config current-context                       <span style=color:#080;font-style:italic># 展示当前所处的上下文</span>
kubectl config use-context my-cluster-name           <span style=color:#080;font-style:italic># 设置默认的上下文为 my-cluster-name</span>

<span style=color:#080;font-style:italic># 添加新的用户配置到 kubeconf 中，使用 basic auth 进行身份认证</span>
kubectl config set-credentials kubeuser/foo.kubernetes.com --username<span style=color:#666>=</span>kubeuser --password<span style=color:#666>=</span>kubepassword

<span style=color:#080;font-style:italic># 在指定上下文中持久性地保存名字空间，供所有后续 kubectl 命令使用</span>
kubectl config set-context --current --namespace<span style=color:#666>=</span>ggckad-s2

<span style=color:#080;font-style:italic># 使用特定的用户名和名字空间设置上下文</span>
kubectl config set-context gce --user<span style=color:#666>=</span>cluster-admin --namespace<span style=color:#666>=</span>foo <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  <span style=color:#666>&amp;&amp;</span> kubectl config use-context gce

kubectl config <span style=color:#a2f>unset</span> users.foo                       <span style=color:#080;font-style:italic># 删除用户 foo</span>
</code></pre></div>
<h2 id=kubectl-apply>Kubectl apply</h2>
<p><code>apply</code> 通过定义 Kubernetes 资源的文件来管理应用。
它通过运行 <code>kubectl apply</code> 在集群中创建和更新资源。
这是在生产中管理 Kubernetes 应用的推荐方法。
参见 <a href=https://kubectl.docs.kubernetes.io>Kubectl 文档</a>。</p>
<h2 id=creating-objects>创建对象</h2>
<p>Kubernetes 配置可以用 YAML 或 JSON 定义。可以使用的文件扩展名有
<code>.yaml</code>、<code>.yml</code> 和 <code>.json</code>。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl apply -f ./my-manifest.yaml           <span style=color:#080;font-style:italic># 创建资源</span>
kubectl apply -f ./my1.yaml -f ./my2.yaml     <span style=color:#080;font-style:italic># 使用多个文件创建</span>
kubectl apply -f ./dir                        <span style=color:#080;font-style:italic># 基于目录下的所有清单文件创建资源</span>
kubectl apply -f https://git.io/vPieo         <span style=color:#080;font-style:italic># 从 URL 中创建资源</span>
kubectl create deployment nginx --image<span style=color:#666>=</span>nginx <span style=color:#080;font-style:italic># 启动单实例 nginx</span>

<span style=color:#080;font-style:italic># 创建一个打印 “Hello World” 的 Job</span>
kubectl create job hello --image<span style=color:#666>=</span>busybox -- <span style=color:#a2f>echo</span> <span style=color:#b44>&#34;Hello World&#34;</span> 

<span style=color:#080;font-style:italic># 创建一个打印 “Hello World” 间隔1分钟的 CronJob</span>
kubectl create cronjob hello --image<span style=color:#666>=</span>busybox   --schedule<span style=color:#666>=</span><span style=color:#b44>&#34;*/1 * * * *&#34;</span> -- <span style=color:#a2f>echo</span> <span style=color:#b44>&#34;Hello World&#34;</span>    

kubectl explain pods                          <span style=color:#080;font-style:italic># 获取 pod 清单的文档说明</span>

<span style=color:#080;font-style:italic># 从标准输入创建多个 YAML 对象</span>
cat <span style=color:#b44>&lt;&lt;EOF | kubectl apply -f -
</span><span style=color:#b44>apiVersion: v1
</span><span style=color:#b44>kind: Pod
</span><span style=color:#b44>metadata:
</span><span style=color:#b44>  name: busybox-sleep
</span><span style=color:#b44>spec:
</span><span style=color:#b44>  containers:
</span><span style=color:#b44>  - name: busybox
</span><span style=color:#b44>    image: busybox
</span><span style=color:#b44>    args:
</span><span style=color:#b44>    - sleep
</span><span style=color:#b44>    - &#34;1000000&#34;
</span><span style=color:#b44>---
</span><span style=color:#b44>apiVersion: v1
</span><span style=color:#b44>kind: Pod
</span><span style=color:#b44>metadata:
</span><span style=color:#b44>  name: busybox-sleep-less
</span><span style=color:#b44>spec:
</span><span style=color:#b44>  containers:
</span><span style=color:#b44>  - name: busybox
</span><span style=color:#b44>    image: busybox
</span><span style=color:#b44>    args:
</span><span style=color:#b44>    - sleep
</span><span style=color:#b44>    - &#34;1000&#34;
</span><span style=color:#b44>EOF</span>

<span style=color:#080;font-style:italic># 创建有多个 key 的 Secret</span>
cat <span style=color:#b44>&lt;&lt;EOF | kubectl apply -f -
</span><span style=color:#b44>apiVersion: v1
</span><span style=color:#b44>kind: Secret
</span><span style=color:#b44>metadata:
</span><span style=color:#b44>  name: mysecret
</span><span style=color:#b44>type: Opaque
</span><span style=color:#b44>data:
</span><span style=color:#b44>  password: $(echo -n &#34;s33msi4&#34; | base64 -w0)
</span><span style=color:#b44>  username: $(echo -n &#34;jane&#34; | base64 -w0)
</span><span style=color:#b44>EOF</span>
</code></pre></div>
<h2 id=查看和查找资源>查看和查找资源</h2>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#080;font-style:italic># get 命令的基本输出</span>
kubectl get services                          <span style=color:#080;font-style:italic># 列出当前命名空间下的所有 services</span>
kubectl get pods --all-namespaces             <span style=color:#080;font-style:italic># 列出所有命名空间下的全部的 Pods</span>
kubectl get pods -o wide                      <span style=color:#080;font-style:italic># 列出当前命名空间下的全部 Pods，并显示更详细的信息</span>
kubectl get deployment my-dep                 <span style=color:#080;font-style:italic># 列出某个特定的 Deployment</span>
kubectl get pods                              <span style=color:#080;font-style:italic># 列出当前命名空间下的全部 Pods</span>
kubectl get pod my-pod -o yaml                <span style=color:#080;font-style:italic># 获取一个 pod 的 YAML</span>

<span style=color:#080;font-style:italic># describe 命令的详细输出</span>
kubectl describe nodes my-node
kubectl describe pods my-pod

<span style=color:#080;font-style:italic># 列出当前名字空间下所有 Services，按名称排序</span>
kubectl get services --sort-by<span style=color:#666>=</span>.metadata.name

<span style=color:#080;font-style:italic># 列出 Pods，按重启次数排序</span>
kubectl get pods --sort-by<span style=color:#666>=</span><span style=color:#b44>&#39;.status.containerStatuses[0].restartCount&#39;</span>

<span style=color:#080;font-style:italic># 列举所有 PV 持久卷，按容量排序</span>
kubectl get pv --sort-by<span style=color:#666>=</span>.spec.capacity.storage

<span style=color:#080;font-style:italic># 获取包含 app=cassandra 标签的所有 Pods 的 version 标签</span>
kubectl get pods --selector<span style=color:#666>=</span><span style=color:#b8860b>app</span><span style=color:#666>=</span>cassandra -o <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.items[*].metadata.labels.version}&#39;</span>

<span style=color:#080;font-style:italic># 检索带有 “.” 键值，例： &#39;ca.crt&#39;</span>
kubectl get configmap myconfig <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.data.ca\.crt}&#39;</span>

<span style=color:#080;font-style:italic># 获取所有工作节点（使用选择器以排除标签名称为 &#39;node-role.kubernetes.io/master&#39; 的结果）</span>
kubectl get node --selector<span style=color:#666>=</span><span style=color:#b44>&#39;!node-role.kubernetes.io/master&#39;</span>

<span style=color:#080;font-style:italic># 获取当前命名空间中正在运行的 Pods</span>
kubectl get pods --field-selector<span style=color:#666>=</span>status.phase<span style=color:#666>=</span>Running

<span style=color:#080;font-style:italic># 获取全部节点的 ExternalIP 地址</span>
kubectl get nodes -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.items[*].status.addresses[?(@.type==&#34;ExternalIP&#34;)].address}&#39;</span>

<span style=color:#080;font-style:italic># 列出属于某个特定 RC 的 Pods 的名称</span>
<span style=color:#080;font-style:italic># 在转换对于 jsonpath 过于复杂的场合，&#34;jq&#34; 命令很有用；可以在 https://stedolan.github.io/jq/ 找到它。</span>
<span style=color:#b8860b>sel</span><span style=color:#666>=</span><span style=color:#b68;font-weight:700>${</span><span style=color:#a2f;font-weight:700>$(</span>kubectl get rc my-rc --output<span style=color:#666>=</span>json | jq -j <span style=color:#b44>&#39;.spec.selector | to_entries | .[] | &#34;\(.key)=\(.value),&#34;&#39;</span><span style=color:#a2f;font-weight:700>)</span>%?<span style=color:#b68;font-weight:700>}</span>
<span style=color:#a2f>echo</span> <span style=color:#a2f;font-weight:700>$(</span>kubectl get pods --selector<span style=color:#666>=</span><span style=color:#b8860b>$sel</span> --output<span style=color:#666>=</span><span style=color:#b8860b>jsonpath</span><span style=color:#666>={</span>.items..metadata.name<span style=color:#666>}</span><span style=color:#a2f;font-weight:700>)</span>

<span style=color:#080;font-style:italic># 显示所有 Pods 的标签（或任何其他支持标签的 Kubernetes 对象）</span>
kubectl get pods --show-labels

<span style=color:#080;font-style:italic># 检查哪些节点处于就绪状态</span>
<span style=color:#b8860b>JSONPATH</span><span style=color:#666>=</span><span style=color:#b44>&#39;{range .items[*]}{@.metadata.name}:{range @.status.conditions[*]}{@.type}={@.status};{end}{end}&#39;</span> <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span> <span style=color:#666>&amp;&amp;</span> kubectl get nodes -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#34;</span><span style=color:#b8860b>$JSONPATH</span><span style=color:#b44>&#34;</span> | grep <span style=color:#b44>&#34;Ready=True&#34;</span>

<span style=color:#080;font-style:italic># 不使用外部工具来输出解码后的 Secret</span>
kubectl get secret my-secret -o go-template<span style=color:#666>=</span><span style=color:#b44>&#39;{{range $k,$v := .data}}{{&#34;### &#34;}}{{$k}}{{&#34;\n&#34;}}{{$v|base64decode}}{{&#34;\n\n&#34;}}{{end}}&#39;</span>

<span style=color:#080;font-style:italic># 列出被一个 Pod 使用的全部 Secret</span>
kubectl get pods -o json | jq <span style=color:#b44>&#39;.items[].spec.containers[].env[]?.valueFrom.secretKeyRef.name&#39;</span> | grep -v null | sort | uniq

<span style=color:#080;font-style:italic># 列举所有 Pods 中初始化容器的容器 ID（containerID）</span>
<span style=color:#080;font-style:italic># 可用于在清理已停止的容器时避免删除初始化容器</span>
kubectl get pods --all-namespaces -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{range .items[*].status.initContainerStatuses[*]}{.containerID}{&#34;\n&#34;}{end}&#39;</span> | cut -d/ -f3

<span style=color:#080;font-style:italic># 列出事件（Events），按时间戳排序</span>
kubectl get events --sort-by<span style=color:#666>=</span>.metadata.creationTimestamp

<span style=color:#080;font-style:italic># 比较当前的集群状态和假定某清单被应用之后的集群状态</span>
kubectl diff -f ./my-manifest.yaml

<span style=color:#080;font-style:italic># 生成一个句点分隔的树，其中包含为节点返回的所有键</span>
<span style=color:#080;font-style:italic># 在复杂的嵌套JSON结构中定位键时非常有用</span>
kubectl get nodes -o json | jq -c <span style=color:#b44>&#39;path(..)|[.[]|tostring]|join(&#34;.&#34;)&#39;</span>

<span style=color:#080;font-style:italic># 生成一个句点分隔的树，其中包含为pod等返回的所有键</span>
kubectl get pods -o json | jq -c <span style=color:#b44>&#39;path(..)|[.[]|tostring]|join(&#34;.&#34;)&#39;</span>

<span style=color:#080;font-style:italic># 假设你的 Pods 有默认的容器和默认的名字空间，并且支持 &#39;env&#39; 命令，可以使用以下脚本为所有 Pods 生成 ENV 变量。</span>
<span style=color:#080;font-style:italic># 该脚本也可用于在所有的 Pods 里运行任何受支持的命令，而不仅仅是 &#39;env&#39;。 </span>
<span style=color:#a2f;font-weight:700>for</span> pod in <span style=color:#a2f;font-weight:700>$(</span>kubectl get po --output<span style=color:#666>=</span><span style=color:#b8860b>jsonpath</span><span style=color:#666>={</span>.items..metadata.name<span style=color:#666>}</span><span style=color:#a2f;font-weight:700>)</span>; <span style=color:#a2f;font-weight:700>do</span> <span style=color:#a2f>echo</span> <span style=color:#b8860b>$pod</span> <span style=color:#666>&amp;&amp;</span> kubectl <span style=color:#a2f>exec</span> -it <span style=color:#b8860b>$pod</span> -- env; <span style=color:#a2f;font-weight:700>done</span>
</code></pre></div>
<h2 id=更新资源>更新资源</h2>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl <span style=color:#a2f>set</span> image deployment/frontend <span style=color:#b8860b>www</span><span style=color:#666>=</span>image:v2               <span style=color:#080;font-style:italic># 滚动更新 &#34;frontend&#34; Deployment 的 &#34;www&#34; 容器镜像</span>
kubectl rollout <span style=color:#a2f>history</span> deployment/frontend                      <span style=color:#080;font-style:italic># 检查 Deployment 的历史记录，包括版本</span>
kubectl rollout undo deployment/frontend                         <span style=color:#080;font-style:italic># 回滚到上次部署版本</span>
kubectl rollout undo deployment/frontend --to-revision<span style=color:#666>=</span><span style=color:#666>2</span>         <span style=color:#080;font-style:italic># 回滚到特定部署版本</span>
kubectl rollout status -w deployment/frontend                    <span style=color:#080;font-style:italic># 监视 &#34;frontend&#34; Deployment 的滚动升级状态直到完成</span>
kubectl rollout restart deployment/frontend                      <span style=color:#080;font-style:italic># 轮替重启 &#34;frontend&#34; Deployment</span>

cat pod.json | kubectl replace -f -                              <span style=color:#080;font-style:italic># 通过传入到标准输入的 JSON 来替换 Pod</span>

<span style=color:#080;font-style:italic># 强制替换，删除后重建资源。会导致服务不可用。</span>
kubectl replace --force -f ./pod.json

<span style=color:#080;font-style:italic># 为多副本的 nginx 创建服务，使用 80 端口提供服务，连接到容器的 8000 端口。</span>
kubectl expose rc nginx --port<span style=color:#666>=</span><span style=color:#666>80</span> --target-port<span style=color:#666>=</span><span style=color:#666>8000</span>

<span style=color:#080;font-style:italic># 将某单容器 Pod 的镜像版本（标签）更新到 v4</span>
kubectl get pod mypod -o yaml | sed <span style=color:#b44>&#39;s/\(image: myimage\):.*$/\1:v4/&#39;</span> | kubectl replace -f -

kubectl label pods my-pod new-label<span style=color:#666>=</span>awesome                      <span style=color:#080;font-style:italic># 添加标签</span>
kubectl annotate pods my-pod icon-url<span style=color:#666>=</span>http://goo.gl/XXBTWq       <span style=color:#080;font-style:italic># 添加注解</span>
kubectl autoscale deployment foo --min<span style=color:#666>=</span><span style=color:#666>2</span> --max<span style=color:#666>=</span><span style=color:#666>10</span>                <span style=color:#080;font-style:italic># 对 &#34;foo&#34; Deployment 自动伸缩容</span>
</code></pre></div>
<h2 id=部分更新资源>部分更新资源</h2>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#080;font-style:italic># 部分更新某节点</span>
kubectl patch node k8s-node-1 -p <span style=color:#b44>&#39;{&#34;spec&#34;:{&#34;unschedulable&#34;:true}}&#39;</span>

<span style=color:#080;font-style:italic># 更新容器的镜像；spec.containers[*].name 是必须的。因为它是一个合并性质的主键。</span>
kubectl patch pod valid-pod -p <span style=color:#b44>&#39;{&#34;spec&#34;:{&#34;containers&#34;:[{&#34;name&#34;:&#34;kubernetes-serve-hostname&#34;,&#34;image&#34;:&#34;new image&#34;}]}}&#39;</span>

<span style=color:#080;font-style:italic># 使用带位置数组的 JSON patch 更新容器的镜像</span>
kubectl patch pod valid-pod --type<span style=color:#666>=</span><span style=color:#b44>&#39;json&#39;</span> -p<span style=color:#666>=</span><span style=color:#b44>&#39;[{&#34;op&#34;: &#34;replace&#34;, &#34;path&#34;: &#34;/spec/containers/0/image&#34;, &#34;value&#34;:&#34;new image&#34;}]&#39;</span>

<span style=color:#080;font-style:italic># 使用带位置数组的 JSON patch 禁用某 Deployment 的 livenessProbe</span>
kubectl patch deployment valid-deployment  --type json   -p<span style=color:#666>=</span><span style=color:#b44>&#39;[{&#34;op&#34;: &#34;remove&#34;, &#34;path&#34;: &#34;/spec/template/spec/containers/0/livenessProbe&#34;}]&#39;</span>

<span style=color:#080;font-style:italic># 在带位置数组中添加元素</span>
kubectl patch sa default --type<span style=color:#666>=</span><span style=color:#b44>&#39;json&#39;</span> -p<span style=color:#666>=</span><span style=color:#b44>&#39;[{&#34;op&#34;: &#34;add&#34;, &#34;path&#34;: &#34;/secrets/1&#34;, &#34;value&#34;: {&#34;name&#34;: &#34;whatever&#34; } }]&#39;</span>
</code></pre></div>
<h2 id=编辑资源>编辑资源</h2>
<p>使用你偏爱的编辑器编辑 API 资源。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl edit svc/docker-registry                      <span style=color:#080;font-style:italic># 编辑名为 docker-registry 的服务</span>
<span style=color:#b8860b>KUBE_EDITOR</span><span style=color:#666>=</span><span style=color:#b44>&#34;nano&#34;</span> kubectl edit svc/docker-registry   <span style=color:#080;font-style:italic># 使用其他编辑器</span>
</code></pre></div>
<h2 id=对资源进行伸缩>对资源进行伸缩</h2>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl scale --replicas<span style=color:#666>=</span><span style=color:#666>3</span> rs/foo                                 <span style=color:#080;font-style:italic># 将名为 &#39;foo&#39; 的副本集伸缩到 3 副本</span>
kubectl scale --replicas<span style=color:#666>=</span><span style=color:#666>3</span> -f foo.yaml                            <span style=color:#080;font-style:italic># 将在 &#34;foo.yaml&#34; 中的特定资源伸缩到 3 个副本</span>
kubectl scale --current-replicas<span style=color:#666>=</span><span style=color:#666>2</span> --replicas<span style=color:#666>=</span><span style=color:#666>3</span> deployment/mysql  <span style=color:#080;font-style:italic># 如果名为 mysql 的 Deployment 的副本当前是 2，那么将它伸缩到 3</span>
kubectl scale --replicas<span style=color:#666>=</span><span style=color:#666>5</span> rc/foo rc/bar rc/baz                   <span style=color:#080;font-style:italic># 伸缩多个副本控制器</span>
</code></pre></div>
<h2 id=删除资源>删除资源</h2>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl delete -f ./pod.json                                              <span style=color:#080;font-style:italic># 删除在 pod.json 中指定的类型和名称的 Pod</span>
kubectl delete pod,service baz foo                                        <span style=color:#080;font-style:italic># 删除名称为 &#34;baz&#34; 和 &#34;foo&#34; 的 Pod 和服务</span>
kubectl delete pods,services -l <span style=color:#b8860b>name</span><span style=color:#666>=</span>myLabel                              <span style=color:#080;font-style:italic># 删除包含 name=myLabel 标签的 pods 和服务</span>
kubectl -n my-ns delete pod,svc --all                                     <span style=color:#080;font-style:italic># 删除在 my-ns 名字空间中全部的 Pods 和服务</span>
<span style=color:#080;font-style:italic># 删除所有与 pattern1 或 pattern2 awk 模式匹配的 Pods</span>
kubectl get pods  -n mynamespace --no-headers<span style=color:#666>=</span><span style=color:#a2f>true</span> | awk <span style=color:#b44>&#39;/pattern1|pattern2/{print $1}&#39;</span> | xargs  kubectl delete -n mynamespace pod
</code></pre></div>
<h2 id=与运行中的-pods-进行交互>与运行中的 Pods 进行交互</h2>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl logs my-pod                                 <span style=color:#080;font-style:italic># 获取 pod 日志（标准输出）</span>
kubectl logs -l <span style=color:#b8860b>name</span><span style=color:#666>=</span>myLabel                        <span style=color:#080;font-style:italic># 获取含 name=myLabel 标签的 Pods 的日志（标准输出）</span>
kubectl logs my-pod --previous                      <span style=color:#080;font-style:italic># 获取上个容器实例的 pod 日志（标准输出）</span>
kubectl logs my-pod -c my-container                 <span style=color:#080;font-style:italic># 获取 Pod 容器的日志（标准输出, 多容器场景）</span>
kubectl logs -l <span style=color:#b8860b>name</span><span style=color:#666>=</span>myLabel -c my-container        <span style=color:#080;font-style:italic># 获取含 name=myLabel 标签的 Pod 容器日志（标准输出, 多容器场景）</span>
kubectl logs my-pod -c my-container --previous      <span style=color:#080;font-style:italic># 获取 Pod 中某容器的上个实例的日志（标准输出, 多容器场景）</span>
kubectl logs -f my-pod                              <span style=color:#080;font-style:italic># 流式输出 Pod 的日志（标准输出）</span>
kubectl logs -f my-pod -c my-container              <span style=color:#080;font-style:italic># 流式输出 Pod 容器的日志（标准输出, 多容器场景）</span>
kubectl logs -f -l <span style=color:#b8860b>name</span><span style=color:#666>=</span>myLabel --all-containers    <span style=color:#080;font-style:italic># 流式输出含 name=myLabel 标签的 Pod 的所有日志（标准输出）</span>
kubectl run -i --tty busybox --image<span style=color:#666>=</span>busybox -- sh  <span style=color:#080;font-style:italic># 以交互式 Shell 运行 Pod</span>
kubectl run nginx --image<span style=color:#666>=</span>nginx -n mynamespace      <span style=color:#080;font-style:italic># 在指定名字空间中运行 nginx Pod</span>
kubectl run nginx --image<span style=color:#666>=</span>nginx                     <span style=color:#080;font-style:italic># 运行 ngins Pod 并将其规约写入到名为 pod.yaml 的文件</span>
  --dry-run<span style=color:#666>=</span>client -o yaml &gt; pod.yaml

kubectl attach my-pod -i                            <span style=color:#080;font-style:italic># 挂接到一个运行的容器中</span>
kubectl port-forward my-pod 5000:6000               <span style=color:#080;font-style:italic># 在本地计算机上侦听端口 5000 并转发到 my-pod 上的端口 6000</span>
kubectl <span style=color:#a2f>exec</span> my-pod -- ls /                         <span style=color:#080;font-style:italic># 在已有的 Pod 中运行命令（单容器场景）</span>
kubectl <span style=color:#a2f>exec</span> --stdin --tty my-pod -- /bin/sh        <span style=color:#080;font-style:italic># 使用交互 shell 访问正在运行的 Pod (一个容器场景)</span>
kubectl <span style=color:#a2f>exec</span> my-pod -c my-container -- ls /         <span style=color:#080;font-style:italic># 在已有的 Pod 中运行命令（多容器场景）</span>
kubectl top pod POD_NAME --containers               <span style=color:#080;font-style:italic># 显示给定 Pod 和其中容器的监控数据</span>
kubectl top pod POD_NAME --sort-by<span style=color:#666>=</span>cpu              <span style=color:#080;font-style:italic># 显示给定 Pod 的指标并且按照 &#39;cpu&#39; 或者 &#39;memory&#39; 排序</span>
</code></pre></div>
<h2 id=与-deployments-和-services-进行交互>与 Deployments 和 Services 进行交互</h2>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl logs deploy/my-deployment                         <span style=color:#080;font-style:italic># 获取一个 Deployment 的 Pod 的日志（单容器例子）</span>
kubectl logs deploy/my-deployment -c my-container         <span style=color:#080;font-style:italic># 获取一个 Deployment 的 Pod 的日志（多容器例子）</span>

kubectl port-forward svc/my-service <span style=color:#666>5000</span>                  <span style=color:#080;font-style:italic># 侦听本地端口 5000 并转发到 Service 后端端口 5000</span>
kubectl port-forward svc/my-service 5000:my-service-port  <span style=color:#080;font-style:italic># 侦听本地端口 5000 并转发到名字为 &lt;my-service-port&gt; 的 Service 目标端口</span>

kubectl port-forward deploy/my-deployment 5000:6000       <span style=color:#080;font-style:italic># 侦听本地端口 5000 并转发到 &lt;my-deployment&gt; 创建的 Pod 里的端口 6000</span>
kubectl <span style=color:#a2f>exec</span> deploy/my-deployment -- ls                   <span style=color:#080;font-style:italic># 在 Deployment 里的第一个 Pod 的第一个容器里运行命令（单容器和多容器例子）</span>
</code></pre></div>
<h2 id=与节点和集群进行交互>与节点和集群进行交互</h2>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl cordon my-node                                                <span style=color:#080;font-style:italic># 标记 my-node 节点为不可调度</span>
kubectl drain my-node                                                 <span style=color:#080;font-style:italic># 对 my-node 节点进行清空操作，为节点维护做准备</span>
kubectl uncordon my-node                                              <span style=color:#080;font-style:italic># 标记 my-node 节点为可以调度</span>
kubectl top node my-node                                              <span style=color:#080;font-style:italic># 显示给定节点的度量值</span>
kubectl cluster-info                                                  <span style=color:#080;font-style:italic># 显示主控节点和服务的地址</span>
kubectl cluster-info dump                                             <span style=color:#080;font-style:italic># 将当前集群状态转储到标准输出</span>
kubectl cluster-info dump --output-directory<span style=color:#666>=</span>/path/to/cluster-state   <span style=color:#080;font-style:italic># 将当前集群状态输出到 /path/to/cluster-state</span>

<span style=color:#080;font-style:italic># 如果已存在具有指定键和效果的污点，则替换其值为指定值。</span>
kubectl taint nodes foo <span style=color:#b8860b>dedicated</span><span style=color:#666>=</span>special-user:NoSchedule
</code></pre></div>
<h3 id=资源类型>资源类型</h3>
<p>列出所支持的全部资源类型和它们的简称、<a href=/zh/docs/concepts/overview/kubernetes-api/#api-groups-and-versioning>API 组</a>, 是否是<a href=/zh/docs/concepts/overview/working-with-objects/namespaces>名字空间作用域</a> 和 <a href=/zh/docs/concepts/overview/working-with-objects/kubernetes-objects>Kind</a>。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl api-resources
</code></pre></div>
<p>用于探索 API 资源的其他操作：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl api-resources --namespaced<span style=color:#666>=</span><span style=color:#a2f>true</span>      <span style=color:#080;font-style:italic># 所有命名空间作用域的资源</span>
kubectl api-resources --namespaced<span style=color:#666>=</span><span style=color:#a2f>false</span>     <span style=color:#080;font-style:italic># 所有非命名空间作用域的资源</span>
kubectl api-resources -o name                <span style=color:#080;font-style:italic># 用简单格式列举所有资源（仅显示资源名称）</span>
kubectl api-resources -o wide                <span style=color:#080;font-style:italic># 用扩展格式列举所有资源（又称 &#34;wide&#34; 格式）</span>
kubectl api-resources --verbs<span style=color:#666>=</span>list,get       <span style=color:#080;font-style:italic># 支持 &#34;list&#34; 和 &#34;get&#34; 请求动词的所有资源</span>
kubectl api-resources --api-group<span style=color:#666>=</span>extensions <span style=color:#080;font-style:italic># &#34;extensions&#34; API 组中的所有资源</span>
</code></pre></div>
<h3 id=格式化输出>格式化输出</h3>
<p>要以特定格式将详细信息输出到终端窗口，将 <code>-o</code>（或者 <code>--output</code>）参数添加到支持的 <code>kubectl</code> 命令中。</p>
<table>
<thead>
<tr>
<th>输出格式</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>-o=custom-columns=&lt;spec></code></td>
<td>使用逗号分隔的自定义列来打印表格</td>
</tr>
<tr>
<td><code>-o=custom-columns-file=&lt;filename></code></td>
<td>使用 <code>&lt;filename></code> 文件中的自定义列模板打印表格</td>
</tr>
<tr>
<td><code>-o=json</code></td>
<td>输出 JSON 格式的 API 对象</td>
</tr>
<tr>
<td><code>-o=jsonpath=&lt;template></code></td>
<td>打印 <a href=/zh/docs/reference/kubectl/jsonpath>jsonpath</a> 表达式中定义的字段</td>
</tr>
<tr>
<td><code>-o=jsonpath-file=&lt;filename></code></td>
<td>打印在 <code>&lt;filename></code> 文件中定义的 <a href=/zh/docs/reference/kubectl/jsonpath>jsonpath</a> 表达式所指定的字段。</td>
</tr>
<tr>
<td><code>-o=name</code></td>
<td>仅打印资源名称而不打印其他内容</td>
</tr>
<tr>
<td><code>-o=wide</code></td>
<td>以纯文本格式输出额外信息，对于 Pod 来说，输出中包含了节点名称</td>
</tr>
<tr>
<td><code>-o=yaml</code></td>
<td>输出 YAML 格式的 API 对象</td>
</tr>
</tbody>
</table>
<p>使用 <code>-o=custom-columns</code> 的示例：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#080;font-style:italic># 集群中运行着的所有镜像</span>
kubectl get pods -A -o<span style=color:#666>=</span>custom-columns<span style=color:#666>=</span><span style=color:#b44>&#39;DATA:spec.containers[*].image&#39;</span>

<span style=color:#080;font-style:italic># 列举 default 名字空间中运行的所有镜像，按 Pod 分组</span>
kubectl get pods --namespace default --output<span style=color:#666>=</span>custom-columns<span style=color:#666>=</span><span style=color:#b44>&#34;NAME:.metadata.name,IMAGE:.spec.containers[*].image&#34;</span>

<span style=color:#080;font-style:italic># 除 &#34;k8s.gcr.io/coredns:1.6.2&#34; 之外的所有镜像</span>
kubectl get pods -A -o<span style=color:#666>=</span>custom-columns<span style=color:#666>=</span><span style=color:#b44>&#39;DATA:spec.containers[?(@.image!=&#34;k8s.gcr.io/coredns:1.6.2&#34;)].image&#39;</span>

<span style=color:#080;font-style:italic># 输出 metadata 下面的所有字段，无论 Pod 名字为何</span>
kubectl get pods -A -o<span style=color:#666>=</span>custom-columns<span style=color:#666>=</span><span style=color:#b44>&#39;DATA:metadata.*&#39;</span>
</code></pre></div><p>有关更多示例，请参看 kubectl <a href=/zh/docs/reference/kubectl/overview/#custom-columns>参考文档</a>。</p>
<h3 id=kubectl-日志输出详细程度和调试>Kubectl 日志输出详细程度和调试</h3>
<p>Kubectl 日志输出详细程度是通过 <code>-v</code> 或者 <code>--v</code> 来控制的，参数后跟一个数字表示日志的级别。
Kubernetes 通用的日志习惯和相关的日志级别在
<a href=https://github.com/kubernetes/community/blob/master/contributors/devel/sig-instrumentation/logging.md>这里</a> 有相应的描述。</p>
<table>
<thead>
<tr>
<th>详细程度</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>--v=0</code></td>
<td>用于那些应该 <em>始终</em> 对运维人员可见的信息，因为这些信息一般很有用。</td>
</tr>
<tr>
<td><code>--v=1</code></td>
<td>如果您不想要看到冗余信息，此值是一个合理的默认日志级别。</td>
</tr>
<tr>
<td><code>--v=2</code></td>
<td>输出有关服务的稳定状态的信息以及重要的日志消息，这些信息可能与系统中的重大变化有关。这是建议大多数系统设置的默认日志级别。</td>
</tr>
<tr>
<td><code>--v=3</code></td>
<td>包含有关系统状态变化的扩展信息。</td>
</tr>
<tr>
<td><code>--v=4</code></td>
<td>包含调试级别的冗余信息。</td>
</tr>
<tr>
<td><code>--v=5</code></td>
<td>跟踪级别的详细程度。</td>
</tr>
<tr>
<td><code>--v=6</code></td>
<td>显示所请求的资源。</td>
</tr>
<tr>
<td><code>--v=7</code></td>
<td>显示 HTTP 请求头。</td>
</tr>
<tr>
<td><code>--v=8</code></td>
<td>显示 HTTP 请求内容。</td>
</tr>
<tr>
<td><code>--v=9</code></td>
<td>显示 HTTP 请求内容而且不截断内容。</td>
</tr>
</tbody>
</table>
<h2 id=what-s-next>What's next</h2>
<ul>
<li>参阅 <a href=/zh/docs/reference/kubectl/overview/>kubectl 概述</a>，进一步了解<a href=/zh/docs/reference/kubectl/jsonpath>JsonPath</a>。</li>
<li>参阅 <a href=/zh/docs/reference/kubectl/kubectl/>kubectl</a> 选项。</li>
<li>参阅 <a href=/zh/docs/reference/kubectl/conventions/>kubectl 使用约定</a>来理解如何在可复用的脚本中使用它。</li>
<li>查看社区中其他的 <a href=https://github.com/dennyzhang/cheatsheet-kubernetes-A4>kubectl 备忘单</a>。</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-8de6aceb8bf692c06cced446bac5bc92>10.6 - kubectl 的用法约定</h1>
<p><code>kubectl</code> 的推荐用法约定。</p>
<h2 id=在可重用脚本中使用-kubectl>在可重用脚本中使用 <code>kubectl</code></h2>
<p>对于脚本中的稳定输出：</p>
<ul>
<li>请求一个面向机器的输出格式，例如 <code>-o name</code>、<code>-o json</code>、<code>-o yaml</code>、<code>-o go template</code> 或 <code>-o jsonpath</code>。</li>
<li>完全限定版本。例如 <code>jobs.v1.batch/myjob</code>。这将确保 kubectl 不会使用其默认版本，该版本会随着时间的推移而更改。</li>
<li>不要依赖上下文、首选项或其他隐式状态。</li>
</ul>
<h2 id=最佳实践>最佳实践</h2>
<h3 id=kubectl-run><code>kubectl run</code></h3>
<p>若希望 <code>kubectl run</code> 满足基础设施即代码的要求：</p>
<ul>
<li>使用特定版本的标签标记镜像，不要将该标签移动到新版本。例如，使用 <code>:v1234</code>、<code>v1.2.3</code>、<code>r03062016-1-4</code>，而不是 <code>:latest</code>（有关详细信息，请参阅<a href=/zh/docs/concepts/configuration/overview/#container-images>配置的最佳实践</a>)。</li>
<li>使用基于版本控制的脚本来运行包含大量参数的镜像。</li>
<li>对于无法通过 <code>kubectl run</code> 参数来表示的功能特性，使用基于源码控制的配置文件，以记录要使用的功能特性。</li>
</ul>
<p>你可以使用 <code>--dry-run=client</code> 参数来预览而不真正提交即将下发到集群的对象实例：</p>
<h3 id=kubectl-apply><code>kubectl apply</code></h3>
<ul>
<li>您可以使用 <code>kubectl apply</code> 命令创建或更新资源。有关使用 kubectl apply 更新资源的详细信息，请参阅 <a href=https://kubectl.docs.kubernetes.io>Kubectl 文档</a>。</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-a7abc09192597e614b58f8b552b682f5>10.7 - 适用于 Docker 用户的 kubectl</h1>
<p>您可以使用 Kubernetes 命令行工具 <code>kubectl</code> 与 API 服务器进行交互。如果您熟悉 Docker 命令行工具，则使用 kubectl 非常简单。但是，Docker 命令和 kubectl 命令之间有一些区别。以下显示了 Docker 子命令，并描述了等效的 <code>kubectl</code> 命令。</p>
<h2 id=docker-run>docker run</h2>
<p>要运行 nginx 部署并将其暴露，请参见<a href=/docs/reference/generated/kubectl/kubectl-commands#-em-deployment-em->kubectl create deployment</a>
docker:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>docker run -d --restart<span style=color:#666>=</span>always -e <span style=color:#b8860b>DOMAIN</span><span style=color:#666>=</span>cluster --name nginx-app -p 80:80 nginx
</code></pre></div><pre><code>55c103fa129692154a7652490236fee9be47d70a8dd562281ae7d2f9a339a6db
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>docker ps
</code></pre></div><pre><code>CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                NAMES
55c103fa1296        nginx               &quot;nginx -g 'daemon of…&quot;   9 seconds ago       Up 9 seconds        0.0.0.0:80-&gt;80/tcp   nginx-app
</code></pre><p>kubectl:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># 启动运行 nginx 的 Pod</span>
kubectl create deployment --image<span style=color:#666>=</span>nginx nginx-app
</code></pre></div><pre><code>deployment.apps/nginx-app created
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># add env to nginx-app</span>
kubectl <span style=color:#a2f>set</span> env deployment/nginx-app  <span style=color:#b8860b>DOMAIN</span><span style=color:#666>=</span>cluster
</code></pre></div><pre><code>deployment.apps/nginx-app env updated
</code></pre><div class="alert alert-info note callout" role=alert>
<strong>Note:</strong>
<p><code>kubectl</code> 命令打印创建或突变资源的类型和名称，然后可以在后续命令中使用。部署后，您可以公开新服务。
</div>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># 通过服务公开端口</span>
kubectl expose deployment nginx-app --port<span style=color:#666>=</span><span style=color:#666>80</span> --name<span style=color:#666>=</span>nginx-http
</code></pre></div><pre><code>service &quot;nginx-http&quot; exposed
</code></pre>
<p>在 kubectl 命令中，我们创建了一个 <a href=/zh/docs/concepts/workloads/controllers/deployment/>Deployment</a>，这将保证有 N 个运行 nginx 的 pod(N 代表 spec 中声明的 replica 数，默认为 1)。我们还创建了一个 <a href=/zh/docs/concepts/services-networking/service/>service</a>，其选择器与容器标签匹配。查看<a href=/zh/docs/tasks/access-application-cluster/service-access-application-cluster>使用服务访问群集中的应用程序</a> 获取更多信息。</p>
<p>默认情况下镜像会在后台运行，与 <code>docker run -d ...</code> 类似，如果您想在前台运行，使用 <a href=/docs/reference/generated/kubectl/kubectl-commands/#run><code>kubectl run</code></a> 在前台运行 Pod:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl run <span style=color:#666>[</span>-i<span style=color:#666>]</span> <span style=color:#666>[</span>--tty<span style=color:#666>]</span> --attach &lt;name&gt; --image<span style=color:#666>=</span>&lt;image&gt;
</code></pre></div>
<p>与 <code>docker run ...</code> 不同的是，如果指定了 <code>--attach</code> ，我们将连接到 <code>stdin</code>，<code>stdout</code> 和 <code>stderr</code>，而不能控制具体连接到哪个输出流（<code>docker -a ...</code>）。要从容器中退出，可以输入 Ctrl + P，然后按 Ctrl + Q。</p>
<p>因为我们使用 Deployment 启动了容器，如果您终止连接到的进程（例如 <code>ctrl-c</code>），容器将会重启，这跟 <code>docker run -it</code> 不同。
如果想销毁该 Deployment（和它的 pod），您需要运行 <code>kubectl delete deployment &lt;name></code>。</p>
<h2 id=docker-ps>docker ps</h2>
<p>如何列出哪些正在运行？查看 <a href=/docs/reference/generated/kubectl/kubectl-commands/#get>kubectl get</a>。</p>
<p>使用 docker 命令：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>docker ps -a
</code></pre></div><pre><code>CONTAINER ID        IMAGE               COMMAND                  CREATED              STATUS                     PORTS                NAMES
14636241935f        ubuntu:16.04        &quot;echo test&quot;              5 seconds ago        Exited (0) 5 seconds ago                        cocky_fermi
55c103fa1296        nginx               &quot;nginx -g 'daemon of…&quot;   About a minute ago   Up About a minute          0.0.0.0:80-&gt;80/tcp   nginx-app
</code></pre>
<p>使用 kubectl 命令：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get po
</code></pre></div><pre><code>NAME                        READY     STATUS      RESTARTS   AGE
nginx-app-8df569cb7-4gd89   1/1       Running     0          3m
ubuntu                      0/1       Completed   0          20s
</code></pre><h2 id=docker-attach>docker attach</h2>
<p>如何连接到已经运行在容器中的进程？查看 <a href=/docs/reference/generated/kubectl/kubectl-commands/#attach>kubectl attach</a>。</p>
<p>使用 docker 命令：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>docker ps
</code></pre></div><pre><code>CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                NAMES
55c103fa1296        nginx               &quot;nginx -g 'daemon of…&quot;   5 minutes ago       Up 5 minutes        0.0.0.0:80-&gt;80/tcp   nginx-app
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>docker attach 55c103fa1296
...
</code></pre></div><p>kubectl:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods
</code></pre></div><pre><code>NAME              READY     STATUS    RESTARTS   AGE
nginx-app-5jyvm   1/1       Running   0          10m
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl attach -it nginx-app-5jyvm
...
</code></pre></div>
<p>要从容器中分离，可以输入 Ctrl + P，然后按 Ctrl + Q。</p>
<h2 id=docker-exec>docker exec</h2>
<p>如何在容器中执行命令？查看 <a href=/docs/reference/generated/kubectl/kubectl-commands/#exec>kubectl exec</a>。</p>
<p>使用 docker 命令：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>docker ps
</code></pre></div><pre><code>CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                NAMES
55c103fa1296        nginx               &quot;nginx -g 'daemon of…&quot;   6 minutes ago       Up 6 minutes        0.0.0.0:80-&gt;80/tcp   nginx-app
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>docker <span style=color:#a2f>exec</span> 55c103fa1296 cat /etc/hostname
</code></pre></div><pre><code>55c103fa1296
</code></pre>
<p>使用 kubectl 命令：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get po
</code></pre></div><pre><code>NAME              READY     STATUS    RESTARTS   AGE
nginx-app-5jyvm   1/1       Running   0          10m
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#a2f>exec</span> nginx-app-5jyvm -- cat /etc/hostname
</code></pre></div><pre><code>nginx-app-5jyvm
</code></pre>
<p>执行交互式命令怎么办？</p>
<p>使用 docker 命令：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>docker <span style=color:#a2f>exec</span> -ti 55c103fa1296 /bin/sh
<span style=color:#080;font-style:italic># exit</span>
</code></pre></div><p>kubectl:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#a2f>exec</span> -ti nginx-app-5jyvm -- /bin/sh      
<span style=color:#080;font-style:italic># exit</span>
</code></pre></div>
<p>更多信息请查看<a href=/zh/docs/tasks/debug-application-cluster/get-shell-running-container/>获取运行中容器的 Shell 环境</a>。</p>
<h2 id=docker-logs>docker logs</h2>
<p>如何查看运行中进程的 stdout/stderr？查看 <a href=/docs/reference/generated/kubectl/kubectl-commands/#logs>kubectl logs</a>。</p>
<p>使用 docker 命令：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>docker logs -f a9e
</code></pre></div><pre><code>192.168.9.1 - - [14/Jul/2015:01:04:02 +0000] &quot;GET / HTTP/1.1&quot; 200 612 &quot;-&quot; &quot;curl/7.35.0&quot; &quot;-&quot;
192.168.9.1 - - [14/Jul/2015:01:04:03 +0000] &quot;GET / HTTP/1.1&quot; 200 612 &quot;-&quot; &quot;curl/7.35.0&quot; &quot;-&quot;
</code></pre>
<p>使用 kubectl 命令：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl logs -f nginx-app-zibvs
</code></pre></div><pre><code>10.240.63.110 - - [14/Jul/2015:01:09:01 +0000] &quot;GET / HTTP/1.1&quot; 200 612 &quot;-&quot; &quot;curl/7.26.0&quot; &quot;-&quot;
10.240.63.110 - - [14/Jul/2015:01:09:02 +0000] &quot;GET / HTTP/1.1&quot; 200 612 &quot;-&quot; &quot;curl/7.26.0&quot; &quot;-&quot;
</code></pre>
<p>现在是时候提一下 pod 和容器之间的细微差别了；默认情况下如果 pod 中的进程退出 pod 也不会终止，相反它将会重启该进程。这类似于 docker run 时的 <code>--restart=always</code> 选项， 这是主要差别。在 docker 中，进程的每个调用的输出都是被连接起来的，但是对于 kubernetes，每个调用都是分开的。要查看以前在 kubernetes 中执行的输出，请执行以下操作：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl logs --previous nginx-app-zibvs
</code></pre></div><pre><code>10.240.63.110 - - [14/Jul/2015:01:09:01 +0000] &quot;GET / HTTP/1.1&quot; 200 612 &quot;-&quot; &quot;curl/7.26.0&quot; &quot;-&quot;
10.240.63.110 - - [14/Jul/2015:01:09:02 +0000] &quot;GET / HTTP/1.1&quot; 200 612 &quot;-&quot; &quot;curl/7.26.0&quot; &quot;-&quot;
</code></pre>
<p>查看<a href=/zh/docs/concepts/cluster-administration/logging/>日志架构</a>获取更多信息。</p>
<h2 id=docker-stop-and-docker-rm>docker stop and docker rm</h2>
<p>如何停止和删除运行中的进程？查看 <a href=/docs/reference/generated/kubectl/kubectl-commands/#delete>kubectl delete</a>。</p>
<p>使用 docker 命令：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>docker ps
</code></pre></div><pre><code>CONTAINER ID        IMAGE               COMMAND                CREATED             STATUS              PORTS                         NAMES
a9ec34d98787        nginx               &quot;nginx -g 'daemon of&quot;  22 hours ago        Up 22 hours         0.0.0.0:80-&gt;80/tcp, 443/tcp   nginx-app
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>docker stop a9ec34d98787
</code></pre></div><pre><code>a9ec34d98787
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>docker rm a9ec34d98787
</code></pre></div><pre><code>a9ec34d98787
</code></pre>
<p>使用 kubectl 命令：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get deployment nginx-app
</code></pre></div><pre><code>NAME         READY   UP-TO-DATE   AVAILABLE   AGE
nginx-app    1/1     1            1           2m
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get po -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>nginx-app
</code></pre></div><pre><code>NAME                         READY     STATUS    RESTARTS   AGE
nginx-app-2883164633-aklf7   1/1       Running   0          2m
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete deployment nginx-app
</code></pre></div><pre><code>deployment &quot;nginx-app&quot; deleted
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get po -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>nginx-app
<span style=color:#080;font-style:italic># Return nothing</span>
</code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>Note:</strong>
<p>请注意，我们不直接删除 pod。使用 kubectl 命令，我们要删除拥有该 pod 的 Deployment。如果我们直接删除 pod，Deployment 将会重新创建该 pod。
</div>
<h2 id=docker-login>docker login</h2>
<p>在 kubectl 中没有对 <code>docker login</code> 的直接模拟。如果您有兴趣在私有镜像仓库中使用 Kubernetes，请参阅<a href=/zh/docs/concepts/containers/images/#using-a-private-registry>使用私有镜像仓库</a>。</p>
<h2 id=docker-version>docker version</h2>
<p>如何查看客户端和服务端的版本？查看 <a href=/docs/reference/generated/kubectl/kubectl-commands/#version>kubectl version</a>。</p>
<p>使用 docker 命令：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>docker version
</code></pre></div><pre><code>Client version: 1.7.0
Client API version: 1.19
Go version (client): go1.4.2
Git commit (client): 0baf609
OS/Arch (client): linux/amd64
Server version: 1.7.0
Server API version: 1.19
Go version (server): go1.4.2
Git commit (server): 0baf609
OS/Arch (server): linux/amd64
</code></pre>
<p>使用 kubectl 命令：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl version
</code></pre></div><pre><code>Client Version: version.Info{Major:&quot;1&quot;, Minor:&quot;6&quot;, GitVersion:&quot;v1.6.9+a3d1dfa6f4335&quot;, GitCommit:&quot;9b77fed11a9843ce3780f70dd251e92901c43072&quot;, GitTreeState:&quot;dirty&quot;, BuildDate:&quot;2017-08-29T20:32:58Z&quot;, OpenPaasKubernetesVersion:&quot;v1.03.02&quot;, GoVersion:&quot;go1.7.5&quot;, Compiler:&quot;gc&quot;, Platform:&quot;linux/amd64&quot;}
Server Version: version.Info{Major:&quot;1&quot;, Minor:&quot;6&quot;, GitVersion:&quot;v1.6.9+a3d1dfa6f4335&quot;, GitCommit:&quot;9b77fed11a9843ce3780f70dd251e92901c43072&quot;, GitTreeState:&quot;dirty&quot;, BuildDate:&quot;2017-08-29T20:32:58Z&quot;, OpenPaasKubernetesVersion:&quot;v1.03.02&quot;, GoVersion:&quot;go1.7.5&quot;, Compiler:&quot;gc&quot;, Platform:&quot;linux/amd64&quot;}
</code></pre><h2 id=docker-info>docker info</h2>
<p>如何获取有关环境和配置的各种信息？查看 <a href=/docs/reference/generated/kubectl/kubectl-commands/#cluster-info>kubectl cluster-info</a>。</p>
<p>使用 docker 命令：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>docker info
</code></pre></div><pre><code>Containers: 40
Images: 168
Storage Driver: aufs
 Root Dir: /usr/local/google/docker/aufs
 Backing Filesystem: extfs
 Dirs: 248
 Dirperm1 Supported: false
Execution Driver: native-0.2
Logging Driver: json-file
Kernel Version: 3.13.0-53-generic
Operating System: Ubuntu 14.04.2 LTS
CPUs: 12
Total Memory: 31.32 GiB
Name: k8s-is-fun.mtv.corp.google.com
ID: ADUV:GCYR:B3VJ:HMPO:LNPQ:KD5S:YKFQ:76VN:IANZ:7TFV:ZBF4:BYJO
WARNING: No swap limit support
</code></pre>
<p>使用 kubectl 命令：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl cluster-info
</code></pre></div><pre><code>Kubernetes master is running at https://108.59.85.141
KubeDNS is running at https://108.59.85.141/api/v1/namespaces/kube-system/services/kube-dns/proxy
kubernetes-dashboard is running at https://108.59.85.141/api/v1/namespaces/kube-system/services/kubernetes-dashboard/proxy
Grafana is running at https://108.59.85.141/api/v1/namespaces/kube-system/services/monitoring-grafana/proxy
Heapster is running at https://108.59.85.141/api/v1/namespaces/kube-system/services/monitoring-heapster/proxy
InfluxDB is running at https://108.59.85.141/api/v1/namespaces/kube-system/services/monitoring-influxdb/proxy
</code></pre>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-54e562dd1441d0195970a6526b0055cc>11 - 组件工具</h1>
</div>
<div class=td-content>
<h1 id=pg-ca5d01a42c486d535539d3038aa67eb9>11.1 - 特性门控</h1>
<p>本页详述了管理员可以在不同的 Kubernetes 组件上指定的各种特性门控。</p>
<p>关于特性各个阶段的说明，请参见<a href=#feature-stages>特性阶段</a>。</p>
<h2 id=概述>概述</h2>
<p>特性门控是描述 Kubernetes 特性的一组键值对。你可以在 Kubernetes 的各个组件中使用
<code>--feature-gates</code> flag 来启用或禁用这些特性。</p>
<p>每个 Kubernetes 组件都支持启用或禁用与该组件相关的一组特性门控。
使用 <code>-h</code> 参数来查看所有组件支持的完整特性门控。
要为诸如 kubelet 之类的组件设置特性门控，请使用 <code>--feature-gates</code> 参数，并向其
传递一个特性设置键值对列表：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>--feature-gates<span style=color:#666>=</span><span style=color:#b44>&#34;...,GracefulNodeShutdown=true&#34;</span>
</code></pre></div>
<p>下表总结了在不同的 Kubernetes 组件上可以设置的特性门控。</p>
<ul>
<li>引入特性或更改其发布阶段后，"开始（Since）" 列将包含 Kubernetes 版本。</li>
<li>"结束（Until）" 列（如果不为空）包含最后一个 Kubernetes 版本，你仍可以在其中使用特性门控。</li>
<li>如果某个特性处于 Alpha 或 Beta 状态，你可以在
<a href=#feature-gates-for-alpha-or-beta-features>Alpha 和 Beta 特性门控表</a>中找到该特性。</li>
<li>如果某个特性处于稳定状态，你可以在
<a href=#feature-gates-for-graduated-or-deprecated-features>已毕业和废弃特性门控表</a>
中找到该特性的所有阶段。</li>
<li><a href=#feature-gates-for-graduated-or-deprecated-features>已毕业和废弃特性门控表</a>
还列出了废弃的和已被移除的特性。</li>
</ul>
<h3 id=feature-gates-for-alpha-or-beta-features>Alpha 和 Beta 状态的特性门控 </h3>
<table><caption style=display:none>处于 Alpha 或 Beta 状态的特性门控</caption>
<thead>
<tr>
<th>特性</th>
<th>默认值</th>
<th>状态</th>
<th>开始（Since）</th>
<th>结束（Until）</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>APIListChunking</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.8</td>
<td>1.8</td>
</tr>
<tr>
<td><code>APIListChunking</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.9</td>
<td></td>
</tr>
<tr>
<td><code>APIPriorityAndFairness</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.18</td>
<td>1.19</td>
</tr>
<tr>
<td><code>APIPriorityAndFairness</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.20</td>
<td></td>
</tr>
<tr>
<td><code>APIResponseCompression</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.7</td>
<td>1.15</td>
</tr>
<tr>
<td><code>APIResponseCompression</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.16</td>
<td></td>
</tr>
<tr>
<td><code>APIServerIdentity</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.20</td>
<td></td>
</tr>
<tr>
<td><code>APIServerTracing</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.22</td>
<td></td>
</tr>
<tr>
<td><code>AllowInsecureBackendProxy</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.17</td>
<td></td>
</tr>
<tr>
<td><code>AnyVolumeDataSource</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.18</td>
<td></td>
</tr>
<tr>
<td><code>AppArmor</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.4</td>
<td></td>
</tr>
<tr>
<td><code>ControllerManagerLeaderMigration</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.21</td>
<td>1.21</td>
</tr>
<tr>
<td><code>ControllerManagerLeaderMigration</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.22</td>
<td></td>
</tr>
<tr>
<td><code>CPUManager</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.8</td>
<td>1.9</td>
</tr>
<tr>
<td><code>CPUManager</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.10</td>
<td></td>
</tr>
<tr>
<td><code>CPUManagerPolicyAlphaOptions</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.23</td>
<td></td>
</tr>
<tr>
<td><code>CPUManagerPolicyBetaOptions</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.23</td>
<td></td>
</tr>
<tr>
<td><code>CPUManagerPolicyOptions</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.22</td>
<td>1.22</td>
</tr>
<tr>
<td><code>CPUManagerPolicyOptions</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.23</td>
<td></td>
</tr>
<tr>
<td><code>CSIInlineVolume</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.15</td>
<td>1.15</td>
</tr>
<tr>
<td><code>CSIInlineVolume</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.16</td>
<td>-</td>
</tr>
<tr>
<td><code>CSIMigration</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.14</td>
<td>1.16</td>
</tr>
<tr>
<td><code>CSIMigration</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.17</td>
<td></td>
</tr>
<tr>
<td><code>CSIMigrationAWS</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.14</td>
<td>1.16</td>
</tr>
<tr>
<td><code>CSIMigrationAWS</code></td>
<td><code>false</code></td>
<td>Beta</td>
<td>1.17</td>
<td>1.22</td>
</tr>
<tr>
<td><code>CSIMigrationAWS</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.23</td>
<td></td>
</tr>
<tr>
<td><code>CSIMigrationAzureDisk</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.15</td>
<td>1.18</td>
</tr>
<tr>
<td><code>CSIMigrationAzureDisk</code></td>
<td><code>false</code></td>
<td>Beta</td>
<td>1.19</td>
<td>1.22</td>
</tr>
<tr>
<td><code>CSIMigrationAzureDisk</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.23</td>
<td></td>
</tr>
<tr>
<td><code>CSIMigrationAzureFile</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.15</td>
<td>1.19</td>
</tr>
<tr>
<td><code>CSIMigrationAzureFile</code></td>
<td><code>false</code></td>
<td>Beta</td>
<td>1.21</td>
<td></td>
</tr>
<tr>
<td><code>CSIMigrationGCE</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.14</td>
<td>1.16</td>
</tr>
<tr>
<td><code>CSIMigrationGCE</code></td>
<td><code>false</code></td>
<td>Beta</td>
<td>1.17</td>
<td>1.22</td>
</tr>
<tr>
<td><code>CSIMigrationGCE</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.23</td>
<td></td>
</tr>
<tr>
<td><code>CSIMigrationOpenStack</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.14</td>
<td>1.17</td>
</tr>
<tr>
<td><code>CSIMigrationOpenStack</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.18</td>
<td></td>
</tr>
<tr>
<td><code>CSIMigrationvSphere</code></td>
<td><code>false</code></td>
<td>Beta</td>
<td>1.19</td>
<td></td>
</tr>
<tr>
<td><code>CSIMigrationPortworx</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.23</td>
<td></td>
</tr>
<tr>
<td><code>csiMigrationRBD</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.23</td>
<td></td>
</tr>
<tr>
<td><code>CSIStorageCapacity</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.19</td>
<td>1.20</td>
</tr>
<tr>
<td><code>CSIStorageCapacity</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.21</td>
<td></td>
</tr>
<tr>
<td><code>CSIVolumeHealth</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.21</td>
<td></td>
</tr>
<tr>
<td><code>CSRDuration</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.22</td>
<td></td>
</tr>
<tr>
<td><code>ControllerManagerLeaderMigration</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.21</td>
<td>1.21</td>
</tr>
<tr>
<td><code>ControllerManagerLeaderMigration</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.22</td>
<td></td>
</tr>
<tr>
<td><code>CustomCPUCFSQuotaPeriod</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.12</td>
<td></td>
</tr>
<tr>
<td><code>CustomResourceValidationExpressions</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.23</td>
<td></td>
</tr>
<tr>
<td><code>DaemonSetUpdateSurge</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.21</td>
<td>1.21</td>
</tr>
<tr>
<td><code>DaemonSetUpdateSurge</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.22</td>
<td></td>
</tr>
<tr>
<td><code>DefaultPodTopologySpread</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.19</td>
<td>1.19</td>
</tr>
<tr>
<td><code>DefaultPodTopologySpread</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.20</td>
<td></td>
</tr>
<tr>
<td><code>DelegateFSGroupToCSIDriver</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.22</td>
<td>1.22</td>
</tr>
<tr>
<td><code>DelegateFSGroupToCSIDriver</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.23</td>
<td></td>
</tr>
<tr>
<td><code>DevicePlugins</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.8</td>
<td>1.9</td>
</tr>
<tr>
<td><code>DevicePlugins</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.10</td>
<td></td>
</tr>
<tr>
<td><code>DisableAcceleratorUsageMetrics</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.19</td>
<td>1.19</td>
</tr>
<tr>
<td><code>DisableAcceleratorUsageMetrics</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.20</td>
<td></td>
</tr>
<tr>
<td><code>DisableCloudProviders</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.22</td>
<td></td>
</tr>
<tr>
<td><code>DisableKubeletCloudCredentialProviders</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.23</td>
<td></td>
</tr>
<tr>
<td><code>DownwardAPIHugePages</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.20</td>
<td>1.20</td>
</tr>
<tr>
<td><code>DownwardAPIHugePages</code></td>
<td><code>false</code></td>
<td>Beta</td>
<td>1.21</td>
<td></td>
</tr>
<tr>
<td><code>EfficientWatchResumption</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.20</td>
<td>1.20</td>
</tr>
<tr>
<td><code>EfficientWatchResumption</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.21</td>
<td></td>
</tr>
<tr>
<td><code>EndpointSliceTerminatingCondition</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.20</td>
<td>1.21</td>
</tr>
<tr>
<td><code>EndpointSliceTerminatingCondition</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.22</td>
<td></td>
</tr>
<tr>
<td><code>EphemeralContainers</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.16</td>
<td>1.22</td>
</tr>
<tr>
<td><code>EphemeralContainers</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.23</td>
<td></td>
</tr>
<tr>
<td><code>ExpandCSIVolumes</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.14</td>
<td>1.15</td>
</tr>
<tr>
<td><code>ExpandCSIVolumes</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.16</td>
<td></td>
</tr>
<tr>
<td><code>ExpandedDNSConfig</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.22</td>
<td></td>
</tr>
<tr>
<td><code>ExpandInUsePersistentVolumes</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.11</td>
<td>1.14</td>
</tr>
<tr>
<td><code>ExpandInUsePersistentVolumes</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.15</td>
<td></td>
</tr>
<tr>
<td><code>ExpandPersistentVolumes</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.8</td>
<td>1.10</td>
</tr>
<tr>
<td><code>ExpandPersistentVolumes</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.11</td>
<td></td>
</tr>
<tr>
<td><code>ExperimentalHostUserNamespaceDefaulting</code></td>
<td><code>false</code></td>
<td>Beta</td>
<td>1.5</td>
<td></td>
</tr>
<tr>
<td><code>GracefulNodeShutdown</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.20</td>
<td>1.20</td>
</tr>
<tr>
<td><code>GracefulNodeShutdown</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.21</td>
<td></td>
</tr>
<tr>
<td><code>GracefulNodeShutdownBasedOnPodPriority</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.23</td>
<td></td>
</tr>
<tr>
<td><code>GRPCContainerProbe</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.23</td>
<td></td>
</tr>
<tr>
<td><code>HonorPVReclaimPolicy</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.23</td>
<td></td>
</tr>
<tr>
<td><code>HPAContainerMetrics</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.20</td>
<td></td>
</tr>
<tr>
<td><code>HPAScaleToZero</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.16</td>
<td></td>
</tr>
<tr>
<td><code>IdentifyPodOS</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.23</td>
<td></td>
</tr>
<tr>
<td><code>IndexedJob</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.21</td>
<td>1.21</td>
</tr>
<tr>
<td><code>IndexedJob</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.22</td>
<td></td>
</tr>
<tr>
<td><code>InTreePluginAWSUnregister</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.21</td>
<td></td>
</tr>
<tr>
<td><code>InTreePluginAzureDiskUnregister</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.21</td>
<td></td>
</tr>
<tr>
<td><code>InTreePluginAzureFileUnregister</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.21</td>
<td></td>
</tr>
<tr>
<td><code>InTreePluginGCEUnregister</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.21</td>
<td></td>
</tr>
<tr>
<td><code>InTreePluginOpenStackUnregister</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.21</td>
<td></td>
</tr>
<tr>
<td><code>InTreePluginPortworxUnregister</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.23</td>
<td></td>
</tr>
<tr>
<td><code>InTreePluginRBDUnregister</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.23</td>
<td></td>
</tr>
<tr>
<td><code>InTreePluginvSphereUnregister</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.21</td>
<td></td>
</tr>
<tr>
<td><code>JobMutableNodeSchedulingDirectives</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.23</td>
<td></td>
</tr>
<tr>
<td><code>JobReadyPods</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.23</td>
<td></td>
</tr>
<tr>
<td><code>JobTrackingWithFinalizers</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.22</td>
<td>1.22</td>
</tr>
<tr>
<td><code>JobTrackingWithFinalizers</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.23</td>
<td></td>
</tr>
<tr>
<td><code>KubeletCredentialProviders</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.20</td>
<td></td>
</tr>
<tr>
<td><code>KubeletInUserNamespace</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.22</td>
<td></td>
</tr>
<tr>
<td><code>KubeletPodResources</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.13</td>
<td>1.14</td>
</tr>
<tr>
<td><code>KubeletPodResources</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.15</td>
<td></td>
</tr>
<tr>
<td><code>KubeletPodResourcesGetAllocatable</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.21</td>
<td>1.22</td>
</tr>
<tr>
<td><code>KubeletPodResourcesGetAllocatable</code></td>
<td><code>false</code></td>
<td>Beta</td>
<td>1.23</td>
<td></td>
</tr>
<tr>
<td><code>LocalStorageCapacityIsolation</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.7</td>
<td>1.9</td>
</tr>
<tr>
<td><code>LocalStorageCapacityIsolation</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.10</td>
<td></td>
</tr>
<tr>
<td><code>LocalStorageCapacityIsolationFSQuotaMonitoring</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.15</td>
<td></td>
</tr>
<tr>
<td><code>LogarithmicScaleDown</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.21</td>
<td>1.21</td>
</tr>
<tr>
<td><code>LogarithmicScaleDown</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.22</td>
<td></td>
</tr>
<tr>
<td><code>MemoryManager</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.21</td>
<td>1.21</td>
</tr>
<tr>
<td><code>MemoryManager</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.22</td>
<td></td>
</tr>
<tr>
<td><code>MemoryQoS</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.22</td>
<td></td>
</tr>
<tr>
<td><code>MixedProtocolLBService</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.20</td>
<td></td>
</tr>
<tr>
<td><code>NetworkPolicyEndPort</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.21</td>
<td>1.21</td>
</tr>
<tr>
<td><code>NetworkPolicyEndPort</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.22</td>
<td></td>
</tr>
<tr>
<td><code>NodeSwap</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.22</td>
<td></td>
</tr>
<tr>
<td><code>NonPreemptingPriority</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.15</td>
<td>1.18</td>
</tr>
<tr>
<td><code>NonPreemptingPriority</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.19</td>
<td></td>
</tr>
<tr>
<td><code>OpenAPIEnums</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.23</td>
<td></td>
</tr>
<tr>
<td><code>OpenAPIV3</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.23</td>
<td></td>
</tr>
<tr>
<td><code>PodAndContainerStatsFromCRI</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.23</td>
<td></td>
</tr>
<tr>
<td><code>PodAffinityNamespaceSelector</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.21</td>
<td>1.21</td>
</tr>
<tr>
<td><code>PodAffinityNamespaceSelector</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.22</td>
<td></td>
</tr>
<tr>
<td><code>PodDeletionCost</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.21</td>
<td>1.21</td>
</tr>
<tr>
<td><code>PodDeletionCost</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.22</td>
<td></td>
</tr>
<tr>
<td><code>PodOverhead</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.16</td>
<td>1.17</td>
</tr>
<tr>
<td><code>PodOverhead</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.18</td>
<td></td>
</tr>
<tr>
<td><code>PodSecurity</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.22</td>
<td>1.22</td>
</tr>
<tr>
<td><code>PodSecurity</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.23</td>
<td></td>
</tr>
<tr>
<td><code>PreferNominatedNode</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.21</td>
<td>1.21</td>
</tr>
<tr>
<td><code>PreferNominatedNode</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.22</td>
<td></td>
</tr>
<tr>
<td><code>ProbeTerminationGracePeriod</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.21</td>
<td>1.21</td>
</tr>
<tr>
<td><code>ProbeTerminationGracePeriod</code></td>
<td><code>false</code></td>
<td>Beta</td>
<td>1.22</td>
<td></td>
</tr>
<tr>
<td><code>ProcMountType</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.12</td>
<td></td>
</tr>
<tr>
<td><code>ProxyTerminatingEndpoints</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.22</td>
<td></td>
</tr>
<tr>
<td><code>QOSReserved</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.11</td>
<td></td>
</tr>
<tr>
<td><code>ReadWriteOncePod</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.22</td>
<td></td>
</tr>
<tr>
<td><code>RecoverVolumeExpansionFailure</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.23</td>
<td></td>
</tr>
<tr>
<td><code>RemainingItemCount</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.15</td>
<td>1.15</td>
</tr>
<tr>
<td><code>RemainingItemCount</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.16</td>
<td></td>
</tr>
<tr>
<td><code>RemoveSelfLink</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.16</td>
<td>1.19</td>
</tr>
<tr>
<td><code>RemoveSelfLink</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.20</td>
<td></td>
</tr>
<tr>
<td><code>RotateKubeletServerCertificate</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.7</td>
<td>1.11</td>
</tr>
<tr>
<td><code>RotateKubeletServerCertificate</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.12</td>
<td></td>
</tr>
<tr>
<td><code>SeccompDefault</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.22</td>
<td></td>
</tr>
<tr>
<td><code>ServiceInternalTrafficPolicy</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.21</td>
<td>1.21</td>
</tr>
<tr>
<td><code>ServiceInternalTrafficPolicy</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.22</td>
<td></td>
</tr>
<tr>
<td><code>ServiceLBNodePortControl</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.20</td>
<td>1.21</td>
</tr>
<tr>
<td><code>ServiceLBNodePortControl</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.22</td>
<td></td>
</tr>
<tr>
<td><code>ServiceLoadBalancerClass</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.21</td>
<td>1.21</td>
</tr>
<tr>
<td><code>ServiceLoadBalancerClass</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.22</td>
<td></td>
</tr>
<tr>
<td><code>SizeMemoryBackedVolumes</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.20</td>
<td>1.21</td>
</tr>
<tr>
<td><code>SizeMemoryBackedVolumes</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.22</td>
<td></td>
</tr>
<tr>
<td><code>StatefulSetAutoDeletePVC</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.22</td>
<td></td>
</tr>
<tr>
<td><code>StatefulSetMinReadySeconds</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.22</td>
<td>1.22</td>
</tr>
<tr>
<td><code>StatefulSetMinReadySeconds</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.23</td>
<td></td>
</tr>
<tr>
<td><code>StorageVersionAPI</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.20</td>
<td></td>
</tr>
<tr>
<td><code>StorageVersionHash</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.14</td>
<td>1.14</td>
</tr>
<tr>
<td><code>StorageVersionHash</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.15</td>
<td></td>
</tr>
<tr>
<td><code>SuspendJob</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.21</td>
<td>1.21</td>
</tr>
<tr>
<td><code>SuspendJob</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.22</td>
<td></td>
</tr>
<tr>
<td><code>TopologyAwareHints</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.21</td>
<td>1.22</td>
</tr>
<tr>
<td><code>TopologyAwareHints</code></td>
<td><code>false</code></td>
<td>Beta</td>
<td>1.23</td>
<td></td>
</tr>
<tr>
<td><code>TopologyManager</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.16</td>
<td>1.17</td>
</tr>
<tr>
<td><code>TopologyManager</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.18</td>
<td></td>
</tr>
<tr>
<td><code>VolumeCapacityPriority</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.21</td>
<td>-</td>
</tr>
<tr>
<td><code>WinDSR</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.14</td>
<td></td>
</tr>
<tr>
<td><code>WinOverlay</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.14</td>
<td>1.19</td>
</tr>
<tr>
<td><code>WinOverlay</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.20</td>
<td></td>
</tr>
<tr>
<td><code>WindowsHostProcessContainers</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.22</td>
<td>1.22</td>
</tr>
<tr>
<td><code>WindowsHostProcessContainers</code></td>
<td><code>false</code></td>
<td>Beta</td>
<td>1.23</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id=feature-gates-for-graduated-or-deprecated-features>已毕业和已废弃的特性门控 </h3>
<table><caption style=display:none>已毕业或不推荐使用的特性门控</caption>
<thead>
<tr>
<th>特性</th>
<th>默认值</th>
<th>状态</th>
<th>开始（Since）</th>
<th>结束（Until）</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Accelerators</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.6</td>
<td>1.10</td>
</tr>
<tr>
<td><code>Accelerators</code></td>
<td>-</td>
<td>Deprecated</td>
<td>1.11</td>
<td>-</td>
</tr>
<tr>
<td><code>AdvancedAuditing</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.7</td>
<td>1.7</td>
</tr>
<tr>
<td><code>AdvancedAuditing</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.8</td>
<td>1.11</td>
</tr>
<tr>
<td><code>AdvancedAuditing</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.12</td>
<td>-</td>
</tr>
<tr>
<td><code>AffinityInAnnotations</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.6</td>
<td>1.7</td>
</tr>
<tr>
<td><code>AffinityInAnnotations</code></td>
<td>-</td>
<td>Deprecated</td>
<td>1.8</td>
<td>-</td>
</tr>
<tr>
<td><code>AllowExtTrafficLocalEndpoints</code></td>
<td><code>false</code></td>
<td>Beta</td>
<td>1.4</td>
<td>1.6</td>
</tr>
<tr>
<td><code>AllowExtTrafficLocalEndpoints</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.7</td>
<td>-</td>
</tr>
<tr>
<td><code>AttachVolumeLimit</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.11</td>
<td>1.11</td>
</tr>
<tr>
<td><code>AttachVolumeLimit</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.12</td>
<td>1.16</td>
</tr>
<tr>
<td><code>AttachVolumeLimit</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.17</td>
<td>-</td>
</tr>
<tr>
<td><code>BalanceAttachedNodeVolumes</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.11</td>
<td>1.21</td>
</tr>
<tr>
<td><code>BalanceAttachedNodeVolumes</code></td>
<td><code>false</code></td>
<td>Deprecated</td>
<td>1.22</td>
<td></td>
</tr>
<tr>
<td><code>BlockVolume</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.9</td>
<td>1.12</td>
</tr>
<tr>
<td><code>BlockVolume</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.13</td>
<td>1.17</td>
</tr>
<tr>
<td><code>BlockVolume</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.18</td>
<td>-</td>
</tr>
<tr>
<td><code>BoundServiceAccountTokenVolume</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.13</td>
<td>1.20</td>
</tr>
<tr>
<td><code>BoundServiceAccountTokenVolume</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.21</td>
<td>1.21</td>
</tr>
<tr>
<td><code>BoundServiceAccountTokenVolume</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.22</td>
<td>-</td>
</tr>
<tr>
<td><code>ConfigurableFSGroupPolicy</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.18</td>
<td>1.19</td>
</tr>
<tr>
<td><code>ConfigurableFSGroupPolicy</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.20</td>
<td>1.22</td>
</tr>
<tr>
<td><code>ConfigurableFSGroupPolicy</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.23</td>
<td></td>
</tr>
<tr>
<td><code>CRIContainerLogRotation</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.10</td>
<td>1.10</td>
</tr>
<tr>
<td><code>CRIContainerLogRotation</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.11</td>
<td>1.20</td>
</tr>
<tr>
<td><code>CRIContainerLogRotation</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.21</td>
<td>-</td>
</tr>
<tr>
<td><code>CSIBlockVolume</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.11</td>
<td>1.13</td>
</tr>
<tr>
<td><code>CSIBlockVolume</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.14</td>
<td>1.17</td>
</tr>
<tr>
<td><code>CSIBlockVolume</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.18</td>
<td>-</td>
</tr>
<tr>
<td><code>CSIDriverRegistry</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.12</td>
<td>1.13</td>
</tr>
<tr>
<td><code>CSIDriverRegistry</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.14</td>
<td>1.17</td>
</tr>
<tr>
<td><code>CSIDriverRegistry</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.18</td>
<td></td>
</tr>
<tr>
<td><code>CSIMigrationAWSComplete</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.17</td>
<td>1.20</td>
</tr>
<tr>
<td><code>CSIMigrationAWSComplete</code></td>
<td>-</td>
<td>Deprecated</td>
<td>1.21</td>
<td>-</td>
</tr>
<tr>
<td><code>CSIMigrationAzureDiskComplete</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.17</td>
<td>1.20</td>
</tr>
<tr>
<td><code>CSIMigrationAzureDiskComplete</code></td>
<td>-</td>
<td>Deprecated</td>
<td>1.21</td>
<td>-</td>
</tr>
<tr>
<td><code>CSIMigrationAzureFileComplete</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.17</td>
<td>1.20</td>
</tr>
<tr>
<td><code>CSIMigrationAzureFileComplete</code></td>
<td>-</td>
<td>Deprecated</td>
<td>1.21</td>
<td>-</td>
</tr>
<tr>
<td><code>CSIMigrationGCEComplete</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.17</td>
<td>1.20</td>
</tr>
<tr>
<td><code>CSIMigrationGCEComplete</code></td>
<td>-</td>
<td>Deprecated</td>
<td>1.21</td>
<td>-</td>
</tr>
<tr>
<td><code>CSIMigrationOpenStackComplete</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.17</td>
<td>1.20</td>
</tr>
<tr>
<td><code>CSIMigrationOpenStackComplete</code></td>
<td>-</td>
<td>Deprecated</td>
<td>1.21</td>
<td>-</td>
</tr>
<tr>
<td><code>CSIMigrationvSphereComplete</code></td>
<td><code>false</code></td>
<td>Beta</td>
<td>1.19</td>
<td>1.21</td>
</tr>
<tr>
<td><code>CSIMigrationvSphereComplete</code></td>
<td>-</td>
<td>Deprecated</td>
<td>1.22</td>
<td>-</td>
</tr>
<tr>
<td><code>CSINodeInfo</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.12</td>
<td>1.13</td>
</tr>
<tr>
<td><code>CSINodeInfo</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.14</td>
<td>1.16</td>
</tr>
<tr>
<td><code>CSINodeInfo</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.17</td>
<td></td>
</tr>
<tr>
<td><code>CSIPersistentVolume</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.9</td>
<td>1.9</td>
</tr>
<tr>
<td><code>CSIPersistentVolume</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.10</td>
<td>1.12</td>
</tr>
<tr>
<td><code>CSIPersistentVolume</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.13</td>
<td>-</td>
</tr>
<tr>
<td><code>CSIServiceAccountToken</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.20</td>
<td>1.20</td>
</tr>
<tr>
<td><code>CSIServiceAccountToken</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.21</td>
<td>1.21</td>
</tr>
<tr>
<td><code>CSIServiceAccountToken</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.22</td>
<td></td>
</tr>
<tr>
<td><code>CSIVolumeFSGroupPolicy</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.19</td>
<td>1.19</td>
</tr>
<tr>
<td><code>CSIVolumeFSGroupPolicy</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.20</td>
<td>1.22</td>
</tr>
<tr>
<td><code>CSIVolumeFSGroupPolicy</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.23</td>
<td></td>
</tr>
<tr>
<td><code>CronJobControllerV2</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.20</td>
<td>1.20</td>
</tr>
<tr>
<td><code>CronJobControllerV2</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.21</td>
<td>1.21</td>
</tr>
<tr>
<td><code>CronJobControllerV2</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.22</td>
<td>-</td>
</tr>
<tr>
<td><code>CustomPodDNS</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.9</td>
<td>1.9</td>
</tr>
<tr>
<td><code>CustomPodDNS</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.10</td>
<td>1.13</td>
</tr>
<tr>
<td><code>CustomPodDNS</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.14</td>
<td>-</td>
</tr>
<tr>
<td><code>CustomResourceDefaulting</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.15</td>
<td>1.15</td>
</tr>
<tr>
<td><code>CustomResourceDefaulting</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.16</td>
<td>1.16</td>
</tr>
<tr>
<td><code>CustomResourceDefaulting</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.17</td>
<td>-</td>
</tr>
<tr>
<td><code>CustomResourcePublishOpenAPI</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.14</td>
<td>1.14</td>
</tr>
<tr>
<td><code>CustomResourcePublishOpenAPI</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.15</td>
<td>1.15</td>
</tr>
<tr>
<td><code>CustomResourcePublishOpenAPI</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.16</td>
<td>-</td>
</tr>
<tr>
<td><code>CustomResourceSubresources</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.10</td>
<td>1.10</td>
</tr>
<tr>
<td><code>CustomResourceSubresources</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.11</td>
<td>1.15</td>
</tr>
<tr>
<td><code>CustomResourceSubresources</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.16</td>
<td>-</td>
</tr>
<tr>
<td><code>CustomResourceValidation</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.8</td>
<td>1.8</td>
</tr>
<tr>
<td><code>CustomResourceValidation</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.9</td>
<td>1.15</td>
</tr>
<tr>
<td><code>CustomResourceValidation</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.16</td>
<td>-</td>
</tr>
<tr>
<td><code>CustomResourceWebhookConversion</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.13</td>
<td>1.14</td>
</tr>
<tr>
<td><code>CustomResourceWebhookConversion</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.15</td>
<td>1.15</td>
</tr>
<tr>
<td><code>CustomResourceWebhookConversion</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.16</td>
<td>-</td>
</tr>
<tr>
<td><code>DryRun</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.12</td>
<td>1.12</td>
</tr>
<tr>
<td><code>DryRun</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.13</td>
<td>1.18</td>
</tr>
<tr>
<td><code>DryRun</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.19</td>
<td>-</td>
</tr>
<tr>
<td><code>DynamicAuditing</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.13</td>
<td>1.18</td>
</tr>
<tr>
<td><code>DynamicAuditing</code></td>
<td>-</td>
<td>Deprecated</td>
<td>1.19</td>
<td>-</td>
</tr>
<tr>
<td><code>DynamicKubeletConfig</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.4</td>
<td>1.10</td>
</tr>
<tr>
<td><code>DynamicKubeletConfig</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.11</td>
<td>1.21</td>
</tr>
<tr>
<td><code>DynamicKubeletConfig</code></td>
<td><code>false</code></td>
<td>Deprecated</td>
<td>1.22</td>
<td>-</td>
</tr>
<tr>
<td><code>DynamicProvisioningScheduling</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.11</td>
<td>1.11</td>
</tr>
<tr>
<td><code>DynamicProvisioningScheduling</code></td>
<td>-</td>
<td>Deprecated</td>
<td>1.12</td>
<td>-</td>
</tr>
<tr>
<td><code>DynamicVolumeProvisioning</code></td>
<td><code>true</code></td>
<td>Alpha</td>
<td>1.3</td>
<td>1.7</td>
</tr>
<tr>
<td><code>DynamicVolumeProvisioning</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.8</td>
<td>-</td>
</tr>
<tr>
<td><code>EnableAggregatedDiscoveryTimeout</code></td>
<td><code>true</code></td>
<td>Deprecated</td>
<td>1.16</td>
<td>-</td>
</tr>
<tr>
<td><code>EnableEquivalenceClassCache</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.8</td>
<td>1.14</td>
</tr>
<tr>
<td><code>EnableEquivalenceClassCache</code></td>
<td>-</td>
<td>Deprecated</td>
<td>1.15</td>
<td>-</td>
</tr>
<tr>
<td><code>EndpointSlice</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.16</td>
<td>1.16</td>
</tr>
<tr>
<td><code>EndpointSlice</code></td>
<td><code>false</code></td>
<td>Beta</td>
<td>1.17</td>
<td>1.17</td>
</tr>
<tr>
<td><code>EndpointSlice</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.18</td>
<td>1.20</td>
</tr>
<tr>
<td><code>EndpointSlice</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.21</td>
<td>-</td>
</tr>
<tr>
<td><code>EndpointSliceNodeName</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.20</td>
<td>1.20</td>
</tr>
<tr>
<td><code>EndpointSliceNodeName</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.21</td>
<td>-</td>
</tr>
<tr>
<td><code>EndpointSliceProxying</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.18</td>
<td>1.18</td>
</tr>
<tr>
<td><code>EndpointSliceProxying</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.19</td>
<td>1.21</td>
</tr>
<tr>
<td><code>EndpointSliceProxying</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.22</td>
<td>-</td>
</tr>
<tr>
<td><code>EvenPodsSpread</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.16</td>
<td>1.17</td>
</tr>
<tr>
<td><code>EvenPodsSpread</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.18</td>
<td>1.18</td>
</tr>
<tr>
<td><code>EvenPodsSpread</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.19</td>
<td>-</td>
</tr>
<tr>
<td><code>ExecProbeTimeout</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.20</td>
<td>-</td>
</tr>
<tr>
<td><code>ExperimentalCriticalPodAnnotation</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.5</td>
<td>1.12</td>
</tr>
<tr>
<td><code>ExperimentalCriticalPodAnnotation</code></td>
<td><code>false</code></td>
<td>Deprecated</td>
<td>1.13</td>
<td>-</td>
</tr>
<tr>
<td><code>ExternalPolicyForExternalIP</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.18</td>
<td>-</td>
</tr>
<tr>
<td><code>GCERegionalPersistentDisk</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.10</td>
<td>1.12</td>
</tr>
<tr>
<td><code>GCERegionalPersistentDisk</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.13</td>
<td>-</td>
</tr>
<tr>
<td><code>GenericEphemeralVolume</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.19</td>
<td>1.20</td>
</tr>
<tr>
<td><code>GenericEphemeralVolume</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.21</td>
<td>1.22</td>
</tr>
<tr>
<td><code>GenericEphemeralVolume</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.23</td>
<td>-</td>
</tr>
<tr>
<td><code>HugePageStorageMediumSize</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.18</td>
<td>1.18</td>
</tr>
<tr>
<td><code>HugePageStorageMediumSize</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.19</td>
<td>1.21</td>
</tr>
<tr>
<td><code>HugePageStorageMediumSize</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.22</td>
<td>-</td>
</tr>
<tr>
<td><code>HugePages</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.8</td>
<td>1.9</td>
</tr>
<tr>
<td><code>HugePages</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.10</td>
<td>1.13</td>
</tr>
<tr>
<td><code>HugePages</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.14</td>
<td>-</td>
</tr>
<tr>
<td><code>HyperVContainer</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.10</td>
<td>1.19</td>
</tr>
<tr>
<td><code>HyperVContainer</code></td>
<td><code>false</code></td>
<td>Deprecated</td>
<td>1.20</td>
<td>-</td>
</tr>
<tr>
<td><code>ImmutableEphemeralVolumes</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.18</td>
<td>1.18</td>
</tr>
<tr>
<td><code>ImmutableEphemeralVolumes</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.19</td>
<td>1.20</td>
</tr>
<tr>
<td><code>ImmutableEphemeralVolumes</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.21</td>
<td></td>
</tr>
<tr>
<td><code>IngressClassNamespacedParams</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.21</td>
<td>1.21</td>
</tr>
<tr>
<td><code>IngressClassNamespacedParams</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.22</td>
<td>1.22</td>
</tr>
<tr>
<td><code>IngressClassNamespacedParams</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.23</td>
<td>-</td>
</tr>
<tr>
<td><code>Initializers</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.7</td>
<td>1.13</td>
</tr>
<tr>
<td><code>Initializers</code></td>
<td>-</td>
<td>Deprecated</td>
<td>1.14</td>
<td>-</td>
</tr>
<tr>
<td><code>IPv6DualStack</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.15</td>
<td>1.20</td>
</tr>
<tr>
<td><code>IPv6DualStack</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.21</td>
<td>1.22</td>
</tr>
<tr>
<td><code>IPv6DualStack</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.23</td>
<td>-</td>
</tr>
<tr>
<td><code>KubeletConfigFile</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.8</td>
<td>1.9</td>
</tr>
<tr>
<td><code>KubeletConfigFile</code></td>
<td>-</td>
<td>Deprecated</td>
<td>1.10</td>
<td>-</td>
</tr>
<tr>
<td><code>KubeletPluginsWatcher</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.11</td>
<td>1.11</td>
</tr>
<tr>
<td><code>KubeletPluginsWatcher</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.12</td>
<td>1.12</td>
</tr>
<tr>
<td><code>KubeletPluginsWatcher</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.13</td>
<td>-</td>
</tr>
<tr>
<td><code>LegacyNodeRoleBehavior</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.16</td>
<td>1.18</td>
</tr>
<tr>
<td><code>LegacyNodeRoleBehavior</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.19</td>
<td>1.20</td>
</tr>
<tr>
<td><code>LegacyNodeRoleBehavior</code></td>
<td><code>false</code></td>
<td>GA</td>
<td>1.21</td>
<td>-</td>
</tr>
<tr>
<td><code>MountContainers</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.9</td>
<td>1.16</td>
</tr>
<tr>
<td><code>MountContainers</code></td>
<td><code>false</code></td>
<td>Deprecated</td>
<td>1.17</td>
<td>-</td>
</tr>
<tr>
<td><code>MountPropagation</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.8</td>
<td>1.9</td>
</tr>
<tr>
<td><code>MountPropagation</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.10</td>
<td>1.11</td>
</tr>
<tr>
<td><code>MountPropagation</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.12</td>
<td>-</td>
</tr>
<tr>
<td><code>NodeDisruptionExclusion</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.16</td>
<td>1.18</td>
</tr>
<tr>
<td><code>NodeDisruptionExclusion</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.19</td>
<td>1.20</td>
</tr>
<tr>
<td><code>NodeDisruptionExclusion</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.21</td>
<td>-</td>
</tr>
<tr>
<td><code>NodeLease</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.12</td>
<td>1.13</td>
</tr>
<tr>
<td><code>NodeLease</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.14</td>
<td>1.16</td>
</tr>
<tr>
<td><code>NodeLease</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.17</td>
<td>-</td>
</tr>
<tr>
<td><code>NamespaceDefaultLabelName</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.21</td>
<td>1.21</td>
</tr>
<tr>
<td><code>NamespaceDefaultLabelName</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.22</td>
<td>-</td>
</tr>
<tr>
<td><code>PVCProtection</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.9</td>
<td>1.9</td>
</tr>
<tr>
<td><code>PVCProtection</code></td>
<td>-</td>
<td>Deprecated</td>
<td>1.10</td>
<td>-</td>
</tr>
<tr>
<td><code>PersistentLocalVolumes</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.7</td>
<td>1.9</td>
</tr>
<tr>
<td><code>PersistentLocalVolumes</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.10</td>
<td>1.13</td>
</tr>
<tr>
<td><code>PersistentLocalVolumes</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.14</td>
<td>-</td>
</tr>
<tr>
<td><code>PodDisruptionBudget</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.3</td>
<td>1.4</td>
</tr>
<tr>
<td><code>PodDisruptionBudget</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.5</td>
<td>1.20</td>
</tr>
<tr>
<td><code>PodDisruptionBudget</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.21</td>
<td>-</td>
</tr>
<tr>
<td><code>PodPriority</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.8</td>
<td>1.10</td>
</tr>
<tr>
<td><code>PodPriority</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.11</td>
<td>1.13</td>
</tr>
<tr>
<td><code>PodPriority</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.14</td>
<td>-</td>
</tr>
<tr>
<td><code>PodReadinessGates</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.11</td>
<td>1.11</td>
</tr>
<tr>
<td><code>PodReadinessGates</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.12</td>
<td>1.13</td>
</tr>
<tr>
<td><code>PodReadinessGates</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.14</td>
<td>-</td>
</tr>
<tr>
<td><code>PodShareProcessNamespace</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.10</td>
<td>1.11</td>
</tr>
<tr>
<td><code>PodShareProcessNamespace</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.12</td>
<td>1.16</td>
</tr>
<tr>
<td><code>PodShareProcessNamespace</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.17</td>
<td>-</td>
</tr>
<tr>
<td><code>RequestManagement</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.15</td>
<td>1.16</td>
</tr>
<tr>
<td><code>RequestManagement</code></td>
<td>-</td>
<td>Deprecated</td>
<td>1.17</td>
<td>-</td>
</tr>
<tr>
<td><code>ResourceLimitsPriorityFunction</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.9</td>
<td>1.18</td>
</tr>
<tr>
<td><code>ResourceLimitsPriorityFunction</code></td>
<td>-</td>
<td>Deprecated</td>
<td>1.19</td>
<td>-</td>
</tr>
<tr>
<td><code>ResourceQuotaScopeSelectors</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.11</td>
<td>1.11</td>
</tr>
<tr>
<td><code>ResourceQuotaScopeSelectors</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.12</td>
<td>1.16</td>
</tr>
<tr>
<td><code>ResourceQuotaScopeSelectors</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.17</td>
<td>-</td>
</tr>
<tr>
<td><code>RootCAConfigMap</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.13</td>
<td>1.19</td>
</tr>
<tr>
<td><code>RootCAConfigMap</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.20</td>
<td>1.20</td>
</tr>
<tr>
<td><code>RootCAConfigMap</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.21</td>
<td>-</td>
</tr>
<tr>
<td><code>RotateKubeletClientCertificate</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.8</td>
<td>1.18</td>
</tr>
<tr>
<td><code>RotateKubeletClientCertificate</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.19</td>
<td>-</td>
</tr>
<tr>
<td><code>RunAsGroup</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.14</td>
<td>1.20</td>
</tr>
<tr>
<td><code>RunAsGroup</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.21</td>
<td>-</td>
</tr>
<tr>
<td><code>RuntimeClass</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.12</td>
<td>1.13</td>
</tr>
<tr>
<td><code>RuntimeClass</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.14</td>
<td>1.19</td>
</tr>
<tr>
<td><code>RuntimeClass</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.20</td>
<td>-</td>
</tr>
<tr>
<td><code>SCTPSupport</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.12</td>
<td>1.18</td>
</tr>
<tr>
<td><code>SCTPSupport</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.19</td>
<td>1.19</td>
</tr>
<tr>
<td><code>SCTPSupport</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.20</td>
<td>-</td>
</tr>
<tr>
<td><code>ScheduleDaemonSetPods</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.11</td>
<td>1.11</td>
</tr>
<tr>
<td><code>ScheduleDaemonSetPods</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.12</td>
<td>1.16</td>
</tr>
<tr>
<td><code>ScheduleDaemonSetPods</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.17</td>
<td>-</td>
</tr>
<tr>
<td><code>SelectorIndex</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.18</td>
<td>1.18</td>
</tr>
<tr>
<td><code>SelectorIndex</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.19</td>
<td>1.19</td>
</tr>
<tr>
<td><code>SelectorIndex</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.20</td>
<td>-</td>
</tr>
<tr>
<td><code>ServerSideApply</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.14</td>
<td>1.15</td>
</tr>
<tr>
<td><code>ServerSideApply</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.16</td>
<td>1.21</td>
</tr>
<tr>
<td><code>ServerSideApply</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.22</td>
<td>-</td>
</tr>
<tr>
<td><code>ServerSideFieldValidation</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.23</td>
<td>-</td>
</tr>
<tr>
<td><code>ServiceAccountIssuerDiscovery</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.18</td>
<td>1.19</td>
</tr>
<tr>
<td><code>ServiceAccountIssuerDiscovery</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.20</td>
<td>1.20</td>
</tr>
<tr>
<td><code>ServiceAccountIssuerDiscovery</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.21</td>
<td>-</td>
</tr>
<tr>
<td><code>ServiceAppProtocol</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.18</td>
<td>1.18</td>
</tr>
<tr>
<td><code>ServiceAppProtocol</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.19</td>
<td>1.19</td>
</tr>
<tr>
<td><code>ServiceAppProtocol</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.20</td>
<td>-</td>
</tr>
<tr>
<td><code>ServiceLoadBalancerFinalizer</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.15</td>
<td>1.15</td>
</tr>
<tr>
<td><code>ServiceLoadBalancerFinalizer</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.16</td>
<td>1.16</td>
</tr>
<tr>
<td><code>ServiceLoadBalancerFinalizer</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.17</td>
<td>-</td>
</tr>
<tr>
<td><code>ServiceNodeExclusion</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.8</td>
<td>1.18</td>
</tr>
<tr>
<td><code>ServiceNodeExclusion</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.19</td>
<td>1.20</td>
</tr>
<tr>
<td><code>ServiceNodeExclusion</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.21</td>
<td>-</td>
</tr>
<tr>
<td><code>ServiceTopology</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.17</td>
<td>1.19</td>
</tr>
<tr>
<td><code>ServiceTopology</code></td>
<td><code>false</code></td>
<td>Deprecated</td>
<td>1.20</td>
<td>-</td>
</tr>
<tr>
<td><code>SetHostnameAsFQDN</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.19</td>
<td>1.19</td>
</tr>
<tr>
<td><code>SetHostnameAsFQDN</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.20</td>
<td>1.21</td>
</tr>
<tr>
<td><code>SetHostnameAsFQDN</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.22</td>
<td>-</td>
</tr>
<tr>
<td><code>StartupProbe</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.16</td>
<td>1.17</td>
</tr>
<tr>
<td><code>StartupProbe</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.18</td>
<td>1.19</td>
</tr>
<tr>
<td><code>StartupProbe</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.20</td>
<td>-</td>
</tr>
<tr>
<td><code>StorageObjectInUseProtection</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.10</td>
<td>1.10</td>
</tr>
<tr>
<td><code>StorageObjectInUseProtection</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.11</td>
<td>-</td>
</tr>
<tr>
<td><code>StreamingProxyRedirects</code></td>
<td><code>false</code></td>
<td>Beta</td>
<td>1.5</td>
<td>1.5</td>
</tr>
<tr>
<td><code>StreamingProxyRedirects</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.6</td>
<td>1.17</td>
</tr>
<tr>
<td><code>StreamingProxyRedirects</code></td>
<td><code>true</code></td>
<td>Deprecated</td>
<td>1.18</td>
<td>1.21</td>
</tr>
<tr>
<td><code>StreamingProxyRedirects</code></td>
<td><code>false</code></td>
<td>Deprecated</td>
<td>1.22</td>
<td>-</td>
</tr>
<tr>
<td><code>SupportIPVSProxyMode</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.8</td>
<td>1.8</td>
</tr>
<tr>
<td><code>SupportIPVSProxyMode</code></td>
<td><code>false</code></td>
<td>Beta</td>
<td>1.9</td>
<td>1.9</td>
</tr>
<tr>
<td><code>SupportIPVSProxyMode</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.10</td>
<td>1.10</td>
</tr>
<tr>
<td><code>SupportIPVSProxyMode</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.11</td>
<td>-</td>
</tr>
<tr>
<td><code>SupportNodePidsLimit</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.14</td>
<td>1.14</td>
</tr>
<tr>
<td><code>SupportNodePidsLimit</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.15</td>
<td>1.19</td>
</tr>
<tr>
<td><code>SupportNodePidsLimit</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.20</td>
<td>-</td>
</tr>
<tr>
<td><code>SupportPodPidsLimit</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.10</td>
<td>1.13</td>
</tr>
<tr>
<td><code>SupportPodPidsLimit</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.14</td>
<td>1.19</td>
</tr>
<tr>
<td><code>SupportPodPidsLimit</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.20</td>
<td>-</td>
</tr>
<tr>
<td><code>Sysctls</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.11</td>
<td>1.20</td>
</tr>
<tr>
<td><code>Sysctls</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.21</td>
<td></td>
</tr>
<tr>
<td><code>TTLAfterFinished</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.12</td>
<td>1.20</td>
</tr>
<tr>
<td><code>TTLAfterFinished</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.21</td>
<td>1.22</td>
</tr>
<tr>
<td><code>TTLAfterFinished</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.23</td>
<td>-</td>
</tr>
<tr>
<td><code>TaintBasedEvictions</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.6</td>
<td>1.12</td>
</tr>
<tr>
<td><code>TaintBasedEvictions</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.13</td>
<td>1.17</td>
</tr>
<tr>
<td><code>TaintBasedEvictions</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.18</td>
<td>-</td>
</tr>
<tr>
<td><code>TaintNodesByCondition</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.8</td>
<td>1.11</td>
</tr>
<tr>
<td><code>TaintNodesByCondition</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.12</td>
<td>1.16</td>
</tr>
<tr>
<td><code>TaintNodesByCondition</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.17</td>
<td>-</td>
</tr>
<tr>
<td><code>TokenRequest</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.10</td>
<td>1.11</td>
</tr>
<tr>
<td><code>TokenRequest</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.12</td>
<td>1.19</td>
</tr>
<tr>
<td><code>TokenRequest</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.20</td>
<td>-</td>
</tr>
<tr>
<td><code>TokenRequestProjection</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.11</td>
<td>1.11</td>
</tr>
<tr>
<td><code>TokenRequestProjection</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.12</td>
<td>1.19</td>
</tr>
<tr>
<td><code>TokenRequestProjection</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.20</td>
<td>-</td>
</tr>
<tr>
<td><code>ValidateProxyRedirects</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.12</td>
<td>1.13</td>
</tr>
<tr>
<td><code>ValidateProxyRedirects</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.14</td>
<td>1.21</td>
</tr>
<tr>
<td><code>ValidateProxyRedirects</code></td>
<td><code>true</code></td>
<td>Deprecated</td>
<td>1.22</td>
<td>-</td>
</tr>
<tr>
<td><code>VolumePVCDataSource</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.15</td>
<td>1.15</td>
</tr>
<tr>
<td><code>VolumePVCDataSource</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.16</td>
<td>1.17</td>
</tr>
<tr>
<td><code>VolumePVCDataSource</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.18</td>
<td>-</td>
</tr>
<tr>
<td><code>VolumeScheduling</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.9</td>
<td>1.9</td>
</tr>
<tr>
<td><code>VolumeScheduling</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.10</td>
<td>1.12</td>
</tr>
<tr>
<td><code>VolumeScheduling</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.13</td>
<td>-</td>
</tr>
<tr>
<td><code>VolumeSnapshotDataSource</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.12</td>
<td>1.16</td>
</tr>
<tr>
<td><code>VolumeSnapshotDataSource</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.17</td>
<td>1.19</td>
</tr>
<tr>
<td><code>VolumeSnapshotDataSource</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.20</td>
<td>-</td>
</tr>
<tr>
<td><code>VolumeSubpath</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.10</td>
<td>-</td>
</tr>
<tr>
<td><code>VolumeSubpathEnvExpansion</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.14</td>
<td>1.14</td>
</tr>
<tr>
<td><code>VolumeSubpathEnvExpansion</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.15</td>
<td>1.16</td>
</tr>
<tr>
<td><code>VolumeSubpathEnvExpansion</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.17</td>
<td>-</td>
</tr>
<tr>
<td><code>WarningHeaders</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.19</td>
<td>1.21</td>
</tr>
<tr>
<td><code>WarningHeaders</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.22</td>
<td>-</td>
</tr>
<tr>
<td><code>WatchBookmark</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.15</td>
<td>1.15</td>
</tr>
<tr>
<td><code>WatchBookmark</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.16</td>
<td>1.16</td>
</tr>
<tr>
<td><code>WatchBookmark</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.17</td>
<td>-</td>
</tr>
<tr>
<td><code>WindowsEndpointSliceProxying</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.19</td>
<td>1.20</td>
</tr>
<tr>
<td><code>WindowsEndpointSliceProxying</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.21</td>
<td>1.21</td>
</tr>
<tr>
<td><code>WindowsEndpointSliceProxying</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.22</td>
<td>-</td>
</tr>
<tr>
<td><code>WindowsGMSA</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.14</td>
<td>1.15</td>
</tr>
<tr>
<td><code>WindowsGMSA</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.16</td>
<td>1.17</td>
</tr>
<tr>
<td><code>WindowsGMSA</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.18</td>
<td>-</td>
</tr>
<tr>
<td><code>WindowsRunAsUserName</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.16</td>
<td>1.16</td>
</tr>
<tr>
<td><code>WindowsRunAsUserName</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.17</td>
<td>1.17</td>
</tr>
<tr>
<td><code>WindowsRunAsUserName</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.18</td>
<td>-</td>
</tr>
</tbody>
</table>
<h2 id=using-a-feature>使用特性 </h2>
<h3 id=feature-stages>特性阶段 </h3>
<p>处于 <em>Alpha</em> 、<em>Beta</em> 、 <em>GA</em> 阶段的特性。</p>
<p><em>Alpha</em> 特性代表：</p>
<ul>
<li>默认禁用。</li>
<li>可能有错误，启用此特性可能会导致错误。</li>
<li>随时可能删除对此特性的支持，恕不另行通知。</li>
<li>在以后的软件版本中，API 可能会以不兼容的方式更改，恕不另行通知。</li>
<li>建议将其仅用于短期测试中，因为开启特性会增加错误的风险，并且缺乏长期支持。</li>
</ul>
<p><em>Beta</em> 特性代表：</p>
<ul>
<li>默认启用。</li>
<li>该特性已经经过良好测试。启用该特性是安全的。</li>
<li>尽管详细信息可能会更改，但不会放弃对整体特性的支持。</li>
<li>对象的架构或语义可能会在随后的 Beta 或稳定版本中以不兼容的方式更改。当发生这种情况时，我们将提供迁移到下一版本的说明。此特性可能需要删除、编辑和重新创建 API 对象。编辑过程可能需要慎重操作，因为这可能会导致依赖该特性的应用程序停机。</li>
<li>推荐仅用于非关键业务用途，因为在后续版本中可能会发生不兼容的更改。如果你具有多个可以独立升级的，则可以放宽此限制。</li>
</ul>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong>
<p>请试用 <em>Beta</em> 特性并提供相关反馈！
一旦特性结束 Beta 状态，我们就不太可能再对特性进行大幅修改。
</div>
<p><em>General Availability</em> (GA) 特性也称为 <em>稳定</em> 特性，<em>GA</em> 特性代表着：</p>
<ul>
<li>此特性会一直启用；你不能禁用它。</li>
<li>不再需要相应的特性门控。</li>
<li>对于许多后续版本，特性的稳定版本将出现在发行的软件中。</li>
</ul>
<h3 id=特性门控列表>特性门控列表</h3>
<p>每个特性门控均用于启用或禁用某个特定的特性：</p>
<ul>
<li><code>APIListChunking</code>：启用 API 客户端以块的形式从 API 服务器检索（“LIST” 或 “GET”）资源。</li>
<li><code>APIPriorityAndFairness</code>: 在每个服务器上启用优先级和公平性来管理请求并发。（由 <code>RequestManagement</code> 重命名而来）</li>
<li><code>APIResponseCompression</code>：压缩 “LIST” 或 “GET” 请求的 API 响应。</li>
<li><code>APIServerIdentity</code>：为集群中的每个 API 服务器赋予一个 ID。</li>
<li><code>APIServerTracing</code>: 为集群中的每个 API 服务器添加对分布式跟踪的支持。</li>
</ul>
<ul>
<li><code>Accelerators</code>：使用 Docker Engine 时启用 Nvidia GPU 支持。这一特性不再提供。
关于替代方案，请参阅<a href=/zh/docs/concepts/extend-kubernetes/compute-storage-net/device-plugins/>设备插件</a>。</li>
<li><code>AdvancedAuditing</code>：启用<a href=/zh/docs/tasks/debug-application-cluster/audit/#advanced-audit>高级审计功能</a>。</li>
<li><code>AffinityInAnnotations</code>：启用 <a href=/zh/docs/concepts/scheduling-eviction/assign-pod-node/#affinity-and-anti-affinity>Pod 亲和或反亲和</a>。</li>
<li><code>AllowExtTrafficLocalEndpoints</code>：启用服务用于将外部请求路由到节点本地终端。</li>
<li><code>AllowInsecureBackendProxy</code>：允许用户在执行 Pod 日志访问请求时跳过 TLS 验证。</li>
<li><code>AnyVolumeDataSource</code>: 允许使用任何自定义的资源来做作为
<a class=glossary-tooltip title=声明在持久卷中定义的存储资源，以便可以将其挂载为容器中的卷。 data-toggle=tooltip data-placement=top href=/zh/docs/concepts/storage/persistent-volumes/ target=_blank aria-label=PVC>PVC</a> 中的 <code>DataSource</code>.</li>
<li><code>AppArmor</code>：在 Linux 节点上为 Pod 启用基于 AppArmor 机制的强制访问控制。
请参见 <a href=/zh/docs/tutorials/security/apparmor/>AppArmor 教程</a> 获取详细信息。</li>
</ul>
<ul>
<li><code>AttachVolumeLimit</code>：启用卷插件用于报告可连接到节点的卷数限制。有关更多详细信息，请参阅
<a href=/zh/docs/concepts/storage/storage-limits/#dynamic-volume-limits>动态卷限制</a>。</li>
<li><code>BalanceAttachedNodeVolumes</code>：在进行平衡资源分配的调度时，考虑节点上的卷数。
调度器在决策时会优先考虑 CPU、内存利用率和卷数更近的节点。</li>
<li><code>BlockVolume</code>：在 Pod 中启用原始块设备的定义和使用。有关更多详细信息，请参见
<a href=/zh/docs/concepts/storage/persistent-volumes/#raw-block-volume-support>原始块卷支持</a>。</li>
<li><code>BoundServiceAccountTokenVolume</code>：迁移 ServiceAccount 卷以使用由
ServiceAccountTokenVolumeProjection 组成的投射卷。集群管理员可以使用
<code>serviceaccount_stale_tokens_total</code> 度量值来监控依赖于扩展令牌的负载。
如果没有这种类型的负载，你可以在启动 <code>kube-apiserver</code> 时添加
<code>--service-account-extend-token-expiration=false</code> 参数关闭扩展令牌。查看
<a href=https://github.com/kubernetes/enhancements/blob/master/keps/sig-auth/1205-bound-service-account-tokens/README.md>绑定服务账号令牌</a>
获取更多详细信息。</li>
<li><code>ControllerManagerLeaderMigration</code>: 为
<a href=/zh/docs/tasks/administer-cluster/controller-manager-leader-migration/#initial-leader-migration-configuration>kube-controller-manager</a> 和
<a href=/zh/docs/tasks/administer-cluster/controller-manager-leader-migration/#deploy-cloud-controller-manager>cloud-controller-manager</a>
启用 Leader 迁移，它允许集群管理者在没有停机的高可用集群环境下，实时
把 kube-controller-manager 迁移迁移到外部的 controller-manager (例如 cloud-controller-manager) 中。</li>
</ul>
<ul>
<li><code>CPUManager</code>：启用容器级别的 CPU 亲和性支持，有关更多详细信息，请参见
<a href=/zh/docs/tasks/administer-cluster/cpu-management-policies/>CPU 管理策略</a>。</li>
<li><code>CPUManagerPolicyAlphaOptions</code>：允许对 CPUManager 策略进行微调，针对试验性的、
alpha 质量级别的选项。
此特性门控用来保护一组质量级别为 alpha 的 CPUManager 选项。
此特性门控永远不会被升级为 beta 或者稳定版本。</li>
<li><code>CPUManagerPolicyBetaOptions</code>：允许对 CPUManager 策略进行微调，针对试验性的、
beta 质量级别的选项。
此特性门控用来保护一组质量级别为 beta 的 CPUManager 选项。
此特性门控永远不会被升级为稳定版本。</li>
<li><code>CPUManagerPolicyOptions</code>: 允许微调 CPU 管理策略。</li>
</ul>
<ul>
<li><code>CRIContainerLogRotation</code>：为 CRI 容器运行时启用容器日志轮换。日志文件的默认最大大小为
10MB，缺省情况下，一个容器允许的最大日志文件数为5。这些值可以在kubelet配置中配置。
更多细节请参见 <a href=/zh/docs/concepts/cluster-administration/logging/#logging-at-the-node-level>日志架构</a>。</li>
<li><code>CSIBlockVolume</code>：启用外部 CSI 卷驱动程序用于支持块存储。有关更多详细信息，请参见
<a href=/zh/docs/concepts/storage/volumes/#csi-raw-block-volume-support><code>csi</code> 原始块卷支持</a>。</li>
<li><code>CSIDriverRegistry</code>：在 csi.storage.k8s.io 中启用与 CSIDriver API 对象有关的所有逻辑。</li>
<li><code>CSIInlineVolume</code>：为 Pod 启用 CSI 内联卷支持。</li>
<li><code>CSIMigration</code>：确保封装和转换逻辑能够将卷操作从内嵌插件路由到相应的预安装 CSI 插件。</li>
</ul>
<ul>
<li><code>CSIMigrationAWS</code>：确保填充和转换逻辑能够将卷操作从 AWS-EBS 内嵌插件路由到 EBS CSI 插件。
如果节点禁用了此特性门控或者未安装和配置 EBS CSI 插件，支持回退到内嵌 EBS 插件
来执行卷挂载操作。不支持回退到这些插件来执行卷制备操作，因为需要安装并配置 CSI 插件。</li>
<li><code>CSIMigrationAWSComplete</code>：停止在 kubelet 和卷控制器中注册 EBS 内嵌插件，
并启用填充和转换逻辑将卷操作从 AWS-EBS 内嵌插件路由到 EBS CSI 插件。
这需要启用 CSIMigration 和 CSIMigrationAWS 特性标志，并在集群中的所有节点上安装和配置
EBS CSI 插件。该特性标志已被废弃，取而代之的是 <code>InTreePluginAWSUnregister</code> ，
后者会阻止注册 EBS 内嵌插件。</li>
</ul>
<ul>
<li><code>CSIMigrationAzureDisk</code>：确保填充和转换逻辑能够将卷操作从 AzureDisk 内嵌插件路由到
Azure 磁盘 CSI 插件。对于禁用了此特性的节点或者没有安装并配置 AzureDisk CSI
插件的节点，支持回退到内嵌（in-tree）AzureDisk 插件来执行磁盘挂载操作。
不支持回退到内嵌插件来执行磁盘制备操作，因为对应的 CSI 插件必须已安装且正确配置。
此特性需要启用 CSIMigration 特性标志。</li>
<li><code>CSIMigrationAzureDiskComplete</code>：停止在 kubelet 和卷控制器中注册 Azure 磁盘内嵌插件，
并启用 shims 和转换逻辑以将卷操作从 Azure 磁盘内嵌插件路由到 AzureDisk CSI 插件。
这需要启用 CSIMigration 和 CSIMigrationAzureDisk 特性标志，
并在集群中的所有节点上安装和配置 AzureDisk CSI 插件。该特性标志已被废弃，取而代之的是
能防止注册内嵌 AzureDisk 插件的 <code>InTreePluginAzureDiskUnregister</code> 特性标志。</li>
</ul>
<ul>
<li><code>CSIMigrationAzureFile</code>：确保封装和转换逻辑能够将卷操作从 AzureFile 内嵌插件路由到
AzureFile CSI 插件。对于禁用了此特性的节点或者没有安装并配置 AzureFile CSI
插件的节点，支持回退到内嵌（in-tree）AzureFile 插件来执行卷挂载操作。
不支持回退到内嵌插件来执行卷制备操作，因为对应的 CSI 插件必须已安装且正确配置。
此特性需要启用 CSIMigration 特性标志。</li>
<li><code>CSIMigrationAzureFileComplete</code>：停止在 kubelet 和卷控制器中注册 Azure-File 内嵌插件，
并启用 shims 和转换逻辑以将卷操作从 Azure-File 内嵌插件路由到 AzureFile CSI 插件。
这需要启用 CSIMigration 和 CSIMigrationAzureFile 特性标志，
并在集群中的所有节点上安装和配置 AzureFile CSI 插件。该特性标志已被废弃，取而代之的是
能防止注册内嵌 AzureDisk 插件的 <code>InTreePluginAzureFileUnregister</code> 特性标志。</li>
</ul>
<ul>
<li><code>CSIMigrationGCE</code>：启用填充和转换逻辑，将卷操作从 GCE-PD 内嵌插件路由到
PD CSI 插件。对于禁用了此特性的节点或者没有安装并配置 PD CSI 插件的节点，
支持回退到内嵌（in-tree）GCE 插件来执行挂载操作。
不支持回退到内嵌插件来执行制备操作，因为对应的 CSI 插件必须已安装且正确配置。
此特性需要启用 CSIMigration 特性标志。</li>
<li><code>CSIMigrationGCEComplete</code>：停止在 kubelet 和卷控制器中注册 GCE-PD 内嵌插件，
并启用 shims 和转换逻辑以将卷操作从 GCE-PD 内嵌插件路由到 PD CSI 插件。
这需要启用 CSIMigration 和 CSIMigrationGCE 特性标志，并在集群中的所有节点上
安装和配置 PD CSI 插件。该特性标志已被废弃，取而代之的是
能防止注册内嵌 GCE PD 插件的 <code>InTreePluginGCEUnregister</code> 特性标志。</li>
</ul>
<ul>
<li><code>csiMigrationRBD</code>：启用填充和转换逻辑，将卷操作从 RBD 的内嵌插件路由到 Ceph RBD
CSI 插件。此特性要求 CSIMigration 和 csiMigrationRBD 特性标志均被启用，
且集群中安装并配置了 Ceph CSI 插件。此标志已被弃用，以鼓励使用
<code>InTreePluginRBDUnregister</code> 特性标志。后者会禁止注册内嵌的 RBD 插件。</li>
</ul>
<ul>
<li><code>CSIMigrationOpenStack</code>：确保填充和转换逻辑能够将卷操作从 Cinder 内嵌插件路由到
Cinder CSI 插件。对于禁用了此特性的节点或者没有安装并配置 Cinder CSI 插件的节点，
支持回退到内嵌（in-tree）Cinder 插件来执行挂载操作。
不支持回退到内嵌插件来执行制备操作，因为对应的 CSI 插件必须已安装且正确配置。
此磁特性需要启用 CSIMigration 特性标志。</li>
<li><code>CSIMigrationOpenStackComplete</code>：停止在 kubelet 和卷控制器中注册 Cinder 内嵌插件，
并启用填充和转换逻辑将卷操作从 Cinder 内嵌插件路由到 Cinder CSI 插件。
这需要启用 CSIMigration 和 CSIMigrationOpenStack 特性标志，并在集群中的所有节点上
安装和配置 Cinder CSI 插件。该特性标志已被弃用，取而代之的是
能防止注册内嵌 OpenStack Cinder 插件的 <code>InTreePluginOpenStackUnregister</code> 特性标志。</li>
</ul>
<ul>
<li><code>CSIMigrationvSphere</code>: 允许封装和转换逻辑将卷操作从 vSphere 内嵌插件路由到
vSphere CSI 插件。如果节点禁用了此特性门控或者未安装和配置 vSphere CSI 插件，
则支持回退到 vSphere 内嵌插件来执行挂载操作。
不支持回退到内嵌插件来执行制备操作，因为对应的 CSI 插件必须已安装且正确配置。
这需要启用 CSIMigration 特性标志。</li>
<li><code>CSIMigrationvSphereComplete</code>: 停止在 kubelet 和卷控制器中注册 vSphere 内嵌插件，
并启用填充和转换逻辑以将卷操作从 vSphere 内嵌插件路由到 vSphere CSI 插件。
这需要启用 CSIMigration 和 CSIMigrationvSphere 特性标志，并在集群中的所有节点上
安装和配置 vSphere CSI 插件。该特性标志已被废弃，取而代之的是
能防止注册内嵌 vsphere 插件的 <code>InTreePluginvSphereUnregister</code> 特性标志。</li>
</ul>
<ul>
<li><code>CSIMigrationPortworx</code>：启用填充和转换逻辑，将卷操作从 Portworx 内嵌插件路由到
Portworx CSI 插件。需要在集群中安装并配置 Portworx CSI 插件，并针对 kube-controller-manager
和 kubelet 配置启用特性门控 <code>CSIMigrationPortworx=true</code>。</li>
</ul>
<ul>
<li><code>CSINodeInfo</code>：在 csi.storage.k8s.io 中启用与 CSINodeInfo API 对象有关的所有逻辑。</li>
<li><code>CSIPersistentVolume</code>：启用发现和挂载通过
<a href=https://github.com/kubernetes/community/blob/master/contributors/design-proposals/storage/container-storage-interface.md>CSI（容器存储接口）</a>
兼容卷插件配置的卷。</li>
<li><code>CSIServiceAccountToken</code>: 允许 CSI 驱动接收挂载卷目标 Pods 的服务账户令牌。
参阅<a href=https://kubernetes-csi.github.io/docs/token-requests.html>令牌请求（Token Requests）</a>。</li>
<li><code>CSIStorageCapacity</code>: 使 CSI 驱动程序可以发布存储容量信息，并使 Kubernetes
调度程序在调度 Pod 时使用该信息。参见
<a href=/zh/docs/concepts/storage/storage-capacity/>存储容量</a>。
详情请参见 <a href=/zh/docs/concepts/storage/volumes/#csi><code>csi</code> 卷类型</a>。</li>
</ul>
<ul>
<li><code>CSIVolumeFSGroupPolicy</code>：允许 CSIDrivers 使用 <code>fsGroupPolicy</code> 字段.
该字段能控制由 CSIDriver 创建的卷在挂载这些卷时是否支持卷所有权和权限修改。</li>
<li><code>CSIVolumeHealth</code>：启用对节点上的 CSI volume 运行状况监控的支持</li>
<li><code>CSRDuration</code>：允许客户端来通过请求 Kubernetes CSR API 签署的证书的持续时间。</li>
<li><code>ConfigurableFSGroupPolicy</code>：在 Pod 中挂载卷时，允许用户为 fsGroup
配置卷访问权限和属主变更策略。请参见
<a href=/zh/docs/tasks/configure-pod-container/security-context/#configure-volume-permission-and-ownership-change-policy-for-pods>为 Pod 配置卷访问权限和属主变更策略</a>。</li>
<li><code>ControllerManagerLeaderMigration</code>：为 <code>kube-controller-manager</code> 和 <code>cloud-controller-manager</code>
开启领导者迁移功能。</li>
<li><code>CronJobControllerV2</code>：使用 <a class=glossary-tooltip title=周期调度的任务（作业）。 data-toggle=tooltip data-placement=top href=/zh/docs/concepts/workloads/controllers/cron-jobs/ target=_blank aria-label=CronJob>CronJob</a>
控制器的一种替代实现。否则，系统会选择同一控制器的 v1 版本。</li>
</ul>
<ul>
<li><code>CustomCPUCFSQuotaPeriod</code>：使节点能够更改
<a href=/zh/docs/tasks/administer-cluster/kubelet-config-file/>kubelet 配置</a>
中的 <code>cpuCFSQuotaPeriod</code>。</li>
<li><code>CustomResourceValidationExpressions</code>：启用 CRD 中的表达式语言合法性检查，
基于 <code>x-kubernetes-validations</code> 扩展中所书写的合法性检查规则来验证定制资源。</li>
<li><code>CustomPodDNS</code>：允许使用 Pod 的 <code>dnsConfig</code> 属性自定义其 DNS 设置。
更多详细信息，请参见
<a href=/zh/docs/concepts/services-networking/dns-pod-service/#pods-dns-config>Pod 的 DNS 配置</a>。</li>
</ul>
<ul>
<li><code>CustomResourceDefaulting</code>：为 CRD 启用在其 OpenAPI v3 验证模式中提供默认值的支持。</li>
<li><code>CustomResourcePublishOpenAPI</code>：启用 CRD OpenAPI 规范的发布。</li>
<li><code>CustomResourceSubresources</code>：对于用
<a href=/zh/docs/concepts/extend-kubernetes/api-extension/custom-resources/>CustomResourceDefinition</a>
创建的资源启用其 <code>/status</code> 和 <code>/scale</code> 子资源。</li>
<li><code>CustomResourceValidation</code>：对于用
<a href=/zh/docs/concepts/extend-kubernetes/api-extension/custom-resources/>CustomResourceDefinition</a>
创建的资源启用基于模式的验证。</li>
<li><code>CustomResourceWebhookConversion</code>：对于用
<a href=/zh/docs/concepts/extend-kubernetes/api-extension/custom-resources/>CustomResourceDefinition</a>
创建的资源启用基于 Webhook 的转换。</li>
<li><code>DaemonSetUpdateSurge</code>: 使 DaemonSet 工作负载在每个节点的更新期间保持可用性。
参阅<a href=/zh/docs/tasks/manage-daemon/update-daemon-set/>对 DaemonSet 执行滚动更新</a>。</li>
</ul>
<ul>
<li><code>DefaultPodTopologySpread</code>: 启用 <code>PodTopologySpread</code> 调度插件来完成
<a href=/zh/docs/concepts/workloads/pods/pod-topology-spread-constraints/#internal-default-constraints>默认的调度传播</a>.</li>
<li><code>DelegateFSGroupToCSIDriver</code>: 如果 CSI 驱动程序支持，则通过 NodeStageVolume 和
NodePublishVolume CSI 调用传递 <code>fsGroup</code> ，将应用 <code>fsGroup</code> 从 Pod 的
<code>securityContext</code> 的角色委托给驱动。</li>
<li><code>DevicePlugins</code>：在节点上启用基于
<a href=/zh/docs/concepts/extend-kubernetes/compute-storage-net/device-plugins/>设备插件</a>
的资源制备。</li>
<li><code>DisableAcceleratorUsageMetrics</code>：
<a href=/zh/docs/concepts/cluster-administration/system-metrics/#disable-accelerator-metrics>禁用 kubelet 收集加速器指标</a>.</li>
</ul>
<ul>
<li><code>DisableCloudProviders</code>: 禁用 <code>kube-apiserver</code>，<code>kube-controller-manager</code> 和
<code>kubelet</code> 组件的 <code>--cloud-provider</code> 标志相关的所有功能。</li>
<li><code>DisableKubeletCloudCredentialProviders</code>：禁用 kubelet 中为拉取镜像内置的凭据机制，
该凭据用于向某云提供商的容器镜像仓库执行身份认证。</li>
<li><code>DownwardAPIHugePages</code>：允许在
<a href=/zh/docs/tasks/inject-data-application/downward-api-volume-expose-pod-information>下行（Downward）API</a>
中使用巨页信息。</li>
<li><code>DryRun</code>：启用在服务器端对请求进行
<a href=/zh/docs/reference/using-api/api-concepts/#dry-run>试运行（Dry Run）</a>，
以便测试验证、合并和修改，同时避免提交更改。</li>
<li><code>DynamicAuditing</code>：在 v1.19 版本前用于启用动态审计。</li>
</ul>
<ul>
<li><code>DynamicKubeletConfig</code>：启用 kubelet 的动态配置。请参阅
<a href=/zh/docs/tasks/administer-cluster/reconfigure-kubelet/>重新配置 kubelet</a>。</li>
<li><code>DynamicProvisioningScheduling</code>：扩展默认调度器以了解卷拓扑并处理 PV 配置。
此特性已在 v1.12 中完全被 <code>VolumeScheduling</code> 特性取代。</li>
<li><code>DynamicVolumeProvisioning</code>：启用持久化卷到 Pod
的<a href=/zh/docs/concepts/storage/dynamic-provisioning/>动态预配置</a>。</li>
<li><code>EfficientWatchResumption</code>：允许从存储发起的 bookmark（进度通知）事件被通知到用户。
此特性仅适用于 watch 操作。</li>
<li><code>EnableAggregatedDiscoveryTimeout</code>：对聚集的发现调用启用五秒钟超时设置。</li>
</ul>
<ul>
<li><code>EnableEquivalenceClassCache</code>：调度 Pod 时，使 scheduler 缓存节点的等效项。</li>
<li><code>EndpointSlice</code>：启用 EndpointSlice 以实现可扩缩性和可扩展性更好的网络端点。
参阅<a href=/zh/docs/concepts/services-networking/endpoint-slices/>启用 EndpointSlice</a>。</li>
<li><code>EndpointSliceNodeName</code>：允许使用 EndpointSlice 的 <code>nodeName</code> 字段。</li>
<li><code>EndpointSliceProxying</code>：启用此特性门控时，Linux 上运行的 kube-proxy 会使用
EndpointSlices 而不是 Endpoints 作为其主要数据源，从而使得可扩缩性和性能提升成为可能。
参阅<a href=/zh/docs/concepts/services-networking/endpoint-slices/>启用 EndpointSlice</a>。</li>
<li><code>EndpointSliceTerminatingCondition</code>：允许使用 EndpointSlice 的 <code>terminating</code> 和
<code>serving</code> 状况字段。</li>
</ul>
<ul>
<li><code>EphemeralContainers</code>：启用添加
<a class=glossary-tooltip title="您可以在 Pod 中临时运行的一种容器类型" data-toggle=tooltip data-placement=top href=/zh/docs/concepts/workloads/pods/ephemeral-containers/ target=_blank aria-label=临时容器>临时容器</a>
到正在运行的 Pod 的特性。</li>
<li><code>EvenPodsSpread</code>：使 Pod 能够在拓扑域之间平衡调度。请参阅
<a href=/zh/docs/concepts/workloads/pods/pod-topology-spread-constraints/>Pod 拓扑扩展约束</a>。</li>
<li><code>ExecProbeTimeout</code>：确保 kubelet 会遵从 exec 探针的超时值设置。
此特性门控的主要目的是方便你处理现有的、依赖于已被修复的缺陷的工作负载；
该缺陷导致 Kubernetes 会忽略 exec 探针的超时值设置。
参阅<a href=/zh/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/#configure-probes>就绪态探针</a>.</li>
</ul>
<ul>
<li><code>ExpandCSIVolumes</code>: 启用扩展 CSI 卷。</li>
<li><code>ExpandedDNSConfig</code>: 在 kubelet 和 kube-apiserver 上启用后，
允许使用更多的 DNS 搜索域和搜索域列表。此功能特性需要容器运行时
（Containerd：v1.5.6 或更高，CRI-O：v1.22 或更高）的支持。参阅
<a href=/zh/docs/concepts/services-networking/dns-pod-service/#expanded-dns-configuration>扩展 DNS 配置</a>.</li>
<li><code>ExpandInUsePersistentVolumes</code>：启用扩充使用中的 PVC 的尺寸。请查阅
<a href=/zh/docs/concepts/storage/persistent-volumes/#resizing-an-in-use-persistentvolumeclaim>调整使用中的 PersistentVolumeClaim 的大小</a>。</li>
<li><code>ExpandPersistentVolumes</code>：允许扩充持久卷。请查阅
<a href=/zh/docs/concepts/storage/persistent-volumes/#expanding-persistent-volumes-claims>扩展持久卷申领</a>。</li>
<li><code>ExperimentalCriticalPodAnnotation</code>：启用将特定 Pod 注解为 <em>critical</em> 的方式，用于
<a href=/zh/docs/tasks/administer-cluster/guaranteed-scheduling-critical-addon-pods/>确保其被调度</a>。
从 v1.13 开始已弃用此特性，转而使用 Pod 优先级和抢占功能。</li>
</ul>
<ul>
<li><code>ExperimentalHostUserNamespaceDefaulting</code>：启用主机默认的用户名字空间。
这适用于使用其他主机名字空间、主机安装的容器，或具有特权或使用特定的非名字空间功能
（例如 MKNODE、SYS_MODULE 等）的容器。
如果在 Docker 守护程序中启用了用户名字空间重新映射，则启用此选项。</li>
<li><code>ExternalPolicyForExternalIP</code>： 修复 ExternalPolicyForExternalIP 没有应用于
Service ExternalIPs 的缺陷。</li>
<li><code>GCERegionalPersistentDisk</code>：在 GCE 上启用带地理区域信息的 PD 特性。</li>
<li><code>GenericEphemeralVolume</code>：启用支持临时的内联卷，这些卷支持普通卷
（可以由第三方存储供应商提供、存储容量跟踪、从快照还原等等）的所有功能。
请参见<a href=/zh/docs/concepts/storage/ephemeral-volumes/>临时卷</a>。</li>
<li><code>GracefulNodeShutdown</code>：在 kubelet 中启用体面地关闭节点的支持。
在系统关闭时，kubelet 会尝试监测该事件并体面地终止节点上运行的 Pods。
参阅<a href=/zh/docs/concepts/architecture/nodes/#graceful-node-shutdown>体面地关闭节点</a>
以了解更多细节。</li>
</ul>
<ul>
<li><code>GracefulNodeShutdownBasedOnPodPriority</code>：允许 kubelet 在体面终止节点时检查
Pod 的优先级。</li>
<li><code>GRPCContainerProbe</code>：为 LivenessProbe、ReadinessProbe、StartupProbe 启用 gRPC 探针。
参阅<a href=/zh/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/#define-a-grpc-liveness-probe>配置活跃态、就绪态和启动探针</a>。</li>
<li><code>HonorPVReclaimPolicy</code>：无论 PV 和 PVC 的删除顺序如何，当持久卷申领的策略为 <code>Delete</code>
时，确保这种策略得到处理。</li>
</ul>
<ul>
<li><code>HPAContainerMetrics</code>：允许 <code>HorizontalPodAutoscaler</code> 基于目标 Pods 中各容器
的度量值来执行扩缩操作。</li>
<li><code>HPAScaleToZero</code>：使用自定义指标或外部指标时，可将 <code>HorizontalPodAutoscaler</code>
资源的 <code>minReplicas</code> 设置为 0。</li>
<li><code>HugePages</code>：启用分配和使用预分配的
<a href=/zh/docs/tasks/manage-hugepages/scheduling-hugepages/>巨页资源</a>。</li>
<li><code>HugePageStorageMediumSize</code>：启用支持多种大小的预分配
<a href=/zh/docs/tasks/manage-hugepages/scheduling-hugepages/>巨页资源</a>。</li>
<li><code>HyperVContainer</code>：为 Windows 容器启用
<a href=https://docs.microsoft.com/en-us/virtualization/windowscontainers/manage-containers/hyperv-container>Hyper-V 隔离</a>。</li>
</ul>
<ul>
<li><code>IdentifyPodOS</code>：允许设置 Pod 的 OS 字段。这一设置有助于在 API 服务器准入期间确定性地辨识
Pod 的 OS。在 Kubernetes 1.23 中，<code>pod.spec.os.name</code> 可选的值包括
<code>windows</code> 和 <code>linux</code>。</li>
<li><code>ImmutableEphemeralVolumes</code>：允许将各个 Secret 和 ConfigMap 标记为不可变更的，
以提高安全性和性能。</li>
<li><code>InTreePluginAWSUnregister</code>: 在 kubelet 和卷控制器上关闭注册 aws-ebs 内嵌插件。</li>
<li><code>InTreePluginAzureDiskUnregister</code>: 在 kubelet 和卷控制器上关闭注册 azuredisk 内嵌插件。</li>
<li><code>InTreePluginAzureFileUnregister</code>: 在 kubelet 和卷控制器上关闭注册 azurefile 内嵌插件。</li>
</ul>
<ul>
<li><code>InTreePluginGCEUnregister</code>: 在 kubelet 和卷控制器上关闭注册 gce-pd 内嵌插件。</li>
<li><code>InTreePluginOpenStackUnregister</code>: 在 kubelet 和卷控制器上关闭注册 OpenStack cinder 内嵌插件。</li>
<li><code>InTreePluginPortworxUnregister</code>: 在 kubelet 和卷控制器上关闭注册 Portworx 内嵌插件。</li>
<li><code>InTreePluginRBDUnregister</code>: 在 kubelet 和卷控制器上关闭注册 RBD 内嵌插件。</li>
</ul>
<ul>
<li><code>InTreePluginvSphereUnregister</code>: 在 kubelet 和卷控制器上关闭注册 vSphere 内嵌插件。</li>
<li><code>IndexedJob</code>：允许 <a href=/zh/docs/concepts/workloads/controllers/job/>Job</a>
控制器根据完成索引来管理 Pod 完成。</li>
<li><code>IngressClassNamespacedParams</code>：允许在 <code>IngressClass</code> 资源中引用命名空间范围的参数。
该特性增加了两个字段 —— <code>scope</code>、<code>namespace</code> 到 <code>IngressClass.spec.parameters</code>。</li>
<li><code>Initializers</code>： 使用 Initializers 准入插件允许异步协调对象创建。</li>
</ul>
<ul>
<li><code>IPv6DualStack</code>：启用<a href=/zh/docs/concepts/services-networking/dual-stack/>双协议栈</a>
以支持 IPv6。</li>
<li><code>JobMutableNodeSchedulingDirectives</code>：允许在 <a href=/docs/concepts/workloads/controllers/job>Job</a>
的 Pod 模板中更新节点调度指令。</li>
<li><code>JobReadyPods</code>：允许跟踪<a href=/zh/docs/concepts/workloads/pods/pod-lifecycle/#pod-conditions>状况</a>为
<code>Ready</code> 的 Pod 的个数。<code>Ready</code> 的 Pod 记录在
<a href=/zh/docs/concepts/workloads/controllers/job>Job</a> 对象的
<a href=/docs/reference/kubernetes-api/workload-resources/job-v1/#JobStatus>status</a> 字段中。</li>
</ul>
<ul>
<li><code>JobTrackingWithFinalizers</code>: 启用跟踪 <a href=/zh/docs/concepts/workloads/controllers/job>Job</a>
完成情况，而不是永远从集群剩余 Pod 来获取信息判断完成情况。Job 控制器使用
Pod finalizers 和 Job 状态中的一个字段来跟踪已完成的 Pod 以计算完成。</li>
<li><code>KubeletConfigFile</code>：启用从使用配置文件指定的文件中加载 kubelet 配置。
有关更多详细信息，请参见
<a href=/zh/docs/tasks/administer-cluster/kubelet-config-file/>通过配置文件设置 kubelet 参数</a>。</li>
</ul>
<ul>
<li><code>KubeletCredentialProviders</code>：允许使用 kubelet exec 凭据提供程序来设置镜像拉取凭据。</li>
<li><code>KubeletInUserNamespace</code>: 支持在<a class=glossary-tooltip title="一种为非特权用户模拟超级用户特权的 Linux 内核功能特性。" data-toggle=tooltip data-placement=top href=https://man7.org/linux/man-pages/man7/user_namespaces.7.html target=_blank aria-label=用户名字空间>用户名字空间</a>
里运行 kubelet 。
请参见<a href=/zh/docs/tasks/administer-cluster/kubelet-in-userns/>使用非 Root 用户来运行 Kubernetes 节点组件</a>。</li>
<li><code>KubeletPluginsWatcher</code>：启用基于探针的插件监视应用程序，使 kubelet 能够发现类似
<a href=/zh/docs/concepts/storage/volumes/#csi>CSI 卷驱动程序</a>这类插件。</li>
</ul>
<ul>
<li><code>KubeletPodResources</code>：启用 kubelet 上 Pod 资源 GRPC 端点。更多详细信息，
请参见<a href=https://github.com/kubernetes/enhancements/blob/master/keps/sig-node/compute-device-assignment.md>支持设备监控</a>。</li>
<li><code>KubeletPodResourcesGetAllocatable</code>：启用 kubelet 的 pod 资源的
<code>GetAllocatableResources</code> 功能。
该 API 增强了<a href=/zh/docs/concepts/extend-kubernetes/compute-storage-net/device-plugins/#monitoring-device-plugin-resources>资源分配报告</a>
包含有关可分配资源的信息，使客户端能够正确跟踪节点上的可用计算资源。</li>
<li><code>LegacyNodeRoleBehavior</code>：禁用此门控时，服务负载均衡器中和节点干扰中的原先行为会忽略
<code>node-role.kubernetes.io/master</code> 标签，使用 <code>NodeDisruptionExclusion</code> 和
<code>ServiceNodeExclusion</code> 对应特性所提供的标签。</li>
</ul>
<ul>
<li><code>LocalStorageCapacityIsolation</code>：允许使用
<a href=/zh/docs/concepts/configuration/manage-resources-containers/>本地临时存储</a>
以及 <a href=/zh/docs/concepts/storage/volumes/#emptydir>emptyDir 卷</a>的 <code>sizeLimit</code> 属性。</li>
<li><code>LocalStorageCapacityIsolationFSQuotaMonitoring</code>：如果
<a href=/zh/docs/concepts/configuration/manage-resources-containers/>本地临时存储</a>启用了
<code>LocalStorageCapacityIsolation</code>，并且
<a href=/zh/docs/concepts/storage/volumes/#emptydir>emptyDir 卷</a>的后备文件系统支持项目配额，
并且启用了这些配额，将使用项目配额来监视
<a href=/zh/docs/concepts/storage/volumes/#emptydir>emptyDir 卷</a>的存储消耗而不是遍历文件系统，
以此获得更好的性能和准确性。</li>
</ul>
<ul>
<li><code>LogarithmicScaleDown</code>：启用 Pod 的半随机（semi-random）选择，控制器将根据 Pod
时间戳的对数桶按比例缩小去驱逐 Pod。</li>
<li><code>MemoryManager</code>: 允许基于 NUMA 拓扑为容器设置内存亲和性。</li>
<li><code>MemoryQoS</code>: 使用 cgroup v2 内存控制器在 pod / 容器上启用内存保护和使用限制。</li>
<li><code>MixedProtocolLBService</code>：允许在同一 <code>LoadBalancer</code> 类型的 Service 实例中使用不同的协议。</li>
<li><code>MountContainers</code>：允许使用主机上的工具容器作为卷挂载程序。</li>
</ul>
<ul>
<li><code>MountPropagation</code>：启用将一个容器安装的共享卷共享到其他容器或 Pod。
更多详细信息，请参见<a href=/zh/docs/concepts/storage/volumes/#mount-propagation>挂载传播</a>。</li>
<li><code>NamespaceDefaultLabelName</code>：配置 API 服务器以在所有名字空间上设置一个不可变的
<a class=glossary-tooltip title=用来为对象设置可标识的属性标记；这些标记对用户而言是有意义且重要的。 data-toggle=tooltip data-placement=top href=/zh/docs/concepts/overview/working-with-objects/labels/ target=_blank aria-label=标签>标签</a> <code>kubernetes.io/metadata.name</code>，
也包括名字空间。</li>
<li><code>NodeDisruptionExclusion</code>：启用节点标签 <code>node.kubernetes.io/exclude-disruption</code>，
以防止在可用区发生故障期间驱逐节点。</li>
<li><code>NodeLease</code>：启用新的 Lease（租期）API 以报告节点心跳，可用作节点运行状况信号。</li>
</ul>
<ul>
<li><code>NodeSwap</code>: 启用 kubelet 为节点上的 Kubernetes 工作负载分配交换内存的能力。
必须将 <code>KubeletConfiguration.failSwapOn</code> 设置为 false 的情况下才能使用。
更多详细信息，请参见<a href=/zh/docs/concepts/architecture/nodes/#swap-memory>交换内存</a>。</li>
<li><code>NonPreemptingPriority</code>：为 PriorityClass 和 Pod 启用 <code>preemptionPolicy</code> 选项。</li>
<li><code>OpenAPIEnums</code>：允许在从 API 服务器返回的 spec 中填充 OpenAPI 模式的 "enum" 字段。</li>
<li><code>OpenAPIV3</code>：允许 API 服务器发布 OpenAPI V3。</li>
<li><code>PVCProtection</code>：启用防止仍被某 Pod 使用的 PVC 被删除的特性。</li>
</ul>
<ul>
<li><code>PodDeletionCost</code>：启用 <a href=/zh/docs/concepts/workloads/controllers/replicaset/#pod-deletion-cost>Pod 删除成本</a>功能。
该功能使用户可以影响 ReplicaSet 的降序顺序。</li>
<li><code>PersistentLocalVolumes</code>：允许在 Pod 中使用 <code>local（本地）</code> 卷类型。
如果请求 <code>local</code> 卷，则必须指定 Pod 亲和性属性。</li>
<li><code>PodDisruptionBudget</code>：启用 <a href=/zh/docs/tasks/run-application/configure-pdb/>PodDisruptionBudget</a> 特性。</li>
<li><code>PodAffinityNamespaceSelector</code>：启用 <a href=/zh/docs/concepts/scheduling-eviction/assign-pod-node/#namespace-selector>Pod 亲和性名称空间选择器</a>
和 <a href=/zh/docs/concepts/policy/resource-quotas/#cross-namespace-pod-affinity-quota>CrossNamespacePodAffinity</a>
资源配额功能。</li>
<li><code>PodOverhead</code>：启用 <a href=/zh/docs/concepts/scheduling-eviction/pod-overhead/>PodOverhead</a>
特性以考虑 Pod 开销。</li>
</ul>
<ul>
<li><code>PodPriority</code>：启用根据<a href=/zh/docs/concepts/scheduling-eviction/pod-priority-preemption/>优先级</a>
的 Pod 调度和抢占。</li>
<li><code>PodReadinessGates</code>：启用 <code>podReadinessGate</code> 字段的设置以扩展 Pod 准备状态评估。
有关更多详细信息，请参见
<a href=/zh/docs/concepts/workloads/pods/pod-lifecycle/#pod-readiness-gate>Pod 就绪状态判别</a>。</li>
<li><code>PodSecurity</code>: 开启 <code>PodSecurity</code> 准入控制插件。</li>
<li><code>PodShareProcessNamespace</code>：在 Pod 中启用 <code>shareProcessNamespace</code> 的设置，
以便在 Pod 中运行的容器之间共享同一进程名字空间。更多详细信息，请参见
<a href=/zh/docs/tasks/configure-pod-container/share-process-namespace/>在 Pod 中的容器间共享同一进程名字空间</a>。</li>
<li><code>PreferNominatedNode</code>: 这个标志告诉调度器在循环遍历集群中的所有其他节点之前，
是否首先检查指定的节点。</li>
</ul>
<ul>
<li><code>ProbeTerminationGracePeriod</code>：在 Pod 上 启用
<a href=/zh/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/#probe-level-terminationgraceperiodseconds>设置探测器级别 <code>terminationGracePeriodSeconds</code></a>。
有关更多信息，请参见<a href=https://github.com/kubernetes/enhancements/tree/master/keps/sig-node/2238-liveness-probe-grace-period>改进提案</a>。</li>
<li><code>ProcMountType</code>：允许容器通过设置 SecurityContext 的 <code>procMount</code> 字段来控制对
proc 文件系统的挂载方式。</li>
<li><code>ProxyTerminatingEndpoints</code>: 当 <code>ExternalTrafficPolicy=Local</code> 时，
允许 kube-proxy 来处理终止过程中的端点。</li>
<li><code>QOSReserved</code>：允许在 QoS 级别进行资源预留，以防止处于较低 QoS 级别的 Pod
突发进入处于较高 QoS 级别的请求资源（目前仅适用于内存）。</li>
<li><code>ReadWriteOncePod</code>: 允许使用 <code>ReadWriteOncePod</code> 访问模式的 PersistentVolume。</li>
</ul>
<ul>
<li><code>RecoverVolumeExpansionFailure</code>：允许用户编辑其 PVC 来缩小其尺寸，
从而从之前卷扩容发生的失败中恢复。更多细节可参见
<a href=/zh/docs/concepts/storage/persistent-volumes/#recovering-from-failure-when-expanding-volumes>从卷扩容失效中恢复</a>。</li>
<li><code>RemainingItemCount</code>：允许 API 服务器在
<a href=/zh/docs/reference/using-api/api-concepts/#retrieving-large-results-sets-in-chunks>分块列表请求</a>
的响应中显示剩余条目的个数。</li>
<li><code>RemoveSelfLink</code>：将 ObjectMeta 和 ListMeta 中的 <code>selfLink</code> 字段废弃并删除。</li>
<li><code>RequestManagement</code>：允许在每个 API 服务器上通过优先级和公平性管理请求并发性。
自 1.17 以来已被 <code>APIPriorityAndFairness</code> 替代。</li>
</ul>
<ul>
<li><code>ResourceLimitsPriorityFunction</code>：启用某调度器优先级函数，
该函数将最低得分 1 指派给至少满足输入 Pod 的 CPU 和内存限制之一的节点，
目的是打破得分相同的节点之间的关联。</li>
<li><code>ResourceQuotaScopeSelectors</code>：启用资源配额范围选择器。</li>
<li><code>RootCAConfigMap</code>：配置 <code>kube-controller-manager</code>，使之发布一个名为 <code>kube-root-ca.crt</code>
的 <a class=glossary-tooltip title="ConfigMap 是一种 API 对象，用来将非机密性的数据保存到键值对中。使用时可以用作环境变量、命令行参数或者存储卷中的配置文件。" data-toggle=tooltip data-placement=top href=/zh/docs/tasks/configure-pod-container/configure-pod-configmap/ target=_blank aria-label=ConfigMap>ConfigMap</a>，
到所有名字空间中。该 ConfigMap 包含用来验证与 kube-apiserver 之间连接的 CA 证书包。
参阅<a href=https://github.com/kubernetes/enhancements/blob/master/keps/sig-auth/1205-bound-service-account-tokens/README.md>绑定服务账户令牌</a>
以了解更多细节。</li>
</ul>
<ul>
<li><code>RotateKubeletClientCertificate</code>：在 kubelet 上启用客户端 TLS 证书的轮换。
更多详细信息，请参见
<a href=/zh/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/#kubelet-configuration>kubelet 配置</a>。</li>
<li><code>RotateKubeletServerCertificate</code>：在 kubelet 上启用服务器 TLS 证书的轮换。
更多详细信息，请参见
<a href=/zh/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/#kubelet-configuration>kubelet 配置</a>。</li>
<li><code>RunAsGroup</code>：启用对容器初始化过程中设置的主要组 ID 的控制。</li>
</ul>
<ul>
<li><code>RuntimeClass</code>：启用 <a href=/zh/docs/concepts/containers/runtime-class/>RuntimeClass</a>
特性用于选择容器运行时配置。</li>
<li><code>ScheduleDaemonSetPods</code>：启用 DaemonSet Pods 由默认调度程序而不是
DaemonSet 控制器进行调度。</li>
<li><code>SCTPSupport</code>：在 Pod、Service、Endpoints、NetworkPolicy 定义中允许将 'SCTP'
用作 <code>protocol</code> 值。</li>
<li><code>SeccompDefault</code>: 允许将所有工作负载的默认 seccomp 配置文件为 <code>RuntimeDefault</code>。
seccomp 配置在 Pod 或者容器的 <code>securityContext</code> 字段中指定。</li>
<li><code>SelectorIndex</code>: 允许使用 API 服务器的 watch 缓存中基于标签和字段的索引来加速 list 操作。</li>
</ul>
<ul>
<li><code>ServerSideApply</code>：在 API 服务器上启用
<a href=/zh/docs/reference/using-api/server-side-apply/>服务器端应用（SSA）</a> 。</li>
<li><code>ServiceAccountIssuerDiscovery</code>：在 API 服务器中为服务帐户颁发者启用 OIDC 发现端点
（颁发者和 JWKS URL）。详情参见
<a href=/zh/docs/tasks/configure-pod-container/configure-service-account/#service-account-issuer-discovery>为 Pod 配置服务账户</a> 。</li>
<li><code>ServiceAppProtocol</code>：为 Service 和 Endpoints 启用 <code>appProtocol</code> 字段。</li>
<li><code>ServiceInternalTrafficPolicy</code>：为服务启用 <code>internalTrafficPolicy</code> 字段。</li>
<li><code>ServiceLBNodePortControl</code>：为服务启用 <code>allocateLoadBalancerNodePorts</code> 字段。</li>
</ul>
<ul>
<li><code>ServiceLoadBalancerClass</code>: 为服务启用 <code>loadBalancerClass</code> 字段。
有关更多信息，请参见<a href=/zh/docs/concepts/services-networking/service/#load-balancer-class>指定负载均衡器实现类</a>。</li>
<li><code>ServiceLoadBalancerFinalizer</code>：为服务负载均衡启用终结器（finalizers）保护。</li>
<li><code>ServiceNodeExclusion</code>：启用从云提供商创建的负载均衡中排除节点。
如果节点标记有 <code>node.kubernetes.io/exclude-from-external-load-balancers</code>，
标签，则可以排除该节点。</li>
<li><code>ServiceTopology</code>：启用服务拓扑可以让一个服务基于集群的节点拓扑进行流量路由。
有关更多详细信息，请参见<a href=/zh/docs/concepts/services-networking/service-topology/>服务拓扑</a>。</li>
</ul>
<ul>
<li><code>SetHostnameAsFQDN</code>：启用将全限定域名（FQDN）设置为 Pod 主机名的功能。
请参见<a href=/zh/docs/concepts/services-networking/dns-pod-service/#pod-sethostnameasfqdn-field>为 Pod 设置 <code>setHostnameAsFQDN</code> 字段</a>。</li>
<li><code>SizeMemoryBackedVolumes</code>：允许 kubelet 检查基于内存制备的卷的尺寸约束
（目前主要针对 <code>emptyDir</code> 卷）。</li>
<li><code>StartupProbe</code>：在 kubelet 中启用
<a href=/zh/docs/concepts/workloads/pods/pod-lifecycle/#when-should-you-use-a-startup-probe>启动探针</a>。</li>
<li><code>StatefulSetMinReadySeconds</code>: 允许 StatefulSet 控制器采纳 <code>minReadySeconds</code> 设置。</li>
</ul>
<ul>
<li><code>StorageObjectInUseProtection</code>：如果仍在使用 PersistentVolume 或
PersistentVolumeClaim 对象，则将其删除操作推迟。</li>
<li><code>StorageVersionAPI</code>: 启用
<a href=/docs/reference/generated/kubernetes-api/v1.23/#storageversion-v1alpha1-internal-apiserver-k8s-io>存储版本 API</a>。</li>
<li><code>StorageVersionHash</code>：允许 API 服务器在版本发现中公开存储版本的哈希值。</li>
<li><code>StreamingProxyRedirects</code>：指示 API 服务器拦截（并跟踪）后端（kubelet）
的重定向以处理流请求。
流请求的例子包括 <code>exec</code>、<code>attach</code> 和 <code>port-forward</code> 请求。</li>
</ul>
<ul>
<li><code>SupportIPVSProxyMode</code>：启用使用 IPVS 提供集群内服务负载平衡。更多详细信息，请参见
<a href=/zh/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies>服务代理</a>。</li>
<li><code>SupportNodePidsLimit</code>：启用支持，限制节点上的 PID 用量。
<code>--system-reserved</code> 和 <code>--kube-reserved</code> 中的参数 <code>pid=&lt;数值></code> 可以分别用来
设定为整个系统所预留的进程 ID 个数和为 Kubernetes 系统守护进程预留的进程 ID 个数。</li>
<li><code>SupportPodPidsLimit</code>：启用支持限制 Pod 中的进程 PID。</li>
</ul>
<ul>
<li><code>SuspendJob</code>： 启用支持以暂停和恢复作业。 更多详细信息，请参见
<a href=/zh/docs/concepts/workloads/controllers/job/>Jobs 文档</a>。</li>
<li><code>Sysctls</code>：允许为每个 Pod 设置的名字空间内核参数（sysctls）。
更多详细信息，请参见 <a href=/zh/docs/tasks/administer-cluster/sysctl-cluster/>sysctls</a>。</li>
<li><code>TTLAfterFinished</code>：资源完成执行后，允许
<a href=/zh/docs/concepts/workloads/controllers/ttlafterfinished/>TTL 控制器</a>清理资源。</li>
</ul>
<ul>
<li><code>TaintBasedEvictions</code>：根据节点上的污点和 Pod 上的容忍度启用从节点驱逐 Pod 的特性。
更多详细信息可参见<a href=/zh/docs/concepts/scheduling-eviction/taint-and-toleration/>污点和容忍度</a>。</li>
<li><code>TaintNodesByCondition</code>：根据<a href=/zh/docs/concepts/scheduling-eviction/taint-and-toleration/>节点状况</a>
启用自动为节点标记污点。</li>
<li><code>TokenRequest</code>：在服务帐户资源上启用 <code>TokenRequest</code> 端点。</li>
<li><code>TokenRequestProjection</code>：启用通过
<a href=/zh/docs/concepts/storage/volumes/#projected><code>projected</code> 卷</a>
将服务帐户令牌注入到 Pod 中的特性。</li>
</ul>
<ul>
<li><code>TopologyAwareHints</code>： 在 EndpointSlices 中启用基于拓扑提示的拓扑感知路由。
更多详细信息可参见<a href=/zh/docs/concepts/services-networking/topology-aware-hints/>拓扑感知提示</a>。</li>
<li><code>TopologyManager</code>：启用一种机制来协调 Kubernetes 不同组件的细粒度硬件资源分配。
详见<a href=/zh/docs/tasks/administer-cluster/topology-manager/>控制节点上的拓扑管理策略</a>。</li>
<li><code>ValidateProxyRedirects</code>： 这个标志控制 API 服务器是否应该验证只跟随到相同的主机的重定向。
仅在启用 <code>StreamingProxyRedirects</code> 标志时被使用。</li>
</ul>
<ul>
<li><code>VolumeCapacityPriority</code>: 基于可用 PV 容量的拓扑，启用对不同节点的优先级支持。</li>
<li><code>VolumePVCDataSource</code>：启用对将现有 PVC 指定数据源的支持。</li>
<li><code>VolumeScheduling</code>：启用卷拓扑感知调度，并使 PersistentVolumeClaim（PVC）
绑定能够了解调度决策；当与 PersistentLocalVolumes 特性门控一起使用时，
还允许使用 <a href=/zh/docs/concepts/storage/volumes/#local><code>local</code></a> 卷类型。</li>
<li><code>VolumeSnapshotDataSource</code>：启用卷快照数据源支持。</li>
<li><code>VolumeSubpath</code>： 允许在容器中挂载卷的子路径。</li>
</ul>
<ul>
<li><code>VolumeSubpathEnvExpansion</code>：启用 <code>subPathExpr</code> 字段用于在 <code>subPath</code> 中展开环境变量。</li>
<li><code>WarningHeaders</code>：允许在 API 响应中发送警告头部。</li>
<li><code>WatchBookmark</code>：启用对 watch 操作中 bookmark 事件的支持。</li>
<li><code>WinDSR</code>：允许 kube-proxy 为 Windows 创建 DSR 负载均衡。</li>
<li><code>WinOverlay</code>：允许在 Windows 的覆盖网络模式下运行 kube-proxy 。</li>
</ul>
<ul>
<li><code>WindowsEndpointSliceProxying</code>: 当启用时，运行在 Windows 上的 kube-proxy
将使用 EndpointSlices 而不是 Endpoints 作为主要数据源，从而实现可伸缩性和并改进性能。
详情请参见<a href=/zh/docs/concepts/services-networking/endpoint-slices/>启用端点切片</a>.</li>
<li><code>WindowsGMSA</code>：允许将 GMSA 凭据规范从 Pod 传递到容器运行时。</li>
<li><code>WindowsHostProcessContainers</code>: 启用对 Windows HostProcess 容器的支持。</li>
<li><code>WindowsRunAsUserName</code>：提供使用非默认用户在 Windows 容器中运行应用程序的支持。
详情请参见
<a href=/zh/docs/tasks/configure-pod-container/configure-runasusername>配置 RunAsUserName</a>。</li>
</ul>
<h2 id=what-s-next>What's next</h2>
<ul>
<li>Kubernetes 的<a href=/zh/docs/reference/using-api/deprecation-policy/>弃用策略</a>
介绍了项目针对已移除特性和组件的处理方法。</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-29e506a6018204679ef5459653a7aa1f>11.2 - kubelet</h1>
<h2 id=synopsis>Synopsis</h2>
<p>kubelet 是在每个 Node 节点上运行的主要 “节点代理”。它可以使用以下之一向 apiserver 注册：
主机名（hostname）；覆盖主机名的参数；某云驱动的特定逻辑。</p>
<p>kubelet 是基于 PodSpec 来工作的。每个 PodSpec 是一个描述 Pod 的 YAML 或 JSON 对象。
kubelet 接受通过各种机制（主要是通过 apiserver）提供的一组 PodSpec，并确保这些
PodSpec 中描述的容器处于运行状态且运行状况良好。
kubelet 不管理不是由 Kubernetes 创建的容器。</p>
<p>除了来自 apiserver 的 PodSpec 之外，还可以通过以下三种方式将容器清单（manifest）提供给 kubelet。</p>
<p>文件（File）：利用命令行参数传递路径。kubelet 周期性地监视此路径下的文件是否有更新。
监视周期默认为 20s，且可通过参数进行配置。</p>
<p>HTTP 端点（HTTP endpoint）：利用命令行参数指定 HTTP 端点。
此端点的监视周期默认为 20 秒，也可以使用参数进行配置。</p>
<p>HTTP 服务器（HTTP server）：kubelet 还可以侦听 HTTP 并响应简单的 API
（目前没有完整规范）来提交新的清单。</p>
<pre><code>kubelet [flags]
</code></pre><h2 id=options>Options</h2>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--add-dir-header</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
设置为 true 表示将文件目录添加到日志消息的头部
</td>
</tr>
<tr>
<td colspan=2>--address ip&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：0.0.0.0</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubelet 用来提供服务的 IP 地址（设置为<code>0.0.0.0</code> 表示使用所有 IPv4 接口，
设置为 <code>::</code> 表示使用所有 IPv6 接口）。已弃用：应在 <code>--config</code> 所给的
配置文件中进行设置。（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--allowed-unsafe-sysctls strings</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
用逗号分隔的字符串序列设置允许使用的非安全的 sysctls 或 sysctl 模式（以 <code>*</code> 结尾) 。
使用此参数时风险自担。已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--alsologtostderr</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
设置为 true 表示将日志输出到文件的同时输出到 stderr
</td>
</tr>
<tr>
<td colspan=2>--anonymous-auth&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：true</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
设置为 true 表示 kubelet 服务器可以接受匿名请求。未被任何认证组件拒绝的请求将被视为匿名请求。
匿名请求的用户名为 <code>system:anonymous</code>，用户组为 <code>system:unauthenticated</code>。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--authentication-token-webhook</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
使用 <code>TokenReview</code> API 对持有者令牌进行身份认证。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--authentication-token-webhook-cache-ttl duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：<code>2m0s</code></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对 Webhook 令牌认证组件所返回的响应的缓存时间。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--authorization-mode string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubelet 服务器的鉴权模式。可选值包括：<code>AlwaysAllow</code>、<code>Webhook</code>。<code>Webhook</code> 模式使用 <code>SubjectAccessReview</code> API 鉴权。
当 <code>--config</code> 参数未被设置时，默认值为 <code>AlwaysAllow</code>，当使用了
<code>--config</code> 时，默认值为 <code>Webhook</code>。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--authorization-webhook-cache-authorized-ttl duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：<code>5m0s</code></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对 Webhook 认证组件所返回的 “Authorized（已授权）” 应答的缓存时间。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--authorization-webhook-cache-unauthorized-ttl duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：<code>30s</code></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对 Webhook 认证组件所返回的 “Unauthorized（未授权）” 应答的缓存时间。
<code>--config</code> 时，默认值为 <code>Webhook</code>。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--azure-container-registry-config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
包含 Azure 容器镜像库配置信息的文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--bootstrap-kubeconfig string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
某 kubeconfig 文件的路径，该文件将用于获取 kubelet 的客户端证书。
如果 <code>--kubeconfig</code> 所指定的文件不存在，则使用引导所用 kubeconfig
从 API 服务器请求客户端证书。成功后，将引用生成的客户端证书和密钥的 kubeconfig
写入 --kubeconfig 所指定的路径。客户端证书和密钥文件将存储在 <code>--cert-dir</code>
所指的目录。
</td>
</tr>
<tr>
<td colspan=2>--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：<code>/var/lib/kubelet/pki</code></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
TLS 证书所在的目录。如果设置了 <code>--tls-cert-file</code> 和 <code>--tls-private-key-file</code>，
则此标志将被忽略。
</td>
</tr>
<tr>
<td colspan=2>--cgroup-driver string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：<code>cgroupfs</code></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubelet 用来操作本机 cgroup 时使用的驱动程序。支持的选项包括 <code>cgroupfs</code>
和 <code>systemd</code>。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--cgroup-root string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：<code>""</code></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
可选的选项，为 Pod 设置根 cgroup。容器运行时会尽可能使用此配置。
默认值 <code>""</code> 意味着将使用容器运行时的默认设置。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--cgroups-per-qos&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：<code>true</code></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
启用创建 QoS cgroup 层次结构。此值为 true 时 kubelet 为 QoS 和 Pod 创建顶级的 cgroup。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--chaos-chance float</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果此值大于 0.0，则引入随机客户端错误和延迟。用于测试。
已启用：将在未来版本中移除。
</td>
</tr>
<tr>
<td colspan=2>--client-ca-file string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果设置了此参数，则使用对应文件中机构之一检查请求中所携带的客户端证书。
若客户端证书通过身份认证，则其对应身份为其证书中所设置的 CommonName。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--cloud-config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
云驱动配置文件的路径。空字符串表示没有配置文件。
已弃用：将在 1.24 或更高版本中移除，以便于从 kubelet 中去除云驱动代码。
</td>
</tr>
<tr>
<td colspan=2>--cloud-provider string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
云服务的提供者。设置为空字符串表示在没有云驱动的情况下运行。
如果设置了此标志，则云驱动负责确定节点的名称（参考云提供商文档以确定是否以及如何使用主机名）。
已弃用：将在 1.24 或更高版本中移除，以便于从 kubelet 中去除云驱动代码。
</td>
</tr>
<tr>
<td colspan=2>--cluster-dns strings</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
DNS 服务器的 IP 地址，以逗号分隔。此标志值用于 Pod 中设置了 “<code>dnsPolicy=ClusterFirst</code>”
时为容器提供 DNS 服务。注意：列表中出现的所有 DNS 服务器必须包含相同的记录组，
否则集群中的名称解析可能无法正常工作。至于名称解析过程中会牵涉到哪些 DNS 服务器，
这一点无法保证。
<code>--config</code> 时，默认值为 <code>Webhook</code>。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--cluster-domain string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
集群的域名。如果设置了此值，kubelet 除了将主机的搜索域配置到所有容器之外，还会为其
配置所搜这里指定的域名。
<code>--config</code> 时，默认值为 <code>Webhook</code>。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--cni-bin-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：<code>/opt/cni/bin</code></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
&lt;警告：alpha 特性> 此值为以逗号分隔的完整路径列表。
kubelet 将在所指定路径中搜索 CNI 插件的可执行文件。
仅当容器运行环境设置为 <code>docker</code> 时，此特定于 docker 的参数才有效。
</td>
</tr>
<tr>
<td colspan=2>--cni-cache-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：<code>/var/lib/cni/cache</code></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
&lt;警告：alpha 特性> 此值为一个目录的全路径名。CNI 将在其中缓存文件。
仅当容器运行环境设置为 <code>docker</code> 时，此特定于 docker 的参数才有效。
</td>
</tr>
<tr>
<td colspan=2>--cni-conf-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：<code>/etc/cni/net.d</code></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
&lt;警告：alpha 特性> 此值为某目录的全路径名。kubelet 将在其中搜索 CNI 配置文件。
仅当容器运行环境设置为 <code>docker</code> 时，此特定于 docker 的参数才有效。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubelet 将从此标志所指的文件中加载其初始配置。此路径可以是绝对路径，也可以是相对路径。
相对路径按 kubelet 的当前工作目录起计。省略此参数时 kubelet 会使用内置的默认配置值。
命令行参数会覆盖此文件中的配置。
</td>
</tr>
<tr>
<td colspan=2>--container-log-max-files int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：5</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
设置容器的日志文件个数上限。此值必须不小于 2。
此标志只能与 <code>--container-runtime=remote</code> 标志一起使用。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--container-log-max-size string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：<code>10Mi</code></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
设置容器日志文件在轮换生成新文件时之前的最大值（例如，<code>10Mi</code>）。
此标志只能与 <code>--container-runtime=remote</code> 标志一起使用。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--container-runtime string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：<code>docker</code></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
要使用的容器运行时。目前支持 <code>docker<code>、</code>remote</code>。
</td>
</tr>
<tr>
<td colspan=2>--container-runtime-endpoint string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：<code>unix:///var/run/dockershim.sock</code></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验性特性] 远程运行时服务的端点。目前支持 Linux 系统上的 UNIX 套接字和
Windows 系统上的 npipe 和 TCP 端点。例如：
<code>unix:///var/run/dockershim.sock</code>、
<code>npipe:////./pipe/dockershim</code>。
</td>
</tr>
<tr>
<td colspan=2>--contention-profiling</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
当启用了性能分析时，启用锁竞争分析。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--cpu-cfs-quota&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：<code>true</code></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为设置了 CPU 限制的容器启用 CPU CFS 配额保障。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--cpu-cfs-quota-period duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：<code>100ms</code></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
设置 CPU CFS 配额周期 <code>cpu.cfs_period_us</code>。默认使用 Linux 内核所设置的默认值 。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--cpu-manager-policy string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：<code>none</code></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
要使用的 CPU 管理器策略。可选值包括：<code>none</code> 和 <code>static</code>。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--cpu-manager-reconcile-period duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：<code>10s</code></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
&lt;警告：alpha 特性> 设置 CPU 管理器的调和时间。例如：<code>10s</code> 或者 <code>1m</code>。
如果未设置，默认使用节点状态更新频率。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--docker-endpoint string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：<code>unix:///var/run/docker.sock</code></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
使用这里的端点与 docker 端点通信。
仅当容器运行环境设置为 <code>docker</code> 时，此特定于 docker 的参数才有效。
</td>
</tr>
<tr>
<td colspan=2>--dynamic-config-dir string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubelet 使用此目录来保存所下载的配置，跟踪配置运行状况。
如果目录不存在，则 kubelet 创建该目录。此路径可以是绝对路径，也可以是相对路径。
相对路径从 kubelet 的当前工作目录计算。
设置此参数将启用动态 kubelet 配置。必须启用 <code>DynamicKubeletConfig</code>
特性门控之后才能设置此标志。
(已弃用：DynamicKubeletConfig 功能在 1.22 中已弃用，不会移至 GA。
计划在 1.24 或更高版本中从 Kubernetes 中移除。
请使用其他方式来更新 kubelet 配置。)
</td>
</tr>
<tr>
<td colspan=2>--enable-controller-attach-detach&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：<code>true</code></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
启用 Attach/Detach 控制器来挂接和摘除调度到该节点的卷，同时禁用 kubelet 执行挂接和摘除操作。
</td>
</tr>
<tr>
<td colspan=2>--enable-debugging-handlers&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：<code>true</code></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
启用服务器上用于日志收集和在本地运行容器和命令的端点。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--enable-server&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
启用 kubelet 服务器。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--enforce-node-allocatable strings&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：<code>pods</code></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
用逗号分隔的列表，包含由 kubelet 强制执行的节点可分配资源级别。
可选配置为：<code>none</code>、<code>pods</code>、<code>system-reserved</code> 和 <code>kube-reserved</code>。
在设置 <code>system-reserved</code> 和 <code>kube-reserved</code> 这两个值时，同时要求设置
<code>--system-reserved-cgroup</code> 和 <code>--kube-reserved-cgroup</code> 这两个参数。
如果设置为 <code>none</code>，则不需要设置其他参数。
<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/reserve-compute-resources/>参考相关文档</a>。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--event-burst int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：10</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
事件记录的个数的突发峰值上限，在遵从 <code>--event-qps</code> 阈值约束的前提下
临时允许事件记录达到此数目。仅在 <code>--event-qps</code> 大于 0 时使用。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--event-qps int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：5</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
设置大于 0 的值表示限制每秒可生成的事件数量。设置为 0 表示不限制。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--eviction-hard string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：<code>imagefs.available&lt;15%,memory.available&lt;100Mi,nodefs.available&lt;10%</code></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
触发 Pod 驱逐操作的一组硬性门限（例如：<code>memory.available&lt;1Gi</code>
（内存可用值小于 1 G））设置。在 Linux 节点上，默认值还包括
<code>nodefs.inodesFree<5%</code>。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--eviction-max-pod-grace-period int32</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
响应满足软性驱逐阈值（Soft Eviction Threshold）而终止 Pod 时使用的最长宽限期（以秒为单位）。
如果设置为负数，则遵循 Pod 的指定值。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--eviction-minimum-reclaim mapStringString</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
当某资源压力过大时，kubelet 将执行 Pod 驱逐操作。
此参数设置软性驱逐操作需要回收的资源的最小数量（例如：<code>imagefs.available=2Gi</code>）。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--eviction-pressure-transition-period duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：<code>5m0s</code></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubelet 在驱逐压力状况解除之前的最长等待时间。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--eviction-soft mapStringString</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
设置一组驱逐阈值（例如：<code>memory.available&lt;1.5Gi</code>）。
如果在相应的宽限期内达到该阈值，则会触发 Pod 驱逐操作。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--eviction-soft-grace-period mapStringString</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
设置一组驱逐宽限期（例如，<code>memory.available=1m30s</code>），对应于触发软性 Pod
驱逐操作之前软性驱逐阈值所需持续的时间长短。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--exit-on-lock-contention</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
设置为 true 表示当发生锁文件竞争时 kubelet 可以退出。
</td>
</tr>
<tr>
<td colspan=2>--experimental-allocatable-ignore-eviction&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：<code>false</code></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
设置为 <code>true</code> 表示在计算节点可分配资源数量时忽略硬性逐出阈值设置。
参考<a href=https://kubernetes.io/docs/tasks/administer-cluster/reserve-compute-resources/>
相关文档</a>。
已启用：将在 1.24 或更高版本中移除。
</td>
</tr>
<tr>
<td colspan=2>--experimental-bootstrap-kubeconfig string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
已弃用：应使用 <code>--bootstrap-kubeconfig</code> 标志
</td>
</tr>
<tr>
<td colspan=2>--experimental-check-node-capabilities-before-mount</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验性特性] 设置为 <code>true</code> 表示 kubelet 在进行挂载卷操作之前要
在本节点上检查所需的组件（如可执行文件等）是否存在。
已弃用：将在 1.24 或更高版本中移除，以便使用 CSI。
</td>
</tr>
<tr>
<td colspan=2>--experimental-kernel-memcg-notification</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
设置为 true 表示 kubelet 将会集成内核的 memcg 通知机制而不是使用轮询机制来
判断是否达到了内存驱逐阈值。
此标志将在 1.24 或更高版本移除。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--experimental-log-sanitization</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[试验性功能] 启用此标志之后，kubelet 会避免将标记为敏感的字段（密码、密钥、令牌等）
写入日志中。运行时的日志清理可能会带来相当的计算开销，因此不应该在
产品环境中启用。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</tr>
<tr>
<td colspan=2>--experimental-mounter-path string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：<code>mount</code></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验性特性] 卷挂载器（mounter）的可执行文件的路径。设置为空表示使用默认挂载器 <code>mount</code>。
已弃用：将在 1.24 或更高版本移除以支持 CSI。
</td>
</tr>
<tr>
<td colspan=2>--fail-swap-on&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：<code>true</code></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
设置为 true 表示如果主机启用了交换分区，kubelet 将直接失败。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--feature-gates mapStringBool</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
用于 alpha 实验性特性的特性开关组，每个开关以 key=value 形式表示。当前可用开关包括：</br>
APIListChunking=true|false (BETA - 默认值为 true)<br>
APIPriorityAndFairness=true|false (BETA - 默认值为 true)<br>
APIResponseCompression=true|false (BETA - 默认值为 true)<br>
APIServerIdentity=true|false (ALPHA - 默认值为 false)<br>
AllAlpha=true|false (ALPHA - 默认值为 false)<br>
AllBeta=true|false (BETA - 默认值为 false)<br>
AllowInsecureBackendProxy=true|false (BETA - 默认值为 true)<br>
AnyVolumeDataSource=true|false (ALPHA - 默认值为 false)<br>
AppArmor=true|false (BETA - 默认值为 true)<br>
BalanceAttachedNodeVolumes=true|false (ALPHA - 默认值为 false)<br>
BoundServiceAccountTokenVolume=true|false (ALPHA - 默认值为 false)<br>
CPUManager=true|false (BETA - 默认值为 true)<br>
CSIInlineVolume=true|false (BETA - 默认值为 true)<br>
CSIMigration=true|false (BETA - 默认值为 true)<br>
CSIMigrationAWS=true|false (BETA - 默认值为 false)<br>
CSIMigrationAWSComplete=true|false (ALPHA - 默认值为 false)<br>
CSIMigrationAzureDisk=true|false (BETA - 默认值为 false)<br>
CSIMigrationAzureDiskComplete=true|false (ALPHA - 默认值为 false)<br>
CSIMigrationAzureFile=true|false (ALPHA - 默认值为 false)<br>
CSIMigrationAzureFileComplete=true|false (ALPHA - 默认值为 false)<br>
CSIMigrationGCE=true|false (BETA - 默认值为 false)<br>
CSIMigrationGCEComplete=true|false (ALPHA - 默认值为 false)<br>
CSIMigrationOpenStack=true|false (BETA - 默认值为 false)<br>
CSIMigrationOpenStackComplete=true|false (ALPHA - 默认值为 false)<br>
CSIMigrationvSphere=true|false (BETA - 默认值为 false)<br>
CSIMigrationvSphereComplete=true|false (BETA - 默认值为 false)<br>
CSIServiceAccountToken=true|false (ALPHA - 默认值为 false)<br>
CSIStorageCapacity=true|false (ALPHA - 默认值为 false)<br>
CSIVolumeFSGroupPolicy=true|false (BETA - 默认值为 true)<br>
ConfigurableFSGroupPolicy=true|false (BETA - 默认值为 true)<br>
CronJobControllerV2=true|false (ALPHA - 默认值为 false)<br>
CustomCPUCFSQuotaPeriod=true|false (ALPHA - 默认值为 false)<br>
DefaultPodTopologySpread=true|false (BETA - 默认值为 true)<br>
DevicePlugins=true|false (BETA - 默认值为 true)<br>
DisableAcceleratorUsageMetrics=true|false (BETA - 默认值为 true)<br>
DownwardAPIHugePages=true|false (ALPHA - 默认值为 false)<br>
DynamicKubeletConfig=true|false (BETA - 默认值为 true)<br>
EfficientWatchResumption=true|false (ALPHA - 默认值为 false)<br>
EndpointSlice=true|false (BETA - 默认值为 true)<br>
EndpointSliceNodeName=true|false (ALPHA - 默认值为 false)<br>
EndpointSliceProxying=true|false (BETA - 默认值为 true)<br>
EndpointSliceTerminatingCondition=true|false (ALPHA - 默认值为 false)<br>
EphemeralContainers=true|false (ALPHA - 默认值为 false)<br>
ExpandCSIVolumes=true|false (BETA - 默认值为 true)<br>
ExpandInUsePersistentVolumes=true|false (BETA - 默认值为 true)<br>
ExpandPersistentVolumes=true|false (BETA - 默认值为 true)<br>
ExperimentalHostUserNamespaceDefaulting=true|false (BETA - 默认值为 false)<br>
GenericEphemeralVolume=true|false (ALPHA - 默认值为 false)<br>
GracefulNodeShutdown=true|false (ALPHA - 默认值为 false)<br>
HPAContainerMetrics=true|false (ALPHA - 默认值为 false)<br>
HPAScaleToZero=true|false (ALPHA - 默认值为 false)<br>
HugePageStorageMediumSize=true|false (BETA - 默认值为 true)<br>
IPv6DualStack=true|false (ALPHA - 默认值为 false)<br>
ImmutableEphemeralVolumes=true|false (BETA - 默认值为 true)<br>
KubeletCredentialProviders=true|false (ALPHA - 默认值为 false)<br>
KubeletPodResources=true|false (BETA - 默认值为 true)<br>
LegacyNodeRoleBehavior=true|false (BETA - 默认值为 true)<br>
LocalStorageCapacityIsolation=true|false (BETA - 默认值为 true)<br>
LocalStorageCapacityIsolationFSQuotaMonitoring=true|false (ALPHA - 默认值为 false)<br>
MixedProtocolLBService=true|false (ALPHA - 默认值为 false)<br>
NodeDisruptionExclusion=true|false (BETA - 默认值为 true)<br>
NonPreemptingPriority=true|false (BETA - 默认值为 true)<br>
PodDisruptionBudget=true|false (BETA - 默认值为 true)<br>
PodOverhead=true|false (BETA - 默认值为 true)<br>
ProcMountType=true|false (ALPHA - 默认值为 false)<br>
QOSReserved=true|false (ALPHA - 默认值为 false)<br>
RemainingItemCount=true|false (BETA - 默认值为 true)<br>
RemoveSelfLink=true|false (BETA - 默认值为 true)<br>
RootCAConfigMap=true|false (BETA - 默认值为 true)<br>
RotateKubeletServerCertificate=true|false (BETA - 默认值为 true)<br>
RunAsGroup=true|false (BETA - 默认值为 true)<br>
SeccompDefault=true|false (ALPHA - 默认值为 false)<br>
ServiceInternalTrafficPolicy=true|false (BETA - 默认值为 true)<br>
ServiceLBNodePortControl=true|false (BETA - 默认值为 true)<br>
ServiceLoadBalancerClass=true|false (BETA - 默认值为 true)<br>
SizeMemoryBackedVolumes=true|false (BETA - 默认值为 true)<br>
StatefulSetAutoDeletePVC=true|false (ALPHA - 默认值为 false)<br>
StatefulSetMinReadySeconds=true|false (BETA - 默认值为 true)<br>
StorageVersionAPI=true|false (ALPHA - 默认值为 false)<br>
StorageVersionHash=true|false (BETA - 默认值为 true)<br>
SuspendJob=true|false (BETA - 默认值为 true)<br>
TopologyAwareHints=true|false (BETA - 默认值为 true)<br>
TopologyManager=true|false (BETA - 默认值为 true)<br>
VolumeCapacityPriority=true|false (ALPHA - 默认值为 false)<br>
WinDSR=true|false (ALPHA - 默认值为 false)<br>
WinOverlay=true|false (BETA - 默认值为 true)<br>
WindowsHostProcessContainers=true|false (BETA - 默认值为 true)<br>
csiMigrationRBD=true|false (ALPHA - 默认值为 false)<br>
已弃用: 应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/docs/tasks/administer-cluster/kubelet-config-file>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--file-check-frequency duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：<code>20s</code></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
检查配置文件中新数据的时间间隔。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--hairpin-mode string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：<code>promiscuous-bridge</code></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
设置 kubelet 执行发夹模式（hairpin）网络地址转译的方式。
该模式允许后端端点对其自身服务的访问能够再次经由负载均衡转发回自身。
可选项包括 <code>promiscuous-bridge</code>、<code>hairpin-veth</code> 和 <code>none</code>。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--healthz-bind-address ip&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：<code>127.0.0.1</code></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
用于运行 healthz 服务器的 IP 地址（设置为 <code>0.0.0.0</code> 表示使用所有 IPv4 接口，
设置为 <code>::</code> 表示使用所有 IPv6 接口。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--healthz-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：10248</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
本地 healthz 端点使用的端口（设置为 0 表示禁用）。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubelet 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>--hostname-override string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果为非空，将使用此字符串而不是实际的主机名作为节点标识。如果设置了
<code>--cloud-provider</code>，则云驱动将确定节点的名称
（请查阅云服务商文档以确定是否以及如何使用主机名）。
</td>
</tr>
<tr>
<td colspan=2>--housekeeping-interval duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：<code>10s</code></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
清理容器操作的时间间隔。
</td>
</tr>
<tr>
<td colspan=2>--http-check-frequency duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：<code>20s</code></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
HTTP 服务以获取新数据的时间间隔。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--image-credential-provider-bin-dir string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指向凭据提供组件可执行文件所在目录的路径。
</td>
</tr>
<tr>
<td colspan=2>--image-credential-provider-config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指向凭据提供插件配置文件所在目录的路径。
</tr>
<tr>
<td colspan=2>--image-gc-high-threshold int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：85</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
镜像垃圾回收上限。磁盘使用空间达到该百分比时，镜像垃圾回收将持续工作。
值必须在 [0，100] 范围内。要禁用镜像垃圾回收，请设置为 100。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--image-gc-low-threshold int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：80</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
镜像垃圾回收下限。磁盘使用空间在达到该百分比之前，镜像垃圾回收操作不会运行。
值必须在 [0，100] 范围内，并且不得大于 <code>--image-gc-high-threshold</code>的值。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--image-pull-progress-deadline duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：<code>1m0s</code></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果在该参数值所设置的期限之前没有拉取镜像的进展，镜像拉取操作将被取消。
仅当容器运行环境设置为 <code>docker</code> 时，此特定于 docker 的参数才有效。
</td>
</tr>
<tr>
<td colspan=2>--image-service-endpoint string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验性特性] 远程镜像服务的端点。若未设定则默认情况下使用 <code>--container-runtime-endpoint</code>
的值。目前支持的类型包括在 Linux 系统上的 UNIX 套接字端点和 Windows 系统上的 npipe 和 TCP 端点。
例如：<code>unix:///var/run/dockershim.sock</code>、<code>npipe:////./pipe/dockershim</code>。
</td>
</tr>
<tr>
<td colspan=2>--iptables-drop-bit int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：15</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
标记数据包将被丢弃的 fwmark 位设置。必须在 [0，31] 范围内。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--iptables-masquerade-bit int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：14</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
标记数据包将进行 SNAT 的 fwmark 空间位设置。必须在 [0，31] 范围内。
请将此参数与 <code>kube-proxy</code> 中的相应参数匹配。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--keep-terminated-pod-volumes</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
设置为 true 表示 Pod 终止后仍然保留之前挂载过的卷，常用于调试与卷有关的问题。
已弃用：将未来版本中移除。
</td>
</tr>
<tr>
<td colspan=2>--kernel-memcg-notification</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
若启用，则 kubelet 将与内核中的 memcg 通知机制集成，不再使用轮询的方式来判定
是否 Pod 达到内存驱逐阈值。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--kube-api-burst int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：10</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
每秒发送到 apiserver 的突发请求数量上限。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--kube-api-content-type string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：<code>application/vnd.kubernetes.protobuf</code></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
发送到 apiserver 的请求的内容类型。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--kube-api-qps int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：5</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
与 apiserver 通信的每秒查询个数（QPS）。
此值必须 >= 0。如果为 0， 则使用默认 QPS（5）。
不包含事件和节点心跳 api，它们的速率限制是由一组不同的标志所控制。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--kube-reserved mapStringString&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：&lt;None></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubernetes 系统预留的资源配置，以一组 <code>资源名称=资源数量</code> 格式表示。
（例如：<code>cpu=200m,memory=500Mi,ephemeral-storage=1Gi,pid='100'</code>）。
当前支持 <code>cpu</code>、<code>memory</code> 和用于根文件系统的 <code>ephemeral-storage</code>。
请参阅<a href=http://kubernetes.io/zh/docs/concepts/configuration/manage-resources-containers/>相关文档</a>获取更多信息。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--kube-reserved-cgroup string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：<code>""</code></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
给出某个顶层 cgroup 绝对名称，该 cgroup 用于管理通过标志 <code>--kube-reserved</code>
为 kubernetes 组件所预留的计算资源。例如：<code>"/kube-reserved"</code>。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--kubeconfig string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeconfig 配置文件的路径，指定如何连接到 API 服务器。
提供 <code>--kubeconfig</code> 将启用 API 服务器模式，而省略 <code>--kubeconfig</code> 将启用独立模式。
</td>
</tr>
<tr>
<td colspan=2>--kubelet-cgroups string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
用于创建和运行 kubelet 的 cgroup 的绝对名称。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--lock-file string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
&lt;警告：alpha 特性> kubelet 使用的锁文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--log-backtrace-at traceLocation&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：<code>:0</code></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
形式为 <code>&lt;file>:&lt;N></code>。
当日志逻辑执行到命中 &lt;file> 的第 &lt;N> 行时，转储调用堆栈。
（已弃用：将在未来的版本中删除，<a href=https://github.com/kubernetes/enhancements/tree/master/keps/sig-instrumentation/2845-deprecate-klog-specific-flags-in-k8s-components>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--log-dir string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果此值为非空，则在所指定的目录中写入日志文件。
（已弃用：将在未来的版本中删除，<a href=https://github.com/kubernetes/enhancements/tree/master/keps/sig-instrumentation/2845-deprecate-klog-specific-flags-in-k8s-components>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--log-file string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果此值非空，使用所给字符串作为日志文件名。
</td>
</tr>
<tr>
<td colspan=2>--log-file-max-size uint&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：1800</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
设置日志文件的最大值。单位为兆字节（M）。如果值为 0，则表示文件大小无限制。
（已弃用：将在未来的版本中删除，<a href=https://github.com/kubernetes/enhancements/tree/master/keps/sig-instrumentation/2845-deprecate-klog-specific-flags-in-k8s-components>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--log-flush-frequency duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：<code>5s</code></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
两次日志刷新之间的最大秒数（默认值为 5s）。
</td>
</tr>
<tr>
<td colspan=2>--log-json-info-buffer-size string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：<code>'0'</code></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验性特性]在具有拆分输出流的 JSON 格式中，可以将信息消息缓冲一段时间以提高性能。
零字节的默认值禁用缓冲。大小可以指定为字节数（512）、1000 的倍数（1K）、1024 的倍数（2Ki） 或这些（3M、4G、5Mi、6Gi）的幂。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--log-json-split-stream</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验性特性]以 JSON 格式，将错误消息写入 stderr，将 info 消息写入 stdout。
默认是将单个流写入标准输出。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--logging-format string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：<code>"text"</code></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
设置日志文件格式。可以设置的格式有：<code>"text"</code>、<code>"json"</code>。
非默认的格式不会使用以下标志的配置：<code>--add-dir-header</code>, <code>--alsologtostderr</code>,
<code>--log-backtrace-at</code>, <code>--log-dir</code>, <code>--log-file</code>,
<code>--log-file-max-size</code>, <code>--logtostderr</code>, <code>--skip-headers</code>,
<code>--skip-log-headers</code>, <code>--stderrthreshold</code>, <code>--log-flush-frequency</code>。
非默认选项的其它值都应视为 Alpha 特性，将来出现更改时不会额外警告。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--logtostderr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：<code>true</code></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
日志输出到 stderr 而不是文件。
（已弃用：将会在未来的版本删除，
<a href=https://github.com/kubernetes/enhancements/tree/master/keps/sig-instrumentation/2845-deprecate-klog-specific-flags-in-k8s-components>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--make-iptables-util-chains&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：<code>true</code></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
设置为 true 表示 kubelet 将确保 <code>iptables</code> 规则在主机上存在。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--manifest-url string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
用于访问要运行的其他 Pod 规范的 URL。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--manifest-url-header string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
取值为由 HTTP 头部组成的逗号分隔列表，在访问 <code>--manifest-url</code> 所给出的 URL 时使用。
名称相同的多个头部将按所列的顺序添加。该参数可以多次使用。例如：
<code>--manifest-url-header 'a:hello,b:again,c:world' --manifest-url-header 'b:beautiful'</code>。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--master-service-namespace string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：<code>default</code></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubelet 向 Pod 注入 Kubernetes 主控服务信息时使用的命名空间。
已弃用：此标志将在未来的版本中删除。
</td>
</tr>
<tr>
<td colspan=2>--max-open-files int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：1000000</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubelet 进程可以打开的最大文件数量。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--max-pods int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：110</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
此 kubelet 能运行的 Pod 最大数量。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--maximum-dead-containers int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：-1</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
设置全局可保留的已停止容器实例个数上限。
每个实例会占用一些磁盘空间。要禁用，请设置为负数。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--maximum-dead-containers-per-container int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：1</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
每个已停止容器可以保留的的最大实例数量。每个容器占用一些磁盘空间。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--memory-manager-policy string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：<code>None</code></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
内存管理器策略使用。可选值：<code>'None'</code>, <code>'Static'</code>。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--minimum-container-ttl-duration duration</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
已结束的容器在被垃圾回收清理之前的最少存活时间。
例如：<code>300ms</code>、<code>10s</code> 或者 <code>2h45m</code>。
已弃用：请改用 <code>--eviction-hard</code> 或者 <code>--eviction-soft</code>。
此标志将在未来的版本中删除。
</td>
</tr>
<tr>
<td colspan=2>--minimum-image-ttl-duration duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：<code>2m0s</code></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
不再使用的镜像在被垃圾回收清理之前的最少存活时间。
例如：<code>300ms</code>、<code>10s</code> 或者 <code>2h45m</code>。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--network-plugin string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
&lt;警告：alpha 特性> 设置 kubelet/Pod 生命周期中各种事件调用的网络插件的名称。
仅当容器运行环境设置为 <code>docker</code> 时，此特定于 docker 的参数才有效。
</td>
</tr>
<tr>
<td colspan=2>--network-plugin-mtu int32</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
&lt;警告：alpha 特性> 传递给网络插件的 MTU 值，将覆盖默认值。
设置为 0 则使用默认的 MTU 1460。仅当容器运行环境设置为 <code>docker</code> 时，
此特定于 docker 的参数才有效。
（已弃用：将会随着 dockershim 一起删除。）
</td>
</tr>
<tr>
<td colspan=2>--node-ip string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
节点的 IP 地址（或逗号分隔的双栈 IP 地址）。
如果未设置，kubelet 将使用节点的默认 IPv4 地址（如果有）或默认 IPv6 地址（如果它没有 IPv4 地址）。
你可以传值 <code>'::'</code> 使其偏向于默认的 IPv6 地址而不是默认的 IPv4 地址。
</td>
</tr>
<tr>
<td colspan=2>--node-labels mapStringString</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
&lt;警告：alpha 特性> kubelet 在集群中注册本节点时设置的标签。标签以
<code>key=value</code> 的格式表示，多个标签以逗号分隔。名字空间 <code>kubernetes.io</code>
中的标签必须以 <code>kubelet.kubernetes.io</code> 或 <code>node.kubernetes.io</code> 为前缀，
或者在以下明确允许范围内：
<code>beta.kubernetes.io/arch</code>, <code>beta.kubernetes.io/instance-type</code>,
<code>beta.kubernetes.io/os</code>, <code>failure-domain.beta.kubernetes.io/region</code>,
<code>failure-domain.beta.kubernetes.io/zone</code>, <code>kubernetes.io/arch</code>,
<code>kubernetes.io/hostname</code>, <code>kubernetes.io/os</code>,
<code>node.kubernetes.io/instance-type</code>, <code>topology.kubernetes.io/region</code>,
<code>topology.kubernetes.io/zone</code>。
</td>
</tr>
<tr>
<td colspan=2>--node-status-max-images int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：50</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
在 <code>node.status.images</code> 中可以报告的最大镜像数量。如果指定为 -1，则不设上限。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--node-status-update-frequency duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：<code>10s</code></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指定 kubelet 向主控节点汇报节点状态的时间间隔。注意：更改此常量时请务必谨慎，
它必须与节点控制器中的 <code>nodeMonitorGracePeriod</code> 一起使用。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--non-masquerade-cidr string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：<code>10.0.0.0/8</code></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubelet 向该 IP 段之外的 IP 地址发送的流量将使用 IP 伪装技术。
设置为 <code>0.0.0.0/0</code> 则不使用伪装。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--one-output</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果设置此标志为 <code>true</code>，则仅将日志写入其原来的严重性级别中，
而不是同时将其写入更低严重性级别中。
已弃用：将在未来的版本中删除，
（<a href=https://github.com/kubernetes/enhancements/tree/master/keps/sig-instrumentation/2845-deprecate-klog-specific-flags-in-k8s-components>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--oom-score-adj int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：-999</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubelet 进程的 oom-score-adj 参数值。有效范围为 <code>[-1000，1000]</code>。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--pod-cidr string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
用于给 Pod 分配 IP 地址的 CIDR 地址池，仅在独立运行模式下使用。
在集群模式下，CIDR 设置是从主服务器获取的。对于 IPv6，分配的 IP 的最大数量为 65536。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--pod-infra-container-image string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：<code>k8s.gcr.io/pause:3.2</code></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
所指定的镜像不会被镜像垃圾收集器删除。
当容器运行环境设置为 <code>docker</code> 时，各个 Pod 中的所有容器都会
使用此镜像中的网络和 IPC 名字空间。
其他 CRI 实现有自己的配置来设置此镜像。
</td>
</tr>
<tr>
<td colspan=2>--pod-manifest-path string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
设置包含要运行的静态 Pod 的文件的路径，或单个静态 Pod 文件的路径。以点（<code>.</code>）
开头的文件将被忽略。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--pod-max-pids int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：-1</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
设置每个 Pod 中的最大进程数目。如果为 -1，则 kubelet 使用节点可分配的 PID 容量作为默认值。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--pods-per-core int32</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubelet 在每个处理器核上可运行的 Pod 数量。此 kubelet 上的 Pod 总数不能超过
<code>--max-pods</code> 标志值。因此，如果此计算结果导致在 kubelet
上允许更多数量的 Pod，则使用 <code>--max-pods</code> 值。值为 0 表示不作限制。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：10250</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubelet 服务监听的本机端口号。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--protect-kernel-defaults</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
设置 kubelet 的默认内核调整行为。如果已设置该参数，当任何内核可调参数与
kubelet 默认值不同时，kubelet 都会出错。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--provider-id string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
设置主机数据库（即，云驱动）中用来标识节点的唯一标识。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--qos-reserved mapStringString</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
&lt;警告：alpha 特性> 设置在指定的 QoS 级别预留的 Pod 资源请求，以一组
<code>"资源名称=百分比"</code> 的形式进行设置，例如 <code>memory=50%</code>。
当前仅支持内存（memory）。要求启用 <code>QOSReserved</code> 特性门控。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--read-only-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：10255</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubelet 可以在没有身份验证/鉴权的情况下提供只读服务的端口（设置为 0 表示禁用）。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--really-crash-for-testing</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
设置为 true 表示发生失效时立即崩溃。仅用于测试。
已弃用：将在未来版本中移除。
</td>
</tr>
<tr>
<td colspan=2>--register-node&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：<code>true</code></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
向 API 服务器注册节点，如果未提供 <code>--kubeconfig</code>，此标志无关紧要，
因为 Kubelet 没有 API 服务器可注册。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--register-schedulable&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：true</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
注册本节点为可调度的节点。当 <code>--register-node</code>标志为 false 时此设置无效。
已弃用：此参数将在未来的版本中删除。
</td>
</tr>
<tr>
<td colspan=2>--register-with-taints mapStringString</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
设置本节点的污点标记，格式为 <code>&lt;key>=&lt;value>:&lt;effect></code>，
以逗号分隔。当 <code>--register-node</code> 为 false 时此标志无效。
已弃用：将在未来版本中移除。
</td>
</tr>
<tr>
<td colspan=2>--registry-burst int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：10</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
设置突发性镜像拉取的个数上限，在不超过 <code>--registration-qps</code> 设置值的前提下
暂时允许此参数所给的镜像拉取个数。仅在 <code>--registry-qps</code> 大于 0 时使用。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--registry-qps int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：5</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如此值大于 0，可用来限制镜像仓库的 QPS 上限。设置为 0，表示不受限制。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--reserved-cpus string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
用逗号分隔的一组 CPU 或 CPU 范围列表，给出为系统和 Kubernetes 保留使用的 CPU。
此列表所给出的设置优先于通过 <code>--system-reserved</code> 和
<code>--kube-reskube-reserved</code> 所保留的 CPU 个数配置。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--reserved-memory string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
以逗号分隔的 NUMA 节点内存预留列表。（例如 <code>--reserved-memory 0:memory=1Gi,hugepages-1M=2Gi --reserved-memory 1:memory=2Gi</code>）。
每种内存类型的总和应该等于<code>--kube-reserved</code>、<code>--system-reserved</code>和<code>--eviction-threshold。
<a href=https://kubernetes.io/docs/tasks/administer-cluster/memory-manager/#reserved-memory-flag>了解更多详细信息。</a>
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--resolv-conf string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：<code>/etc/resolv.conf</code></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
名字解析服务的配置文件名，用作容器 DNS 解析配置的基础。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--root-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：<code>/var/lib/kubelet</code></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
设置用于管理 kubelet 文件的根目录（例如挂载卷的相关文件等）。
</td>
</tr>
<tr>
<td colspan=2>--rotate-certificates</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
&lt;警告：Beta 特性> 设置当客户端证书即将过期时 kubelet 自动从
<code>kube-apiserver</code> 请求新的证书进行轮换。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--rotate-server-certificates</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
当 kubelet 的服务证书即将过期时自动从 kube-apiserver 请求新的证书进行轮换。
要求启用 <code>RotateKubeletServerCertificate</code> 特性门控，以及对提交的
<code>CertificateSigningRequest</code> 对象进行批复（Approve）操作。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--runonce</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
设置为 true 表示从本地清单或远程 URL 创建完 Pod 后立即退出 kubelet 进程。
与 <code>--enable-server</code> 标志互斥。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--runtime-cgroups string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
设置用于创建和运行容器运行时的 cgroup 的绝对名称。
</td>
</tr>
<tr>
<td colspan=2>--runtime-request-timeout duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：<code>2m0s</code></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
设置除了长时间运行的请求（包括 <code>pull</code>、<code>logs</code>、<code>exec</code>
和 <code>attach</code> 等操作）之外的其他运行时请求的超时时间。
到达超时时间时，请求会被取消，抛出一个错误并会等待重试。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--seccomp-profile-root string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：<code>/var/lib/kubelet/seccomp</code></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
&lt;警告：alpha 特性> seccomp 配置文件目录。
已弃用：将在 1.23 或更高版本中移除，以使用 <code>&lt;root-dir>/seccomp</code> 目录。
</td>
</tr>
<tr>
<td colspan=2>--serialize-image-pulls&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：<code>true</code></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
逐一拉取镜像。建议 *不要* 在 docker 守护进程版本低于 1.9 或启用了 Aufs 存储后端的节点上
更改默认值。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--skip-headers</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
设置为 true 时在日志消息中去掉标头前缀。
（已弃用：将在未来的版本中删除，<a href=https://github.com/kubernetes/enhancements/tree/master/keps/sig-instrumentation/2845-deprecate-klog-specific-flags-in-k8s-components>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--skip-log-headers</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
设置为 true，打开日志文件时去掉标头。
（已弃用：将在未来的版本中删除，<a href=https://github.com/kubernetes/enhancements/tree/master/keps/sig-instrumentation/2845-deprecate-klog-specific-flags-in-k8s-components>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--stderrthreshold int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：2</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
设置严重程度达到或超过此阈值的日志输出到标准错误输出。
（已弃用：将在未来的版本中删除，<a href=https://github.com/kubernetes/enhancements/tree/master/keps/sig-instrumentation/2845-deprecate-klog-specific-flags-in-k8s-components>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--streaming-connection-idle-timeout duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：<code>4h0m0s</code></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
设置流连接在自动关闭之前可以空闲的最长时间。0 表示没有超时限制。
例如：<code>5m</code>。
注意：与 kubelet 服务器的所有连接最长持续时间为 4 小时。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--sync-frequency duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：<code>1m0s</code></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
在运行中的容器与其配置之间执行同步操作的最长时间间隔。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--system-cgroups /</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
此标志值为一个 cgroup 的绝对名称，用于所有尚未放置在根目录下某 cgroup 内的非内核进程。
空值表示不指定 cgroup。回滚该参数需要重启机器。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--system-reserved mapStringString&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：无</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
系统预留的资源配置，以一组 <code>资源名称=资源数量</code> 的格式表示，
（例如：<code>cpu=200m,memory=500Mi,ephemeral-storage=1Gi,pid='100'</code>）。
目前仅支持 <code>cpu</code> 和 <code>memory</code> 的设置。
更多细节可参考
<a href=http://kubernetes.io/zh/docs/concepts/configuration/manage-resources-containers/>相关文档</a>。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--system-reserved-cgroup string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：<code>""</code></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
此标志给出一个顶层 cgroup 绝对名称，该 cgroup 用于管理非 kubernetes 组件，
这些组件的计算资源通过 <code>--system-reserved</code> 标志进行预留。
例如 <code>"/system-reserved"</code>。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--tls-cert-file string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
包含 x509 证书的文件路径，用于 HTTPS 认证。
如果有中间证书，则中间证书要串接在在服务器证书之后。
如果未提供 <code>--tls-cert-file</code> 和 <code>--tls-private-key-file</code>，
kubelet 会为公开地址生成自签名证书和密钥，并将其保存到通过
<code>--cert-dir</code> 指定的目录中。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--tls-cipher-suites string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
服务器端加密算法列表，以逗号分隔。如果不设置，则使用 Go 语言加密包的默认算法列表。<br>
首选算法：
TLS_AES_128_GCM_SHA256, TLS_AES_256_GCM_SHA384, TLS_CHACHA20_POLY1305_SHA256, TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA, TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256, TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA, TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384, TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305, TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256, TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA, TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256, TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA, TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384, TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305, TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256, TLS_RSA_WITH_AES_128_CBC_SHA, TLS_RSA_WITH_AES_128_GCM_SHA256, TLS_RSA_WITH_AES_256_CBC_SHA, TLS_RSA_WITH_AES_256_GCM_SHA384 <br>
不安全算法：
TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256, TLS_ECDHE_ECDSA_WITH_RC4_128_SHA, TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256, TLS_ECDHE_RSA_WITH_RC4_128_SHA, TLS_RSA_WITH_AES_128_CBC_SHA256, TLS_RSA_WITH_RC4_128_SHA。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--tls-min-version string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
设置支持的最小 TLS 版本号，可选的版本号包括：<code>VersionTLS10</code>、
<code>VersionTLS11</code>、<code>VersionTLS12</code> 和 <code>VersionTLS13</code>。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--tls-private-key-file string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
包含与 <code>--tls-cert-file</code> 对应的 x509 私钥文件路径。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--topology-manager-policy string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：<code>none</code></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
设置拓扑管理策略（Topology Manager policy）。可选值包括：<code>none</code>、
<code>best-effort</code>、<code>restricted</code> 和 <code>single-numa-node</code>。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--topology-manager-scope string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：<code>container</code></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
拓扑提示信息使用范围。拓扑管理器从提示提供者（Hints Providers）处收集提示信息，
并将其应用到所定义的范围以确保 Pod 准入。
可选值包括：<code>container</code>（默认）、<code>pod</code>。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>-v, --v Level</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
设置 kubelet 日志级别详细程度的数值。
</td>
</tr>
<tr>
<td colspan=2>--version version[=true]</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
打印 kubelet 版本信息并退出。
</td>
</tr>
<tr>
<td colspan=2>--vmodule moduleSpec</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
以逗号分隔的 <code>pattern=N</code> 设置列表，用于文件过滤的日志记录
</td>
</tr>
<tr>
<td colspan=2>--volume-plugin-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：<code>/usr/libexec/kubernetes/kubelet-plugins/volume/exec/</code></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
用来搜索第三方存储卷插件的目录。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--volume-stats-agg-period duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：<code>1m0s</code></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指定 kubelet 计算和缓存所有 Pod 和卷的磁盘用量总值的时间间隔。要禁用磁盘用量计算，
请设置为 0。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-ec8ff2888d36f533a57bc9704ccc84e0>11.3 - kube-apiserver</h1>
<h2 id=synopsis>Synopsis</h2>
<p>Kubernetes API 服务器验证并配置 API 对象的数据，
这些对象包括 pods、services、replicationcontrollers 等。
API 服务器为 REST 操作提供服务，并为集群的共享状态提供前端，
所有其他组件都通过该前端进行交互。</p>
<pre><code>kube-apiserver [flags]
</code></pre><h2 id=options>Options</h2>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--add-dir-header</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
<p>如果为 true，则将文件目录添加到日志消息的标题中</p>
</td>
</tr>
<tr>
<td colspan=2>--admission-control-config-file string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
<p>包含准入控制配置的文件。</p>
</td>
</tr>
<tr>
<td colspan=2>--advertise-address string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
<p>
向集群成员通知 apiserver 消息的 IP 地址。
这个地址必须能够被集群中其他成员访问。
如果 IP 地址为空，将会使用 --bind-address，
如果未指定 --bind-address，将会使用主机的默认接口地址。
</p>
</td>
</tr>
<tr>
<td colspan=2>--allow-metric-labels stringToString&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：[]</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>
允许使用的指标标签到指标值的映射列表。键的格式为 &lt;MetricName>,&lt;LabelName>.
值的格式为 &lt;allowed_value>,&lt;allowed_value>...。
例如：<code>metric1,label1='v1,v2,v3', metric1,label2='v1,v2,v3' metric2,label1='v1,v2,v3'</code>。
</p></td>
</tr>
<tr>
<td colspan=2>--allow-privileged</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果为 true, 将允许特权容器。[默认值=false]
</td>
</tr>
<tr>
<td colspan=2>--alsologtostderr</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
在向文件输出日志的同时，也将日志写到标准输出。
</td>
</tr>
<tr>
<td colspan=2>--anonymous-auth&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：true</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
启用到 API 服务器的安全端口的匿名请求。
未被其他认证方法拒绝的请求被当做匿名请求。
匿名请求的用户名为 <code>system:anonymous</code>，
用户组名为 </code>system:unauthenticated</code>。
</td>
</tr>
<tr>
<td colspan=2>--api-audiences strings</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
API 的标识符。
服务帐户令牌验证者将验证针对 API 使用的令牌是否已绑定到这些受众中的至少一个。
如果配置了 <code>--service-account-issuer</code> 标志，但未配置此标志，
则此字段默认为包含发布者 URL 的单个元素列表。
</td>
</tr>
<tr>
<td colspan=2>--apiserver-count int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：1</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
集群中运行的 API 服务器数量，必须为正数。
（在启用 --endpoint-reconciler-type=master-count 时使用。）
</td>
</tr>
<tr>
<td colspan=2>--audit-log-batch-buffer-size int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：10000</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
批处理和写入之前用于存储事件的缓冲区大小。
仅在批处理模式下使用。
</td>
</tr>
<tr>
<td colspan=2>--audit-log-batch-max-size int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：1</td>
</tr><tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
每个批次的最大大小。仅在批处理模式下使用。
</td>
</tr>
<tr>
<td colspan=2>--audit-log-batch-max-wait duration</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
强制写入尚未达到最大大小的批次之前要等待的时间。
仅在批处理模式下使用。
</td>
</tr>
<tr>
<td colspan=2>--audit-log-batch-throttle-burst int</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果之前未使用 ThrottleQPS，则为同时发送的最大请求数。
仅在批处理模式下使用。
</td>
</tr>
<tr>
<td colspan=2>--audit-log-batch-throttle-enable</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
是否启用了批量限制。仅在批处理模式下使用。
</td>
</tr>
<tr>
<td colspan=2>--audit-log-batch-throttle-qps float</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
每秒的最大平均批次数。仅在批处理模式下使用。
</td>
</tr>
<tr>
<td colspan=2>--audit-log-compress</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
若设置了此标志，则被轮换的日志文件会使用 gzip 压缩。
</td>
</tr>
<tr>
<td colspan=2>--audit-log-format string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："json" </td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
所保存的审计格式。
"legacy" 表示每行一个事件的文本格式。"json" 表示结构化的 JSON 格式。
已知格式为 legacy，json。
</td>
</tr>
<tr>
<td colspan=2>--audit-log-maxage int</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
根据文件名中编码的时间戳保留旧审计日志文件的最大天数。
</td>
</tr>
<tr>
<td colspan=2>--audit-log-maxbackup int</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
要保留的旧的审计日志文件个数上限。
</td>
</tr>
<tr>
<td colspan=2>--audit-log-maxsize int</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
轮换之前，审计日志文件的最大大小（以兆字节为单位）。
</td>
</tr>
<tr>
<td colspan=2>--audit-log-mode string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："blocking"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
用来发送审计事件的策略。
阻塞（blocking）表示发送事件应阻止服务器响应。
批处理（batch）会导致后端异步缓冲和写入事件。
已知的模式是批处理（batch），阻塞（blocking），严格阻塞（blocking-strict）。
</td>
</tr>
<tr>
<td colspan=2>--audit-log-path string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果设置，则所有到达 API 服务器的请求都将记录到该文件中。
"-" 表示标准输出。
</td>
</tr>
<tr>
<td colspan=2>--audit-log-truncate-enabled</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
是否启用事件和批次截断。
</td>
</tr>
<tr>
<td colspan=2>--audit-log-truncate-max-batch-size int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：10485760</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
发送到下层后端的每批次的最大数据量。
实际的序列化大小可能会增加数百个字节。
如果一个批次超出此限制，则将其分成几个较小的批次。
</td>
</tr>
<tr>
<td colspan=2>--audit-log-truncate-max-event-size int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：102400</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
发送到下层后端的每批次的最大数据量。
如果事件的大小大于此数字，则将删除第一个请求和响应；
如果这样做没有减小足够大的程度，则将丢弃事件。
</td>
</tr>
<tr>
<td colspan=2>--audit-log-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："audit.k8s.io/v1"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
用于对写入日志的审计事件执行序列化的 API 组和版本。
</td>
</tr>
<tr>
<td colspan=2>--audit-policy-file string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
定义审计策略配置的文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--audit-webhook-batch-buffer-size int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：10000</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
划分批次和写入之前用于存储事件的缓冲区大小。
仅在批处理模式下使用。
</td>
</tr>
<tr>
<td colspan=2>--audit-webhook-batch-max-size int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：400</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
批次的最大大小。
仅在批处理模式下使用。
</td>
</tr>
<tr>
<td colspan=2>--audit-webhook-batch-max-wait duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：30s</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
强制写入尚未达到最大大小的批处理之前要等待的时间。
仅在批处理模式下使用。
</td>
</tr>
<tr>
<td colspan=2>--audit-webhook-batch-throttle-burst int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：15</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果之前未使用 ThrottleQPS，同时发送的最大请求数。
仅在批处理模式下使用。
</td>
</tr>
<tr>
<td colspan=2>--audit-webhook-batch-throttle-enable&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：true</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
是否启用了批量限制。仅在批处理模式下使用。
</td>
</tr>
<tr>
<td colspan=2>--audit-webhook-batch-throttle-qps float32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：10</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
每秒的最大平均批次数。仅在批处理模式下使用。
</td>
</tr>
<tr>
<td colspan=2>--audit-webhook-config-file string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
定义审计 webhook 配置的 kubeconfig 格式文件的路径。
</tr>
<tr>
<td colspan=2>--audit-webhook-initial-backoff duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：10s</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
重试第一个失败的请求之前要等待的时间。
</td>
</tr>
<tr>
<td colspan=2>--audit-webhook-mode string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："batch"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
发送审计事件的策略。
阻止（Blocking）表示发送事件应阻止服务器响应。
批处理（Batch）导致后端异步缓冲和写入事件。
已知的模式是批处理（batch），阻塞（blocking），严格阻塞（blocking-strict）。
</td>
</tr>
<tr>
<td colspan=2>--audit-webhook-truncate-enabled</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
是否启用事件和批处理截断。
</td>
</tr>
<tr>
<td colspan=2>--audit-webhook-truncate-max-batch-size int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：10485760</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
发送到下层后端的批次的最大数据量。
实际的序列化大小可能会增加数百个字节。
如果一个批次超出此限制，则将其分成几个较小的批次。
</td>
</tr>
<tr>
<td colspan=2>--audit-webhook-truncate-max-event-size int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：102400</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
发送到下层后端的批次的最大数据量。
如果事件的大小大于此数字，则将删除第一个请求和响应；
如果事件和事件的大小没有减小到一定幅度，则将丢弃事件。
</td>
</tr>
<tr>
<td colspan=2>--audit-webhook-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："audit.k8s.io/v1"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
用于序列化写入 Webhook 的审计事件的 API 组和版本。
</td>
</tr>
<tr>
<td colspan=2>--authentication-token-webhook-cache-ttl duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2m0s</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对来自 Webhook 令牌身份验证器的响应的缓存时间。
</td>
</tr>
<tr>
<td colspan=2>--authentication-token-webhook-config-file string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
包含 Webhook 配置的 kubeconfig 格式文件，用于进行令牌认证。
API 服务器将查询远程服务，以对持有者令牌进行身份验证。
</td>
</tr>
<tr>
<td colspan=2>--authentication-token-webhook-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："v1beta1"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
与 Webhook 之间交换 authentication.k8s.io TokenReview 时使用的 API 版本。
</td>
</tr>
<tr>
<td colspan=2>--authorization-mode stringSlice&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："AlwaysAllow"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
在安全端口上进行鉴权的插件的顺序列表。
逗号分隔的列表：AlwaysAllow、AlwaysDeny、ABAC、Webhook、RBAC、Node。
</td>
</tr>
<tr>
<td colspan=2>--authorization-policy-file string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
包含鉴权策略的文件，其内容为分行 JSON 格式，
在安全端口上与 --authorization-mode=ABAC 一起使用。
</td>
</tr>
<tr>
<td colspan=2>--authorization-webhook-cache-authorized-ttl duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：5m0s</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对来自 Webhook 鉴权组件的 “授权（authorized）” 响应的缓存时间。
</td>
</tr>
<tr>
<td colspan=2>--authorization-webhook-cache-unauthorized-ttl duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：30s</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对来自 Webhook 鉴权模块的 “未授权（unauthorized）” 响应的缓存时间。
</td>
</tr>
<tr>
<td colspan=2>--authorization-webhook-config-file string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
包含 Webhook 配置的文件，其格式为 kubeconfig，
与 --authorization-mode=Webhook 一起使用。
API 服务器将查询远程服务，以对 API 服务器的安全端口的访问执行鉴权。
</td>
</tr>
<tr>
<td colspan=2>--authorization-webhook-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："v1beta1"</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
与 Webhook 之间交换 authorization.k8s.io SubjectAccessReview 时使用的 API 版本。
</td>
</tr>
<tr>
<td colspan=2>--azure-container-registry-config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
包含 Azure 容器仓库配置信息的文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--bind-address string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："0.0.0.0"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
用来监听 <code>--secure-port</code> 端口的 IP 地址。
集群的其余部分以及 CLI/web 客户端必须可以访问所关联的接口。
如果为空白或未指定地址（<tt>0.0.0.0</tt> 或 <tt>::</tt>），则将使用所有接口。
</td>
</tr>
<tr>
<td colspan=2>--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/var/run/kubernetes"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
TLS 证书所在的目录。
如果提供了 <code>--tls-cert-file</code> 和 <code>--tls-private-key-file</code>
标志值，则将忽略此标志。
</td>
</tr>
<tr>
<td colspan=2>--client-ca-file string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果已设置，则使用与客户端证书的 CommonName 对应的标识对任何出示由
client-ca 文件中的授权机构之一签名的客户端证书的请求进行身份验证。
</td>
</tr>
<tr>
<td colspan=2>--cloud-config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
云厂商配置文件的路径。空字符串表示无配置文件。
</td>
</tr>
<tr>
<td colspan=2>--cloud-provider string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
云服务提供商。空字符串表示没有云厂商。
</td>
</tr>
<tr>
<td colspan=2>--cloud-provider-gce-l7lb-src-cidrs cidrs&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："130.211.0.0/22,35.191.0.0/16"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
在 GCE 防火墙中打开 CIDR，以进行第 7 层负载均衡流量代理和健康状况检查。
</td>
</tr>
<tr>
<td colspan=2>--contention-profiling</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果启用了性能分析，则启用锁争用性能分析。
</td>
</tr>
<tr>
<td colspan=2>--cors-allowed-origins strings</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
CORS 允许的来源清单，以逗号分隔。
允许的来源可以是支持子域匹配的正则表达式。
如果此列表为空，则不会启用 CORS。
</td>
</tr>
<tr>
<td colspan=2>--default-not-ready-toleration-seconds int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：300</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对污点 NotReady:NoExecute 的容忍时长（以秒计）。
默认情况下这一容忍度会被添加到尚未具有此容忍度的每个 pod 中。
</td>
</tr>
<tr>
<td colspan=2>--default-unreachable-toleration-seconds int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：300</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对污点 Unreachable:NoExecute 的容忍时长（以秒计）
默认情况下这一容忍度会被添加到尚未具有此容忍度的每个 pod 中。
</td>
</tr>
<tr>
<td colspan=2>--default-watch-cache-size int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：100</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
默认监听（watch）缓存大小。
如果为零，则将为没有设置默认监视大小的资源禁用监视缓存。
</td>
</tr>
<tr>
<td colspan=2>--delete-collection-workers int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值： 1</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为 DeleteCollection 调用而产生的工作线程数。
这些用于加速名字空间清理。
</td>
</tr>
<tr>
<td colspan=2>--disable-admission-plugins strings</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
尽管位于默认启用的插件列表中（NamespaceLifecycle、LimitRanger、ServiceAccount、TaintNodesByCondition、PodSecurity、Priority、DefaultTolerationSeconds、DefaultStorageClass、StorageObjectInUseProtection、PersistentVolumeClaimResize、RuntimeClass、CertificateApproval、CertificateSigning、CertificateSubjectRestriction、DefaultIngressClass、MutatingAdmissionWebhook、ValidatingAdmissionWebhook、ResourceQuota）仍须被禁用的插件。
<br>取值为逗号分隔的准入插件列表：AlwaysAdmit、AlwaysDeny、AlwaysPullImages、CertificateApproval、CertificateSigning、CertificateSubjectRestriction、DefaultIngressClass、DefaultStorageClass、DefaultTolerationSeconds、DenyServiceExternalIPs、EventRateLimit、ExtendedResourceToleration、ImagePolicyWebhook、LimitPodHardAntiAffinityTopology、LimitRanger、MutatingAdmissionWebhook、NamespaceAutoProvision、NamespaceExists、NamespaceLifecycle、NodeRestriction、OwnerReferencesPermissionEnforcement、PersistentVolumeClaimResize、PersistentVolumeLabel、PodNodeSelector、PodSecurity、PodSecurityPolicy、PodTolerationRestriction、Priority、ResourceQuota、RuntimeClass、SecurityContextDeny、ServiceAccount、StorageObjectInUseProtection、TaintNodesByCondition、ValidatingAdmissionWebhook。
<br>该标志中插件的顺序无关紧要。
</td>
</tr>
<tr>
<td colspan=2>--disabled-metrics strings</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
此标志为行为不正确的度量指标提供一种处理方案。
你必须提供完全限定的指标名称才能将其禁止。
声明：禁用度量值的行为优先于显示已隐藏的度量值。
</td>
</tr>
<tr>
<td colspan=2>--egress-selector-config-file string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
带有 API 服务器出站选择器配置的文件。
</td>
</tr>
<tr>
<td colspan=2>--enable-admission-plugins stringSlice</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
除了默认启用的插件（NamespaceLifecycle、LimitRanger、ServiceAccount、TaintNodesByCondition、PodSecurity、Priority、DefaultTolerationSeconds、DefaultStorageClass、StorageObjectInUseProtection、PersistentVolumeClaimResize、RuntimeClass、CertificateApproval、CertificateSigning、CertificateSubjectRestriction、DefaultIngressClass、MutatingAdmissionWebhook、ValidatingAdmissionWebhook、ResourceQuota）之外要启用的插件
</br>取值为逗号分隔的准入插件列表：AlwaysAdmit、AlwaysDeny、AlwaysPullImages、CertificateApproval、CertificateSigning、CertificateSubjectRestriction、DefaultIngressClass、DefaultStorageClass、DefaultTolerationSeconds、DenyServiceExternalIPs、EventRateLimit、ExtendedResourceToleration、ImagePolicyWebhook、LimitPodHardAntiAffinityTopology、LimitRanger、MutatingAdmissionWebhook、NamespaceAutoProvision、NamespaceExists、NamespaceLifecycle、NodeRestriction、OwnerReferencesPermissionEnforcement、PersistentVolumeClaimResize、PersistentVolumeLabel、PodNodeSelector、PodSecurity、PodSecurityPolicy、PodTolerationRestriction、Priority、ResourceQuota、RuntimeClass、SecurityContextDeny、ServiceAccount、StorageObjectInUseProtection、TaintNodesByCondition、ValidatingAdmissionWebhook
<br>该标志中插件的顺序无关紧要。
</td>
</tr>
<tr>
<td colspan=2>--enable-aggregator-routing</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
允许聚合器将请求路由到端点 IP 而非集群 IP。
</td>
</tr>
<tr>
<td colspan=2>--enable-bootstrap-token-auth</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
启用以允许将 "kube-system" 名字空间中类型为 "bootstrap.kubernetes.io/token"
的 Secret 用于 TLS 引导身份验证。
</td>
</tr>
<tr>
<td colspan=2>--enable-garbage-collector&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：true</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
启用通用垃圾收集器。必须与 kube-controller-manager 的相应标志同步。
</td>
</tr>
<tr>
<td colspan=2>--enable-priority-and-fairness&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：true</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果为 true 且启用了 <code>APIPriorityAndFairness</code> 特性门控，
请使用增强的处理程序替换 max-in-flight 处理程序，
以便根据优先级和公平性完成排队和调度。
</td>
</tr>
<tr>
<td colspan=2>--encryption-provider-config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
包含加密提供程序配置信息的文件，用在 etcd 中所存储的 Secret 上。
</td>
</tr>
<tr>
<td colspan=2>--endpoint-reconciler-type string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："lease"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
使用端点协调器（<code>master-count</code>、<code>lease</code> 或 <code>none</code>）。
</td>
</tr>
<tr>
<td colspan=2>--etcd-cafile string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
用于保护 etcd 通信的 SSL 证书颁发机构文件。
</td>
</tr>
<tr>
<td colspan=2>--etcd-certfile string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
用于保护 etcd 通信的 SSL 证书文件。
</td>
</tr>
<tr>
<td colspan=2>--etcd-compaction-interval duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：5m0s</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
压缩请求的间隔。
如果为0，则禁用来自 API 服务器的压缩请求。
</td>
</tr>
<tr>
<td colspan=2>--etcd-count-metric-poll-period duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：1m0s</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
针对每种类型的资源数量轮询 etcd 的频率。
0 值表示禁用度量值收集。
</td>
</tr>
<tr>
<td colspan=2>--etcd-db-metric-poll-interval duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：30s</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
轮询 etcd 和更新度量值的请求间隔。0 值表示禁用度量值收集。
</td>
</tr>
<tr>
<td colspan=2>--etcd-healthcheck-timeout duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
检查 etcd 健康状况时使用的超时时长。
</td>
</tr>
<tr>
<td colspan=2>--etcd-keyfile string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
用于保护 etcd 通信的 SSL 密钥文件。
</td>
</tr>
<tr>
<td colspan=2>--etcd-prefix string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/registry"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
要在 etcd 中所有资源路径之前添加的前缀。
</td>
</tr>
<tr>
<td colspan=2>--etcd-servers strings</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
要连接的 etcd 服务器列表（<code>scheme://ip:port</code>），以逗号分隔。
</td>
</tr>
<tr>
<td colspan=2>--etcd-servers-overrides strings</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
etcd 服务器针对每个资源的重载设置，以逗号分隔。
单个替代格式：组/资源#服务器（group/resource#servers），
其中服务器是 URL，以分号分隔。
</td>
</tr>
<tr>
<td colspan=2>--event-ttl duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：1h0m0s</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
事件的保留时长。
</td>
</tr>
<tr>
<td colspan=2>--experimental-logging-sanitization</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[试验性功能] 启用此标志时，被标记为敏感的字段（密码、密钥、令牌）都不会被日志输出。<br>
运行时的日志清理可能会引入相当程度的计算开销，因此不应该在产品环境中启用。
</td>
</tr>
<tr>
<td colspan=2>--external-hostname string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为此主机生成外部化 UR L时要使用的主机名（例如 Swagger API 文档或 OpenID 发现）。
</td>
</tr>
<tr>
<td colspan=2>--feature-gates &lt;逗号分隔的 'key=True|False' 键值对></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
<p>一组 key=value 对，用来描述测试性/试验性功能的特性门控。可选项有：
APIListChunking=true|false (BETA - 默认值=true)<br>
APIPriorityAndFairness=true|false (BETA - 默认值=true)<br>
APIResponseCompression=true|false (BETA - 默认值=true)<br>
APIServerIdentity=true|false (ALPHA - 默认值=false)<br>
APIServerTracing=true|false (ALPHA - 默认值=false)<br>
AllAlpha=true|false (ALPHA - 默认值=false)<br>
AllBeta=true|false (BETA - 默认值=false)<br>
AnyVolumeDataSource=true|false (ALPHA - 默认值=false)<br>
AppArmor=true|false (BETA - 默认值=true)<br>
CPUManager=true|false (BETA - 默认值=true)<br>
CPUManagerPolicyOptions=true|false (ALPHA - 默认值=false)<br>
CSIInlineVolume=true|false (BETA - 默认值=true)<br>
CSIMigration=true|false (BETA - 默认值=true)<br>
CSIMigrationAWS=true|false (BETA - 默认值=false)<br>
CSIMigrationAzureDisk=true|false (BETA - 默认值=false)<br>
CSIMigrationAzureFile=true|false (BETA - 默认值=false)<br>
CSIMigrationGCE=true|false (BETA - 默认值=false)<br>
CSIMigrationOpenStack=true|false (BETA - 默认值=true)<br>
CSIMigrationvSphere=true|false (BETA - 默认值=false)<br>
CSIStorageCapacity=true|false (BETA - 默认值=true)<br>
CSIVolumeFSGroupPolicy=true|false (BETA - 默认值=true)<br>
CSIVolumeHealth=true|false (ALPHA - 默认值=false)<br>
CSRDuration=true|false (BETA - 默认值=true)<br>
ConfigurableFSGroupPolicy=true|false (BETA - 默认值=true)<br>
ControllerManagerLeaderMigration=true|false (BETA - 默认值=true)<br>
CustomCPUCFSQuotaPeriod=true|false (ALPHA - 默认值=false)<br>
DaemonSetUpdateSurge=true|false (BETA - 默认值=true)<br>
默认值PodTopologySpread=true|false (BETA - 默认值=true)<br>
DelegateFSGroupToCSIDriver=true|false (ALPHA - 默认值=false)<br>
DevicePlugins=true|false (BETA - 默认值=true)<br>
DisableAcceleratorUsageMetrics=true|false (BETA - 默认值=true)<br>
DisableCloudProviders=true|false (ALPHA - 默认值=false)<br>
DownwardAPIHugePages=true|false (BETA - 默认值=false)<br>
EfficientWatchResumption=true|false (BETA - 默认值=true)<br>
EndpointSliceTerminatingCondition=true|false (BETA - 默认值=true)<br>
EphemeralContainers=true|false (ALPHA - 默认值=false)<br>
ExpandCSIVolumes=true|false (BETA - 默认值=true)<br>
ExpandInUsePersistentVolumes=true|false (BETA - 默认值=true)<br>
ExpandPersistentVolumes=true|false (BETA - 默认值=true)<br>
ExpandedDNSConfig=true|false (ALPHA - 默认值=false)<br>
ExperimentalHostUserNamespace默认值ing=true|false (BETA - 默认值=false)<br>
GenericEphemeralVolume=true|false (BETA - 默认值=true)<br>
GracefulNodeShutdown=true|false (BETA - 默认值=true)<br>
HPAContainerMetrics=true|false (ALPHA - 默认值=false)<br>
HPAScaleToZero=true|false (ALPHA - 默认值=false)<br>
IPv6DualStack=true|false (BETA - 默认值=true)<br>
InTreePluginAWSUnregister=true|false (ALPHA - 默认值=false)<br>
InTreePluginAzureDiskUnregister=true|false (ALPHA - 默认值=false)<br>
InTreePluginAzureFileUnregister=true|false (ALPHA - 默认值=false)<br>
InTreePluginGCEUnregister=true|false (ALPHA - 默认值=false)<br>
InTreePluginOpenStackUnregister=true|false (ALPHA - 默认值=false)<br>
InTreePluginvSphereUnregister=true|false (ALPHA - 默认值=false)<br>
IndexedJob=true|false (BETA - 默认值=true)<br>
IngressClassNamespacedParams=true|false (BETA - 默认值=true)<br>
JobTrackingWithFinalizers=true|false (ALPHA - 默认值=false)<br>
KubeletCredentialProviders=true|false (ALPHA - 默认值=false)<br>
KubeletInUserNamespace=true|false (ALPHA - 默认值=false)<br>
KubeletPodResources=true|false (BETA - 默认值=true)<br>
KubeletPodResourcesGetAllocatable=true|false (ALPHA - 默认值=false)<br>
LocalStorageCapacityIsolation=true|false (BETA - 默认值=true)<br>
LocalStorageCapacityIsolationFSQuotaMonitoring=true|false (ALPHA - 默认值=false)<br>
LogarithmicScaleDown=true|false (BETA - 默认值=true)<br>
MemoryManager=true|false (BETA - 默认值=true)<br>
MemoryQoS=true|false (ALPHA - 默认值=false)<br>
MixedProtocolLBService=true|false (ALPHA - 默认值=false)<br>
NetworkPolicyEndPort=true|false (BETA - 默认值=true)<br>
NodeSwap=true|false (ALPHA - 默认值=false)<br>
NonPreemptingPriority=true|false (BETA - 默认值=true)<br>
PodAffinityNamespaceSelector=true|false (BETA - 默认值=true)<br>
PodDeletionCost=true|false (BETA - 默认值=true)<br>
PodOverhead=true|false (BETA - 默认值=true)<br>
PodSecurity=true|false (ALPHA - 默认值=false)<br>
PreferNominatedNode=true|false (BETA - 默认值=true)<br>
ProbeTerminationGracePeriod=true|false (BETA - 默认值=false)<br>
ProcMountType=true|false (ALPHA - 默认值=false)<br>
ProxyTerminatingEndpoints=true|false (ALPHA - 默认值=false)<br>
QOSReserved=true|false (ALPHA - 默认值=false)<br>
ReadWriteOncePod=true|false (ALPHA - 默认值=false)<br>
RemainingItemCount=true|false (BETA - 默认值=true)<br>
RemoveSelfLink=true|false (BETA - 默认值=true)<br>
RotateKubeletServerCertificate=true|false (BETA - 默认值=true)<br>
Seccomp默认值=true|false (ALPHA - 默认值=false)<br>
ServiceInternalTrafficPolicy=true|false (BETA - 默认值=true)<br>
ServiceLBNodePortControl=true|false (BETA - 默认值=true)<br>
ServiceLoadBalancerClass=true|false (BETA - 默认值=true)<br>
SizeMemoryBackedVolumes=true|false (BETA - 默认值=true)<br>
StatefulSetMinReadySeconds=true|false (ALPHA - 默认值=false)<br>
StorageVersionAPI=true|false (ALPHA - 默认值=false)<br>
StorageVersionHash=true|false (BETA - 默认值=true)<br>
SuspendJob=true|false (BETA - 默认值=true)<br>
TTLAfterFinished=true|false (BETA - 默认值=true)<br>
TopologyAwareHints=true|false (ALPHA - 默认值=false)<br>
TopologyManager=true|false (BETA - 默认值=true)<br>
VolumeCapacityPriority=true|false (ALPHA - 默认值=false)<br>
WinDSR=true|false (ALPHA - 默认值=false)<br>
WinOverlay=true|false (BETA - 默认值=true)<br>
WindowsHostProcessContainers=true|false (ALPHA - 默认值=false)</p>
</td>
</tr>
<tr>
<td colspan=2>--goaway-chance float</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为防止 HTTP/2 客户端卡在单个 API 服务器上，可启用随机关闭连接（GOAWAY）。
客户端的其他运行中请求将不会受到影响，并且客户端将重新连接，
可能会在再次通过负载平衡器后登陆到其他 API 服务器上。
此参数设置将发送 GOAWAY 的请求的比例。
具有单个 API 服务器或不使用负载平衡器的群集不应启用此功能。
最小值为0（关闭），最大值为 .02（1/50 请求）； 建议使用 .001（1/1000）。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kube-apiserver 的帮助命令
</td>
</tr>
<tr>
<td colspan=2>--http2-max-streams-per-connection int</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
服务器为客户端提供的 HTTP/2 连接中最大流数的限制。
零表示使用 GoLang 的默认值。
</td>
</tr>
<tr>
<td colspan=2>--identity-lease-duration-seconds int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：3600</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kube-apiserver 租约时长（按秒计），必须是正数。
（当 APIServerIdentity 特性门控被启用时使用此标志值）
</td>
</tr>
<tr>
<td colspan=2>--identity-lease-renew-interval-seconds int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：10</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kube-apiserver 对其租约进行续期的时间间隔（按秒计），必须是正数。
（当 APIServerIdentity 特性门控被启用时使用此标志值）
</td>
</tr>
<tr>
<td colspan=2>--kubelet-certificate-authority string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
证书颁发机构的证书文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--kubelet-client-certificate string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
TLS 的客户端证书文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--kubelet-client-key string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
TLS 客户端密钥文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--kubelet-preferred-address-types strings&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：Hostname,InternalDNS,InternalIP,ExternalDNS,ExternalIP</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
用于 kubelet 连接的首选 NodeAddressTypes 列表。
</td>
</tr>
<tr>
<td colspan=2>--kubelet-timeout duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：5s</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubelet 操作超时时间。
</td>
</tr>
<tr>
<td colspan=2>--kubernetes-service-node-port int</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果非零，那么 Kubernetes 主服务（由 apiserver 创建/维护）将是 NodePort 类型，
使用它作为端口的值。
如果为零，则 Kubernetes 主服务将为 ClusterIP 类型。
</td>
</tr>
<tr>
<td colspan=2>--lease-reuse-duration-seconds int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：60</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
每个租约被重用的时长。
如果此值比较低，可以避免大量对象重用此租约。
注意，如果此值过小，可能导致存储层出现性能问题。
</td>
</tr>
<tr>
<td colspan=2>--livez-grace-period duration</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
此选项代表 API 服务器完成启动序列并生效所需的最长时间。
从 API 服务器的启动时间到这段时间为止，
<tt>/livez</tt> 将假定未完成的启动后钩子将成功完成，因此返回 true。
</td>
</tr>
<tr>
<td colspan=2>--log-backtrace-at traceLocation&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：<tt>:0</tt></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
当日志机制执行到'文件 :N'时，生成堆栈跟踪。
</td>
</tr>
<tr>
<td colspan=2>--log-dir string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果为非空，则在此目录中写入日志文件。
</td>
</tr>
<tr>
<td colspan=2>--log-file string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果为非空，使用此值作为日志文件。
</td>
</tr>
<tr>
<td colspan=2>--log-file-max-size uint&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：1800</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
定义日志文件可以增长到的最大大小。单位为兆字节。
如果值为 0，则最大文件大小为无限制。
</td>
</tr>
<tr>
<td colspan=2>--log-flush-frequency duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：5s</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
两次日志刷新之间的最大秒数
</td>
</tr>
<tr>
<td colspan=2>--logging-format string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："text"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
设置日志格式。允许的格式："text"。<br>
非默认格式不支持以下标志：<code>--add-dir-header</code>、<code>--alsologtostderr</code>、<code>--log-backtrace-at</code>、<code>--log-dir</code>、<code>--log-file</code>、<code>--log-file-max-size</code>、<code>--logtostderr</code>、<code>--one-output</code>、<code>-skip-headers</code>、<code>-skip-log-headers</code>、<code>--stderrthreshold</code>、<code>-vmodule</code> 和 <code>--log-flush-frequency</code>。<br>
当前非默认选择为 alpha，会随时更改而不会发出警告。
</td>
</tr>
<tr>
<td colspan=2>--logtostderr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：true</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
在标准错误而不是文件中输出日志记录。
</td>
</tr>
<tr>
<td colspan=2>--master-service-namespace string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："default"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
已废弃：应该从其中将 Kubernetes 主服务注入到 Pod 中的名字空间。
</td>
</tr>
<tr>
<td colspan=2>--max-connection-bytes-per-sec int</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果不为零，则将每个用户连接限制为该数（字节数/秒）。
当前仅适用于长时间运行的请求。
</td>
</tr>
<tr>
<td colspan=2>--max-mutating-requests-inflight int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：200</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果 --enable-priority-and-fairness 为 true，那么此值和 --max-requests-inflight 的和将确定服务器的总并发限制（必须是正数）。
否则，该值限制进行中变更类型请求的最大个数，零表示无限制。
</td>
</tr>
<tr>
<td colspan=2>--max-requests-inflight int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：400</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果 --enable-priority-and-fairness 为 true，那么此值和 --max-mutating-requests-inflight 的和将确定服务器的总并发限制（必须是正数）。
否则，该值限制进行中非变更类型请求的最大个数，零表示无限制。
</td>
</tr>
<tr>
<td colspan=2>--min-request-timeout int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：1800</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
可选字段，表示处理程序在请求超时前，必须保持其处于打开状态的最小秒数。
当前只对监听（Watch）请求的处理程序有效，它基于这个值选择一个随机数作为连接超时值，
以达到分散负载的目的。
</td>
</tr>
<tr>
<td colspan=2>--oidc-ca-file string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果设置该值，将会使用 oidc-ca-file 中的机构之一对 OpenID 服务的证书进行验证，
否则将会使用主机的根 CA 对其进行验证。
</td>
</tr>
<tr>
<td colspan=2>--oidc-client-id string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
OpenID 连接客户端的要使用的客户 ID，如果设置了 oidc-issuer-url，则必须设置这个值。
</td>
</tr>
<tr>
<td colspan=2>--oidc-groups-claim string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果提供该值，这个自定义 OpenID 连接声明将被用来设定用户组。
该声明值需要是一个字符串或字符串数组。
此标志为实验性的，请查阅身份认证相关文档进一步了解详细信息。
</td>
</tr>
<tr>
<td colspan=2>--oidc-groups-prefix string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果提供了此值，则所有组都将以该值作为前缀，以防止与其他身份认证策略冲突。
</td>
</tr>
<tr>
<td colspan=2>--oidc-issuer-url string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
OpenID 颁发者 URL，只接受 HTTPS 方案。
如果设置该值，它将被用于验证 OIDC JSON Web Token(JWT)。
</td>
</tr>
<tr>
<td colspan=2>--oidc-required-claim &lt;逗号分隔的 'key=value' 键值对列表></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
描述 ID 令牌中必需声明的键值对。
如果设置此值，则会验证 ID 令牌中存在与该声明匹配的值。
重复此标志以指定多个声明。
</td>
</tr>
<tr>
<td colspan=2>--oidc-signing-algs strings&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：RS256</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
允许的 JOSE 非对称签名算法的逗号分隔列表。
若 JWT 所带的 "alg" 标头值不在列表中，则该 JWT 将被拒绝。
取值依据 RFC 7518 https://tools.ietf.org/html/rfc7518#section-3.1 定义。
</td>
</tr>
<tr>
<td colspan=2>--oidc-username-claim string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："sub"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
要用作用户名的 OpenID 声明。
请注意，除默认声明（"sub"）以外的其他声明不能保证是唯一且不可变的。
此标志是实验性的，请参阅身份认证文档以获取更多详细信息。
</td>
</tr>
<tr>
<td colspan=2>--oidc-username-prefix string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果提供，则所有用户名都将以该值作为前缀。
如果未提供，则除 "email" 之外的用户名声明都会添加颁发者 URL 作为前缀，以避免冲突。
要略过添加前缀处理，请设置值为 "-"。
</td>
</tr>
<tr>
<td colspan=2>--one-output</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
此标志为真时，日志只会被写入到其原生的严重性级别中（而不是同时写到所有较低
严重性级别中）。
</td>
</tr>
<tr>
<td colspan=2>--permit-address-sharing&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：false</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>
若此标志为 true，则使用 <tt>SO_REUSEADDR</tt> 来绑定端口。
这样设置可以同时绑定到用通配符表示的类似 0.0.0.0 这种 IP 地址，
以及特定的 IP 地址。也可以避免等待内核释放 <tt>TIME_WAIT</tt> 状态的套接字。
</p></td>
</tr>
<tr>
<td colspan=2>--permit-port-sharing&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：false</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果为 true，则在绑定端口时将使用 <tt>SO_REUSEPORT</tt>，
这样多个实例可以绑定到同一地址和端口上。
</td>
</tr>
<tr>
<td colspan=2>--profiling&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：true</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
通过 Web 接口 <code>host:port/debug/pprof/</code> 启用性能分析。
</td>
</tr>
<tr>
<td colspan=2>--proxy-client-cert-file string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
当必须调用外部程序以处理请求时，用于证明聚合器或者 kube-apiserver 的身份的客户端证书。
包括代理转发到用户 api-server 的请求和调用 Webhook 准入控制插件的请求。
Kubernetes 期望此证书包含来自于 --requestheader-client-ca-file 标志中所给 CA 的签名。
该 CA 在 kube-system 命名空间的 "extension-apiserver-authentication" ConfigMap 中公开。
从 kube-aggregator 收到调用的组件应该使用该 CA 进行各自的双向 TLS 验证。
</td>
</tr>
<tr>
<td colspan=2>--proxy-client-key-file string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
当必须调用外部程序来处理请求时，用来证明聚合器或者 kube-apiserver 的身份的客户端私钥。
这包括代理转发给用户 api-server 的请求和调用 Webhook 准入控制插件的请求。
</td>
</tr>
<tr>
<td colspan=2>--request-timeout duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：1m0s</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
可选字段，指示处理程序在超时之前必须保持打开请求的持续时间。
这是请求的默认请求超时，但对于特定类型的请求，可能会被
<code>--min-request-timeout</code>等标志覆盖。
</td>
</tr>
<tr>
<td colspan=2>--requestheader-allowed-names strings</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
此值为客户端证书通用名称（Common Name）的列表；表中所列的表项可以用来提供用户名，
方式是使用 <code>--requestheader-username-headers</code> 所指定的头部。
如果为空，能够通过 <code>--requestheader-client-ca-file</code> 中机构
认证的客户端证书都是被允许的。
</td>
</tr>
<tr>
<td colspan=2>--requestheader-client-ca-file string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
在信任请求头中以 <code>--requestheader-username-headers</code> 指示的用户名之前，
用于验证接入请求中客户端证书的根证书包。
警告：一般不要假定传入请求已被授权。
</td>
</tr>
<tr>
<td colspan=2>--requestheader-extra-headers-prefix strings</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
用于查验请求头部的前缀列表。建议使用 <code>X-Remote-Extra-</code>。
</td>
</tr>
<tr>
<td colspan=2>--requestheader-group-headers strings</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
用于查验用户组的请求头部列表。建议使用 <code>X-Remote-Group</code>。
</td>
</tr>
<tr>
<td colspan=2>--requestheader-username-headers strings</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
用于查验用户名的请求头头列表。建议使用 <code>X-Remote-User</code>。
</td>
</tr>
<tr>
<td colspan=2>--runtime-config &lt;逗号分隔的 'key=value' 对列表></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
一组启用或禁用内置 API 的键值对。支持的选项包括：
<br>v1=true|false（针对核心 API 组）
<br>&lt;group>/&lt;version>=true|false（针对特定 API 组和版本，例如：apps/v1=true）
<br>api/all=true|false 控制所有 API 版本
<br>api/ga=true|false 控制所有 v[0-9]+ API 版本
<br>api/beta=true|false 控制所有 v[0-9]+beta[0-9]+ API 版本
<br>api/alpha=true|false 控制所有 v[0-9]+alpha[0-9]+ API 版本
<br>api/legacy 已弃用，并将在以后的版本中删除
</td>
</tr>
<tr>
<td colspan=2>--secure-port int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：6443</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
带身份验证和鉴权机制的 HTTPS 服务端口。
不能用 0 关闭。
</td>
</tr>
<tr>
<td colspan=2>--service-account-extend-token-expiration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：true</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
在生成令牌时，启用投射服务帐户到期时间扩展，
这有助于从旧版令牌安全地过渡到绑定的服务帐户令牌功能。
如果启用此标志，则准入插件注入的令牌的过期时间将延长至 1 年，以防止过渡期间发生意外故障，
并忽略 service-account-max-token-expiration 的值。
</td>
</tr>
<tr>
<td colspan=2>--service-account-issuer strings</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
服务帐号令牌颁发者的标识符。
颁发者将在已办法令牌的 "iss" 声明中检查此标识符。
此值为字符串或 URI。
如果根据 OpenID Discovery 1.0 规范检查此选项不是有效的 URI，则即使特性门控设置为 true，
ServiceAccountIssuerDiscovery 功能也将保持禁用状态。
强烈建议该值符合 OpenID 规范：https://openid.net/specs/openid-connect-discovery-1_0.html。
实践中，这意味着 service-account-issuer 取值必须是 HTTPS URL。
还强烈建议此 URL 能够在 {service-account-issuer}/.well-known/openid-configuration
处提供 OpenID 发现文档。
当此值被多次指定时，第一次的值用于生成令牌，所有的值用于确定接受哪些发行人。
</td>
</tr>
<tr>
<td colspan=2>--service-account-jwks-uri string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
覆盖 <code>/.well-known/openid-configuration</code> 提供的发现文档中 JSON Web 密钥集的 URI。
如果发现文档和密钥集是通过 API 服务器外部
（而非自动检测到或被外部主机名覆盖）之外的 URL 提供给依赖方的，则此标志很有用。
仅在启用 ServiceAccountIssuerDiscovery 特性门控的情况下有效。
</td>
</tr>
<tr>
<td colspan=2>--service-account-key-file strings</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
包含 PEM 编码的 x509 RSA 或 ECDSA 私钥或公钥的文件，用于验证 ServiceAccount 令牌。
指定的文件可以包含多个键，并且可以使用不同的文件多次指定标志。
如果未指定，则使用 <code>--tls-private-key-file</code>。
提供 <code>--service-account-signing-key</code> 时必须指定。
</td>
</tr>
<tr>
<td colspan=2>--service-account-lookup&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：true</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果为 true，则在身份认证时验证 etcd 中是否存在 ServiceAccount 令牌。
</td>
</tr>
<tr>
<td colspan=2>--service-account-max-token-expiration duration</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
服务帐户令牌发布者创建的令牌的最长有效期。
如果请求有效期大于此值的有效令牌请求，将使用此值的有效期颁发令牌。
</td>
</tr>
<tr>
<td colspan=2>--service-account-signing-key-file string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
包含服务帐户令牌颁发者当前私钥的文件的路径。
颁发者将使用此私钥签署所颁发的 ID 令牌。
</td>
</tr>
<tr>
<td colspan=2>--service-cluster-ip-range string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
CIDR 表示的 IP 范围用来为服务分配集群 IP。
此地址不得与指定给节点或 Pod 的任何 IP 范围重叠。
</td>
</tr>
<tr>
<td colspan=2>--service-node-port-range &lt;形式为 'N1-N2' 的字符串>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：30000-32767</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
保留给具有 NodePort 可见性的服务的端口范围。
例如："30000-32767"。范围的两端都包括在内。
</td>
</tr>
<tr>
<td colspan=2>--show-hidden-metrics-for-version string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
你要显示隐藏指标的先前版本。仅先前的次要版本有意义，不允许其他值。
格式为 &lt;major>.&lt;minor>，例如："1.16"。
这种格式的目的是确保你有机会注意到下一个版本是否隐藏了其他指标，
而不是在此之后将它们从发行版中永久删除时感到惊讶。
</td>
</tr>
<tr>
<td colspan=2>--shutdown-delay-duration duration</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
延迟终止时间。在此期间，服务器将继续正常处理请求。
端点 /healthz 和 /livez 将返回成功，但是 /readyz 立即返回失败。
在此延迟过去之后，将开始正常终止。
这可用于允许负载平衡器停止向该服务器发送流量。
</td>
</tr>
<tr>
<td colspan=2>--skip-headers</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果为 true，日志消息中避免标题前缀。
</td>
</tr>
<tr>
<td colspan=2>--skip-log-headers</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果为 true，则在打开日志文件时避免标题。
</td>
</tr>
<tr>
<td colspan=2>--stderrthreshold int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：2</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
将达到或超过此阈值的日志写到标准错误输出
</td>
</tr>
<tr>
<td colspan=2>--storage-backend string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
持久化存储后端。选项："etcd3"（默认）。
</td>
</tr>
<tr>
<td colspan=2>--storage-media-type string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："application/vnd.kubernetes.protobuf"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
用于在存储中存储对象的媒体类型。
某些资源或存储后端可能仅支持特定的媒体类型，并且将忽略此设置。
</td>
</tr>
<tr>
<td colspan=2>--strict-transport-security-directives strings</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>
为 HSTS 所设置的指令列表，用逗号分隔。
如果此列表为空，则不会添加 HSTS 指令。
例如： 'max-age=31536000,includeSubDomains,preload'
</p></td>
</tr>
<tr>
<td colspan=2>--tls-cert-file string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
包含用于 HTTPS 的默认 x509 证书的文件。（CA 证书（如果有）在服务器证书之后并置）。
如果启用了 HTTPS 服务，并且未提供 <code>--tls-cert-file</code> 和
<code>--tls-private-key-file</code>，
为公共地址生成一个自签名证书和密钥，并将其保存到 <code>--cert-dir</code> 指定的目录中。
</td>
</tr>
<tr>
<td colspan=2>--tls-cipher-suites strings</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
服务器的密码套件的列表，以逗号分隔。如果省略，将使用默认的 Go 密码套件。
<br>首选值：
TLS_AES_128_GCM_SHA256、TLS_AES_256_GCM_SHA384、TLS_CHACHA20_POLY1305_SHA256、TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA、TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256、TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA、TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384、TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305、TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256、TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA、TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA、TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256、TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA、TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384、TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305、TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256、TLS_RSA_WITH_3DES_EDE_CBC_SHA、TLS_RSA_WITH_AES_128_CBC_SHA、TLS_RSA_WITH_AES_128_GCM_SHA256、 TLS_RSA_WITH_AES_256_CBC_SHA, TLS_RSA_WITH_AES_256_GCM_SHA384.
不安全的值有：
TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256、TLS_ECDHE_ECDSA_WITH_RC4_128_SHA、TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256、TLS_ECDHE_RSA_WITH_RC4_128_SHA、TLS_RSA_WITH_AES_128_CBC_SHA256、TLS_RSA_WITH_RC4_128_SHA。
</td>
</tr>
<tr>
<td colspan=2>--tls-min-version string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
支持的最低 TLS 版本。可能的值：VersionTLS10，VersionTLS11，VersionTLS12，VersionTLS13
</td>
</tr>
<tr>
<td colspan=2>--tls-private-key-file string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
包含匹配 <code>--tls-cert-file</code> 的 x509 证书私钥的文件。
</td>
</tr>
<tr>
<td colspan=2>--tls-sni-cert-key string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值： []</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
一对 x509 证书和私钥文件路径，（可选）后缀为全限定域名的域名模式列表，可以使用带有通配符的前缀。
域模式也允许使用 IP 地址，但仅当 apiserver 对客户端请求的IP地址具有可见性时，才应使用 IP。
如果未提供域模式，则提取证书的名称。
非通配符匹配优先于通配符匹配，显式域模式优先于提取出的名称。
对于多个密钥/证书对，请多次使用 <code>--tls-sni-cert-key</code>。
示例："example.crt,example.key" 或 "foo.crt,foo.key:\*.foo.com,foo.com"。
</td>
</tr>
<tr>
<td colspan=2>--token-auth-file string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果设置该值，这个文件将被用于通过令牌认证来保护 API 服务的安全端口。
</td>
</tr>
<tr>
<td colspan=2>--tracing-config-file string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
包含 API 服务器跟踪配置的文件。
</td>
</tr>
<tr>
<td colspan=2>-v, --v int</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
日志级别详细程度的数字。
</td>
</tr>
<tr>
<td colspan=2>--version version[=true]</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
打印版本信息并退出
</td>
</tr>
<tr>
<td colspan=2>--vmodule &lt;用逗号分隔的多个 'pattern=N' 配置字符串></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
以逗号分隔的 <code>pattern=N</code> 设置列表，用于文件过滤的日志记录。
</td>
</tr>
<tr>
<td colspan=2>--watch-cache&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：true</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
在 API 服务器中启用监视缓存。
</td>
</tr>
<tr>
<td colspan=2>--watch-cache-sizes strings</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
某些资源（Pods、Nodes 等）的监视缓存大小设置，以逗号分隔。
每个资源对应的设置格式：<code>resource[.group]#size</code>，其中
<code>resource</code> 为小写复数（无版本），
对于 apiVersion v1（旧版核心 API）的资源要省略 <code>group</code>，
对其它资源要给出 <code>group</code>；<code>size 为一个数字</code>。
启用 <code>watch-cache</code> 时，此功能生效。
某些资源（<code>replicationcontrollers</code>、<code>endpoints</code>、
<code>nodes</code>、<code>pods</code>、<code>services</code>、
<code>apiservices.apiregistration.k8s.io</code>）
具有通过启发式设置的系统默认值，其他资源默认为
<code>default-watch-cache-size<code>。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-8a37271ec8fd36a3a1ce07c4c58533d9>11.4 - kube-controller-manager</h1>
<h2 id=synopsis>Synopsis</h2>
<p>Kubernetes 控制器管理器是一个守护进程，内嵌随 Kubernetes 一起发布的核心控制回路。
在机器人和自动化的应用中，控制回路是一个永不休止的循环，用于调节系统状态。
在 Kubernetes 中，每个控制器是一个控制回路，通过 API 服务器监视集群的共享状态，
并尝试进行更改以将当前状态转为期望状态。
目前，Kubernetes 自带的控制器例子包括副本控制器、节点控制器、命名空间控制器和服务账号控制器等。</p>
<pre><code>kube-controller-manager [flags]
</code></pre><h2 id=options>Options</h2>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--add-dir-header</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
若为 true，将文件目录添加到日志消息的头部。
</td>
</tr>
<tr>
<td colspan=2>--allocate-node-cidrs</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
基于云驱动来为 Pod 分配和设置子网掩码。
</td>
</tr>
<tr>
<td colspan=2>--allow-metric-labels stringToString&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：""</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>
<p>
从度量值标签到准许值列表的映射。键名的格式为&lt;MetricName>,&lt;LabelName>。
准许值的格式为&lt;allowed_value>,&lt;allowed_value>...。
例如，<code>metric1,label1='v1,v2,v3', metric1,label2='v1,v2,v3'
metric2,label='v1,v2,v3'</code>。
</p>
</td>
</tr>
<tr>
<td colspan=2>--alsologtostderr</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
在向文件输出日志的同时，也将日志写到标准输出。
</td>
</tr>
<tr>
<td colspan=2>--attach-detach-reconcile-sync-period duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：1m0s</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
协调器（reconciler）在相邻两次对存储卷进行挂载和解除挂载操作之间的等待时间。
此时长必须长于 1 秒钟。此值设置为大于默认值时，可能导致存储卷无法与 Pods 匹配。
</td>
</tr>
<tr>
<td colspan=2>--authentication-kubeconfig string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
此标志值为一个 kubeconfig 文件的路径名。该文件中包含与某 Kubernetes “核心”
服务器相关的信息，并支持足够的权限以创建 tokenreviews.authentication.k8s.io。
此选项是可选的。如果设置为空值，所有令牌请求都会被认作匿名请求，
Kubernetes 也不再在集群中查找客户端的 CA 证书信息。
</td>
</tr>
<tr>
<td colspan=2>--authentication-skip-lookup</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
此值为 false 时，通过 authentication-kubeconfig 参数所指定的文件会被用来
检索集群中缺失的身份认证配置信息。
</td>
</tr>
<tr>
<td colspan=2>--authentication-token-webhook-cache-ttl duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：10s</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对 Webhook 令牌认证设施返回结果的缓存时长。
</td>
</tr>
<tr>
<td colspan=2>--authentication-tolerate-lookup-failure</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
此值为 true 时，即使无法从集群中检索到缺失的身份认证配置信息也无大碍。
需要注意的是，这样设置可能导致所有请求都被视作匿名请求。
</td>
</tr>
<tr>
<td colspan=2>--authorization-always-allow-paths strings&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/healthz,/readyz,/livez"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
鉴权过程中会忽略的一个 HTTP 路径列表。
换言之，控制器管理器会对列表中路径的访问进行授权，并且无须征得
Kubernetes “核心” 服务器同意。
</td>
</tr>
<tr>
<td colspan=2>--authorization-kubeconfig string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
包含 Kubernetes “核心” 服务器信息的 kubeconfig 文件路径，
所包含信息具有创建 subjectaccessreviews.authorization.k8s.io 的足够权限。
此参数是可选的。如果配置为空字符串，未被鉴权模块所忽略的请求都会被禁止。
</td>
</tr>
<tr>
<td colspan=2>--authorization-webhook-cache-authorized-ttl duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：10s</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对 Webhook 形式鉴权组件所返回的“已授权（Authorized）”响应的缓存时长。
</td>
</tr>
<tr>
<td colspan=2>--authorization-webhook-cache-unauthorized-ttl duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：10s</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对 Webhook 形式鉴权组件所返回的“未授权（Unauthorized）”响应的缓存时长。
</td>
</tr>
<tr>
<td colspan=2>--azure-container-registry-config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指向包含 Azure 容器仓库配置信息的文件的路径名。
</td>
</tr>
<tr>
<td colspan=2>--bind-address ip&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：0.0.0.0</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
针对 <code>--secure-port</code> 端口上请求执行监听操作的 IP 地址。
所对应的网络接口必须从集群中其它位置可访问（含命令行及 Web 客户端）。
如果此值为空或者设定为非特定地址（<code>0.0.0.0</code> 或 <code>::</code>），
意味着所有网络接口都在监听范围。
</td>
</tr>
<tr>
<td colspan=2>--cert-dir string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
TLS 证书所在的目录。如果提供了 <code>--tls-cert-file</code> 和
<code>--tls-private-key-file</code>，此标志会被忽略。
</td>
</tr>
<tr>
<td colspan=2>--cidr-allocator-type string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："RangeAllocator"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
要使用的 CIDR 分配器类型。
</td>
</tr>
<tr>
<td colspan=2>--client-ca-file string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果设置了此标志，对于所有能够提供客户端证书的请求，若该证书由
<code>--client-ca-file</code> 中所给机构之一签署，则该请求会被
成功认证为客户端证书中 CommonName 所标识的实体。
</td>
</tr>
<tr>
<td colspan=2>--cloud-config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
云驱动程序配置文件的路径。空字符串表示没有配置文件。
</td>
</tr>
<tr>
<td colspan=2>--cloud-provider string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
云服务的提供者。空字符串表示没有对应的提供者（驱动）。
</td>
</tr>
<tr>
<td colspan=2>--cluster-cidr string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
集群中 Pods 的 CIDR 范围。要求 <code>--allocate-node-cidrs</code> 标志为 true。
</td>
</tr>
<tr>
<td colspan=2>--cluster-name string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："kubernetes"</td -->
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
集群实例的前缀。
</td>
</tr>
<tr>
<td colspan=2>--cluster-signing-cert-file string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
包含 PEM 编码格式的 X509 CA 证书的文件名。该证书用来发放集群范围的证书。
如果设置了此标志，则不能指定更具体的<code>--cluster-signing-*</code> 标志。
</td>
</tr>
<tr>
<td colspan=2>--cluster-signing-duration duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：8760h0m0s</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
所签名证书的有效期限。每个 CSR 可以通过设置 spec.expirationSeconds 来请求更短的证书。
</td>
</tr>
<tr>
<td colspan=2>--cluster-signing-key-file string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
包含 PEM 编码的 RSA 或 ECDSA 私钥的文件名。该私钥用来对集群范围证书签名。
若指定了此选项，则不可再设置 <code>--cluster-signing-*</code> 参数。
</td>
</tr>
<tr>
<td colspan=2>--cluster-signing-kube-apiserver-client-cert-file string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
包含 PEM 编码的 X509 CA 证书的文件名，
该证书用于为 kubernetes.io/kube-apiserver-client 签署者颁发证书。
如果指定，则不得设置 <code>--cluster-signing-{cert,key}-file</code>。
</td>
</tr>
<tr>
<td colspan=2>--cluster-signing-kube-apiserver-client-key-file string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
包含 PEM 编码的 RSA 或 ECDSA 私钥的文件名，
该私钥用于为 kubernetes.io/kube-apiserver-client 签署者签名证书。
如果指定，则不得设置 <code>--cluster-signing-{cert,key}-file</code>。
</td>
</tr>
<tr>
<td colspan=2>--cluster-signing-kubelet-client-cert-file string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
包含 PEM 编码的 X509 CA 证书的文件名，
该证书用于为 kubernetes.io/kube-apiserver-client-kubelet 签署者颁发证书。
如果指定，则不得设置 <code>--cluster-signing-{cert,key}-file</code>。
</td>
</tr>
<tr>
<td colspan=2>--cluster-signing-kubelet-client-key-file string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
包含 PEM 编码的 RSA 或 ECDSA 私钥的文件名，
该私钥用于为 kubernetes.io/kube-apiserver-client-kubelet 签署者签名证书。
如果指定，则不得设置 <code>--cluster-signing-{cert,key}-file</code>。
</td>
</tr>
<tr>
<td colspan=2>--cluster-signing-kubelet-serving-cert-file string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
包含 PEM 编码的 X509 CA 证书的文件名，
该证书用于为 kubernetes.io/kubelet-serving 签署者颁发证书。
如果指定，则不得设置 </code>--cluster-signing-{cert,key}-file</code>。
</td>
</tr>
<tr>
<td colspan=2>--cluster-signing-kubelet-serving-key-file string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
包含 PEM 编码的 RSA或ECDSA 私钥的文件名，
该私钥用于对 kubernetes.io/kubelet-serving 签署者的证书进行签名。
如果指定，则不得设置 <code>--cluster-signing-{cert,key}-file</code>。
</td>
</tr>
<tr>
<td colspan=2>--cluster-signing-legacy-unknown-cert-file string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
包含 PEM 编码的 X509 CA 证书的文件名，
用于为 kubernetes.io/legacy-unknown 签署者颁发证书。
如果指定，则不得设置 <code>--cluster-signing-{cert,key}-file</code>。
</td>
</tr>
<tr>
<td colspan=2>--cluster-signing-legacy-unknown-key-file string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
包含 PEM 编码的 RSA 或 ECDSA 私钥的文件名，
用于为 kubernetes.io/legacy-unknown 签署者签名证书。
如果指定，则不得设置 <code>--cluster-signing-{cert,key}-file</code>。
</td>
</tr>
<tr>
<td colspan=2>--concurrent-deployment-syncs int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：5</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
可以并发同步的 Deployment 对象个数。数值越大意味着对 Deployment 的响应越及时，
同时也意味着更大的 CPU（和网络带宽）压力。
</td>
</tr>
<tr>
<td colspan=2>--concurrent-endpoint-syncs int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：5</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
可以并发执行的 Endpoints 同步操作个数。数值越大意味着更快的 Endpoints 更新操作，
同时也意味着更大的 CPU （和网络）压力。
</td>
</tr>
<tr>
<td colspan=2>--concurrent-gc-syncs int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：20</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
可以并发同步的垃圾收集工作线程个数。
</td>
</tr>
<tr>
<td colspan=2>--concurrent-namespace-syncs int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：10</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
可以并发同步的 Namespace 对象个数。较大的数值意味着更快的名字空间终结操作，
不过也意味着更多的 CPU （和网络）占用。
</td>
</tr>
<tr>
<td colspan=2>--concurrent-rc-syncs int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：5</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>
可以并发同步的副本控制器对象个数。较大的数值意味着更快的副本管理操作，
不过也意味着更多的 CPU （和网络）占用。
</p></td>
</tr>
<tr>
<td colspan=2>--concurrent-replicaset-syncs int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：5</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
可以并发同步的 ReplicaSet 个数。数值越大意味着副本管理的响应速度越快，
同时也意味着更多的 CPU （和网络）占用。
</td>
</tr>
<tr>
<td colspan=2>--concurrent-resource-quota-syncs int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：5</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
可以并发同步的 ResourceQuota 对象个数。数值越大，配额管理的响应速度越快，
不过对 CPU （和网络）的占用也越高。
</td>
</tr>
<tr>
<td colspan=2>--concurrent-service-endpoint-syncs int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：5</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
可以并发执行的服务端点同步操作个数。数值越大，端点片段（Endpoint Slice）
的更新速度越快，不过对 CPU （和网络）的占用也越高。默认值为 5。
</td>
</tr>
<tr>
<td colspan=2>--concurrent-service-syncs int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：1</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
可以并发同步的 Service 对象个数。数值越大，服务管理的响应速度越快，
不过对 CPU （和网络）的占用也越高。
</td>
</tr>
<tr>
<td colspan=2>--concurrent-serviceaccount-token-syncs int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：5</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
可以并发同步的服务账号令牌对象个数。数值越大，令牌生成的速度越快，
不过对 CPU （和网络）的占用也越高。
</td>
</tr>
<tr>
<td colspan=2>--concurrent-statefulset-syncs int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：5</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
可以并发同步的 StatefulSet 对象个数。数值越大，StatefulSet 管理的响应速度越快，
不过对 CPU （和网络）的占用也越高。
</td>
</tr>
<tr>
<td colspan=2>--concurrent-ttl-after-finished-syncs int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：5</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
可以并发同步的 TTL-after-finished 控制器线程个数。
</td>
</tr>
<tr>
<td colspan=2>--configure-cloud-routes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：true</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
决定是否由 <code>--allocate-node-cidrs</code> 所分配的 CIDR 要通过云驱动程序来配置。
</td>
</tr>
<tr>
<td colspan=2>--contention-profiling</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
在启用了性能分析（profiling）时，也启用锁竞争情况分析。
</td>
</tr>
<tr>
<td colspan=2>--controller-start-interval duration</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
在两次启动控制器管理器之间的时间间隔。
</td>
</tr>
<tr>
<td colspan=2>--controllers strings&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：<code>[*]</code></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
要启用的控制器列表。<code>\*</code> 表示启用所有默认启用的控制器；
<code>foo</code> 启用名为 foo 的控制器；
<code>-foo</code> 表示禁用名为 foo 的控制器。<br>
控制器的全集：attachdetach、bootstrapsigner、cloud-node-lifecycle、clusterrole-aggregation、cronjob、csrapproving、csrcleaner、csrsigning、daemonset、deployment、disruption、endpoint、endpointslice、endpointslicemirroring、ephemeral-volume、garbagecollector、horizontalpodautoscaling、job、namespace、nodeipam、nodelifecycle、persistentvolume-binder、persistentvolume-expander、podgc、pv-protection、pvc-protection、replicaset、replicationcontroller、resourcequota、root-ca-cert-publisher、route、service、serviceaccount、serviceaccount-token、statefulset、tokencleaner、ttl、ttl-after-finished<br>
默认禁用的控制器有：bootstrapsigner 和 tokencleaner。</td>
</tr>
<tr>
<td colspan=2>--deployment-controller-sync-period duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：30s</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
Deployment 资源的同步周期。
</td>
</tr>
<tr>
<td colspan=2>--disable-attach-detach-reconcile-sync</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
禁用卷挂接/解挂调节器的同步。禁用此同步可能导致卷存储与 Pod 之间出现错位。
请小心使用。
</td>
</tr>
<tr>
<td colspan=2>--disabled-metrics strings</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>
此标志提供对行为异常的度量值的防控措施。你必须提供度量值的
完全限定名称才能将其禁用。<b>声明</b>：禁用度量值的操作比显示隐藏度量值
的操作优先级高。
</p></td>
</tr>
<tr>
<td colspan=2>--enable-dynamic-provisioning&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：true</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
在环境允许的情况下启用动态卷制备。
</td>
</tr>
<tr>
<td colspan=2>--enable-garbage-collector&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：true</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
启用通用垃圾收集器。必须与 kube-apiserver 中对应的标志一致。
</td>
</tr>
<tr>
<td colspan=2>--enable-hostpath-provisioner</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
在没有云驱动程序的情况下，启用 HostPath 持久卷的制备。
此参数便于对卷供应功能进行开发和测试。HostPath 卷的制备并非受支持的功能特性，
在多节点的集群中也无法工作，因此除了开发和测试环境中不应使用。
</td>
</tr>
<tr>
<td colspan=2>--enable-leader-migration</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>
此标志决定是否启用控制器领导者迁移。
</p></td>
</tr>
<tr>
<td colspan=2>--enable-taint-manager&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：true</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
警告：此为Beta 阶段特性。设置为 true 时会启用 NoExecute 污点，
并在所有标记了此污点的节点上逐出所有无法忍受该污点的 Pods。
</td>
</tr>
<tr>
<td colspan=2>--endpoint-updates-batch-period duration</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
端点（Endpoint）批量更新周期时长。对 Pods 变更的处理会被延迟，
以便将其与即将到来的更新操作合并，从而减少端点更新操作次数。
较大的数值意味着端点更新的迟滞时间会增长，也意味着所生成的端点版本个数会变少。
</td>
</tr>
<tr>
<td colspan=2>--endpointslice-updates-batch-period duration</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
端点片段（Endpoint Slice）批量更新周期时长。对 Pods 变更的处理会被延迟，
以便将其与即将到来的更新操作合并，从而减少端点更新操作次数。
较大的数值意味着端点更新的迟滞时间会增长，也意味着所生成的端点版本个数会变少。
</td>
</tr>
<tr>
<td colspan=2>--experimental-logging-sanitization</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[试验性功能] 当启用此标志时，被标记为敏感的字段（密码、密钥、令牌）不会被日志输出。<br>
运行时的日志清理操作可能会引入相当程度的计算开销，因此不应在生产环境中启用。
</td>
</tr>
<tr>
<td colspan=2>--external-cloud-volume-plugin string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
当云驱动程序设置为 external 时要使用的插件名称。此字符串可以为空。
只能在云驱动程序为 external 时设置。目前用来保证节点控制器和卷控制器能够
在三种云驱动上正常工作。
</td>
</tr>
<tr>
<td colspan=2>--feature-gates &lt;逗号分隔的 'key=True|False' 对列表></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
<p>
一组 key=value 对，用来描述测试性/试验性功能的特性门控（Feature Gate）。可选项有：
APIListChunking=true|false (BETA - 默认值=true)<br>
APIPriorityAndFairness=true|false (BETA - 默认值=true)<br>
APIResponseCompression=true|false (BETA - 默认值=true)<br>
APIServerIdentity=true|false (ALPHA - 默认值=false)<br>
APIServerTracing=true|false (ALPHA - 默认值=false)<br>
AllAlpha=true|false (ALPHA - 默认值=false)<br>
AllBeta=true|false (BETA - 默认值=false)<br>
AnyVolumeDataSource=true|false (ALPHA - 默认值=false)<br>
AppArmor=true|false (BETA - 默认值=true)<br>
CPUManager=true|false (BETA - 默认值=true)<br>
CPUManagerPolicyOptions=true|false (ALPHA - 默认值=false)<br>
CSIInlineVolume=true|false (BETA - 默认值=true)<br>
CSIMigration=true|false (BETA - 默认值=true)<br>
CSIMigrationAWS=true|false (BETA - 默认值=false)<br>
CSIMigrationAzureDisk=true|false (BETA - 默认值=false)<br>
CSIMigrationAzureFile=true|false (BETA - 默认值=false)<br>
CSIMigrationGCE=true|false (BETA - 默认值=false)<br>
CSIMigrationOpenStack=true|false (BETA - 默认值=true)<br>
CSIMigrationvSphere=true|false (BETA - 默认值=false)<br>
CSIStorageCapacity=true|false (BETA - 默认值=true)<br>
CSIVolumeFSGroupPolicy=true|false (BETA - 默认值=true)<br>
CSIVolumeHealth=true|false (ALPHA - 默认值=false)<br>
CSRDuration=true|false (BETA - 默认值=true)<br>
ConfigurableFSGroupPolicy=true|false (BETA - 默认值=true)<br>
ControllerManagerLeaderMigration=true|false (BETA - 默认值=true)<br>
CustomCPUCFSQuotaPeriod=true|false (ALPHA - 默认值=false)<br>
DaemonSetUpdateSurge=true|false (BETA - 默认值=true)<br>
默认值PodTopologySpread=true|false (BETA - 默认值=true)<br>
DelegateFSGroupToCSIDriver=true|false (ALPHA - 默认值=false)<br>
DevicePlugins=true|false (BETA - 默认值=true)<br>
DisableAcceleratorUsageMetrics=true|false (BETA - 默认值=true)<br>
DisableCloudProviders=true|false (ALPHA - 默认值=false)<br>
DownwardAPIHugePages=true|false (BETA - 默认值=false)<br>
EfficientWatchResumption=true|false (BETA - 默认值=true)<br>
EndpointSliceTerminatingCondition=true|false (BETA - 默认值=true)<br>
EphemeralContainers=true|false (ALPHA - 默认值=false)<br>
ExpandCSIVolumes=true|false (BETA - 默认值=true)<br>
ExpandInUsePersistentVolumes=true|false (BETA - 默认值=true)<br>
ExpandPersistentVolumes=true|false (BETA - 默认值=true)<br>
ExpandedDNSConfig=true|false (ALPHA - 默认值=false)<br>
ExperimentalHostUserNamespace默认值ing=true|false (BETA - 默认值=false)<br>
GenericEphemeralVolume=true|false (BETA - 默认值=true)<br>
GracefulNodeShutdown=true|false (BETA - 默认值=true)<br>
HPAContainerMetrics=true|false (ALPHA - 默认值=false)<br>
HPAScaleToZero=true|false (ALPHA - 默认值=false)<br>
IPv6DualStack=true|false (BETA - 默认值=true)<br>
InTreePluginAWSUnregister=true|false (ALPHA - 默认值=false)<br>
InTreePluginAzureDiskUnregister=true|false (ALPHA - 默认值=false)<br>
InTreePluginAzureFileUnregister=true|false (ALPHA - 默认值=false)<br>
InTreePluginGCEUnregister=true|false (ALPHA - 默认值=false)<br>
InTreePluginOpenStackUnregister=true|false (ALPHA - 默认值=false)<br>
InTreePluginvSphereUnregister=true|false (ALPHA - 默认值=false)<br>
IndexedJob=true|false (BETA - 默认值=true)<br>
IngressClassNamespacedParams=true|false (BETA - 默认值=true)<br>
JobTrackingWithFinalizers=true|false (ALPHA - 默认值=false)<br>
KubeletCredentialProviders=true|false (ALPHA - 默认值=false)<br>
KubeletInUserNamespace=true|false (ALPHA - 默认值=false)<br>
KubeletPodResources=true|false (BETA - 默认值=true)<br>
KubeletPodResourcesGetAllocatable=true|false (ALPHA - 默认值=false)<br>
LocalStorageCapacityIsolation=true|false (BETA - 默认值=true)<br>
LocalStorageCapacityIsolationFSQuotaMonitoring=true|false (ALPHA - 默认值=false)<br>
LogarithmicScaleDown=true|false (BETA - 默认值=true)<br>
MemoryManager=true|false (BETA - 默认值=true)<br>
MemoryQoS=true|false (ALPHA - 默认值=false)<br>
MixedProtocolLBService=true|false (ALPHA - 默认值=false)<br>
NetworkPolicyEndPort=true|false (BETA - 默认值=true)<br>
NodeSwap=true|false (ALPHA - 默认值=false)<br>
NonPreemptingPriority=true|false (BETA - 默认值=true)<br>
PodAffinityNamespaceSelector=true|false (BETA - 默认值=true)<br>
PodDeletionCost=true|false (BETA - 默认值=true)<br>
PodOverhead=true|false (BETA - 默认值=true)<br>
PodSecurity=true|false (ALPHA - 默认值=false)<br>
PreferNominatedNode=true|false (BETA - 默认值=true)<br>
ProbeTerminationGracePeriod=true|false (BETA - 默认值=false)<br>
ProcMountType=true|false (ALPHA - 默认值=false)<br>
ProxyTerminatingEndpoints=true|false (ALPHA - 默认值=false)<br>
QOSReserved=true|false (ALPHA - 默认值=false)<br>
ReadWriteOncePod=true|false (ALPHA - 默认值=false)<br>
RemainingItemCount=true|false (BETA - 默认值=true)<br>
RemoveSelfLink=true|false (BETA - 默认值=true)<br>
RotateKubeletServerCertificate=true|false (BETA - 默认值=true)<br>
Seccomp默认值=true|false (ALPHA - 默认值=false)<br>
ServiceInternalTrafficPolicy=true|false (BETA - 默认值=true)<br>
ServiceLBNodePortControl=true|false (BETA - 默认值=true)<br>
ServiceLoadBalancerClass=true|false (BETA - 默认值=true)<br>
SizeMemoryBackedVolumes=true|false (BETA - 默认值=true)<br>
StatefulSetMinReadySeconds=true|false (ALPHA - 默认值=false)<br>
StorageVersionAPI=true|false (ALPHA - 默认值=false)<br>
StorageVersionHash=true|false (BETA - 默认值=true)<br>
SuspendJob=true|false (BETA - 默认值=true)<br>
TTLAfterFinished=true|false (BETA - 默认值=true)<br>
TopologyAwareHints=true|false (ALPHA - 默认值=false)<br>
TopologyManager=true|false (BETA - 默认值=true)<br>
VolumeCapacityPriority=true|false (ALPHA - 默认值=false)<br>
WinDSR=true|false (ALPHA - 默认值=false)<br>
WinOverlay=true|false (BETA - 默认值=true)<br>
WindowsHostProcessContainers=true|false (ALPHA - 默认值=false)
</p>
</td>
</tr>
<tr>
<td colspan=2>--flex-volume-plugin-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/usr/libexec/kubernetes/kubelet-plugins/volume/exec/"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
FlexVolume 插件要搜索第三方卷插件的目录路径全名。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kube-controller-manager 的帮助信息。
</td>
</tr>
<tr>
<td colspan=2>--horizontal-pod-autoscaler-cpu-initialization-period duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：5m0s</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
Pod 启动之后可以忽略 CPU 采样值的时长。
</td>
</tr>
<tr>
<td colspan=2>--horizontal-pod-autoscaler-downscale-stabilization duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：5m0s</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
自动扩缩程序的回溯时长。自动扩缩器不会基于在给定的时长内所建议的规模
对负载执行规模缩小的操作。
</td>
</tr>
<tr>
<td colspan=2>--horizontal-pod-autoscaler-initial-readiness-delay duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：30s</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
Pod 启动之后，在此值所给定的时长内，就绪状态的变化都不会作为初始的就绪状态。
</td>
</tr>
<tr>
<td colspan=2>--horizontal-pod-autoscaler-sync-period duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：15s</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
水平 Pod 扩缩器对 Pods 数目执行同步操作的周期。
</td>
</tr>
<tr>
<td colspan=2>--horizontal-pod-autoscaler-tolerance float&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：0.1</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
此值为目标值与实际值的比值与 1.0 的差值。只有超过此标志所设的阈值时，
HPA 才会考虑执行缩放操作。
</td>
</tr>
<tr>
<td colspan=2>--http2-max-streams-per-connection int</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
服务器为客户端所设置的 HTTP/2 连接中流式连接个数上限。
此值为 0 表示采用 Go 语言库所设置的默认值。
</td>
</tr>
<tr>
<td colspan=2>--kube-api-burst int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：30</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
与 Kubernetes API 服务器通信时突发峰值请求个数上限。
</td>
</tr>
<tr>
<td colspan=2>--kube-api-content-type string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："application/vnd.kubernetes.protobuf"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
向 API 服务器发送请求时使用的内容类型（Content-Type）。
</td>
</tr>
<tr>
<td colspan=2>--kube-api-qps float32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：20</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
与 API 服务器通信时每秒请求数（QPS）限制。
</td>
</tr>
<tr>
<td colspan=2>--kubeconfig string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指向 kubeconfig 文件的路径。该文件中包含主控节点位置以及鉴权凭据信息。
</td>
</tr>
<tr>
<td colspan=2>--large-cluster-size-threshold int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：50</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
节点控制器在执行 Pod 逐出操作逻辑时，基于此标志所设置的节点个数阈值来判断
所在集群是否为大规模集群。当集群规模小于等于此规模时，
<code>--secondary-node-eviction-rate</code> 会被隐式重设为 0。
</td>
</tr>
<tr>
<td colspan=2>--leader-elect&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：true</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
在执行主循环之前，启动领导选举（Leader Election）客户端，并尝试获得领导者身份。
在运行多副本组件时启用此标志有助于提高可用性。
</td>
</tr>
<tr>
<td colspan=2>--leader-elect-lease-duration duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：15s</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对于未获得领导者身份的节点，在探测到领导者身份需要更迭时需要等待
此标志所设置的时长，才能尝试去获得曾经是领导者但尚未续约的席位。
本质上，这个时长也是现有领导者节点在被其他候选节点替代之前可以停止
的最长时长。只有集群启用了领导者选举机制时，此标志才起作用。
</td>
</tr>
<tr>
<td colspan=2>--leader-elect-renew-deadline duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：10s</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
当前执行领导者角色的节点在被停止履行领导职责之前可多次尝试续约领导者身份；
此标志给出相邻两次尝试之间的间歇时长。
此值必须小于或等于租期时长（Lease Duration）。
仅在集群启用了领导者选举时有效。
</td>
</tr>
<tr>
<td colspan=2>--leader-elect-resource-lock string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："leases"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
在领导者选举期间用于锁定的资源对象的类型。 支持的选项为 "endpoints"、
"configmaps"、"leases"、"endpointsleases" 和 "configmapsleases"。
</td>
</tr>
<tr>
<td colspan=2>--leader-elect-resource-name string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："kube-controller-manager"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
在领导者选举期间，用来执行锁操作的资源对象名称。
</td>
</tr>
<tr>
<td colspan=2>--leader-elect-resource-namespace string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："kube-system"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
在领导者选举期间，用来执行锁操作的资源对象的名字空间。
</td>
</tr>
<tr>
<td colspan=2>--leader-elect-retry-period duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：2s</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
尝试获得领导者身份时，客户端在相邻两次尝试之间要等待的时长。
此标志仅在启用了领导者选举的集群中起作用。
</td>
</tr>
<tr>
<td colspan=2>--leader-migration-config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>
控制器领导者迁移所用的配置文件路径。
此值为空意味着使用控制器管理器的默认配置。
配置文件应该是 <code>controllermanager.config.k8s.io</code> 组、
<code>v1alpha1</code> 版本的 <code>LeaderMigrationConfiguration</code> 结构。
</p></td>
</tr>
<tr>
<td colspan=2>--log-backtrace-at traceLocation&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：<code>:0</code></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
当执行到 <code>file:N</code> 所给的文件和代码行时，日志机制会生成一个调用栈快照。
</td>
</tr>
<tr>
<td colspan=2>--log-dir string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
此标志为非空字符串时，日志文件会写入到所给的目录中。
</td>
</tr>
<tr>
<td colspan=2>--log-file string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
此标志为非空字符串时，意味着日志会写入到所给的文件中。
</td>
</tr>
<tr>
<td colspan=2>--log-file-max-size uint&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：1800</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
定义日志文件大小的上限。单位是兆字节（MB）。
若此值为 0，则不对日志文件尺寸进行约束。
</td>
</tr>
<tr>
<td colspan=2>--log-flush-frequency duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：5s</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
将内存中日志数据清除到日志文件中时，相邻两次清除操作之间最大间隔秒数。
</td>
</tr>
<tr>
<td colspan=2>--logging-format string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："text"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
设置日志格式。允许的格式："text"。
<br>非默认格式不支持以下标志：<code>--add-dir-header</code>、
<code>--alsologtostderr</code>》、<code>--log-backtrace-at</code>、
<code>--log-dir</code>、<code>--log-file</code>、<code>--log-file-max-size</code>、
<code>--logtostderr</code>、<code>--one-output</code>、<code>--skip-headers</code>、
<code>--skip-log-headers</code>、<code>--stderrthreshold</code>、
<code>--vmodule</code>、<code>--log-flush-frequency</code>。
<br>当前非默认选项为 Alpha 阶段，如有更改，恕不另行通知。
</td>
</tr>
<tr>
<td colspan=2>--logtostderr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：true</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
将日志写出到标准错误输出（stderr）而不是写入到日志文件。
</td>
</tr>
<tr>
<td colspan=2>--master string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
Kubernetes API 服务器的地址。此值会覆盖 kubeconfig 文件中所给的地址。
</td>
</tr>
<tr>
<td colspan=2>--max-endpoints-per-slice int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：100</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
每个 EndpointSlice 中可以添加的端点个数上限。每个片段中端点个数越多，
得到的片段个数越少，但是片段的规模会变得更大。默认值为 100。
</td>
</tr>
<tr>
<td colspan=2>--min-resync-period duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：12h0m0s</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
自省程序的重新同步时隔下限。实际时隔长度会在 <code>min-resync-period</code> 和
<code>2 * min-resync-period</code> 之间。
</td>
</tr>
<tr>
<td colspan=2>--mirroring-concurrent-service-endpoint-syncs int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：5</td>
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
EndpointSliceMirroring 控制器将同时执行的服务端点同步操作数。
较大的数量 = 更快的端点切片更新，但 CPU（和网络）负载更多。 默认为 5。
</td>
</tr>
<tr>
<td colspan=2>--mirroring-endpointslice-updates-batch-period duration</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
EndpointSlice 的长度更新了 EndpointSliceMirroring 控制器的批处理周期。
EndpointSlice 更改的处理将延迟此持续时间，
以使它们与潜在的即将进行的更新结合在一起，并减少 EndpointSlice 更新的总数。
较大的数量 = 较高的端点编程延迟，但是生成的端点修订版本数量较少
</td>
</tr>
<tr>
<td colspan=2>--mirroring-max-endpoints-per-subset int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：1000</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
EndpointSliceMirroring 控制器将添加到 EndpointSlice 的最大端点数。
每个分片的端点越多，端点分片越少，但资源越大。
</td>
</tr>
<tr>
<td colspan=2>--namespace-sync-period duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：5m0s</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对名字空间对象进行同步的周期。
</td>
</tr>
<tr>
<td colspan=2>--node-cidr-mask-size int32</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
集群中节点 CIDR 的掩码长度。对 IPv4 而言默认为 24；对 IPv6 而言默认为 64。
</td>
</tr>
<tr>
<td colspan=2>--node-cidr-mask-size-ipv4 int32</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
在双堆栈（同时支持 IPv4 和 IPv6）的集群中，节点 IPV4 CIDR 掩码长度。默认为 24。
</td>
</tr>
<tr>
<td colspan=2>--node-cidr-mask-size-ipv6 int32</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
在双堆栈（同时支持 IPv4 和 IPv6）的集群中，节点 IPv6 CIDR 掩码长度。默认为 64。
</td>
</tr>
<tr>
<td colspan=2>--node-eviction-rate float32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：0.1</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
当某区域变得不健康，节点失效时，每秒钟可以从此标志所设定的节点
个数上删除 Pods。请参阅 <code>--unhealthy-zone-threshold</code>
以了解“健康”的判定标准。这里的区域（zone）在集群并不跨多个区域时
指的是整个集群。
</td>
</tr>
<tr>
<td colspan=2>--node-monitor-grace-period duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：40s</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
在将一个 Node 标记为不健康之前允许其无响应的时长上限。
必须比 kubelet 的 nodeStatusUpdateFrequency 大 N 倍；
这里 N 指的是 kubelet 发送节点状态的重试次数。
</td>
</tr>
<tr>
<td colspan=2>--node-monitor-period duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：5s</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
节点控制器对节点状态进行同步的重复周期。
</td>
</tr>
<tr>
<td colspan=2>--node-startup-grace-period duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：1m0s</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
在节点启动期间，节点可以处于无响应状态；
但超出此标志所设置的时长仍然无响应则该节点被标记为不健康。
</td>
</tr>
<tr>
<td colspan=2>--one-output</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果此标志为 true，则仅将日志写入其自身的严重性级别（而不是同时写入更低的严重性级别中）。
</td>
</tr>
<tr>
<td colspan=2>--permit-address-sharing</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>
如果此标志为 true，则在绑定端口时使用 <code>SO_REUSEADDR</code>。
这就意味着可以同时绑定到 <code>0.0.0.0</code> 和特定的 IP 地址，
并且避免等待内核释放处于 <code>TIME_WAITE</code> 状态的套接字。
</p></td>
</tr>
<tr>
<td colspan=2>--permit-port-sharing</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果为 true，则在绑定端口时将使用 <code>SO_REUSEPORT</code>，
这允许多个实例在同一地址和端口上进行绑定。
</td>
</tr>
<tr>
<td colspan=2>--pod-eviction-timeout duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：5m0s</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
在失效的节点上删除 Pods 时为其预留的宽限期。
</td>
</tr>
<tr>
<td colspan=2>--profiling&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：true</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
通过位于 <code>host:port/debug/pprof/</code> 的 Web 接口启用性能分析。
</td>
</tr>
<tr>
<td colspan=2>--pv-recycler-increment-timeout-nfs int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：30</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
NFS 清洗 Pod 在清洗用过的卷时，根据此标志所设置的秒数，为每清洗 1 GiB 数据
增加对应超时时长，作为 activeDeadlineSeconds。
</td>
</tr>
<tr>
<td colspan=2>--pv-recycler-minimum-timeout-hostpath int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：60</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对于 HostPath 回收器 Pod，设置其 activeDeadlineSeconds 参数下限。
此参数仅用于开发和测试目的，不适合在多节点集群中使用。
</td>
</tr>
<tr>
<td colspan=2>--pv-recycler-minimum-timeout-nfs int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：300</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
NFS 回收器 Pod 要使用的 activeDeadlineSeconds 参数下限。
</td>
</tr>
<tr>
<td colspan=2>--pv-recycler-pod-template-filepath-hostpath string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对 HostPath 持久卷进行回收利用时，用作模版的 Pod 定义文件所在路径。
此标志仅用于开发和测试目的，不适合多节点集群中使用。
</td>
</tr>
<tr>
<td colspan=2>--pv-recycler-pod-template-filepath-nfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对 NFS 卷执行回收利用时，用作模版的 Pod 定义文件所在路径。
</td>
</tr>
<tr>
<td colspan=2>--pv-recycler-timeout-increment-hostpath int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：30</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
HostPath 清洗器 Pod 在清洗对应类型持久卷时，为每 GiB 数据增加此标志所设置的秒数，
作为其 activeDeadlineSeconds 参数。此标志仅用于开发和测试环境，不适合多节点集群环境。
</td>
</tr>
<tr>
<td colspan=2>--pvclaimbinder-sync-period duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：15s</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
持久卷（PV）和持久卷申领（PVC）对象的同步周期。
</td>
</tr>
<tr>
<td colspan=2>--requestheader-allowed-names strings</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
标志值是客户端证书中的 Common Names 列表。其中所列的名称可以通过
<code>--requestheader-username-headers</code> 所设置的 HTTP 头部来提供用户名。
如果此标志值为空表，则被 <code>--requestheader-client-ca-file</code>
中机构所验证过的所有客户端证书都是允许的。
</td>
</tr>
<tr>
<td colspan=2>--requestheader-client-ca-file string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
根证书包文件名。在信任通过 <code>--requestheader-username-headers</code>
所指定的任何用户名之前，要使用这里的证书来检查请求中的客户证书。
警告：一般不要依赖对请求所作的鉴权结果。
</td>
</tr>
<tr>
<td colspan=2>--requestheader-extra-headers-prefix strings&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：<code>"x-remote-extra-"</code></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
要插入的请求头部前缀。建议使用 <code>X-Remote-Exra-</code>。
</td>
</tr>
<tr>
<td colspan=2>--requestheader-group-headers strings&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：<code>"x-remote-group"</code></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
用来检查用户组名的请求头部名称列表。建议使用 <code>X-Remote-Group</code>。
</td>
</tr>
<tr>
<td colspan=2>--requestheader-username-headers strings&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：<code>"x-remote-user"</code></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
用来检查用户名的请求头部名称列表。建议使用 <code>X-Remote-User</code>。
</td>
</tr>
<tr>
<td colspan=2>--resource-quota-sync-period duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：5m0s</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对系统中配额用量信息进行同步的周期。
</td>
</tr>
<tr>
<td colspan=2>--root-ca-file string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果此标志非空，则在服务账号的令牌 Secret 中会包含此根证书机构。
所指定标志值必须是一个合法的 PEM 编码的 CA 证书包。
</td>
</tr>
<tr>
<td colspan=2>--route-reconciliation-period duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：10s</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对云驱动为节点所创建的路由信息进行调解的周期。
</td>
</tr>
<tr>
<td colspan=2>--secondary-node-eviction-rate float32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：0.01</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
当区域不健康，节点失效时，每秒钟从此标志所给的节点个数上删除 Pods。
参见 <code>--unhealthy-zone-threshold</code> 以了解“健康与否”的判定标准。
在只有一个区域的集群中，区域指的是整个集群。如果集群规模小于
<code>--large-cluster-size-threshold</code> 所设置的节点个数时，
此值被隐式地重设为 0。
</td>
</tr>
<tr>
<td colspan=2>--secure-port int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：10257</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
在此端口上提供 HTTPS 身份认证和鉴权操作。若此标志值为 0，则不提供 HTTPS 服务。
</td>
</tr>
<tr>
<td colspan=2>--service-account-private-key-file string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
包含 PEM 编码的 RSA 或 ECDSA 私钥数据的文件名，这些私钥用来对服务账号令牌签名。
</td>
</tr>
<tr>
<td colspan=2>--service-cluster-ip-range string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
集群中 Service 对象的 CIDR 范围。要求 <code>--allocate-node-cidrs</code> 标志为 true。
</td>
</tr>
<tr>
<td colspan=2>--show-hidden-metrics-for-version string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
你希望展示隐藏度量值的上一个版本。只有上一个次版本号有意义，其他值都是不允许的。
字符串格式为 "&lt;major>.&lt;minor>"。例如："1.16"。
此格式的目的是确保你能够有机会注意到下一个版本隐藏了一些额外的度量值，
而不是在更新版本中某些度量值被彻底删除时措手不及。
</td>
</tr>
<tr>
<td colspan=2>--skip-headers</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
若此标志为 true，则在日志消息中避免写入头部前缀信息。
</td>
</tr>
<tr>
<td colspan=2>--skip-log-headers</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
若此标志为 true，则在写入日志文件时避免写入头部信息。
</td>
</tr>
<tr>
<td colspan=2>--stderrthreshold severity&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：2</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
等于或大于此阈值的日志信息会被写入到标准错误输出（stderr）。
</td>
</tr>
<tr>
<td colspan=2>--terminated-pod-gc-threshold int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：12500</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
在已终止 Pods 垃圾收集器删除已终止 Pods 之前，可以保留的已删除
Pods 的个数上限。若此值小于等于 0，则相当于禁止垃圾回收已终止的 Pods。
</td>
</tr>
<tr>
<td colspan=2>--tls-cert-file string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
包含 HTTPS 所用的默认 X509 证书的文件。如果有 CA 证书，会被串接在服务器证书之后。
若启用了 HTTPS 服务且 <code>--tls-cert-file</code> 和 <code>--tls-private-key-file</code>
标志未设置，
则为节点的公开地址生成自签名的证书和密钥，并保存到 <code>--cert-dir</code>
所给的目录中。
</td>
</tr>
<tr>
<td colspan=2>--tls-cipher-suites strings</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
供服务器使用的加密包的逗号分隔列表。若忽略此标志，则使用 Go 语言默认的加密包。<br>
可选值包括：TLS_AES_128_GCM_SHA256、TLS_AES_256_GCM_SHA384、TLS_CHACHA20_POLY1305_SHA256、TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA、TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256、TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA、TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384、TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305、TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256、TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA、TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA、TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256、TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA、TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384、TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305、TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256、TLS_RSA_WITH_3DES_EDE_CBC_SHA、TLS_RSA_WITH_AES_128_CBC_SHA、TLS_RSA_WITH_AES_128_GCM_SHA256、TLS_RSA_WITH_AES_256_CBC_SHA、TLS_RSA_WITH_AES_256_GCM_SHA384.
<br>不安全的值: TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256、TLS_ECDHE_ECDSA_WITH_RC4_128_SHA、TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256、TLS_ECDHE_RSA_WITH_RC4_128_SHA、TLS_RSA_WITH_AES_128_CBC_SHA256、TLS_RSA_WITH_RC4_128_SHA
</td>
</tr>
<tr>
<td colspan=2>--tls-min-version string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
可支持的最低 TLS 版本。可选值包括：
“VersionTLS10”、“VersionTLS11”、“VersionTLS12”、“VersionTLS13”。
</td>
</tr>
<tr>
<td colspan=2>--tls-private-key-file string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
包含与 <code>--tls-cert-file</code> 对应的默认 X509 私钥的文件。
</td>
</tr>
<tr>
<td colspan=2>--tls-sni-cert-key namedCertKey&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：[]</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
X509 证书和私钥文件路径的耦对。作为可选项，可以添加域名模式的列表，
其中每个域名模式都是可以带通配片段前缀的全限定域名（FQDN）。
域名模式也可以使用 IP 地址字符串，不过只有 API 服务器在所给 IP 地址上
对客户端可见时才可以使用 IP 地址。在未提供域名模式时，从证书中提取域名。
如果有非通配方式的匹配，则优先于通配方式的匹配；显式的域名模式优先于提取的域名。
当存在多个密钥/证书耦对时，可以多次使用 <code>--tls-sni-cert-key</code> 标志。
例如：<code>example.crt,example.key</code> 或 <code>foo.crt,foo.key:\*.foo.com,foo.com</code>。
</td>
</tr>
<tr>
<td colspan=2>--unhealthy-zone-threshold float32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：0.55</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
仅当给定区域中处于非就绪状态的节点（最少 3 个）的占比高于此值时，
才将该区域视为不健康。
</td>
</tr>
<tr>
<td colspan=2>--use-service-account-credentials</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
当此标志为 true 时，为每个控制器单独使用服务账号凭据。
</td>
</tr>
<tr>
<td colspan=2>-v, --v int</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
日志级别详细程度取值。
</td>
</tr>
<tr>
<td colspan=2>--version version[=true]</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
打印版本信息之后退出。
</td>
</tr>
<tr>
<td colspan=2>--vmodule &lt;逗号分隔的 'pattern=N' 配置值></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
由逗号分隔的列表，每一项都是 pattern=N 格式，用来执行根据文件过滤的日志行为。
</td>
</tr>
<tr>
<td colspan=2>--volume-host-allow-local-loopback&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：true</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
此标志为 false 时，禁止本地回路 IP 地址和 <code>--volume-host-cidr-denylist</code>
中所指定的 CIDR 范围。
</td>
</tr>
<tr>
<td colspan=2>--volume-host-cidr-denylist strings</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
用逗号分隔的一个 CIDR 范围列表，禁止使用这些地址上的卷插件。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-a727de6cb5a090d5f115f88a8606c438>11.5 - kube-proxy</h1>
<h2 id=synopsis>Synopsis</h2>
<p>Kubernetes 网络代理在每个节点上运行。网络代理反映了每个节点上 Kubernetes API
中定义的服务，并且可以执行简单的 TCP、UDP 和 SCTP 流转发，或者在一组后端进行
循环 TCP、UDP 和 SCTP 转发。
当前可通过 Docker-links-compatible 环境变量找到服务集群 IP 和端口，
这些环境变量指定了服务代理打开的端口。
有一个可选的插件，可以为这些集群 IP 提供集群 DNS。
用户必须使用 apiserver API 创建服务才能配置代理。</p>
<pre><code>kube-proxy [flags]
</code></pre><h2 id=options>Options</h2>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--add-dir-header</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>
若此标志为 true，则将文件目录添加到日志消息的头部。
</p></td>
</tr>
<tr>
<td colspan=2>--alsologtostderr</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>
将日志输出到文件时也输出到标准错误输出（stderr）。
</p></td>
</tr>
<tr>
<td colspan=2>--azure-container-registry-config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>
包含 Azure 容器仓库配置信息的文件的路径。
</p>
</td>
</tr>
<tr>
<td colspan=2>--bind-address 0.0.0.0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：0.0.0.0</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>
代理服务器要使用的 IP 地址（设置为 '0.0.0.0' 表示要使用所有 IPv4 接口；
设置为 '::' 表示使用所有 IPv6 接口）。
</p>
</td>
</tr>
<tr>
<td colspan=2>--bind-address-hard-fail</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>
若此标志为 true，kube-proxy 会将无法绑定端口的失败操作视为致命错误并退出。
</p></td>
</tr>
<tr>
<td colspan=2>--boot-id-file string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/proc/sys/kernel/random/boot_id"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>
用来检查 Boot-ID 的文件名，用逗号隔开。
第一个存在的文件会被使用。
</p></td>
</tr>
<tr>
<td colspan=2>--cleanup</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>
如果为 true，清理 iptables 和 ipvs 规则并退出。
</p>
</td>
</tr>
<tr>
<td colspan=2>--cluster-cidr string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>
集群中 Pod 的 CIDR 范围。配置后，将从该范围之外发送到服务集群 IP
的流量被伪装，从 Pod 发送到外部 LoadBalancer IP 的流量将被重定向
到相应的集群 IP。
</p>
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>
配置文件的路径。
</p>
</td>
</tr>
<tr>
<td colspan=2>--config-sync-period duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：15m0s</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>
来自 apiserver 的配置的刷新频率。必须大于 0。
</p>
</td>
</tr>
<tr>
<td colspan=2>--conntrack-max-per-core int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：32768</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>
每个 CPU 核跟踪的最大 NAT 连接数（0 表示保留当前限制并忽略 conntrack-min 设置）。
</p>
</td>
</tr>
<tr>
<td colspan=2>--conntrack-min int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：131072</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>
无论 <code>conntrack-max-per-core</code> 多少，要分配的 conntrack
条目的最小数量（将 <code>conntrack-max-per-core</code> 设置为 0 即可
保持当前的限制）。
</p>
</td>
</tr>
<tr>
<td colspan=2>--conntrack-tcp-timeout-close-wait duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：1h0m0s
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>
处于 <code>CLOSE_WAIT</code> 状态的 TCP 连接的 NAT 超时。
</p>
</td>
</tr>
<tr>
<td colspan=2>--conntrack-tcp-timeout-established duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：24h0m0s</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>
已建立的 TCP 连接的空闲超时（0 保持当前设置）。
</p>
</td>
</tr>
<tr>
<td colspan=2>--detect-local-mode LocalMode</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>
用于检测本地流量的模式。
</p>
</td>
</tr>
<tr>
<td colspan=2>--feature-gates &lt;逗号分隔的 'key=True|False' 对’></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>
一组键=值（key=value）对，描述了 alpha/experimental 的特征。可选项有：
APIListChunking=true|false (BETA - 默认值=true)<br>
APIPriorityAndFairness=true|false (BETA - 默认值=true)<br>
APIResponseCompression=true|false (BETA - 默认值=true)<br>
APIServerIdentity=true|false (ALPHA - 默认值=false)<br>
APIServerTracing=true|false (ALPHA - 默认值=false)<br>
AllAlpha=true|false (ALPHA - 默认值=false)<br>
AllBeta=true|false (BETA - 默认值=false)<br>
AnyVolumeDataSource=true|false (ALPHA - 默认值=false)<br>
AppArmor=true|false (BETA - 默认值=true)<br>
CPUManager=true|false (BETA - 默认值=true)<br>
CPUManagerPolicyOptions=true|false (ALPHA - 默认值=false)<br>
CSIInlineVolume=true|false (BETA - 默认值=true)<br>
CSIMigration=true|false (BETA - 默认值=true)<br>
CSIMigrationAWS=true|false (BETA - 默认值=false)<br>
CSIMigrationAzureDisk=true|false (BETA - 默认值=false)<br>
CSIMigrationAzureFile=true|false (BETA - 默认值=false)<br>
CSIMigrationGCE=true|false (BETA - 默认值=false)<br>
CSIMigrationOpenStack=true|false (BETA - 默认值=true)<br>
CSIMigrationvSphere=true|false (BETA - 默认值=false)<br>
CSIStorageCapacity=true|false (BETA - 默认值=true)<br>
CSIVolumeFSGroupPolicy=true|false (BETA - 默认值=true)<br>
CSIVolumeHealth=true|false (ALPHA - 默认值=false)<br>
CSRDuration=true|false (BETA - 默认值=true)<br>
ConfigurableFSGroupPolicy=true|false (BETA - 默认值=true)<br>
ControllerManagerLeaderMigration=true|false (BETA - 默认值=true)<br>
CustomCPUCFSQuotaPeriod=true|false (ALPHA - 默认值=false)<br>
DaemonSetUpdateSurge=true|false (BETA - 默认值=true)<br>
DefaultPodTopologySpread=true|false (BETA - 默认值=true)<br>
DelegateFSGroupToCSIDriver=true|false (ALPHA - 默认值=false)<br>
DevicePlugins=true|false (BETA - 默认值=true)<br>
DisableAcceleratorUsageMetrics=true|false (BETA - 默认值=true)<br>
DisableCloudProviders=true|false (ALPHA - 默认值=false)<br>
DownwardAPIHugePages=true|false (BETA - 默认值=false)<br>
EfficientWatchResumption=true|false (BETA - 默认值=true)<br>
EndpointSliceTerminatingCondition=true|false (BETA - 默认值=true)<br>
EphemeralContainers=true|false (ALPHA - 默认值=false)<br>
ExpandCSIVolumes=true|false (BETA - 默认值=true)<br>
ExpandInUsePersistentVolumes=true|false (BETA - 默认值=true)<br>
ExpandPersistentVolumes=true|false (BETA - 默认值=true)<br>
ExpandedDNSConfig=true|false (ALPHA - 默认值=false)<br>
ExperimentalHostUserNamespaceDefaulting=true|false (BETA - 默认值=false)<br>
GenericEphemeralVolume=true|false (BETA - 默认值=true)<br>
GracefulNodeShutdown=true|false (BETA - 默认值=true)<br>
HPAContainerMetrics=true|false (ALPHA - 默认值=false)<br>
HPAScaleToZero=true|false (ALPHA - 默认值=false)<br>
IPv6DualStack=true|false (BETA - 默认值=true)<br>
InTreePluginAWSUnregister=true|false (ALPHA - 默认值=false)<br>
InTreePluginAzureDiskUnregister=true|false (ALPHA - 默认值=false)<br>
InTreePluginAzureFileUnregister=true|false (ALPHA - 默认值=false)<br>
InTreePluginGCEUnregister=true|false (ALPHA - 默认值=false)<br>
InTreePluginOpenStackUnregister=true|false (ALPHA - 默认值=false)<br>
InTreePluginvSphereUnregister=true|false (ALPHA - 默认值=false)<br>
IndexedJob=true|false (BETA - 默认值=true)<br>
IngressClassNamespacedParams=true|false (BETA - 默认值=true)<br>
JobTrackingWithFinalizers=true|false (ALPHA - 默认值=false)<br>
KubeletCredentialProviders=true|false (ALPHA - 默认值=false)<br>
KubeletInUserNamespace=true|false (ALPHA - 默认值=false)<br>
KubeletPodResources=true|false (BETA - 默认值=true)<br>
KubeletPodResourcesGetAllocatable=true|false (ALPHA - 默认值=false)<br>
LocalStorageCapacityIsolation=true|false (BETA - 默认值=true)<br>
LocalStorageCapacityIsolationFSQuotaMonitoring=true|false (ALPHA - 默认值=false)<br>
LogarithmicScaleDown=true|false (BETA - 默认值=true)<br>
MemoryManager=true|false (BETA - 默认值=true)<br>
MemoryQoS=true|false (ALPHA - 默认值=false)<br>
MixedProtocolLBService=true|false (ALPHA - 默认值=false)<br>
NetworkPolicyEndPort=true|false (BETA - 默认值=true)<br>
NodeSwap=true|false (ALPHA - 默认值=false)<br>
NonPreemptingPriority=true|false (BETA - 默认值=true)<br>
PodAffinityNamespaceSelector=true|false (BETA - 默认值=true)<br>
PodDeletionCost=true|false (BETA - 默认值=true)<br>
PodOverhead=true|false (BETA - 默认值=true)<br>
PodSecurity=true|false (ALPHA - 默认值=false)<br>
PreferNominatedNode=true|false (BETA - 默认值=true)<br>
ProbeTerminationGracePeriod=true|false (BETA - 默认值=false)<br>
ProcMountType=true|false (ALPHA - 默认值=false)<br>
ProxyTerminatingEndpoints=true|false (ALPHA - 默认值=false)<br>
QOSReserved=true|false (ALPHA - 默认值=false)<br>
ReadWriteOncePod=true|false (ALPHA - 默认值=false)<br>
RemainingItemCount=true|false (BETA - 默认值=true)<br>
RemoveSelfLink=true|false (BETA - 默认值=true)<br>
RotateKubeletServerCertificate=true|false (BETA - 默认值=true)<br>
SeccompDefault=true|false (ALPHA - 默认值=false)<br>
ServiceInternalTrafficPolicy=true|false (BETA - 默认值=true)<br>
ServiceLBNodePortControl=true|false (BETA - 默认值=true)<br>
ServiceLoadBalancerClass=true|false (BETA - 默认值=true)<br>
SizeMemoryBackedVolumes=true|false (BETA - 默认值=true)<br>
StatefulSetMinReadySeconds=true|false (ALPHA - 默认值=false)<br>
StorageVersionAPI=true|false (ALPHA - 默认值=false)<br>
StorageVersionHash=true|false (BETA - 默认值=true)<br>
SuspendJob=true|false (BETA - 默认值=true)<br>
TTLAfterFinished=true|false (BETA - 默认值=true)<br>
TopologyAwareHints=true|false (ALPHA - 默认值=false)<br>
TopologyManager=true|false (BETA - 默认值=true)<br>
VolumeCapacityPriority=true|false (ALPHA - 默认值=false)<br>
WinDSR=true|false (ALPHA - 默认值=false)<br>
WinOverlay=true|false (BETA - 默认值=true)<br>
WindowsHostProcessContainers=true|false (ALPHA - 默认值=false)
</p>
</td>
</tr>
<tr>
<td colspan=2>--healthz-bind-address 0.0.0.0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：<code>0.0.0.0:10256</code></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>
服务健康状态检查的 IP 地址和端口（设置为 '0.0.0.0:10256' 表示使用所有
IPv4 接口，设置为 '[::]:10256' 表示使用所有 IPv6 接口）；
设置为空则禁用。
</p>
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>
kube-proxy 操作的帮助命令。
</p>
</td>
</tr>
<tr>
<td colspan=2>--hostname-override string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>
如果非空，将使用此字符串而不是实际的主机名作为标识。
</p>
</td>
</tr>
<tr>
<td colspan=2>--iptables-masquerade-bit int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：14</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>
在使用纯 iptables 代理时，用来设置 fwmark 空间的 bit，标记需要
SNAT 的数据包。必须在 [0,31] 范围内。
</p>
</td>
</tr>
<tr>
<td colspan=2>--iptables-min-sync-period duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：1s</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>
iptables 规则可以随着端点和服务的更改而刷新的最小间隔（例如 '5s'、'1m'、'2h22m'）。
</p>
</td>
</tr>
<tr>
<td colspan=2>--iptables-sync-period duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：30s</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>
刷新 iptables 规则的最大间隔（例如 '5s'、'1m'、'2h22m'）。必须大于 0。
</p>
</td>
</tr>
<tr>
<td colspan=2>--ipvs-exclude-cidrs strings</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>
逗号分隔的 CIDR 列表，ipvs 代理在清理 IPVS 规则时不会此列表中的地址范围。
</p>
</td>
</tr>
<tr>
<td colspan=2>--ipvs-min-sync-period duration</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>
ipvs 规则可以随着端点和服务的更改而刷新的最小间隔（例如 '5s'、'1m'、'2h22m'）。
</p>
</td>
</tr>
<tr>
<td colspan=2>--ipvs-scheduler string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>
代理模式为 ipvs 时所选的 ipvs 调度器类型。
</p>
</td>
</tr>
<tr>
<td colspan=2>--ipvs-strict-arp</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>
通过将 <code>arp_ignore</code> 设置为 1 并将 <code>arp_announce</code>
设置为 2 启用严格的 ARP。
</p>
</td>
</tr>
<tr>
<td colspan=2>--ipvs-sync-period duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：30s</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>
刷新 ipvs 规则的最大间隔（例如 '5s'、'1m'、'2h22m'）。必须大于 0。
</p>
</td>
</tr>
<tr>
<td colspan=2>--ipvs-tcp-timeout duration</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>
空闲 IPVS TCP 连接的超时时间，0 保持连接（例如 '5s'、'1m'、'2h22m'）。
</p>
</td>
</tr>
<tr>
<td colspan=2>--ipvs-tcpfin-timeout duration</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>
收到 FIN 数据包后，IPVS TCP 连接的超时，0 保持当前设置不变。（例如 '5s'、'1m'、'2h22m'）。
</p>
</td>
</tr>
<tr>
<td colspan=2>--ipvs-udp-timeout duration</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>
IPVS UDP 数据包的超时，0 保持当前设置不变。（例如 '5s'、'1m'、'2h22m'）。
</p>
</td>
</tr>
<tr>
<td colspan=2>--kube-api-burst int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：10</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>
与 kubernetes apiserver 通信的突发数量。
</p>
</td>
</tr>
<tr>
<td colspan=2>--kube-api-content-type string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："application/vnd.kubernetes.protobuf"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>
发送到 apiserver 的请求的内容类型。
</p>
</td>
</tr>
<tr>
<td colspan=2>--kube-api-qps float32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：5</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>
与 kubernetes apiserver 交互时使用的 QPS。
</p>
</td>
</tr>
<tr>
<td colspan=2>--kubeconfig string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>
包含鉴权信息的 kubeconfig 文件的路径（主控节点位置由 master 标志设置）。
</p>
</td>
</tr>
<tr>
<td colspan=2>--log-backtrace-at &lt;形式为 'file:N' 的字符串>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: :0</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>
当日志逻辑执行到文件 file 的第 N 行时，输出调用堆栈跟踪。
</p></td>
</tr>
<tr>
<td colspan=2>--log-dir string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>
若此标志费控，则将日志文件写入到此标志所给的目录下。
</p>
</td>
</tr>
<tr>
<td colspan=2>--log-file string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>
若此标志非空，则该字符串作为日志文件名。
</p></td>
</tr>
<tr>
<td colspan=2>--log-file-max-size uint&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：1800</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>
定义日志文件可增长到的最大尺寸。单位是兆字节（MB）。
如果此值为 0，则最大文件大小无限制。
</p></td>
</tr>
<tr>
<td colspan=2>--log-flush-frequency duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：5s
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
两次日志刷新之间的最大秒数。
</td>
</tr>
<tr>
<td colspan=2>--machine-id-file string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/machine-id,/var/lib/dbus/machine-id"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>
用来检查 Machine-ID 的文件列表，用逗号分隔。
使用找到的第一个文件。
</p></td>
</tr>
<tr>
<td colspan=2>--masquerade-all</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>
如果使用纯 iptables 代理，则对通过服务集群 IP 发送的所有流量
进行 SNAT（通常不需要）。
</p>
</td>
</tr>
<tr>
<td colspan=2>--master string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>
Kubernetes API 服务器的地址（覆盖 kubeconfig 中的相关值）。
</p>
</td>
</tr>
<tr>
<td colspan=2>--metrics-bind-address ipport&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：<code>127.0.0.1:10249</code></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>
metrics 服务器要使用的 IP 地址和端口
（设置为 '0.0.0.0:10249' 则使用所有 IPv4 接口，设置为 '[::]:10249' 则使用所有 IPv6 接口）
设置为空则禁用。
</p>
</td>
</tr>
<tr>
<td colspan=2>--nodeport-addresses strings</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>
一个字符串值，指定用于 NodePort 服务的地址。
值可以是有效的 IP 块（例如 1.2.3.0/24, 1.2.3.4/32）。
默认的空字符串切片（[]）表示使用所有本地地址。
</p>
</td>
</tr>
<tr>
<td colspan=2>--one-output</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>
若此标志为 true，则仅将日志写入到其原本的严重性级别之下
（而不是将其写入到所有更低严重性级别中）。
</p></td>
</tr>
<tr>
<td colspan=2>--oom-score-adj int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：-999</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>
kube-proxy 进程中的 oom-score-adj 值，必须在 [-1000,1000] 范围内。
</p>
</td>
</tr>
<tr>
<td colspan=2>--profiling</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>
如果为 true，则通过 Web 接口 <code>/debug/pprof</code> 启用性能分析。
</p>
</td>
</tr>
<tr>
<td colspan=2>--proxy-mode string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>
使用哪种代理模式：'userspace'（较旧）或 'iptables'（较快）或 'ipvs'。
如果为空，使用最佳可用代理（当前为 iptables）。
如果选择了 iptables 代理（无论是否为显式设置），但系统的内核或
iptables 版本较低，总是会回退到 userspace 代理。
</p>
</td>
</tr>
<tr>
<td colspan=2>--proxy-port-range port-range</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>
可以用来代理服务流量的主机端口范围（包括'起始端口-结束端口'、
'单个端口'、'起始端口+偏移'几种形式）。
如果未指定或者设置为 0（或 0-0），则随机选择端口。
</p>
</td>
</tr>
<tr>
<td colspan=2>--show-hidden-metrics-for-version string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>
要显示隐藏指标的先前版本。
仅先前的次要版本有意义，不允许其他值。
格式为 &lt;major>.&lt;minor> ，例如：'1.16'。
这种格式的目的是确保你有机会注意到下一个发行版是否隐藏了其他指标，
而不是在之后将其永久删除时感到惊讶。
</p>
</td>
</tr>
<tr>
<td colspan=2>--skip-headers</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>
若此标志为 true，则避免在日志消息中包含头部前缀。
</p></td>
</tr>
<tr>
<td colspan=2>--skip-log-headers</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>
如果此标志为 true，则避免在打开日志文件时使用头部。
</p></td>
</tr>
<tr>
<td colspan=2>--stderrthreshold int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：2</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>
如果日志消息处于或者高于此阈值所设置的级别，则将其输出到标准错误输出（stderr）。
</p></td>
</tr>
<tr>
<td colspan=2>--udp-timeout duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：250ms</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>
空闲 UDP 连接将保持打开的时长（例如 '250ms'，'2s'）。必须大于 0。
仅适用于 proxy-mode=userspace。
</p>
</td>
</tr>
<tr>
<td colspan=2>-v, --v int</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>
用来设置日志详细程度的数值。
</p></td>
</tr>
<tr>
<td colspan=2>--version version[=true]</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>
打印版本信息并退出。
</p>
</td>
</tr>
<tr>
<td colspan=2>--vmodule &lt;逗号分隔的 'pattern=N' 设置’></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>
用逗号分隔的列表，其中每一项为 'pattern=N' 格式。
用来支持基于文件过滤的日志机制。
</p></td>
</tr>
<tr>
<td colspan=2>--write-config-to string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>
如果设置，将默认配置信息写入此文件并退出。
</p>
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-57e59e5ddd9db63da6c9d27cc0e2f254>11.6 - kube-scheduler</h1>
<h2 id=synopsis>Synopsis</h2>
<p>Kubernetes 调度器是一个控制面进程，负责将 Pods 指派到节点上。
调度器基于约束和可用资源为调度队列中每个 Pod 确定其可合法放置的节点。
调度器之后对所有合法的节点进行排序，将 Pod 绑定到一个合适的节点。
在同一个集群中可以使用多个不同的调度器；kube-scheduler 是其参考实现。
参阅<a href=/zh/docs/concepts/scheduling-eviction/>调度</a>
以获得关于调度和 kube-scheduler 组件的更多信息。</p>
<pre><code>kube-scheduler [flags]
</code></pre><h2 id=options>Options</h2>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--add-dir-header</td>
</tr>
<tr><td></td><td style=line-height:130%;word-wrap:break-word>
如果为 true，则将文件目录添加到日志消息的头部
</td>
</tr>
<tr><td colspan=2>--address string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："0.0.0.0"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
已弃用： 要监听 --port 端口的 IP 地址（将其设置为 0.0.0.0 或者 :: 用于监听所有接口和 IP族）。
请参阅 --bind-address。
如果在 --config 中指定了一个配置文件，这个参数将被忽略。
</td>
</tr>
<tr>
<td colspan=2>--algorithm-provider string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
已弃用： 要使用的调度算法驱动，此标志设置组件配置框架的默认插件。
可选值：ClusterAutoscalerProvider | DefaultProvider
</td>
</tr>
<tr>
<td colspan=2>--allow-metric-labels stringToString&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
默认值： []</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
这个键值映射表设置 度量标签 所允许设置的值。
其中键的格式是 &lt;MetricName>,&lt;LabelName>。
值的格式是 &lt;allowed_value>,&lt;allowed_value>。
例如：metric1,label1='v1,v2,v3', metric1,label2='v1,v2,v3' metric2,label1='v1,v2,v3'。
</td>
</tr>
<tr>
<td colspan=2>--alsologtostderr</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
日志记录到标准错误以及文件
</td>
</tr>
<tr>
<td colspan=2>--authentication-kubeconfig string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指向具有足够权限以创建 <code>tokenaccessreviews.authentication.k8s.io</code> 的
Kubernetes 核心服务器的 kubeconfig 文件。
这是可选的。如果为空，则所有令牌请求均被视为匿名请求，并且不会在集群中查找任何客户端 CA。
</td>
</tr>
<tr>
<td colspan=2>--authentication-skip-lookup</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果为 false，则 authentication-kubeconfig 将用于从集群中查找缺少的身份验证配置。
</td>
</tr>
<tr>
<td colspan=2>--authentication-token-webhook-cache-ttl duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：10s</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
缓存来自 Webhook 令牌身份验证器的响应的持续时间。
</td>
</tr>
<tr>
<td colspan=2>--authentication-tolerate-lookup-failure&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：true</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果为 true，则无法从集群中查找缺少的身份验证配置是致命的。
请注意，这可能导致身份验证将所有请求视为匿名。
</td>
</tr>
<tr>
<td colspan=2>--authorization-always-allow-paths strings&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/healthz,/readyz,/livez"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
在授权过程中跳过的 HTTP 路径列表，即在不联系 'core' kubernetes 服务器的情况下被授权的 HTTP 路径。
</td>
</tr>
<tr>
<td colspan=2>--authorization-kubeconfig string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指向具有足够权限以创建 subjectaccessreviews.authorization.k8s.io 的
Kubernetes 核心服务器的 kubeconfig 文件。这是可选的。
如果为空，则所有未被鉴权机制略过的请求都会被禁止。
</td>
</tr>
<tr>
<td colspan=2>--authorization-webhook-cache-authorized-ttl duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：10s</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
缓存来自 Webhook 授权者的 'authorized' 响应的持续时间。
</td>
</tr>
<tr>
<td colspan=2>--authorization-webhook-cache-unauthorized-ttl duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：10s</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
缓存来自 Webhook 授权者的 'unauthorized' 响应的持续时间。
</td>
</tr>
<tr>
<td colspan=2>--azure-container-registry-config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
包含 Azure 容器仓库配置信息的文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--bind-address string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：0.0.0.0</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
监听 --secure-port 端口的 IP 地址。
集群的其余部分以及 CLI/ Web 客户端必须可以访问关联的接口。
如果为空，将使用所有接口（0.0.0.0 表示使用所有 IPv4 接口，"::" 表示使用所有 IPv6 接口）。
如果为空或未指定地址 (0.0.0.0 或 ::)，所有接口将被使用。
</td>
</tr>
<tr>
<td colspan=2>--cert-dir string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
TLS 证书所在的目录。如果提供了--tls-cert-file 和 --tls private-key-file，
则将忽略此参数。
</td>
</tr>
<tr>
<td colspan=2>--client-ca-file string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果已设置，由 client-ca-file 中的证书机构签名的客户端证书的任何请求都将使用
与客户端证书的 CommonName 对应的身份进行身份验证。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
配置文件的路径。以下标志会覆盖此文件中的值：<br>
--algorithm-provider<br>
--policy-config-file<br>
--policy-configmap<br>
--policy-configmap-namespace
</td>
</tr>
<tr>
<td colspan=2>--contention-profiling&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值: true</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
已弃用: 如果启用了性能分析，则启用锁竞争分析。
如果 --config 指定了一个配置文件，那么这个参数将被忽略。
</td>
</tr>
<tr>
<td colspan=2>--disabled-metrics strings</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
这个标志提供了一个规避不良指标的选项。你必须提供完整的指标名称才能禁用它。
免责声明：禁用指标的优先级比显示隐藏的指标更高。
</td>
</tr>
<tr>
<td colspan=2>--experimental-logging-sanitization</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[试验性功能] 当启用此标志时，标记为敏感的字段（密码、密钥、令牌）等不会被日志
输出。<br>
运行时的日志清理操作可能引入相当程度的计算开销，因此不应在生产环境中启用。
</td>
</tr>
<tr>
<td colspan=2>--feature-gates &lt;逗号分隔的 'key=True|False' 对></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
一组 key=value 对，描述了 alpha/experimental 特征开关。选项包括：<br>
A set of key=value pairs that describe feature gates for alpha/experimental features. Options are:<br>
APIListChunking=true|false (BETA - 默认值=true)<br>
APIPriorityAndFairness=true|false (BETA - 默认值=true)<br>
APIResponseCompression=true|false (BETA - 默认值=true)<br>
APIServerIdentity=true|false (ALPHA - 默认值=false)<br>
AllAlpha=true|false (ALPHA - 默认值=false)<br>
AllBeta=true|false (BETA - 默认值=false)<br>
AnyVolumeDataSource=true|false (ALPHA - 默认值=false)<br>
AppArmor=true|false (BETA - 默认值=true)<br>
BalanceAttachedNodeVolumes=true|false (ALPHA - 默认值=false)<br>
BoundServiceAccountTokenVolume=true|false (BETA - 默认值=true)<br>
CPUManager=true|false (BETA - 默认值=true)<br>
CSIInlineVolume=true|false (BETA - 默认值=true)<br>
CSIMigration=true|false (BETA - 默认值=true)<br>
CSIMigrationAWS=true|false (BETA - 默认值=false)<br>
CSIMigrationAzureDisk=true|false (BETA - 默认值=false)<br>
CSIMigrationAzureFile=true|false (BETA - 默认值=false)<br>
CSIMigrationGCE=true|false (BETA - 默认值=false)<br>
CSIMigrationOpenStack=true|false (BETA - 默认值=true)<br>
CSIMigrationvSphere=true|false (BETA - 默认值=false)<br>
CSIMigrationvSphereComplete=true|false (BETA - 默认值=false)<br>
CSIServiceAccountToken=true|false (BETA - 默认值=true)<br>
CSIStorageCapacity=true|false (BETA - 默认值=true)<br>
CSIVolumeFSGroupPolicy=true|false (BETA - 默认值=true)<br>
CSIVolumeHealth=true|false (ALPHA - 默认值=false)<br>
ConfigurableFSGroupPolicy=true|false (BETA - 默认值=true)<br>
ControllerManagerLeaderMigration=true|false (ALPHA - 默认值=false)<br>
CronJobControllerV2=true|false (BETA - 默认值=true)<br>
CustomCPUCFSQuotaPeriod=true|false (ALPHA - 默认值=false)<br>
DaemonSetUpdateSurge=true|false (ALPHA - 默认值=false)<br>
DefaultPodTopologySpread=true|false (BETA - 默认值=true)<br>
DevicePlugins=true|false (BETA - 默认值=true)<br>
DisableAcceleratorUsageMetrics=true|false (BETA - 默认值=true)<br>
DownwardAPIHugePages=true|false (BETA - 默认值=false)<br>
DynamicKubeletConfig=true|false (BETA - 默认值=true)<br>
EfficientWatchResumption=true|false (BETA - 默认值=true)<br>
EndpointSliceProxying=true|false (BETA - 默认值=true)<br>
EndpointSliceTerminatingCondition=true|false (ALPHA - 默认值=false)<br>
EphemeralContainers=true|false (ALPHA - 默认值=false)<br>
ExpandCSIVolumes=true|false (BETA - 默认值=true)<br>
ExpandInUsePersistentVolumes=true|false (BETA - 默认值=true)<br>
ExpandPersistentVolumes=true|false (BETA - 默认值=true)<br>
ExperimentalHostUserNamespaceDefaulting=true|false (BETA - 默认值=false)<br>
GenericEphemeralVolume=true|false (BETA - 默认值=true)<br>
GracefulNodeShutdown=true|false (BETA - 默认值=true)<br>
HPAContainerMetrics=true|false (ALPHA - 默认值=false)<br>
HPAScaleToZero=true|false (ALPHA - 默认值=false)<br>
HugePageStorageMediumSize=true|false (BETA - 默认值=true)<br>
IPv6DualStack=true|false (BETA - 默认值=true)<br>
InTreePluginAWSUnregister=true|false (ALPHA - 默认值=false)<br>
InTreePluginAzureDiskUnregister=true|false (ALPHA - 默认值=false)<br>
InTreePluginAzureFileUnregister=true|false (ALPHA - 默认值=false)<br>
InTreePluginGCEUnregister=true|false (ALPHA - 默认值=false)<br>
InTreePluginOpenStackUnregister=true|false (ALPHA - 默认值=false)<br>
InTreePluginvSphereUnregister=true|false (ALPHA - 默认值=false)<br>
IndexedJob=true|false (ALPHA - 默认值=false)<br>
IngressClassNamespacedParams=true|false (ALPHA - 默认值=false)<br>
KubeletCredentialProviders=true|false (ALPHA - 默认值=false)<br>
KubeletPodResources=true|false (BETA - 默认值=true)<br>
KubeletPodResourcesGetAllocatable=true|false (ALPHA - 默认值=false)<br>
LocalStorageCapacityIsolation=true|false (BETA - 默认值=true)<br>
LocalStorageCapacityIsolationFSQuotaMonitoring=true|false (ALPHA - 默认值=false)<br>
LogarithmicScaleDown=true|false (ALPHA - 默认值=false)<br>
MemoryManager=true|false (ALPHA - 默认值=false)<br>
MixedProtocolLBService=true|false (ALPHA - 默认值=false)<br>
NamespaceDefaultLabelName=true|false (BETA - 默认值=true)<br>
NetworkPolicyEndPort=true|false (ALPHA - 默认值=false)<br>
NonPreemptingPriority=true|false (BETA - 默认值=true)<br>
PodAffinityNamespaceSelector=true|false (ALPHA - 默认值=false)<br>
PodDeletionCost=true|false (ALPHA - 默认值=false)<br>
PodOverhead=true|false (BETA - 默认值=true)<br>
PreferNominatedNode=true|false (ALPHA - 默认值=false)<br>
ProbeTerminationGracePeriod=true|false (ALPHA - 默认值=false)<br>
ProcMountType=true|false (ALPHA - 默认值=false)<br>
QOSReserved=true|false (ALPHA - 默认值=false)<br>
RemainingItemCount=true|false (BETA - 默认值=true)<br>
RemoveSelfLink=true|false (BETA - 默认值=true)<br>
RotateKubeletServerCertificate=true|false (BETA - 默认值=true)<br>
ServerSideApply=true|false (BETA - 默认值=true)<br>
ServiceInternalTrafficPolicy=true|false (ALPHA - 默认值=false)<br>
ServiceLBNodePortControl=true|false (ALPHA - 默认值=false)<br>
ServiceLoadBalancerClass=true|false (ALPHA - 默认值=false)<br>
ServiceTopology=true|false (ALPHA - 默认值=false)<br>
SetHostnameAsFQDN=true|false (BETA - 默认值=true)<br>
SizeMemoryBackedVolumes=true|false (ALPHA - 默认值=false)<br>
StorageVersionAPI=true|false (ALPHA - 默认值=false)<br>
StorageVersionHash=true|false (BETA - 默认值=true)<br>
SuspendJob=true|false (ALPHA - 默认值=false)<br>
TTLAfterFinished=true|false (BETA - 默认值=true)<br>
TopologyAwareHints=true|false (ALPHA - 默认值=false)<br>
TopologyManager=true|false (BETA - 默认值=true)<br>
ValidateProxyRedirects=true|false (BETA - 默认值=true)<br>
VolumeCapacityPriority=true|false (ALPHA - 默认值=false)<br>
WarningHeaders=true|false (BETA - 默认值=true)<br>
WinDSR=true|false (ALPHA - 默认值=false)<br>
WinOverlay=true|false (BETA - 默认值=true)<br>
WindowsEndpointSliceProxying=true|false (BETA - 默认值=true)
</td>
</tr>
<tr>
<td colspan=2>--hard-pod-affinity-symmetric-weight int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：1</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
已弃用: RequiredDuringScheduling 亲和性是不对称的，但是存在与每个
RequiredDuringScheduling 关联性规则相对应的隐式 PreferredDuringScheduling 关联性规则。
<code>--hard-pod-affinity-symmetric-weight</code> 代表隐式 PreferredDuringScheduling
关联性规则的权重。权重必须在 0-100 范围内。
如果 --config 指定了一个配置文件，那么这个参数将被忽略。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kube-scheduler 帮助命令
</td>
</tr>
<tr>
<td colspan=2>--http2-max-streams-per-connection int</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
服务器为客户端提供的 HTTP/2 连接最大限制。零表示使用 Golang 的默认值。
</td>
</tr>
<tr>
<td colspan=2>--kube-api-burst int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：100</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
已弃用: 与 kubernetes API 通信时使用的突发请求个数限值。
如果 --config 指定了一个配置文件，那么这个参数将被忽略。
</td>
</tr>
<tr>
<td colspan=2>--kube-api-content-type string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："application/vnd.kubernetes.protobuf"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
已弃用: 发送到 API 服务器的请求的内容类型。
如果 --config 指定了一个配置文件，那么这个参数将被忽略。
</td>
</tr>
<tr>
<td colspan=2>--kube-api-qps float32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：50</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
已弃用: 与 kubernetes apiserver 通信时要使用的 QPS
如果 --config 指定了一个配置文件，那么这个参数将被忽略。
</td>
</tr>
<tr>
<td colspan=2>--kubeconfig string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
已弃用: 包含鉴权和主节点位置信息的 kubeconfig 文件的路径。
如果 --config 指定了一个配置文件，那么这个参数将被忽略。
</td>
</tr>
<tr>
<td colspan=2>--leader-elect&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：true</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
在执行主循环之前，开始领导者选举并选出领导者。
使用多副本来实现高可用性时，可启用此标志。
</td>
</tr>
<tr>
<td colspan=2>--leader-elect-lease-duration duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：15s</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
非领导者候选人在观察到领导者更新后将等待直到试图获得领导但未更新的领导者职位的等待时间。
这实际上是领导者在被另一位候选人替代之前可以停止的最大持续时间。
该情况仅在启用了领导者选举的情况下才适用。
</td>
</tr>
<tr>
<td colspan=2>--leader-elect-renew-deadline duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：10s</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
领导者尝试在停止领导之前更新领导职位的间隔时间。该时间必须小于或等于租赁期限。
仅在启用了领导者选举的情况下才适用。
</td>
</tr>
<tr>
<td colspan=2>--leader-elect-resource-lock string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："leases"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
在领导者选举期间用于锁定的资源对象的类型。支持的选项是 `endpoints`、
`configmaps`、`leases`、`endpointleases` 和 `configmapsleases`。
</td>
</tr>
<tr>
<td colspan=2>--leader-elect-resource-name string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："kube-scheduler"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
在领导者选举期间用于锁定的资源对象的名称。
</td>
</tr>
<tr>
<td colspan=2>--leader-elect-resource-namespace string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："kube-system"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
在领导者选举期间用于锁定的资源对象的命名空间。
</td>
</tr>
<tr>
<td colspan=2>--leader-elect-retry-period duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：2s
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
客户应在尝试获取和更新领导之间等待的时间。仅在启用了领导者选举的情况下才适用。
</td>
</tr>
<tr>
<td colspan=2>--lock-object-name string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："kube-scheduler"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
已弃用: 定义锁对象的名称。将被删除以便使用 <code>--leader-elect-resource-name</code>。
如果 --config 指定了一个配置文件，那么这个参数将被忽略。
</td>
</tr>
<tr>
<td colspan=2>--lock-object-namespace string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："kube-system"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
已弃用: 定义锁对象的命名空间。将被删除以便使用 <code>leader-elect-resource-namespace</code>。
如果 --config 指定了一个配置文件，那么这个参数将被忽略。
</td>
</tr>
<tr>
<td colspan=2>--log-backtrace-at &lt;a string in the form 'file:N'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
默认值: 0</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
当记录命中行文件 <code>file</code> 的第 <code>N</code> 行时输出堆栈跟踪。
</td>
</tr>
<tr>
<td colspan=2>--log-dir string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果为非空，则在此目录中写入日志文件。
</td>
</tr>
<tr>
<td colspan=2>--log-file string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果为非空，则使用此文件作为日志文件。
</td>
</tr>
<tr>
<td colspan=2>--log-file-max-size uint&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：1800</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
定义日志文件可以增长到的最大值。单位为兆字节。
如果值为 0，则最大文件大小为无限制。
</td>
</tr>
<tr>
<td colspan=2>--log-flush-frequency duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：5s</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
两次日志刷新之间的最大秒数。
</td>
</tr>
<tr>
<td colspan=2>--logging-format string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：“text”</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
设置日志格式。可选格式：“json”，“text”。<br>
采用非默认格式时，以下标识不会生效：
--add-dir-header, --alsologtostderr, --log-backtrace-at,
--log-dir, --log-file, --log-file-max-size,
--logtostderr, --one-output, --skip-headers, --skip-log-headers,
--stderrthreshold, --vmodule, --log-flush-frequency.<br>
非默认选项目前处于 Alpha 阶段，有可能会出现变更且无事先警告。
</td>
</tr>
<tr>
<td colspan=2>--logtostderr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：true</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
日志记录到标准错误输出而不是文件。
</td>
</tr>
<tr>
<td colspan=2>--master string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
Kubernetes API 服务器的地址（覆盖 kubeconfig 中的任何值）。
</td>
</tr>
<tr>
<td colspan=2>--one-output</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
若此标志为 true，则日志仅写入其自身的严重性级别，而不会写入所有较低严重性级别。
</td>
</tr>
<tr>
<td colspan=2>--permit-address-sharing</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果为 true，在绑定端口时将使用 SO_REUSEADDR。
这将允许同时绑定诸如 0.0.0.0 这类通配符 IP和特定 IP，
并且它避免等待内核释放处于 TIME_WAIT 状态的套接字。
默认值： false
</td>
</tr>
<tr>
<td colspan=2>--permit-port-sharing</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果此标志为 true，在绑定端口时会使用 SO_REUSEPORT，从而允许不止一个
实例绑定到同一地址和端口。
默认值：false
</td>
</tr>
<tr>
<td colspan=2>--policy-config-file string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
已弃用：包含调度器策略配置的文件。
当策略 ConfigMap 为提供时，或者 <code>--use-legacy-policy-config=true</code> 时使用此文件。
注意：当此标志与插件配置一起使用时，调度器会失败。
</td>
</tr>
<tr>
<td colspan=2>--policy-configmap string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
已弃用: 包含调度器策略配置的 ConfigMap 对象的名称。
如果 --use-legacy-policy-config=false，则它必须在调度器初始化之前存在于
系统命名空间中。配置数据必须对应 'data' 映射中键名为 'policy.cfg' 的元素的值。
注意：如果与插件配置一起使用，调度器会失败。
</td>
</tr>
<tr>
<td colspan=2>--policy-configmap-namespace string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："kube-system"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
已弃用: 策略 ConfigMap 所在的名字空间。如果未提供或为空，则将使用 kube-system 名字空间。
注意：如果与插件配置一起使用，调度器会失败。
</td>
</tr>
<tr>
<td colspan=2>--port int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：10251</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
已弃用： 在没有身份验证和鉴权的情况下不安全地为 HTTP 服务的端口。
如果为 0，则根本不提供 HTTP。请参见 --secure-port。
如果 --config 指定了一个配置文件，这个参数将被忽略。
</td>
</tr>
<tr>
<td colspan=2>--profiling&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值： true</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
已弃用: 通过 Web 界面主机启用配置文件：<code>host:port/debug/pprof/</code>。
如果 --config 指定了一个配置文件，这个参数将被忽略。
</td>
</tr>
<tr>
<td colspan=2>--requestheader-allowed-names stringSlice</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
客户端证书通用名称列表，允许在 <code>--requestheader-username-headers</code>
指定的头部中提供用户名。如果为空，则允许任何由
<code>--requestheader-client-ca-file</code> 中证书机构验证的客户端证书。
</td>
</tr>
<tr>
<td colspan=2>--requestheader-client-ca-file string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
在信任 <code>--requestheader-username-headers</code> 指定的头部中的用户名之前
用于验证传入请求上的客户端证书的根证书包。
警告：通常不应假定传入请求已经完成鉴权。
</td>
</tr>
<tr>
<td colspan=2>--requestheader-extra-headers-prefix strings&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
默认值: "x-remote-extra-"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
要检查请求头部前缀列表。建议使用 <code>X-Remote-Extra-</code>。
</td>
</tr>
<tr>
<td colspan=2>--requestheader-group-headers strings&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
默认值: "x-remote-group"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
用于检查组的请求头部列表。建议使用 <code>X-Remote-Group</code>。
</td>
</tr>
<tr>
<td colspan=2>--requestheader-username-headers strings&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
默认值: "x-remote-user"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
用于检查用户名的请求头部列表。<code>X-Remote-User</code> 很常用。
</td>
</tr>
<tr>
<td colspan=2>--scheduler-name string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
默认值："default-scheduler"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
已弃用: 调度器名称，用于根据 Pod 的 “spec.schedulerName” 选择此
调度器将处理的 Pod。
如果 --config 指定了一个配置文件，那么这个参数将被忽略
</td>
</tr>
<tr>
<td colspan=2>--secure-port int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：10259</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
通过身份验证和授权为 HTTPS 服务的端口。如果为 0，则根本不提供 HTTPS。
</td>
</tr>
<tr>
<td colspan=2>--show-hidden-metrics-for-version string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
你希望显式隐藏指标的老版本号。只有较早的此版本号有意义，其它值都是不允许的。
格式为 &lt;主版本>.&lt;此版本>，例如：'1.16'。
此格式的目的是确保你有机会注意到是否下一个发行版本中隐藏了一些额外的指标，
而不是当某些指标在该版本之后被彻底移除时感到震惊。
</td>
</tr>
<tr>
<td colspan=2>--skip-headers</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果为 true，日志消息中不再写入头部前缀。
</td>
</tr>
<tr>
<td colspan=2>--skip-log-headers</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果为 true，则在打开日志文件时忽略其头部。
</td>
</tr>
<tr>
<td colspan=2>--stderrthreshold int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：2</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
达到或超过此阈值的日志会被写入到标准错误输出。
</td>
</tr>
<tr>
<td colspan=2>--tls-cert-file string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
包含默认的 HTTPS x509 证书的文件。（CA证书（如果有）在服务器证书之后并置）。
如果启用了 HTTPS 服务，并且未提供 <code>--tls-cert-file</code> 和
<code>--tls-private-key-file</code>，则会为公共地址生成一个自签名证书和密钥，
并将其保存到 <code>--cert-dir</code> 指定的目录中。
</td>
</tr>
<tr>
<td colspan=2>--tls-cipher-suites strings</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
服务器的密码套件列表，以逗号分隔。如果省略，将使用默认的 Go 密码套件。
优先考虑的值：
TLS_AES_128_GCM_SHA256, TLS_AES_256_GCM_SHA384, TLS_CHACHA20_POLY1305_SHA256, TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA, TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256, TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA, TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384, TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305, TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256, TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA, TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA, TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256, TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA, TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384, TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305, TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256, TLS_RSA_WITH_3DES_EDE_CBC_SHA, TLS_RSA_WITH_AES_128_CBC_SHA, TLS_RSA_WITH_AES_128_GCM_SHA256, TLS_RSA_WITH_AES_256_CBC_SHA, TLS_RSA_WITH_AES_256_GCM_SHA384.<br>
不安全的值：
TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256, TLS_ECDHE_ECDSA_WITH_RC4_128_SHA, TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256, TLS_ECDHE_RSA_WITH_RC4_128_SHA, TLS_RSA_WITH_AES_128_CBC_SHA256, TLS_RSA_WITH_RC4_128_SHA.
</td>
</tr>
<tr>
<td colspan=2>--tls-min-version string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
支持的最低 TLS 版本。可能的值：VersionTLS10, VersionTLS11, VersionTLS12, VersionTLS13
</td>
</tr>
<tr>
<td colspan=2>--tls-private-key-file string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
包含与 --tls-cert-file 匹配的默认 x509 私钥的文件。
</td>
</tr>
<tr>
<td colspan=2>--tls-sni-cert-key string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
一对 x509 证书和私钥文件路径，也可以包含由全限定域名构成的域名模式列表作为后缀，
并可能带有前缀的通配符段。域名匹配还允许是 IP 地址，
但是只有当 apiserver 对客户端请求的 IP 地址可见时，才能使用 IP。
如果未提供域名匹配模式，则提取证书名称。
非通配符匹配优先于通配符匹配，显式域名匹配优先于提取而来的名称。
若有多个密钥/证书对，可多次使用 <code>--tls-sni-cert-key</code>。
例子: "example.crt,example.key" 或者 "foo.crt,foo.key:*.foo.com,foo.com"。
</td>
</tr>
<tr>
<td colspan=2>--use-legacy-policy-config</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
已弃用：设置为 true 时，调度程序将忽略策略 ConfigMap 并使用策略配置文件。
注意：当此标志与插件配置一起使用时，调度器会失败。
</td>
</tr>
<tr>
<td colspan=2>-v, --v int</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
设置日志级别详细程度的数字
</td>
</tr>
<tr>
<td colspan=2>--version version[=true]</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
打印版本信息并退出。
</td>
</tr>
<tr>
<td colspan=2>--vmodule &lt;逗号分隔的 ‘模式=N’ 配置列表></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
以逗号分隔的 ‘模式=N’ 设置列表，用于文件过滤的日志记录。
</td>
</tr>
<tr>
<td colspan=2>--write-config-to string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果已设置，将配置值写入此文件并退出。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-1715b765e2ff39feffd103d59ec0ef07>11.7 - Kubelet 认证/鉴权</h1>
<h2 id=概述>概述</h2>
<p>kubelet 的 HTTPS 端点公开了 API，
这些 API 可以访问敏感度不同的数据，
并允许你在节点上和容器内以不同级别的权限执行操作。</p>
<p>本文档介绍了如何对 kubelet 的 HTTPS 端点的访问进行认证和鉴权。</p>
<h2 id=kubelet-身份认证>Kubelet 身份认证</h2>
<p>默认情况下，未被已配置的其他身份认证方法拒绝的对 kubelet 的 HTTPS 端点的请求会被视为匿名请求，
并被赋予 <code>system:anonymous</code> 用户名和 <code>system:unauthenticated</code> 组。</p>
<p>要禁用匿名访问并向未经身份认证的请求发送 <code>401 Unauthorized</code> 响应，请执行以下操作：</p>
<ul>
<li>带 <code>--anonymous-auth=false</code> 标志启动 kubelet</li>
</ul>
<p>要对 kubelet 的 HTTPS 端点启用 X509 客户端证书认证：</p>
<ul>
<li>带 <code>--client-ca-file</code> 标志启动 kubelet，提供一个 CA 证书包以供验证客户端证书</li>
<li>带 <code>--kubelet-client-certificate</code> 和 <code>--kubelet-client-key</code> 标志启动 apiserver</li>
<li>有关更多详细信息，请参见
<a href=/zh/docs/reference/access-authn-authz/authentication/#x509-client-certs>apiserver 身份验证文档</a></li>
</ul>
<p>要启用 API 持有者令牌（包括服务帐户令牌）以对 kubelet 的 HTTPS 端点进行身份验证，请执行以下操作：</p>
<ul>
<li>确保在 API 服务器中启用了 <code>authentication.k8s.io/v1beta1</code> API 组</li>
<li>带 <code>--authentication-token-webhook</code> 和 <code>--kubeconfig</code> 标志启动 kubelet</li>
<li>kubelet 调用已配置的 API 服务器上的 <code>TokenReview</code> API，以根据持有者令牌确定用户信息</li>
</ul>
<h2 id=kubelet-鉴权>Kubelet 鉴权</h2>
<p>任何成功通过身份验证的请求（包括匿名请求）之后都会被鉴权。
默认的鉴权模式为 <code>AlwaysAllow</code>，它允许所有请求。</p>
<p>细分对 kubelet API 的访问权限可能有多种原因：</p>
<ul>
<li>启用了匿名身份验证，但是应限制匿名用户调用 kubelet API 的能力</li>
<li>启用了持有者令牌认证，但应限制任意 API 用户（如服务帐户）调用 kubelet API 的能力</li>
<li>启用了客户端证书身份验证，但仅应允许已配置的 CA 签名的某些客户端证书使用 kubelet API</li>
</ul>
<p>要细分对 kubelet API 的访问权限，请将鉴权委派给 API 服务器：</p>
<ul>
<li>确保在 API 服务器中启用了 <code>authorization.k8s.io/v1beta1</code> API 组</li>
<li>带 <code>--authorization-mode=Webhook</code> 和 <code>--kubeconfig</code> 标志启动 kubelet</li>
<li>kubelet 调用已配置的 API 服务器上的 <code>SubjectAccessReview</code> API，
以确定每个请求是否得到鉴权</li>
</ul>
<p>kubelet 使用与 apiserver 相同的
<a href=/zh/docs/reference/access-authn-authz/authorization/#review-your-request-attributes>请求属性</a>
方法对 API 请求执行鉴权。</p>
<p>请求的动词根据传入请求的 HTTP 动词确定：</p>
<table>
<thead>
<tr>
<th>HTTP 动词</th>
<th>请求动词</th>
</tr>
</thead>
<tbody>
<tr>
<td>POST</td>
<td>create</td>
</tr>
<tr>
<td>GET, HEAD</td>
<td>get</td>
</tr>
<tr>
<td>PUT</td>
<td>update</td>
</tr>
<tr>
<td>PATCH</td>
<td>patch</td>
</tr>
<tr>
<td>DELETE</td>
<td>delete</td>
</tr>
</tbody>
</table>
<p>资源和子资源是根据传入请求的路径确定的：</p>
<table>
<thead>
<tr>
<th>Kubelet API</th>
<th>资源</th>
<th>子资源</th>
</tr>
</thead>
<tbody>
<tr>
<td>/stats/*</td>
<td>nodes</td>
<td>stats</td>
</tr>
<tr>
<td>/metrics/*</td>
<td>nodes</td>
<td>metrics</td>
</tr>
<tr>
<td>/logs/*</td>
<td>nodes</td>
<td>log</td>
</tr>
<tr>
<td>/spec/*</td>
<td>nodes</td>
<td>spec</td>
</tr>
<tr>
<td><em>其它所有</em></td>
<td>nodes</td>
<td>proxy</td>
</tr>
</tbody>
</table>
<p>名字空间和 API 组属性始终是空字符串，
资源名称始终是 kubelet 的 <code>Node</code> API 对象的名称。</p>
<p>在此模式下运行时，请确保传递给 apiserver 的由 <code>--kubelet-client-certificate</code> 和
<code>--kubelet-client-key</code> 标志标识的用户具有以下属性的鉴权：</p>
<ul>
<li>verb=*, resource=nodes, subresource=proxy</li>
<li>verb=*, resource=nodes, subresource=stats</li>
<li>verb=*, resource=nodes, subresource=log</li>
<li>verb=*, resource=nodes, subresource=spec</li>
<li>verb=*, resource=nodes, subresource=metrics</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-bdd3803a4bb6efcc44a7ab03590ce93c>11.8 - TLS 启动引导</h1>
<p>在一个 Kubernetes 集群中，工作节点上的组件（kubelet 和 kube-proxy）需要与
Kubernetes 控制平面组件通信，尤其是 kube-apiserver。
为了确保通信本身是私密的、不被干扰，并且确保集群的每个组件都在与另一个
可信的组件通信，我们强烈建议使用节点上的客户端 TLS 证书。</p>
<p>启动引导这些组件的正常过程，尤其是需要证书来与 kube-apiserver 安全通信的
工作节点，可能会是一个具有挑战性的过程，因为这一过程通常不受 Kubernetes 控制，
需要不少额外工作。
这也使得初始化或者扩缩一个集群的操作变得具有挑战性。</p>
<p>为了简化这一过程，从 1.4 版本开始，Kubernetes 引入了一个证书请求和签名
API 以便简化此过程。该提案可在
<a href=https://github.com/kubernetes/kubernetes/pull/20439>这里</a>看到。</p>
<p>本文档描述节点初始化的过程，如何为 kubelet 配置 TLS 客户端证书启动引导，
以及其背后的工作原理。</p>
<h2 id=initialization-process>初始化过程 </h2>
<p>当工作节点启动时，kubelet 执行以下操作：</p>
<ol>
<li>寻找自己的 <code>kubeconfig</code> 文件</li>
<li>检索 API 服务器的 URL 和凭据，通常是来自 <code>kubeconfig</code> 文件中的
TLS 密钥和已签名证书</li>
<li>尝试使用这些凭据来与 API 服务器通信</li>
</ol>
<p>假定 kube-apiserver 成功地认证了 kubelet 的凭据数据，它会将 kubelet 视为
一个合法的节点并开始将 Pods 分派给该节点。</p>
<p>注意，签名的过程依赖于：</p>
<ul>
<li><code>kubeconfig</code> 中包含密钥和本地主机的证书</li>
<li>证书被 kube-apiserver 所信任的一个证书机构（CA）所签名</li>
</ul>
<p>负责部署和管理集群的人有以下责任：</p>
<ol>
<li>创建 CA 密钥和证书</li>
<li>将 CA 证书发布到 kube-apiserver 运行所在的控制平面节点上</li>
<li>为每个 kubelet 创建密钥和证书；强烈建议为每个 kubelet 使用独一无二的、
CN 取值与众不同的密钥和证书</li>
<li>使用 CA 密钥对 kubelet 证书签名</li>
<li>将 kubelet 密钥和签名的证书发布到 kubelet 运行所在的特定节点上</li>
</ol>
<p>本文中描述的 TLS 启动引导过程有意简化甚至完全自动化上述过程，尤其是
第三步之后的操作，因为这些步骤是初始化或者扩缩集群时最常见的操作。</p>
<h3 id=bootstrap-initialization>启动引导初始化 </h3>
<p>在启动引导初始化过程中，会发生以下事情：</p>
<ol>
<li>kubelet 启动</li>
<li>kubelet 看到自己 <em>没有</em> 对应的 <code>kubeconfig</code> 文件</li>
<li>kubelet 搜索并发现 <code>bootstrap-kubeconfig</code> 文件</li>
<li>kubelet 读取该启动引导文件，从中获得 API 服务器的 URL 和用途有限的
一个“令牌（Token）”</li>
<li>kubelet 建立与 API 服务器的连接，使用上述令牌执行身份认证</li>
<li>kubelet 现在拥有受限制的凭据来创建和取回证书签名请求（CSR）</li>
<li>kubelet 为自己创建一个 CSR，并将其 signerName 设置为 <code>kubernetes.io/kube-apiserver-client-kubelet</code></li>
<li>CSR 被以如下两种方式之一批复：</li>
</ol>
<ul>
<li>如果配置了，kube-controller-manager 会自动批复该 CSR</li>
<li>如果配置了，一个外部进程，或者是人，使用 Kubernetes API 或者使用 <code>kubectl</code>
来批复该 CSR</li>
</ul>
<ol start=9>
<li>kubelet 所需要的证书被创建</li>
</ol>
<ol start=10>
<li>证书被发放给 kubelet</li>
<li>kubelet 取回该证书</li>
<li>kubelet 创建一个合适的 <code>kubeconfig</code>，其中包含密钥和已签名的证书</li>
<li>kubelet 开始正常操作</li>
<li>可选地，如果配置了，kubelet 在证书接近于过期时自动请求更新证书</li>
<li>更新的证书被批复并发放；取决于配置，这一过程可能是自动的或者手动完成</li>
</ol>
<p>本文的其余部分描述配置 TLS 启动引导的必要步骤及其局限性。</p>
<h2 id=configuration>配置 </h2>
<p>要配置 TLS 启动引导及可选的自动批复，你必须配置以下组件的选项：</p>
<ul>
<li>kube-apiserver</li>
<li>kube-controller-manager</li>
<li>kubelet</li>
<li>集群内的资源：<code>ClusterRoleBinding</code> 以及可能需要的 <code>ClusterRole</code></li>
</ul>
<p>此外，你需要有 Kubernetes 证书机构（Certificate Authority，CA）。</p>
<h2 id=certificate-authority>证书机构 </h2>
<p>就像在没有启动引导的情况下，你会需要证书机构（CA）密钥和证书。
这些数据会被用来对 kubelet 证书进行签名。
如前所述，将证书机构密钥和证书发布到控制平面节点是你的责任。</p>
<p>就本文而言，我们假定这些数据被发布到控制平面节点上的
<code>/var/lib/kubernetes/ca.pem</code>（证书）和
<code>/var/lib/kubernetes/ca-key.pem</code>（密钥）文件中。
我们将这两个文件称作“Kubernetes CA 证书和密钥”。
所有 Kubernetes 组件（kubelet、kube-apiserver、kube-controller-manager）都使用
这些凭据，并假定这里的密钥和证书都是 PEM 编码的。</p>
<h2 id=kube-apiserver-configuration>kube-apiserver 配置 </h2>
<p>启用 TLS 启动引导对 kube-apiserver 有若干需求：</p>
<ul>
<li>能够识别对客户端证书进行签名的 CA</li>
<li>能够对启动引导的 kubelet 执行身份认证，并将其置入 <code>system:bootstrappers</code> 组</li>
<li>能够对启动引导的 kubelet 执行鉴权操作，允许其创建证书签名请求（CSR）</li>
</ul>
<h3 id=recognizing-client-certificates>识别客户证书 </h3>
<p>对于所有客户端证书的认证操作而言，这是很常见的。
如果还没有设置，要为 kube-apiserver 命令添加 <code>--client-ca-file=FILENAME</code>
标志来启用客户端证书认证，在标志中引用一个包含用来签名的证书的证书机构包，
例如：<code>--client-ca-file=/var/lib/kubernetes/ca.pem</code>。</p>
<h3 id=initial-bootstrap-authentication>初始启动引导认证 </h3>
<p>为了让启动引导的 kubelet 能够连接到 kube-apiserver 并请求证书，
它必须首先在服务器上认证自身身份。你可以使用任何一种能够对 kubelet 执行身份认证的
<a href=/zh/docs/reference/access-authn-authz/authentication/>身份认证组件</a>。</p>
<p>尽管所有身份认证策略都可以用来对 kubelet 的初始启动凭据来执行认证，
出于容易准备的因素，建议使用如下两个身份认证组件：</p>
<ol>
<li><a href=#bootstrap-tokens>启动引导令牌（Bootstrap Token）</a></li>
<li><a href=#token-authentication-file>令牌认证文件</a></li>
</ol>
<p>启动引导令牌是一种对 kubelet 进行身份认证的方法，相对简单且容易管理，
且不需要在启动 kube-apiserver 时设置额外的标志。</p>
<p>无论选择哪种方法，这里的需求是 kubelet 能够被身份认证为某个具有如下权限的用户：</p>
<ol>
<li>创建和读取 CSR</li>
<li>在启用了自动批复时，能够在请求节点客户端证书时得到自动批复</li>
</ol>
<p>使用启动引导令牌执行身份认证的 kubelet 会被认证为 <code>system:bootstrappers</code>
组中的用户。这是使用启动引导令牌的一种标准方法。</p>
<p>随着这个功能特性的逐渐成熟，你需要确保令牌绑定到某基于角色的的访问控制（RBAC）
策略上，从而严格限制请求（使用<a href=/zh/docs/reference/access-authn-authz/bootstrap-tokens/>启动引导令牌</a>）
仅限于客户端申请提供证书。当 RBAC 被配置启用时，可以将令牌限制到某个组，从而
提高灵活性。例如，你可以在准备节点期间禁止某特定启动引导组的访问。</p>
<h4 id=bootstrap-tokens>启动引导令牌 </h4>
<p>启动引导令牌的细节在<a href=/zh/docs/reference/access-authn-authz/bootstrap-tokens/>这里</a>
详述。启动引导令牌在 Kubernetes 集群中存储为 Secret 对象，被发放给各个 kubelet。
你可以在整个集群中使用同一个令牌，也可以为每个节点发放单独的令牌。</p>
<p>这一过程有两个方面：</p>
<ol>
<li>基于令牌 ID、机密数据和范畴信息创建 Kubernetes Secret</li>
<li>将令牌发放给 kubelet</li>
</ol>
<p>从 kubelet 的角度，所有令牌看起来都很像，没有特别的含义。
从 kube-apiserver 服务器的角度，启动引导令牌是很特殊的。
根据其 <code>type</code>、<code>namespace</code> 和 <code>name</code>，kube-apiserver 能够将认作特殊的令牌，
并授予携带该令牌的任何人特殊的启动引导权限，换言之，将其视为
<code>system:bootstrappers</code> 组的成员。这就满足了 TLS 启动引导的基本需求。</p>
<p>关于创建 Secret 的进一步细节可访问<a href=/zh/docs/reference/access-authn-authz/bootstrap-tokens/>这里</a>。</p>
<p>如果你希望使用启动引导令牌，你必须在 kube-apiserver 上使用下面的标志启用之：</p>
<pre><code class=language-console data-lang=console>--enable-bootstrap-token-auth=true
</code></pre>
<h4 id=token-authentication-file>令牌认证文件 </h4>
<p>kube-apiserver 能够将令牌视作身份认证依据。
这些令牌可以是任意数据，但必须表示为基于某安全的随机数生成器而得到的
至少 128 位混沌数据。这里的随机数生成器可以是现代 Linux 系统上的
<code>/dev/urandom</code>。生成令牌的方式有很多种。例如：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>head -c <span style=color:#666>16</span> /dev/urandom | od -An -t x | tr -d <span style=color:#b44>&#39; &#39;</span>
</code></pre></div>
<p>上面的命令会生成类似于 <code>02b50b05283e98dd0fd71db496ef01e8</code> 这样的令牌。</p>
<p>令牌文件看起来是下面的例子这样，其中前面三个值可以是任何值，用引号括起来
的组名称则只能用例子中给的值。</p>
<pre><code class=language-console data-lang=console>02b50b05283e98dd0fd71db496ef01e8,kubelet-bootstrap,10001,&quot;system:bootstrappers&quot;
</code></pre>
<p>向 kube-apiserver 添加 <code>--token-auth-file=FILENAME</code> 标志（或许这要对 systemd
的单元文件作修改）以启用令牌文件。参见
<a href=/zh/docs/reference/access-authn-authz/authentication/#static-token-file>这里</a>
的文档以了解进一步的细节。</p>
<h3 id=authorize-kubelet-to-create-csr>授权 kubelet 创建 CSR </h3>
<p>现在启动引导节点被身份认证为 <code>system:bootstrapping</code> 组的成员，它需要被 <em>授权</em>
创建证书签名请求（CSR）并在证书被签名之后将其取回。
幸运的是，Kubernetes 提供了一个 <code>ClusterRole</code>，其中精确地封装了这些许可，
<code>system:node-bootstrapper</code>。</p>
<p>为了实现这一点，你只需要创建 <code>ClusterRoleBinding</code>，将 <code>system:bootstrappers</code>
组绑定到集群角色 <code>system:node-bootstrapper</code>。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#080;font-style:italic># 允许启动引导节点创建 CSR</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRoleBinding<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>create-csrs-for-bootstrapping<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>subjects</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Group<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>system:bootstrappers<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>roleRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>system:node-bootstrapper<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span></code></pre></div>
<h2 id=kube-controller-manager-configuration>kube-controller-manager 配置 </h2>
<p>API 服务器从 kubelet 收到证书请求并对这些请求执行身份认证，但真正负责发放
签名证书的是控制器管理器。</p>
<p>控制器管理器通过一个证书发放的控制回路来执行此操作。该操作的执行方式是使用磁盘上
的文件用 <a href=https://blog.cloudflare.com/introducing-cfssl/>cfssl</a> 本地签名组件
来完成。目前，所发放的所有证书都有一年的有效期，并设定了默认的一组密钥用法。</p>
<p>为了让控制器管理器对证书签名，它需要：</p>
<ul>
<li>能够访问你之前所创建并分发的“Kubernetes CA 密钥和证书”</li>
<li>启用 CSR 签名</li>
</ul>
<h3 id=access-to-key-and-certificate>访问密钥和证书 </h3>
<p>如前所述，你需要创建一个 Kubernetes CA 密钥和证书，并将其发布到控制平面节点。
这些数据会被控制器管理器来对 kubelet 证书进行签名。</p>
<p>由于这些被签名的证书反过来会被 kubelet 用来在 kube-apiserver 执行普通的
kubelet 身份认证，很重要的一点是为控制器管理器所提供的 CA 也被 kube-apiserver
信任用来执行身份认证。CA 密钥和证书是通过 kube-apiserver 的标志
<code>--client-ca-file=FILENAME</code>（例如，<code>--client-ca-file=/var/lib/kubernetes/ca.pem</code>)，
来设定的，正如 kube-apiserver 配置节所述。</p>
<p>要将 Kubernetes CA 密钥和证书提供给 kube-controller-manager，可使用以下标志：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>--cluster-signing-cert-file<span style=color:#666>=</span><span style=color:#b44>&#34;/etc/path/to/kubernetes/ca/ca.crt&#34;</span> --cluster-signing-key-file<span style=color:#666>=</span><span style=color:#b44>&#34;/etc/path/to/kubernetes/ca/ca.key&#34;</span>
</code></pre></div>
<p>例如：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>--cluster-signing-cert-file<span style=color:#666>=</span><span style=color:#b44>&#34;/var/lib/kubernetes/ca.pem&#34;</span> --cluster-signing-key-file<span style=color:#666>=</span><span style=color:#b44>&#34;/var/lib/kubernetes/ca-key.pem&#34;</span>
</code></pre></div>
<p>所签名的证书的合法期限可以通过下面的标志来配置：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>--cluster-signing-duration
</code></pre></div>
<h3 id=approval>批复 </h3>
<p>为了对 CSR 进行批复，你需要告诉控制器管理器批复这些 CSR 是可接受的。
这是通过将 RBAC 访问权限授予正确的组来实现的。</p>
<p>许可权限有两组：</p>
<ul>
<li><code>nodeclient</code>：如果节点在为节点创建新的证书，则该节点还没有证书。该节点
使用前文所列的令牌之一来执行身份认证，因此是组 <code>system:bootstrappers</code> 组
的成员。</li>
<li><code>selfnodeclient</code>：如果节点在对证书执行续期操作，则该节点已经拥有一个证书。
节点持续使用现有的证书将自己认证为 <code>system:nodes</code> 组的成员。</li>
</ul>
<p>要允许 kubelet 请求并接收新的证书，可以创建一个 <code>ClusterRoleBinding</code> 将启动
引导节点所处的组 <code>system:bootstrappers</code> 绑定到为其赋予访问权限的
<code>ClusterRole</code> <code>system:certificates.k8s.io:certificatesigningrequests:nodeclient</code>：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#080;font-style:italic># 批复 &#34;system:bootstrappers&#34; 组的所有 CSR</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRoleBinding<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>auto-approve-csrs-for-group<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>subjects</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Group<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>system:bootstrappers<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>roleRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>system:certificates.k8s.io:certificatesigningrequests:nodeclient<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span></code></pre></div>
<p>要允许 kubelet 对其客户端证书执行续期操作，可以创建一个 <code>ClusterRoleBinding</code>
将正常工作的节点所处的组 <code>system:nodes</code> 绑定到为其授予访问许可的 <code>ClusterRole</code>
<code>system:certificates.k8s.io:certificatesigningrequests:selfnodeclient</code>：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#080;font-style:italic># 批复 &#34;system:nodes&#34; 组的 CSR 续约请求</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRoleBinding<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>auto-approve-renewals-for-nodes<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>subjects</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Group<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>system:nodes<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>roleRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>system:certificates.k8s.io:certificatesigningrequests:selfnodeclient<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span></code></pre></div>
<p>作为 <a href=/zh/docs/reference/generated/kube-controller-manager/>kube-controller-manager</a>
的一部分的 <code>csrapproving</code> 控制器是自动被启用的。
该控制器使用 <a href=/zh/docs/reference/access-authn-authz/authorization/#checking-api-access><code>SubjectAccessReview</code> API</a>
来确定是否某给定用户被授权请求 CSR，之后基于鉴权结果执行批复操作。
为了避免与其它批复组件发生冲突，内置的批复组件不会显式地拒绝任何 CSRs。
该组件仅是忽略未被授权的请求。
控制器也会作为垃圾收集的一部分清除已过期的证书。</p>
<h2 id=kubelet-configuration>kubelet 配置 </h2>
<p>最后，当控制平面节点被正确配置并且所有必要的身份认证和鉴权机制都就绪时，
我们可以配置 kubelet。</p>
<p>kubelet 需要以下配置来执行启动引导：</p>
<ul>
<li>一个用来存储所生成的密钥和证书的路径（可选，可以使用默认配置）</li>
<li>一个用来指向尚不存在的 <code>kubeconfig</code> 文件的路径；kubelet 会将启动引导
配置文件放到这个位置</li>
<li>一个指向启动引导 <code>kubeconfig</code> 文件的路径，用来提供 API 服务器的 URL
和启动引导凭据，例如，启动引导令牌</li>
<li>可选的：轮换证书的指令</li>
</ul>
<p>启动引导 <code>kubeconfig</code> 文件应该放在一个 kubelet 可访问的路径下，例如
<code>/var/lib/kubelet/bootstrap-kubeconfig</code>。</p>
<p>其格式与普通的 <code>kubeconfig</code> 文件完全相同。实例文件可能看起来像这样：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Config<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>clusters</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>cluster</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>certificate-authority</span>:<span style=color:#bbb> </span>/var/lib/kubernetes/ca.pem<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>server</span>:<span style=color:#bbb> </span>https://my.server.example.com:6443<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>bootstrap<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>contexts</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>context</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>cluster</span>:<span style=color:#bbb> </span>bootstrap<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>user</span>:<span style=color:#bbb> </span>kubelet-bootstrap<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>bootstrap<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>current-context</span>:<span style=color:#bbb> </span>bootstrap<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>preferences</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>users</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>kubelet-bootstrap<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>user</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>token</span>:<span style=color:#bbb> </span>07401b.f395accd246ae52d<span style=color:#bbb>
</span></code></pre></div>
<p>需要额外注意的一些因素有：</p>
<ul>
<li><code>certificate-authority</code>：指向 CA 文件的路径，用来对 kube-apiserver 所出示
的服务器证书进行验证</li>
<li><code>server</code>： 用来访问 kube-apiserver 的 URL</li>
<li><code>token</code>：要使用的令牌</li>
</ul>
<p>令牌的格式并不重要，只要它与 kube-apiserver 的期望匹配即可。
在上面的例子中，我们使用的是启动引导令牌。
如前所述，任何合法的身份认证方法都可以使用，不限于令牌。</p>
<p>因为启动引导 <code>kubeconfig</code> 文件是一个标准的 <code>kubeconfig</code> 文件，你可以使用
<code>kubectl</code> 来生成该文件。要生成上面的示例文件：</p>
<pre><code>kubectl config --kubeconfig=/var/lib/kubelet/bootstrap-kubeconfig set-cluster bootstrap --server='https://my.server.example.com:6443' --certificate-authority=/var/lib/kubernetes/ca.pem
kubectl config --kubeconfig=/var/lib/kubelet/bootstrap-kubeconfig set-credentials kubelet-bootstrap --token=07401b.f395accd246ae52d
kubectl config --kubeconfig=/var/lib/kubelet/bootstrap-kubeconfig set-context bootstrap --user=kubelet-bootstrap --cluster=bootstrap
kubectl config --kubeconfig=/var/lib/kubelet/bootstrap-kubeconfig use-context bootstrap
</code></pre>
<p>要指示 kubelet 使用启动引导 <code>kubeconfig</code> 文件，可以使用下面的 kubelet 标志：</p>
<pre><code>--bootstrap-kubeconfig=&quot;/var/lib/kubelet/bootstrap-kubeconfig&quot; --kubeconfig=&quot;/var/lib/kubelet/kubeconfig&quot;
</code></pre>
<p>在启动 kubelet 时，如果 <code>--kubeconfig</code> 标志所指定的文件并不存在，会使用通过标志
<code>--bootstrap-kubeconfig</code> 所指定的启动引导 kubeconfig 配置来向 API 服务器请求
客户端证书。在证书请求被批复并被 kubelet 收回时，一个引用所生成的密钥和所获得
证书的 kubeconfig 文件会被写入到通过 <code>--kubeconfig</code> 所指定的文件路径下。
证书和密钥文件会被放到 <code>--cert-dir</code> 所指定的目录中。</p>
<h3 id=client-and-serving-certificates>客户和服务证书 </h3>
<p>前文所述的内容都与 kubelet <em>客户端</em> 证书相关，尤其是 kubelet 用来向
kube-apiserver 认证自身身份的证书。</p>
<p>kubelet 也可以使用 <em>服务（Serving）</em> 证书。kubelet 自身向外提供一个
HTTPS 末端，包含若干功能特性。要保证这些末端的安全性，kubelet 可以执行以下操作
之一：</p>
<ul>
<li>使用通过 <code>--tls-private-key-file</code> 和 <code>--tls-cert-file</code> 所设置的密钥和证书</li>
<li>如果没有提供密钥和证书，则创建自签名的密钥和证书</li>
<li>通过 CSR API 从集群服务器请求服务证书</li>
</ul>
<p>TLS 启动引导所提供的客户端证书默认被签名为仅用于 <code>client auth</code>（客户端认证），
因此不能作为提供服务的证书，或者 <code>server auth</code>。</p>
<p>不过，你可以启用服务器证书，至少可以部分地通过证书轮换来实现这点。</p>
<h3 id=certificate-rotation>证书轮换 </h3>
<p>Kubernetes v1.8 和更高版本的 kubelet 实现了对客户端证书与/或服务证书进行轮换
这一 Beta 特性。这一特性通过 kubelet 对应的 <code>RotateKubeletClientCertificate</code> 和
<code>RotateKubeletServerCertificate</code> 特性门控标志来控制，并且是默认启用的。</p>
<p><code>RotateKubeletClientCertificate</code> 会导致 kubelet 在其现有凭据即将过期时通过
创建新的 CSR 来轮换其客户端证书。要启用此功能特性，可将下面的标志传递给
kubelet：</p>
<pre><code>--rotate-certificates
</code></pre>
<p><code>RotateKubeletServerCertificate</code> 会让 kubelet 在启动引导其客户端凭据之后请求
一个服务证书 <strong>且</strong> 对该服务证书执行轮换操作。要启用此功能特性，将下面的标志
传递给 kubelet：</p>
<pre><code>--rotate-server-certificates
</code></pre><div class="alert alert-info note callout" role=alert>
<strong>Note:</strong>
<p>Kubernetes 核心中所实现的 CSR 批复控制器出于
<a href=https://github.com/kubernetes/community/pull/1982>安全原因</a>
并不会自动批复节点的 <em>服务</em> 证书。
要使用 <code>RotateKubeletServerCertificate</code> 功能特性，集群运维人员需要运行一个
定制的控制器或者手动批复服务证书的请求。</p>
<p>对 kubelet 服务证书的批复过程因集群部署而异，通常应该仅批复如下 CSR：</p>
<ol>
<li>由节点发出的请求（确保 <code>spec.username</code> 字段形式为 <code>system:node:&lt;nodeName></code>
且 <code>spec.groups</code> 包含 <code>system:nodes</code>）</li>
<li>请求中包含服务证书用法（确保 <code>spec.usages</code> 中包含 <code>server auth</code>，可选地也可
包含 <code>digital signature</code> 和 <code>key encipherment</code>，且不包含其它用法）</li>
<li>仅包含隶属于请求节点的 IP 和 DNS 的 <code>subjectAltNames</code>，没有 URI 和 Email
形式的 <code>subjectAltNames</code>（解析 <code>spec.request</code> 中的 x509 证书签名请求可以
检查 <code>subjectAltNames</code>）</li>
</ol>
</div>
<h2 id=other-authenticating-components>其它身份认证组件 </h2>
<p>本文所描述的所有 TLS 启动引导内容都与 kubelet 相关。不过，其它组件也可能需要
直接与 kube-apiserver 直接通信。容易想到的是 kube-proxy，同样隶属于
Kubernetes 的控制面并且运行在所有节点之上，不过也可能包含一些其它负责
监控或者联网的组件。</p>
<p>与 kubelet 类似，这些其它组件也需要一种向 kube-apiserver 认证身份的方法。
你可以用几种方法来生成这类凭据：</p>
<ul>
<li>较老的方式：和 kubelet 在 TLS 启动引导之前所做的一样，用类似的方式
创建和分发证书</li>
<li>DaemonSet：由于 kubelet 自身被加载到所有节点之上，并且有足够能力来启动基本服务，
你可以运行将 kube-proxy 和其它特定节点的服务作为 <code>kube-system</code> 名字空间中的
DaemonSet 来执行，而不是独立的进程。由于 DaemonSet 位于集群内部，你可以为其
指派一个合适的服务账户，使之具有适当的访问权限来完成其使命。这也许是配置此类
服务的最简单的方法。</li>
</ul>
<h2 id=kubectl-approval>kubectl 批复 </h2>
<p>CSRs 可以在控制器管理其内置的批复工作流之外被批复。</p>
<p>签名控制器并不会立即对所有证书请求执行签名操作。相反，它会等待这些请求被某
具有适当特权的用户标记为 “Approved（已批准）”状态。
这一流程有意允许由外部批复控制器来自动执行的批复，或者由控制器管理器内置的
批复控制器来自动批复。
不过，集群管理员也可以使用 <code>kubectl</code> 来手动批准证书请求。
管理员可以通过 <code>kubectl get csr</code> 来列举所有的 CSR，使用
<code>kubectl descsribe csr &lt;name></code> 来描述某个 CSR 的细节。
管理员可以使用 <code>kubectl certificate approve &lt;name</code> 来批准某 CSR，或者
<code>kubectl certificate deny &lt;name></code> 来拒绝某 CSR。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-a6ae13190e147ef3922315c2091fc258>12 - 配置 API</h1>
</div>
<div class=td-content>
<h1 id=pg-8f61883225b6bed85530d1904e148392>12.1 - kube-apiserver Audit 配置 (v1)</h1>
<h2 id=resource-types>资源类型 </h2>
<ul>
<li><a href=#audit-k8s-io-v1-Event>Event</a></li>
<li><a href=#audit-k8s-io-v1-EventList>EventList</a></li>
<li><a href=#audit-k8s-io-v1-Policy>Policy</a></li>
<li><a href=#audit-k8s-io-v1-PolicyList>PolicyList</a></li>
</ul>
<h2 id=audit-k8s-io-v1-Event><code>Event</code> </h2>
<p><strong>出现在：</strong></p>
<ul>
<li><a href=#audit-k8s-io-v1-EventList>EventList</a></li>
</ul>
<p>Event 结构包含可出现在 API 审计日志中的所有信息。</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>apiVersion</code><br>string</td><td><code>audit.k8s.io/v1</code></td></tr>
<tr><td><code>kind</code><br>string</td><td><code>Event</code></td></tr>
<tr><td><code>level</code> <b>[必需]</b><br>
<a href=#audit-k8s-io-v1-Level><code>Level</code></a>
</td>
<td>
生成事件所对应的审计级别。
</td>
</tr>
<tr><td><code>auditID</code> <b>[必需]</b><br>
<a href=https://godoc.org/k8s.io/apimachinery/pkg/types#UID><code>k8s.io/apimachinery/pkg/types.UID</code></a>
</td>
<td>
为每个请求所生成的唯一审计 ID。
</td>
</tr>
<tr><td><code>stage</code> <b>[必需]</b><br>
<a href=#audit-k8s-io-v1-Stage><code>Stage</code></a>
</td>
<td>
生成此事件时请求的处理阶段。
</td>
</tr>
<tr><td><code>requestURI</code> <b>[必需]</b><br>
<code>string</code>
</td>
<td>
requestURI 是客户端发送到服务器端的请求 URI。
</td>
</tr>
<tr><td><code>verb</code> <b>[必需]</b><br>
<code>string</code>
</td>
<td>
verb 是与请求对应的 Kubernetes 动词。对于非资源请求，此字段为 HTTP 方法的小写形式。
</td>
</tr>
<tr><td><code>user</code> <b>[必需]</b><br>
<a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/#userinfo-v1-authentication><code>authentication/v1.UserInfo</code></a>
</td>
<td>
关于认证用户的信息。
</td>
</tr>
<tr><td><code>impersonatedUser</code><br>
<a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/#userinfo-v1-authentication><code>authentication/v1.UserInfo</code></a>
</td>
<td>
关于所伪装（impersonated）的用户的信息。
</td>
</tr>
<tr><td><code>sourceIPs</code><br>
<code>[]string</code>
</td>
<td>
发起请求和中间代理的源 IP 地址。
</td>
</tr>
<tr><td><code>userAgent</code><br>
<code>string</code>
</td>
<td>
userAgent 中记录客户端所报告的用户代理（User Agent）字符串。
注意 userAgent 信息是由客户端提供的，一定不要信任。
</td>
</tr>
<tr><td><code>objectRef</code><br>
<a href=#audit-k8s-io-v1-ObjectReference><code>ObjectReference</code></a>
</td>
<td>
此请求所指向的对象引用。对于 List 类型的请求或者非资源请求，此字段可忽略。
</td>
</tr>
<tr><td><code>responseStatus</code><br>
<a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/#status-v1-meta><code>meta/v1.Status</code></a>
</td>
<td>
响应的状态，当 responseObject 不是 Status 类型时被赋值。
对于成功的请求，此字段仅包含 code 和 statusSuccess。
对于非 Status 类型的错误响应，此字段会被自动赋值为出错信息。
</td>
</tr>
<tr><td><code>requestObject</code><br>
<a href=https://godoc.org/k8s.io/apimachinery/pkg/runtime#Unknown><code>k8s.io/apimachinery/pkg/runtime.Unknown</code></a>
</td>
<td>
来自请求的 API 对象，以 JSON 格式呈现。requestObject 在请求中按原样记录
（可能会采用 JSON 重新编码），之后会进入版本转换、默认值填充、准入控制以及
配置信息合并等阶段。此对象为外部版本化的对象类型，甚至其自身可能并不是一个
合法的对象。对于非资源请求，此字段被忽略。
只有当审计级别为 Request 或更高的时候才会记录。
</td>
</tr>
<tr><td><code>responseObject</code><br>
<a href=https://godoc.org/k8s.io/apimachinery/pkg/runtime#Unknown><code>k8s.io/apimachinery/pkg/runtime.Unknown</code></a>
</td>
<td>
响应中包含的 API 对象，以 JSON 格式呈现。requestObject 是在被转换为外部类型
并序列化为 JSON 格式之后才被记录的。
对于非资源请求，此字段会被忽略。
只有审计级别为 Response 时才会记录。
</td>
</tr>
<tr><td><code>requestReceivedTimestamp</code><br>
<a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/#microtime-v1-meta><code>meta/v1.MicroTime</code></a>
</td>
<td>
请求到达 API 服务器时的时间。
</td>
</tr>
<tr><td><code>stageTimestamp</code><br>
<a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/#microtime-v1-meta><code>meta/v1.MicroTime</code></a>
</td>
<td>
请求到达当前审计阶段时的时间。
</td>
</tr>
<tr><td><code>annotations</code><br>
<code>map[string]string</code>
</td>
<td>
annotations 是一个无结构的键-值映射，其中保存的是一个审计事件。
该事件可以由请求处理链路上的插件来设置，包括身份认证插件、鉴权插件以及
准入控制插件等。
注意这些注解是针对审计事件本身的，与所提交的对象中的 metadata.annotations
之间不存在对应关系。
映射中的键名应该唯一性地标识生成该事件的组件，从而避免名字上的冲突
（例如 podsecuritypolicy.admission.k8s.io/policy）。
映射中的键值应该比较简洁。
当审计级别为 Metadata 时会包含 annotations 字段。
</td>
</tr>
</tbody>
</table>
<h2 id=audit-k8s-io-v1-EventList><code>EventList</code> </h2>
<p>EventList 是审计事件（Event）的列表。</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>apiVersion</code><br>string</td><td><code>audit.k8s.io/v1</code></td></tr>
<tr><td><code>kind</code><br>string</td><td><code>EventList</code></td></tr>
<tr><td><code>metadata</code><br>
<a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/#listmeta-v1-meta><code>meta/v1.ListMeta</code></a>
</td>
<td>
<span class=text-muted>列表结构元数据</span>
</td>
</tr>
<tr><td><code>items</code> <b>[必需]</b><br>
<a href=#audit-k8s-io-v1-Event><code>[]Event</code></a>
</td>
<td>
<span class=text-muted>事件对象列表</span>
</td>
</tr>
</tbody>
</table>
<h2 id=audit-k8s-io-v1-Policy><code>Policy</code> </h2>
<p><strong>出现在：</strong></p>
<ul>
<li><a href=#audit-k8s-io-v1-PolicyList>PolicyList</a></li>
</ul>
<p>Policy 定义的是审计日志的配置以及不同类型请求的日志记录规则。</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>apiVersion</code><br>string</td><td><code>audit.k8s.io/v1</code></td></tr>
<tr><td><code>kind</code><br>string</td><td><code>Policy</code></td></tr>
<tr><td><code>metadata</code><br>
<a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/#objectmeta-v1-meta><code>meta/v1.ObjectMeta</code></a>
</td>
<td>
包含 <code>metadata</code> 字段是为了便于与 API 基础设施之间实现互操作。
参考 Kubernetes API 文档了解 <code>metadata</code> 字段的详细信息。
</td>
</tr>
<tr><td><code>rules</code> <b>[必需]</b><br>
<a href=#audit-k8s-io-v1-PolicyRule><code>[]PolicyRule</code></a>
</td>
<td>
字段 rules 设置请求要被记录的审计级别（level）。
每个请求可能会与多条规则相匹配；发生这种状况时遵从第一条匹配规则。
默认的审计级别是 None，不过可以在列表的末尾使用一条全抓（catch-all）规则
重载其设置。
列表中的规则（PolicyRule）是严格有序的。
</td>
</tr>
<tr><td><code>omitStages</code><br>
<a href=#audit-k8s-io-v1-Stage><code>[]Stage</code></a>
</td>
<td>
字段 omitStages 是一个阶段（Stage）列表，其中包含无须生成事件的阶段。
注意这一选项也可以通过每条规则来设置。
审计组件最终会忽略出现在 omitStages 中阶段，也会忽略规则中的阶段。
</td>
</tr>
</tbody>
</table>
<h2 id=audit-k8s-io-v1-PolicyList><code>PolicyList</code> </h2>
<p>PolicyList 是由审计策略（Policy）组成的列表。</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>apiVersion</code><br>string</td><td><code>audit.k8s.io/v1</code></td></tr>
<tr><td><code>kind</code><br>string</td><td><code>PolicyList</code></td></tr>
<tr><td><code>metadata</code><br>
<a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/#listmeta-v1-meta><code>meta/v1.ListMeta</code></a>
</td>
<td>
<span class=text-muted>列表结构元数据。</span>
</td>
</tr>
<tr><td><code>items</code> <b>[必需]</b><br>
<a href=#audit-k8s-io-v1-Policy><code>[]Policy</code></a>
</td>
<td>
<span class=text-muted>策略（Policy）对象列表。</span>
</td>
</tr>
</tbody>
</table>
<h2 id=audit-k8s-io-v1-GroupResources><code>GroupResources</code> </h2>
<p><strong>出现在：</strong></p>
<ul>
<li><a href=#audit-k8s-io-v1-PolicyRule>PolicyRule</a></li>
</ul>
<p>GroupResources 代表的是某 API 组中的资源类别。</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>group</code><br>
<code>string</code>
</td>
<td>
字段 group 给出包含资源的 API 组的名称。
空字符串代表 <code>core</code> API 组。
</td>
</tr>
<tr><td><code>resources</code><br>
<code>[]string</code>
</td>
<td>
<p>如果存在通配符，则合法性检查逻辑会确保 resources 中的条目不会彼此重叠。<br>
空的列表意味着规则适用于该 API 组中的所有资源及其子资源。</p>
</td>
</tr>
<tr><td><code>resourceNames</code><br>
<code>[]string</code>
</td>
<td>
字段 resourceNames 是策略将匹配的资源实例名称列表。
使用此字段时，<code>resources</code> 必须指定。
空的 resourceNames 列表意味着资源的所有实例都会匹配到此策略。
</td>
</tr>
</tbody>
</table>
<h2 id=audit-k8s-io-v1-Level><code>Level</code> </h2>
<p><code>string</code> 数据类型的别名。</p>
<p><strong>出现在：</strong></p>
<ul>
<li><a href=#audit-k8s-io-v1-Event>Event</a></li>
<li><a href=#audit-k8s-io-v1-PolicyRule>PolicyRule</a></li>
</ul>
<p>Level 定义的是审计过程中在日志内记录的信息量。</p>
<h2 id=audit-k8s-io-v1-ObjectReference><code>ObjectReference</code> </h2>
<p><strong>出现在：</strong></p>
<ul>
<li><a href=#audit-k8s-io-v1-Event>Event</a></li>
</ul>
<p>ObjectReference 包含的是用来检查或修改所引用对象时将需要的全部信息。</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>resource</code><br>
<code>string</code>
</td>
<td>
<span class=text-muted>资源类别。</span>
</td>
</tr>
<tr><td><code>namespace</code><br>
<code>string</code>
</td>
<td>
<span class=text-muted>资源对象所在名字空间。</span>
</td>
</tr>
<tr><td><code>name</code><br>
<code>string</code>
</td>
<td>
<span class=text-muted>资源对象名称。</span>
</td>
</tr>
<tr><td><code>uid</code><br>
<a href=https://godoc.org/k8s.io/apimachinery/pkg/types#UID><code>k8s.io/apimachinery/pkg/types.UID</code></a>
</td>
<td>
<span class=text-muted>资源对象的唯一标识（UID）。</span>
</td>
</tr>
<tr><td><code>apiGroup</code><br>
<code>string</code>
</td>
<td>
字段 apiGroup 给出包含所引用对象的 API 组的名称。
空字符串代表 <code>core</code> API 组。
</td>
</tr>
<tr><td><code>apiVersion</code><br>
<code>string</code>
</td>
<td>
字段 apiVersion 是包含所引用对象的 API 组的版本。
</td>
</tr>
<tr><td><code>resourceVersion</code><br>
<code>string</code>
</td>
<td>
<span class=text-muted>资源对象自身的版本值。</span>
</td>
</tr>
<tr><td><code>subresource</code><br>
<code>string</code>
</td>
<td>
<span class=text-muted>子资源的类别。</span>
</td>
</tr>
</tbody>
</table>
<h2 id=audit-k8s-io-v1-PolicyRule><code>PolicyRule</code> </h2>
<p><strong>出现在：</strong></p>
<ul>
<li><a href=#audit-k8s-io-v1-Policy>Policy</a></li>
</ul>
<p>PolicyRule 包含一个映射，基于元数据将请求映射到某审计级别。
请求必须与每个字段所定义的规则都匹配（即 rules 的交集）才被视为匹配。</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>level</code> <b>[必需]</b><br>
<a href=#audit-k8s-io-v1-Level><code>Level</code></a>
</td>
<td>
与此规则匹配的请求所对应的日志记录级别（Level）。
</td>
</tr>
<tr><td><code>users</code><br>
<code>[]string</code>
</td>
<td>
根据身份认证所确定的用户名的列表，给出此规则所适用的用户。
空列表意味着适用于所有用户。
</td>
</tr>
<tr><td><code>userGroups</code><br>
<code>[]string</code>
</td>
<td>
此规则所适用的用户组的列表。如果用户是所列用户组中任一用户组的成员，则视为匹配。
空列表意味着适用于所有用户组。
</td>
</tr>
<tr><td><code>verbs</code><br>
<code>[]string</code>
</td>
<td>
此规则所适用的动词（verb）列表。
空列表意味着适用于所有动词。
</td>
</tr>
<tr><td><code>resources</code><br>
<a href=#audit-k8s-io-v1-GroupResources><code>[]GroupResources</code></a>
</td>
<td>
此规则所适用的资源类别列表。
空列表意味着适用于 API 组中的所有资源类别。
</td>
</tr>
<tr><td><code>namespaces</code><br>
<code>[]string</code>
</td>
<td>
</td>
此规则所适用的名字空间列表。
空字符串（""）意味着适用于非名字空间作用域的资源。
空列表意味着适用于所有名字空间。
</tr>
<tr><td><code>nonResourceURLs</code><br>
<code>[]string</code>
</td>
<td>
字段 nonResourceURLs 给出一组需要被审计的 URL 路径。
允许使用 &#8727;，但只能作为路径中最后一个完整分段。<br>
例如：<br>
"/metrics" - 记录对 API 服务器度量值（metrics）的所有请求；<br>
"/healthz&#8727;" - 记录所有健康检查请求。
</td>
</tr>
<tr><td><code>omitStages</code><br>
<a href=#audit-k8s-io-v1-Stage><code>[]Stage</code></a>
</td>
<td>
字段 omitStages 是一个阶段（Stage）列表，针对所列的阶段服务器不会生成审计事件。
注意这一选项也可以在策略（Policy）级别指定。服务器审计组件会忽略
omitStages 中给出的阶段，也会忽略策略中给出的阶段。
空列表意味着不对阶段作任何限制。
</td>
</tr>
</tbody>
</table>
<h2 id=audit-k8s-io-v1-Stage><code>Stage</code> </h2>
<p><code>string</code> 数据类型的别名。</p>
<p><strong>出现在：</strong></p>
<ul>
<li><a href=#audit-k8s-io-v1-Event>Event</a></li>
<li><a href=#audit-k8s-io-v1-Policy>Policy</a></li>
<li><a href=#audit-k8s-io-v1-PolicyRule>PolicyRule</a></li>
</ul>
<p>Stage 定义在请求处理过程中可以生成审计事件的阶段。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-eaf7c149d8e3f45225002d76aa5af774>12.2 - kube-apiserver 加密配置 (v1)</h1>
<p>
包 v1 是 API 的 v1 版本。</p>
<h2 id=资源类型>资源类型</h2>
<ul>
<li><a href=#apiserver-config-k8s-io-v1-EncryptionConfiguration>EncryptionConfiguration</a></li>
</ul>
<h2 id=apiserver-config-k8s-io-v1-EncryptionConfiguration><code>EncryptionConfiguration</code> </h2>
<p>
EncryptionConfiguration 为加密驱动保存完整的配置信息。
</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>apiVersion</code><br>string</td><td><code>apiserver.config.k8s.io/v1</code></td></tr>
<tr><td><code>kind</code><br>string</td><td><code>EncryptionConfiguration</code></td></tr>
<tr><td><code>resources</code> <b>[必需]</b><br>
<a href=#apiserver-config-k8s-io-v1-ResourceConfiguration><code>[]ResourceConfiguration</code></a>
</td>
<td>
<p>
<code>resources</code> 是一个包含资源及其对应的加密驱动的列表。
</p>
</td>
</tr>
</tbody>
</table>
<h2 id=apiserver-config-k8s-io-v1-AESConfiguration><code>AESConfiguration</code> </h2>
<p><strong>出现在：</strong></p>
<ul>
<li><a href=#apiserver-config-k8s-io-v1-ProviderConfiguration>ProviderConfiguration</a></li>
</ul>
<p>
AESConfiguration 包含 AES 转换器的 API 配置信息。
</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>keys</code> <b>[必需]</b><br>
<a href=#apiserver-config-k8s-io-v1-Key><code>[]Key</code></a>
</td>
<td>
<p>
<code>keys</code> 是一组用于创建 AES 转换器的秘钥。
对于 AES-CBC，每个秘钥必须是 32 字节长；对于 AES-GCM，每个秘钥可以是 16、24、32 字节长。
</p>
</td>
</tr>
</tbody>
</table>
<h2 id=apiserver-config-k8s-io-v1-IdentityConfiguration><code>IdentityConfiguration</code> </h2>
<p><strong>出现在：</strong></p>
<ul>
<li><a href=#apiserver-config-k8s-io-v1-ProviderConfiguration>ProviderConfiguration</a></li>
</ul>
<p>
IdentityConfiguration 是一个空的结构，用来支持在驱动配置中支持标识转换器。
</p>
<h2 id=apiserver-config-k8s-io-v1-KMSConfiguration><code>KMSConfiguration</code> </h2>
<p><strong>出现在：</strong></p>
<ul>
<li><a href=#apiserver-config-k8s-io-v1-ProviderConfiguration>ProviderConfiguration</a></li>
</ul>
<p>
KMSConfiguration 包含基于 KMS 的封套转换器的名称、缓存大小以及配置文件路径信息。
</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>name</code> <b>[必需]</b><br>
<code>string</code>
</td>
<td>
<p>
<code>name</code> 是要使用的 KMS 插件名称。
</p>
</td>
</tr>
<tr><td><code>cachesize</code><br>
<code>int32</code>
</td>
<td>
<p>
<code>cachesize</code> 是可在内存中缓存的 Secret 数量上限。默认值是 1000。将此字段设置为负值会禁用缓存。
</p>
</td>
</tr>
<tr><td><code>endpoint</code> <b>[必需]</b><br>
<code>string</code>
</td>
<td>
<p>
<code>endpoint</code> 是 gRPC 服务器的监听地址，例如 "unix:///var/run/kms-provider.sock"。
</p>
</td>
</tr>
<tr><td><code>timeout</code><br>
<a href=https://pkg.go.dev/k8s.io/apimachinery/pkg/apis/meta/v1#Duration><code>meta/v1.Duration</code></a>
</td>
<td>
<p>
对 KMS 插件执行 gRPC 调用的超时时长（例如，'5s'）。默认值为 3 秒。
</p>
</td>
</tr>
</tbody>
</table>
<h2 id=apiserver-config-k8s-io-v1-Key><code>Key</code> </h2>
<p><strong>出现在：</strong></p>
<ul>
<li><a href=#apiserver-config-k8s-io-v1-AESConfiguration>AESConfiguration</a></li>
<li><a href=#apiserver-config-k8s-io-v1-SecretboxConfiguration>SecretboxConfiguration</a></li>
</ul>
<p>
Key 中包含为某转换器所提供的键名和对应的私密数据。
</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>name</code> <b>[必需]</b><br>
<code>string</code>
</td>
<td>
<p>
<code>name</code> 是在向磁盘中存储数据时使用的键名。
</p>
</td>
</tr>
<tr><td><code>secret</code> <b>[必需]</b><br>
<code>string</code>
</td>
<td>
<p>
<code>secret</code> 是实际的秘钥，用 base64 编码。
</p>
</td>
</tr>
</tbody>
</table>
<h2 id=apiserver-config-k8s-io-v1-ProviderConfiguration><code>ProviderConfiguration</code> </h2>
<p><strong>出现在：</strong></p>
<ul>
<li><a href=#apiserver-config-k8s-io-v1-ResourceConfiguration>ResourceConfiguration</a></li>
</ul>
<p>
ProviderConfiguration 为加密驱动存储配置信息。
</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>aesgcm</code> <b>[必需]</b><br>
<a href=#apiserver-config-k8s-io-v1-AESConfiguration><code>AESConfiguration</code></a>
</td>
<td>
<p>
<code>aesgcm</code> 是用于 AES-GCM 转换器的配置。
</p>
</td>
</tr>
<tr><td><code>aescbc</code> <b>[必需]</b><br>
<a href=#apiserver-config-k8s-io-v1-AESConfiguration><code>AESConfiguration</code></a>
</td>
<td>
<p>
<code>aescbc</code> 是用于 AES-CBC 转换器的配置。
</p>
</td>
</tr>
<tr><td><code>secretbox</code> <b>[必需]</b><br>
<a href=#apiserver-config-k8s-io-v1-SecretboxConfiguration><code>SecretboxConfiguration</code></a>
</td>
<td>
<p>
<code>secretbox</code> 是用于基于 Secretbox 的转换器的配置。
</p>
</td>
</tr>
<tr><td><code>identity</code> <b>[必需]</b><br>
<a href=#apiserver-config-k8s-io-v1-IdentityConfiguration><code>IdentityConfiguration</code></a>
</td>
<td>
<p>
<code>identity</code> 是用于标识转换器的配置（空）。
</p>
</td>
</tr>
<tr><td><code>kms</code> <b>[必需]</b><br>
<a href=#apiserver-config-k8s-io-v1-KMSConfiguration><code>KMSConfiguration</code></a>
</td>
<td>
<p>
<code>kms</code> 中包含用于基于 KMS 的封套转换器的名称、缓存大小以及配置文件路径信息。
</p>
</td>
</tr>
</tbody>
</table>
<h2 id=apiserver-config-k8s-io-v1-ResourceConfiguration><code>ResourceConfiguration</code> </h2>
<p><strong>出现在：</strong></p>
<ul>
<li><a href=#apiserver-config-k8s-io-v1-EncryptionConfiguration>EncryptionConfiguration</a></li>
</ul>
<p>
ResourceConfiguration 中保存资源配置。
</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>resources</code> <b>[必需]</b><br>
<code>[]string</code>
</td>
<td>
<p>
<code>resources</code> 是必需要加密的 Kubernetes 资源的列表。
</p>
</td>
</tr>
<tr><td><code>providers</code> <b>[必需]</b><br>
<a href=#apiserver-config-k8s-io-v1-ProviderConfiguration><code>[]ProviderConfiguration</code></a>
</td>
<td>
<p>
<code>providers</code> 是一个转换器列表，用来将资源写入到磁盘或从磁盘上读出。
例如：'aesgcm'、'aescbc'、'secretbox'、'identity'。
</p>
</td>
</tr>
</tbody>
</table>
<h2 id=apiserver-config-k8s-io-v1-SecretboxConfiguration><code>SecretboxConfiguration</code> </h2>
<p><strong>出现在：</strong></p>
<ul>
<li><a href=#apiserver-config-k8s-io-v1-ProviderConfiguration>ProviderConfiguration</a></li>
</ul>
<p>
SecretboxConfiguration 包含用于某 Secretbox 转换器的 API 配置。
</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>keys</code> <b>[必需]</b><br>
<a href=#apiserver-config-k8s-io-v1-Key><code>[]Key</code></a>
</td>
<td>
<p>
<code>keys</code> 是一个秘钥列表，用来创建 Secretbox 转换器。每个秘钥必须是 32 字节长。
</p>
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-fd52840184e93a463355aa21a234f263>12.3 - kube-apiserver 配置 (v1)</h1>
<p>v1 包中包含 API 的 v1 版本。</p>
<h2 id=资源类型>资源类型</h2>
<ul>
<li><a href=#apiserver-config-k8s-io-v1-AdmissionConfiguration>AdmissionConfiguration</a></li>
</ul>
<h2 id=apiserver-config-k8s-io-v1-AdmissionConfiguration><code>AdmissionConfiguration</code> </h2>
<p>AdmissionConfiguration 为准入控制器提供版本化的配置。</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>apiVersion</code><br>string</td><td><code>apiserver.config.k8s.io/v1</code></td></tr>
<tr><td><code>kind</code><br>string</td><td><code>AdmissionConfiguration</code></td></tr>
<tr><td><code>plugins</code><br>
<a href=#apiserver-config-k8s-io-v1-AdmissionPluginConfiguration><code>[]AdmissionPluginConfiguration</code></a>
</td>
<td>
<p><code>plugins</code> 字段允许为每个准入控制插件设置配置选项。</p>
</td>
</tr>
</tbody>
</table>
<h2 id=apiserver-config-k8s-io-v1-AdmissionPluginConfiguration><code>AdmissionPluginConfiguration</code> </h2>
<p><strong>出现在：</strong></p>
<ul>
<li><a href=#apiserver-config-k8s-io-v1-AdmissionConfiguration>AdmissionConfiguration</a></li>
</ul>
<p>AdmissionPluginConfiguration 为某个插件提供配置信息。</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>name</code> <b>[必需]</b><br>
<code>string</code>
</td>
<td>
<p><code>name</code> 是准入控制器的名称。它必须与所注册的准入插件名称匹配。</p>
</td>
</tr>
<tr><td><code>path</code><br>
<code>string</code>
</td>
<td>
<p><code>path</code> 是指向包含插件配置信息的配置文件的路径。</p>
</td>
</tr>
<tr><td><code>configuration</code><br>
<a href=https://pkg.go.dev/k8s.io/apimachinery/pkg/runtime#Unknown><code>k8s.io/apimachinery/pkg/runtime.Unknown</code></a>
</td>
<td>
<p><code>configuration</code> 是一个内嵌的配置对象，用来保存插件的配置信息。
如果存在，则使用这里的配置信息而不是指向配置文件的路径。</p>
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-e9edd8df1106a991be062e37a9ef87b5>12.4 - kube-apiserver 配置 (v1alpha1)</h1>
<p>包 v1alpha1 包含 API 的 v1alpha1 版本。</p>
<h2 id=资源类型>资源类型</h2>
<ul>
<li><a href=#apiserver-k8s-io-v1alpha1-AdmissionConfiguration>AdmissionConfiguration</a></li>
<li><a href=#apiserver-k8s-io-v1alpha1-EgressSelectorConfiguration>EgressSelectorConfiguration</a></li>
<li><a href=#apiserver-k8s-io-v1alpha1-TracingConfiguration>TracingConfiguration</a></li>
</ul>
<h2 id=apiserver-k8s-io-v1alpha1-AdmissionConfiguration><code>AdmissionConfiguration</code> </h2>
<p>
AdmissionConfiguration 为准入控制器提供版本化的配置信息。
</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>apiVersion</code><br>string</td><td><code>apiserver.k8s.io/v1alpha1</code></td></tr>
<tr><td><code>kind</code><br>string</td><td><code>AdmissionConfiguration</code></td></tr>
<tr><td><code>plugins</code><br>
<a href=#apiserver-k8s-io-v1alpha1-AdmissionPluginConfiguration><code>[]AdmissionPluginConfiguration</code></a>
</td>
<td>
<p>
<code>plugins</code> 允许用户为每个准入控制插件指定设置。
</p>
</td>
</tr>
</tbody>
</table>
<h2 id=apiserver-k8s-io-v1alpha1-EgressSelectorConfiguration><code>EgressSelectorConfiguration</code> </h2>
<p>
EgressSelectorConfiguration 为 Egress 选择算符客户端提供版本化的配置选项。
</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>apiVersion</code><br>string</td><td><code>apiserver.k8s.io/v1alpha1</code></td></tr>
<tr><td><code>kind</code><br>string</td><td><code>EgressSelectorConfiguration</code></td></tr>
<tr><td><code>egressSelections</code> <b>[必需]</b><br>
<a href=#apiserver-k8s-io-v1alpha1-EgressSelection><code>[]EgressSelection</code></a>
</td>
<td>
<p>
<code>connectionServices</code> 包含一组 Egress 选择算符客户端配置选项。
</p>
</td>
</tr>
</tbody>
</table>
<h2 id=apiserver-k8s-io-v1alpha1-TracingConfiguration><code>TracingConfiguration</code> </h2>
<p>
TracingConfiguration 为跟踪客户端提供版本化的配置信息。
</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>apiVersion</code><br>string</td><td><code>apiserver.k8s.io/v1alpha1</code></td></tr>
<tr><td><code>kind</code><br>string</td><td><code>TracingConfiguration</code></td></tr>
<tr><td><code>endpoint</code><br>
<code>string</code>
</td>
<td>
<p>
在控制面节点上运行的采集器的端点。
API 服务器在向采集器发送数据时将 <code>egressType</code> 设置为 ControlPlane。
这里的语法定义在 https://github.com/grpc/grpc/blob/master/doc/naming.md。
默认值为 otlpgrpc 的默认值，即 <code>localhost:4317</code>
这一连接是不安全的，且不支持 TLS。
</p>
</td>
</tr>
<tr><td><code>samplingRatePerMillion</code><br>
<code>int32</code>
</td>
<td>
<p>
<code>samplingRatePerMillion</code> 设置每一百万个数据点中要采样的样本个数。默认值为 0。
</p>
</td>
</tr>
</tbody>
</table>
<h2 id=apiserver-k8s-io-v1alpha1-AdmissionPluginConfiguration><code>AdmissionPluginConfiguration</code> </h2>
<p><strong>出现在：</strong></p>
<ul>
<li><a href=#apiserver-k8s-io-v1alpha1-AdmissionConfiguration>AdmissionConfiguration</a></li>
</ul>
<p>
AdmissionPluginConfiguration 为某个插件提供配置信息。
</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>name</code> <b>[必需]</b><br>
<code>string</code>
</td>
<td>
<p>
<code>name</code> 是准入控制器的名称。此名称必须与所注册的准入插件名称匹配。
</p>
</td>
</tr>
<tr><td><code>path</code><br>
<code>string</code>
</td>
<td>
<p>
<code>path</code> 为指向包含插件配置数据的配置文件的路径。
</p>
</td>
</tr>
<tr><td><code>configuration</code><br>
<a href=https://pkg.go.dev/k8s.io/apimachinery/pkg/runtime#Unknown><code>k8s.io/apimachinery/pkg/runtime.Unknown</code></a>
</td>
<td>
<p>
<code>configuration</code> 是一个嵌入的配置对象，用作插件的配置数据来源。
如果设置了此字段，则使用此字段而不是指向配置文件的路径。
</p>
</td>
</tr>
</tbody>
</table>
<h2 id=apiserver-k8s-io-v1alpha1-Connection><code>Connection</code> </h2>
<p><strong>出现在：</strong></p>
<ul>
<li><a href=#apiserver-k8s-io-v1alpha1-EgressSelection>EgressSelection</a></li>
</ul>
<p>
Connection 提供某个 Egress 选择客户端的配置信息。
</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>proxyProtocol</code> <b>[必需]</b><br>
<a href=#apiserver-k8s-io-v1alpha1-ProtocolType><code>ProtocolType</code></a>
</td>
<td>
<p>
<code>proxyProtocol</code> 是客户端连接到 konnectivity 服务器所使用的协议。
</p>
</td>
</tr>
<tr><td><code>transport</code><br>
<a href=#apiserver-k8s-io-v1alpha1-Transport><code>Transport</code></a>
</td>
<td>
<p>
<code>transport</code> 定义的是传输层的配置。我们使用这个配置来联系 konnectivity 服务器。
当 <code>proxyProtocol</code> 是 HTTPConnect 或 GRPC 时需要设置此字段。
</p>
</td>
</tr>
</tbody>
</table>
<h2 id=apiserver-k8s-io-v1alpha1-EgressSelection><code>EgressSelection</code> </h2>
<p><strong>出现在：</strong></p>
<ul>
<li><a href=#apiserver-k8s-io-v1alpha1-EgressSelectorConfiguration>EgressSelectorConfiguration</a></li>
</ul>
<p>
EgressSelection 为某个 Egress 选择客户端提供配置信息。
</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>name</code> <b>[必需]</b><br>
<code>string</code>
</td>
<td>
<p>
<code>name</code> 是 Egress 选择器的名称。当前支持的取值有 "controlplane"，
"master"，"etcd" 和 "cluster"。
"master" Egress 选择器已被弃用，推荐使用 "controlplane"。
</p>
</td>
</tr>
<tr><td><code>connection</code> <b>[必需]</b><br>
<a href=#apiserver-k8s-io-v1alpha1-Connection><code>Connection</code></a>
</td>
<td>
<p>
<code>connection</code> 是用来配置 Egress 选择器的配置信息。
</p>
</td>
</tr>
</tbody>
</table>
<h2 id=apiserver-k8s-io-v1alpha1-ProtocolType><code>ProtocolType</code> </h2>
<p>（<code>string</code> 类型的别名）</p>
<p><strong>出现在：</strong></p>
<ul>
<li><a href=#apiserver-k8s-io-v1alpha1-Connection>Connection</a></li>
</ul>
<p>
ProtocolType 是 <code>connection.protocolType</code> 的合法值集合。
</p>
<h2 id=apiserver-k8s-io-v1alpha1-TCPTransport><code>TCPTransport</code> </h2>
<p><strong>出现在：</strong></p>
<ul>
<li><a href=#apiserver-k8s-io-v1alpha1-Transport>Transport</a></li>
</ul>
<p>
TCPTransport 提供使用 TCP 连接 konnectivity 服务器时需要的信息。
</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>url</code> <b>[必需]</b><br>
<code>string</code>
</td>
<td>
<p>
<code>url</code> 是要连接的 konnectivity 服务器的位置。例如 "https://127.0.0.1:8131"。
</p>
</td>
</tr>
<tr><td><code>tlsConfig</code><br>
<a href=#apiserver-k8s-io-v1alpha1-TLSConfig><code>TLSConfig</code></a>
</td>
<td>
<p>
<code>tlsConfig</code> 是使用 TLS 来连接 konnectivity 服务器时需要的信息。
</p>
</td>
</tr>
</tbody>
</table>
<h2 id=apiserver-k8s-io-v1alpha1-TLSConfig><code>TLSConfig</code> </h2>
<p><strong>出现在：</strong></p>
<ul>
<li><a href=#apiserver-k8s-io-v1alpha1-TCPTransport>TCPTransport</a></li>
</ul>
<p>
TLSConfig 为连接 konnectivity 服务器提供身份认证信息。仅用于 TCPTransport。
</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>caBundle</code><br>
<code>string</code>
</td>
<td>
<p>
<code>caBundle</code> 是指向用来确定与 konnectivity 服务器间信任欢喜的 CA 证书包的文件位置。
当 <code>tcpTransport.url</code> 前缀为 "http://" 时必须不设置，或者设置为空。
如果 <code>tcpTransport.url</code> 前缀为 "https://" 并且此字段未设置，则默认使用系统的信任根。
</p>
</td>
</tr>
<tr><td><code>clientKey</code><br>
<code>string</code>
</td>
<td>
<p>
<code>clientKey</code> 是与 konnectivity 服务器进行 mtls 握手时使用的客户端秘钥文件位置。
如果 `tcp.url` 前缀为 <code>http://</code>，必须不指定或者为空；
如果 `tcp.url` 前缀为 <code>https://</code>，必须设置。
</p>
</td>
</tr>
<tr><td><code>clientCert</code><br>
<code>string</code>
</td>
<td>
<p>
<code>clientCert</code> 是与 konnectivity 服务器进行 mtls 握手时使用的客户端证书文件位置。
如果 `tcp.url` 前缀为 <code>http://</code>，必须不指定或者为空；
如果 `tcp.url` 前缀为 <code>https://</code>，必须设置。
</p>
</td>
</tr>
</tbody>
</table>
<h2 id=apiserver-k8s-io-v1alpha1-Transport><code>Transport</code> </h2>
<p><strong>出现在：</strong></p>
<ul>
<li><a href=#apiserver-k8s-io-v1alpha1-Connection>Connection</a></li>
</ul>
<p>
Transport 定义联系 konnectivity 服务器时要使用的传输层配置。
</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>tcp</code><br>
<a href=#apiserver-k8s-io-v1alpha1-TCPTransport><code>TCPTransport</code></a>
</td>
<td>
<p>
<code>tcp</code> 包含通过 TCP 与 konnectivity 服务器通信时使用的 TCP 配置。
目前使用 TCP 传输时不支持 GRPC 的 <code>proxyProtocol</code>。
<code>tcp</code> 和 <code>uds</code> 二者至少设置一个。
</p>
</td>
</tr>
<tr><td><code>uds</code><br>
<a href=#apiserver-k8s-io-v1alpha1-UDSTransport><code>UDSTransport</code></a>
</td>
<td>
<p>
<code>uds</code> 包含通过 UDS 与 konnectivity 服务器通信时使用的 UDS 配置。
<code>tcp</code> 和 <code>uds</code> 二者至少设置一个。
</p>
</td>
</tr>
</tbody>
</table>
<h2 id=apiserver-k8s-io-v1alpha1-UDSTransport><code>UDSTransport</code> </h2>
<p><strong>出现在：</strong></p>
<ul>
<li><a href=#apiserver-k8s-io-v1alpha1-Transport>Transport</a></li>
</ul>
<p>
UDSTransport 设置通过 UDS 连接 konnectivity 服务器时需要的信息。
</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>udsName</code> <b>[必需]</b><br>
<code>string</code>
</td>
<td>
<p>
<code>udsName</code> 是与 konnectivity 服务器连接时使用的 UNIX 域套接字名称。
字段取值不要求包含 <code>unix://</code> 前缀。
（例如：<code>/etc/srv/kubernetes/konnectivity-server/konnectivity-server.socket</code>）
</p>
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-d8644f8d8b33ff33a31c8b55065eaf37>12.5 - kube-proxy 配置 (v1alpha1)</h1>
<h2 id=resource-types>资源类型 </h2>
<ul>
<li><a href=#kubeproxy-config-k8s-io-v1alpha1-KubeProxyConfiguration>KubeProxyConfiguration</a></li>
</ul>
<h2 id=kubeproxy-config-k8s-io-v1alpha1-KubeProxyConfiguration><code>KubeProxyConfiguration</code> </h2>
<p>KubeProxyConfiguration 包含用来配置 Kubernetes 代理服务器的所有配置信息。</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>apiVersion</code><br>string</td><td><code>kubeproxy.config.k8s.io/v1alpha1</code></td></tr>
<tr><td><code>kind</code><br>string</td><td><code>KubeProxyConfiguration</code></td></tr>
<tr><td><code>featureGates</code> <b>[必需]</b><br>
<code>map[string]bool</code>
</td>
<td>
featureGates 是一个功能特性名称到布尔值的映射表，用来启用或者禁用测试性质的功能特性。
</td>
</tr>
<tr><td><code>bindAddress</code> <b>[必需]</b><br>
<code>string</code>
</td>
<td>
bindAddress 是代理服务器提供服务时所用 IP 地址（设置为 0.0.0.0
时意味着在所有网络接口上提供服务）。
</td>
</tr>
<tr><td><code>healthzBindAddress</code> <b>[必需]</b><br>
<code>string</code>
</td>
<td>
healthzBindAddress 是健康状态检查服务器提供服务时所使用的的 IP 地址和端口，
默认设置为 '0.0.0.0:10256'。
</td>
</tr>
<tr><td><code>metricsBindAddress</code> <b>[必需]</b><br>
<code>string</code>
</td>
<td>
metricsBindAddress 是度量值服务器提供服务时所使用的的 IP 地址和端口，
默认设置为 '127.0.0.1:10249'（设置为 0.0.0.0 意味着在所有接口上提供服务）。
</td>
</tr>
<tr><td><code>bindAddressHardFail</code> <b>[必需]</b><br>
<code>bool</code>
</td>
<td>
bindAddressHardFail 设置为 true 时，kube-proxy 将无法绑定到某端口这类问题视为致命错误并直接退出。
</td>
</tr>
<tr><td><code>enableProfiling</code> <b>[必需]</b><br>
<code>bool</code>
</td>
<td>
enableProfiling 通过 '/debug/pprof' 处理程序在 Web 界面上启用性能分析。
性能分析处理程序将由度量值服务器执行。
</td>
</tr>
<tr><td><code>clusterCIDR</code> <b>[必需]</b><br>
<code>string</code>
</td>
<td>
clusterCIDR 是集群中 Pods 所使用的 CIDR 范围。这一地址范围用于对来自集群外的请求
流量进行桥接。如果未设置，则 kube-proxy 不会对非集群内部的流量做桥接。
</td>
</tr>
<tr><td><code>hostnameOverride</code> <b>[必需]</b><br>
<code>string</code>
</td>
<td>
hostnameOverride 非空时，所给的字符串（而不是实际的主机名）将被用作 kube-proxy 的标识。
</td>
</tr>
<tr><td><code>clientConnection</code> <b>[必需]</b><br>
<a href=#ClientConnectionConfiguration><code>ClientConnectionConfiguration</code></a>
</td>
<td>
clientConnection 给出代理服务器与 API 服务器通信时要使用的 kubeconfig 文件和客户端链接设置。
</td>
</tr>
<tr><td><code>iptables</code> <b>[必需]</b><br>
<a href=#kubeproxy-config-k8s-io-v1alpha1-KubeProxyIPTablesConfiguration><code>KubeProxyIPTablesConfiguration</code></a>
</td>
<td>
iptables 字段包含与 iptables 相关的配置选项。
</td>
</tr>
<tr><td><code>ipvs</code> <b>[必需]</b><br>
<a href=#kubeproxy-config-k8s-io-v1alpha1-KubeProxyIPVSConfiguration><code>KubeProxyIPVSConfiguration</code></a>
</td>
<td>
ipvs 中包含与 ipvs 相关的配置选项。
</td>
</tr>
<tr><td><code>oomScoreAdj</code> <b>[必需]</b><br>
<code>int32</code>
</td>
<td>
oomScoreAdj 是为 kube-proxy 进程所设置的 oom-score-adj 值。
此设置值必须介于 [-1000, 1000] 范围内。
</td>
</tr>
<tr><td><code>mode</code> <b>[必需]</b><br>
<a href=#kubeproxy-config-k8s-io-v1alpha1-ProxyMode><code>ProxyMode</code></a>
</td>
<td>
mode 用来设置将使用的代理模式。
</td>
</tr>
<tr><td><code>portRange</code> <b>[必需]</b><br>
<code>string</code>
</td>
<td>
portRange 是主机端口的范围，形式为 ‘beginPort-endPort’（包含边界），
用来设置代理服务所使用的端口。如果未指定（即‘0-0’），则代理服务会随机选择端口号。
</td>
</tr>
<tr><td><code>udpIdleTimeout</code> <b>[必需]</b><br>
<a href=https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Duration><code>meta/v1.Duration</code></a>
</td>
<td>
udpIdleTimeout 用来设置 UDP 链接保持活跃的时长（例如，'250ms'、'2s'）。
此值必须大于 0。此字段仅适用于 mode 值为 'userspace' 的场合。
</td>
</tr>
<tr><td><code>conntrack</code> <b>[必需]</b><br>
<a href=#kubeproxy-config-k8s-io-v1alpha1-KubeProxyConntrackConfiguration><code>KubeProxyConntrackConfiguration</code></a>
</td>
<td>
conntrack 包含与 conntrack 相关的配置选项。
</td>
</tr>
<tr><td><code>configSyncPeriod</code> <b>[必需]</b><br>
<a href=https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Duration><code>meta/v1.Duration</code></a>
</td>
<td>
configSyncPeriod 是从 API 服务器刷新配置的频率。此值必须大于 0。
</td>
</tr>
<tr><td><code>nodePortAddresses</code> <b>[必需]</b><br>
<code>[]string</code>
</td>
<td>
nodePortAddresses 是 kube-proxy 进程的 <code>--nodeport-addresses</code> 命令行参数设置。
此值必须是合法的 IP 段。所给的 IP 段会作为参数来选择 NodePort 类型服务所使用的接口。
如果有人希望将本地主机（Localhost）上的服务暴露给本地访问，同时暴露在某些其他网络接口上
以实现某种目标，可以使用 IP 段的列表。
如果此值被设置为 "127.0.0.0/8"，则 kube-proxy 将仅为 NodePort 服务选择本地回路（loopback）接口。
如果此值被设置为非零的 IP 段，则 kube-proxy 会对 IP 作过滤，仅使用适用于当前节点的 IP 地址。
空的字符串列表意味着选择所有网络接口。
</td>
</tr>
<tr><td><code>winkernel</code> <b>[必需]</b><br>
<a href=#kubeproxy-config-k8s-io-v1alpha1-KubeProxyWinkernelConfiguration><code>KubeProxyWinkernelConfiguration</code></a>
</td>
<td>
winkernel 包含与 winkernel 相关的配置选项。
</td>
</tr>
<tr><td><code>showHiddenMetricsForVersion</code> <b>[必需]</b><br>
<code>string</code>
</td>
<td>
showHiddenMetricsForVersion 给出的是一个 Kubernetes 版本号字符串，用来设置你希望
显示隐藏度量值的版本。
</td>
</tr>
<tr><td><code>detectLocalMode</code> <b>[必需]</b><br>
<a href=#kubeproxy-config-k8s-io-v1alpha1-LocalMode><code>LocalMode</code></a>
</td>
<td>
detectLocalMode 用来确定检测本地流量的方式，默认为 LocalModeClusterCIDR。
</td>
</tr>
</tbody>
</table>
<h2 id=kubeproxy-config-k8s-io-v1alpha1-KubeProxyConntrackConfiguration><code>KubeProxyConntrackConfiguration</code> </h2>
<p><strong>出现在：</strong></p>
<ul>
<li><a href=#kubeproxy-config-k8s-io-v1alpha1-KubeProxyConfiguration>KubeProxyConfiguration</a></li>
</ul>
<p>KubeProxyConntrackConfiguration 包含为 Kubernetes 代理服务器提供的 conntrack 设置。</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>maxPerCore</code> <b>[必需]</b><br>
<code>int32</code>
</td>
<td>
maxPerCore 是每个 CPU 核所跟踪的 NAT 链接个数上限
（0 意味着保留当前上限限制并忽略 min 字段设置值）。
</td>
</tr>
<tr><td><code>min</code> <b>[必需]</b><br>
<code>int32</code>
</td>
<td>
min 给出要分配的链接跟踪记录个数下限。
设置此值时会忽略 maxPerCore 的值（将 maxPerCore 设置为 0 时不会调整上限值）。
</td>
</tr>
<tr><td><code>tcpEstablishedTimeout</code> <b>[必需]</b><br>
<a href=https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Duration><code>meta/v1.Duration</code></a>
</td>
<td>
tcpEstablishedTimeout 给出空闲 TCP 连接的保留时间（例如，'2s'）。
此值必须大于 0。
</td>
</tr>
<tr><td><code>tcpCloseWaitTimeout</code> <b>[必需]</b><br>
<a href=https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Duration><code>meta/v1.Duration</code></a>
</td>
<td>
tcpCloseWaitTimeout 用来设置空闲的、处于 CLOSE_WAIT 状态的 conntrack 条目
保留在 conntrack 表中的时间长度（例如，'60s'）。
此设置值必须大于 0。
</td>
</tr>
</tbody>
</table>
<h2 id=kubeproxy-config-k8s-io-v1alpha1-KubeProxyIPTablesConfiguration><code>KubeProxyIPTablesConfiguration</code> </h2>
<p><strong>出现在：</strong></p>
<ul>
<li><a href=#kubeproxy-config-k8s-io-v1alpha1-KubeProxyConfiguration>KubeProxyConfiguration</a></li>
</ul>
<p>KubeProxyIPTablesConfiguration 包含用于 Kubernetes 代理服务器的、与 iptables 相关的配置细节。</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>masqueradeBit</code> <b>[必需]</b><br>
<code>int32</code>
</td>
<td>
masqueradeBit 是 iptables fwmark 空间中的具体一位，用来在纯 iptables 代理模式下
设置 SNAT。此值必须介于 [0, 31]（含边界值）。
</td>
</tr>
<tr><td><code>masqueradeAll</code> <b>[必需]</b><br>
<code>bool</code>
</td>
<td>
masqueradeAll 用来通知 kube-proxy 在使用纯 iptables 代理模式时对所有流量执行
SNAT 操作。
</td>
</tr>
<tr><td><code>syncPeriod</code> <b>[必需]</b><br>
<a href=https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Duration><code>meta/v1.Duration</code></a>
</td>
<td>
syncPeriod 给出 iptables 规则的刷新周期（例如，'5s'、'1m'、'2h22m'）。
此值必须大于 0。
</td>
</tr>
<tr><td><code>minSyncPeriod</code> <b>[必需]</b><br>
<a href=https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Duration><code>meta/v1.Duration</code></a>
</td>
<td>
minSyncPeriod 给出 iptables 规则被刷新的最小周期（例如，'5s'、'1m'、'2h22m'）。
</td>
</tr>
</tbody>
</table>
<h2 id=kubeproxy-config-k8s-io-v1alpha1-KubeProxyIPVSConfiguration><code>KubeProxyIPVSConfiguration</code> </h2>
<p><strong>出现在：</strong></p>
<ul>
<li><a href=#kubeproxy-config-k8s-io-v1alpha1-KubeProxyConfiguration>KubeProxyConfiguration</a></li>
</ul>
<p>KubeProxyIPVSConfiguration 包含用于 Kubernetes 代理服务器的、与 ipvs 相关的配置细节。</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>syncPeriod</code> <b>[必需]</b><br>
<a href=https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Duration><code>meta/v1.Duration</code></a>
</td>
<td>
syncPeriod 给出 ipvs 规则的刷新周期（例如，'5s'、'1m'、'2h22m'）。
此值必须大于 0。
</td>
</tr>
<tr><td><code>minSyncPeriod</code> <b>[必需]</b><br>
<a href=https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Duration><code>meta/v1.Duration</code></a>
</td>
<td>
minSyncPeriod 给出 ipvs 规则被刷新的最小周期（例如，'5s'、'1m'、'2h22m'）。
</td>
</tr>
<tr><td><code>scheduler</code> <b>[必需]</b><br>
<code>string</code>
</td>
<td>
IPVS 调度器。
</td>
</tr>
<tr><td><code>excludeCIDRs</code> <b>[必需]</b><br>
<code>[]string</code>
</td>
<td>
excludeCIDRs 取值为一个 CIDR 列表，ipvs 代理程序在清理 IPVS 服务时不应触碰这些 IP 地址。
</td>
</tr>
<tr><td><code>strictARP</code> <b>[必需]</b><br>
<code>bool</code>
</td>
<td>
strictARP 用来配置 arp_ignore 和 arp_announce，以避免（错误地）响应来自 kube-ipvs0 接口的
ARP 查询请求。
</td>
</tr>
<tr><td><code>tcpTimeout</code> <b>[必需]</b><br>
<a href=https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Duration><code>meta/v1.Duration</code></a>
</td>
<td>
tcpTimeout 是用于设置空闲 IPVS TCP 会话的超时值。
默认值为 0，意味着使用系统上当前的超时值设置。
</td>
</tr>
<tr><td><code>tcpFinTimeout</code> <b>[必需]</b><br>
<a href=https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Duration><code>meta/v1.Duration</code></a>
</td>
<td>
tcpFinTimeout 用来设置 IPVS TCP 会话在收到 FIN 之后的超时值。
默认值为 0，意味着使用系统上当前的超时值设置。
</td>
</tr>
<tr><td><code>udpTimeout</code> <b>[必需]</b><br>
<a href=https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Duration><code>meta/v1.Duration</code></a>
</td>
<td>
udpTimeout 用来设置 IPVS UDP 包的超时值。
默认值为 0，意味着使用系统上当前的超时值设置。
</td>
</tr>
</tbody>
</table>
<h2 id=kubeproxy-config-k8s-io-v1alpha1-KubeProxyWinkernelConfiguration><code>KubeProxyWinkernelConfiguration</code> </h2>
<p><strong>出现在：</strong></p>
<ul>
<li><a href=#kubeproxy-config-k8s-io-v1alpha1-KubeProxyConfiguration>KubeProxyConfiguration</a></li>
</ul>
<p>KubeProxyWinkernelConfiguration 包含 Kubernetes 代理服务器的 Windows/HNS 设置。</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>networkName</code> <b>[必需]</b><br>
<code>string</code>
</td>
<td>
networkName 是 kube-proxy 用来创建端点和策略的网络名称。
</td>
</tr>
<tr><td><code>sourceVip</code> <b>[必需]</b><br>
<code>string</code>
</td>
<td>
sourceVip 是执行负载均衡时进行 NAT 转换所使用的源端 VIP 端点 IP 地址。
</td>
</tr>
<tr><td><code>enableDSR</code> <b>[必需]</b><br>
<code>bool</code>
</td>
<td>
enableDSR 通知 kube-proxy 是否使用 DSR 来创建 HNS 策略。
</td>
</tr>
</tbody>
</table>
<h2 id=kubeproxy-config-k8s-io-v1alpha1-LocalMode><code>LocalMode</code> </h2>
<p>（<code>string</code> 类型的别名）</p>
<p><strong>出现在：</strong></p>
<ul>
<li><a href=#kubeproxy-config-k8s-io-v1alpha1-KubeProxyConfiguration>KubeProxyConfiguration</a></li>
</ul>
<p>LocalMode 代表的是对节点上本地流量进行检测的模式。</p>
<h2 id=kubeproxy-config-k8s-io-v1alpha1-ProxyMode><code>ProxyMode</code> </h2>
<p>（<code>string</code> 类型的别名）</p>
<p><strong>出现在：</strong></p>
<ul>
<li><a href=#kubeproxy-config-k8s-io-v1alpha1-KubeProxyConfiguration>KubeProxyConfiguration</a></li>
</ul>
<p>ProxyMode 表示的是 Kubernetes 代理服务器所使用的模式。</p>
<p>目前 Linux 平台上有三种可用的代理模式：'userspace'（相对较老，即将被淘汰）、
'iptables'（相对较新，速度较快）、'ipvs'（最新，在性能和可扩缩性上表现好）。</p>
<p>在 Windows 平台上有两种可用的代理模式：'userspace'（相对较老，但稳定）和
'kernelspace'（相对较新，速度更快）。</p>
<p>在 Linux 平台上，如果代理的 mode 为空，则使用可用的最佳代理（目前是 iptables，
将来可能会发生变化）。如果选择的是 iptables 代理（无论原因如何），但系统的内核
或者 iptables 的版本不够高，kube-proxy 也会回退为 userspace 代理服务器所使用的模式。
当代理的 mode 设置为 'ipvs' 时会启用 IPVS 模式，对应的回退路径是先尝试 iptables，
最后回退到 userspace。</p>
<p>在 Windows 平台上，如果代理 mode 为空，则使用可用的最佳代理（目前是 userspace，
不过将来可能会发生变化）。如果所选择的是 winkernel 代理（无论原因如何），
但 Windows 内核不支持此代理模式，则 kube-proxy 会回退到 userspace 代理。</p>
<h2 id=ClientConnectionConfiguration><code>ClientConnectionConfiguration</code> </h2>
<p><strong>出现在：</strong></p>
<ul>
<li><a href=#kubeproxy-config-k8s-io-v1alpha1-KubeProxyConfiguration>KubeProxyConfiguration</a></li>
</ul>
<p>ClientConnectionConfiguration 包含构造客户端所需要的细节信息。</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>kubeconfig</code> <b>[必需]</b><br>
<code>string</code>
</td>
<td>
kubeconfig 是指向一个 KubeConfig 文件的路径。
</td>
</tr>
<tr><td><code>acceptContentTypes</code> <b>[必需]</b><br>
<code>string</code>
</td>
<td>
acceptContentTypes 定义客户端在连接到服务器时所发送的 Accept 头部字段。
此设置值会覆盖默认配置 'application/json'。
此字段会控制某特定客户端与指定服务器的所有链接。
</td>
</tr>
<tr><td><code>contentType</code> <b>[必需]</b><br>
<code>string</code>
</td>
<td>
contentType 是从此客户端向服务器发送数据时使用的内容类型（Content Type）。
</td>
</tr>
<tr><td><code>qps</code> <b>[必需]</b><br>
<code>float32</code>
</td>
<td>
qps 控制此连接上每秒钟可以发送的查询请求个数。
</td>
</tr>
<tr><td><code>burst</code> <b>[必需]</b><br>
<code>int32</code>
</td>
<td>
允许客户端超出其速率限制时可以临时累积的额外查询个数。
</td>
</tr>
</tbody>
</table>
<h2 id=FormatOptions><code>FormatOptions</code> </h2>
<p>FormatOptions 包含不同日志记录格式的配置选项。</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>json</code> <b>[必需]</b><br>
<a href=#JSONOptions><code>JSONOptions</code></a>
</td>
<td>
[实验特性] json 字段包含 “JSON” 日志格式的配置选项。
</td>
</tr>
</tbody>
</table>
<h2 id=JSONOptions><code>JSONOptions</code> </h2>
<p><strong>出现在：</strong></p>
<ul>
<li><a href=#FormatOptions>FormatOptions</a></li>
</ul>
<p>JSONOptions 包含“json”日志格式的配置选项。</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>splitStream</code> <b>[必需]</b><br>
<code>bool</code>
</td>
<td>
[实验特性] splitStream 将信息类型的信息输出到标准输出，错误信息重定向到标准
错误输出，并提供缓存。默认行为是将二者都输出到标准输出且不提供缓存。
</td>
</tr>
<tr><td><code>infoBufferSize</code> <b>[必需]</b><br>
<a href=https://pkg.go.dev/k8s.io/apimachinery/pkg/api/resource#QuantityValue><code>k8s.io/apimachinery/pkg/api/resource.QuantityValue</code></a>
</td>
<td>
[实验特性] infoBufferSize 设置在使用分离数据流时 info 数据流的缓冲区大小。
默认值为 0，意味着不提供缓存。
</td>
</tr>
</tbody>
</table>
<h2 id=VModuleConfiguration><code>VModuleConfiguration</code> </h2>
<p>（<code>[]k8s.io/component-base/config/v1alpha1.VModuleItem</code> 的别名）</p>
<p>VModuleConfiguration 是一组文件名或文件名模式，及其对应的日志详尽程度阈值配置。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-5cf379787cc3cd6f11182678610e6b5e>12.6 - kube-scheduler 配置 (v1beta2)</h1>
<h2 id=资源类型>资源类型</h2>
<ul>
<li><a href=#kubescheduler-config-k8s-io-v1beta2-DefaultPreemptionArgs>DefaultPreemptionArgs</a></li>
<li><a href=#kubescheduler-config-k8s-io-v1beta2-InterPodAffinityArgs>InterPodAffinityArgs</a></li>
<li><a href=#kubescheduler-config-k8s-io-v1beta2-KubeSchedulerConfiguration>KubeSchedulerConfiguration</a></li>
<li><a href=#kubescheduler-config-k8s-io-v1beta2-NodeAffinityArgs>NodeAffinityArgs</a></li>
<li><a href=#kubescheduler-config-k8s-io-v1beta2-NodeResourcesBalancedAllocationArgs>NodeResourcesBalancedAllocationArgs</a></li>
<li><a href=#kubescheduler-config-k8s-io-v1beta2-NodeResourcesFitArgs>NodeResourcesFitArgs</a></li>
<li><a href=#kubescheduler-config-k8s-io-v1beta2-PodTopologySpreadArgs>PodTopologySpreadArgs</a></li>
<li><a href=#kubescheduler-config-k8s-io-v1beta2-VolumeBindingArgs>VolumeBindingArgs</a></li>
</ul>
<h2 id=kubescheduler-config-k8s-io-v1beta2-DefaultPreemptionArgs><code>DefaultPreemptionArgs</code> </h2>
<p>DefaultPreemptionArgs 包含用来配置 DefaultPreemption 插件的参数。</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>apiVersion</code><br>string</td><td><code>kubescheduler.config.k8s.io/v1beta2</code></td></tr>
<tr><td><code>kind</code><br>string</td><td><code>DefaultPreemptionArgs</code></td></tr>
<tr><td><code>minCandidateNodesPercentage</code> <b>[必需]</b><br>
<code>int32</code>
</td>
<td>
此字段为试运行抢占时 shortlist 中候选节点数的下限，数值为节点数的百分比。
字段值必须介于 [0, 100] 之间。未指定时默认值为整个集群规模的 10%。
</td>
</tr>
<tr><td><code>minCandidateNodesAbsolute</code> <b>[必需]</b><br>
<code>int32</code>
</td>
<td>
<p>此字段设置 shortlist 中候选节点的绝对下限。用于试运行抢占而列举的
候选节点个数近似于通过下面的公式计算的：</p>
<p>候选节点数 = max(节点数 * minCandidateNodesPercentage, minCandidateNodesAbsolute)</p>
<p>之所以说是“近似于”是因为存在一些类似于 PDB 违例这种因素，会影响到进入 shortlist
中候选节点的个数。取值至少为 0 节点。若未设置默认为 100 节点。</p>
</td>
</tr>
</tbody>
</table>
<h2 id=kubescheduler-config-k8s-io-v1beta2-InterPodAffinityArgs><code>InterPodAffinityArgs</code> </h2>
<p>InterPodAffinityArgs 包含用来配置 InterPodAffinity 插件的参数。</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>apiVersion</code><br>string</td><td><code>kubescheduler.config.k8s.io/v1beta2</code></td></tr>
<tr><td><code>kind</code><br>string</td><td><code>InterPodAffinityArgs</code></td></tr>
<tr><td><code>hardPodAffinityWeight</code> <b>[必需]</b><br>
<code>int32</code>
</td>
<td>
此字段是一个计分权重值。针对新增的 Pod，要对现存的、带有与新 Pod 匹配的
硬性亲和性设置的 Pod 计算亲和性得分。
</td>
</tr>
</tbody>
</table>
<h2 id=kubescheduler-config-k8s-io-v1beta2-KubeSchedulerConfiguration><code>KubeSchedulerConfiguration</code> </h2>
<p>KubeSchedulerConfiguration 用来配置调度器。</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>apiVersion</code><br>string</td><td><code>kubescheduler.config.k8s.io/v1beta2</code></td></tr>
<tr><td><code>kind</code><br>string</td><td><code>KubeSchedulerConfiguration</code></td></tr>
<tr><td><code>parallelism</code> <b>[必需]</b><br>
<code>int32</code>
</td>
<td>
此字段设置为调度 Pod 而执行算法时的并发度。此值必须大于 0。
默认值为 16。
</td>
</tr>
<tr><td><code>leaderElection</code> <b>[必需]</b><br>
<a href=#LeaderElectionConfiguration><code>LeaderElectionConfiguration</code></a>
</td>
<td>
此字段用来定义领导者选举客户端的配置。
</td>
</tr>
<tr><td><code>clientConnection</code> <b>[必需]</b><br>
<a href=#ClientConnectionConfiguration><code>ClientConnectionConfiguration</code></a>
</td>
<td>
此字段为与 API 服务器通信时使用的代理服务器设置 kubeconfig 文件和客户端
连接配置。
</td>
</tr>
<tr><td><code>healthzBindAddress</code> <b>[必需]</b><br>
<code>string</code>
</td>
<td>
<code>healthzBindAddress</code> 是健康检查服务器提供服务所用的 IP 地址和端口。
注意：<code>healthzBindAddress</code> 和 <code>metricsBindAddress</code>
这两个字段都已被弃用。
只可以设置空地址或者端口 0。其他设置值都无法通过合法性检查。
</td>
</tr>
<tr><td><code>metricsBindAddress</code> <b>[必需]</b><br>
<code>string</code>
</td>
<td>
<code>metricsBindAddress</code> 是度量值服务器提供服务所用的 IP 地址和端口。
</td>
</tr>
<tr><td><code>DebuggingConfiguration</code> <b>[必需]</b><br>
<a href=#DebuggingConfiguration><code>DebuggingConfiguration</code></a>
</td>
<td>（<code>DebuggingConfiguration</code> 的成员被内嵌到此类型中）
此字段设置与调试相关功能特性的配置。
</td>
</tr>
<tr><td><code>percentageOfNodesToScore</code> <b>[必需]</b><br>
<code>int32</code>
</td>
<td>
此字段为所有节点的百分比，一旦调度器找到所设置比例的、能够运行 Pod 的节点，
则停止在集群中继续寻找更合适的节点。这一配置有助于提高调度器的性能。调度器
总会尝试寻找至少 "minFeasibleNodesToFind" 个可行节点，无论此字段的取值如何。
例如：当集群规模为 500 个节点，而此字段的取值为 30，则调度器在找到 150 个合适
的节点后会停止继续寻找合适的节点。当此值为 0 时，调度器会使用默认节点数百分比（基于集群规模
确定的值，在 5% 到 50% 之间）来执行打分操作。
</td>
</tr>
<tr><td><code>podInitialBackoffSeconds</code> <b>[必需]</b><br>
<code>int64</code>
</td>
<td>
此字段设置不可调度 Pod 的初始回退秒数。如果设置了此字段，其取值必须大于零。
若此值为 null，则使用默认值（1s）。
</td>
</tr>
<tr><td><code>podMaxBackoffSeconds</code> <b>[必需]</b><br>
<code>int64</code>
</td>
<td>
此字段设置不可调度的 Pod 的最大回退秒数。如果设置了此字段，则其值必须大于
podInitialBackoffSeconds 字段值。如果此值设置为 null，则使用默认值（10s）。
</td>
</tr>
<tr><td><code>profiles</code> <b>[必需]</b><br>
<a href=#kubescheduler-config-k8s-io-v1beta2-KubeSchedulerProfile><code>[]KubeSchedulerProfile</code></a>
</td>
<td>
此字段为 kube-scheduler 所支持的方案（profiles）。Pod 可以通过设置其对应
的调度器名称来选择使用特定的方案。未指定调度器名称的 Pod 会使用
“default-scheduler”方案来调度，如果存在的话。
</td>
</tr>
<tr><td><code>extenders</code> <b>[必需]</b><br>
<a href=#kubescheduler-config-k8s-io-v1beta2-Extender><code>[]Extender</code></a>
</td>
<td>
此字段为调度器扩展模块（Extender）的列表，每个元素包含如何与某扩展模块
通信的配置信息。所有调度器模仿会共享此扩展模块列表。
</td>
</tr>
</tbody>
</table>
<h2 id=kubescheduler-config-k8s-io-v1beta2-NodeAffinityArgs><code>NodeAffinityArgs</code> </h2>
<p>NodeAffinityArgs 中包含配置 NodeAffinity 插件的参数。</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>apiVersion</code><br>string</td><td><code>kubescheduler.config.k8s.io/v1beta2</code></td></tr>
<tr><td><code>kind</code><br>string</td><td><code>NodeAffinityArgs</code></td></tr>
<tr><td><code>addedAffinity</code><br>
<a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/#nodeaffinity-v1-core><code>core/v1.NodeAffinity</code></a>
</td>
<td>
<code>addedAffinity</code> 会作为附加的亲和性属性添加到所有 Pod 的
规约中指定的 NodeAffinity 中。换言之，节点需要同时满足 addedAffinity
和 .spec.nodeAffinity。默认情况下，addedAffinity 为空（与所有节点匹配）。
使用了 addedAffinity 时，某些带有已经能够与某特定节点匹配的亲和性需求
的 Pod （例如 DaemonSet Pod）可能会继续呈现不可调度状态。
</td>
</tr>
</tbody>
</table>
<h2 id=kubescheduler-config-k8s-io-v1beta2-NodeResourcesBalancedAllocationArgs><code>NodeResourcesBalancedAllocationArgs</code> </h2>
<p>NodeResourcesBalancedAllocationArgs 包含用来配置 NodeResourcesBalancedAllocation 插件的参数。</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>apiVersion</code><br>string</td><td><code>kubescheduler.config.k8s.io/v1beta2</code></td></tr>
<tr><td><code>kind</code><br>string</td><td><code>NodeResourcesBalancedAllocationArgs</code></td></tr>
<tr><td><code>resources</code> <b>[必需]</b><br>
<a href=#kubescheduler-config-k8s-io-v1beta2-ResourceSpec><code>[]ResourceSpec</code></a>
</td>
<td>
要管理的资源；如果未设置，则默认值为 "cpu" 和 "memory"。
</td>
</tr>
</tbody>
</table>
<h2 id=kubescheduler-config-k8s-io-v1beta2-NodeResourcesFitArgs><code>NodeResourcesFitArgs</code> </h2>
<p>NodeResourcesFitArgs 包含用来配置 NodeResourcesFit 插件的参数。</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>apiVersion</code><br>string</td><td><code>kubescheduler.config.k8s.io/v1beta2</code></td></tr>
<tr><td><code>kind</code><br>string</td><td><code>NodeResourcesFitArgs</code></td></tr>
<tr><td><code>ignoredResources</code> <b>[必需]</b><br>
<code>[]string</code>
</td>
<td>
此字段为 NodeResources 匹配过滤器要忽略的资源列表。此列表不影响节点打分。
</td>
</tr>
<tr><td><code>ignoredResourceGroups</code> <b>[必需]</b><br>
<code>[]string</code>
</td>
<td>
此字段定义 NodeResources 匹配过滤器要忽略的资源组列表。
例如，如果配置值为 ["example.com"]，则以 "example.com" 开头的资源名（如
"example.com/aaa" 和 "example.com/bbb"）都会被忽略。
资源组名称中不可以包含 '/'。此设置不影响节点的打分。
</td>
</tr>
<tr><td><code>scoringStrategy</code> <b>[必需]</b><br>
<a href=#kubescheduler-config-k8s-io-v1beta2-ScoringStrategy><code>ScoringStrategy</code></a>
</td>
<td>
此字段用来选择节点资源打分策略。默认的策略为 LeastAllocated，且 "cpu" 和
"memory" 的权重相同。
</td>
</tr>
</tbody>
</table>
<h2 id=kubescheduler-config-k8s-io-v1beta2-PodTopologySpreadArgs><code>PodTopologySpreadArgs</code> </h2>
<p>PodTopologySpreadArgs 包含用来配置 PodTopologySpread 插件的参数。</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>apiVersion</code><br>string</td><td><code>kubescheduler.config.k8s.io/v1beta2</code></td></tr>
<tr><td><code>kind</code><br>string</td><td><code>PodTopologySpreadArgs</code></td></tr>
<tr><td><code>defaultConstraints</code><br>
<a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/#topologyspreadconstraint-v1-core><code>[]core/v1.TopologySpreadConstraint</code></a>
</td>
<td>
此字段针对未定义 <code>.spec.topologySpreadConstraints</code> 的 Pod，
为其提供拓扑分布约束。<code>.defaultConstraints[&#8727;].labelSelectors</code>
必须为空，因为这一信息要从 Pod 所属的 Service、ReplicationController、
ReplicaSet 或 StatefulSet 来推导。
此字段不为空时，<code>.defaultingType</code> 必须为 "List"。
</td>
</tr>
<tr><td><code>defaultingType</code><br>
<a href=#kubescheduler-config-k8s-io-v1beta2-PodTopologySpreadConstraintsDefaulting><code>PodTopologySpreadConstraintsDefaulting</code></a>
</td>
<td>
<p>
<code>defaultingType</code> 决定如何推导 <code>.defaultConstraints</code>。
可选值为 "System" 或 "List"。
</p>
<ul>
<li>"System"：使用 Kubernetes 定义的约束，将 Pod 分布到不同节点和可用区；</li>
<li>"List"：使用 <code>.defaultConstraints</code> 中定义的约束。</li>
</ul>
<p>当特性门控 DefaultPodTopologySpread 被禁用时，默认值为 "list"；反之，默认值为 "System"。</p>
</td>
</tr>
</tbody>
</table>
<h2 id=kubescheduler-config-k8s-io-v1beta2-VolumeBindingArgs><code>VolumeBindingArgs</code> </h2>
<p>VolumeBindingArgs 包含用来配置 VolumeBinding 插件的参数。</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>apiVersion</code><br>string</td><td><code>kubescheduler.config.k8s.io/v1beta2</code></td></tr>
<tr><td><code>kind</code><br>string</td><td><code>VolumeBindingArgs</code></td></tr>
<tr><td><code>bindTimeoutSeconds</code> <b>[必需]</b><br>
<code>int64</code>
</td>
<td>
此字段设置卷绑定操作的超时秒数。字段值必须是非负数。
取值为 0 意味着不等待。如果此值为 null，则使用默认值（600）。
</td>
</tr>
<tr><td><code>shape</code><br>
<a href=#kubescheduler-config-k8s-io-v1beta2-UtilizationShapePoint><code>[]UtilizationShapePoint</code></a>
</td>
<td>
<p><code>shape</code> 用来设置打分函数曲线所使用的计分点，这些计分点
用来基于静态制备的 PV 卷的利用率为节点打分。
卷的利用率是计算得来的，将 Pod 所请求的总的存储空间大小除以每个节点
上可用的总的卷容量。每个计分点包含利用率（范围从 0 到 100）和其对应
的得分（范围从 0 到 10）。你可以通过为不同的使用率值设置不同的得分来
反转优先级：</p>
<p>默认的曲线计分点为：</p>
<ul>
<li>利用率为 0 时得分为 0；</li>
<li>利用率为 100 时得分为 10。</li>
</ul>
<p>所有计分点必须按利用率值的升序来排序。</p>
</td>
</tr>
</tbody>
</table>
<h2 id=kubescheduler-config-k8s-io-v1beta2-Extender><code>Extender</code> </h2>
<p><strong>出现在：</strong></p>
<ul>
<li><a href=#kubescheduler-config-k8s-io-v1beta2-KubeSchedulerConfiguration>KubeSchedulerConfiguration</a></li>
</ul>
<p>Extender 包含与扩展模块（Extender）通信所用的参数。
如果未指定 verb 或者 verb 为空，则假定对应的扩展模块选择不提供该扩展功能。</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>urlPrefix</code> <b>[必需]</b><br>
<code>string</code>
</td>
<td>
用来访问扩展模块的 URL 前缀。
</td>
</tr>
<tr><td><code>filterVerb</code> <b>[必需]</b><br>
<code>string</code>
</td>
<td>
filter 调用所使用的动词，如果不支持过滤操作则为空。
此动词会在向扩展模块发送 filter 调用时追加到 urlPrefix 后面。
</td>
</tr>
<tr><td><code>preemptVerb</code> <b>[必需]</b><br>
<code>string</code>
</td>
<td>
preempt 调用所使用的动词，如果不支持抢占操作则为空。
此动词会在向扩展模块发送 preempt 调用时追加到 urlPrefix 后面。
</td>
</tr>
<tr><td><code>prioritizeVerb</code> <b>[必需]</b><br>
<code>string</code>
</td>
<td>
prioritize 调用所使用的动词，如果不支持 prioritize 操作则为空。
此动词会在向扩展模块发送 prioritize 调用时追加到 urlPrefix 后面。
</td>
</tr>
<tr><td><code>weight</code> <b>[必需]</b><br>
<code>int64</code>
</td>
<td>
针对 prioritize 调用所生成的节点分数要使用的数值系数。
weight 值必须是正整数。
</td>
</tr>
<tr><td><code>bindVerb</code> <b>[必需]</b><br>
<code>string</code>
</td>
<td>
bind 调用所使用的动词，如果不支持 bind 操作则为空。
此动词会在向扩展模块发送 bind 调用时追加到 urlPrefix 后面。
如果扩展模块实现了此方法，扩展模块要负责将 Pod 绑定到 API 服务器。
只有一个扩展模块可以实现此函数。
</td>
</tr>
<tr><td><code>enableHTTPS</code> <b>[必需]</b><br>
<code>bool</code>
</td>
<td>
此字段设置是否需要使用 HTTPS 来与扩展模块通信。
</td>
</tr>
<tr><td><code>tlsConfig</code> <b>[必需]</b><br>
<a href=#kubescheduler-config-k8s-io-v1beta2-ExtenderTLSConfig><code>ExtenderTLSConfig</code></a>
</td>
<td>
此字段设置传输层安全性（TLS）配置。
</td>
</tr>
<tr><td><code>httpTimeout</code> <b>[必需]</b><br>
<a href=https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Duration><code>meta/v1.Duration</code></a>
</td>
<td>
此字段给出扩展模块功能调用的超时值。filter 操作超时会导致 Pod 无法被调度。
prioritize 操作超时会被忽略，Kubernetes 或者其他扩展模块所给出的优先级值
会被用来选择节点。
</td>
</tr>
<tr><td><code>nodeCacheCapable</code> <b>[必需]</b><br>
<code>bool</code>
</td>
<td>
此字段指示扩展模块可以缓存节点信息，从而调度器应该发送关于可选节点的最少信息，
假定扩展模块已经缓存了集群中所有节点的全部详细信息。
</td>
</tr>
<tr><td><code>managedResources</code><br>
<a href=#kubescheduler-config-k8s-io-v1beta2-ExtenderManagedResource><code>[]ExtenderManagedResource</code></a>
</td>
<td>
<p><code>managedResources</code> 是一个由此扩展模块所管理的扩展资源的列表。</p>
<ul>
<li>如果某 Pod 请求了此列表中的至少一个扩展资源，则 Pod 会在 filter、
prioritize 和 bind （如果扩展模块可以执行绑定操作）阶段被发送到该扩展模块。
若此字段为空或未设置，则所有 Pod 都会发送到此扩展模块。</li>
<li>如果某资源上设置了 <code>ignoredByScheduler</code> 为 true，则 kube-scheduler
会在断言阶段略过对该资源的检查。</li>
</ul>
</td>
</tr>
<tr><td><code>ignorable</code> <b>[必需]</b><br>
<code>bool</code>
</td>
<td>
此字段用来设置扩展模块是否是可忽略的。换言之，当扩展模块返回错误或者
完全不可达时，调度操作不应失败。
</td>
</tr>
</tbody>
</table>
<h2 id=kubescheduler-config-k8s-io-v1beta2-ExtenderManagedResource><code>ExtenderManagedResource</code> </h2>
<p><strong>出现在：</strong></p>
<ul>
<li><a href=#kubescheduler-config-k8s-io-v1beta2-Extender>Extender</a></li>
</ul>
<p>ExtenderManagedResource 描述某扩展模块所管理的扩展资源的参数。</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>name</code> <b>[必需]</b><br>
<code>string</code>
</td>
<td>
扩展资源的名称。
</td>
</tr>
<tr><td><code>ignoredByScheduler</code> <b>[必需]</b><br>
<code>bool</code>
</td>
<td>
此字段标明 kube-scheduler 是否应在应用断言时忽略此资源。
</td>
</tr>
</tbody>
</table>
<h2 id=kubescheduler-config-k8s-io-v1beta2-ExtenderTLSConfig><code>ExtenderTLSConfig</code> </h2>
<p><strong>出现在：</strong></p>
<ul>
<li><a href=#kubescheduler-config-k8s-io-v1beta2-Extender>Extender</a></li>
</ul>
<p>ExtenderTLSConfig 包含启用与扩展模块间 TLS 传输所需的配置参数。</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>insecure</code> <b>[必需]</b><br>
<code>bool</code>
</td>
<td>
访问服务器时不需要检查 TLS 证书。此配置仅针对测试用途。
</td>
</tr>
<tr><td><code>serverName</code> <b>[必需]</b><br>
<code>string</code>
</td>
<td>
<code>serverName</code> 会被发送到服务器端，作为 SNI 标志；客户端会使用
此设置来检查服务器证书。如果 <code>serverName</code> 为空，则会使用联系
服务器时所用的主机名。
</td>
</tr>
<tr><td><code>certFile</code> <b>[必需]</b><br>
<code>string</code>
</td>
<td>
服务器端所要求的 TLS 客户端证书认证。
</td>
</tr>
<tr><td><code>keyFile</code> <b>[必需]</b><br>
<code>string</code>
</td>
<td>
服务器端所要求的 TLS 客户端秘钥认证。
</td>
</tr>
<tr><td><code>caFile</code> <b>[必需]</b><br>
<code>string</code>
</td>
<td>
服务器端可信任的根证书。
</td>
</tr>
<tr><td><code>certData</code> <b>[必需]</b><br>
<code>[]byte</code>
</td>
<td>
<code>certData</code> 包含 PEM 编码的字节流（通常从某客户端证书文件读入）。
此字段优先级高于 certFile 字段。
</td>
</tr>
<tr><td><code>keyData</code> <b>[必需]</b><br>
<code>[]byte</code>
</td>
<td>
<code>keyData</code> 包含 PEM 编码的字节流（通常从某客户端证书秘钥文件读入）。
此字段优先级高于 keyFile 字段。
</td>
</tr>
<tr><td><code>caData</code> <b>[必需]</b><br>
<code>[]byte</code>
</td>
<td>
<code>caData</code> 包含 PEM 编码的字节流（通常从某根证书包文件读入）。
此字段优先级高于 caFile 字段。
</td>
</tr>
</tbody>
</table>
<h2 id=kubescheduler-config-k8s-io-v1beta2-KubeSchedulerProfile><code>KubeSchedulerProfile</code> </h2>
<p><strong>出现在：</strong></p>
<ul>
<li><a href=#kubescheduler-config-k8s-io-v1beta2-KubeSchedulerConfiguration>KubeSchedulerConfiguration</a></li>
</ul>
<p>KubeSchedulerProfile 是一个调度方案。</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>schedulerName</code> <b>[必需]</b><br>
<code>string</code>
</td>
<td>
<code>schedulerName</code> 是与此调度方案相关联的调度器的名称。
如果 <code>schedulerName</code> 与 Pod 的 <code>spec.schedulerName</code>
匹配，则该 Pod 会使用此方案来调度。
</td>
</tr>
<tr><td><code>plugins</code> <b>[必需]</b><br>
<a href=#kubescheduler-config-k8s-io-v1beta2-Plugins><code>Plugins</code></a>
</td>
<td>
<p><code>plugins</code> 设置一组应该被启用或禁止的插件。
被启用的插件是指除了默认插件之外需要被启用的插件。被禁止的插件
是指需要被禁用的默认插件。</p>
<p>如果针对某个扩展点没有设置被启用或被禁止的插件，则使用该扩展点
的默认插件（如果有的话）。如果设置了 QueueSort 插件，则同一个 QueueSort
插件和 <code>pluginConfig</code> 要被设置到所有调度方案之上。</p>
</td>
</tr>
<tr><td><code>pluginConfig</code> <b>[必需]</b><br>
<a href=#kubescheduler-config-k8s-io-v1beta2-PluginConfig><code>[]PluginConfig</code></a>
</td>
<td>
<code>pluginConfig</code> 是为每个插件提供的一组可选的定制插件参数。
如果忽略了插件的配置参数，则意味着使用该插件的默认配置。
</td>
</td>
</tr>
</tbody>
</table>
<h2 id=kubescheduler-config-k8s-io-v1beta2-Plugin><code>Plugin</code> </h2>
<p><strong>出现在：</strong></p>
<ul>
<li><a href=#kubescheduler-config-k8s-io-v1beta2-PluginSet>PluginSet</a></li>
</ul>
<p>Plugin 指定插件的名称及其权重（如果适用的话）。权重仅用于评分（Score）插件。</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>name</code> <b>[必需]</b><br>
<code>string</code>
</td>
<td>
插件的名称。
</td>
</tr>
<tr><td><code>weight</code> <b>[必需]</b><br>
<code>int32</code>
</td>
<td>
插件的权重；仅适用于评分（Score）插件。
</td>
</tr>
</tbody>
</table>
<h2 id=kubescheduler-config-k8s-io-v1beta2-PluginConfig><code>PluginConfig</code> </h2>
<p><strong>出现在：</strong></p>
<ul>
<li><a href=#kubescheduler-config-k8s-io-v1beta2-KubeSchedulerProfile>KubeSchedulerProfile</a></li>
</ul>
<p>PluginConfig 给出初始化阶段要传递给插件的参数。
在多个扩展点被调用的插件仅会被初始化一次。
参数可以是任意结构。插件负责处理这里所传的参数。</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>name</code> <b>[必需]</b><br>
<code>string</code>
</td>
<td>
<code>name</code> 是所配置的插件的名称。
</td>
</tr>
<tr><td><code>args</code> <b>[必需]</b><br>
<a href=https://godoc.org/k8s.io/apimachinery/pkg/runtime/#RawExtension><code>k8s.io/apimachinery/pkg/runtime.RawExtension</code></a>
</td>
<td>
<code>args</code> 定义在初始化阶段要传递给插件的参数。参数可以为任意结构。
</td>
</tr>
</tbody>
</table>
<h2 id=kubescheduler-config-k8s-io-v1beta2-PluginSet><code>PluginSet</code> </h2>
<p><strong>出现在：</strong></p>
<ul>
<li><a href=#kubescheduler-config-k8s-io-v1beta2-Plugins>Plugins</a></li>
</ul>
<p>PluginSet 为某扩展点设置要启用或禁用的插件。
如果数组为空，或者取值为 null，则使用该扩展点的默认插件集合。</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>enabled</code> <b>[必需]</b><br>
<a href=#kubescheduler-config-k8s-io-v1beta2-Plugin><code>[]Plugin</code></a>
</td>
<td>
<code>enabled</code> 设置在默认插件之外要启用的插件。如果在调度器的配置
文件中也配置了默认插件，则对应插件的权重会被覆盖。
此处所设置的插件会在默认插件之后被调用，调用顺序与数组中元素顺序相同。
</td>
</tr>
<tr><td><code>disabled</code> <b>[必需]</b><br>
<a href=#kubescheduler-config-k8s-io-v1beta2-Plugin><code>[]Plugin</code></a>
</td>
<td>
<code>disabled</code> 设置要被禁用的默认插件。
如果需要禁用所有的默认插件，应该提供仅包含一个元素 "&#8727;" 的数组。
</td>
</tr>
</tbody>
</table>
<h2 id=kubescheduler-config-k8s-io-v1beta2-Plugins><code>Plugins</code> </h2>
<p><strong>出现在：</strong></p>
<ul>
<li><a href=#kubescheduler-config-k8s-io-v1beta2-KubeSchedulerProfile>KubeSchedulerProfile</a></li>
</ul>
<p>Plugins 结构中包含多个扩展点。当此结构被设置时，针对特定扩展点所启用
的所有插件都在这一列表中。
如果配置中不包含某个扩展点，则使用该扩展点的默认插件集合。
被启用的插件的调用顺序与这里指定的顺序相同，都在默认插件之后调用。
如果它们需要在默认插件之前调用，则需要先行禁止默认插件，之后在这里
按期望的顺序重新启用。</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>queueSort</code> <b>[必需]</b><br>
<a href=#kubescheduler-config-k8s-io-v1beta2-PluginSet><code>PluginSet</code></a>
</td>
<td>
<code>queueSort</code> 是一个在对调度队列中 Pod 排序时要调用的插件列表。
</td>
</tr>
<tr><td><code>preFilter</code> <b>[必需]</b><br>
<a href=#kubescheduler-config-k8s-io-v1beta2-PluginSet><code>PluginSet</code></a>
</td>
<td>
<code>preFilter</code> 是一个在调度框架中“PreFilter（预过滤）”扩展点上要
调用的插件列表。
</td>
</tr>
<tr><td><code>filter</code> <b>[必需]</b><br>
<a href=#kubescheduler-config-k8s-io-v1beta2-PluginSet><code>PluginSet</code></a>
</td>
<td>
<code>filter</code> 是一个在需要过滤掉无法运行 Pod 的节点时被调用的插件列表。
</td>
</tr>
<tr><td><code>postFilter</code> <b>[必需]</b><br>
<a href=#kubescheduler-config-k8s-io-v1beta2-PluginSet><code>PluginSet</code></a>
</td>
<td>
<code>postFilter</code> 是一个在过滤阶段结束后会被调用的插件列表；
这里的插件只有在找不到合适的节点来运行 Pod 时才会被调用。
</td>
</tr>
<tr><td><code>preScore</code> <b>[必需]</b><br>
<a href=#kubescheduler-config-k8s-io-v1beta2-PluginSet><code>PluginSet</code></a>
</td>
<td>
<code>preScore</code> 是一个在打分之前要调用的插件列表。
</td>
</tr>
<tr><td><code>score</code> <b>[必需]</b><br>
<a href=#kubescheduler-config-k8s-io-v1beta2-PluginSet><code>PluginSet</code></a>
</td>
<td>
<code>score</code> 是一个在对已经通过过滤阶段的节点进行排序时调用的插件的列表。
</td>
</tr>
<tr><td><code>reserve</code> <b>[必需]</b><br>
<a href=#kubescheduler-config-k8s-io-v1beta2-PluginSet><code>PluginSet</code></a>
</td>
<td>
<code>reserve</code> 是一组在运行 Pod 的节点已被选定后，需要预留或者释放资源时调用的插件的列表。
</td>
</tr>
<tr><td><code>permit</code> <b>[必需]</b><br>
<a href=#kubescheduler-config-k8s-io-v1beta2-PluginSet><code>PluginSet</code></a>
</td>
<td>
<code>permit</code> 是一个用来控制 Pod 绑定关系的插件列表。这些插件可以
禁止或者延迟 Pod 的绑定。
</td>
</tr>
<tr><td><code>preBind</code> <b>[必需]</b><br>
<a href=#kubescheduler-config-k8s-io-v1beta2-PluginSet><code>PluginSet</code></a>
</td>
<td>
<code>preBind</code> 是一个在 Pod 被绑定到某节点之前要被调用的插件的列表。
</td>
</tr>
<tr><td><code>bind</code> <b>[必需]</b><br>
<a href=#kubescheduler-config-k8s-io-v1beta2-PluginSet><code>PluginSet</code></a>
</td>
<td>
<code>bind</code> 是一个在调度框架中“Bind（绑定）”扩展点上要调用的
插件的列表。调度器按顺序调用这些插件。只要其中某个插件返回成功，则调度器
就略过余下的插件。
</td>
</tr>
<tr><td><code>postBind</code> <b>[必需]</b><br>
<a href=#kubescheduler-config-k8s-io-v1beta2-PluginSet><code>PluginSet</code></a>
</td>
<td>
<code>postBind</code> 是一个在 Pod 已经被成功绑定之后要调用的插件的列表。
</td>
</tr>
<tr><td><code>multiPoint</code> <b>[必需]</b><br>
<a href=#kubescheduler-config-k8s-io-v1beta2-PluginSet><code>PluginSet</code></a>
</td>
<td>
<p><code>multiPoint</code> 是一个简化的配置段落，用来为所有合法的扩展点启用插件。
</td>
</tr>
</tbody>
</table>
<h2 id=kubescheduler-config-k8s-io-v1beta2-PodTopologySpreadConstraintsDefaulting><code>PodTopologySpreadConstraintsDefaulting</code> </h2>
<p>（<code>string</code> 类型的别名）</p>
<p><strong>出现在：</strong></p>
<ul>
<li><a href=#kubescheduler-config-k8s-io-v1beta2-PodTopologySpreadArgs>PodTopologySpreadArgs</a></li>
</ul>
<p>PodTopologySpreadConstraintsDefaulting 定义如何为 PodTopologySpread 插件
设置默认的约束。</p>
<h2 id=kubescheduler-config-k8s-io-v1beta2-RequestedToCapacityRatioParam><code>RequestedToCapacityRatioParam</code> </h2>
<p><strong>出现在：</strong></p>
<ul>
<li><a href=#kubescheduler-config-k8s-io-v1beta2-ScoringStrategy>ScoringStrategy</a></li>
</ul>
<p>RequestedToCapacityRatioParam 结构定义 RequestedToCapacityRatio 的参数。</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>shape</code> <b>[必需]</b><br>
<a href=#kubescheduler-config-k8s-io-v1beta2-UtilizationShapePoint><code>[]UtilizationShapePoint</code></a>
</td>
<td>
<code>shape</code> 是一个定义评分函数曲线的计分点的列表。
</td>
</tr>
</tbody>
</table>
<h2 id=kubescheduler-config-k8s-io-v1beta2-ResourceSpec><code>ResourceSpec</code> </h2>
<p><strong>出现在：</strong></p>
<ul>
<li><a href=#kubescheduler-config-k8s-io-v1beta2-NodeResourcesBalancedAllocationArgs>NodeResourcesBalancedAllocationArgs</a></li>
<li><a href=#kubescheduler-config-k8s-io-v1beta2-ScoringStrategy>ScoringStrategy</a></li>
</ul>
<p>ResourceSpec 用来代表某个资源。</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>name</code> <b>[必需]</b><br>
<code>string</code>
</td>
<td>
资源名称。
</td>
</tr>
<tr><td><code>weight</code> <b>[必需]</b><br>
<code>int64</code>
</td>
<td>
资源权重。
</td>
</tr>
</tbody>
</table>
<h2 id=kubescheduler-config-k8s-io-v1beta2-ScoringStrategy><code>ScoringStrategy</code> </h2>
<p><strong>出现在：</strong></p>
<ul>
<li><a href=#kubescheduler-config-k8s-io-v1beta2-NodeResourcesFitArgs>NodeResourcesFitArgs</a></li>
</ul>
<p>ScoringStrategy 为节点资源插件定义 ScoringStrategyType。</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>type</code> <b>[必需]</b><br>
<a href=#kubescheduler-config-k8s-io-v1beta2-ScoringStrategyType><code>ScoringStrategyType</code></a>
</td>
<td>
<code>type</code> 用来选择要运行的策略。
</td>
</tr>
<tr><td><code>resources</code> <b>[必需]</b><br>
<a href=#kubescheduler-config-k8s-io-v1beta2-ResourceSpec><code>[]ResourceSpec</code></a>
</td>
<td>
<p><code>resources</code> 设置在评分时要考虑的资源。</p>
<p>默认的资源集合包含 "cpu" 和 "memory"，且二者权重相同。</p>
<p>权重的取值范围为 1 到 100。</p>
<p>当权重未设置或者显式设置为 0 时，意味着使用默认值 1。</p>
</td>
</tr>
<tr><td><code>requestedToCapacityRatio</code> <b>[必需]</b><br>
<a href=#kubescheduler-config-k8s-io-v1beta2-RequestedToCapacityRatioParam><code>RequestedToCapacityRatioParam</code></a>
</td>
<td>
特定于 RequestedToCapacityRatio 策略的参数。
</td>
</tr>
</tbody>
</table>
<h2 id=kubescheduler-config-k8s-io-v1beta2-ScoringStrategyType><code>ScoringStrategyType</code> </h2>
<p>（<code>string</code> 数据类型的别名）</p>
<p><strong>出现在：</strong></p>
<ul>
<li><a href=#kubescheduler-config-k8s-io-v1beta2-ScoringStrategy>ScoringStrategy</a></li>
</ul>
<p>ScoringStrategyType 是 NodeResourcesFit 插件所使用的的评分策略类型。</p>
<h2 id=kubescheduler-config-k8s-io-v1beta2-UtilizationShapePoint><code>UtilizationShapePoint</code> </h2>
<p><strong>出现在：</strong></p>
<ul>
<li><a href=#kubescheduler-config-k8s-io-v1beta2-VolumeBindingArgs>VolumeBindingArgs</a></li>
<li><a href=#kubescheduler-config-k8s-io-v1beta2-RequestedToCapacityRatioParam>RequestedToCapacityRatioParam</a></li>
</ul>
<p>UtilizationShapePoint 代表的是优先级函数曲线中的一个评分点。</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>utilization</code> <b>[必需]</b><br>
<code>int32</code>
</td>
<td>
利用率（x 轴）。合法值为 0 到 100。完全被利用的节点映射到 100。
</td>
</tr>
<tr><td><code>score</code> <b>[必需]</b><br>
<code>int32</code>
</td>
<td>
分配给指定利用率的分值（y 轴）。合法值为 0 到 10。
</td>
</tr>
</tbody>
</table>
<h2 id=ClientConnectionConfiguration><code>ClientConnectionConfiguration</code> </h2>
<p><strong>出现在：</strong></p>
<ul>
<li><a href=#kubescheduler-config-k8s-io-v1beta2-KubeSchedulerConfiguration>KubeSchedulerConfiguration</a></li>
</ul>
<p>ClientConnectionConfiguration 中包含用来构造一个客户端所需的细节。</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>kubeconfig</code> <b>[必需]</b><br>
<code>string</code>
</td>
<td>
此字段为指向某 KubeConfig 文件的路径。
</td>
</tr>
<tr><td><code>acceptContentTypes</code> <b>[必需]</b><br>
<code>string</code>
</td>
<td>
<code>acceptContentTypes</code> 定义的是客户端与服务器建立连接时要发送的
Accept 头部；这里的设置值会覆盖默认值 "application/json"。
此字段会影响某特定客户端与服务器的所有连接。
</td>
</tr>
<tr><td><code>contentType</code> <b>[必需]</b><br>
<code>string</code>
</td>
<td>
<code>contentType</code> 包含的是此客户端向服务器发送数据时使用的
内容类型（Content Type）。
</td>
</tr>
<tr><td><code>qps</code> <b>[必需]</b><br>
<code>float32</code>
</td>
<td>
<code>qps</code> 控制的是此连接上每秒可以发送的查询个数。
</td>
</tr>
<tr><td><code>burst</code> <b>[必需]</b><br>
<code>int32</code>
</td>
<td>
<code>burst</code> 允许在客户端超出其速率限制时可以累积的额外查询个数。
</td>
</tr>
</tbody>
</table>
<h2 id=DebuggingConfiguration><code>DebuggingConfiguration</code> </h2>
<p><strong>出现在：</strong></p>
<ul>
<li><a href=#kubescheduler-config-k8s-io-v1beta2-KubeSchedulerConfiguration>KubeSchedulerConfiguration</a></li>
</ul>
<p>DebuggingConfiguration 保存与调试功能相关的配置。</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>enableProfiling</code> <b>[必需]</b><br>
<code>bool</code>
</td>
<td>
此字段允许通过 Web 接口 host:port/debug/pprof/ 执行性能分析。
</td>
</tr>
<tr><td><code>enableContentionProfiling</code> <b>[必需]</b><br>
<code>bool</code>
</td>
<td>
此字段在 <code>enableProfiling</code> 为 true 时允许执行锁竞争分析。
</td>
</tr>
</tbody>
</table>
<h2 id=FormatOptions><code>FormatOptions</code> </h2>
<p>FormatOptions 中包含不同日志格式的配置选项。</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>json</code> <b>[必需]</b><br>
<a href=#JSONOptions><code>JSONOptions</code></a>
</td>
<td>
[实验特性] <code>json</code> 字段包含为 "json" 日志格式提供的配置选项。
</td>
</tr>
</tbody>
</table>
<h2 id=JSONOptions><code>JSONOptions</code> </h2>
<p><strong>出现在：</strong></p>
<ul>
<li><a href=#FormatOptions>FormatOptions</a></li>
</ul>
<p>JSONOptions 包含为 "json" 日志格式所设置的配置选项。</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>splitStream</code> <b>[必需]</b><br>
<code>bool</code>
</td>
<td>
[实验特性] 此字段将错误信息重定向到标准错误输出（stderr），将提示消息
重定向到标准输出（stdout），并且支持缓存。默认配置为将二者都输出到
标准输出（stdout），且不提供缓存。
</td>
</tr>
<tr><td><code>infoBufferSize</code> <b>[必需]</b><br>
<a href=https://pkg.go.dev/k8s.io/apimachinery/pkg/api/resource#QuantityValue><code>k8s.io/apimachinery/pkg/api/resource.QuantityValue</code></a>
</td>
<td>
[实验特性] <code>infoBufferSize</code> 用来在分离数据流场景是设置提示
信息数据流的大小。默认值为 0，意味着禁止缓存。
</td>
</tr>
</tbody>
</table>
<h2 id=LeaderElectionConfiguration><code>LeaderElectionConfiguration</code> </h2>
<p><strong>出现在：</strong></p>
<ul>
<li><a href=#kubescheduler-config-k8s-io-v1beta2-KubeSchedulerConfiguration>KubeSchedulerConfiguration</a></li>
</ul>
<p>LeaderElectionConfiguration 为能够支持领导者选举的组件定义其领导者选举
客户端的配置。</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>leaderElect</code> <b>[必需]</b><br>
<code>bool</code>
</td>
<td>
<code>leaderElect</code> 启用领导者选举客户端，从而在进入主循环执行之前
先要获得领导者角色。当运行多副本组件时启用此功能有助于提高可用性。
</td>
</tr>
<tr><td><code>leaseDuration</code> <b>[必需]</b><br>
<a href=https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Duration><code>meta/v1.Duration</code></a>
</td>
<td>
<code>leaseDuration</code> 是非领导角色候选者在观察到需要领导席位更新时
要等待的时间；只有经过所设置时长才可以尝试去获得一个仍处于领导状态但需要
被刷新的席位。这里的设置值本质上意味着某个领导者在被另一个候选者替换掉
之前可以停止运行的最长时长。只有当启用了领导者选举时此字段有意义。
</td>
</tr>
<tr><td><code>renewDeadline</code> <b>[必需]</b><br>
<a href=https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Duration><code>meta/v1.Duration</code></a>
</td>
<td>
<code>renewDeadline</code> 设置的是当前领导者在停止扮演领导角色之前
需要刷新领导状态的时间间隔。此值必须小于或等于租约期限的长度。
只有到启用了领导者选举时此字段才有意义。
</td>
</tr>
<tr><td><code>retryPeriod</code> <b>[必需]</b><br>
<a href=https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Duration><code>meta/v1.Duration</code></a>
</td>
<td>
<code>retryPeriod</code> 是客户端在连续两次尝试获得或者刷新领导状态
之间需要等待的时长。只有当启用了领导者选举时此字段才有意义。
</td>
</tr>
<tr><td><code>resourceLock</code> <b>[必需]</b><br>
<code>string</code>
</td>
<td>
此字段给出在领导者选举期间要作为锁来使用的资源对象类型。
</td>
</tr>
<tr><td><code>resourceName</code> <b>[必需]</b><br>
<code>string</code>
</td>
<td>
此字段给出在领导者选举期间要作为锁来使用的资源对象名称。
</td>
</tr>
<tr><td><code>resourceNamespace</code> <b>[必需]</b><br>
<code>string</code>
</td>
<td>
此字段给出在领导者选举期间要作为锁来使用的资源对象所在名字空间。
</td>
</tr>
</tbody>
</table>
<h2 id=VModuleConfiguration><code>VModuleConfiguration</code> </h2>
<p>（<code>[]k8s.io/component-base/config/v1alpha1.VModuleItem</code> 的别名)</p>
<p>VModuleConfiguration 是一组文件名（通配符）及其对应的日志详尽程度阈值。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-2d4b71a4502f9ff672631862fe08b182>12.7 - kube-scheduler 配置 (v1beta3)</h1>
<h2 id=资源类型>资源类型</h2>
<ul>
<li><a href=#kubescheduler-config-k8s-io-v1beta3-DefaultPreemptionArgs>DefaultPreemptionArgs</a></li>
<li><a href=#kubescheduler-config-k8s-io-v1beta3-InterPodAffinityArgs>InterPodAffinityArgs</a></li>
<li><a href=#kubescheduler-config-k8s-io-v1beta3-KubeSchedulerConfiguration>KubeSchedulerConfiguration</a></li>
<li><a href=#kubescheduler-config-k8s-io-v1beta3-NodeAffinityArgs>NodeAffinityArgs</a></li>
<li><a href=#kubescheduler-config-k8s-io-v1beta3-NodeResourcesBalancedAllocationArgs>NodeResourcesBalancedAllocationArgs</a></li>
<li><a href=#kubescheduler-config-k8s-io-v1beta3-NodeResourcesFitArgs>NodeResourcesFitArgs</a></li>
<li><a href=#kubescheduler-config-k8s-io-v1beta3-PodTopologySpreadArgs>PodTopologySpreadArgs</a></li>
<li><a href=#kubescheduler-config-k8s-io-v1beta3-VolumeBindingArgs>VolumeBindingArgs</a></li>
</ul>
<h2 id=kubescheduler-config-k8s-io-v1beta3-DefaultPreemptionArgs><code>DefaultPreemptionArgs</code> </h2>
<p>DefaultPreemptionArgs 包含用来配置 DefaultPreemption 插件的参数。</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>apiVersion</code><br>string</td><td><code>kubescheduler.config.k8s.io/v1beta3</code></td></tr>
<tr><td><code>kind</code><br>string</td><td><code>DefaultPreemptionArgs</code></td></tr>
<tr><td><code>minCandidateNodesPercentage</code> <b>[必需]</b><br>
<code>int32</code>
</td>
<td>
此字段为试运行抢占时 shortlist 中候选节点数的下限，数值为节点数的百分比。
字段值必须介于 [0, 100] 之间。未指定时默认值为整个集群规模的 10%。
</td>
</tr>
<tr><td><code>minCandidateNodesAbsolute</code> <b>[必需]</b><br>
<code>int32</code>
</td>
<td>
此字段设置 shortlist 中候选节点的绝对下限。用于试运行抢占而列举的
候选节点个数近似于通过下面的公式计算的：<br>
候选节点数 = max(节点数 * minCandidateNodesPercentage, minCandidateNodesAbsolute)
之所以说是“近似于”是因为存在一些类似于 PDB 违例这种因素，会影响到进入 shortlist
中候选节点的个数。取值至少为 0 节点。若未设置默认为 100 节点。
</td>
</tr>
</tbody>
</table>
<h2 id=kubescheduler-config-k8s-io-v1beta3-InterPodAffinityArgs><code>InterPodAffinityArgs</code> </h2>
<p>InterPodAffinityArgs 包含用来配置 InterPodAffinity 插件的参数。</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>apiVersion</code><br>string</td><td><code>kubescheduler.config.k8s.io/v1beta3</code></td></tr>
<tr><td><code>kind</code><br>string</td><td><code>InterPodAffinityArgs</code></td></tr>
<tr><td><code>hardPodAffinityWeight</code> <b>[必需]</b><br>
<code>int32</code>
</td>
<td>
此字段是一个计分权重值。针对新增的 Pod，要对现存的、带有与新 Pod 匹配的
硬性亲和性设置的 Pods 计算亲和性得分。
</td>
</tr>
</tbody>
</table>
<h2 id=kubescheduler-config-k8s-io-v1beta3-KubeSchedulerConfiguration><code>KubeSchedulerConfiguration</code> </h2>
<p>KubeSchedulerConfiguration 用来配置调度器。</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>apiVersion</code><br>string</td><td><code>kubescheduler.config.k8s.io/v1beta3</code></td></tr>
<tr><td><code>kind</code><br>string</td><td><code>KubeSchedulerConfiguration</code></td></tr>
<tr><td><code>parallelism</code> <b>[必需]</b><br>
<code>int32</code>
</td>
<td>
此字段设置为调度 Pod 而执行算法时的并发度。此值必须大于 0。
默认值为 16。
</td>
</tr>
<tr><td><code>leaderElection</code> <b>[必需]</b><br>
<a href=#LeaderElectionConfiguration><code>LeaderElectionConfiguration</code></a>
</td>
<td>
此字段用来定义领导者选举客户端的配置。
</td>
</tr>
<tr><td><code>clientConnection</code> <b>[必需]</b><br>
<a href=#ClientConnectionConfiguration><code>ClientConnectionConfiguration</code></a>
</td>
<td>
此字段为与 API 服务器通信时使用的代理服务器设置 kubeconfig 文件和客户端
连接配置。
</td>
</tr>
<tr><td><code>DebuggingConfiguration</code> <b>[必需]</b><br>
<a href=#DebuggingConfiguration><code>DebuggingConfiguration</code></a>
</td>
<td>（<code>DebuggingConfiguration</code> 的成员被内嵌到此类型中）
此字段设置与调试相关功能特性的配置。
</td>
</tr>
<tr><td><code>percentageOfNodesToScore</code> <b>[必需]</b><br>
<code>int32</code>
</td>
<td>
此字段为所有节点的百分比，一旦调度器找到所设置比例的、能够运行 Pod 的节点，
则停止在集群中继续寻找更合适的节点。这一配置有助于提高调度器的性能。调度器
总会尝试寻找至少 "minFeasibleNodesToFind" 个可行节点，无论此字段的取值如何。
例如：当集群规模为 500 个节点，而此字段的取值为 30，则调度器在找到 150 个合适
的节点后会停止继续寻找合适的节点。当此值为 0 时，调度器会使用默认节点数百分比（基于集群规模
确定的值，在 5% 到 50% 之间）来执行打分操作。
</td>
</tr>
<tr><td><code>podInitialBackoffSeconds</code> <b>[必需]</b><br>
<code>int64</code>
</td>
<td>
此字段设置不可调度 Pod 的初始回退秒数。如果设置了此字段，其取值必须大于零。
若此值为 null，则使用默认值（1s）。
</td>
</tr>
<tr><td><code>podMaxBackoffSeconds</code> <b>[必需]</b><br>
<code>int64</code>
</td>
<td>
此字段设置不可调度的 Pod 的最大回退秒数。如果设置了此字段，则其值必须大于
podInitialBackoffSeconds 字段值。如果此值设置为 null，则使用默认值（10s）。
</td>
</tr>
<tr><td><code>profiles</code> <b>[必需]</b><br>
<a href=#kubescheduler-config-k8s-io-v1beta3-KubeSchedulerProfile><code>[]KubeSchedulerProfile</code></a>
</td>
<td>
此字段为 kube-scheduler 所支持的方案（profiles）。Pod 可以通过设置其对应
的调度器名称来选择使用特定的方案。未指定调度器名称的 Pod 会使用
“default-scheduler”方案来调度，如果存在的话。
</td>
</tr>
<tr><td><code>extenders</code> <b>[必需]</b><br>
<a href=#kubescheduler-config-k8s-io-v1beta3-Extender><code>[]Extender</code></a>
</td>
<td>
此字段为调度器扩展模块（Extender）的列表，每个元素包含如何与某扩展模块
通信的配置信息。所有调度器模仿会共享此扩展模块列表。
</td>
</tr>
</tbody>
</table>
<h2 id=kubescheduler-config-k8s-io-v1beta3-NodeAffinityArgs><code>NodeAffinityArgs</code> </h2>
<p>NodeAffinityArgs 中包含配置 NodeAffinity 插件的参数。</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>apiVersion</code><br>string</td><td><code>kubescheduler.config.k8s.io/v1beta3</code></td></tr>
<tr><td><code>kind</code><br>string</td><td><code>NodeAffinityArgs</code></td></tr>
<tr><td><code>addedAffinity</code><br>
<a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/#nodeaffinity-v1-core><code>core/v1.NodeAffinity</code></a>
</td>
<td>
<code>addedAffinity</code> 会作为附加的亲和性属性添加到所有 Pod 的
规约中指定的 NodeAffinity 中。换言之，节点需要同时满足 addedAffinity
和 .spec.nodeAffinity。默认情况下，addedAffinity 为空（与所有节点匹配）。
使用了 addedAffinity 时，某些带有已经能够与某特定节点匹配的亲和性需求
的 Pod （例如 DaemonSet Pod）可能会继续呈现不可调度状态。
</td>
</tr>
</tbody>
</table>
<h2 id=kubescheduler-config-k8s-io-v1beta3-NodeResourcesBalancedAllocationArgs><code>NodeResourcesBalancedAllocationArgs</code> </h2>
<p>NodeResourcesBalancedAllocationArgs 包含用来配置 NodeResourcesBalancedAllocation 插件的参数。</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>apiVersion</code><br>string</td><td><code>kubescheduler.config.k8s.io/v1beta3</code></td></tr>
<tr><td><code>kind</code><br>string</td><td><code>NodeResourcesBalancedAllocationArgs</code></td></tr>
<tr><td><code>resources</code> <b>[必需]</b><br>
<a href=#kubescheduler-config-k8s-io-v1beta3-ResourceSpec><code>[]ResourceSpec</code></a>
</td>
<td>
要管理的资源；如果未设置，则默认值为 "cpu" 和 "memory"。
</td>
</tr>
</tbody>
</table>
<h2 id=kubescheduler-config-k8s-io-v1beta3-NodeResourcesFitArgs><code>NodeResourcesFitArgs</code> </h2>
<p>NodeResourcesFitArgs 包含用来配置 NodeResourcesFit 插件的参数。</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>apiVersion</code><br>string</td><td><code>kubescheduler.config.k8s.io/v1beta3</code></td></tr>
<tr><td><code>kind</code><br>string</td><td><code>NodeResourcesFitArgs</code></td></tr>
<tr><td><code>ignoredResources</code> <b>[必需]</b><br>
<code>[]string</code>
</td>
<td>
此字段为 NodeResources 匹配过滤器要忽略的资源列表。此列表不影响节点打分。
</td>
</tr>
<tr><td><code>ignoredResourceGroups</code> <b>[必需]</b><br>
<code>[]string</code>
</td>
<td>
此字段定义 NodeResources 匹配过滤器要忽略的资源组列表。
例如，如果配置值为 ["example.com"]，则以 "example.com" 开头的资源名（如
"example.com/aaa" 和 "example.com/bbb"）都会被忽略。
资源组名称中不可以包含 '/'。此设置不影响节点的打分。
</td>
</tr>
<tr><td><code>scoringStrategy</code> <b>[必需]</b><br>
<a href=#kubescheduler-config-k8s-io-v1beta3-ScoringStrategy><code>ScoringStrategy</code></a>
</td>
<td>
此字段用来选择节点资源打分策略。默认的策略为 LeastAllocated，且 "cpu" 和
"memory" 的权重相同。
</td>
</tr>
</tbody>
</table>
<h2 id=kubescheduler-config-k8s-io-v1beta3-PodTopologySpreadArgs><code>PodTopologySpreadArgs</code> </h2>
<p>PodTopologySpreadArgs 包含用来配置 PodTopologySpread 插件的参数。</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>apiVersion</code><br>string</td><td><code>kubescheduler.config.k8s.io/v1beta3</code></td></tr>
<tr><td><code>kind</code><br>string</td><td><code>PodTopologySpreadArgs</code></td></tr>
<tr><td><code>defaultConstraints</code><br>
<a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/#topologyspreadconstraint-v1-core><code>[]core/v1.TopologySpreadConstraint</code></a>
</td>
<td>
此字段针对未定义 <code>.spec.topologySpreadConstraints</code> 的 Pod，
为其提供拓扑分布约束。<code>.defaultConstraints[&#8727;].labelSelectors</code>
必须为空，因为这一信息要从 Pod 所属的 Service、ReplicationController、
ReplicaSet 或 StatefulSet 来推导。
此字段不为空时，<code>.defaultingType</code> 必须为 "List"。
</td>
</tr>
<tr><td><code>defaultingType</code><br>
<a href=#kubescheduler-config-k8s-io-v1beta3-PodTopologySpreadConstraintsDefaulting><code>PodTopologySpreadConstraintsDefaulting</code></a>
</td>
<td>
<p><code>defaultingType</code> 决定如何推导 <code>.defaultConstraints</code>。
可选值为 "System" 或 "List"。</p>
<ul>
<li>"System"：使用 Kubernetes 定义的约束，将 Pod 分布到不同节点和可用区；</li>
<li>"List"：使用 <code>.defaultConstraints</code> 中定义的约束。</li>
</ul>
<p>当特性门控 DefaultPodTopologySpread 被禁用时，默认值为 "list"；反之，默认值为 "System"。</p>
</td>
</tr>
</tbody>
</table>
<h2 id=kubescheduler-config-k8s-io-v1beta3-VolumeBindingArgs><code>VolumeBindingArgs</code> </h2>
<p>VolumeBindingArgs 包含用来配置 VolumeBinding 插件的参数。</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>apiVersion</code><br>string</td><td><code>kubescheduler.config.k8s.io/v1beta3</code></td></tr>
<tr><td><code>kind</code><br>string</td><td><code>VolumeBindingArgs</code></td></tr>
<tr><td><code>bindTimeoutSeconds</code> <b>[必需]</b><br>
<code>int64</code>
</td>
<td>
此字段设置卷绑定操作的超时秒数。字段值必须是非负数。
取值为 0 意味着不等待。如果此值为 null，则使用默认值（600）。
</td>
</tr>
<tr><td><code>shape</code><br>
<a href=#kubescheduler-config-k8s-io-v1beta3-UtilizationShapePoint><code>[]UtilizationShapePoint</code></a>
</td>
<td>
<p><code>shape</code> 用来设置打分函数曲线所使用的计分点，这些计分点
用来基于静态制备的 PV 卷的利用率为节点打分。
卷的利用率是计算得来的，将 Pod 所请求的总的存储空间大小除以每个节点
上可用的总的卷容量。每个计分点包含利用率（范围从 0 到 100）和其对应
的得分（范围从 0 到 10）。你可以通过为不同的使用率值设置不同的得分来
反转优先级：</p>
<p>默认的曲线计分点为：</p>
<ul>
<li>利用率为 0 时得分为 0；</li>
<li>利用率为 100 时得分为 10。</li>
</ul>
<p>所有计分点必须按利用率值的升序来排序。</p>
</td>
</tr>
</tbody>
</table>
<h2 id=kubescheduler-config-k8s-io-v1beta3-Extender><code>Extender</code> </h2>
<p><strong>出现在：</strong></p>
<ul>
<li><a href=#kubescheduler-config-k8s-io-v1beta3-KubeSchedulerConfiguration>KubeSchedulerConfiguration</a></li>
</ul>
<p>Extender 包含与扩展模块（Extender）通信所用的参数。
如果未指定 verb 或者 verb 为空，则假定对应的扩展模块选择不提供该扩展功能。</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>urlPrefix</code> <b>[必需]</b><br>
<code>string</code>
</td>
<td>
用来访问扩展模块的 URL 前缀。
</td>
</tr>
<tr><td><code>filterVerb</code> <b>[必需]</b><br>
<code>string</code>
</td>
<td>
filter 调用所使用的动词，如果不支持过滤操作则为空。
此动词会在向扩展模块发送 filter 调用时追加到 urlPrefix 后面。
</td>
</tr>
<tr><td><code>preemptVerb</code> <b>[必需]</b><br>
<code>string</code>
</td>
<td>
preempt 调用所使用的动词，如果不支持过滤操作则为空。
此动词会在向扩展模块发送 preempt 调用时追加到 urlPrefix 后面。
</td>
</tr>
<tr><td><code>prioritizeVerb</code> <b>[必需]</b><br>
<code>string</code>
</td>
<td>
prioritize 调用所使用的动词，如果不支持过滤操作则为空。
此动词会在向扩展模块发送 prioritize 调用时追加到 urlPrefix 后面。
</td>
</tr>
<tr><td><code>weight</code> <b>[必需]</b><br>
<code>int64</code>
</td>
<td>
针对 prioritize 调用所生成的节点分数要使用的数值系数。
weight 值必须是正整数。
</td>
</tr>
<tr><td><code>bindVerb</code> <b>[必需]</b><br>
<code>string</code>
</td>
<td>
bind 调用所使用的动词，如果不支持过滤操作则为空。
此动词会在向扩展模块发送 bind 调用时追加到 urlPrefix 后面。
如果扩展模块实现了此方法，扩展模块要负责将 Pod 绑定到 API 服务器。
只有一个扩展模块可以实现此函数。
</td>
</tr>
<tr><td><code>enableHTTPS</code> <b>[必需]</b><br>
<code>bool</code>
</td>
<td>
此字段设置是否需要使用 HTTPS 来与扩展模块通信。
</td>
</tr>
<tr><td><code>tlsConfig</code> <b>[必需]</b><br>
<a href=#kubescheduler-config-k8s-io-v1beta3-ExtenderTLSConfig><code>ExtenderTLSConfig</code></a>
</td>
<td>
此字段设置传输层安全性（TLS）配置。
</td>
</tr>
<tr><td><code>httpTimeout</code> <b>[必需]</b><br>
<a href=https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Duration><code>meta/v1.Duration</code></a>
</td>
<td>
此字段给出扩展模块功能调用的超时值。filter 操作超时会导致 Pod 无法被调度。
prioritize 操作超时会被忽略，Kubernetes 或者其他扩展模块所给出的优先级值
会被用来选择节点。
</td>
</tr>
<tr><td><code>nodeCacheCapable</code> <b>[必需]</b><br>
<code>bool</code>
</td>
<td>
此字段指示扩展模块可以缓存节点信息，从而调度器应该发送关于可选节点的最少信息，
假定扩展模块已经缓存了集群中所有节点的全部详细信息。
</td>
</tr>
<tr><td><code>managedResources</code><br>
<a href=#kubescheduler-config-k8s-io-v1beta3-ExtenderManagedResource><code>[]ExtenderManagedResource</code></a>
</td>
<td>
<p><code>managedResources</code> 是一个由此扩展模块所管理的扩展资源的列表。</p>
<ul>
<li>如果某 Pod 请求了此列表中的至少一个扩展资源，则 Pod 会在 filter、
prioritize 和 bind （如果扩展模块可以执行绑定操作）阶段被发送到该扩展模块。</li>
<li>如果某资源上设置了 <code>ignoredByScheduler</code> 为 true，则 kube-scheduler
会在断言阶段略过对该资源的检查。</li>
</ul>
</td>
</tr>
<tr><td><code>ignorable</code> <b>[必需]</b><br>
<code>bool</code>
</td>
<td>
此字段用来设置扩展模块是否是可忽略的。换言之，当扩展模块返回错误或者
完全不可达时，调度操作不应失败。
</td>
</tr>
</tbody>
</table>
<h2 id=kubescheduler-config-k8s-io-v1beta3-ExtenderManagedResource><code>ExtenderManagedResource</code> </h2>
<p><strong>出现在：</strong></p>
<ul>
<li><a href=#kubescheduler-config-k8s-io-v1beta3-Extender>Extender</a></li>
</ul>
<p>ExtenderManagedResource 描述某扩展模块所管理的扩展资源的参数。</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>name</code> <b>[必需]</b><br>
<code>string</code>
</td>
<td>
扩展资源的名称。
</td>
</tr>
<tr><td><code>ignoredByScheduler</code> <b>[必需]</b><br>
<code>bool</code>
</td>
<td>
此字段标明 kube-scheduler 是否应在应用断言时忽略此资源。
</td>
</tr>
</tbody>
</table>
<h2 id=kubescheduler-config-k8s-io-v1beta3-ExtenderTLSConfig><code>ExtenderTLSConfig</code> </h2>
<p><strong>出现在：</strong></p>
<ul>
<li><a href=#kubescheduler-config-k8s-io-v1beta3-Extender>Extender</a></li>
</ul>
<p>ExtenderTLSConfig 包含启用与扩展模块间 TLS 传输所需的配置参数。</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>insecure</code> <b>[必需]</b><br>
<code>bool</code>
</td>
<td>
访问服务器时不需要检查 TLS 证书。此配置仅针对测试用途。
</td>
</tr>
<tr><td><code>serverName</code> <b>[必需]</b><br>
<code>string</code>
</td>
<td>
<code>serverName</code> 会被发送到服务器端，作为 SNI 标志；客户端会使用
此设置来检查服务器证书。如果 <code>serverName</code> 为空，则会使用联系
服务器时所用的主机名。
</td>
</tr>
<tr><td><code>certFile</code> <b>[必需]</b><br>
<code>string</code>
</td>
<td>
服务器端所要求的 TLS 客户端证书认证。
</td>
</tr>
<tr><td><code>keyFile</code> <b>[必需]</b><br>
<code>string</code>
</td>
<td>
服务器端所要求的 TLS 客户端秘钥认证。
</td>
</tr>
<tr><td><code>caFile</code> <b>[必需]</b><br>
<code>string</code>
</td>
<td>
服务器端被信任的根证书。
</td>
</tr>
<tr><td><code>certData</code> <b>[必需]</b><br>
<code>[]byte</code>
</td>
<td>
<code>certData</code> 包含 PEM 编码的字节流（通常从某客户端证书文件读入）。
此字段优先级高于 certFile 字段。
</td>
</tr>
<tr><td><code>keyData</code> <b>[必需]</b><br>
<code>[]byte</code>
</td>
<td>
<code>keyData</code> 包含 PEM 编码的字节流（通常从某客户端证书秘钥文件读入）。
此字段优先级高于 keyFile 字段。
</td>
</tr>
<tr><td><code>caData</code> <b>[必需]</b><br>
<code>[]byte</code>
</td>
<td>
<code>caData</code> 包含 PEM 编码的字节流（通常从某根证书包文件读入）。
此字段优先级高于 caFile 字段。
</td>
</tr>
</tbody>
</table>
<h2 id=kubescheduler-config-k8s-io-v1beta3-KubeSchedulerProfile><code>KubeSchedulerProfile</code> </h2>
<p><strong>出现在：</strong></p>
<ul>
<li><a href=#kubescheduler-config-k8s-io-v1beta3-KubeSchedulerConfiguration>KubeSchedulerConfiguration</a></li>
</ul>
<p>KubeSchedulerProfile 是一个调度方案。</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>schedulerName</code> <b>[必需]</b><br>
<code>string</code>
</td>
<td>
<code>schedulerName</code> 是与此调度方案相关联的调度器的名称。
如果 <code>schedulerName</code> 与 Pod 的 <code>spec.schedulerName</code>
匹配，则该 Pod 会使用此方案来调度。
</td>
</tr>
<tr><td><code>plugins</code> <b>[必需]</b><br>
<a href=#kubescheduler-config-k8s-io-v1beta3-Plugins><code>Plugins</code></a>
</td>
<td>
<p><code>plugins</code> 设置一组应该被启用或禁止的插件。
被启用的插件是指除了默认插件之外需要被启用的插件。被禁止的插件
是指需要被禁用的默认插件。</p>
<p>如果针对某个扩展点没有设置被启用或被禁止的插件，则使用该扩展点
的默认插件（如果有的话）。如果设置了 QueueSort 插件，则同一个 QueueSort
插件和 <code>pluginConfig</code> 要被设置到所有调度方案之上。</p>
</td>
</tr>
<tr><td><code>pluginConfig</code> <b>[必需]</b><br>
<a href=#kubescheduler-config-k8s-io-v1beta3-PluginConfig><code>[]PluginConfig</code></a>
</td>
<td>
<code>pluginConfig</code> 是为每个插件提供的一组可选的定制插件参数。
如果忽略了插件的配置参数，则意味着使用该插件的默认配置。
</td>
</tr>
</tbody>
</table>
<h2 id=kubescheduler-config-k8s-io-v1beta3-Plugin><code>Plugin</code> </h2>
<p><strong>出现在：</strong></p>
<ul>
<li><a href=#kubescheduler-config-k8s-io-v1beta3-PluginSet>PluginSet</a></li>
</ul>
<p>Plugin 指定插件的名称及其权重（如果适用的话）。权重仅用于评分（Score）插件。</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>name</code> <b>[必需]</b><br>
<code>string</code>
</td>
<td>
插件的名称。
</td>
</tr>
<tr><td><code>weight</code> <b>[必需]</b><br>
<code>int32</code>
</td>
<td>
插件的权重；仅适用于评分（Score）插件。
</td>
</tr>
</tbody>
</table>
<h2 id=kubescheduler-config-k8s-io-v1beta3-PluginConfig><code>PluginConfig</code> </h2>
<p><strong>出现在：</strong></p>
<ul>
<li><a href=#kubescheduler-config-k8s-io-v1beta3-KubeSchedulerProfile>KubeSchedulerProfile</a></li>
</ul>
<p>PluginConfig 给出初始化阶段要传递给插件的参数。
在多个扩展点被调用的插件仅会被初始化一次。
参数可以是任意结构。插件负责处理这里所传的参数。</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>name</code> <b>[必需]</b><br>
<code>string</code>
</td>
<td>
<code>name</code> 是所配置的插件的名称。
</td>
</tr>
<tr><td><code>args</code> <b>[必需]</b><br>
<a href=https://godoc.org/k8s.io/apimachinery/pkg/runtime/#RawExtension><code>k8s.io/apimachinery/pkg/runtime.RawExtension</code></a>
</td>
<td>
<code>args</code> 定义在初始化阶段要传递给插件的参数。参数可以为任意结构。
</td>
</tr>
</tbody>
</table>
<h2 id=kubescheduler-config-k8s-io-v1beta3-PluginSet><code>PluginSet</code> </h2>
<p><strong>出现在：</strong></p>
<ul>
<li><a href=#kubescheduler-config-k8s-io-v1beta3-Plugins>Plugins</a></li>
</ul>
<p>PluginSet 为某扩展点设置要启用或禁用的插件。
如果数组为空，或者取值为 null，则使用该扩展点的默认插件集合。</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>enabled</code> <b>[必需]</b><br>
<a href=#kubescheduler-config-k8s-io-v1beta3-Plugin><code>[]Plugin</code></a>
</td>
<td>
<code>enabled</code> 设置在默认插件之外要启用的插件。如果在调度器的配置
文件中也配置了默认插件，则对应插件的权重会被覆盖。
此处所设置的插件会在默认插件之后被调用，调用顺序与数组中元素顺序相同。
</td>
</tr>
<tr><td><code>disabled</code> <b>[必需]</b><br>
<a href=#kubescheduler-config-k8s-io-v1beta3-Plugin><code>[]Plugin</code></a>
</td>
<td>
<code>disabled</code> 设置要被禁用的默认插件。
如果需要禁用所有的默认插件，应该提供仅包含一个元素 "&#8727;" 的数组。
</td>
</tr>
</tbody>
</table>
<h2 id=kubescheduler-config-k8s-io-v1beta3-Plugins><code>Plugins</code> </h2>
<p><strong>出现在：</strong></p>
<ul>
<li><a href=#kubescheduler-config-k8s-io-v1beta3-KubeSchedulerProfile>KubeSchedulerProfile</a></li>
</ul>
<p>Plugins 结构中包含多个扩展点。当此结构被设置时，针对特定扩展点所启用
的所有插件都在这一列表中。
如果配置中不包含某个扩展点，则使用该扩展点的默认插件集合。
被启用的插件的调用顺序与这里指定的顺序相同，都在默认插件之后调用。
如果它们需要在默认插件之前调用，则需要先行禁止默认插件，之后在这里
按期望的顺序重新启用。</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>queueSort</code> <b>[必需]</b><br>
<a href=#kubescheduler-config-k8s-io-v1beta3-PluginSet><code>PluginSet</code></a>
</td>
<td>
<code>queueSort</code> 是一个在对调度队列中 Pod 排序时要调用的插件列表。
</td>
</tr>
<tr><td><code>preFilter</code> <b>[必需]</b><br>
<a href=#kubescheduler-config-k8s-io-v1beta3-PluginSet><code>PluginSet</code></a>
</td>
<td>
<code>preFilter</code> 是一个在调度框架中“PreFilter（预过滤）”扩展点上要
调用的插件列表。
</td>
</tr>
<tr><td><code>filter</code> <b>[必需]</b><br>
<a href=#kubescheduler-config-k8s-io-v1beta3-PluginSet><code>PluginSet</code></a>
</td>
<td>
<code>filter</code> 是一个在需要过滤掉无法运行 Pod 的节点时被调用的插件列表。
</td>
</tr>
<tr><td><code>postFilter</code> <b>[必需]</b><br>
<a href=#kubescheduler-config-k8s-io-v1beta3-PluginSet><code>PluginSet</code></a>
</td>
<td>
<code>postFilter</code> 是一个在过滤阶段结束后会被调用的插件列表；
这里的插件只有在找不到合适的节点来运行 Pod 时才会被调用。
</td>
</tr>
<tr><td><code>preScore</code> <b>[必需]</b><br>
<a href=#kubescheduler-config-k8s-io-v1beta3-PluginSet><code>PluginSet</code></a>
</td>
<td>
<code>preScore</code> 是一个在打分之前要调用的插件列表。
</td>
</tr>
<tr><td><code>score</code> <b>[必需]</b><br>
<a href=#kubescheduler-config-k8s-io-v1beta3-PluginSet><code>PluginSet</code></a>
</td>
<td>
<code>score</code> 是一个在对已经通过过滤阶段的节点进行排序时调用的插件的列表。
</td>
</tr>
<tr><td><code>reserve</code> <b>[必需]</b><br>
<a href=#kubescheduler-config-k8s-io-v1beta3-PluginSet><code>PluginSet</code></a>
</td>
<td>
<code>reserve</code> 是一组在运行 Pod 的节点已被选定后，需要预留或者释放资源时调用的插件的列表。
</td>
</tr>
<tr><td><code>permit</code> <b>[必需]</b><br>
<a href=#kubescheduler-config-k8s-io-v1beta3-PluginSet><code>PluginSet</code></a>
</td>
<td>
<code>permit</code> 是一个用来控制 Pod 绑定关系的插件列表。这些插件可以
禁止或者延迟 Pod 的绑定。
</td>
</tr>
<tr><td><code>preBind</code> <b>[必需]</b><br>
<a href=#kubescheduler-config-k8s-io-v1beta3-PluginSet><code>PluginSet</code></a>
</td>
<td>
<code>preBind</code> 是一个在 Pod 被绑定到某节点之前要被调用的插件的列表。
</td>
</tr>
<tr><td><code>bind</code> <b>[必需]</b><br>
<a href=#kubescheduler-config-k8s-io-v1beta3-PluginSet><code>PluginSet</code></a>
</td>
<td>
<code>bind</code> 是一个在调度框架中“Bind（绑定）”扩展点上要调用的
插件的列表。调度器按顺序调用这些插件。只要其中某个插件返回成功，则调度器
就略过余下的插件。
</td>
</tr>
<tr><td><code>postBind</code> <b>[必需]</b><br>
<a href=#kubescheduler-config-k8s-io-v1beta3-PluginSet><code>PluginSet</code></a>
</td>
<td>
<code>postBind</code> 是一个在 Pod 已经被成功绑定之后要调用的插件的列表。
</td>
</tr>
<tr><td><code>multiPoint</code> <b>[必需]</b><br>
<a href=#kubescheduler-config-k8s-io-v1beta3-PluginSet><code>PluginSet</code></a>
</td>
<td>
<p><code>multiPoint</code> 是一个简化的配置段落，用来为所有合法的扩展点启用插件。
通过 <code>multiPoint</code> 启用的插件会自动注册到插件所实现的每个独立的扩展点上。
通过 <code>multiPoint</code> 禁用的插件会禁用对应的操作行为。
通过 <code>multiPoint</code> 所禁止的 "&#8727;" 也是如此，意味着所有默认
插件都不会被自动注册。
插件也可以通过各个独立的扩展点来禁用。</p>
<p>就优先序而言，插件配置遵从以下基本层次：</p>
<ol>
<li>特定的扩展点；</li>
<li>显式配置的 <code>multiPoint</code> 插件；</li>
<li>默认插件的集合，以及 <code>multiPoint</code> 插件。</li>
</ol>
<p>这意味着优先序较高的插件会先被运行，并且覆盖 <code>multiPoint</code> 中的任何配置。</p>
<p>用户显式配置的插件也会比默认插件优先序高。</p>
<p>在这样的层次结构设计之下，<code>enabled</code> 的优先序高于 <code>disabled</code>。
例如，某插件同时出现在 <code>multiPoint.enabled</code> 和 <code>multiPoint.disalbed</code> 时，
该插件会被启用。类似的，同时设置 <code>multiPoint.disabled = '&#8727;'</code>
和 <code>multiPoint.enabled = pluginA</code> 时，插件 pluginA 仍然会被注册。
这一设计与所有其他扩展点的配置行为是相符的。
</td>
</tr>
</tbody>
</table>
<h2 id=kubescheduler-config-k8s-io-v1beta3-PodTopologySpreadConstraintsDefaulting><code>PodTopologySpreadConstraintsDefaulting</code> </h2>
<p>（<code>string</code> 类型的别名）</p>
<p><strong>出现在：</strong></p>
<ul>
<li><a href=#kubescheduler-config-k8s-io-v1beta3-PodTopologySpreadArgs>PodTopologySpreadArgs</a></li>
</ul>
<p>PodTopologySpreadConstraintsDefaulting 定义如何为 PodTopologySpread 插件
设置默认的约束。</p>
<h2 id=kubescheduler-config-k8s-io-v1beta3-RequestedToCapacityRatioParam><code>RequestedToCapacityRatioParam</code> </h2>
<p><strong>出现在：</strong></p>
<ul>
<li><a href=#kubescheduler-config-k8s-io-v1beta3-ScoringStrategy>ScoringStrategy</a></li>
</ul>
<p>RequestedToCapacityRatioParam 结构定义 RequestedToCapacityRatio 的参数。</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>shape</code> <b>[必需]</b><br>
<a href=#kubescheduler-config-k8s-io-v1beta3-UtilizationShapePoint><code>[]UtilizationShapePoint</code></a>
</td>
<td>
<code>shape</code> 是一个定义评分函数曲线的计分点的列表。
</td>
</tr>
</tbody>
</table>
<h2 id=kubescheduler-config-k8s-io-v1beta3-ResourceSpec><code>ResourceSpec</code> </h2>
<p><strong>出现在：</strong></p>
<ul>
<li><a href=#kubescheduler-config-k8s-io-v1beta3-NodeResourcesBalancedAllocationArgs>NodeResourcesBalancedAllocationArgs</a></li>
<li><a href=#kubescheduler-config-k8s-io-v1beta3-ScoringStrategy>ScoringStrategy</a></li>
</ul>
<p>ResourceSpec 用来代表某个资源。</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>name</code> <b>[必需]</b><br>
<code>string</code>
</td>
<td>
资源名称。
</td>
</tr>
<tr><td><code>weight</code> <b>[必需]</b><br>
<code>int64</code>
</td>
<td>
资源权重。
</td>
</tr>
</tbody>
</table>
<h2 id=kubescheduler-config-k8s-io-v1beta3-ScoringStrategy><code>ScoringStrategy</code> </h2>
<p><strong>出现在：</strong></p>
<ul>
<li><a href=#kubescheduler-config-k8s-io-v1beta3-NodeResourcesFitArgs>NodeResourcesFitArgs</a></li>
</ul>
<p>ScoringStrategy 为节点资源插件定义 ScoringStrategyType。</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>type</code> <b>[必需]</b><br>
<a href=#kubescheduler-config-k8s-io-v1beta3-ScoringStrategyType><code>ScoringStrategyType</code></a>
</td>
<td>
<code>type</code> 用来选择要运行的策略。
</td>
</tr>
<tr><td><code>resources</code> <b>[必需]</b><br>
<a href=#kubescheduler-config-k8s-io-v1beta3-ResourceSpec><code>[]ResourceSpec</code></a>
</td>
<td>
<p><code>resources</code> 设置在评分时要考虑的资源。</p>
<p>默认的资源集合包含 "cpu" 和 "memory"，且二者权重相同。</p>
<p>权重的取值范围为 1 到 100。</p>
<p>当权重未设置或者显式设置为 0 时，意味着使用默认值 1。</p>
</td>
</tr>
<tr><td><code>requestedToCapacityRatio</code> <b>[必需]</b><br>
<a href=#kubescheduler-config-k8s-io-v1beta3-RequestedToCapacityRatioParam><code>RequestedToCapacityRatioParam</code></a>
</td>
<td>
特定于 RequestedToCapacityRatio 策略的参数。
</td>
</tr>
</tbody>
</table>
<h2 id=kubescheduler-config-k8s-io-v1beta3-ScoringStrategyType><code>ScoringStrategyType</code> </h2>
<p>（<code>string</code> 数据类型的别名）</p>
<p><strong>出现在：</strong></p>
<ul>
<li><a href=#kubescheduler-config-k8s-io-v1beta3-ScoringStrategy>ScoringStrategy</a></li>
</ul>
<p>ScoringStrategyType 是 NodeResourcesFit 插件所使用的的评分策略类型。</p>
<h2 id=kubescheduler-config-k8s-io-v1beta3-UtilizationShapePoint><code>UtilizationShapePoint</code> </h2>
<p><strong>出现在：</strong></p>
<ul>
<li><a href=#kubescheduler-config-k8s-io-v1beta3-VolumeBindingArgs>VolumeBindingArgs</a></li>
<li><a href=#kubescheduler-config-k8s-io-v1beta3-RequestedToCapacityRatioParam>RequestedToCapacityRatioParam</a></li>
</ul>
<p>UtilizationShapePoint 代表的是优先级函数曲线中的一个评分点。</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>utilization</code> <b>[必需]</b><br>
<code>int32</code>
</td>
<td>
利用率（x 轴）。合法值为 0 到 100。完全被利用的节点映射到 100。
</td>
</tr>
<tr><td><code>score</code> <b>[必需]</b><br>
<code>int32</code>
</td>
<td>
分配给指定利用率的分值（y 轴）。合法值为 0 到 10。
</td>
</tr>
</tbody>
</table>
<h2 id=ClientConnectionConfiguration><code>ClientConnectionConfiguration</code> </h2>
<p><strong>出现在：</strong></p>
<ul>
<li><a href=#kubescheduler-config-k8s-io-v1beta2-KubeSchedulerConfiguration>KubeSchedulerConfiguration</a></li>
<li><a href=#kubescheduler-config-k8s-io-v1beta3-KubeSchedulerConfiguration>KubeSchedulerConfiguration</a></li>
</ul>
<p>ClientConnectionConfiguration 中包含用来构造一个客户端所需的细节。</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>kubeconfig</code> <b>[必需]</b><br>
<code>string</code>
</td>
<td>
此字段为指向某 KubeConfig 文件的路径。
</td>
</tr>
<tr><td><code>acceptContentTypes</code> <b>[必需]</b><br>
<code>string</code>
</td>
<td>
<code>acceptContentTypes</code> 定义的是客户端与服务器建立连接时要发送的
Accept 头部；这里的设置值会覆盖默认值 "application/json"。
此字段会影响某特定客户端与服务器的所有连接。
</td>
</tr>
<tr><td><code>contentType</code> <b>[必需]</b><br>
<code>string</code>
</td>
<td>
<code>contentType</code> 包含的是此客户端向服务器发送数据时使用的
内容类型（Content Type）。
</td>
</tr>
<tr><td><code>qps</code> <b>[必需]</b><br>
<code>float32</code>
</td>
<td>
<code>qps</code> 控制的是此连接上每秒可以发送的查询个数。
</td>
</tr>
<tr><td><code>burst</code> <b>[必需]</b><br>
<code>int32</code>
</td>
<td>
<code>burst</code> 允许在客户端超出其速率限制时可以累积的额外查询个数。
</td>
</tr>
</tbody>
</table>
<h2 id=DebuggingConfiguration><code>DebuggingConfiguration</code> </h2>
<p><strong>出现在：</strong></p>
<ul>
<li><a href=#kubescheduler-config-k8s-io-v1beta3-KubeSchedulerConfiguration>KubeSchedulerConfiguration</a></li>
<li><a href=#kubescheduler-config-k8s-io-v1beta2-KubeSchedulerConfiguration>KubeSchedulerConfiguration</a></li>
</ul>
<p>DebuggingConfiguration 保存与调试功能相关的配置。</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>enableProfiling</code> <b>[必需]</b><br>
<code>bool</code>
</td>
<td>
此字段允许通过 Web 接口 host:port/debug/pprof/ 执行性能分析。
</td>
</tr>
<tr><td><code>enableContentionProfiling</code> <b>[必需]</b><br>
<code>bool</code>
</td>
<td>
此字段在 <code>enableProfiling</code> 为 true 时允许执行锁竞争分析。
</td>
</tr>
</tbody>
</table>
<h2 id=FormatOptions><code>FormatOptions</code> </h2>
<p>FormatOptions 中包含不同日志格式的配置选项。</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>json</code> <b>[必需]</b><br>
<a href=#JSONOptions><code>JSONOptions</code></a>
</td>
<td>
[实验特性] <code>json</code> 字段包含为 "json" 日志格式提供的配置选项。
</td>
</tr>
</tbody>
</table>
<h2 id=JSONOptions><code>JSONOptions</code> </h2>
<p><strong>出现在：</strong></p>
<ul>
<li><a href=#FormatOptions>FormatOptions</a></li>
</ul>
<p>JSONOptions 包含为 "json" 日志格式所设置的配置选项。</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>splitStream</code> <b>[必需]</b><br>
<code>bool</code>
</td>
<td>
[实验特性] 此字段将错误信息重定向到标准错误输出（stderr），将提示消息
重定向到标准输出（stdout），并且支持缓存。默认配置为将二者都输出到
标准输出（stdout），且不提供缓存。
</td>
</tr>
<tr><td><code>infoBufferSize</code> <b>[必需]</b><br>
<a href=https://pkg.go.dev/k8s.io/apimachinery/pkg/api/resource#QuantityValue><code>k8s.io/apimachinery/pkg/api/resource.QuantityValue</code></a>
</td>
<td>
[实验特性] <code>infoBufferSize</code> 用来在分离数据流场景是设置提示
信息数据流的大小。默认值为 0，意味着禁止缓存。
</td>
</tr>
</tbody>
</table>
<h2 id=LeaderElectionConfiguration><code>LeaderElectionConfiguration</code> </h2>
<p><strong>出现在：</strong></p>
<ul>
<li><a href=#kubescheduler-config-k8s-io-v1beta2-KubeSchedulerConfiguration>KubeSchedulerConfiguration</a></li>
<li><a href=#kubescheduler-config-k8s-io-v1beta3-KubeSchedulerConfiguration>KubeSchedulerConfiguration</a></li>
</ul>
<p>LeaderElectionConfiguration 为能够支持领导者选举的组件定义其领导者选举
客户端的配置。</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>leaderElect</code> <b>[必需]</b><br>
<code>bool</code>
</td>
<td>
<code>leaderElect</code> 启用领导者选举客户端，从而在进入主循环执行之前
先要获得领导者角色。当运行多副本组件时启用此功能有助于提高可用性。
</td>
</tr>
<tr><td><code>leaseDuration</code> <b>[必需]</b><br>
<a href=https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Duration><code>meta/v1.Duration</code></a>
</td>
<td>
<code>leaseDuration</code> 是非领导角色候选者在观察到需要领导席位更新时
要等待的时间；只有经过所设置时长才可以尝试去获得一个仍处于领导状态但需要
被刷新的席位。这里的设置值本质上意味着某个领导者在被另一个候选者替换掉
之前可以停止运行的最长时长。只有当启用了领导者选举时此字段有意义。
</td>
</tr>
<tr><td><code>renewDeadline</code> <b>[必需]</b><br>
<a href=https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Duration><code>meta/v1.Duration</code></a>
</td>
<td>
<code>renewDeadline</code> 设置的是当前领导者在停止扮演领导角色之前
需要刷新领导状态的时间间隔。此值必须小于或等于租约期限的长度。
只有到启用了领导者选举时此字段才有意义。
</td>
</tr>
<tr><td><code>retryPeriod</code> <b>[必需]</b><br>
<a href=https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Duration><code>meta/v1.Duration</code></a>
</td>
<td>
<code>retryPeriod</code> 是客户端在连续两次尝试获得或者刷新领导状态
之间需要等待的时长。只有当启用了领导者选举时此字段才有意义。
</td>
</tr>
<tr><td><code>resourceLock</code> <b>[必需]</b><br>
<code>string</code>
</td>
<td>
此字段给出在领导者选举期间要作为锁来使用的资源对象类型。
</td>
</tr>
<tr><td><code>resourceName</code> <b>[必需]</b><br>
<code>string</code>
</td>
<td>
此字段给出在领导者选举期间要作为锁来使用的资源对象名称。
</td>
</tr>
<tr><td><code>resourceNamespace</code> <b>[必需]</b><br>
<code>string</code>
</td>
<td>
此字段给出在领导者选举期间要作为锁来使用的资源对象所在名字空间。
</td>
</tr>
</tbody>
</table>
<h2 id=VModuleConfiguration><code>VModuleConfiguration</code> </h2>
<p>（<code>[]k8s.io/component-base/config/v1alpha1.VModuleItem</code> 的别名)</p>
<p>VModuleConfiguration 是一组文件名（通配符）及其对应的日志详尽程度阈值。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-81f4b8f1501e8345c99315695078a771>12.8 - kubeadm 配置 (v1beta2)</h1>
<h2>概述</h2>
<p>包 v1beta2 定义 kubeadm 配置文件格式的 v1beta2 版本。
此版本改进了 v1beta1 的格式，修复了一些小问题并添加了一些新的字段。</p>
<p>从 v1beta1 版本以来的变更列表：</p>
<ul>
<li>"certificateKey" 字段被添加到 InitConfiguration 和 JoinConfiguration 中。</li>
<li>"ignorePreflightErrors" 字段被添加到 NodeRegistrationOptions 中。</li>
<li>JSON 标签 "omitempty" 在合适的情况下被用到更多的位置。</li>
<li>"taints" 字段（在 NodeRegistrationOptions）的 JSON 标签 "omitempty" 被去除。</li>
</ul>
<p>参阅 Kubernetes 1.15 的变更记录以了解详细信息。</p>
<p>从老的 kubeadm 配置版本迁移：</p>
<p>请使用 kubeadm v1.15.x 的 "kubeadm config migrate" 命令将 v1beta1
版本的配置文件转换为 v1beta2。
（从更老版本的 kubeadm 配置文件迁移需要使用更老版本的 kubeadm。例如：</p>
<ul>
<li>kubeadm v1.11 版本可以用来从 v1alpha1 迁移到 v1alpha2 版本；kubeadm v1.12
可用来将 v1alpha2 翻译为 v1alpha3。</li>
<li>kubeadm v1.13 或 v1.14 可以用来将 v1alpha3 迁移到 v1beta1。</li>
</ul>
）
<p>尽管如此，kubeadm v1.15.x 会支持读取 v1beta1 版本的 kubeadm 配置文件格式。</p>
<h2>基础知识</h2>
<p>配置 kubeadm 的推荐方式是使用 <code>--config</code> 选项向其传递一个 YAML 配置文件。
kubeadm 配置文件中定义的某些配置选项也可以作为命令行标志来使用，
不过这种方法所支持的都是一些最常见的、最简单的使用场景。</p>
<p>一个 kubeadm 配置文件中可以包含多个配置类型，使用三根横线（<code>---</code>）作为分隔符。</p>
<p>kubeadm 支持以下配置类型：</p>
<pre style=background-color:#fff><span style=color:#000;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>kubeadm.k8s.io/v1beta2<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#000;font-weight:700>kind</span>:<span style=color:#bbb> </span>InitConfiguration<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#000;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>kubeadm.k8s.io/v1beta2<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#000;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterConfiguration<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#000;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>kubelet.config.k8s.io/v1beta1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#000;font-weight:700>kind</span>:<span style=color:#bbb> </span>KubeletConfiguration<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#000;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>kubeproxy.config.k8s.io/v1alpha1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#000;font-weight:700>kind</span>:<span style=color:#bbb> </span>KubeProxyConfiguration<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#000;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>kubeadm.k8s.io/v1beta2<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#000;font-weight:700>kind</span>:<span style=color:#bbb> </span>JoinConfiguration<span style=color:#bbb>
</span></pre>
<p>要输出 "init" 和 "join" 动作的默认值，可以使用下面的命令：</p>
<pre style=background-color:#fff>kubeadm config print init-defaults
kubeadm config print join-defaults
</pre>
<p>配置文件中必须包含的配置类型列表取决于你在执行的动作（<code>init</code> 或 <code>join</code>），
也取决于你要使用的配置选项（默认值或者高级定制）。</p>
<p>如果某些配置类型没有提供，或者仅部分提供，kubeadm 将使用默认值；
kubeadm 所提供的默认值在必要时也会保证其在多个组件之间是一致的
（例如控制器管理器上的 <code>--cluster-cidr</code> 参数和 kube-proxy 上的
<code>clusterCIDR</code>）。</p>
<p>用户总是可以重载默认配置值，唯一的例外是一小部分与安全性相关联的配置
（例如在 API 服务器上强制实施 Node 和 RBAC 鉴权模式）。</p>
<p>如果用户所提供的配置类型并非你所执行的操作需要的，
kubeadm 会忽略这些配置类型并打印警告信息。</p>
<h2>kubeadm init 配置类型</h2>
<p>当带有 <code>--config</code> 选项来执行 kubeadm init 命令时，可以使用下面的配置类型：
<code>InitConfiguration</code>、<code>ClusterConfiguration</code>、<code>KubeProxyConfiguration</code>、
<code>KubeletConfiguration</code>，但 <code>InitConfiguration</code> 和 <code>ClusterConfiguration</code>
之间只有一个是必须提供的。</p>
<pre style=background-color:#fff><span style=color:#000;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>kubeadm.k8s.io/v1beta2<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#000;font-weight:700>kind</span>:<span style=color:#bbb> </span>InitConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#000;font-weight:700>bootstrapTokens</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#000;font-weight:700>nodeRegistration</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></pre>
<p>类型 InitConfiguration 用来配置运行时设置，就 kubeadm init 命令而言，
包括启动引导令牌以及所有与 kubeadm 所在节点相关的设置，包括：</p>
<ul>
<li><code>nodeRegistration</code>：其中包含与向集群注册新节点相关的字段；
使用这个类型来定制节点名称、要使用的 CRI 套接字或者其他仅对当前节点起作用的设置
（例如节点 IP 地址）。</li>
<li><code>apiServer</code>：代表的是要部署到此节点上的 API 服务器示例的端点；
使用这个类型可以完成定制 API 服务器公告地址这类操作。</li>
</ul>
<pre style=background-color:#fff><span style=color:#000;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>kubeadm.k8s.io/v1beta2<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#000;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#000;font-weight:700>networking</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>...<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#000;font-weight:700>etcd</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>...<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#000;font-weight:700>apiServer</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#000;font-weight:700>extraArgs</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>...<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#000;font-weight:700>extraVolumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>...<span style=color:#bbb>
</span><span style=color:#bbb></span>...<span style=color:#bbb>
</span></pre>
<p>类型 <code>ClusterConfiguration</code> 用来定制集群范围的设置，具体包括以下设置：</p>
<ul>
<li><code>networking</code>：其中包含集群的网络拓扑配置。使用这一部分可以定制 Pod
的子网或者 Service 的子网。</li>
<li><code>etcd</code>：etcd 数据库的配置。例如使用这个部分可以定制本地 etcd 或者配置
API 服务器使用一个外部的 etcd 集群。</li>
<li><code>kube-apiserver</code>、<code>kube-scheduler</code>、<code>kube-controller-manager</code>
配置：这些部分可以通过添加定制的设置或者重载 kubeadm 的默认设置来定制控制面组件。</li>
</ul>
<pre style=background-color:#fff><span style=color:#000;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>kubeproxy.config.k8s.io/v1alpha1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#000;font-weight:700>kind</span>:<span style=color:#bbb> </span>KubeProxyConfiguration<span style=color:#bbb>
</span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></pre>
<p>KubeProxyConfiguration 类型用来更改传递给在集群中部署的 kube-proxy 实例的配置。
如果此对象没有提供，或者仅部分提供，kubeadm 使用默认值。</p>
<p>关于 kube-proxy 的官方文档，可参阅
https://kubernetes.io/zh/docs/reference/command-line-tools-reference/kube-proxy/
或者 https://godoc.org/k8s.io/kube-proxy/config/v1alpha1#KubeProxyConfiguration。
</p>
<pre style=background-color:#fff><span style=color:#000;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>kubelet.config.k8s.io/v1beta1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#000;font-weight:700>kind</span>:<span style=color:#bbb> </span>KubeletConfiguration<span style=color:#bbb>
</span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></pre>
<p>KubeletConfiguration 类型用来更改传递给在集群中部署的 kubelet 实例的配置。
如果此对象没有提供，或者仅部分提供，kubeadm 使用默认值。</p>
<p>关于 kubelet 的官方文档，可参阅
https://kubernetes.io/zh/docs/reference/command-line-tools-reference/kubelet/
或者
https://godoc.org/k8s.io/kubelet/config/v1beta1#KubeletConfiguration。</p>
<p>下面是一个为执行 <code>kubeadm init</code> 而提供的、包含多个配置类型的单一 YAML 文件，
其中填充了很多部分。</p>
<pre style=background-color:#fff><span style=color:#000;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>kubeadm.k8s.io/v1beta2<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#000;font-weight:700>kind</span>:<span style=color:#bbb> </span>InitConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#000;font-weight:700>bootstrapTokens</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:#000;font-weight:700>token</span>:<span style=color:#bbb> </span><span style=color:#d14>&#34;9a08jv.c0izixklcxtmnze7&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#000;font-weight:700>description</span>:<span style=color:#bbb> </span><span style=color:#d14>&#34;kubeadm bootstrap token&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#000;font-weight:700>ttl</span>:<span style=color:#bbb> </span><span style=color:#d14>&#34;24h&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:#000;font-weight:700>token</span>:<span style=color:#bbb> </span><span style=color:#d14>&#34;783bde.3f89s0fje9f38fhf&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#000;font-weight:700>description</span>:<span style=color:#bbb> </span><span style=color:#d14>&#34;another bootstrap token&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#000;font-weight:700>usages</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- authentication<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- signing<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#000;font-weight:700>groups</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- system:bootstrappers:kubeadm:default-node-token<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#000;font-weight:700>nodeRegistration</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#000;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#d14>&#34;ec2-10-100-0-1&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#000;font-weight:700>criSocket</span>:<span style=color:#bbb> </span><span style=color:#d14>&#34;/var/run/dockershim.sock&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#000;font-weight:700>taints</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:#000;font-weight:700>key</span>:<span style=color:#bbb> </span><span style=color:#d14>&#34;kubeadmNode&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#000;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#d14>&#34;master&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#000;font-weight:700>effect</span>:<span style=color:#bbb> </span><span style=color:#d14>&#34;NoSchedule&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#000;font-weight:700>kubeletExtraArgs</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#000;font-weight:700>v</span>:<span style=color:#bbb> </span><span style=color:#099>4</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#000;font-weight:700>ignorePreflightErrors</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- IsPrivilegedUser<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#000;font-weight:700>localAPIEndpoint</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#000;font-weight:700>advertiseAddress</span>:<span style=color:#bbb> </span><span style=color:#d14>&#34;10.100.0.1&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#000;font-weight:700>bindPort</span>:<span style=color:#bbb> </span><span style=color:#099>6443</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#000;font-weight:700>certificateKey</span>:<span style=color:#bbb> </span><span style=color:#d14>&#34;e6a2eb8581237ab72a4f494f30285ec12a9694d750b9785706a83bfcbbbd2204&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span>---<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#000;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>kubeadm.k8s.io/v1beta2<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#000;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#000;font-weight:700>etcd</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#998;font-style:italic># one of local or external</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#000;font-weight:700>local</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#000;font-weight:700>imageRepository</span>:<span style=color:#bbb> </span><span style=color:#d14>&#34;k8s.gcr.io&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#000;font-weight:700>imageTag</span>:<span style=color:#bbb> </span><span style=color:#d14>&#34;3.2.24&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#000;font-weight:700>dataDir</span>:<span style=color:#bbb> </span><span style=color:#d14>&#34;/var/lib/etcd&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#000;font-weight:700>extraArgs</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#000;font-weight:700>listen-client-urls</span>:<span style=color:#bbb> </span><span style=color:#d14>&#34;http://10.100.0.1:2379&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#000;font-weight:700>serverCertSANs</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:#bbb> </span><span style=color:#d14>&#34;ec2-10-100-0-1.compute-1.amazonaws.com&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#000;font-weight:700>peerCertSANs</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:#d14>&#34;10.100.0.1&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#998;font-style:italic># external:</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#998;font-style:italic>#   endpoints:</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#998;font-style:italic>#     - &#34;10.100.0.1:2379&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#998;font-style:italic>#     - &#34;10.100.0.2:2379&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#998;font-style:italic>#   caFile: &#34;/etcd/kubernetes/pki/etcd/etcd-ca.crt&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#998;font-style:italic>#   certFile: &#34;/etcd/kubernetes/pki/etcd/etcd.crt&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#998;font-style:italic>#   keyFile: &#34;/etcd/kubernetes/pki/etcd/etcd.key&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#000;font-weight:700>networking</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#000;font-weight:700>serviceSubnet</span>:<span style=color:#bbb> </span><span style=color:#d14>&#34;10.96.0.0/16&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#000;font-weight:700>podSubnet</span>:<span style=color:#bbb> </span><span style=color:#d14>&#34;10.244.0.0/24&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#000;font-weight:700>dnsDomain</span>:<span style=color:#bbb> </span><span style=color:#d14>&#34;cluster.local&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#000;font-weight:700>kubernetesVersion</span>:<span style=color:#bbb> </span><span style=color:#d14>&#34;v1.12.0&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#000;font-weight:700>controlPlaneEndpoint</span>:<span style=color:#bbb> </span><span style=color:#d14>&#34;10.100.0.1:6443&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#000;font-weight:700>apiServer</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#000;font-weight:700>extraArgs</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#000;font-weight:700>authorization-mode</span>:<span style=color:#bbb> </span><span style=color:#d14>&#34;Node,RBAC&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#000;font-weight:700>extraVolumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:#000;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#d14>&#34;some-volume&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#000;font-weight:700>hostPath</span>:<span style=color:#bbb> </span><span style=color:#d14>&#34;/etc/some-path&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#000;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#d14>&#34;/etc/some-pod-path&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#000;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#000;font-weight:700>false</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#000;font-weight:700>pathType</span>:<span style=color:#bbb> </span>File<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#000;font-weight:700>certSANs</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:#d14>&#34;10.100.1.1&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:#d14>&#34;ec2-10-100-0-1.compute-1.amazonaws.com&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#000;font-weight:700>timeoutForControlPlane</span>:<span style=color:#bbb> </span>4m0s<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#000;font-weight:700>controllerManager</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#000;font-weight:700>extraArgs</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#000;font-weight:700>&#34;node-cidr-mask-size&#34;: </span><span style=color:#d14>&#34;20&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#000;font-weight:700>extraVolumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:#000;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#d14>&#34;some-volume&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#000;font-weight:700>hostPath</span>:<span style=color:#bbb> </span><span style=color:#d14>&#34;/etc/some-path&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#000;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#d14>&#34;/etc/some-pod-path&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#000;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#000;font-weight:700>false</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#000;font-weight:700>pathType</span>:<span style=color:#bbb> </span>File<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#000;font-weight:700>scheduler</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#000;font-weight:700>extraArgs</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#000;font-weight:700>address</span>:<span style=color:#bbb> </span><span style=color:#d14>&#34;10.100.0.1&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#000;font-weight:700>extraVolumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:#000;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#d14>&#34;some-volume&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#000;font-weight:700>hostPath</span>:<span style=color:#bbb> </span><span style=color:#d14>&#34;/etc/some-path&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#000;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#d14>&#34;/etc/some-pod-path&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#000;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#000;font-weight:700>false</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#000;font-weight:700>pathType</span>:<span style=color:#bbb> </span>File<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#000;font-weight:700>certificatesDir</span>:<span style=color:#bbb> </span><span style=color:#d14>&#34;/etc/kubernetes/pki&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#000;font-weight:700>imageRepository</span>:<span style=color:#bbb> </span><span style=color:#d14>&#34;k8s.gcr.io&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#000;font-weight:700>useHyperKubeImage</span>:<span style=color:#bbb> </span><span style=color:#000;font-weight:700>false</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#000;font-weight:700>clusterName</span>:<span style=color:#bbb> </span><span style=color:#d14>&#34;example-cluster&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span>---<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#000;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>kubelet.config.k8s.io/v1beta1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#000;font-weight:700>kind</span>:<span style=color:#bbb> </span>KubeletConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#998;font-style:italic># kubelet specific options here</span><span style=color:#bbb>
</span><span style=color:#bbb></span>---<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#000;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>kubeproxy.config.k8s.io/v1alpha1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#000;font-weight:700>kind</span>:<span style=color:#bbb> </span>KubeProxyConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#998;font-style:italic># kube-proxy specific options here</span><span style=color:#bbb>
</span></pre>
<h2> kubeadm join 配置类型</h2>
<p>当带有 <code>--config</code> 选项来执行 <code>kubeadm join</code> 操作时，
需要提供 JoinConfiguration 类型。</p>
<pre style=background-color:#fff><span style=color:#000;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>kubeadm.k8s.io/v1beta2<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#000;font-weight:700>kind</span>:<span style=color:#bbb> </span>JoinConfiguration<span style=color:#bbb>
</span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></pre>
<p>JoinConfiguration 类型用来配置运行时设置，就 <code>kubeadm join</code>
而言包括用来访问集群信息的发现方法，以及所有特定于 kubeadm 执行所在节点的设置，
包括：</p>
<ul>
<li><code>nodeRegistration</code>：其中包含向集群注册新节点相关的配置字段；
使用这个类型可以定制节点名称、用使用的 CRI 套接字和所有其他仅适用于当前节点的设置
（例如节点 IP 地址）。</li>
<li><code>apiEndpoint</code>：用来代表最终要部署到此节点上的 API
服务器实例的端点。</li>
</ul>
<h2 id=resource-types>资源类型 </h2>
<ul>
<li><a href=#kubeadm-k8s-io-v1beta2-ClusterConfiguration>ClusterConfiguration</a></li>
<li><a href=#kubeadm-k8s-io-v1beta2-ClusterStatus>ClusterStatus</a></li>
<li><a href=#kubeadm-k8s-io-v1beta2-InitConfiguration>InitConfiguration</a></li>
<li><a href=#kubeadm-k8s-io-v1beta2-JoinConfiguration>JoinConfiguration</a></li>
</ul>
<h2 id=kubeadm-k8s-io-v1beta2-ClusterConfiguration><code>ClusterConfiguration</code> </h2>
<p>ClusterConfiguration 包含一个 kubadm 集群的集群范围配置信息。</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>apiVersion</code><br>string</td><td><code>kubeadm.k8s.io/v1beta2</code></td></tr>
<tr><td><code>kind</code><br>string</td><td><code>ClusterConfiguration</code></td></tr>
<tr><td><code>etcd</code> <b>[必需]</b><br>
<a href=#kubeadm-k8s-io-v1beta2-Etcd><code>Etcd</code></a>
</td>
<td>
<p><code>etcd</code> 中包含 etcd 服务的配置。</p>
</td>
</tr>
<tr><td><code>networking</code> <b>[必需]</b><br>
<a href=#kubeadm-k8s-io-v1beta2-Networking><code>Networking</code></a>
</td>
<td>
<code>networking</code> 字段包含集群的网络拓扑配置。
</td>
</tr>
<tr><td><code>kubernetesVersion</code> <b>[必需]</b><br>
<code>string</code>
</td>
<td>
<p><code>kubernetesVersion</code> 设置控制面的目标版本。</p>
</td>
</tr>
<tr><td><code>controlPlaneEndpoint</code> <b>[必需]</b><br>
<code>string</code>
</td>
<td>
<p><code>controlPlaneEndpoint</code> 为控制面设置一个稳定的 IP 地址或 DNS 名称。
取值可以是一个合法的 IP 地址或者 RFC-1123 形式的 DNS 子域名，二者均可以带一个可选的
TCP 端口号。
如果 <code>controlPlaneEndpoint</code> 未设置，则使用 <code>advertiseAddress<code>
+ <code>bindPort</code>。
如果设置了 <code>controlPlaneEndpoint</code>，但未指定 TCP 端口号，则使用
<code>bindPort</code>。</p>
<p>可能的用法有：</p>
<ul>
<li>在一个包含不止一个控制面实例的集群中，
该字段应该设置为放置在控制面实例之前的外部负载均衡器的地址。</li>
<li>在带有强制性节点回收的环境中，<code>controlPlaneEndpoint</code>
可以用来为控制面设置一个稳定的 DNS。</li>
</ul>
</td>
</tr>
<tr><td><code>apiServer</code> <b>[必需]</b><br>
<a href=#kubeadm-k8s-io-v1beta2-APIServer><code>APIServer</code></a>
</td>
<td>
<p><code>apiServer</code> 包含 API 服务器的一些额外配置。</p>
</td>
</tr>
<tr><td><code>controllerManager</code> <b>[必需]</b><br>
<a href=#kubeadm-k8s-io-v1beta2-ControlPlaneComponent><code>ControlPlaneComponent</code></a>
</td>
<td>
<p><code>controllerManager</code> 中包含控制器管理器的额外配置。</p>
</td>
</tr>
<tr><td><code>scheduler</code> <b>[必需]</b><br>
<a href=#kubeadm-k8s-io-v1beta2-ControlPlaneComponent><code>ControlPlaneComponent</code></a>
</td>
<td>
<p><code>scheduler</code> 包含调度器的额外配置。</p>
</td>
</tr>
<tr><td><code>dns</code> <b>[必需]</b><br>
<a href=#kubeadm-k8s-io-v1beta2-DNS><code>DNS</code></a>
</td>
<td>
<p><code>dns</code> 定义在集群中安装的 DNS 插件的选项。</p>
</td>
</tr>
<tr><td><code>certificatesDir</code> <b>[必需]</b><br>
<code>string</code>
</td>
<td>
<p><code>certificatesDir</code> 设置在何处存放或者查找所需证书。</p>
</td>
</tr>
<tr><td><code>imageRepository</code> <b>[必需]</b><br>
<code>string</code>
</td>
<td>
<p><code>imageRepository</code> 设置用来拉取镜像的容器仓库。
如果此字段为空，默认使用 <code>k8s.gcr.io</code>；
当 Kubernetes 用来执行 CI 构造时（Kubernetes 版本以 <code>ci/</code> 开头），
将默认使用 <code>gcr.io/k8s-staging-ci-images</code> 来拉取控制面组件镜像，
而使用 <code>k8s.gcr.io</code> 来拉取所有其他镜像。</p>
</td>
</tr>
<tr><td><code>useHyperKubeImage</code> <b>[必需]</b><br>
<code>bool</code>
</td>
<td>
<p><code>useHyperKubeImage</code> 控制是否使用 hyperkube 来作为Kubernetes
组件，而不是一个个独立的镜像。
已启用：由于 <code>hyperkube</code> 自身已被弃用，此字段也被启用。
将被从将来的 kubeadm 配置版本中移除，kubeadm 在此字段设置为 true
时会打印多个警告信息，并且在一些其他位置忽略此字段设置。</p>
</td>
</tr>
<tr><td><code>featureGates</code> <b>[必需]</b><br>
<code>map[string]bool</code>
</td>
<td>
<p><code>featureGates</code> 包含用户所启用的特性门控。</p>
</td>
</tr>
<tr><td><code>clusterName</code> <b>[必需]</b><br>
<code>string</code>
</td>
<td>
<p>集群名称。</p>
</td>
</tr>
</tbody>
</table>
<h2 id=kubeadm-k8s-io-v1beta2-ClusterStatus><code>ClusterStatus</code> </h2>
<p>ClusterStatus 包含集群信息。ClusterStatus 会被保存在集群中 kubeadm-config
ConfigMap 中，之后在新的控制面实例添加到集群或者现有控制面实例离开集群时被更新。</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>apiVersion</code><br>string</td><td><code>kubeadm.k8s.io/v1beta2</code></td></tr>
<tr><td><code>kind</code><br>string</td><td><code>ClusterStatus</code></td></tr>
<tr><td><code>apiEndpoints</code> <b>[必需]</b><br>
<a href=#kubeadm-k8s-io-v1beta2-APIEndpoint><code>map[string]APIEndpoint</code></a>
</td>
<td>
<p><code>apiEndpoints</code> 为当前集群中可用的 API 端点，每个控制面实例
（API 服务器）对应一个表项。
映射的键名为主机默认接口的 IP 地址。</p>
</td>
</tr>
</tbody>
</table>
<h2 id=kubeadm-k8s-io-v1beta2-InitConfiguration><code>InitConfiguration</code> </h2>
<p>InitConfiguration 包含一组特定于 "kubeadm init" 的运行时元素。</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>apiVersion</code><br>string</td><td><code>kubeadm.k8s.io/v1beta2</code></td></tr>
<tr><td><code>kind</code><br>string</td><td><code>InitConfiguration</code></td></tr>
<tr><td><code>bootstrapTokens</code> <b>[必需]</b><br>
<a href=#kubeadm-k8s-io-v1beta2-BootstrapToken><code>[]BootstrapToken</code></a>
</td>
<td>
<p><code>bootstrapTokens</code> 在 <code>kubeadm init</code> 执行时会被用到，
其中描述了一组要创建的启动引导令牌（Bootstrap Tokens）。
这里的信息不会被上传到 kubeadm 在集群中保存的 ConfigMap 中，部分原因是由于信息本身比较敏感。</p>
</td>
</tr>
<tr><td><code>nodeRegistration</code> <b>[必需]</b><br>
<a href=#kubeadm-k8s-io-v1beta2-NodeRegistrationOptions><code>NodeRegistrationOptions</code></a>
</td>
<td>
<p><code>nodeRegistration</code> 中包含与向集群中注册新的控制面节点相关的字段。</p>
</td>
</tr>
<tr><td><code>localAPIEndpoint</code> <b>[必需]</b><br>
<a href=#kubeadm-k8s-io-v1beta2-APIEndpoint><code>APIEndpoint</code></a>
</td>
<td>
<p><code>localAPIEndpoint</code> 所代表的的是在此控制面节点上要部署的 API 服务器的端点。
在高可用（HA）配置中，此字段与 <code>ClusterConfiguration.controlPlaneEndpoint</code>
的取值不同：后者代表的是整个集群的全局端点，该端点上的请求会被负载均衡到每个 API 服务器。
此配置对象允许你定制本地 API 服务器所公布的、可访问的 IP/DNS 名称和端口。
默认情况下，kubeadm 会尝试自动检测默认接口上的 IP 并使用该地址。
不过，如果这种检测失败，你可以在此字段中直接设置所期望的值。</p>
</td>
</tr>
<tr><td><code>certificateKey</code> <b>[必需]</b><br>
<code>string</code>
</td>
<td>
<p><code>certificateKey</code> 用来设置一个秘钥，该秘钥将对 <code>uploadcerts init</code>
阶段上传到集群中某 Secret 内的秘钥和证书加密。</p>
</td>
</tr>
</tbody>
</table>
<h2 id=kubeadm-k8s-io-v1beta2-JoinConfiguration><code>JoinConfiguration</code> </h2>
<p>
JoinConfiguration 包含描述特定节点的元素。
</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>apiVersion</code><br>string</td><td><code>kubeadm.k8s.io/v1beta2</code></td></tr>
<tr><td><code>kind</code><br>string</td><td><code>JoinConfiguration</code></td></tr>
<tr><td><code>nodeRegistration</code> <b>[必需]</b><br>
<a href=#kubeadm-k8s-io-v1beta2-NodeRegistrationOptions><code>NodeRegistrationOptions</code></a>
</td>
<td>
<code>nodeRegistration</code> 包含与向集群注册控制面节点相关的字段。
</td>
</tr>
<tr><td><code>caCertPath</code> <b>[必需]</b><br>
<code>string</code>
</td>
<td>
<p><code>caCertPath</code> 是指向 SSL 证书机构的路径，
该证书包用来加密节点与控制面之间的通信。默认值为
"/etc/kubernetes/pki/ca.crt"。</p>
</td>
</tr>
<tr><td><code>discovery</code> <b>[必需]</b><br>
<a href=#kubeadm-k8s-io-v1beta2-Discovery><code>Discovery</code></a>
</td>
<td>
<p><code>discovery</code> 设置 TLS 引导过程中 kubelet 要使用的选项。</p>
</td>
</tr>
<tr><td><code>controlPlane</code> <b>[必需]</b><br>
<a href=#kubeadm-k8s-io-v1beta2-JoinControlPlane><code>JoinControlPlane</code></a>
</td>
<td>
<p><code>controlPlane</code> 定义要在正被加入到集群中的节点上部署的额外控制面实例。
此字段为 null 时，不会再上面部署额外的控制面实例。</p>
</td>
</tr>
</tbody>
</table>
<h2 id=kubeadm-k8s-io-v1beta2-APIEndpoint><code>APIEndpoint</code> </h2>
<p><strong>出现在：</strong></p>
<ul>
<li>
<p><a href=#kubeadm-k8s-io-v1beta2-ClusterStatus>ClusterStatus</a></p>
</li>
<li>
<p><a href=#kubeadm-k8s-io-v1beta2-InitConfiguration>InitConfiguration</a></p>
</li>
<li>
<p><a href=#kubeadm-k8s-io-v1beta2-JoinControlPlane>JoinControlPlane</a></p>
</li>
</ul>
<p>
APIEndpoint 结构包含某节点上部署的 API 服务器的配置元素。
</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>advertiseAddress</code> <b>[必需]</b><br>
<code>string</code>
</td>
<td>
<p><code>advertiseAddress</code> 设置 API 服务器要公布的 IP 地址。</p>
</td>
</tr>
<tr><td><code>bindPort</code> <b>[必需]</b><br>
<code>int32</code>
</td>
<td>
<code>bindPort</code> 设置 API 服务器要绑定到的安全端口。默认值为 6443。
</td>
</tr>
</tbody>
</table>
<h2 id=kubeadm-k8s-io-v1beta2-APIServer><code>APIServer</code> </h2>
<p><strong>出现在：</strong></p>
<ul>
<li><a href=#kubeadm-k8s-io-v1beta2-ClusterConfiguration>ClusterConfiguration</a></li>
</ul>
<p>
APIServer 包含集群中 API 服务器部署所必需的设置。
</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>ControlPlaneComponent</code> <b>[必需]</b><br>
<a href=#kubeadm-k8s-io-v1beta2-ControlPlaneComponent><code>ControlPlaneComponent</code></a>
</td>
<td>（<code>ControlPlaneComponent</code> 结构的字段被嵌入到此类型中）
<span class=text-muted>无描述</span>
</tr>
<tr><td><code>certSANs</code> <b>[必需]</b><br>
<code>[]string</code>
</td>
<td>
<code>certSANs</code> 设置 API 服务器签署证书所用的额外主题替代名（Subject Alternative Name，SAN）。
</td>
</tr>
<tr><td><code>timeoutForControlPlane</code> <b>[必需]</b><br>
<a href=https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Duration><code>meta/v1.Duration</code></a>
</td>
<td>
<p><code>timeoutForControlPlane</code> 用来控制我们等待 API 服务器开始运行的超时时间。</p>
</td>
</tr>
</tbody>
</table>
<h2 id=kubeadm-k8s-io-v1beta2-BootstrapToken><code>BootstrapToken</code> </h2>
<p><strong>出现在：</strong></p>
<ul>
<li><a href=#kubeadm-k8s-io-v1beta2-InitConfiguration>InitConfiguration</a></li>
</ul>
<p>BootstrapToken 描述的是一个启动引导令牌，以 Secret 形式存储在集群中。</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>token</code> <b>[必需]</b><br>
<a href=#kubeadm-k8s-io-v1beta2-BootstrapTokenString><code>BootstrapTokenString</code></a>
</td>
<td>
<p><code>token</code> 用来在节点与控制面之间建立双向的信任关系。
在向集群中添加节点时使用。</p>
</td>
</tr>
<tr><td><code>description</code> <b>[必需]</b><br>
<code>string</code>
</td>
<td>
<p><code>description</code> 设置一个对人友好的消息，
说明为什么此令牌会存在以及其目标用途，这样其他管理员能够知道其目的。</p>
</td>
</tr>
<tr><td><code>ttl</code> <b>[必需]</b><br>
<a href=https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Duration><code>meta/v1.Duration</code></a>
</td>
<td>
<p><code>ttl</code> 定义此令牌的声明周期。默认为 <code>24h</code>。
<code>expires</code> 和 <code>ttl</code> 是互斥的。</p>
</td>
</tr>
<tr><td><code>expires</code> <b>[必需]</b><br>
<a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/#time-v1-meta><code>meta/v1.Time</code></a>
</td>
<td>
<p><code>expires</code> 设置此令牌过期的时间戳。
默认为在运行时基于<code>ttl</code>来决定。
<code>expires</code>和<code>ttl</code>是互斥的。</p>
</td>
</tr>
<tr><td><code>usages</code> <b>[必需]</b><br>
<code>[]string</code>
</td>
<td>
<p><code>usages</code> 描述此令牌的可能使用方式。默认情况下，
令牌可用于建立双向的信任关系；不过这里可以改变默认用途。</p>
</td>
</tr>
<tr><td><code>groups</code> <b>[必需]</b><br>
<code>[]string</code>
</td>
<td>
<p><code>groups</code> 设定此令牌被用于身份认证时对应的附加用户组。</p>
</td>
</tr>
</tbody>
</table>
<h2 id=kubeadm-k8s-io-v1beta2-BootstrapTokenDiscovery><code>BootstrapTokenDiscovery</code> </h2>
<p><strong>出现在：</strong></p>
<ul>
<li><a href=#kubeadm-k8s-io-v1beta2-Discovery>Discovery</a></li>
</ul>
<p>
BootstrapTokenDiscovery 用来设置基于引导令牌的服务发现选项。
</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>token</code> <b>[必需]</b><br>
<code>string</code>
</td>
<td>
<p>
<code>token</code> 用来验证从控制面获得的集群信息。
</p>
</td>
</tr>
<tr><td><code>apiServerEndpoint</code> <b>[必需]</b><br>
<code>string</code>
</td>
<td>
<p>
<code>apiServerEndpoint</p> 为 API 服务器的 IP 地址或者域名，从该端点可以获得集群信息。
</p>
</td>
</tr>
<tr><td><code>caCertHashes</code> <b>[必需]</b><br>
<code>[]string</code>
</td>
<td>
<p>
<code>caCertHashes</code> 设置一组在基于令牌来发现服务时要验证的公钥指纹。
发现过程中获得的根 CA 必须与这里的数值之一匹配。
设置为空集合意味着禁用根 CA 指纹，因而可能是不安全的。
每个哈希值的形式为 "&lt;type>:&lt;value>"，当前唯一支持的 type 为
"sha256"。
哈希值为主体公钥信息（Subject Public Key Info，SPKI）对象的 SHA-256
哈希值（十六进制编码），形式为 DER 编码的 ASN.1。
例如，这些哈希值可以使用 OpenSSL 来计算。
</p>
</td>
</tr>
<tr><td><code>unsafeSkipCAVerification</code> <b>[必需]</b><br>
<code>bool</code>
</td>
<td>
<code>unsafeSkipCAVerification</code> 允许在使用基于令牌的服务发现时不使用
<code>caCertHashes</code> 来执行 CA 验证。这会弱化 kubeadm 的安全性，
因为其他节点可以伪装成控制面。
</td>
</tr>
</tbody>
</table>
<h2 id=kubeadm-k8s-io-v1beta2-BootstrapTokenString><code>BootstrapTokenString</code> </h2>
<p><strong>出现在：</strong></p>
<ul>
<li><a href=#kubeadm-k8s-io-v1beta2-BootstrapToken>BootstrapToken</a></li>
</ul>
<p>BootstrapTokenString 形式为 <code>abcdef.abcdef0123456789</code> 的一个令牌，
用来从加入集群的节点角度验证 API 服务器的身份，或者 "kubeadm join"
在节点启动引导是作为一种身份认证方法。
此令牌的生命期是短暂的，并且应该如此。</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>id</code> <b>[必需]</b><br>
<code>string</code>
</td>
<td>
<span class=text-muted>无描述</span>
</tr>
<tr><td><code>secret</code> <b>[必需]</b><br>
<code>string</code>
</td>
<td>
<span class=text-muted>无描述</span>
</tr>
</tbody>
</table>
<h2 id=kubeadm-k8s-io-v1beta2-ControlPlaneComponent><code>ControlPlaneComponent</code> </h2>
<p><strong>出现在：</strong></p>
<ul>
<li><a href=#kubeadm-k8s-io-v1beta2-ClusterConfiguration>ClusterConfiguration</a></li>
<li><a href=#kubeadm-k8s-io-v1beta2-APIServer>APIServer</a></li>
</ul>
<p>
ControlPlaneComponent 中包含对集群中所有控制面组件都适用的设置。
</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>extraArgs</code> <b>[必需]</b><br>
<code>map[string]string</code>
</td>
<td>
<p>
<code>extraArgs</code> 是要传递给控制面组件的一组额外的参数标志。
此映射中的每个键对应命令行上使用的标志名称，只是没有其引导连字符。
</p>
</td>
</tr>
<tr><td><code>extraVolumes</code> <b>[必需]</b><br>
<a href=#kubeadm-k8s-io-v1beta2-HostPathMount><code>[]HostPathMount</code></a>
</td>
<td>
<p>
<code>extraVolumes</code> 是一组额外的主机卷，需要挂载到控制面组件中。
</p>
</td>
</tr>
</tbody>
</table>
<h2 id=kubeadm-k8s-io-v1beta2-DNS><code>DNS</code> </h2>
<p><strong>出现在：</strong></p>
<ul>
<li><a href=#kubeadm-k8s-io-v1beta2-ClusterConfiguration>ClusterConfiguration</a></li>
</ul>
<p>
DNS 结构定义要在集群中使用的 DNS 插件。
</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>type</code> <b>[必需]</b><br>
<a href=#kubeadm-k8s-io-v1beta2-DNSAddOnType><code>DNSAddOnType</code></a>
</td>
<td>
<p><code>type</code> 定义要使用的 DNS 插件类型。</p>
</td>
</tr>
<tr><td><code>ImageMeta</code> <b>[必需]</b><br>
<a href=#kubeadm-k8s-io-v1beta2-ImageMeta><code>ImageMeta</code></a>
</td>
<td>（<code>ImageMeta</code> 的成员被内嵌到此类型中）。
<p>
<code>imageMeta</code> 允许对 DNS 组件所使用的的镜像作定制。
</p>
</td>
</tr>
</tbody>
</table>
<h2 id=kubeadm-k8s-io-v1beta2-DNSAddOnType><code>DNSAddOnType</code> </h2>
<p>（<code>string</code> 数据类型的别名）</p>
<p><strong>出现在：</strong></p>
<ul>
<li><a href=#kubeadm-k8s-io-v1beta2-DNS>DNS</a></li>
</ul>
<p>DNSAddOnType 定义的是用来辨识 DNS 插件类型的字符串。</p>
<h2 id=kubeadm-k8s-io-v1beta2-Discovery><code>Discovery</code> </h2>
<p><strong>出现在：</strong></p>
<ul>
<li><a href=#kubeadm-k8s-io-v1beta2-JoinConfiguration>JoinConfiguration</a></li>
</ul>
<p>
Discovery 设置 TLS 启动引导过程中 kubelet 要使用的配置选项。
</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>bootstrapToken</code> <b>[必需]</b><br>
<a href=#kubeadm-k8s-io-v1beta2-BootstrapTokenDiscovery><code>BootstrapTokenDiscovery</code></a>
</td>
<td>
<p>
<code>bootstrapToken</code> 设置基于启动引导令牌的服务发现选项。
<code>bootstrapToken</code> 与 <code>file</code> 是互斥的。
</p>
</td>
</tr>
<tr><td><code>file</code> <b>[必需]</b><br>
<a href=#kubeadm-k8s-io-v1beta2-FileDiscovery><code>FileDiscovery</code></a>
</td>
<td>
<code> 用来设置一个文件或者 URL 路径，指向一个 kubeconfig 文件；
该配置文件中包含集群信息。
<code>bootstrapToken</code> 与 <code>file</code> 是互斥的。
</td>
</tr>
<tr><td><code>tlsBootstrapToken</code> <b>[必需]</b><br>
<code>string</code>
</td>
<td>
<p>
<code>tlsBootstrapToken</code> 是 TLS 启动引导过程中使用的令牌。
如果设置了 <code>bootstrapToken</code>，则此字段默认值为 <code>.bootstrapToken.token</code>，
不过可以被重载。
如果设置了 <code>file</code>，此字段<b>必须被设置</b>，以防 kubeconfig
文件中不包含其他身份认证信息。
</p>
</td>
</tr>
<tr><td><code>timeout</code> <b>[必需]</b><br>
<a href=https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Duration><code>meta/v1.Duration</code></a>
</td>
<td>
<p>
<code>timeout</code> 用来修改发现过程的超时时长。
</p>
</td>
</tr>
</tbody>
</table>
<h2 id=kubeadm-k8s-io-v1beta2-Etcd><code>Etcd</code> </h2>
<p><strong>出现在：</strong></p>
<ul>
<li><a href=#kubeadm-k8s-io-v1beta2-ClusterConfiguration>ClusterConfiguration</a></li>
</ul>
<p>
Etcd 包含用来描述 etcd 配置的元素。
</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>local</code> <b>[必需]</b><br>
<a href=#kubeadm-k8s-io-v1beta2-LocalEtcd><code>LocalEtcd</code></a>
</td>
<td>
<p>
<code>local</code> 提供配置本地 etcd 实例的选项。<code>local</code> 和
<code>external</code> 是互斥的。
</p>
</td>
</tr>
<tr><td><code>external</code> <b>[必需]</b><br>
<a href=#kubeadm-k8s-io-v1beta2-ExternalEtcd><code>ExternalEtcd</code></a>
</td>
<td>
<p>
<code>external</code>描述如何连接到外部的 etcd 集群。
<code>local</code>和<code>external</code>是互斥的。
</p>
</td>
</tr>
</tbody>
</table>
<h2 id=kubeadm-k8s-io-v1beta2-ExternalEtcd><code>ExternalEtcd</code> </h2>
<p><strong>出现在：</strong></p>
<ul>
<li><a href=#kubeadm-k8s-io-v1beta2-Etcd>Etcd</a></li>
</ul>
<p>
ExternalEtcd 描述外部 etcd 集群。
kubeadm 不清楚证书文件的存放位置，因此必须单独提供证书信息。
</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>endpoints</code> <b>[必需]</b><br>
<code>[]string</code>
</td>
<td>
<p><code>endpoints</code> 包含一组 etcd 成员的列表。</p>
</td>
</tr>
<tr><td><code>caFile</code> <b>[必需]</b><br>
<code>string</code>
</td>
<td>
<p><code>caFile</code> 是一个 SSL 证书机构（CA）文件，用来加密 etcd 通信。
如果使用 TLS 连接，此字段为必需字段。</p>
</td>
</tr>
<tr><td><code>certFile</code> <b>[必需]</b><br>
<code>string</code>
</td>
<td>
<p><code>certFile</code> 是一个 SSL 证书文件，用来加密 etcd 通信。
如果使用 TLS 连接，此字段为必需字段。</p>
</td>
</tr>
<tr><td><code>keyFile</code> <b>[必需]</b><br>
<code>string</code>
</td>
<td>
<p><code>keyFile</code> 是一个用来加密 etcd 通信的 SSL 秘钥文件。
此字段在使用 TLS 连接时为必填字段。</p>
</td>
</tr>
</tbody>
</table>
<h2 id=kubeadm-k8s-io-v1beta2-FileDiscovery><code>FileDiscovery</code> </h2>
<p><strong>出现在：</strong></p>
<ul>
<li><a href=#kubeadm-k8s-io-v1beta2-Discovery>Discovery</a></li>
</ul>
<p>FileDiscovery 用来指定一个文件或者 URL 路径，指向一个 kubeconfig 文件；
该配置文件可用来加载集群信息。</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>kubeConfigPath</code> <b>[必需]</b><br>
<code>string</code>
</td>
<td>
<p><code>kubeConfigPath</code> 用来指定一个文件或者 URL 路径，指向一个 kubeconfig 文件；
该配置文件可用来加载集群信息。</p>
</td>
</tr>
</tbody>
</table>
<h2 id=kubeadm-k8s-io-v1beta2-HostPathMount><code>HostPathMount</code> </h2>
<p><strong>出现在：</strong></p>
<ul>
<li><a href=#kubeadm-k8s-io-v1beta2-ControlPlaneComponent>ControlPlaneComponent</a></li>
</ul>
<p>HostPathMount 包含从宿主节点挂载的卷的信息。</p-->
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>name</code> <b>[必需]</b><br>
<code>string</code>
</td>
<td>
<p><code>name</code> 为卷在 Pod 模板中的名称。</p>
</td>
</tr>
<tr><td><code>hostPath</code> <b>[必需]</b><br>
<code>string</code>
</td>
<td>
<p><code>hostPath</code> 是要在 Pod 中挂载的卷在宿主系统上的路径。</p>
</td>
</tr>
<tr><td><code>mountPath</code> <b>[必需]</b><br>
<code>string</code>
</td>
<td>
<p><code>mountPath</code> 是 <code>hostPath</code> 在 Pod 内挂载的路径。</p>
</td>
</tr>
<tr><td><code>readOnly</code> <b>[必需]</b><br>
<code>bool</code>
</td>
<td>
<p><code>readOnly</code> 控制卷的读写访问模式。</p>
</td>
</tr>
<tr><td><code>pathType</code> <b>[必需]</b><br>
<a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/#hostpathtype-v1-core><code>core/v1.HostPathType</code></a>
</td>
<td>
<p><code>pathType</code> 是 <code>hostPath</code> 的类型。</p>
</td>
</tr>
</tbody>
</table>
<h2 id=kubeadm-k8s-io-v1beta2-ImageMeta><code>ImageMeta</code> </h2>
<p><strong>出现在：</strong></p>
<ul>
<li>
<p><a href=#kubeadm-k8s-io-v1beta2-DNS>DNS</a></p>
</li>
<li>
<p><a href=#kubeadm-k8s-io-v1beta2-LocalEtcd>LocalEtcd</a></p>
</li>
</ul>
<p>ImageMeta 用来配置来源不是 Kubernetes/kubernetes
发布过程的组件所使用的镜像。</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>imageRepository</code> <b>[必需]</b><br>
<code>string</code>
</td>
<td>
<p><code>imageRepository</code> 设置镜像拉取所用的容器仓库。
若未设置，则使用 ClusterConfiguration 中的 <code>imageRepository</code>。</p>
</td>
</tr>
<tr><td><code>imageTag</code> <b>[必需]</b><br>
<code>string</code>
</td>
<td>
<p><code>imageTag</code> 允许用户设置镜像的标签。
如果设置了此字段，则 kubeadm 不再在集群升级时自动更改组件的版本。</p>
</td>
</tr>
</tbody>
</table>
<h2 id=kubeadm-k8s-io-v1beta2-JoinControlPlane><code>JoinControlPlane</code> </h2>
<p><strong>出现在：</strong></p>
<ul>
<li><a href=#kubeadm-k8s-io-v1beta2-JoinConfiguration>JoinConfiguration</a></li>
</ul>
<p>JoinControlPlane 包含在正在加入集群的节点上要部署的额外的控制面组件的设置。</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>localAPIEndpoint</code> <b>[必需]</b><br>
<a href=#kubeadm-k8s-io-v1beta2-APIEndpoint><code>APIEndpoint</code></a>
</td>
<td>
<p><code>localAPIEndpoint</code> 代表的是将在此节点上部署的 API 服务器实例的端点。</p>
</td>
</tr>
<tr><td><code>certificateKey</code> <b>[必需]</b><br>
<code>string</code>
</td>
<td>
<p><code>certificateKey</code> 是在添加新的控制面节点时用来解密所下载的
Secret 中的证书的秘钥。对应的加密秘钥在 InitConfiguration 结构中。</p>
</td>
</tr>
</tbody>
</table>
<h2 id=kubeadm-k8s-io-v1beta2-LocalEtcd><code>LocalEtcd</code> </h2>
<p><strong>出现在：</strong></p>
<ul>
<li><a href=#kubeadm-k8s-io-v1beta2-Etcd>Etcd</a></li>
</ul>
<p>LocalEtcd 描述的是 kubeadm 要使用的本地 etcd 集群。</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>ImageMeta</code> <b>[必需]</b><br>
<a href=#kubeadm-k8s-io-v1beta2-ImageMeta><code>ImageMeta</code></a>
</td>
<td>（<code>ImageMeta</code> 结构的字段被嵌入到此类型中。）
<p>ImageMeta 允许用户为 etcd 定制要使用的容器。</p>
</td>
</tr>
<tr><td><code>dataDir</code> <b>[必需]</b><br>
<code>string</code>
</td>
<td>
<p><code>dataDir</code> 是 etcd 用来存放数据的目录。
默认值为 "/var/lib/etcd"。</p>
</td>
</tr>
<tr><td><code>extraArgs</code> <b>[必需]</b><br>
<code>map[string]string</code>
</td>
<td>
<p><code>extraArgs</code> 是为 etcd 可执行文件提供的额外参数，用于在静态
Pod 中运行 etcd。映射中的每一个键对应命令行上的一个标志参数，只是去掉了前置的连字符。</p>
</td>
</tr>
<tr><td><code>serverCertSANs</code> <b>[必需]</b><br>
<code>[]string</code>
</td>
<td>
<p><code>serverCertSANs</code> 为 etcd 服务器的签名证书设置额外的主体替代名
（Subject Alternative Names，SAN）。</p>
</td>
</tr>
<tr><td><code>peerCertSANs</code> <b>[必需]</b><br>
<code>[]string</code>
</td>
<td>
<p><code>peerCertSANs</code> 为 etcd 的对等端签名证书设置额外的主体替代名
（Subject Alternative Names，SAN）。</p>
</td>
</tr>
</tbody>
</table>
<h2 id=kubeadm-k8s-io-v1beta2-Networking><code>Networking</code> </h2>
<p><strong>出现在：</strong></p>
<ul>
<li><a href=#kubeadm-k8s-io-v1beta2-ClusterConfiguration>ClusterConfiguration</a></li>
</ul>
<p>Networking 中包含描述集群网络配置的元素。</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>serviceSubnet</code> <b>[必需]</b><br>
<code>string</code>
</td>
<td>
<p><code>serviceSubnet</code> 是 Kubernetes 服务所使用的的子网。
默认值为 "10.96.0.0/12"。</p>
</td>
</tr>
<tr><td><code>podSubnet</code> <b>[必需]</b><br>
<code>string</code>
</td>
<td>
<p><code>podSubnet</code> 为 Pod 所使用的子网。</p>
</td>
</tr>
<tr><td><code>dnsDomain</code> <b>[必需]</b><br>
<code>string</code>
</td>
<td>
<p><code>dnsDomain</code> 是 Kubernetes 服务所使用的的 DNS 域名。
默认值为 "cluster.local"。</p>
</td>
</tr>
</tbody>
</table>
<h2 id=kubeadm-k8s-io-v1beta2-NodeRegistrationOptions><code>NodeRegistrationOptions</code> </h2>
<p><strong>出现在：</strong></p>
<ul>
<li><a href=#kubeadm-k8s-io-v1beta2-InitConfiguration>InitConfiguration</a></li>
<li><a href=#kubeadm-k8s-io-v1beta2-JoinConfiguration>JoinConfiguration</a></li>
</ul>
<p>NodeRegistrationOptions 包含向集群中注册新的控制面或节点所需要的信息；
节点注册可能通过 "kubeadm init" 或 "kubeadm join" 完成。</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>name</code> <b>[必需]</b><br>
<code>string</code>
</td>
<td>
<p><code>name</code> 是 Node API 对象的 <code>.metadata.name</code> 字段值；
该 API 对象会在此 <code>kubeadm init</code> 或 <code>kubeadm join</code> 操作期间创建。
在提交给 API 服务器的 kubelet 客户端证书中，此字段也用作其 <code>CommonName</code>。
如果未指定则默认为节点的主机名。</p>
</td>
</tr>
<tr><td><code>criSocket</code> <b>[必需]</b><br>
<code>string</code>
</td>
<td>
<p><code>criSocket</code> 用来读取容器运行时的信息。
此信息会被以注解的方式添加到 Node API 对象至上，用于后续用途。</p>
</td>
</tr>
<tr><td><code>taints</code> <b>[必需]</b><br>
<a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/#taint-v1-core><code>[]core/v1.Taint</code></a>
</td>
<td>
<p><code>tains</code> 设定 Node API 对象被注册时要附带的污点。
若未设置此字段（即字段值为 null）, 在 <code>kubeadm init</code> 期间，节点与控制面之间的通信。
默认值为污点默认设置为 <code>taints: ["node-role.kubernetes.io/master:""]</code>。
如果你不希望为控制面节点设置污点，可以在 YAML 中将此字段设置为空的列表，即
<code>taints: []</code>。 此字段仅用在 Node 注册期间。</p>
</td>
</tr>
<tr><td><code>kubeletExtraArgs</code> <b>[必需]</b><br>
<code>map[string]string</code>
</td>
<td>
<p><code>kubeletExtraArgs</code> 用来向 kubelet 传递额外参数。
这里的参数会通过 kubeadm 在运行时写入的、由 kubelet 来读取的环境文件来传递给 kubelet 命令行。
这里的设置会覆盖掉 'kubelet-config-1.X' ConfigMap 中包含的一般性的配置。
命令行标志在解析时优先级更高。
这里的设置值仅作用于 kubeadm 运行所在的节点。
映射中的每个键对应命令行中的一个标志参数，只是去掉了前置的连字符。</p>
</td>
</tr>
<tr><td><code>ignorePreflightErrors</code> <b>[必需]</b><br>
<code>[]string</code>
</td>
<td>
<p><code>ignorePreflightErrors</code> 提供一组在当前节点被注册时可以忽略掉的预检错误。</p>
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-675226e13e76ef189fe0156f7e52353a>12.9 - kubeadm 配置 (v1beta3)</h1>
<h2>概述</h2>
<p>包 v1beta3 定义 kubeadm 配置文件格式的 v1beta3 版本。
此版本改进了 v1beta2 的格式，修复了一些小问题并添加了一些新的字段。</p>
<p>从 v1beta2 版本以来的变更列表：</p>
<ul>
<li>已弃用的字段 "ClusterConfiguration.useHyperKubeImage" 现在被移除。
kubeadm 不再支持 hyperkube 镜像。</li>
<li>字段 "ClusterConfiguration.dns.type" 已经被移除，因为 CoreDNS 是 kubeadm 所支持
的唯一 DNS 服务器类型。</li>
<li>保存私密信息的字段现在包含了 "datapolicy" 标记（tag）。
这一标记会导致 API 结构通过 klog 打印输出时，会忽略这些字段的值。</li>
<li>添加了 "InitConfiguration.skipPhases", "JoinConfiguration.skipPhases"，
以允许在执行 kubeadm init/join 命令时略过某些阶段。</li>
<li>添加了 "InitConfiguration.nodeRegistration.imagePullPolicy" 和
"JoinConfiguration.nodeRegistration.imagePullPolicy"
以允许在 kubeadm init 和 kubeadm join 期间指定镜像拉取策略。
这两个字段的值必须是 "Always"、"Never" 或 "IfNotPresent&quot 之一。
默认值是 &quot;IfNotPresent"，也是添加此字段之前的默认行为。</li>
<li>添加了 "InitConfiguration.patches.directory",
"JoinConfiguration.patches.directory" 以允许用户配置一个目录，
kubeadm 将从该目录中提取组件的补丁包。</li>
<li>BootstrapToken&#8727; API 和相关的工具被从 "kubeadm" API 组中移出，
放到一个新的 "bootstraptoken" 组中。kubeadm API 版本 v1beta3 不再包含
BootstrapToken&#8727; 结构。</li>
</ul>
<p>从老的 kubeadm 配置版本迁移：</p>
<ul>
<li>kubeadm v1.15.x 及更新的版本可以用来从 v1beta1 迁移到 v1beta2 版本；</li>
<li>kubeadm v1.22.x 及更新的版本不再支持 v1beta1 和更老的 API，但可以用来
从 v1beta2 迁移到 v1beta3。</li
</ul>
<h2>基础知识</h2>
<p>配置 kubeadm 的推荐方式是使用 <code>--config</code> 选项向其传递一个 YAML 配置文件。
kubeadm 配置文件中定义的某些配置选项也可以作为命令行标志来使用，不过这种
方法所支持的都是一些最常见的、最简单的使用场景。</p>
<p>一个 kubeadm 配置文件中可以包含多个配置类型，使用三根横线（<code>---</code>）作为分隔符。</p>
<p>kubeadm 支持以下配置类型：</p>
<pre style=background-color:#fff><span style=color:#000;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>kubeadm.k8s.io/v1beta3<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#000;font-weight:700>kind</span>:<span style=color:#bbb> </span>InitConfiguration<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#000;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>kubeadm.k8s.io/v1beta3<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#000;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterConfiguration<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#000;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>kubelet.config.k8s.io/v1beta1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#000;font-weight:700>kind</span>:<span style=color:#bbb> </span>KubeletConfiguration<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#000;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>kubeproxy.config.k8s.io/v1alpha1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#000;font-weight:700>kind</span>:<span style=color:#bbb> </span>KubeProxyConfiguration<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#000;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>kubeadm.k8s.io/v1beta3<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#000;font-weight:700>kind</span>:<span style=color:#bbb> </span>JoinConfiguration<span style=color:#bbb>
</span></pre>
<p>要输出 "init" 和 "join" 动作的默认值，可以使用下面的命令：</p>
<pre style=background-color:#fff>kubeadm config print init-defaults
kubeadm config print join-defaults
</pre>
<p>配置文件中必须包含的配置类型列表取决于你在执行的动作（<code>init</code> 或 <code>join</code>），
也取决于你要使用的配置选项（默认值或者高级定制）。</p>
<p>如果某些配置类型没有提供，或者仅部分提供，kubeadm 将使用默认值；
kubeadm 所提供的默认值在必要时也会保证其在多个组件之间是一致的
（例如控制器管理器上的 <code>--cluster-cidr</code> 参数和 kube-proxy 上的
<code>clusterCIDR</code>）。</p>
<p>用户总是可以重载默认配置值，唯一的例外是一小部分与安全性相关联的配置
（例如在 API 服务器上强制实施 Node 和 RBAC 鉴权模式）。</p>
<p>如果用户所提供的配置类型并非你所执行的操作需要的，kubeadm 会忽略这些配置类型
并打印警告信息。</p>
<h2>kubeadm init 配置类型</h2>
<p>当带有 <code>--config</code> 选项来执行 kubeadm init 命令时，可以使用下面的配置类型：
`InitConfiguration`、`ClusterConfiguration`、`KubeProxyConfiguration`、`KubeletConfiguration`，
但 `InitConfiguration` 和 `ClusterConfiguration`
之间只有一个是必须提供的。</p>
<pre style=background-color:#fff><span style=color:#000;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>kubeadm.k8s.io/v1beta3<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#000;font-weight:700>kind</span>:<span style=color:#bbb> </span>InitConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#000;font-weight:700>bootstrapTokens</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#000;font-weight:700>nodeRegistration</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></pre>
<p>类型 InitConfiguration 用来配置运行时设置，就 kubeadm init 命令而言，包括
启动引导令牌以及所有与 kubeadm 所在节点相关的设置，包括：</p>
<ul>
<li>nodeRegistration：其中包含与向集群注册新节点相关的字段；使用这个类型来
定制节点名称、要使用的 CRI 套接字或者其他仅对当前节点起作用的设置
（例如节点 IP 地址）。</li>
<li>localAPIEndpoint：代表的是要部署到此节点上的 API 服务器示例的端点；
使用这个类型可以完成定制 API 服务器公告地址这类操作。</li>
</ul>
<pre><code>apiVersion: kubeadm.k8s.io/v1beta3
kind: ClusterConfiguration
networking:
  ...
etcd:
  ...
apiServer:
  extraArgs:
    ...
  extraVolumes:
    ...
...
</code></pre>
<p>类型 `ClusterConfiguration` 用来定制集群范围的设置，具体包括以下设置：</p>
<ul>
<li><code>networking</code>：其中包含集群的网络拓扑配置。使用这一部分可以定制 Pod 的
子网或者 Service 的子网。</li>
<li><code>etcd</code>：etcd 数据库的配置。例如使用这个部分可以定制本地 etcd 或者配置 API 服务器
使用一个外部的 etcd 集群。</li>
<li><code>kube-apiserver</code>、<code>kube-scheduler</code>、<code>kube-controller-manager</code>
配置：这些部分可以通过添加定制的设置或者重载 kubeadm 的默认设置来定制控制面组件。</li>
</ul>
<pre style=background-color:#fff><span style=color:#000;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>kubeproxy.config.k8s.io/v1alpha1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#000;font-weight:700>kind</span>:<span style=color:#bbb> </span>KubeProxyConfiguration<span style=color:#bbb>
</span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></pre>
<p>KubeProxyConfiguration 类型用来更改传递给在集群中部署的 kube-proxy 实例
的配置。如果此对象没有提供，或者仅部分提供，kubeadm 使用默认值。</p>
<p>关于 kube-proxy 的官方文档，可参阅
https://kubernetes.io/zh/docs/reference/command-line-tools-reference/kube-proxy/
或者 https://godoc.org/k8s.io/kube-proxy/config/v1alpha1#KubeProxyConfiguration。
</p>
<pre style=background-color:#fff><span style=color:#000;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>kubelet.config.k8s.io/v1beta1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#000;font-weight:700>kind</span>:<span style=color:#bbb> </span>KubeletConfiguration<span style=color:#bbb>
</span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></pre>
<p>KubeletConfiguration 类型用来更改传递给在集群中部署的 kubelet 实例的配置。
如果此对象没有提供，或者仅部分提供，kubeadm 使用默认值。</p>
<p>关于 kubelet 的官方文档，可参阅
https://kubernetes.io/zh/docs/reference/command-line-tools-reference/kubelet/
或者
https://godoc.org/k8s.io/kubelet/config/v1beta1#KubeletConfiguration。</p>
<p>下面是一个为执行 <code>kubeadm init</code> 而提供的、包含多个配置类型的单一 YAML 文件，
其中填充了很多部分。</p>
<pre style=background-color:#fff><span style=color:#000;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>kubeadm.k8s.io/v1beta3<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#000;font-weight:700>kind</span>:<span style=color:#bbb> </span>InitConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#000;font-weight:700>bootstrapTokens</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:#000;font-weight:700>token</span>:<span style=color:#bbb> </span><span style=color:#d14>&#34;9a08jv.c0izixklcxtmnze7&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#000;font-weight:700>description</span>:<span style=color:#bbb> </span><span style=color:#d14>&#34;kubeadm bootstrap token&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#000;font-weight:700>ttl</span>:<span style=color:#bbb> </span><span style=color:#d14>&#34;24h&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:#000;font-weight:700>token</span>:<span style=color:#bbb> </span><span style=color:#d14>&#34;783bde.3f89s0fje9f38fhf&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#000;font-weight:700>description</span>:<span style=color:#bbb> </span><span style=color:#d14>&#34;another bootstrap token&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#000;font-weight:700>usages</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- authentication<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- signing<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#000;font-weight:700>groups</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- system:bootstrappers:kubeadm:default-node-token<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#000;font-weight:700>nodeRegistration</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#000;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#d14>&#34;ec2-10-100-0-1&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#000;font-weight:700>criSocket</span>:<span style=color:#bbb> </span><span style=color:#d14>&#34;/var/run/dockershim.sock&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#000;font-weight:700>taints</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:#000;font-weight:700>key</span>:<span style=color:#bbb> </span><span style=color:#d14>&#34;kubeadmNode&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#000;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#d14>&#34;master&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#000;font-weight:700>effect</span>:<span style=color:#bbb> </span><span style=color:#d14>&#34;NoSchedule&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#000;font-weight:700>kubeletExtraArgs</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#000;font-weight:700>v</span>:<span style=color:#bbb> </span><span style=color:#099>4</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#000;font-weight:700>ignorePreflightErrors</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- IsPrivilegedUser<span style=color:#bbb>
</span><span style=color:#bbb>   </span><span style=color:#000;font-weight:700>imagePullPolicy</span>:<span style=color:#bbb> </span><span style=color:#d14>&#34;IfNotPresent&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#000;font-weight:700>localAPIEndpoint</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#000;font-weight:700>advertiseAddress</span>:<span style=color:#bbb> </span><span style=color:#d14>&#34;10.100.0.1&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#000;font-weight:700>bindPort</span>:<span style=color:#bbb> </span><span style=color:#099>6443</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#000;font-weight:700>certificateKey</span>:<span style=color:#bbb> </span><span style=color:#d14>&#34;e6a2eb8581237ab72a4f494f30285ec12a9694d750b9785706a83bfcbbbd2204&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb> </span><span style=color:#000;font-weight:700>skipPhases</span>:<span style=color:#bbb>
</span><span style=color:#bbb> </span>- addon/kube-proxy<span style=color:#bbb>
</span><span style=color:#bbb></span>---<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#000;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>kubeadm.k8s.io/v1beta3<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#000;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#000;font-weight:700>etcd</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#998;font-style:italic># one of local or external</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#000;font-weight:700>local</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#000;font-weight:700>imageRepository</span>:<span style=color:#bbb> </span><span style=color:#d14>&#34;k8s.gcr.io&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#000;font-weight:700>imageTag</span>:<span style=color:#bbb> </span><span style=color:#d14>&#34;3.2.24&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#000;font-weight:700>dataDir</span>:<span style=color:#bbb> </span><span style=color:#d14>&#34;/var/lib/etcd&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#000;font-weight:700>extraArgs</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#000;font-weight:700>listen-client-urls</span>:<span style=color:#bbb> </span><span style=color:#d14>&#34;http://10.100.0.1:2379&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#000;font-weight:700>serverCertSANs</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:#bbb> </span><span style=color:#d14>&#34;ec2-10-100-0-1.compute-1.amazonaws.com&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#000;font-weight:700>peerCertSANs</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:#d14>&#34;10.100.0.1&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#998;font-style:italic># external:</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#998;font-style:italic># endpoints:</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#998;font-style:italic># - &#34;10.100.0.1:2379&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#998;font-style:italic># - &#34;10.100.0.2:2379&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#998;font-style:italic># caFile: &#34;/etcd/kubernetes/pki/etcd/etcd-ca.crt&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#998;font-style:italic># certFile: &#34;/etcd/kubernetes/pki/etcd/etcd.crt&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#998;font-style:italic># keyFile: &#34;/etcd/kubernetes/pki/etcd/etcd.key&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#000;font-weight:700>networking</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#000;font-weight:700>serviceSubnet</span>:<span style=color:#bbb> </span><span style=color:#d14>&#34;10.96.0.0/16&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#000;font-weight:700>podSubnet</span>:<span style=color:#bbb> </span><span style=color:#d14>&#34;10.244.0.0/24&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#000;font-weight:700>dnsDomain</span>:<span style=color:#bbb> </span><span style=color:#d14>&#34;cluster.local&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#000;font-weight:700>kubernetesVersion</span>:<span style=color:#bbb> </span><span style=color:#d14>&#34;v1.21.0&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#000;font-weight:700>controlPlaneEndpoint</span>:<span style=color:#bbb> </span><span style=color:#d14>&#34;10.100.0.1:6443&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#000;font-weight:700>apiServer</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#000;font-weight:700>extraArgs</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#000;font-weight:700>authorization-mode</span>:<span style=color:#bbb> </span><span style=color:#d14>&#34;Node,RBAC&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#000;font-weight:700>extraVolumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:#000;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#d14>&#34;some-volume&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#000;font-weight:700>hostPath</span>:<span style=color:#bbb> </span><span style=color:#d14>&#34;/etc/some-path&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#000;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#d14>&#34;/etc/some-pod-path&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#000;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#000;font-weight:700>false</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#000;font-weight:700>pathType</span>:<span style=color:#bbb> </span>File<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#000;font-weight:700>certSANs</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:#d14>&#34;10.100.1.1&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:#d14>&#34;ec2-10-100-0-1.compute-1.amazonaws.com&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#000;font-weight:700>timeoutForControlPlane</span>:<span style=color:#bbb> </span>4m0s<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#000;font-weight:700>controllerManager</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#000;font-weight:700>extraArgs</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#000;font-weight:700>&#34;node-cidr-mask-size&#34;: </span><span style=color:#d14>&#34;20&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#000;font-weight:700>extraVolumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:#000;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#d14>&#34;some-volume&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#000;font-weight:700>hostPath</span>:<span style=color:#bbb> </span><span style=color:#d14>&#34;/etc/some-path&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#000;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#d14>&#34;/etc/some-pod-path&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#000;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#000;font-weight:700>false</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#000;font-weight:700>pathType</span>:<span style=color:#bbb> </span>File<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#000;font-weight:700>scheduler</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#000;font-weight:700>extraArgs</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#000;font-weight:700>address</span>:<span style=color:#bbb> </span><span style=color:#d14>&#34;10.100.0.1&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#000;font-weight:700>extraVolumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:#000;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#d14>&#34;some-volume&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#000;font-weight:700>hostPath</span>:<span style=color:#bbb> </span><span style=color:#d14>&#34;/etc/some-path&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#000;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#d14>&#34;/etc/some-pod-path&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#000;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#000;font-weight:700>false</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#000;font-weight:700>pathType</span>:<span style=color:#bbb> </span>File<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#000;font-weight:700>certificatesDir</span>:<span style=color:#bbb> </span><span style=color:#d14>&#34;/etc/kubernetes/pki&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#000;font-weight:700>imageRepository</span>:<span style=color:#bbb> </span><span style=color:#d14>&#34;k8s.gcr.io&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#000;font-weight:700>clusterName</span>:<span style=color:#bbb> </span><span style=color:#d14>&#34;example-cluster&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span>---<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#000;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>kubelet.config.k8s.io/v1beta1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#000;font-weight:700>kind</span>:<span style=color:#bbb> </span>KubeletConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#998;font-style:italic># kubelet specific options here</span><span style=color:#bbb>
</span><span style=color:#bbb></span>---<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#000;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>kubeproxy.config.k8s.io/v1alpha1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#000;font-weight:700>kind</span>:<span style=color:#bbb> </span>KubeProxyConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#998;font-style:italic># kube-proxy specific options here</span><span style=color:#bbb>
</span></pre>
<h2> kubeadm join 配置类型</h2>
<p>当带有 <code>--config</code> 选项来执行 <code>kubeadm join</code> 操作时，
需要提供 JoinConfiguration 类型。</p>
<pre style=background-color:#fff><span style=color:#000;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>kubeadm.k8s.io/v1beta3<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#000;font-weight:700>kind</span>:<span style=color:#bbb> </span>JoinConfiguration<span style=color:#bbb>
</span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></pre>
<p>JoinConfiguration 类型用来配置运行时设置，就 <code>kubeadm join</code> 而言包括
用来访问集群信息的发现方法，以及所有特定于 kubeadm 执行所在节点的设置，包括：</p>
<ul>
<li><code>nodeRegistration</code>：其中包含向集群注册新节点相关的配置字段；
使用这个类型可以定制节点名称、用使用的 CRI 套接字和所有其他仅适用于当前节点的设置
（例如节点 IP 地址）。</li>
<li><code>apiEndpoint</code>：用来代表最终要部署到此节点上的 API
服务器实例的端点。</li>
</ul>
<h2 id=resource-types>资源类型 </h2>
<ul>
<li><a href=#kubeadm-k8s-io-v1beta3-ClusterConfiguration>ClusterConfiguration</a></li>
<li><a href=#kubeadm-k8s-io-v1beta3-InitConfiguration>InitConfiguration</a></li>
<li><a href=#kubeadm-k8s-io-v1beta3-JoinConfiguration>JoinConfiguration</a></li>
</ul>
<h2 id=kubeadm-k8s-io-v1beta3-ClusterConfiguration><code>ClusterConfiguration</code> </h2>
<p>ClusterConfiguration 包含一个 kubadm 集群的集群范围配置信息。</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>apiVersion</code><br>string</td><td><code>kubeadm.k8s.io/v1beta3</code></td></tr>
<tr><td><code>kind</code><br>string</td><td><code>ClusterConfiguration</code></td></tr>
<tr><td><code>etcd</code><br>
<a href=#kubeadm-k8s-io-v1beta3-Etcd><code>Etcd</code></a>
</td>
<td>
<p><code>etcd</code> 中包含 etcd 服务的配置。</p>
</td>
</tr>
<tr><td><code>networking</code><br>
<a href=#kubeadm-k8s-io-v1beta3-Networking><code>Networking</code></a>
</td>
<td>
<code>networking</code> 字段包含集群的网络拓扑配置。
</td>
</tr>
<tr><td><code>kubernetesVersion</code><br>
<code>string</code>
</td>
<td>
<p><code>kubernetesVersion</code> 设置控制面的目标版本。</p>
</td>
</tr>
<tr><td><code>controlPlaneEndpoint</code><br>
<code>string</code>
</td>
<td>
<p><code>controlPlaneEndpoint</code> 为控制面设置一个稳定的 IP 地址或 DNS 名称。
取值可以是一个合法的 IP 地址或者 RFC-1123 形式的 DNS 子域名，二者均可以带一个
可选的 TCP 端口号。
如果 <code>controlPlaneEndpoint</code> 未设置，则使用 <code>advertiseAddress<code>
+ <code>bindPort</code>。
如果设置了 <code>controlPlaneEndpoint</code>，但未指定 TCP 端口号，则使用
<code>bindPort</code>。</p>
<p>可能的用法有：</p>
<ul>
<li>在一个包含不止一个控制面实例的集群中，该字段应该设置为放置在控制面
实例之前的外部负载均衡器的地址。</li>
<li>在带有强制性节点回收的环境中，<code>controlPlaneEndpoint</code> 可以用来
为控制面设置一个稳定的 DNS。</li>
</ul>
</td>
</tr>
<tr><td><code>apiServer</code><br>
<a href=#kubeadm-k8s-io-v1beta3-APIServer><code>APIServer</code></a>
</td>
<td>
<p><code>apiServer</code> 包含 API 服务器的一些额外配置。</p>
</td>
</tr>
<tr><td><code>controllerManager</code><br>
<a href=#kubeadm-k8s-io-v1beta3-ControlPlaneComponent><code>ControlPlaneComponent</code></a>
</td>
<td>
<p><code>controllerManager</code> 中包含控制器管理器的额外配置。</p>
</td>
</tr>
<tr><td><code>scheduler</code><br>
<a href=#kubeadm-k8s-io-v1beta3-ControlPlaneComponent><code>ControlPlaneComponent</code></a>
</td>
<td>
<p><code>scheduler</code> 包含调度器的额外配置。</p>
</td>
</tr>
<tr><td><code>dns</code><br>
<a href=#kubeadm-k8s-io-v1beta3-DNS><code>DNS</code></a>
</td>
<td>
<p><code>dns</code> 定义在集群中安装的 DNS 插件的选项。</p>
</td>
</tr>
<tr><td><code>certificatesDir</code><br>
<code>string</code>
</td>
<td>
<p><code>certificatesDir</code> 设置在何处存放或者查找所需证书。</p>
</td>
</tr>
<tr><td><code>imageRepository</code><br>
<code>string</code>
</td>
<td>
<p><code>imageRepository</code> 设置用来拉取镜像的容器仓库。
如果此字段为空，默认使用 <code>k8s.gcr.io</code>。
当 Kubernetes 用来执行 CI 构造时（Kubernetes 版本以 <code>ci/</code> 开头），
将默认使用 <code>gcr.io/k8s-staging-ci-images</code> 来拉取控制面组件镜像，
而使用 <code>k8s.gcr.io</code> 来拉取所有其他镜像。</p>
</td>
</tr>
<tr><td><code>featureGates</code><br>
<code>map[string]bool</code>
</td>
<td>
<p><code>featureGates</code> 包含用户所启用的特性门控。</p>
</td>
</tr>
<tr><td><code>clusterName</code><br>
<code>string</code>
</td>
<td>
<p>集群名称。</p>
</td>
</tr>
</tbody>
</table>
<h2 id=kubeadm-k8s-io-v1beta3-InitConfiguration><code>InitConfiguration</code> </h2>
<p>InitConfiguration 包含一组特定于 "kubeadm init" 的运行时元素。
这里的字段仅用于第一次运行 <code>kubeadm init</code> 命令。
之后，此结构中的字段信息不会再被上传到 <code>kubeadm upgrade</code> 所要使用的
<code>kubeadm-config</code> ConfigMap 中。
这些字段必须设置 "omitempty"</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>apiVersion</code><br>string</td><td><code>kubeadm.k8s.io/v1beta3</code></td></tr>
<tr><td><code>kind</code><br>string</td><td><code>InitConfiguration</code></td></tr>
<tr><td><code>bootstrapTokens</code><br>
<a href=#BootstrapToken><code>[]BootstrapToken</code></a>
</td>
<td>
<p><code>bootstrapTokens</code> 在 <code>kubeadm init</code> 执行时会被用到，
其中描述了一组要创建的启动引导令牌（Bootstrap Tokens）。
这里的信息不会被上传到 kubeadm 在集群中保存的 ConfigMap 中，部分原因是由于信息
本身比较敏感。</p>
</td>
</tr>
<tr><td><code>nodeRegistration</code><br>
<a href=#kubeadm-k8s-io-v1beta3-NodeRegistrationOptions><code>NodeRegistrationOptions</code></a>
</td>
<td>
<p><code>nodeRegistration</code> 中包含与向集群中注册新的控制面节点相关的字段。</p>
</td>
</tr>
<tr><td><code>localAPIEndpoint</code><br>
<a href=#kubeadm-k8s-io-v1beta3-APIEndpoint><code>APIEndpoint</code></a>
</td>
<td>
<p><code>localAPIEndpoint</code> 所代表的的是在此控制面节点上要部署的 API 服务器
的端点。在高可用（HA）配置中，此字段与 <code>ClusterConfiguration.controlPlaneEndpoint</code>
的取值不同：后者代表的是整个集群的全局端点，该端点上的请求会被负载均衡到每个
API 服务器。
此配置对象允许你定制本地 API 服务器所公布的、可访问的 IP/DNS 名称和端口。
默认情况下，kubeadm 会尝试自动检测默认接口上的 IP 并使用该地址。
不过，如果这种检测失败，你可以在此字段中直接设置所期望的值。</p>
</td>
</tr>
<tr><td><code>certificateKey</code><br>
<code>string</code>
</td>
<td>
<p><code>certificateKey</code> 用来设置一个秘钥，该秘钥将对 <code>uploadcerts init</code>
阶段上传到集群中某 Secret 内的秘钥和证书加密。</p>
</td>
</tr>
<tr><td><code>skipPhases</code><br>
<code>[]string</code>
</td>
<td>
<p><code>skipPhases</code> 是命令执行过程中药略过的阶段（Phases）。
通过执行命令 <code>kubeadm init --help</code> 可以获得阶段的列表。
参数标志 "--skip-phases" 优先于此字段的设置。</p>
</td>
</tr>
<tr><td><code>patches</code><br>
<a href=#kubeadm-k8s-io-v1beta3-Patches><code>Patches</code></a>
</td>
<td>
<p><code>patches</code> 包含与 <code>kubeadm init</code> 阶段 kubeadm 所部署
的组件上要应用的补丁相关的信息。</p>
</td>
</tr>
</tbody>
</table>
<h2 id=kubeadm-k8s-io-v1beta3-JoinConfiguration><code>JoinConfiguration</code> </h2>
<p>
JoinConfiguration 包含描述特定节点的元素。
</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>apiVersion</code><br>string</td><td><code>kubeadm.k8s.io/v1beta3</code></td></tr>
<tr><td><code>kind</code><br>string</td><td><code>JoinConfiguration</code></td></tr>
<tr><td><code>nodeRegistration</code><br>
<a href=#kubeadm-k8s-io-v1beta3-NodeRegistrationOptions><code>NodeRegistrationOptions</code></a>
</td>
<td>
<p>
<code>nodeRegistration</code> 包含与向集群注册控制面节点相关的字段。
</p>
</td>
</tr>
<tr><td><code>caCertPath</code><br>
<code>string</code>
</td>
<td>
<p>
<code>caCertPath</code> 是指向 SSL 证书机构的路径，该证书包用来加密
节点与控制面之间的通信。默认值为 "/etc/kubernetes/pki/ca.crt"。
</p>
</td>
</tr>
<tr><td><code>discovery</code> <b>[必需]-->[必需]</b><br>
<a href=#kubeadm-k8s-io-v1beta3-Discovery><code>Discovery</code></a>
</td>
<td>
<p>
<code>discovery</code> 设置 TLS 引导过程中 kubelet 要使用的选项。
</p>
</td>
</tr>
<tr><td><code>controlPlane</code><br>
<a href=#kubeadm-k8s-io-v1beta3-JoinControlPlane><code>JoinControlPlane</code></a>
</td>
<td>
<p>
<code>controlPlane</code> 定义要在正被加入到集群中的节点上部署的额外
控制面实例。此字段为 null 时，不会再上面部署额外的控制面实例。
</p>
</td>
</tr>
<tr><td><code>skipPhases</code><br>
<code>[]string</code>
</td>
<td>
<p>
此字段包含在命令执行过程中要略过的阶段。通过 <code>kubeadm join --help</code>
命令可以查看阶段的列表。参数 <code>--skip-phases</code> 优先于此字段。
</p>
</td>
</tr>
<tr><td><code>patches</code><br>
<a href=#kubeadm-k8s-io-v1beta3-Patches><code>Patches</code></a>
</td>
<td>
<p>
此字段包含 <code>kubeadm join</code> 阶段向 kubeadm 所部署的组件打补丁
的选项。
</p>
</td>
</tr>
</tbody>
</table>
<h2 id=kubeadm-k8s-io-v1beta3-APIEndpoint><code>APIEndpoint</code> </h2>
<p><strong>出现在：</strong></p>
<ul>
<li>
<p><a href=#kubeadm-k8s-io-v1beta3-InitConfiguration>InitConfiguration</a></p>
</li>
<li>
<p><a href=#kubeadm-k8s-io-v1beta3-JoinControlPlane>JoinControlPlane</a></p>
</li>
</ul>
<p>
APIEndpoint 结构包含某节点上部署的 API 服务器的配置元素。
</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>advertiseAddress</code><br>
<code>string</code>
</td>
<td>
<p>
<code>advertiseAddress</code> 设置 API 服务器要公布的 IP 地址。
</p>
</td>
</tr>
<tr><td><code>bindPort</code><br>
<code>int32</code>
</td>
<td>
<p>
<code>bindPort</code> 设置 API 服务器要绑定到的安全端口。默认值为 6443。
</p>
</td>
</tr>
</tbody>
</table>
<h2 id=kubeadm-k8s-io-v1beta3-APIServer><code>APIServer</code> </h2>
<p><strong>出现在：</strong></p>
<ul>
<li><a href=#kubeadm-k8s-io-v1beta3-ClusterConfiguration>ClusterConfiguration</a></li>
</ul>
<p>
APIServer 包含集群中 API 服务器部署所必需的设置。
</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>ControlPlaneComponent</code> <b>[必需]-->[必需]</b><br>
<a href=#kubeadm-k8s-io-v1beta3-ControlPlaneComponent><code>ControlPlaneComponent</code></a>
</td>
<td>（<code>ControlPlaneComponent</code> 结构的字段被嵌入到此类型中）
<span class=text-muted>无描述.</span>
</td>
</tr>
<tr><td><code>certSANs</code><br>
<code>[]string</code>
</td>
<td>
<p>
<code>certSANs</code> 设置 API 服务器签署证书所用的额外主题替代名（Subject Alternative Name，SAN）。
</p>
</td>
</tr>
<tr><td><code>timeoutForControlPlane</code><br>
<a href=https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Duration><code>meta/v1.Duration</code></a>
</td>
<td>
<p>
<code>timeoutForControlPlane</code> 用来控制我们等待 API 服务器开始运行的超时时间。
</p>
</td>
</tr>
</tbody>
</table>
<h2 id=kubeadm-k8s-io-v1beta3-BootstrapTokenDiscovery><code>BootstrapTokenDiscovery</code> </h2>
<p><strong>出现在：</strong></p>
<ul>
<li><a href=#kubeadm-k8s-io-v1beta3-Discovery>Discovery</a></li>
</ul>
<p>
BootstrapTokenDiscovery 用来设置基于引导令牌的服务发现选项。
</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>token</code> <b>[必需]-->[必需]</b><br>
<code>string</code>
</td>
<td>
<p>
<code>token</code> 用来验证从控制面获得的集群信息。
</p>
</td>
</tr>
<tr><td><code>apiServerEndpoint</code><br>
<code>string</code>
</td>
<td>
<p>
<code>apiServerEndpoint</p> 为 API 服务器的 IP 地址或者域名，从该端点可以获得集群信息。
</p>
</td>
</tr>
<tr><td><code>caCertHashes</code><br>
<code>[]string</code>
</td>
<td>
<p>
<code>caCertHashes</code> 设置一组在基于令牌来发现服务时要验证的公钥指纹。
发现过程中获得的根 CA 必须与这里的数值之一匹配。
设置为空集合意味着禁用根 CA 指纹，因而可能是不安全的。
每个哈希值的形式为 "&lt;type>:&lt;value>"，当前唯一支持的 type 为
"sha256"。
哈希值为主体公钥信息（Subject Public Key Info，SPKI）对象的 SHA-256
哈希值（十六进制编码），形式为 DER 编码的 ASN.1。
例如，这些哈希值可以使用 OpenSSL 来计算。
</p>
</td>
</tr>
<tr><td><code>unsafeSkipCAVerification</code><br>
<code>bool</code>
</td>
<td>
<p>
<code>unsafeSkipCAVerification</code> 允许在使用基于令牌的服务发现时
不使用 <code>caCertHashes</code> 来执行 CA 验证。这会弱化 kubeadm 的安全性，
因为其他节点可以伪装成控制面。
</p>
</td>
</tr>
</tbody>
</table>
<h2 id=kubeadm-k8s-io-v1beta3-ControlPlaneComponent><code>ControlPlaneComponent</code> </h2>
<p><strong>出现在：</strong></p>
<ul>
<li><a href=#kubeadm-k8s-io-v1beta3-ClusterConfiguration>ClusterConfiguration</a></li>
<li><a href=#kubeadm-k8s-io-v1beta3-APIServer>APIServer</a></li>
</ul>
<p>ControlPlaneComponent 中包含对集群中所有控制面组件都适用的设置。</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>extraArgs</code><br>
<code>map[string]string</code>
</td>
<td>
<p>
<code>extraArgs</code> 是要传递给控制面组件的一组额外的参数标志。
此映射中的每个键对应命令行上使用的标志名称，只是没有其引导连字符。
</p>
</td>
</tr>
<tr><td><code>extraVolumes</code><br>
<a href=#kubeadm-k8s-io-v1beta3-HostPathMount><code>[]HostPathMount</code></a>
</td>
<td>
<p>
<code>extraVolumes</code> 是一组额外的主机卷，需要挂载到控制面组件中。
</p>
</td>
</tr>
</tbody>
</table>
<h2 id=kubeadm-k8s-io-v1beta3-DNS><code>DNS</code> </h2>
<p><strong>出现在：</strong></p>
<ul>
<li><a href=#kubeadm-k8s-io-v1beta3-ClusterConfiguration>ClusterConfiguration</a></li>
</ul>
<p>DNS 结构定义要在集群中使用的 DNS 插件。</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>ImageMeta</code> <b>[必需]-->[必需]</b><br>
<a href=#kubeadm-k8s-io-v1beta3-ImageMeta><code>ImageMeta</code></a>
</td>
<td>（<code>ImageMeta</code> 的成员被内嵌到此类型中）。
<p>
<code>imageMeta</code> 允许对 DNS 组件所使用的的镜像作定制。
</p>
</td>
</tr>
</tbody>
</table>
<h2 id=kubeadm-k8s-io-v1beta3-Discovery><code>Discovery</code> </h2>
<p><strong>出现在：</strong></p>
<ul>
<li><a href=#kubeadm-k8s-io-v1beta3-JoinConfiguration>JoinConfiguration</a></li>
</ul>
<p>Discovery 设置 TLS 启动引导过程中 kubelet 要使用的配置选项。</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>bootstrapToken</code><br>
<a href=#kubeadm-k8s-io-v1beta3-BootstrapTokenDiscovery><code>BootstrapTokenDiscovery</code></a>
</td>
<td>
<p>
<code>bootstrapToken</code> 设置基于启动引导令牌的服务发现选项。
<code>bootstrapToken</code> 与 <code>file</code> 是互斥的。
</p>
</td>
</tr>
<tr><td><code>file</code><br>
<a href=#kubeadm-k8s-io-v1beta3-FileDiscovery><code>FileDiscovery</code></a>
</td>
<td>
<p>
<code> 用来设置一个文件或者 URL 路径，指向一个 kubeconfig 文件；该配置文件
中包含集群信息。
<code>bootstrapToken</code> 与 <code>file</code> 是互斥的。
</p>
</td>
</tr>
<tr><td><code>tlsBootstrapToken</code><br>
<code>string</code>
</td>
<td>
<p>
<code>tlsBootstrapToken</code> 是 TLS 启动引导过程中使用的令牌。
如果设置了 <code>bootstrapToken</code>，则此字段默认值为 <code>.bootstrapToken.token</code>，不过可以被重载。
如果设置了 <code>file</code>，此字段<b>必须被设置</b>，以防 kubeconfig 文件
中不包含其他身份认证信息。
</p>
</td>
</tr>
<tr><td><code>timeout</code><br>
<a href=https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Duration><code>meta/v1.Duration</code></a>
</td>
<td>
<p>
<code>timeout</code> 用来修改发现过程的超时时长。
</p>
</td>
</tr>
</tbody>
</table>
<h2 id=kubeadm-k8s-io-v1beta3-Etcd><code>Etcd</code> </h2>
<p><strong>出现在：</strong></p>
<ul>
<li><a href=#kubeadm-k8s-io-v1beta3-ClusterConfiguration>ClusterConfiguration</a></li>
</ul>
<p>Etcd 包含用来描述 etcd 配置的元素。</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>local</code><br>
<a href=#kubeadm-k8s-io-v1beta3-LocalEtcd><code>LocalEtcd</code></a>
</td>
<td>
<p>
<code>local</code> 提供配置本地 etcd 实例的选项。<code>local</code> 和
<code>external</code> 是互斥的。
</p>
</td>
</tr>
<tr><td><code>external</code><br>
<a href=#kubeadm-k8s-io-v1beta3-ExternalEtcd><code>ExternalEtcd</code></a>
</td>
<td>
<p>
<code>external</code> 描述如何连接到外部的 etcd 集群。
<code>external</code> 是互斥的。
</p>
</td>
</tr>
</tbody>
</table>
<h2 id=kubeadm-k8s-io-v1beta3-ExternalEtcd><code>ExternalEtcd</code> </h2>
<p><strong>出现在：</strong></p>
<ul>
<li><a href=#kubeadm-k8s-io-v1beta3-Etcd>Etcd</a></li>
</ul>
<p>ExternalEtcd 描述外部 etcd 集群。
kubeadm 不清楚证书文件的存放位置，因此必须单独提供证书信息。</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>endpoints</code> <b>[必需]-->[必需]</b><br>
<code>[]string</code>
</td>
<td>
<p><code>endpoints</code> 包含一组 etcd 成员的列表。</p>
</td>
</tr>
<tr><td><code>caFile</code> <b>[必需]-->[必需]</b><br>
<code>string</code>
</td>
<td>
<p><code>caFile</code> 是一个 SSL 证书机构（CA）文件，用来加密 etcd 通信。
如果使用 TLS 连接，此字段为必需字段。</p>
</td>
</tr>
<tr><td><code>certFile</code> <b>[必需]</b><br>
<code>string</code>
</td>
<td>
<p><code>certFile</code> 是一个 SSL 证书文件，用来加密 etcd 通信。
如果使用 TLS 连接，此字段为必需字段。</p>
</td>
</tr>
<tr><td><code>keyFile</code> <b>[必需]</b><br>
<code>string</code>
</td>
<td>
<p><code>keyFile</code> 是一个用来加密 etcd 通信的 SSL 秘钥文件。
此字段在使用 TLS 连接时为必填字段。</p>
</td>
</tr>
</tbody>
</table>
<h2 id=kubeadm-k8s-io-v1beta3-FileDiscovery><code>FileDiscovery</code> </h2>
<p><strong>出现在：</strong></p>
<ul>
<li><a href=#kubeadm-k8s-io-v1beta3-Discovery>Discovery</a></li>
</ul>
<p>FileDiscovery 用来指定一个文件或者 URL 路径，指向一个 kubeconfig 文件；该配置文件
可用来加载集群信息。</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>kubeConfigPath</code> <b>[必需]</b><br>
<code>string</code>
</td>
<td>
<p><code>kubeConfigPath</code> 用来指定一个文件或者 URL 路径，指向一个 kubeconfig 文件；
该配置文件可用来加载集群信息。</p>
</td>
</tr>
</tbody>
</table>
<h2 id=kubeadm-k8s-io-v1beta3-HostPathMount><code>HostPathMount</code> </h2>
<p><strong>出现在：</strong></p>
<ul>
<li><a href=#kubeadm-k8s-io-v1beta3-ControlPlaneComponent>ControlPlaneComponent</a></li>
</ul>
<p>HostPathMount 包含从宿主节点挂载的卷的信息。</p-->
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>name</code> <b>[必需]</b><br>
<code>string</code>
</td>
<td>
<p><code>name</code> 为卷在 Pod 模板中的名称。</p>
</td>
</tr>
<tr><td><code>hostPath</code> <b>[必需]</b><br>
<code>string</code>
</td>
<td>
<p><code>hostPath</code> 是要在 Pod 中挂载的卷在宿主系统上的路径。</p>
</td>
</tr>
<tr><td><code>mountPath</code> <b>[必需]</b><br>
<code>string</code>
</td>
<td>
<p><code>mountPath</code> 是 <code>hostPath</code> 在 Pod 内挂载的路径。</p>
</td>
</tr>
<tr><td><code>readOnly</code><br>
<code>bool</code>
</td>
<td>
<p><code>readOnly</code> 控制卷的读写访问模式。</p>
</td>
</tr>
<tr><td><code>pathType</code><br>
<a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/#hostpathtype-v1-core><code>core/v1.HostPathType</code></a>
</td>
<td>
<p><code>pathType</code> 是 <code>hostPath</code> 的类型。</p>
</td>
</tr>
</tbody>
</table>
<h2 id=kubeadm-k8s-io-v1beta3-ImageMeta><code>ImageMeta</code> </h2>
<p><strong>出现在：</strong></p>
<ul>
<li><a href=#kubeadm-k8s-io-v1beta3-DNS>DNS</a></li>
<li><a href=#kubeadm-k8s-io-v1beta3-LocalEtcd>LocalEtcd</a></li>
</ul>
<p>ImageMeta 用来配置来源不是 Kubernetes/kubernetes
发布过程的组件所使用的镜像。</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>imageRepository</code><br>
<code>string</code>
</td>
<td>
<p><code>imageRepository</code> 设置镜像拉取所用的容器仓库。
若未设置，则使用 ClusterConfiguration 中的 <code>imageRepository</code>。</p>
</td>
</tr>
<tr><td><code>imageTag</code><br>
<code>string</code>
</td>
<td>
<p><code>imageTag</code> 允许用户设置镜像的标签。
如果设置了此字段，则 kubeadm 不再在集群升级时自动更改组件的版本。</p>
</td>
</tr>
</tbody>
</table>
<h2 id=kubeadm-k8s-io-v1beta3-JoinControlPlane><code>JoinControlPlane</code> </h2>
<p><strong>出现在：</strong></p>
<ul>
<li><a href=#kubeadm-k8s-io-v1beta3-JoinConfiguration>JoinConfiguration</a></li>
</ul>
<p>JoinControlPlane 包含在正在加入集群的节点上要部署的额外的控制面组件的
设置。</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>localAPIEndpoint</code><br>
<a href=#kubeadm-k8s-io-v1beta3-APIEndpoint><code>APIEndpoint</code></a>
</td>
<td>
<p><code>localAPIEndpoint</code> 代表的是将在此节点上部署的 API 服务器实例
的端点。</p>
</td>
</tr>
<tr><td><code>certificateKey</code><br>
<code>string</code>
</td>
<td>
<p><code>certificateKey</code> 是在添加新的控制面节点时用来解密所下载的
Secret 中的证书的秘钥。对应的加密秘钥在 InitConfiguration 结构中。</p>
</td>
</tr>
</tbody>
</table>
<h2 id=kubeadm-k8s-io-v1beta3-LocalEtcd><code>LocalEtcd</code> </h2>
<p><strong>出现在：</strong></p>
<ul>
<li><a href=#kubeadm-k8s-io-v1beta3-Etcd>Etcd</a></li>
</ul>
<p>LocalEtcd 描述的是 kubeadm 要使用的本地 etcd 集群。</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>ImageMeta</code> <b>[必需]</b><br>
<a href=#kubeadm-k8s-io-v1beta3-ImageMeta><code>ImageMeta</code></a>
</td>
<td>（<code>ImageMeta</code> 结构的字段被嵌入到此类型中。）
<p>ImageMeta 允许用户为 etcd 定制要使用的容器。</p>
</td>
</tr>
<tr><td><code>dataDir</code> <b>[必需]</b><br>
<code>string</code>
</td>
<td>
<p><code>dataDir</code> 是 etcd 用来存放数据的目录。
默认值为 "/var/lib/etcd"。</p>
</td>
</tr>
<tr><td><code>extraArgs</code><br>
<code>map[string]string</code>
</td>
<td>
<p><code>extraArgs</code> 是为 etcd 可执行文件提供的额外参数，用于在静态
Pod 中运行 etcd。映射中的每一个键对应命令行上的一个标志参数，只是去掉了
前置的连字符。</p>
</td>
</tr>
<tr><td><code>serverCertSANs</code><br>
<code>[]string</code>
</td>
<td>
<p><code>serverCertSANs</code> 为 etcd 服务器的签名证书设置额外的
主体替代名（Subject Alternative Names，SAN）。</p>
</td>
</tr>
<tr><td><code>peerCertSANs</code><br>
<code>[]string</code>
</td>
<td>
<p><code>peerCertSANs</code> 为 etcd 的对等端签名证书设置额外的
主体替代名（Subject Alternative Names，SAN）。</p>
</td>
</tr>
</tbody>
</table>
<h2 id=kubeadm-k8s-io-v1beta3-Networking><code>Networking</code> </h2>
<p><strong>出现在：</strong></p>
<ul>
<li><a href=#kubeadm-k8s-io-v1beta3-ClusterConfiguration>ClusterConfiguration</a></li>
</ul>
<p>Networking 中包含描述集群网络配置的元素。</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>serviceSubnet</code><br>
<code>string</code>
</td>
<td>
<p><code>serviceSubnet</code> 是 Kubernetes 服务所使用的的子网。
默认值为 "10.96.0.0/12"。</p>
</td>
</tr>
<tr><td><code>podSubnet</code><br>
<code>string</code>
</td>
<td>
<p><code>podSubnet</code> 为 Pod 所使用的子网。</p>
</td>
</tr>
<tr><td><code>dnsDomain</code><br>
<code>string</code>
</td>
<td>
<p><code>dnsDomain</code> 是 Kubernetes 服务所使用的的 DNS 域名。
默认值为 "cluster.local"。</p>
</td>
</tr>
</tbody>
</table>
<h2 id=kubeadm-k8s-io-v1beta3-NodeRegistrationOptions><code>NodeRegistrationOptions</code> </h2>
<p><strong>出现在：</strong></p>
<ul>
<li><a href=#kubeadm-k8s-io-v1beta3-InitConfiguration>InitConfiguration</a></li>
<li><a href=#kubeadm-k8s-io-v1beta3-JoinConfiguration>JoinConfiguration</a></li>
</ul>
<p>NodeRegistrationOptions 包含向集群中注册新的控制面或节点所需要的信息；
节点注册可能通过 "kubeadm init" 或 "kubeadm join" 完成。</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>name</code><br>
<code>string</code>
</td>
<td>
<p><code>name</code> 是 Node API 对象的 <code>.metadata.name</code> 字段值；
该 API 对象会在此 <code>kubeadm init</code> 或 <code>kubeadm join</code> 操作期间创建。
在提交给 API 服务器的 kubelet 客户端证书中，此字段也用作其 <code>CommonName</code>。
如果未指定则默认为节点的主机名。</p>
</td>
</tr>
<tr><td><code>criSocket</code><br>
<code>string</code>
</td>
<td>
<p><code>criSocket</code> 用来读取容器运行时的信息。
此信息会被以注解的方式添加到 Node API 对象至上，用于后续用途。</p>
</td>
</tr>
<tr><td><code>taints</code> <b>[必需]</b><br>
<a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/#taint-v1-core><code>[]core/v1.Taint</code></a>
</td>
<td>
<p><code>tains</code> 设定 Node API 对象被注册时要附带的污点。
若未设置此字段（即字段值为 null）, 在 <code>kubeadm init</code> 期间，节点与控制面之间的通信。默认值为污点默认设置为 <code>taints: ["node-role.kubernetes.io/master:""]</code>。
如果你不希望为控制面节点设置污点，可以在 YAML 中将此字段设置为空的列表，即
<code>taints: []</code>。 此字段仅用在 Node 注册期间。</p>
</td>
</tr>
<tr><td><code>kubeletExtraArgs</code><br>
<code>map[string]string</code>
</td>
<td>
<p><code>kubeletExtraArgs</code> 用来向 kubelet 传递额外参数。
这里的参数会通过 kubeadm 在运行时写入的、由 kubelet 来读取的环境文件来
传递给 kubelet 命令行。
这里的设置会覆盖掉 'kubelet-config-1.X' ConfigMap 中包含的一般性的配置。
命令行标志在解析时优先级更高。
这里的设置值仅作用于 kubeadm 运行所在的节点。
映射中的每个键对应命令行中的一个标志参数，只是去掉了前置的连字符。</p>
</td>
</tr>
<tr><td><code>ignorePreflightErrors</code><br>
<code>[]string</code>
</td>
<td>
<p><code>ignorePreflightErrors</code> 提供一组在当前节点被注册时可以
忽略掉的预检错误。</p>
</td>
</tr>
<tr><td><code>imagePullPolicy</code><br>
<a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/#pullpolicy-v1-core><code>core/v1.PullPolicy</code></a>
</td>
<td>
<p><code>imagePullPolicy</code> 设定 "kubeadm init" 和 "kubeadm join"
操作期间的镜像拉取策略。此字段的取值可以是 "Always"、"IfNotPresent" 或
"Never" 之一。
若此字段未设置，则 kubeadm 使用 "IfNotPresent" 作为其默认值，换言之，
当镜像在主机上不存在时才执行拉取操作。</p>
</td>
</tr>
</tbody>
</table>
<h2 id=kubeadm-k8s-io-v1beta3-Patches><code>Patches</code> </h2>
<p><strong>出现在：</strong></p>
<ul>
<li><a href=#kubeadm-k8s-io-v1beta3-JoinConfiguration>JoinConfiguration</a></li>
</ul>
<p>Patches 包含要向 kubeadm 所部署的组件应用的补丁信息。</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>directory</code><br>
<code>string</code>
</td>
<td>
<p><code>directory</code> 是指向某目录的路径，该目录中包含名为
"target[suffix][+patchtype].extension" 的文件。
例如，"kube-apiserver0+merge.yaml" 或者 "etcd.json"。
"target" 可以是 "kube-apiserver"、"kube-controller-manager"、
"kube-scheduler"、"etcd" 之一。
"patchtype" 可以是 "strategic"、"merge" 或者 "json"，
其取值对应 kubectl 所支持的补丁形式。
"patchtype" 的默认值是 "strategic"。
"extension" 必须是 "json" 或者 "yaml"。
"suffix" 是一个可选的字符串，用来确定按字母表顺序来应用时，哪个补丁最先被应用。</p>
</td>
</tr>
</tbody>
</table>
<h2 id=BootstrapToken><code>BootstrapToken</code> </h2>
<p><strong>出现在：</strong></p>
<ul>
<li><a href=#kubeadm-k8s-io-v1beta3-InitConfiguration>InitConfiguration</a></li>
</ul>
<p>BootstrapToken 描述的是一个启动引导令牌，以 Secret 形式存储在集群中。</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>token</code> <b>[必需]</b><br>
<a href=#BootstrapTokenString><code>BootstrapTokenString</code></a>
</td>
<td>
<p><code>token</code> 用来在节点与控制面之间建立双向的信任关系。
在向集群中添加节点时使用。</p>
</td>
</tr>
<tr><td><code>description</code><br>
<code>string</code>
</td>
<td>
<p><code>description</code> 设置一个对人友好的消息，说明为什么此令牌
会存在以及其目标用途，这样其他管理员能够知道其目的。</p>
</td>
</tr>
<tr><td><code>ttl</code><br>
<a href=https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Duration><code>meta/v1.Duration</code></a>
</td>
<td>
<p><code>ttl</code> 定义此令牌的声明周期。默认为 <code>24h</code>。
<code>expires</code> 和 <code>ttl</code> 是互斥的。</p>
</td>
</tr>
<tr><td><code>expires</code><br>
<a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/#time-v1-meta><code>meta/v1.Time</code></a>
</td>
<td>
<p><code>expires</code> 设置此令牌过期的时间戳。默认为在运行时基于
<code>ttl</code> 来决定。
<code>expires</code> 和 <code>ttl</code> 是互斥的。</p>
</td>
</tr>
<tr><td><code>usages</code><br>
<code>[]string</code>
</td>
<td>
<p><code>usages</code> 描述此令牌的可能使用方式。默认情况下，令牌可用于
建立双向的信任关系；不过这里可以改变默认用途。</p>
</td>
</tr>
<tr><td><code>groups</code><br>
<code>[]string</code>
</td>
<td>
<p><code>groups</code> 设定此令牌被用于身份认证时对应的附加用户组。</p>
</td>
</tr>
</tbody>
</table>
<h2 id=BootstrapTokenString><code>BootstrapTokenString</code> </h2>
<p><strong>出现在：</strong></p>
<ul>
<li><a href=#BootstrapToken>BootstrapToken</a></li>
</ul>
<p>BootstrapTokenString 形式为 <code>abcdef.abcdef0123456789</code> 的一个令牌，
用来从加入集群的节点角度验证 API 服务器的身份，或者 "kubeadm join"
在节点启动引导是作为一种身份认证方法。
此令牌的生命期是短暂的，并且应该如此。</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>id</code> <b>[必需]</b><br>
<code>string</code>
</td>
<td>
<span class=text-muted>无描述</span>
</td>
</tr>
<tr><td><code>secret</code> <b>[必需]</b><br>
<code>string</code>
</td>
<td>
<span class=text-muted>无描述</span>
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-f0a175531432662368ed2e01f663b35f>12.10 - Kubelet 配置 (v1alpha1)</h1>
<h2 id=资源类型>资源类型</h2>
<ul>
<li><a href=#kubelet-config-k8s-io-v1alpha1-CredentialProviderConfig>CredentialProviderConfig</a></li>
</ul>
<h2 id=FormatOptions><code>FormatOptions</code> </h2>
<p><strong>出现在：</strong></p>
<ul>
<li><a href=#LoggingConfiguration>LoggingConfiguration</a></li>
</ul>
<p>FormatOptions 包含为不同类型日志格式提供的选项。</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>json</code> <b>[必需]</b><br>
<a href=#JSONOptions><code>JSONOptions</code></a>
</td>
<td>
[试验特性] <code>json</code> 中包含 "json" 日志格式的选项。
</td>
</tr>
</tbody>
</table>
<h2 id=JSONOptions><code>JSONOptions</code> </h2>
<p><strong>出现在：</strong></p>
<ul>
<li><a href=#FormatOptions>FormatOptions</a></li>
</ul>
<p>JSONOptions 包含用于 "json" 日志格式的选项。</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>splitStream</code> <b>[必需]</b><br>
<code>bool</code>
</td>
<td>
[试验特性] <code>splitStream</code> 将错误信息重定向到标准错误输出（stderr），
将提示信息重定向到标准输出（stdout），并为二者提供缓存。默认配置是将两类信息都写出到标准输出，
并且不提供缓存。
</td>
</tr>
<tr><td><code>infoBufferSize</code> <b>[必需]</b><br>
<a href=https://pkg.go.dev/k8s.io/apimachinery/pkg/api/resource#QuantityValue><code>k8s.io/apimachinery/pkg/api/resource.QuantityValue</code></a>
</td>
<td>
[试验特性] <code>infoBufferSize</code> 设置使用分离数据流时信息数据流的大小。
默认值是 0，意味着禁止缓存。
</td>
</tr>
</tbody>
</table>
<h2 id=VModuleConfiguration><code>VModuleConfiguration</code> </h2>
<p>（<code>[]k8s.io/component-base/config/v1alpha1.VModuleItem</code> 的别名）</p>
<p><strong>出现在：</strong></p>
<ul>
<li><a href=#LoggingConfiguration>LoggingConfiguration</a></li>
</ul>
<p>VModuleConfiguration 是一个集合，其中包含一个个的文件名（或者文件名模式）
及对应的详细程度阈值。</p>
<h2 id=kubelet-config-k8s-io-v1alpha1-CredentialProviderConfig><code>CredentialProviderConfig</code> </h2>
<p>CredentialProviderConfig 包含有关每个 exec 凭据提供者的配置信息。
Kubelet 从磁盘上读取这些配置信息，并根据 CredentialProvider 类型启用各个提供者。</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>apiVersion</code><br>string</td><td><code>kubelet.config.k8s.io/v1alpha1</code></td></tr>
<tr><td><code>kind</code><br>string</td><td><code>CredentialProviderConfig</code></td></tr>
<tr><td><code>providers</code> <b>[必需]</b><br>
<a href=#kubelet-config-k8s-io-v1alpha1-CredentialProvider><code>[]CredentialProvider</code></a>
</td>
<td>
<code>providers</code> 是一组凭据提供者插件，这些插件会被 kubelet 启用。
多个提供者可以匹配到同一镜像上，这时，来自所有提供者的凭据信息都会返回给 kubelet。
如果针对同一镜像调用了多个提供者，则结果会被组合起来。如果提供者返回的认证主键有重复，
列表中先出现的提供者所返回的值将被使用。
</td>
</tr>
</tbody>
</table>
<h2 id=kubelet-config-k8s-io-v1alpha1-CredentialProvider><code>CredentialProvider</code> </h2>
<p><strong>出现在：</strong></p>
<ul>
<li><a href=#kubelet-config-k8s-io-v1alpha1-CredentialProviderConfig>CredentialProviderConfig</a></li>
</ul>
<p>CredentialProvider 代表的是要被 kubelet 调用的一个 exec 插件。
这一插件只会在所拉取的镜像与该插件所处理的镜像匹配时才会被调用（参见 <code>matchImages</code>）。</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>name</code> <b>[必需]</b><br>
<code>string</code>
</td>
<td>
<code>name</code> 是凭据提供者的名称（必需）。此名称必须与 kubelet
所看到的提供者可执行文件的名称匹配。可执行文件必须位于 kubelet 的
<code>bin</code> 目录（通过 <code>--image-credential-provider-bin-dir</code> 设置）下。
</td>
</tr>
<tr><td><code>matchImages</code> <b>[必需]</b><br>
<code>[]string</code>
</td>
<td>
<p><code>matchImages</code> 是一个必须设置的字符串列表，用来匹配镜像以便确定是否要调用此提供者。
如果字符串之一与 kubelet 所请求的镜像匹配，则此插件会被调用并给予提供凭证的机会。
镜像应该包含镜像库域名和 URL 路径。</p>
<p><code>matchImages</code> 中的每个条目都是一个模式字符串，其中可以包含端口号和路径。
域名部分可以包含统配符，但端口或路径部分不可以。通配符可以用作子域名，例如
'&#8727;.k8s.io' 或 'k8s.&#8727;.io'，以及顶级域名，如 'k8s.&#8727;'。</p>
<p>对类似 'app&#8727;.k8s.io' 这类部分子域名的匹配也是支持的。
每个通配符只能用来匹配一个子域名段，所以 '&#8727;.io' 不会匹配 '&#8727;.k8s.io'。</p>
<p>镜像与 <code>matchImages</code> 之间存在匹配时，以下条件都要满足：</p>
<ul>
<li>二者均包含相同个数的域名部分，并且每个域名部分都对应匹配；</li>
<li><code>matchImages</code> 条目中的 URL 路径部分必须是目标镜像的 URL 路径的前缀；</li>
<li>如果 <code>matchImages</code> 条目中包含端口号，则端口号也必须与镜像端口号匹配。</li>
</ul>
<p><code>matchImages</code> 的一些示例如下：</p>
<ul>
<li>123456789.dkr.ecr.us-east-1.amazonaws.com</li>
<li>&#8727;.azurecr.io</li>
<li>gcr.io</li>
<li>&#8727;.&#8727;.registry.io</li>
<li>registry.io:8080/path</li>
</ul>
</td>
</tr>
<tr><td><code>defaultCacheDuration</code> <b>[必需]</b><br>
<a href=https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Duration><code>meta/v1.Duration</code></a>
</td>
<td>
<code>defaultCacheDuration</code> 是插件在内存中缓存凭据的默认时长，
在插件响应中没有给出缓存时长时，使用这里设置的值。此字段是必需的。
</td>
</tr>
<tr><td><code>apiVersion</code> <b>[必需]</b><br>
<code>string</code>
</td>
<td>
<p>要求 exec 插件 CredentialProviderRequest 请求的输入版本。
所返回的 CredentialProviderResponse 必须使用与输入相同的编码版本。当前支持的值有：</p>
<ul>
<li><code>credentialprovider.kubelet.k8s.io/v1alpha1</code></li>
</ul>
</td>
</tr>
<tr><td><code>args</code><br>
<code>[]string</code>
</td>
<td>
在执行插件可执行文件时要传递给命令的参数。
</td>
</tr>
<tr><td><code>env</code><br>
<a href=#kubelet-config-k8s-io-v1alpha1-ExecEnvVar><code>[]ExecEnvVar</code></a>
</td>
<td>
<code>env</code> 定义要提供给插件进程的额外的环境变量。
这些环境变量会与主机上的其他环境变量以及 client-go 所使用的环境变量组合起来，
一起传递给插件。
</td>
</tr>
</tbody>
</table>
<h2 id=kubelet-config-k8s-io-v1alpha1-ExecEnvVar><code>ExecEnvVar</code> </h2>
<p><strong>出现在：</strong></p>
<ul>
<li><a href=#kubelet-config-k8s-io-v1alpha1-CredentialProvider>CredentialProvider</a></li>
</ul>
<p>ExecEnvVar 用来在执行基于 exec 的凭据插件时设置环境变量。</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>name</code> <b>[必需]</b><br>
<code>string</code>
</td>
<td>
环境变量名称。
</td>
</tr>
<tr><td><code>value</code> <b>[必需]</b><br>
<code>string</code>
</td>
<td>
环境变量取值。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-aaa2b8b78fe84a05914c155652d10956>12.11 - Kubelet 配置 (v1beta1)</h1>
<h2 id=资源类型>资源类型</h2>
<ul>
<li><a href=#kubelet-config-k8s-io-v1beta1-KubeletConfiguration>KubeletConfiguration</a></li>
<li><a href=#kubelet-config-k8s-io-v1beta1-SerializedNodeConfigSource>SerializedNodeConfigSource</a></li>
</ul>
<h2 id=kubelet-config-k8s-io-v1beta1-KubeletConfiguration><code>KubeletConfiguration</code> </h2>
<p>KubeletConfiguration 中包含 Kubelet 的配置。</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>apiVersion</code><br>string</td><td><code>kubelet.config.k8s.io/v1beta1</code></td></tr>
<tr><td><code>kind</code><br>string</td><td><code>KubeletConfiguration</code></td></tr>
<tr><td><code>enableServer</code> <b>[必需]</b><br>
<code>bool</code>
</td>
<td>
<p><code>enableServer</code> 会启用 kubelet 的安全服务器。</p>
<p>注意：kubelet 的不安全端口由 <code>readOnlyPort</code> 选项控制。</p>
<p>当 <code>DynamicKubeletConfig</code> （已弃用，默认为关闭）被启用时，
如果动态更新了此字段，请考虑可能会影响到与 kubelet 服务器交互的组件。</p>
<p>默认值：<code>true</code></p>
</td>
</tr>
<tr><td><code>staticPodPath</code><br>
<code>string</code>
</td>
<td>
<p><code>staticPodPath</code> 是指向要运行的本地（静态）Pod 的目录，
或者指向某个静态 Pod 文件的路径。</p>
<p>当 <code>DynamicKubeletConfig</code> （已弃用，默认为关闭）被启用时，
如果动态更新了此字段，请考虑新路径下所给的静态 Pod 集合可能与 kubelet
启动时所看到的集合不同，而这一差别可能会扰乱节点状态。</p>
<p>默认值：""</p>
</td>
</tr>
<tr><td><code>syncFrequency</code><br>
<a href=https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Duration><code>meta/v1.Duration</code></a>
</td>
<td>
<p><code>syncFrequency</code> 是对运行中的容器和配置进行同步的最长周期。</p>
<p>当 <code>DynamicKubeletConfig</code> （已弃用，默认为关闭）被启用时，
如果动态更新了此字段，请考虑缩短这一同步周期可能会带来负面的性能影响，
尤其当节点上 Pod 个数增加时。相反，增加此周期长度时可能会导致 ConfigMap、
Secret 这类资源未被及时更新。</p>
<p>默认值："1m"</p>
</td>
</tr>
<tr><td><code>fileCheckFrequency</code><br>
<a href=https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Duration><code>meta/v1.Duration</code></a>
</td>
<td>
<p><code>fileCheckFrequency</code> 是对配置文件中新数据进行检查的时间间隔值。</p>
<p>当 <code>DynamicKubeletConfig</code> （已弃用，默认为关闭）被启用时，
如果动态更新了此字段，请考虑缩短此时长会导致 kubelet 更为频繁地重新加载其静态 Pod 配置，
而这会带来负面的性能影响。</p>
<p>默认值："20s"</p>
</td>
</tr>
<tr><td><code>httpCheckFrequency</code><br>
<a href=https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Duration><code>meta/v1.Duration</code></a>
</td>
<td>
<p><code>httpCheckFrequency</code> 是对 HTTP 服务器上新数据进行检查的时间间隔值。</p>
<p>当 <code>DynamicKubeletConfig</code> （已弃用，默认为关闭）被启用时，
如果动态更新了此字段，请考虑缩短此时长会导致 kubelet 更为频繁地轮询
<code>staticPodURL</code>，而这会带来负面的性能影响。</p>
<p>默认值："20s"</p>
</td>
</tr>
<tr><td><code>staticPodURL</code><br>
<code>string</code>
</td>
<td>
<p><code>staticPodURL</code> 是访问要运行的静态 Pod 的 URL 地址。
<p>当 <code>DynamicKubeletConfig</code> （已弃用，默认为关闭）被启用时，
如果动态更新了此字段，新的 URL 上包含的静态 Pod 集合可能与 kubelet
初始启动时看到的不同，而这种差异可能会扰乱节点状态。</p>
<p>默认值：""</p>
</td>
</tr>
<tr><td><code>staticPodURLHeader</code><br>
<code>map[string][]string</code>
</td>
<td>
<p><code>staticPodURLHeader</code>是一个由字符串组成的映射表，其中包含的 HTTP
头部信息用于访问<code>podURL</code>。</p>
<p>当 <code>DynamicKubeletConfig</code> （已弃用，默认为关闭）被启用时，
如果动态更新了此字段，要考虑可能导致无法从<code>staticPodURL</code>
读取最新的静态 Pod 集合。</p>
<p>默认值：nil</p>
</td>
</tr>
<tr><td><code>address</code><br>
<code>string</code>
</td>
<td>
<p><code>address</code> 是 kubelet 提供服务所用的 IP 地址（设置为 0.0.0.0
使用所有网络接口提供服务）。</p>
<p>当 <code>DynamicKubeletConfig</code> （已弃用，默认为关闭）被启用时，
如果动态更新了此字段，请考虑可能干扰与 kubelet 服务器交互的组件。</p>
<p>默认值："0.0.0.0"</p>
</td>
</tr>
<tr><td><code>port</code><br>
<code>int32</code>
</td>
<td>
<p><code>port</code> 是 kubelet 用来提供服务所使用的端口号。
这一端口号必须介于 1 到 65535 之间，包含 1 和 65535。</p>
<p>当 <code>DynamicKubeletConfig</code> （已弃用，默认为关闭）被启用时，
如果动态更新了此字段，请考虑可能干扰与 kubelet 服务器交互的组件。</p>
<p>默认值：10250</p>
</td>
</tr>
<tr><td><code>readOnlyPort</code><br>
<code>int32</code>
</td>
<td>
<p><code>readOnlyPort</code> 是 kubelet 用来提供服务所使用的只读端口号。
此端口上的服务不支持身份认证或鉴权。这一端口号必须介于 1 到 65535 之间，
包含 1 和 65535。将此字段设置为 0 会禁用只读服务。</p>
<p>当 <code>DynamicKubeletConfig</code> （已弃用，默认为关闭）被启用时，
如果动态更新了此字段，请考虑可能干扰与 kubelet 服务器交互的组件。</p>
<p>默认值：0（禁用）</p>
</td>
</tr>
<tr><td><code>tlsCertFile</code><br>
<code>string</code>
</td>
<td>
<p><code>tlsCertFile</code>是包含 HTTPS 所需要的 x509 证书的文件
（如果有 CA 证书，会串接到服务器证书之后）。如果<code>tlsCertFile</code>
和<code>tlsPrivateKeyFile</code>都没有设置，则系统会为节点的公开地址生成自签名的证书和私钥，
并将其保存到 kubelet <code>--cert-dir</code>参数所指定的目录下。</p>
<p>当 <code>DynamicKubeletConfig</code> （已弃用，默认为关闭）被启用时，
如果动态更新了此字段，请考虑可能干扰与 kubelet 服务器交互的组件。</p>
<p>默认值：""</p>
</td>
</tr>
<tr><td><code>tlsPrivateKeyFile</code><br>
<code>string</code>
</td>
<td>
<p><code>tlsPrivateKeyFile</code>是一个包含与<code>tlsCertFile</code>
证书匹配的 X509 私钥的文件。</p>
<p>当 <code>DynamicKubeletConfig</code> （已弃用，默认为关闭）被启用时，
如果动态更新了此字段，请考虑可能干扰与 kubelet 服务器交互的组件。</p>
<p>默认值：""</p>
</td>
</tr>
<tr><td><code>tlsCipherSuites</code><br>
<code>[]string</code>
</td>
<td>
<p><code>tlsCipherSuites</code>是一个字符串列表，其中包含服务器所接受的加密包名称。
列表中的每个值来自于<code>tls</code>包中定义的常数（https://golang.org/pkg/crypto/tls/#pkg-constants）。</p>
<p>当 <code>DynamicKubeletConfig</code> （已弃用，默认为关闭）被启用时，
如果动态更新了此字段，请考虑可能干扰到与 kubelet 服务器交互的组件。</p>
<p>默认值：nil</p>
</td>
</tr>
<tr><td><code>tlsMinVersion</code><br>
<code>string</code>
</td>
<td>
<p><code>tlsMinVersion</code>给出所支持的最小 TLS 版本。
字段取值来自于<code>tls</code>包中的常数定义（https://golang.org/pkg/crypto/tls/#pkg-constants）。</p>
<p>当 <code>DynamicKubeletConfig</code> （已弃用，默认为关闭）被启用时，
如果动态更新了此字段，请考虑可能干扰到与 kubelet 服务器交互的组件。</p>
<p>默认值：""</p>
</td>
</tr>
<tr><td><code>rotateCertificates</code><br>
<code>bool</code>
</td>
<td>
<p><code>rotateCertificates</code>用来启用客户端证书轮换。kubelet 会调用
<code>certificates.k8s.io</code> API 来请求新的证书。需要有一个批复人批准证书签名请求。</p>
<p>当 <code>DynamicKubeletConfig</code> （已弃用，默认为关闭）被启用时，
如果动态更新了此字段，请考虑禁用此行为时可能导致 kubelet 无法在当前证书过期时向
API 服务器执行身份认证。</p>
<p>默认值：false</code>
</td>
</tr>
<tr><td><code>serverTLSBootstrap</code><br>
<code>bool</code>
</td>
<td>
<p><code>serverTLSBootstrap</code>用来启用服务器证书引导。系统不再使用自签名的服务证书，
kubelet 会调用<code>certificates.k8s.io</code> API 来请求证书。
需要有一个批复人来批准证书签名请求（CSR）。
设置此字段时，<code>RotateKubeletServerCertificate</code>特性必须被启用。</p>
<p>当 <code>DynamicKubeletConfig</code> （已弃用，默认为关闭）被启用时，
如果动态更新了此字段，请考虑禁用此特性会导致 kubelet 的服务器证书无法被续约，
长期上这会干扰到与 kubelet 服务器交互的组件，因为证书会过期。</p>
<p>默认值：false</p>
</td>
</tr>
<tr><td><code>authentication</code><br>
<a href=#kubelet-config-k8s-io-v1beta1-KubeletAuthentication><code>KubeletAuthentication</code></a>
</td>
<td>
<p><code>authorization</code>设置发送给 kubelet 服务器的请求是如何进行身份认证的。</p>
<p>当 <code>DynamicKubeletConfig</code> （已弃用，默认为关闭）被启用时，
如果动态更新了此字段，请考虑可能干扰与 kubelet 服务器交互的组件。</p>
<p>默认值：</p>
<pre><code>
  anonymous:
    enabled: false
  webhook:
    enabled: true
    cacheTTL: "2m"
  </code></pre>
</td>
</tr>
<tr><td><code>authorization</code><br>
<a href=#kubelet-config-k8s-io-v1beta1-KubeletAuthorization><code>KubeletAuthorization</code></a>
</td>
<td>
<p><code>authorization</code>设置发送给 kubelet 服务器的请求是如何进行鉴权的。</p>
<p>当 <code>DynamicKubeletConfig</code> （已弃用，默认为关闭）被启用时，
如果动态更新了此字段，请考虑可能会干扰到与 kubelet 服务器交互的组件。</p>
<p>默认值：</p>
<pre><code>
  mode: Webhook
  webhook:
    cacheAuthorizedTTL: "5m"
    cacheUnauthorizedTTL: "30s"
  </code></pre>
</td>
</tr>
<tr><td><code>registryPullQPS</code><br>
<code>int32</code>
</td>
<td>
<p><code>registryPullQPS</code>是每秒钟可以执行的镜像仓库拉取操作限值。
此值必须不能为负数。将其设置为 0 表示没有限值。</p>
<p>当 <code>DynamicKubeletConfig</code> （已弃用，默认为关闭）被启用时，
如果动态更新了此字段，请考虑这类更新可能会因为镜像拉取所产生的流量变化而导致集群可扩缩能力问题。</p>
<p>默认值：5</code>
</td>
</tr>
<tr><td><code>registryBurst</code><br>
<code>int32</code>
</td>
<td>
<p><code>registryBurst</code>是突发性镜像拉取的上限值，允许镜像拉取临时上升到所指定数量，
不过仍然不超过<code>registryPullQPS</code>所设置的约束。此值必须是非负值。
只有<code>registryPullQPS</code>参数值大于 0 时才会使用此设置。</p>
<p>当 <code>DynamicKubeletConfig</code> （已弃用，默认为关闭）被启用时，
如果动态更新了此字段，请考虑可能因为镜像拉取所造成的流量变化，导致集群可扩缩能力受影响。</p>
<p>默认值：10</p>
</td>
</tr>
<tr><td><code>eventRecordQPS</code><br>
<code>int32</code>
</td>
<td>
<p><code>eventRecordQPS</code>设置每秒钟可创建的事件个数上限。如果此值为 0，
则表示没有限制。此值不能设置为负数。</p>
<p>当 <code>DynamicKubeletConfig</code> （已弃用，默认为关闭）被启用时，
如果动态更新了此字段，请考虑可能因为生成事件所造成的流量变化，导致集群可扩缩能力受影响。</p>
<p>默认值：5</p>
</td>
</tr>
<tr><td><code>eventBurst</code><br>
<code>int32</code>
</td>
<td>
<p><code>eventBurst</code>是突发性事件创建的上限值，允许事件创建临时上升到所指定数量，
不过仍然不超过<code>eventRecordQPS</code>所设置的约束。此值必须是非负值，
且只有<code>eventRecordQPS</code>大于 0 时才会使用此设置。</p>
<p>当 <code>DynamicKubeletConfig</code> （已弃用，默认为关闭）被启用时，
如果动态更新了此字段，请考虑可能因为事件创建所造成的流量变化，导致集群可扩缩能力受影响。</p>
<p>默认值：10</p>
</td>
</tr>
<tr><td><code>enableDebuggingHandlers</code><br>
<code>bool</code>
</td>
<td>
<p><code>enableDebuggingHandlers</code>启用服务器上用来访问日志、
在本地运行容器和命令的端点，包括<code>exec</code>、<code>attach</code>、
<code>logs</code>和<code>portforward</code>等功能。</p>
<p>当 <code>DynamicKubeletConfig</code> （已弃用，默认为关闭）被启用时，
如果动态更新了此字段，请考虑禁用此能力可能干扰到与 kubelet 服务器交互的组件。</p>
<p>默认值：true</p>
</td>
</tr>
<tr><td><code>enableContentionProfiling</code><br>
<code>bool</code>
</td>
<td>
<p><code>enableContentionProfiling</code>用于启用锁竞争性能分析，
仅用于<code>enableDebuggingHandlers</code>为<code>true</code>的场合。</p>
<p>当 <code>DynamicKubeletConfig</code> （已弃用，默认为关闭）被启用时，
如果动态更新了此字段，请考虑启用此分析可能隐含着一定的性能影响。</p>
<p>默认值：false</code>
</td>
</tr>
<tr><td><code>healthzPort</code><br>
<code>int32</code>
</td>
<td>
<p><code>healthzPort</code>是本地主机上提供<code>healthz</code>端点的端口
（设置值为 0 时表示禁止）。合法值介于 1 和 65535 之间。</p>
<p>当 <code>DynamicKubeletConfig</code> （已弃用，默认为关闭）被启用时，
如果动态更新了此字段，请考虑可能干扰到监控 kubelet 健康状况的组件。</p>
<p>默认值：10248</p>
</td>
</tr>
<tr><td><code>healthzBindAddress</code><br>
<code>string</code>
</td>
<td>
<p><code>healthzBindAddress<code>是<code>healthz</code>服务器用来提供服务的 IP 地址。</p>
<p>当 <code>DynamicKubeletConfig</code> （已弃用，默认为关闭）被启用时，
如果动态更新了此字段，请考虑可能影响到监测 kubelet 健康状况的组件。</p>
<p>默认值："127.0.0.1"</p>
</td>
</tr>
<tr><td><code>oomScoreAdj</code><br>
<code>int32</code>
</td>
<td>
<p><code>oomScoreAdj</code> 是为 kubelet 进程设置的<code>oom-score-adj</code>值。
所设置的取值要在 [-1000, 1000] 范围之内。</p>
<p>当 <code>DynamicKubeletConfig</code> （已弃用，默认为关闭）被启用时，
如果动态更新了此字段，请考虑可能影响到内存压力较大时节点的稳定性。</p>
<p>默认值：-999</p>
</td>
</tr>
<tr><td><code>clusterDomain</code><br>
<code>string</code>
</td>
<td>
<p><code>clusterDomain</code>是集群的 DNS 域名。如果设置了此字段，kubelet
会配置所有容器，使之在搜索主机的搜索域的同时也搜索这里指定的 DNS 域。</p>
<p><code>DynamicKubeletConfig</code> （已弃用，默认为关闭）：
不建议动态更新此字段，因为这一设置值要与整个集群中的其他组件保持一致。</p>
<p>默认值：""</p>
</td>
</tr>
<tr><td><code>clusterDNS</code><br>
<code>[]string</code>
</td>
<td>
<p><code>clusterDNS</code>是集群 DNS 服务器的 IP 地址的列表。
如果设置了，kubelet 将会配置所有容器使用这里的 IP 地址而不是宿主系统上的 DNS
服务器来完成 DNS 解析。
<p>当 <code>DynamicKubeletConfig</code> （已弃用，默认为关闭）被启用时，
如果动态更新了此字段，请考虑变更仅会对更新后创建的 Pod 起作用。建议在更改此字段之前腾空节点。</p>
<p>默认值：nil</p>
</td>
</tr>
<tr><td><code>streamingConnectionIdleTimeout</code><br>
<a href=https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Duration><code>meta/v1.Duration</code></a>
</td>
<td>
<p><code>streamingConnectionIdleTimeout</code>设置流式连接在被自动关闭之前可以空闲的最长时间。</p>
<p>当 <code>DynamicKubeletConfig</code> （已弃用，默认为关闭）被启用时，
如果动态更新了此字段，请考虑可能影响到依赖于通过与 kubelet
服务器间流式连接来接受非频繁更新事件的组件。</p>
<p>默认值："4h"</p>
</td>
</tr>
<tr><td><code>nodeStatusUpdateFrequency</code><br>
<a href=https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Duration><code>meta/v1.Duration</code></a>
</td>
<td>
<p><code>nodeStatusUpdateFrequency</code>是 kubelet 计算节点状态的频率。
如果未启用节点租约特性，这一字段设置的也是 kubelet 向控制面投递节点状态的频率。</p>
<p>注意：如果节点租约特性未被启用，更改此参数设置时要非常小心，
所设置的参数值必须与节点控制器的<code>nodeMonitorGracePeriod</code>协同。</p>
<p>当 <code>DynamicKubeletConfig</code> （已弃用，默认为关闭）被启用时，
如果动态更新了此字段，请考虑变更可能影响节点的可扩缩性。还要注意节点控制器的
<code>nodeMonitorGracePeriod</code>必须设置为<code>N&#8727;nodeStatusUpdateFrequency</code>，
其中<code>N</code>是节点控制器标记节点不健康之前执行重试的次数。</p>
<p>默认值："10s"</p>
</td>
</tr>
<tr><td><code>nodeStatusReportFrequency</code><br>
<a href=https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Duration><code>meta/v1.Duration</code></a>
</td>
<td>
<p><code>nodeStatusReportFrequency</code>是节点状态未发生变化时，kubelet
向控制面更新节点状态的频率。如果节点状态发生变化，则 kubelet 会忽略这一频率设置，
立即更新节点状态。</p>
<p>此字段仅当启用了节点租约特性时才被使用。<code>nodeStatusReportFrequency</code>
的默认值是"5m"。不过，如果<code>nodeStatusUpdateFrequency</code>
被显式设置了，则<code>nodeStatusReportFrequency</code>的默认值会等于
<code>nodeStatusUpdateFrequency</code>值，这是为了实现向后兼容。</p>
<p>默认值："5m"</p>
</td>
</tr>
<tr><td><code>nodeLeaseDurationSeconds</code><br>
<code>int32</code>
</td>
<td>
<p><code>nodeLeaseDurationSeconds</code>是 kubelet 会在其对应的 Lease 对象上设置的时长值。
<code>NodeLease</code>让 kubelet 来在<code>kube-node-lease</code>名字空间中创建
按节点名称命名的租约并定期执行续约操作，并通过这种机制来了解节点健康状况。</p>
<p>如果租约过期，则节点可被视作不健康。根据 KEP-0009 约定，目前的租约每 10 秒钟续约一次。
在将来，租约的续约时间间隔可能会根据租约的时长来设置。</p>
<p>此字段的取值必须大于零。</p>
<p>当 <code>DynamicKubeletConfig</code> （已弃用，默认为关闭）被启用时，
如果动态更新了此字段，请考虑缩短租约期限可能降低节点对那些暂时导致 kubelet
无法续约的问题的容忍度（例如，时延很短的网络问题）。</p>
<p>默认值：40</p>
</td>
</tr>
<tr><td><code>imageMinimumGCAge</code><br>
<a href=https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Duration><code>meta/v1.Duration</code></a>
</td>
<td>
<p><code>imageMinimumGCAge</code>是对未使用镜像进行垃圾搜集之前允许其存在的时长。</p>
<p>当 <code>DynamicKubeletConfig</code> （已弃用，默认为关闭）被启用时，
如果动态更新了此字段，请考虑这种变更可能触发垃圾收集或者延迟垃圾收集，
并且可能影响节点上镜像的额外开销。</p>
<p>默认值："2m"</p>
</td>
</tr>
<tr><td><code>imageGCHighThresholdPercent</code><br>
<code>int32</code>
</td>
<td>
<p><code>imageGCHighThresholdPercent</code>所给的是镜像的磁盘用量百分数，
一旦镜像用量超过此阈值，则镜像垃圾收集会一直运行。百分比是用这里的值除以 100
得到的，所以此字段取值必须介于 0 和 100 之间，包括 0 和 100。如果设置了此字段，
则取值必须大于<code>imageGCLowThresholdPercent</code>取值。</p>
<p>当 <code>DynamicKubeletConfig</code> （已弃用，默认为关闭）被启用时，
如果动态更新了此字段，请考虑这种变更可能触发垃圾收集或者延迟垃圾收集，
并且可能影响节点上镜像的额外开销。</p>
<p>默认值：85</p>
</td>
</tr>
<tr><td><code>imageGCLowThresholdPercent</code><br>
<code>int32</code>
</td>
<td>
<p><code>imageGCLowThresholdPercent</code>所给的是镜像的磁盘用量百分数，
镜像用量低于此阈值时不会执行镜像垃圾收集操作。垃圾收集操作也将此作为最低磁盘用量边界。
百分比是用这里的值除以 100 得到的，所以此字段取值必须介于 0 和 100 之间，包括 0 和 100。
如果设置了此字段，则取值必须小于<code>imageGCHighThresholdPercent</code>取值。</p>
<p>当 <code>DynamicKubeletConfig</code> （已弃用，默认为关闭）被启用时，
如果动态更新了此字段，请考虑这种变更可能触发垃圾收集或者延迟垃圾收集，
并且可能影响节点上镜像的额外开销。</p>
<p>默认值：80</p>
</td>
</tr>
<tr><td><code>volumeStatsAggPeriod</code><br>
<a href=https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Duration><code>meta/v1.Duration</code></a>
</td>
<td>
<p><code>volumeStatsAggPeriod</code>是计算和缓存所有 Pod 磁盘用量的频率。</p>
<p>当 <code>DynamicKubeletConfig</code> （已弃用，默认为关闭）被启用时，
如果动态更新了此字段，请考虑缩短此周期长度可能产生性能影响。</p>
<p>默认值："1m"</p>
</td>
</tr>
<tr><td><code>kubeletCgroups</code><br>
<code>string</code>
</td>
<td>
<p><code>kubeletCgroups</code>是用来隔离 kubelet 的控制组（CGroup）的绝对名称。</p>
<p><code>DynamicKubeletConfig</code> （已弃用）：
更新此字段时需要对整个节点执行重启。最安全的做法是确保此值与本地配置相同。</p>
<p>默认值：""</p>
</td>
</tr>
<tr><td><code>systemCgroups</code><br>
<code>string</code>
</td>
<td>
<p><code>systemCgroups</code>是用来放置那些未被容器化的、非内核的进程的控制组
(CGroup）的绝对名称。设置为空字符串表示没有这类容器。回滚此字段设置需要重启节点。
当此字段非空时，必须设置<code>cgroupRoot</code>字段。</p>
<p><code>DynamicKubeletConfig</code> （已弃用）：
更新此字段时需要对整个节点执行重启。最安全的做法是确保此值与本地配置相同。</p>
<p>默认值：""</p>
</td>
</tr>
<tr><td><code>cgroupRoot</code><br>
<code>string</code>
</td>
<td>
<p><code>cgroupRoot</code>是用来运行 Pod 的控制组 (CGroup）。
容器运行时会尽可能处理此字段的设置值。</p>
<p><code>DynamicKubeletConfig</code> （已弃用）：
更新此字段时需要对整个节点执行重启。最安全的做法是确保此值与本地配置相同。</p>
<p>默认值：""</p>
</td>
</tr>
<tr><td><code>cgroupsPerQOS</code><br>
<code>bool</code>
</td>
<td>
<p><code>cgroupsPerQOS</code>用来启用基于 QoS 的控制组（CGroup）层次结构：
顶层的控制组用于不同 QoS 类，所有<code>Burstable</code>和<code>BestEffort</code> Pod
都会被放置到对应的顶级 QoS 控制组下。</p>
<p><code>DynamicKubeletConfig</code> （已弃用）：
更新此字段时需要对整个节点执行重启。最安全的做法是确保此值与本地配置相同。</p>
<p>默认值：true</p>
</td>
</tr>
<tr><td><code>cgroupDriver</code><br>
<code>string</code>
</td>
<td>
<p><code>cgroupDriver</code>是 kubelet 用来操控宿主系统上控制组 (CGroup）
的驱动程序（cgroupfs 或 systemd）。</p>
<p><code>DynamicKubeletConfig</code> （已弃用）：
更新此字段时需要对整个节点执行重启。最安全的做法是确保此值与本地配置相同。</p>
<p>默认值："cgroupfs"</p>
</td>
</tr>
<tr><td><code>cpuManagerPolicy</code><br>
<code>string</code>
</td>
<td>
<p><code>cpuManagerPolicy</code>是要使用的策略名称。需要启用<code>CPUManager</code>
特性门控。</p>
<p><code>DynamicKubeletConfig</code> （已弃用）：
更新此字段时需要对整个节点执行重启。最安全的做法是确保此值与本地配置相同。</p>
<p>默认值："None"</p>
</td>
</tr>
<tr><td><code>cpuManagerPolicyOptions</code><br>
<code>map[string]string</code>
</td>
<td>
<p><code>cpuManagerPolicyOptions</code>是一组<code>key=value</code>键值映射，
容许通过额外的选项来精细调整 CPU 管理器策略的行为。需要<code>CPUManager</code>和
<code>CPUManagerPolicyOptions</code>两个特性门控都被启用。</p>
<p><code>DynamicKubeletConfig</code> （已弃用）：
更新此字段时需要对整个节点执行重启。最安全的做法是确保此值与本地配置相同。</p>
<p>默认值：nil</p>
</td>
</tr>
<tr><td><code>cpuManagerReconcilePeriod</code><br>
<a href=https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Duration><code>meta/v1.Duration</code></a>
</td>
<td>
<p><code>cpuManagerReconcilePeriod</code>是 CPU 管理器的协调周期时长。
需要启用<code>CPUManager</code>特性门控。</p>
<p><code>DynamicKubeletConfig</code> （已弃用）：
<p>当 <code>DynamicKubeletConfig</code> （已弃用，默认为关闭）被启用时，
如果动态更新了此字段，请考虑缩短周期时长可能带来的性能影响。</p>
<p>默认值："10s"</p>
</td>
</tr>
<tr><td><code>memoryManagerPolicy</code><br>
<code>string</code>
</td>
<td>
<p><code>memoryManagerPolicy</code>是内存管理器要使用的策略的名称。
要求启用<code>MemoryManager</code>特性门控。</p>
<p><code>DynamicKubeletConfig</code> （已弃用）：
更新此字段时需要对整个节点执行重启。最安全的做法是确保此值与本地配置相同。</p>
<p>默认值："none"</p>
</td>
</tr>
<tr><td><code>topologyManagerPolicy</code><br>
<code>string</code>
</td>
<td>
<p><code>topologyManagerPolicy</code>是要使用的拓扑管理器策略名称。合法值包括：</p>
<ul>
<li><code>restricted</code>：kubelet 仅接受在所请求资源上实现最佳 NUMA 对齐的 Pod。</li>
<li><code>best-effort</code>：kubelet 会优选在 CPU 和设备资源上实现 NUMA 对齐的 Pod。</li>
<li><code>none</code>：kubelet 不了解 Pod CPU 和设备资源 NUMA 对齐需求。</li>
<li><code>single-numa-node</code>：kubelet 仅允许在 CPU 和设备资源上对齐到同一 NUMA 节点的 Pod。</li>
</ul>
<p>如果策略不是 "none"，则要求启用<code>TopologyManager</code>特性门控。</p>
<p><code>DynamicKubeletConfig</code> （已弃用）：
更新此字段时需要对整个节点执行重启。最安全的做法是确保此值与本地配置相同。</p>
<p>默认值："none"</p>
</td>
</tr>
<tr><td><code>topologyManagerScope</code><br>
<code>string</code>
</td>
<td>
<p><code>topologyManagerScope</code>代表的是拓扑提示生成的范围，
拓扑提示信息由提示提供者生成，提供给拓扑管理器。合法值包括：</p>
<ul>
<li><code>container</code>：拓扑策略是按每个容器来实施的。</li>
<li><code>pod</code>：拓扑策略是按每个 Pod 来实施的。</li>
</ul>
<p>"pod" 范围要求启用<code>TopologyManager</code>特性门控。</p>
<p>默认值："container"</p>
</td>
</tr>
<tr><td><code>qosReserved</code><br>
<code>map[string]string</code>
</td>
<td>
<p><code>qosReserved</code>是一组从资源名称到百分比值的映射，用来为<code>Guaranteed</code>
QoS 类型的负载预留供其独占使用的资源百分比。目前支持的资源为："memory"。
需要启用<code>QOSReserved</code>特性门控。</p>
<p><code>DynamicKubeletConfig</code> （已弃用）：
更新此字段时需要对整个节点执行重启。最安全的做法是确保此值与本地配置相同。</p>
<p>默认值：nil</p>
</td>
</tr>
<tr><td><code>runtimeRequestTimeout</code><br>
<a href=https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Duration><code>meta/v1.Duration</code></a>
</td>
<td>
<p><code>runtimeRequestTimeout</code>用来设置除长期运行的请求（<code>pull</code>、
<code>logs</code>、<code>exec</code>和<code>attach</code>）之外所有运行时请求的超时时长。</p>
<p>当 <code>DynamicKubeletConfig</code> （已弃用，默认为关闭）被启用时，
如果动态更新了此字段，请考虑可能干扰与 kubelet 服务器交互的组件。</p>
<p>默认值："2m"</p>
</td>
</tr>
<tr><td><code>hairpinMode</code><br>
<code>string</code>
</td>
<td>
<p><code>hairpinMode</code>设置 kubelet 如何为发夹模式数据包配置容器网桥。
设置此字段可以让 Service 中的端点在尝试访问自身 Service 时将服务请求路由的自身。
可选值有：</p>
<ul>
<li>"promiscuous-bridge"：将容器网桥设置为混杂模式。</li>
<li>"hairpin-veth"：在容器的 veth 接口上设置发夹模式标记。</li>
<li>"none"：什么也不做。</li>
</ul>
<p>一般而言，用户必须设置<code>--hairpin-mode=hairpin-veth</code>才能实现发夹模式的网络地址转译
（NAT），因为混杂模式的网桥要求存在一个名为<code>cbr0</code>的容器网桥。</p>
<p>当 <code>DynamicKubeletConfig</code> （已弃用，默认为关闭）被启用时，
如果动态更新了此字段，请考虑取决于网络插件，可能需要重启节点。</p>
<p>默认值："promiscuous-bridge"</p>
</td>
</tr>
<tr><td><code>maxPods</code><br>
<code>int32</code>
</td>
<td>
<p><code>maxPods</code>是此 kubelet 上课运行的 Pod 个数上限。此值必须为非负整数。</p>
<p>当 <code>DynamicKubeletConfig</code> （已弃用，默认为关闭）被启用时，
如果动态更新了此字段，请考虑变更可能导致 kubelet 重启时 Pod 无法被准入，
而且可能改变<code>Node.status.capacity[v1.ResourcePods]</code>中报告的数值，
从而影响将来的调度决策。增大此个数值也可能会降低性能，因为会有更多的 Pod
塞到同一节点运行。</p>
<p>默认值：110</p>
</td>
</tr>
<tr><td><code>podCIDR</code><br>
<code>string</code>
</td>
<td>
<p><code>podCIDR</code>是用来设置 Pod IP 地址的 CIDR 值，仅用于独立部署模式。
运行于集群模式时，这一数值会从控制面获得。</p>
<p><code>DynamicKubeletConfig</code> （已弃用）：
此字段应该总是设置为默认的空字符串值。并且仅用来设置独立运行的 kubelet，
因为这种 kubelet 模式下无法利用动态 kubelet 配置能力。</p>
<p>默认值：""</p>
</td>
</tr>
<tr><td><code>podPidsLimit</code><br>
<code>int64</code>
</td>
<td>
<p><code>podPidsLimit</code>是每个 Pod 中可使用的 PID 个数上限。</p>
<p>当 <code>DynamicKubeletConfig</code> （已弃用，默认为关闭）被启用时，
如果动态更新了此字段，请考虑减小此值可能会导致变更后无法创建容器进程。</p>
<p>默认值：-1</p>
</td>
</tr>
<tr><td><code>resolvConf</code><br>
<code>string</code>
</td>
<td>
<p><code>resolvConf</code>是一个域名解析配置文件，用作容器 DNS 解析配置的基础。</p>
<p>当 <code>DynamicKubeletConfig</code> （已弃用，默认为关闭）被启用时，
如果动态更新了此字段，请考虑变更仅会对更新完成后所创建的 Pod 起作用。
建议在变更此字段之前先腾空节点。如果此值设置为空字符串，则会覆盖 DNS 解析的默认配置，
本质上相当于禁用了 DNS 查询。</p>
<p>默认值："/etc/resolv.conf"</p>
</td>
</tr>
<tr><td><code>runOnce</code><br>
<code>bool</code>
</td>
<td>
<p><code>runOnce</code>字段被设置时，kubelet 会咨询 API 服务器一次并获得 Pod 列表，
运行在静态 Pod 文件中指定的 Pod 及这里所获得的的 Pod，然后退出。</p>
<p>默认值：false</p>
</td>
</tr>
<tr><td><code>cpuCFSQuota</code><br>
<code>bool</code>
</td>
<td>
<p><code>cpuCFSQuota</code>允许为设置了 CPU 限制的容器实施 CPU CFS 配额约束。</p>
<p>当 <code>DynamicKubeletConfig</code> （已弃用，默认为关闭）被启用时，
如果动态更新了此字段，请考虑禁止此功能可能会降低节点稳定性。</p>
<p>默认值：true</p>
</td>
</tr>
<tr><td><code>cpuCFSQuotaPeriod</code><br>
<a href=https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Duration><code>meta/v1.Duration</code></a>
</td>
<td>
<p><code>cpuCFSQuotaPeriod</code>设置 CPU CFS 配额周期值，<code>cpu.cfs_period_us</code>。
此值需要介于 1 微秒和 1 秒之间，包含 1 微秒和 1 秒。
此功能要求启用<code>CustomCPUCFSQuotaPeriod</code>特性门控被启用。</p>
<p>当 <code>DynamicKubeletConfig</code> （已弃用，默认为关闭）被启用时，
如果动态更新了此字段，请考虑为容器所设置的限制值可能导致<code>cpu.cfs_period_us</code>
设置发生变化。这一变化会在节点被重新配置时触发容器重启。</p>
<p>默认值："100ms"</p>
</td>
</tr>
<tr><td><code>nodeStatusMaxImages</code><br>
<code>int32</code>
</td>
<td>
<p><code>nodeStatusMaxImages</code>限制<code>Node.status.images</code>中报告的镜像数量。
此值必须大于 -2。</p>
<p>注意：如果设置为 -1，则不会对镜像数量做限制；如果设置为 0，则不会返回任何镜像。</p>
<p>当 <code>DynamicKubeletConfig</code> （已弃用，默认为关闭）被启用时，
如果动态更新了此字段，请考虑节点状态中可能报告不同的数值。</p>
<p>默认值：50</p>
</td>
</tr>
<tr><td><code>maxOpenFiles</code><br>
<code>int64</code>
</td>
<td>
<p><code>maxOpenFiles</code>是 kubelet 进程可以打开的文件个数。此值必须不能为负数。</p>
<p>当 <code>DynamicKubeletConfig</code> （已弃用，默认为关闭）被启用时，
如果动态更新了此字段，请考虑可能影响到 kubelet 与节点文件系统间交互的能力。</p>
<p>默认值：1000000</p>
</td>
</tr>
<tr><td><code>contentType</code><br>
<code>string</code>
</td>
<td>
<p><code>contentType</code>是向 API 服务器发送请求时使用的内容类型。</p>
<p>当 <code>DynamicKubeletConfig</code> （已弃用，默认为关闭）被启用时，
如果动态更新了此字段，请考虑这样做可能影响 kubelet 与 API 服务器通信的能力。
如果 kubelet 因为此字段的变更而失去与 API 服务器间的连接，
则之前所作的变更无法通过动态 kubelet 配置来实现回退。</p>
<p>默认值："application/vnd.kubernetes.protobuf"</p>
</td>
</tr>
<tr><td><code>kubeAPIQPS</code><br>
<code>int32</code>
</td>
<td>
<p><code>kubeAPIQPS</code>设置与 Kubernetes API 服务器通信时要使用的 QPS（每秒查询数）。</p>
<p>当 <code>DynamicKubeletConfig</code> （已弃用，默认为关闭）被启用时，
如果动态更新了此字段，请考虑这可能因为 kubelet 与 API 服务器之间流量的变化而影响集群扩缩能力。</p>
<p>默认值：5</p>
</td>
</tr>
<tr><td><code>kubeAPIBurst</code><br>
<code>int32</code>
</td>
<td>
<p><code>kubeAPIBurst</code>设置与 Kubernetes API 服务器通信时突发的流量级别。
此字段取值不可以是负数。</p>
<p>当 <code>DynamicKubeletConfig</code> （已弃用，默认为关闭）被启用时，
如果动态更新了此字段，请考虑这可能因为 kubelet 与 API 服务器之间流量的变化而影响集群扩缩能力。</p>
<p>默认值：10</p>
</td>
</tr>
<tr><td><code>serializeImagePulls</code><br>
<code>bool</code>
</td>
<td>
<p><code>serializeImagePulls</code>被启用时会通知 kubelet 每次仅拉取一个镜像。
我们建议<em>不要</em>在所运行的 docker 守护进程版本低于 1.9、使用 aufs
存储后端的节点上更改默认值。详细信息可参见 Issue #10959。</p>
<p>当 <code>DynamicKubeletConfig</code> （已弃用，默认为关闭）被启用时，
如果动态更新了此字段，请考虑这可能会影响镜像拉取的性能。</p>
<p>默认值：true</p>
</td>
</tr>
<tr><td><code>evictionHard</code><br>
<code>map[string]string</code>
</td>
<td>
<p><code>evictionHard</code>是一个映射，是从信号名称到定义硬性驱逐阈值的映射。
例如：<code>{"memory.available": "300Mi"}</code>。
如果希望显式地禁用，可以在任意资源上将其阈值设置为 0% 或 100%。</p>
<p>当 <code>DynamicKubeletConfig</code> （已弃用，默认为关闭）被启用时，
如果动态更新了此字段，请考虑这可能会触发或延迟 Pod 驱逐操作。</p>
<p>默认值：</p>
<code><pre>
  memory.available:  "100Mi"
  nodefs.available:  "10%"
  nodefs.inodesFree: "5%"
  imagefs.available: "15%"
  </pre></code>
</td>
</tr>
<tr><td><code>evictionSoft</code><br>
<code>map[string]string</code>
</td>
<td>
<p><code>evictionSoft</code>是一个映射，是从信号名称到定义软性驱逐阈值的映射。
例如：<code>{"memory.available": "300Mi"}</code>。</p>
<p>当 <code>DynamicKubeletConfig</code> （已弃用，默认为关闭）被启用时，
如果动态更新了此字段，请考虑这可能会触发或延迟 Pod 驱逐操作，
并且可能造成节点所报告的可分配资源数量发生变化。</p>
<p>默认值：nil</p>
</td>
</tr>
<tr><td><code>evictionSoftGracePeriod</code><br>
<code>map[string]string</code>
</td>
<td>
<p><code>evictionSoftGracePeriod</code>是一个映射，是从信号名称到每个软性驱逐信号的宽限期限。
例如：<code>{"memory.available": "30s"}</code>。</p>
<p>当 <code>DynamicKubeletConfig</code> （已弃用，默认为关闭）被启用时，
如果动态更新了此字段，请考虑这可能会触发或延迟 Pod 驱逐操作。</p>
<p>默认值：nil</p>
</td>
</tr>
<tr><td><code>evictionPressureTransitionPeriod</code><br>
<a href=https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Duration><code>meta/v1.Duration</code></a>
</td>
<td>
<p><code>evictionPressureTransitionPeriod</code>设置 kubelet
离开驱逐压力状况之前必须要等待的时长。</p>
<p>当 <code>DynamicKubeletConfig</code> （已弃用，默认为关闭）被启用时，
如果动态更新了此字段，请考虑减少此字段值可能会在节点过量分配时降低节点稳定性。</p>
<p>默认值："5m"</p>
</td>
</tr>
<tr><td><code>evictionMaxPodGracePeriod</code><br>
<code>int32</code>
</td>
<td>
<p><code>evictionMaxPodGracePeriod</code>是指达到软性逐出阈值而引起 Pod 终止时，
可以赋予的宽限期限最大值（按秒计）。这个值本质上限制了软性逐出事件发生时，
Pod 可以获得的<code>terminationGracePeriodSeconds</code>。</p>
<p>注意：由于 Issue #64530 的原因，系统中存在一个缺陷，即此处所设置的值会在软性逐出时覆盖
Pod 的宽限期设置，从而有可能增加 Pod 上原本设置的宽限期限时长。
这个缺陷会在未来版本中修复。</p>
<p>当 <code>DynamicKubeletConfig</code> （已弃用，默认为关闭）被启用时，
如果动态更新了此字段，请考虑缩短此宽限期限值会导致软性逐出期间 Pod
在被杀死之前用来体面地完成清理工作可用的时间。</p>
<p>默认值：0</p>
</td>
</tr>
<tr><td><code>evictionMinimumReclaim</code><br>
<code>map[string]string</code>
</td>
<td>
<p><code>evictionMinimumReclaim</code>是一个映射，定义信号名称与最小回收量数值之间的关系。
最小回收量指的是资源压力较大而执行 Pod 驱逐操作时，kubelet 对给定资源的最小回收量。
例如：<code>{"imagefs.available": "2Gi"}</code>。</p>
<p>当 <code>DynamicKubeletConfig</code> （已弃用，默认为关闭）被启用时，
如果动态更新了此字段，请考虑这可能会改变驱逐操作应对资源压力的效果。</p>
<p>默认值：nil</p>
</td>
</tr>
<tr><td><code>podsPerCore</code><br>
<code>int32</code>
</td>
<td>
<p><code>podsPerCore</code>设置的是每个核上 Pod 个数上限。此值不能超过<code>maxPods</code>。
所设值必须是非负整数。如果设置为 0，则意味着对 Pod 个数没有限制。</p>
<p>当 <code>DynamicKubeletConfig</code> （已弃用，默认为关闭）被启用时，
如果动态更新了此字段，请考虑变更可能导致 kubelet 重启时 Pod 无法被准入，
还可能导致<code>Node.status.capacity.pods</code>所报告的数值发生变化，
进而影响到将来的调度决策。增大此值也会降低性能，因为在同一个处理器核上需要运行更多的 Pod。</p>
<p>默认值：0</p>
</td>
</tr>
<tr><td><code>enableControllerAttachDetach</code><br>
<code>bool</code>
</td>
<td>
<p><code>enableControllerAttachDetach</code>用来允许 Attach/Detach
控制器管理调度到本节点的卷的挂接（attachment）和解除挂接（detachement），
并且禁止 kubelet 执行任何 attach/detach 操作。</p>
<p>当 <code>DynamicKubeletConfig</code> （已弃用，默认为关闭）被启用时，
如果动态更新了此字段，请考虑在运行中的节点上更改由哪个组件来负责卷管理时，
这一变更可能导致节点在被更新前尚未腾空时卷无法被解除挂接。
如果 kubelet 尚未更新<code>volumes.kubernetes.io/controller-managed-attach-detach</code>
注解时 Pod 已经被调度到了该节点，节点上的卷也会无法解除挂接。
一般而言，最安全的做法是将此字段设置为与本地配置相同的值。</p>
<p>默认值：true</p>
</td>
</tr>
<tr><td><code>protectKernelDefaults</code><br>
<code>bool</code>
</td>
<td>
<p><code>protectKernelDefaults</code>设置为<code>true</code>时，会令 kubelet
在发现内核参数与预期不符时出错退出。若此字段设置为<code>false</code>，则 kubelet
会尝试更改内核参数以满足其预期。</p>
<p>当 <code>DynamicKubeletConfig</code> （已弃用，默认为关闭）被启用时，
如果动态更新了此字段，请考虑启用此设置会在内核参数与 kubelet 预期不匹配时导致
kubelet 进入崩溃循环（Crash-Loop）状态。</p>
<p>默认值：false</p>
</td>
</tr>
<tr><td><code>makeIPTablesUtilChains</code><br>
<code>bool</code>
</td>
<td>
<p><code>makeIPTablesUtilChains</code>设置为<code>true</code>时，相当于允许 kubelet
确保一组 iptables 规则存在于宿主机上。这些规则会为不同的组件（例如 kube-proxy）
提供工具性质的规则。它们是基于<code>iptablesMasqueradeBit</code>和<code>iptablesDropBit</code>
来创建的。</p>
<p>当 <code>DynamicKubeletConfig</code> （已弃用，默认为关闭）被启用时，
如果动态更新了此字段，请考虑禁用此行为会导致 kubelet 无法在本地 iptables
规则出错时实现自愈。</p>
<p>默认值：true</p>
</td>
</tr>
<tr><td><code>iptablesMasqueradeBit</code><br>
<code>int32</code>
</td>
<td>
<p><code>iptablesMasqueradeBit</code>是 iptables fwmark 空间中用来为 SNAT
作标记的位。此值必须介于<code>[0, 31]</code>区间，必须与其他标记位不同。</p>
<p>警告：请确保此值设置与 kube-proxy 中对应的参数设置取值相同。</p>
<p>当 <code>DynamicKubeletConfig</code> （已弃用，默认为关闭）被启用时，
如果动态更新了此字段，请考虑此处的变更要与其他组件（如 kube-proxy）相应的变更协调一致。
只有当<code>makeIPTablesUtilChains</code>能力被启用时，这里的更新才会起作用。</p>
<p>默认值：14</p>
</td>
</tr>
<tr><td><code>iptablesDropBit</code><br>
<code>int32</code>
</td>
<td>
<p><code>iptablesDropBit</code>是 iptables fwmark 空间中用来标记丢弃包的数据位。
此值必须介于<code>[0, 31]</code>区间，必须与其他标记位不同。</p>
<p>当 <code>DynamicKubeletConfig</code> （已弃用，默认为关闭）被启用时，
如果动态更新了此字段，请考虑此处的变更要与其他组件（如 kube-proxy）相应的变更协调一致。
只有当<code>makeIPTablesUtilChains</code>能力被启用时，这里的更新才会起作用。</p>
<p>默认值：15</p>
</td>
</tr>
<tr><td><code>featureGates</code><br>
<code>map[string]bool</code>
</td>
<td>
<p><code>featureGates</code>是一个从功能特性名称到布尔值的映射，用来启用或禁用实验性的功能。
此字段可逐条更改文件 "k8s.io/kubernetes/pkg/features/kube_features.go"
中所给的内置默认值。</p>
<p>当 <code>DynamicKubeletConfig</code> （已弃用，默认为关闭）被启用时，
如果动态更新了此字段，请考虑你所启用或禁止的功能特性的文档。
尽管我们鼓励功能特性的开发人员使动态启用或禁用功能特性成为可能，
某些变更可能要求重新启动节点，某些特性可能要求在从启用到禁用切换时作出精细的协调。</p>
<p>默认值：nil</p>
</td>
</tr>
<tr><td><code>failSwapOn</code><br>
<code>bool</code>
</td>
<td>
<p><code>failSwapOn</code>通知 kubelet 在节点上启用交换分区时拒绝启动。</p>
<p>当 <code>DynamicKubeletConfig</code> （已弃用，默认为关闭）被启用时，
如果动态更新了此字段，请考虑缩短此周期长度可能产生性能影响。</p>
<p>默认值：true</p>
</td>
</tr>
<tr><td><code>memorySwap</code><br>
<a href=#kubelet-config-k8s-io-v1beta1-MemorySwapConfiguration><code>MemorySwapConfiguration</code></a>
</td>
<td>
<p><code>memorySwap</code>配置容器负载可用的交换内存。</p>
</td>
</tr>
<tr><td><code>containerLogMaxSize</code><br>
<code>string</code>
</td>
<td>
<p><code>containerLogMaxSize</code>是定义容器日志文件被轮转之前可以到达的最大尺寸。
例如："5Mi" 或 "256Ki"。</p>
<p>当 <code>DynamicKubeletConfig</code> （已弃用，默认为关闭）被启用时，
如果动态更新了此字段，请考虑可能会触发日志轮转。</p>
<p>默认值："10Mi"</p>
</td>
</tr>
<tr><td><code>containerLogMaxFiles</code><br>
<code>int32</code>
</td>
<td>
<p><code>containerLogMaxFiles</code>设置每个容器可以存在的日志文件个数上限。</p>
<p>当 <code>DynamicKubeletConfig</code> （已弃用，默认为关闭）被启用时，
如果动态更新了此字段，请考虑降低此值可能导致日志文件被删除。</p>
<p>默认值："5"</p>
</td>
</tr>
<tr><td><code>configMapAndSecretChangeDetectionStrategy</code><br>
<a href=#kubelet-config-k8s-io-v1beta1-ResourceChangeDetectionStrategy><code>ResourceChangeDetectionStrategy</code></a>
</td>
<td>
<p><code>configMapAndSecretChangeDetectionStrategy</code>是 ConfigMap 和 Secret
管理器的运行模式。合法值包括：</p>
<ul>
<li><code>Get</code>：kubelet 从 API 服务器直接取回必要的对象；</li>
<li><code>Cache</code>：kubelet 使用 TTL 缓存来管理来自 API 服务器的对象；</li>
<li><code>Watch</code>：kubelet 使用 watch 操作来观察所关心的对象的变更。</li>
</ul>
<p>默认值："Watch"</p>
</td>
</tr>
<tr><td><code>systemReserved</code><br>
<code>map[string]string</code>
</td>
<td>
<p><code>systemReserved</code>是一组<code>资源名称=资源数量</code>对，
用来描述为非 Kubernetes 组件预留的资源（例如：'cpu=200m,memory=150G'）。</p>
<p>目前仅支持 CPU 和内存。更多细节可参见 http://kubernetes.io/zh/docs/user-guide/compute-resources。</p>
<p>当 <code>DynamicKubeletConfig</code> （已弃用，默认为关闭）被启用时，
如果动态更新了此字段，请考虑增加预留资源也许是不可能的，因为需要改变控制组大小。
在更改了此字段之后，应该总是关注<code>NodeAllocatableEnforced</code>事件，
以确保更新是成功的。</p>
<p>默认值：Nil</p>
</td>
</tr>
<tr><td><code>kubeReserved</code><br>
<code>map[string]string</code>
</td>
<td>
<p><code>kubeReserved</code>是一组<code>资源名称=资源数量</code>对，
用来描述为 Kubernetes 系统组件预留的资源（例如：'cpu=200m,memory=150G'）。
目前支持 CPU、内存和根文件系统的本地存储。
更多细节可参见 https://kubernetes.io/zh/docs/concepts/configuration/manage-resources-containers/。</p>
<p>当 <code>DynamicKubeletConfig</code> （已弃用，默认为关闭）被启用时，
如果动态更新了此字段，请考虑增加预留资源也许是不可能的，因为需要改变控制组大小。
在更改了此字段之后，应该总是关注<code>NodeAllocatableEnforced</code>事件，
以确保更新是成功的。</p>
<p>默认值：Nil</p>
</td>
</tr>
<tr><td><code>reservedSystemCPUs</code> <b>[必需]</b><br>
<code>string</code>
</td>
<td>
<p><code>reservedSystemCPUs</code>选项设置为宿主级系统线程和 Kubernetes
相关线程所预留的 CPU 列表。此字段提供的是一种“静态”的 CPU 列表，而不是像
<code>systemReserved</code>和<code>kubeReserved</code>所提供的“动态”列表。
此选项不支持<code>systemReservedCgroup</code>或<code>kubeReservedCgroup</code>。</p>
</td>
</tr>
<tr><td><code>showHiddenMetricsForVersion</code><br>
<code>string</code>
</td>
<td>
<p><code>showHiddenMetricsForVersion<code>是你希望显示隐藏度量值的上一版本。
只有上一个次版本是有意义的，其他值都是不允许的。
字段值的格式为<code>&lt;major>.&lt;minor></code>，例如：<code>1.16</code>。
此格式的目的是为了确保在下一个版本中有新的度量值被隐藏时，你有机会注意到这类变化，
而不是当这些度量值在其后的版本中彻底去除时来不及应对。</p>
<p>默认值：""</p>
</td>
</tr>
<tr><td><code>systemReservedCgroup</code><br>
<code>string</code>
</td>
<td>
<p><code>systemReservedCgroup</code>帮助 kubelet 识别用来为 OS 系统级守护进程实施
<code>systemReserved</code>计算资源预留时使用的顶级控制组（CGroup）。
参考[Node Allocatable](https://git.k8s.io/community/contributors/design-proposals/node/node-allocatable.md)
以了解详细信息。</p>
<p><code>DynamicKubeletConfig</code>（已弃用）：
此字段更新时需要整个节点重启。最安全的做法是保持此值与本地配置相同。</p>
<p>默认值：""</p>
</td>
</tr>
<tr><td><code>kubeReservedCgroup</code><br>
<code>string</code>
</td>
<td>
<p><code>kubeReservedCgroup</code> 帮助 kubelet 识别用来为 Kubernetes 节点系统级守护进程实施
<code>kubeReserved</code>计算资源预留时使用的顶级控制组（CGroup）。
参阅<a href=https://git.k8s.io/community/contributors/design-proposals/node/node-allocatable.md>Node Allocatable</a>
了解进一步的信息。</p>
<p><code>DynamicKubeletConfig</code>（已弃用）：
此字段更新时需要整个节点重启。最安全的做法是保持此值与本地配置相同。</p>
<p>默认值：""</p>
</td>
</tr>
<tr><td><code>enforceNodeAllocatable</code><br>
<code>[]string</code>
</td>
<td>
<p>此标志设置 kubelet 需要执行的各类节点可分配资源策略。此字段接受一组选项列表。
可接受的选项有<code>none</code>、<code>pods</code>、<code>system-reserved</code>和
<code>kube-reserved</code>。</p>
<p>如果设置了<code>none</code>，则字段值中不可以包含其他选项。</p>
<p>如果列表中包含<code>system-reserved</code>，则必须设置<code>systemReservedCgroup</code>。</p>
<p>如果列表中包含<code>kube-reserved</code>，则必须设置<code>kubeReservedCgroup</code>。</p>
<p>这个字段只有在<code>cgroupsPerQOS</code>被设置为<code>true</code>才被支持。</p>
<p>参阅<a href=https://git.k8s.io/community/contributors/design-proposals/node/node-allocatable.md>Node Allocatable</a>
了解进一步的信息。</p>
<p>当 <code>DynamicKubeletConfig</code> （已弃用，默认为关闭）被启用时，
如果动态更新了此字段，请考虑去掉此机制可能会降低节点稳定性。
反之，添加此机制可能会降低原来使用资源超出预留量的组件的稳定性。
例如，实施 kube-reserved 在 kubelet 使用资源超出预留量时可能导致 kubelet 发生 OOM，
而实施 system-reserved 机制可能导致使用资源超出预留量的系统守护进程发生 OOM。</p>
<p>默认值：["pods"]</p>
</td>
</tr>
<tr><td><code>allowedUnsafeSysctls</code><br>
<code>[]string</code>
</td>
<td>
<p>用逗号分隔的白名单列表，其中包含不安全的 sysctl 或 sysctl 模式（以<code>&#8727;</code>结尾）。
</p>
<p>不安全的 sysctl 组有 <code>kernel.shm&#8727;</code>、<code>kernel.msg&#8727;</code>、
<code>kernel.sem</code>、<code>fs.mqueue.&#8727;</code> 和<code>net.&#8727;</code>。</p>
<p>例如："<code>kernel.msg&#8727;,net.ipv4.route.min\_pmtu</code>"</p>
<p>默认值：[]</p>
</td>
</tr>
<tr><td><code>volumePluginDir</code><br>
<code>string</code>
</td>
<td>
<p><code>volumePluginDir</code>是用来搜索其他第三方卷插件的目录的路径。</p>
<p>当 <code>DynamicKubeletConfig</code> （已弃用，默认为关闭）被启用时，
如果动态更新了此字段，请考虑更改<code>volumePluginDir</code>可能干扰使用第三方卷插件的负载。</p>
<p>默认值："/usr/libexec/kubernetes/kubelet-plugins/volume/exec/"</p>
</td>
</tr>
<tr><td><code>providerID</code><br>
<code>string</code>
</td>
<td>
<p><code>providerID</code>字段被设置时，指定的是一个外部提供者（即云驱动）实例的唯一 ID，
该提供者可用来唯一性地标识特定节点。</p>
<p>当 <code>DynamicKubeletConfig</code> （已弃用，默认为关闭）被启用时，
如果动态更新了此字段，请考虑可能影响到 kubelet 与云驱动之间进行交互的能力。</p>
<p>默认值：""</p>
</td>
</tr>
<tr><td><code>kernelMemcgNotification</code><br>
<code>bool</code>
</td>
<td>
<p><code>kernelMemcgNotification</code>字段如果被设置了，会告知 kubelet 集成内核的
memcg 通知机制来确定是否超出内存逐出阈值，而不是使用轮询机制来判定。</p>
<p>当 <code>DynamicKubeletConfig</code> （已弃用，默认为关闭）被启用时，
如果动态更新了此字段，请考虑这样做可能影响到 kubelet 与内核的交互方式。</p>
<p>默认值：false</p>
</td>
</tr>
<tr><td><code>logging</code> <b>[必需]</b><br>
<a href=#LoggingConfiguration><code>LoggingConfiguration</code></a>
</td>
<td>
<p><code>logging</code>设置日志机制选项。更多的详细信息科参阅
<a href=https://github.com/kubernetes/component-base/blob/master/logs/options.go>日志选项</a>。</p>
<p>默认值：</p>
<code><pre>Format: text</pre></code>
</td>
</tr>
<tr><td><code>enableSystemLogHandler</code><br>
<code>bool</code>
</td>
<td>
<p><code>enableSystemLogHandler</code>用来启用通过 Web 接口 host:port/logs/
访问系统日志的能力。</p>
<p>默认值：true</p>
</td>
</tr>
<tr><td><code>shutdownGracePeriod</code><br>
<a href=https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Duration><code>meta/v1.Duration</code></a>
</td>
<td>
<p><code>shutdownGracePeriod</code>设置节点关闭期间，节点自身需要延迟以及为
Pod 提供的宽限期限的总时长。</p>
<p>默认值："0s"</p>
</td>
</tr>
<tr><td><code>shutdownGracePeriodCriticalPods</code><br>
<a href=https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Duration><code>meta/v1.Duration</code></a>
</td>
<td>
<p><code>shutdownGracePeriodCriticalPods</code>设置节点关闭期间用来终止关键性
Pod 的时长。此时长要短于<code>shutdownGracePeriod</code>。
例如，如果<code>shutdownGracePeriod=30s</code>，<code>shutdownGracePeriodCriticalPods=10s<code>，
在节点关闭期间，前 20 秒钟被预留用来体面终止普通 Pod，后 10 秒钟用来终止关键 Pod。</p>
<p>默认值："0s"</p>
</td>
</tr>
<tr><td><code>shutdownGracePeriodByPodPriority</code><br>
<a href=#kubelet-config-k8s-io-v1beta1-ShutdownGracePeriodByPodPriority><code>[]ShutdownGracePeriodByPodPriority</code></a>
</td>
<td>
<p><code>shutdownGracePeriodByPodPriority</code>设置基于 Pod
相关的优先级类值而确定的体面关闭时间。当 kubelet 收到关闭请求的时候，kubelet
会针对节点上运行的所有 Pod 发起关闭操作，这些关闭操作会根据 Pod 的优先级确定其宽限期限，
之后 kubelet 等待所有 Pod 退出。</p>
<p>数组中的每个表项代表的是节点关闭时 Pod 的体面终止时间；这里的 Pod
的优先级类介于列表中当前优先级类值和下一个表项的优先级类值之间。</p>
<p>例如，要赋予关键 Pod 10 秒钟时间来关闭，赋予优先级>=10000 Pod 20 秒钟时间来关闭，
赋予其余的 Pod 30 秒钟来关闭。</p>
<p>shutdownGracePeriodByPodPriority:</p>
<ul>
<li>priority: 2000000000
shutdownGracePeriodSeconds: 10</li>
<li>priority: 10000
shutdownGracePeriodSeconds: 20</li>
<li>priority: 0
shutdownGracePeriodSeconds: 30</li>
</ul>
<p>在退出之前，kubelet 要等待的时间上限为节点上所有优先级类的
<code>shutdownGracePeriodSeconds</code>的最大值。
当所有 Pod 都退出或者到达其宽限期限时，kubelet 会释放关闭防护锁。
此功能要求<code>GracefulNodeShutdown</code>特性门控被启用。</p>
<p>当<code>shutdownGracePeriod</code>或<code>shutdownGracePeriodCriticalPods</code>
被设置时，此配置字段必须为空。</p>
<p>默认值：nil</p>
</td>
</tr>
<tr><td><code>reservedMemory</code><br>
<a href=#kubelet-config-k8s-io-v1beta1-MemoryReservation><code>[]MemoryReservation</code></a>
</td>
<td>
<p><code>reservedMemory</code>给出一个逗号分隔的列表，为 NUMA 节点预留内存。</p>
<p>此参数仅在内存管理器功能特性语境下有意义。内存管理器不会为容器负载分配预留内存。
例如，如果你的 NUMA0 节点内存为 10Gi，<code>reservedMemory</code>设置为在 NUMA0
上预留 1Gi 内存，内存管理器会认为其上只有 9Gi 内存可供分配。</p>
<p>你可以设置不同数量的 NUMA 节点和内存类型。你也可以完全忽略这个字段，不过你要清楚，
所有 NUMA 节点上预留内存的总量要等于通过
<a href=https://kubernetes.io/docs/tasks/administer-cluster/reserve-compute-resources/#node-allocatable>node allocatable</a>
设置的内存量。</p>
<p>如果至少有一个节点可分配参数设置值非零，则你需要设置至少一个 NUMA 节点。</p>
<p>此外，避免如下设置：</p>
<ol>
<li>在配置值中存在重复项，NUMA 节点和内存类型相同，但配置值不同，这是不允许的。</li>
<li>为任何内存类型设置限制值为零。</li>
<li>NUMA 节点 ID 在宿主系统上不存在。/li>
<li>除<code>memory</code>和<code>hugepages-&lt;size></code>之外的内存类型。</li>
</ol>
<p>默认值：nil</p>
</td>
</tr>
<tr><td><code>enableProfilingHandler</code><br>
<code>bool</code>
</td>
<td>
<p><code>enableProfilingHandler</code>启用通过 host:port/debug/pprof/ 接口来执行性能分析。</p>
<p>默认值：true</p>
</td>
</tr>
<tr><td><code>enableDebugFlagsHandler</code><br>
<code>bool</code>
</td>
<td>
<p><code>enableDebugFlagsHandler</code>启用通过 host:port/debug/flags/v Web
接口上的标志设置。</p>
<p>默认值：true</p>
</td>
</tr>
<tr><td><code>seccompDefault</code><br>
<code>bool</code>
</td>
<td>
<p><code>seccompDefault</code>字段允许针对所有负载将<code>RuntimeDefault</code>
设置为默认的 seccomp 配置。这一设置要求对应的<code>SeccompDefault</code>特性门控被启用。</p>
<p>默认值：false</p>
</td>
</tr>
<tr><td><code>memoryThrottlingFactor</code><br>
<code>float64</code>
</td>
<td>
<p>当设置 cgroupv2 <code>memory.high</code>以实施<code>MemoryQoS</code>特性时，
<code>memoryThrottlingFactor</code>用来作为内存限制或节点可分配内存的系数。</p>
<p>减小此系数会为容器控制组设置较低的 high 限制值，从而增大回收压力；反之，
增大此系数会降低回收压力。更多细节参见 http://kep.k8s.io/2570。</p>
<p>默认值：0.8</p>
</td>
</tr>
<tr><td><code>registerWithTaints</code><br>
<a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/#taint-v1-core><code>[]core/v1.Taint</code></a>
</td>
<td>
<p><code>registerWithTaints</code>是一个由污点组成的数组，包含 kubelet
注册自身时要向节点对象添加的污点。只有<code>registerNode</code>为<code>true</code>
时才会起作用，并且仅在节点的最初注册时起作用。</p>
<p>默认值：nil</p>
</td>
</tr>
<tr><td><code>registerNode</code><br>
<code>bool</code>
</td>
<td>
<p><code>registerNode</code>启用向 API 服务器的自动注册。</p>
<p>默认值：true</p>
</td>
</tr>
</tbody>
</table>
<h2 id=kubelet-config-k8s-io-v1beta1-SerializedNodeConfigSource><code>SerializedNodeConfigSource</code> </h2>
<p>SerializedNodeConfigSource 允许对 <code>v1.NodeConfigSource</code> 执行序列化操作。
这一类型供 kubelet 内部使用，以便跟踪动态配置的检查点。
此资源存在于 kubeletconfig API 组是因为它被当做是对 kubelet 的一种版本化输入。</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>apiVersion</code><br>string</td><td><code>kubelet.config.k8s.io/v1beta1</code></td></tr>
<tr><td><code>kind</code><br>string</td><td><code>SerializedNodeConfigSource</code></td></tr>
<tr><td><code>source</code><br>
<a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/#nodeconfigsource-v1-core><code>core/v1.NodeConfigSource</code></a>
</td>
<td>
<p><code>source</code>是我们执行序列化的数据源。</p>
</td>
</tr>
</tbody>
</table>
<h2 id=kubelet-config-k8s-io-v1beta1-KubeletAnonymousAuthentication><code>KubeletAnonymousAuthentication</code> </h2>
<p><strong>出现在：</strong></p>
<ul>
<li><a href=#kubelet-config-k8s-io-v1beta1-KubeletAuthentication>KubeletAuthentication</a></li>
</ul>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>enabled</code><br>
<code>bool</code>
</td>
<td>
<p><code>enabled</code>允许匿名用户向 kubelet 服务器发送请求。
未被其他身份认证方法拒绝的请求都会被当做匿名请求。
匿名请求对应的用户名为<code>system:anonymous</code>，对应的用户组名为
<code>system:unauthenticated</code>。</p>
</td>
</tr>
</tbody>
</table>
<h2 id=kubelet-config-k8s-io-v1beta1-KubeletAuthentication><code>KubeletAuthentication</code> </h2>
<p><strong>出现在：</strong></p>
<ul>
<li><a href=#kubelet-config-k8s-io-v1beta1-KubeletConfiguration>KubeletConfiguration</a></li>
</ul>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>x509</code><br>
<a href=#kubelet-config-k8s-io-v1beta1-KubeletX509Authentication><code>KubeletX509Authentication</code></a>
</td>
<td>
<p><code>x509</code>包含与 x509 客户端证书认证相关的配置。</p>
</td>
</tr>
<tr><td><code>webhook</code><br>
<a href=#kubelet-config-k8s-io-v1beta1-KubeletWebhookAuthentication><code>KubeletWebhookAuthentication</code></a>
</td>
<td>
<p><code>webhook</code>包含与 Webhook 持有者令牌认证相关的配置。</p>
</td>
</tr>
<tr><td><code>anonymous</code><br>
<a href=#kubelet-config-k8s-io-v1beta1-KubeletAnonymousAuthentication><code>KubeletAnonymousAuthentication</code></a>
</td>
<td>
<p><code>anonymous</code>包含与匿名身份认证相关的配置信息。</p>
</td>
</tr>
</tbody>
</table>
<h2 id=kubelet-config-k8s-io-v1beta1-KubeletAuthorization><code>KubeletAuthorization</code> </h2>
<p><strong>出现在：</strong></p>
<ul>
<li><a href=#kubelet-config-k8s-io-v1beta1-KubeletConfiguration>KubeletConfiguration</a></li>
</ul>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>mode</code><br>
<a href=#kubelet-config-k8s-io-v1beta1-KubeletAuthorizationMode><code>KubeletAuthorizationMode</code></a>
</td>
<td>
<p><code>mode>是应用到 kubelet 服务器所接收到的请求上的鉴权模式。合法值包括
<code>AlwaysAllow</code>和<code>Webhook</code>。
Webhook 模式使用 <code>SubjectAccessReview</code> API 来确定鉴权。</p>
</td>
</tr>
<tr><td><code>webhook</code><br>
<a href=#kubelet-config-k8s-io-v1beta1-KubeletWebhookAuthorization><code>KubeletWebhookAuthorization</code></a>
</td>
<td>
<p><code>webhook</code>包含与 Webhook 鉴权相关的配置信息。</p>
</td>
</tr>
</tbody>
</table>
<h2 id=kubelet-config-k8s-io-v1beta1-KubeletAuthorizationMode><code>KubeletAuthorizationMode</code> </h2>
<p>（<code>string</code> 类型的别名）</p>
<p><strong>出现在：</strong></p>
<ul>
<li><a href=#kubelet-config-k8s-io-v1beta1-KubeletAuthorization>KubeletAuthorization</a></li>
</ul>
<h2 id=kubelet-config-k8s-io-v1beta1-KubeletWebhookAuthentication><code>KubeletWebhookAuthentication</code> </h2>
<p><strong>出现在：</strong></p>
<ul>
<li><a href=#kubelet-config-k8s-io-v1beta1-KubeletAuthentication>KubeletAuthentication</a></li>
</ul>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>enabled</code><br>
<code>bool</code>
</td>
<td>
<p><code>enabled</code>允许使用<code>tokenreviews.authentication.k8s.io</code>
API 来提供持有者令牌身份认证。</p>
</td>
</tr>
<tr><td><code>cacheTTL</code><br>
<a href=https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Duration><code>meta/v1.Duration</code></a>
</td>
<td>
<p><code>cacheTTL</code>启用对身份认证结果的缓存。</p>
</td>
</tr>
</tbody>
</table>
<h2 id=kubelet-config-k8s-io-v1beta1-KubeletWebhookAuthorization><code>KubeletWebhookAuthorization</code> </h2>
<p><strong>出现在：</strong></p>
<ul>
<li><a href=#kubelet-config-k8s-io-v1beta1-KubeletAuthorization>KubeletAuthorization</a></li>
</ul>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>cacheAuthorizedTTL</code><br>
<a href=https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Duration><code>meta/v1.Duration</code></a>
</td>
<td>
<p><code>cacheAuthorizedTTL</code>设置来自 Webhook 鉴权组件的 'authorized'
响应的缓存时长。</p>
</td>
</tr>
<tr><td><code>cacheUnauthorizedTTL</code><br>
<a href=https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Duration><code>meta/v1.Duration</code></a>
</td>
<td>
<p><code>cacheUnauthorizedTTL</code>设置来自 Webhook 鉴权组件的 'unauthorized'
响应的缓存时长。</p>
</td>
</tr>
</tbody>
</table>
<h2 id=kubelet-config-k8s-io-v1beta1-KubeletX509Authentication><code>KubeletX509Authentication</code> </h2>
<p><strong>出现在：</strong></p>
<ul>
<li><a href=#kubelet-config-k8s-io-v1beta1-KubeletAuthentication>KubeletAuthentication</a></li>
</ul>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>clientCAFile</code><br>
<code>string</code>
</td>
<td>
<p><code>clientCAFile</code>是一个指向 PEM 编发的证书包的路径。
如果设置了此字段，则能够提供由此证书包中机构之一所签名的客户端证书的请求会被成功认证，
并且其用户名对应于客户端证书的<code>CommonName</code>、组名对应于客户端证书的
<code>Organization</code>。</p>
</td>
</tr>
</tbody>
</table>
<h2 id=kubelet-config-k8s-io-v1beta1-MemoryReservation><code>MemoryReservation</code> </h2>
<p><strong>出现在：</strong></p>
<ul>
<li><a href=#kubelet-config-k8s-io-v1beta1-KubeletConfiguration>KubeletConfiguration</a></li>
</ul>
<p>MemoryReservation 为每个 NUMA 节点设置不同类型的内存预留。</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>numaNode</code> <b>[必需]</b><br>
<code>int32</code>
</td>
<td>
<p>NUMA 节点</p>
</td>
</tr>
<tr><td><code>limits</code> <b>[必需]</b><br>
<a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/#resourcelist-v1-core><code>core/v1.ResourceList</code></a>
</td>
<td>
<p>资源列表</p>
</td>
</tr>
</tbody>
</table>
<h2 id=kubelet-config-k8s-io-v1beta1-MemorySwapConfiguration><code>MemorySwapConfiguration</code> </h2>
<p><strong>出现在：</strong></p>
<ul>
<li><a href=#kubelet-config-k8s-io-v1beta1-KubeletConfiguration>KubeletConfiguration</a></li>
</ul>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>swapBehavior</code><br>
<code>string</code>
</td>
<td>
<p><code>swapBehavior</code>配置容器负载可以使用的交换内存。可以是
<ul>
<li>""、"LimitedSwap"：工作负载的内存和交换分区总用量不能超过 Pod 的内存限制；</li>
<li>"UnlimitedSwap"：工作负载可以无限制地使用交换分区，上限是可分配的约束。</li>
</ul>
</td>
</tr>
</tbody>
</table>
<h2 id=kubelet-config-k8s-io-v1beta1-ResourceChangeDetectionStrategy><code>ResourceChangeDetectionStrategy</code> </h2>
<p>（<code>string</code> 类型的别名）</p>
<p><strong>出现在：</strong></p>
<ul>
<li><a href=#kubelet-config-k8s-io-v1beta1-KubeletConfiguration>KubeletConfiguration</a></li>
</ul>
<p>ResourceChangeDetectionStrategy 给出的是内部管理器（ConfigMap、Secret）
用来发现对象变化的模式。</p>
<h2 id=kubelet-config-k8s-io-v1beta1-ShutdownGracePeriodByPodPriority><code>ShutdownGracePeriodByPodPriority</code> </h2>
<p><strong>出现在：</strong></p>
<ul>
<li><a href=#kubelet-config-k8s-io-v1beta1-KubeletConfiguration>KubeletConfiguration</a></li>
</ul>
<p>ShutdownGracePeriodByPodPriority 基于 Pod 关联的优先级类数值来为其设置关闭宽限时间。</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>priority</code> <b>[必需]</b><br>
<code>int32</code>
</td>
<td>
<p><code>priority</code>是与关闭宽限期限相关联的优先级值。</p>
</td>
</tr>
<tr><td><code>shutdownGracePeriodSeconds</code> <b>[必需]</b><br>
<code>int64</code>
</td>
<td>
<p><code>shutdownGracePeriodSeconds</code>是按秒数给出的关闭宽限期限。
</td>
</tr>
</tbody>
</table>
<h2 id=FormatOptions><code>FormatOptions</code> </h2>
<p><strong>出现在：</strong></p>
<ul>
<li><a href=#LoggingConfiguration>LoggingConfiguration</a></li>
</ul>
<p>
FormatOptions 包含为不同日志格式提供的选项。
</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>json</code> <b>[必需]</b><br>
<a href=#JSONOptions><code>JSONOptions</code></a>
</td>
<td>
<p>
[试验功能] <code>json</code> 包含为 "json" 日志格式提供的选项。
</p>
</td>
</tr>
</tbody>
</table>
<h2 id=JSONOptions><code>JSONOptions</code> </h2>
<p><strong>出现在：</strong></p>
<ul>
<li><a href=#FormatOptions>FormatOptions</a></li>
</ul>
<p>
JSONOptions 包含为 "json" 日志格式提供的选项。
</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>splitStream</code> <b>[必需]</b><br>
<code>bool</code>
</td>
<td>
<p>
[试验功能] <code>splitStream</code> 将错误信息重定向到标准错误输出（stderr），
而将提示信息重定向到标准输出（stdout），并为二者提供缓存。
默认设置是将二者都写出到标准输出，并且不提供缓存。
</p>
</td>
</tr>
<tr><td><code>infoBufferSize</code> <b>[必需]</b><br>
<a href=https://pkg.go.dev/k8s.io/apimachinery/pkg/api/resource#QuantityValue><code>k8s.io/apimachinery/pkg/api/resource.QuantityValue</code></a>
</td>
<td>
<p>
[试验功能] <code>infoBufferSize</coe> 在分离数据流时用来设置提示数据流的大小。
默认值为 0，相当于禁止缓存。
</p>
</td>
</tr>
</tbody>
</table>
<h2 id=LoggingConfiguration><code>LoggingConfiguration</code> </h2>
<p><strong>出现在：</strong></p>
<ul>
<li><a href=#kubelet-config-k8s-io-v1beta1-KubeletConfiguration>KubeletConfiguration</a></li>
</ul>
<p>LoggingConfiguration 包含日志选项。
参考 <a href=https://github.com/kubernetes/component-base/blob/master/logs/options.go>Logs Options</a>
以了解更多信息。</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>format</code> <b>[必需]</b><br>
<code>string</code>
</td>
<td>
<p>
<code>format<code> 设置日志消息的结构。默认的格式取值为 <code>text</code>。
</p>
</td>
</tr>
<tr><td><code>flushFrequency</code> <b>[必需]</b><br>
<a href=https://godoc.org/time#Duration><code>time.Duration</code></a>
</td>
<td>
<p>
对日志进行清洗的最大间隔秒数。如果所选的日志后端在写入日志消息时不提供缓存，
则此配置会被忽略。
</p>
</td>
</tr>
<tr><td><code>verbosity</code> <b>[必需]</b><br>
<code>uint32</code>
</td>
<td>
<p>
<code>verbosity</code> 用来确定日志消息记录的详细程度阈值。默认值为 0，
意味着仅记录最重要的消息。数值越大，额外的消息越多。出错消息总是会被记录下来。
</p>
</td>
</tr>
<tr><td><code>vmodule</code> <b>[必需]</b><br>
<a href=#VModuleConfiguration><code>VModuleConfiguration</code></a>
</td>
<td>
<p>
<code>vmodule</code> 会在单个文件层面重载 verbosity 阈值的设置。
这一选项仅支持 "text" 日志格式。
</p>
</td>
</tr>
<tr><td><code>sanitization</code> <b>[必需]</b><br>
<code>bool</code>
</td>
<td>
<p>
[试验功能] 当启用此选项时，被标记为敏感的字段（密码、秘钥、令牌）不会被日志记录。
运行时日志过滤功能可能会引入非常大的计算开销，因此在生产环境中不应启用。
</p>
</td>
</tr>
<tr><td><code>options</code> <b>[必需]</b><br>
<a href=#FormatOptions><code>FormatOptions</code></a>
</td>
<td>
<p>
[试验功能] <code>options</code> 中包含特定于不同日志格式的配置参数。
只有针对所选格式的选项会被使用，但是合法性检查时会查看所有选项配置。
</p>
</td>
</tr>
</tbody>
</table>
<h2 id=VModuleConfiguration><code>VModuleConfiguration</code> </h2>
<p>（<code>[]k8s.io/component-base/config/v1alpha1.VModuleItem</code> 类型的别名）</p>
<p><strong>出现在：</strong></p>
<ul>
<li><a href=#LoggingConfiguration>LoggingConfiguration</a></li>
</ul>
<p>VModuleConfiguration 是一个集合，其中包含一个个文件名（或文件名模式）
及其对应的详细程度阈值。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-74f43b2a33c21414f1ed8c359b37d326>12.12 - WebhookAdmission 配置 (v1)</h1>
<p>此 API 的版本是 v1。</p>
<h2 id=resource-types>资源类型 </h2>
<ul>
<li><a href=#apiserver-config-k8s-io-v1-WebhookAdmission>WebhookAdmission</a></li>
</ul>
<h2 id=apiserver-config-k8s-io-v1-WebhookAdmission><code>WebhookAdmission</code> </h2>
<p>WebhookAdmission 为 Webhook 准入控制器提供配置信息。</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>apiVersion</code><br>string</td><td><code>apiserver.config.k8s.io/v1</code></td></tr>
<tr><td><code>kind</code><br>string</td><td><code>WebhookAdmission</code></td></tr>
<tr><td><code>kubeConfigFile</code> <b>[必需]</b><br>
<code>string</code>
</td>
<td>
<p>字段 kubeConfigFile 包含指向 kubeconfig 文件的路径。</p>
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-eee842643d4d2c372827920430a15614>12.13 - 客户端身份认证（Client Authentication） (v1)</h1>
<h2 id=resource-types>资源类型 </h2>
<ul>
<li><a href=#client-authentication-k8s-io-v1-ExecCredential>ExecCredential</a></li>
</ul>
<h2 id=client-authentication-k8s-io-v1-ExecCredential><code>ExecCredential</code> </h2>
<p>ExecCredential 由基于 exec 的插件使用，与 HTTP 传输组件沟通凭据信息。</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>apiVersion</code><br>string</td><td><code>client.authentication.k8s.io/v1</code></td></tr>
<tr><td><code>kind</code><br>string</td><td><code>ExecCredential</code></td></tr>
<tr><td><code>spec</code> <b>[必需]</b><br>
<a href=#client-authentication-k8s-io-v1-ExecCredentialSpec><code>ExecCredentialSpec</code></a>
</td>
<td>
字段 spec 包含由 HTTP 传输组件传递给插件的信息。
</td>
</tr>
<tr><td><code>status</code><br>
<a href=#client-authentication-k8s-io-v1-ExecCredentialStatus><code>ExecCredentialStatus</code></a>
</td>
<td>
字段 status 由插件填充，包含传输组件与 API 服务器连接时需要提供的凭据。
</td>
</tr>
</tbody>
</table>
<h2 id=client-authentication-k8s-io-v1-Cluster><code>Cluster</code> </h2>
<p><strong>出现在：</strong></p>
<ul>
<li><a href=#client-authentication-k8s-io-v1-ExecCredentialSpec>ExecCredentialSpec</a></li>
</ul>
<p>Cluster 中包含允许 exec 插件与 Kubernetes 集群进行通信身份认证时所需
的信息。</p>
<p>为了确保该结构体包含需要与 Kubernetes 集群进行通信的所有内容（就像通过 Kubeconfig 一样），
除了证书授权之外，该字段应该映射到 "k8s.io/client-go/tools/clientcmd/api/v1".cluster，
由于 CA 数据将始终以字节形式传递给插件。</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>server</code> <b>[必需]</b><br>
<code>string</code>
</td>
<td>
字段 server 是 Kubernetes 集群的地址（https://hostname:port）。
</td>
</tr>
<tr><td><code>tls-server-name</code><br>
<code>string</code>
</td>
<td>
tls-server-name 是用来提供给服务器用作 SNI 解析的，客户端以此检查服务器的证书。
如此字段为空，则使用链接服务器时使用的主机名。
</td>
</tr>
<tr><td><code>insecure-skip-tls-verify</code><br>
<code>bool</code>
</td>
<td>
设置此字段之后，会令客户端跳过对服务器端证书的合法性检查。
这会使得你的 HTTPS 链接不再安全。
</td>
</tr>
<tr><td><code>certificate-authority-data</code><br>
<code>[]byte</code>
</td>
<td>
此字段包含 PEM 编码的证书机构（CA）证书。
如果为空，则使用系统的根证书。
</td>
</tr>
<tr><td><code>proxy-url</code><br>
<code>string</code>
</td>
<td>
此字段用来设置向集群发送所有请求时要使用的代理服务器。
</td>
</tr>
<tr><td><code>config</code><br>
<a href=https://godoc.org/k8s.io/apimachinery/pkg/runtime/#RawExtension><code>k8s.io/apimachinery/pkg/runtime.RawExtension</code></a>
</td>
<td>
<p>在某些环境中，用户配置可能对很多集群而言都完全一样（即调用同一个 exec 插件），
只是针对不同集群会有一些细节上的差异，例如 audience。
此字段使得特定于集群的配置可以直接使用集群信息来设置。
不建议使用此字段来保存 Secret 数据，因为 exec 插件的主要优势之一是不需要在
kubeconfig 中保存 Secret 数据。</p>
</td>
</tr>
</tbody>
</table>
<h2 id=client-authentication-k8s-io-v1-ExecCredentialSpec><code>ExecCredentialSpec</code> </h2>
<p><strong>出现在：</strong></p>
<ul>
<li><a href=#client-authentication-k8s-io-v1-ExecCredential>ExecCredential</a></li>
</ul>
<p>ExecCredentialSpec 保存传输组件所提供的特定于请求和运行时的信息。</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>cluster</code><br>
<a href=#client-authentication-k8s-io-v1-Cluster><code>Cluster</code></a>
</td>
<td>
此字段中包含的信息使得 exec 插件能够与要访问的 Kubernetes 集群通信。
注意，cluster 字段只有在 exec 驱动的配置中 provideClusterInfo
（即：ExecConfig.ProvideClusterInfo）被设置为 true 时才不能为空。
</td>
</tr>
<tr><td><code>interactive</code> <b>[必需]</b><br>
<code>bool</code>
</td>
<td>
此字段用来标明标准输出信息是否已传递给 exec 插件。
</td>
</tr>
</tbody>
</table>
<h2 id=client-authentication-k8s-io-v1-ExecCredentialStatus><code>ExecCredentialStatus</code> </h2>
<p><strong>出现在：</strong></p>
<ul>
<li><a href=#client-authentication-k8s-io-v1-ExecCredential>ExecCredential</a></li>
</ul>
<p>ExecCredentialStatus 中包含传输组件要使用的凭据。</p>
<p>字段 token 和 clientKeyData 都是敏感字段。此数据只能在
客户端与 exec 插件进程之间使用内存来传递。exec 插件本身至少
应通过文件访问许可来实施保护。</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>expirationTimestamp</code><br>
<a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/#time-v1-meta><code>meta/v1.Time</code></a>
</td>
<td>
给出所提供的凭据到期的时间。
</td>
</tr>
<tr><td><code>token</code> <b>[必需]</b><br>
<code>string</code>
</td>
<td>
客户端用做请求身份认证的持有者令牌。
</td>
</tr>
<tr><td><code>clientCertificateData</code> <b>[必需]</b><br>
<code>string</code>
</td>
<td>
PEM 编码的客户端 TLS 证书（如果有临时证书，也会包含）。
</td>
</tr>
<tr><td><code>clientKeyData</code> <b>[必需]</b><br>
<code>string</code>
</td>
<td>
与上述证书对应的、PEM 编码的私钥。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-2896357fe4f62fe85522254410e0be7d>12.14 - 客户端身份认证（Client Authentication）(v1beta1)</h1>
<h2 id=resource-types>资源类型 </h2>
<ul>
<li><a href=#client-authentication-k8s-io-v1beta1-ExecCredential>ExecCredential</a></li>
</ul>
<h2 id=client-authentication-k8s-io-v1beta1-ExecCredential><code>ExecCredential</code> </h2>
<p>ExecCredential 由基于 exec 的插件使用，与 HTTP 传输组件沟通凭据信息。</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>apiVersion</code><br>string</td><td><code>client.authentication.k8s.io/v1beta1</code></td></tr>
<tr><td><code>kind</code><br>string</td><td><code>ExecCredential</code></td></tr>
<tr><td><code>spec</code> <b>[必需]</b><br>
<a href=#client-authentication-k8s-io-v1beta1-ExecCredentialSpec><code>ExecCredentialSpec</code></a>
</td>
<td>
字段 spec 包含由 HTTP 传输组件传递给插件的信息。
</td>
</tr>
<tr><td><code>status</code><br>
<a href=#client-authentication-k8s-io-v1beta1-ExecCredentialStatus><code>ExecCredentialStatus</code></a>
</td>
<td>
字段 status 由插件填充，包含传输组件与 API 服务器连接时需要提供的凭据。
</td>
</tr>
</tbody>
</table>
<h2 id=client-authentication-k8s-io-v1beta1-Cluster><code>Cluster</code> </h2>
<p><strong>出现在：</strong></p>
<ul>
<li><a href=#client-authentication-k8s-io-v1beta1-ExecCredentialSpec>ExecCredentialSpec</a></li>
</ul>
<p>Cluster 中包含允许 exec 插件与 Kubernetes 集群进行通信身份认证时所需
的信息。</p>
<p>为了确保该结构体包含需要与 Kubernetes 集群进行通信的所有内容（就像通过 Kubeconfig 一样），
该字段应该映射到 "k8s.io/client-go/tools/clientcmd/api/v1".cluster，
除了证书授权之外，由于 CA 数据将始终以字节形式传递给插件。</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>server</code> <b>[必需]</b><br>
<code>string</code>
</td>
<td>
字段 server 是 Kubernetes 集群的地址（https://hostname:port）。
</td>
</tr>
<tr><td><code>tls-server-name</code><br>
<code>string</code>
</td>
<td>
tls-server-name 是用来提供给服务器用作 SNI 解析的，客户端以此检查服务器的证书。
如此字段为空，则使用链接服务器时使用的主机名。
</td>
</tr>
<tr><td><code>insecure-skip-tls-verify</code><br>
<code>bool</code>
</td>
<td>
设置此字段之后，会令客户端跳过对服务器端证书的合法性检查。
这会使得你的 HTTPS 链接不再安全。
</td>
</tr>
<tr><td><code>certificate-authority-data</code><br>
<code>[]byte</code>
</td>
<td>
此字段包含 PEM 编码的证书机构（CA）证书。
如果为空，则使用系统的根证书。
</td>
</tr>
<tr><td><code>proxy-url</code><br>
<code>string</code>
</td>
<td>
此字段用来设置向集群发送所有请求时要使用的代理服务器。
</td>
</tr>
<tr><td><code>config</code><br>
<a href=https://godoc.org/k8s.io/apimachinery/pkg/runtime/#RawExtension><code>k8s.io/apimachinery/pkg/runtime.RawExtension</code></a>
</td>
<td>
<p>在某些环境中，用户配置可能对很多集群而言都完全一样（即调用同一个 exec 插件），
只是针对不同集群会有一些细节上的差异，例如 audience。
此字段使得特定于集群的配置可以直接使用集群信息来设置。
不建议使用此字段来保存 Secret 数据，因为 exec 插件的主要优势之一是不需要在
kubeconfig 中保存 Secret 数据。</p>
</td>
</tr>
</tbody>
</table>
<h2 id=client-authentication-k8s-io-v1beta1-ExecCredentialSpec><code>ExecCredentialSpec</code> </h2>
<p><strong>出现在：</strong></p>
<ul>
<li><a href=#client-authentication-k8s-io-v1beta1-ExecCredential>ExecCredential</a></li>
</ul>
<p>ExecCredentialSpec 保存传输组件所提供的特定于请求和运行时的信息。</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tbody>
<tr><td><code>cluster</code><br>
<a href=#client-authentication-k8s-io-v1beta1-Cluster><code>Cluster</code></a>
</td>
<td>
此字段中包含的信息使得 exec 插件能够与要访问的 Kubernetes 集群通信。
注意，cluster 字段只有在 exec 驱动的配置中 provideClusterInfo
（即：ExecConfig.ProvideClusterInfo）被设置为 true 时才不能为空。
</td>
</tr>
</tbody>
</table>
<h2 id=client-authentication-k8s-io-v1beta1-ExecCredentialStatus><code>ExecCredentialStatus</code> </h2>
<p><strong>出现在：</strong></p>
<ul>
<li><a href=#client-authentication-k8s-io-v1beta1-ExecCredential>ExecCredential</a></li>
</ul>
<p>ExecCredentialStatus 中包含传输组件要使用的凭据。</p>
<p>字段 token 和 clientKeyData 都是敏感字段。
此数据只能在客户端与 exec 插件进程之间使用内存来传递。
exec 插件本身至少应通过文件访问许可来实施保护。</p>
<table class=table>
<thead><tr><th width=30%>字段</th><th>描述</th></tr></thead>
<tr><td><code>expirationTimestamp</code><br>
<a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.20/#time-v1-meta><code>meta/v1.Time</code></a>
</td>
<td>
给出所提供的凭据到期的时间。
</td>
</tr>
<tr><td><code>token</code> <b>[必需]</b><br>
<code>string</code>
</td>
<td>
客户端用做请求身份认证的持有者令牌。
</td>
</tr>
<tr><td><code>clientCertificateData</code> <b>[必需]</b><br>
<code>string</code>
</td>
<td>
PEM 编码的客户端 TLS 证书（如果有临时证书，也会包含）。
</td>
</tr>
<tr><td><code>clientKeyData</code> <b>[必需]</b><br>
<code>string</code>
</td>
<td>
与上述证书对应的、PEM 编码的私钥。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-f8b023454daa9497b7eea35b7d35c075>13 - 调度</h1>
</div>
<div class=td-content>
<h1 id=pg-ef4fb938b6b63c95f5f26f9b1cec3054>13.1 - 调度器配置</h1>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.19 [beta]</code>
</div>
<p>你可以通过编写配置文件，并将其路径传给 <code>kube-scheduler</code> 的命令行参数，定制 <code>kube-scheduler</code> 的行为。</p>
<p>调度模板（Profile）允许你配置 <a class=glossary-tooltip title="控制平面组件，负责监视新创建的、未指定运行节点的 Pod，选择节点让 Pod 在上面运行。" data-toggle=tooltip data-placement=top href=/zh/docs/reference/command-line-tools-reference/kube-scheduler/ target=_blank aria-label=kube-scheduler>kube-scheduler</a>
中的不同调度阶段。每个阶段都暴露于某个扩展点中。插件通过实现一个或多个扩展点来提供调度行为。</p>
<p>你可以通过运行 <code>kube-scheduler --config &lt;filename></code> 来设置调度模板，
使用 KubeSchedulerConfiguration （<a href=/zh/docs/reference/config-api/kube-scheduler-config.v1beta2/>v1beta2</a>
或者 <a href=/zh/docs/reference/config-api/kube-scheduler-config.v1beta3/>v1beta3</a>） 结构体。</p>
<p>最简单的配置如下：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>kubescheduler.config.k8s.io/v1beta2<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>KubeSchedulerConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>clientConnection</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>kubeconfig</span>:<span style=color:#bbb> </span>/etc/srv/kubernetes/kube-scheduler/kubeconfig<span style=color:#bbb>
</span></code></pre></div>
<h2 id=profiles>配置文件 </h2>
<p>通过调度配置文件，你可以配置 <a class=glossary-tooltip title="控制平面组件，负责监视新创建的、未指定运行节点的 Pod，选择节点让 Pod 在上面运行。" data-toggle=tooltip data-placement=top href=/zh/docs/reference/command-line-tools-reference/kube-scheduler/ target=_blank aria-label=kube-scheduler>kube-scheduler</a> 在不同阶段的调度行为。
每个阶段都在一个<a href=#extension-points>扩展点</a>中公开。
<a href=#scheduling-plugins>调度插件</a>通过实现一个或多个扩展点，来提供调度行为。</p>
<p>你可以配置同一 <code>kube-scheduler</code> 实例使用<a href=#multiple-profiles>多个配置文件</a>。</p>
<h3 id=extensions-points>扩展点 </h3>
<p>调度行为发生在一系列阶段中，这些阶段是通过以下扩展点公开的：</p>
<ol>
<li><code>queueSort</code>：这些插件对调度队列中的悬决的 Pod 排序。
一次只能启用一个队列排序插件。</li>
</ol>
<ol start=2>
<li><code>preFilter</code>：这些插件用于在过滤之前预处理或检查 Pod 或集群的信息。
它们可以将 Pod 标记为不可调度。</li>
</ol>
<ol start=3>
<li><code>filter</code>：这些插件相当于调度策略中的断言（Predicates），用于过滤不能运行 Pod 的节点。
过滤器的调用顺序是可配置的。
如果没有一个节点通过所有过滤器的筛选，Pod 将会被标记为不可调度。</li>
</ol>
<ol start=4>
<li><code>postFilter</code>：当无法为 Pod 找到可用节点时，按照这些插件的配置顺序调用他们。
如果任何 <code>postFilter</code> 插件将 Pod 标记为“可调度”，则不会调用其余插件。</li>
</ol>
<ol start=5>
<li><code>preScore</code>：这是一个信息扩展点，可用于预打分工作。</li>
</ol>
<ol start=6>
<li><code>score</code>：这些插件给通过筛选阶段的节点打分。调度器会选择得分最高的节点。</li>
</ol>
<ol start=7>
<li><code>reserve</code>：这是一个信息扩展点，当资源已经预留给 Pod 时，会通知插件。
这些插件还实现了 <code>Unreserve</code> 接口，在 <code>Reserve</code> 期间或之后出现故障时调用。</li>
</ol>
<ol start=8>
<li><code>permit</code>：这些插件可以阻止或延迟 Pod 绑定。</li>
</ol>
<ol start=9>
<li><code>preBind</code>：这些插件在 Pod 绑定节点之前执行。</li>
</ol>
<ol start=10>
<li><code>bind</code>：这个插件将 Pod 与节点绑定。绑定插件是按顺序调用的，只要有一个插件完成了绑定，其余插件都会跳过。绑定插件至少需要一个。</li>
</ol>
<ol start=11>
<li><code>postBind</code>：这是一个信息扩展点，在 Pod 绑定了节点之后调用。</li>
</ol>
<ol start=12>
<li><code>multiPoint</code>：这是一个仅配置字段，允许同时为所有适用的扩展点启用或禁用插件。</li>
</ol>
<p>对每个扩展点，你可以禁用<a href=#scheduling-plugins>默认插件</a>或者是启用自己的插件，例如：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>kubescheduler.config.k8s.io/v1beta2<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>KubeSchedulerConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>profiles</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>plugins</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>score</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>disabled</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>PodTopologySpread<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>enabled</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>MyCustomPluginA<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>weight</span>:<span style=color:#bbb> </span><span style=color:#666>2</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>MyCustomPluginB<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>weight</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></code></pre></div>
<p>你可以在 <code>disabled</code> 数组中使用 <code>*</code> 禁用该扩展点的所有默认插件。
如果需要，这个字段也可以用来对插件重新顺序。</p>
<h3 id=scheduling-plugins>调度插件 </h3>
<p>下面默认启用的插件实现了一个或多个扩展点：</p>
<ul>
<li>
<p><code>ImageLocality</code>：选择已经存在 Pod 运行所需容器镜像的节点。</p>
<p>实现的扩展点：<code>score</code>。</p>
</li>
</ul>
<ul>
<li>
<p><code>TaintToleration</code>：实现了<a href=/zh/docs/concepts/scheduling-eviction/taint-and-toleration/>污点和容忍</a>。</p>
<p>实现的扩展点：<code>filter</code>，<code>prescore</code>，<code>score</code>。</p>
</li>
</ul>
<ul>
<li>
<p><code>NodeName</code>：检查 Pod 指定的节点名称与当前节点是否匹配。</p>
<p>实现的扩展点：<code>filter</code>。</p>
</li>
</ul>
<ul>
<li>
<p><code>NodePorts</code>：检查 Pod 请求的端口在节点上是否可用。</p>
<p>实现的扩展点：<code>preFilter</code>，<code>filter</code>。</p>
</li>
</ul>
<ul>
<li>
<p><code>NodeAffinity</code>：实现了<a href=/zh/docs/concepts/scheduling-eviction/assign-pod-node/#nodeselector>节点选择器</a>
和<a href=/zh/docs/concepts/scheduling-eviction/assign-pod-node/#node-affinity>节点亲和性</a>。</p>
<p>实现的扩展点：<code>filter</code>，<code>score</code>.</p>
</li>
</ul>
<ul>
<li>
<p><code>PodTopologySpread</code>：实现了 <a href=/zh/docs/concepts/workloads/pods/pod-topology-spread-constraints/>Pod 拓扑分布</a>。</p>
<p>实现的扩展点：<code>preFilter</code>，<code>filter</code>，<code>preScore</code>，<code>score</code>。</p>
</li>
</ul>
<ul>
<li>
<p><code>NodeUnschedulable</code>：过滤 <code>.spec.unschedulable</code> 值为 true 的节点。</p>
<p>实现的扩展点：<code>filter</code>。</p>
</li>
</ul>
<ul>
<li>
<p><code>NodeResourcesFit</code>：检查节点是否拥有 Pod 请求的所有资源。
得分可以使用以下三种策略之一：<code>LeastAllocated</code>（默认）、<code>MostAllocated</code>
和<code>RequestedToCapacityRatio</code>。</p>
<p>实现的扩展点：<code>preFilter</code>，<code>filter</code>，<code>score</code>。</p>
</li>
</ul>
<ul>
<li>
<p><code>NodeResourcesBalancedAllocation</code>：调度 Pod 时，选择资源使用更为均衡的节点。</p>
<p>实现的扩展点：<code>score</code>。</p>
</li>
</ul>
<ul>
<li><code>VolumeBinding</code>：检查节点是否有请求的卷，或是否可以绑定请求的卷。
实现的扩展点: <code>preFilter</code>、<code>filter</code>、<code>reserve</code>、<code>preBind</code> 和 <code>score</code>。
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> 当 <code>VolumeCapacityPriority</code> 特性被启用时，<code>score</code> 扩展点也被启用。
它优先考虑可以满足所需卷大小的最小 PV。
</div></li>
</ul>
<ul>
<li>
<p><code>VolumeRestrictions</code>：检查挂载到节点上的卷是否满足卷提供程序的限制。</p>
<p>实现的扩展点：<code>filter</code>。</p>
</li>
</ul>
<ul>
<li>
<p><code>VolumeZone</code>：检查请求的卷是否在任何区域都满足。</p>
<p>实现的扩展点：<code>filter</code>。</p>
</li>
</ul>
<ul>
<li>
<p><code>NodeVolumeLimits</code>：检查该节点是否满足 CSI 卷限制。</p>
<p>实现的扩展点：<code>filter</code>。</p>
</li>
</ul>
<ul>
<li>
<p><code>EBSLimits</code>：检查节点是否满足 AWS EBS 卷限制。</p>
<p>实现的扩展点：<code>filter</code>。</p>
</li>
</ul>
<ul>
<li>
<p><code>GCEPDLimits</code>：检查该节点是否满足 GCP-PD 卷限制。</p>
<p>实现的扩展点：<code>filter</code>。</p>
</li>
</ul>
<ul>
<li>
<p><code>AzureDiskLimits</code>：检查该节点是否满足 Azure 卷限制。</p>
<p>实现的扩展点：<code>filter</code>。</p>
</li>
</ul>
<ul>
<li>
<p><code>InterPodAffinity</code>：实现 <a href=/zh/docs/concepts/scheduling-eviction/assign-pod-node/#inter-pod-affinity-and-anti-affinity>Pod 间亲和性与反亲和性</a>。</p>
<p>实现的扩展点：<code>preFilter</code>，<code>filter</code>，<code>preScore</code>，<code>score</code>。</p>
</li>
</ul>
<ul>
<li>
<p><code>PrioritySort</code>：提供默认的基于优先级的排序。</p>
<p>实现的扩展点：<code>queueSort</code>。</p>
</li>
</ul>
<ul>
<li>
<p><code>DefaultBinder</code>：提供默认的绑定机制。</p>
<p>实现的扩展点：<code>bind</code>。</p>
</li>
</ul>
<ul>
<li>
<p><code>DefaultPreemption</code>：提供默认的抢占机制。</p>
<p>实现的扩展点：<code>postFilter</code>。</p>
</li>
</ul>
<p>你也可以通过组件配置 API 启用以下插件（默认不启用）:</p>
<ul>
<li>
<p><code>SelectorSpread</code>：偏向把属于
<a class=glossary-tooltip title="将运行在一组 Pods 上的应用程序公开为网络服务的抽象方法。" data-toggle=tooltip data-placement=top href=/zh/docs/concepts/services-networking/service/ target=_blank aria-label=Services>Services</a>，
<a class=glossary-tooltip title="ReplicaSet 是下一代副本控制器。" data-toggle=tooltip data-placement=top href=/zh/docs/concepts/workloads/controllers/replicaset/ target=_blank aria-label=ReplicaSets>ReplicaSets</a> 和
<a class=glossary-tooltip title="StatefulSet 用来管理某 Pod 集合的部署和扩缩，并为这些 Pod 提供持久存储和持久标识符。" data-toggle=tooltip data-placement=top href=/zh/docs/concepts/workloads/controllers/statefulset/ target=_blank aria-label=StatefulSets>StatefulSets</a> 的 Pod 跨节点分布。</p>
<p>实现的扩展点：<code>preScore</code>，<code>score</code>。</p>
</li>
</ul>
<ul>
<li><code>CinderLimits</code>：检查是否可以满足节点的 <a href=https://docs.openstack.org/cinder/>OpenStack Cinder</a>
卷限制</li>
</ul>
<h3 id=multiple-profiles>多配置文件 </h3>
<p>你可以配置 <code>kube-scheduler</code> 运行多个配置文件。
每个配置文件都有一个关联的调度器名称，并且可以在其扩展点中配置一组不同的插件。</p>
<p>使用下面的配置样例，调度器将运行两个配置文件：一个使用默认插件，另一个禁用所有打分插件。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>kubescheduler.config.k8s.io/v1beta2<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>KubeSchedulerConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>profiles</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>schedulerName</span>:<span style=color:#bbb> </span>default-scheduler<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>schedulerName</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>no</span>-scoring-scheduler<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>plugins</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>preScore</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>disabled</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;*&#39;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>score</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>disabled</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;*&#39;</span><span style=color:#bbb>
</span></code></pre></div>
<p>对于那些希望根据特定配置文件来进行调度的 Pod，可以在 <code>.spec.schedulerName</code> 字段指定相应的调度器名称。</p>
<p>默认情况下，将创建一个调度器名为 <code>default-scheduler</code> 的配置文件。
这个配置文件包括上面描述的所有默认插件。
声明多个配置文件时，每个配置文件中调度器名称必须唯一。</p>
<p>如果 Pod 未指定调度器名称，kube-apiserver 将会把调度器名设置为 <code>default-scheduler</code>。
因此，应该存在一个调度器名为 <code>default-scheduler</code> 的配置文件来调度这些 Pod。</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong>
<p>Pod 的调度事件把 <code>.spec.schedulerName</code> 字段值作为 ReportingController。
领导者选举事件使用列表中第一个配置文件的调度器名称。
</div>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong>
<p>所有配置文件必须在 queueSort 扩展点使用相同的插件，并具有相同的配置参数（如果适用）。
这是因为调度器只有一个保存 pending 状态 Pod 的队列。
</div>
<h3 id=multipoint>应用于多个扩展点的插件</h3>
<p>从 <code>kubescheduler.config.k8s.io/v1beta3</code> 开始，配置文件配置中有一个附加字段 <code>multiPoint</code>，它允许跨多个扩展点轻松启用或禁用插件。
<code>multiPoint</code> 配置的目的是简化用户和管理员在使用自定义配置文件时所需的配置。</p>
<p>考虑一个插件，<code>MyPlugin</code>，它实现了 <code>preScore</code>、<code>score</code>、<code>preFilter</code> 和 <code>filter</code> 扩展点。
要为其所有可用的扩展点启用 <code>MyPlugin</code>，配置文件配置如下所示：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>kubescheduler.config.k8s.io/v1beta3<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>KubeSchedulerConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>profiles</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>schedulerName</span>:<span style=color:#bbb> </span>multipoint-scheduler<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>plugins</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>multiPoint</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>enabled</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>MyPlugin<span style=color:#bbb>
</span></code></pre></div>
<p>这相当于为所有扩展点手动启用<code>MyPlugin</code>，如下所示：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>kubescheduler.config.k8s.io/v1beta3<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>KubeSchedulerConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>profiles</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>schedulerName</span>:<span style=color:#bbb> </span>non-multipoint-scheduler<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>plugins</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>preScore</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>enabled</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>MyPlugin<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>score</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>enabled</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>MyPlugin<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>preFilter</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>enabled</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>MyPlugin<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>filter</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>enabled</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>MyPlugin<span style=color:#bbb>
</span></code></pre></div>
<p>在这里使用 <code>multiPoint</code> 的一个好处是，如果 <code>MyPlugin</code> 将来实现另一个扩展点，<code>multiPoint</code> 配置将自动为新扩展启用它。</p>
<p>可以使用该扩展点的 <code>disabled</code> 字段将特定扩展点从 <code>MultiPoint</code> 扩展中排除。
这适用于禁用默认插件、非默认插件或使用通配符 (<code>'*'</code>) 来禁用所有插件。
禁用 <code>Score</code> 和 <code>PreScore</code> 的一个例子是：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>kubescheduler.config.k8s.io/v1beta3<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>KubeSchedulerConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>profiles</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>schedulerName</span>:<span style=color:#bbb> </span>non-multipoint-scheduler<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>plugins</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>multiPoint</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>enabled</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;MyPlugin&#39;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>preScore</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>disabled</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;*&#39;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>score</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>disabled</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;*&#39;</span><span style=color:#bbb>
</span></code></pre></div>
<p>在 <code>v1beta3</code> 中，所有 <a href=#scheduling-plugins>默认插件</a> 都通过 <code>MultiPoint</code> 在内部启用。
但是，仍然可以使用单独的扩展点来灵活地重新配置默认值（例如排序和分数权重）。
例如，考虑两个Score插件 <code>DefaultScore1</code> 和 <code>DefaultScore2</code> ，每个插件的权重为 <code>1</code> 。
它们可以用不同的权重重新排序，如下所示：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>kubescheduler.config.k8s.io/v1beta3<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>KubeSchedulerConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>profiles</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>schedulerName</span>:<span style=color:#bbb> </span>multipoint-scheduler<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>plugins</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>score</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>enabled</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;DefaultScore2&#39;</span><span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>weight</span>:<span style=color:#bbb> </span><span style=color:#666>5</span><span style=color:#bbb>
</span></code></pre></div>
<p>在这个例子中，没有必要在 <code>MultiPoint</code> 中明确指定插件，因为它们是默认插件。
<code>Score</code> 中指定的唯一插件是 <code>DefaultScore2</code>。
这是因为通过特定扩展点设置的插件将始终优先于 <code>MultiPoint</code> 插件。
因此，此代码段实质上重新排序了这两个插件，而无需同时指定它们。</p>
<p>配置 <code>MultiPoint</code> 插件时优先级的一般层次结构如下：</p>
<ol>
<li>特定的扩展点首先运行，它们的设置会覆盖其他地方的设置</li>
</ol>
<ol start=2>
<li>通过 <code>MultiPoint</code> 手动配置的插件及其设置</li>
</ol>
<ol start=3>
<li>默认插件及其默认设置</li>
</ol>
<p>为了演示上述层次结构，以下示例基于这些插件：</p>
<table>
<thead>
<tr>
<th>插件</th>
<th>扩展点</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>DefaultQueueSort</code></td>
<td><code>QueueSort</code></td>
</tr>
<tr>
<td><code>CustomQueueSort</code></td>
<td><code>QueueSort</code></td>
</tr>
<tr>
<td><code>DefaultPlugin1</code></td>
<td><code>Score</code>, <code>Filter</code></td>
</tr>
<tr>
<td><code>DefaultPlugin2</code></td>
<td><code>Score</code></td>
</tr>
<tr>
<td><code>CustomPlugin1</code></td>
<td><code>Score</code>, <code>Filter</code></td>
</tr>
<tr>
<td><code>CustomPlugin2</code></td>
<td><code>Score</code>, <code>Filter</code></td>
</tr>
</tbody>
</table>
<p>这些插件的一个有效示例配置是：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>kubescheduler.config.k8s.io/v1beta3<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>KubeSchedulerConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>profiles</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>schedulerName</span>:<span style=color:#bbb> </span>multipoint-scheduler<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>plugins</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>multiPoint</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>enabled</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;CustomQueueSort&#39;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;CustomPlugin1&#39;</span><span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>weight</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;CustomPlugin2&#39;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>disabled</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;DefaultQueueSort&#39;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>filter</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>disabled</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;DefaultPlugin1&#39;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>score</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>enabled</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;DefaultPlugin2&#39;</span><span style=color:#bbb>
</span></code></pre></div>
<p>请注意，在特定扩展点中重新声明 <code>MultiPoint</code> 插件不会出错。
重新声明被忽略（并记录），因为特定的扩展点优先。</p>
<p>除了将大部分配置保存在一个位置之外，此示例还做了一些事情：</p>
<ul>
<li>
<p>启用自定义 <code>queueSort</code> 插件并禁用默认插件</p>
</li>
<li>
<p>启用 <code>CustomPlugin1</code> 和 <code>CustomPlugin2</code>，这将首先为它们的所有扩展点运行</p>
</li>
<li>
<p>禁用 <code>DefaultPlugin1</code>，但仅适用于 <code>filter</code></p>
</li>
<li>
<p>重新排序 <code>DefaultPlugin2</code> 以在 <code>score</code> 中首先运行（甚至在自定义插件之前）</p>
</li>
</ul>
<p>在 <code>v1beta3</code> 之前的配置版本中，没有 <code>multiPoint</code>，上面的代码片段等同于：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>kubescheduler.config.k8s.io/v1beta2<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>KubeSchedulerConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>profiles</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>schedulerName</span>:<span style=color:#bbb> </span>multipoint-scheduler<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>plugins</span>:<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># Disable the default QueueSort plugin</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>queueSort</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>enabled</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;CustomQueueSort&#39;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>disabled</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;DefaultQueueSort&#39;</span><span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># Enable custom Filter plugins</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>filter</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>enabled</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;CustomPlugin1&#39;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;CustomPlugin2&#39;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;DefaultPlugin2&#39;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>disabled</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;DefaultPlugin1&#39;</span><span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># Enable and reorder custom score plugins</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>score</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>enabled</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;DefaultPlugin2&#39;</span><span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>weight</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;DefaultPlugin1&#39;</span><span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>weight</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span></code></pre></div>
<p>虽然这是一个复杂的例子，但它展示了 <code>MultiPoint</code> 配置的灵活性以及它与配置扩展点的现有方法的无缝集成。</p>
<h2 id=调度程序配置迁移>调度程序配置迁移</h2>
<ul class="nav nav-tabs" id=tab-with-md role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tab-with-md-0 role=tab aria-controls=tab-with-md-0 aria-selected=true>v1beta1 → v1beta2</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tab-with-md-1 role=tab aria-controls=tab-with-md-1>v1beta2 → v1beta3</a></li></ul>
<div class=tab-content id=tab-with-md><div id=tab-with-md-0 class="tab-pane show active" role=tabpanel aria-labelledby=tab-with-md-0>
<p>
<ul>
<li>
<p>在 v1beta2 配置版本中，你可以为 <code>NodeResourcesFit</code> 插件使用新的 score 扩展。
新的扩展结合了 <code>NodeResourcesLeastAllocated</code>、<code>NodeResourcesMostAllocated</code> 和 <code>RequestedToCapacityRatio</code> 插件的功能。
例如，如果你之前使用了 <code>NodeResourcesMostAllocated</code> 插件，
则可以改用 <code>NodeResourcesFit</code>（默认启用）并添加一个 <code>pluginConfig</code> 和 <code>scoreStrategy</code>，类似于：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>kubescheduler.config.k8s.io/v1beta2<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>KubeSchedulerConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>profiles</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>pluginConfig</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>args</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>scoringStrategy</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cpu<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>weight</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>MostAllocated<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>NodeResourcesFit<span style=color:#bbb>
</span></code></pre></div></li>
</ul>
<ul>
<li>调度器插件 <code>NodeLabel</code> 已弃用；
相反，要使用 <a href=/zh/docs/concepts/scheduling-eviction/assign-pod-node/#affinity-and-anti-affinity><code>NodeAffinity</code></a>
插件（默认启用）来实现类似的行为。</li>
</ul>
<ul>
<li>调度程序插件 <code>ServiceAffinity</code> 已弃用；
相反，使用 <a href=/zh/doc/concepts/scheduling-eviction/assign-pod-node/#inter-pod-affinity-and-anti-affinity><code>InterPodAffinity</code></a>
插件（默认启用）来实现类似的行为。</li>
</ul>
<ul>
<li>调度器插件 <code>NodePreferAvoidPods</code> 已弃用；
相反，使用 <a href=/zh/docs/concepts/scheduling-eviction/taint-and-toleration/>节点污点</a> 来实现类似的行为。</li>
</ul>
<ul>
<li>在 v1beta2 配置文件中启用的插件优先于该插件的默认配置。</li>
</ul>
<ul>
<li>调度器的健康检查和审计的绑定地址，所配置的 <code>host</code> 或 <code>port</code> 无效将导致验证失败。</li>
</ul>
</div>
<div id=tab-with-md-1 class=tab-pane role=tabpanel aria-labelledby=tab-with-md-1>
<p>
<ul>
<li>默认增加三个插件的权重：
<ul>
<li><code>InterPodAffinity</code> 从 1 到 2</li>
<li><code>NodeAffinity</code> 从 1 到 2</li>
<li><code>TaintToleration</code> 从 1 到 3</li>
</ul>
</li>
</ul>
</div></div>
<h2 id=what-s-next>What's next</h2>
<ul>
<li>阅读 <a href=/zh/docs/reference/command-line-tools-reference/kube-scheduler/>kube-scheduler 参考</a></li>
<li>了解<a href=/zh/docs/concepts/scheduling-eviction/kube-scheduler/>调度</a></li>
<li>阅读 <a href=/zh/docs/reference/config-api/kube-scheduler-config.v1beta2/>kube-scheduler 配置 (v1beta2)</a> 参考</li>
<li>阅读 <a href=/zh/docs/reference/config-api/kube-scheduler-config.v1beta3/>kube-scheduler 配置 (v1beta3)</a> 参考</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-5a0a68fb6a7ffefb6d5f861100fa0ae3>13.2 - 调度策略</h1>
<p>在 Kubernetes v1.23 版本之前，可以使用调度策略来指定 <em>predicates</em> 和 <em>priorities</em> 进程。
例如，可以通过运行 <code>kube-scheduler --policy-config-file &lt;filename></code> 或者
<code>kube-scheduler --policy-configmap &lt;ConfigMap></code> 设置调度策略。</p>
<p>但是从 Kubernetes v1.23 版本开始，不再支持这种调度策略。
同样地也不支持相关的 <code>policy-config-file</code>、 <code>policy-configmap</code>、 <code>policy-configmap-namespace</code> 以及 <code>use-legacy-policy-config</code> 标志。
你可以通过使用 <a href=/zh/docs/reference/scheduling/config/>调度配置</a>来实现类似的行为。</p>
<h2 id=what-s-next>What's next</h2>
<ul>
<li>了解 <a href=/zh/docs/concepts/scheduling-eviction/kube-scheduler/>调度</a>。</li>
<li>了解 <a href=/zh/docs/reference/scheduling/config/>kube-scheduler 配置</a>。</li>
<li>阅读 <a href=/zh/docs/reference/config-api/kube-scheduler-config.v1beta3/>kube-scheduler 配置参考(v1beta3)</a>。</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-c808ce38575e73f72835d7ed02b03780>14 - 其他工具</h1>
<p>Kubernetes 包含多个内置工具来帮助你使用 Kubernetes 系统。</p>
<h2 id=minikube>Minikube</h2>
<p><a href=https://minikube.sigs.k8s.io/docs/><code>minikube</code></a>
是一种在你的工作站上本地运行单节点 Kubernetes 集群的工具，用于开发和测试。</p>
<h2 id=仪表盘>仪表盘</h2>
<p><a href=/zh/docs/tasks/access-application-cluster/web-ui-dashboard/><code>Dashboard</code></a>，
基于 Web 的 Kubernetes 用户界面，
允许你将容器化的应用程序部署到 Kubernetes 集群，
对它们进行故障排查，并管理集群及其资源本身。</p>
<h2 id=helm>Helm</h2>
<p><a href=https://github.com/kubernetes/helm><code>Kubernetes Helm</code></a>
是一个用于管理预配置 Kubernetes 资源包的工具，也就是 Kubernetes 图表。</p>
<p>使用 Helm 来：</p>
<ul>
<li>查找和使用打包为 Kubernetes 图表的流行软件</li>
<li>将你自己的应用程序共享为 Kubernetes 图表</li>
<li>为你的 Kubernetes 应用程序创建可重现的构建</li>
<li>智能管理你的 Kubernetes 清单文件</li>
<li>管理 Helm 包的发布</li>
</ul>
<h2 id=kompose>Kompose</h2>
<p><a href=https://github.com/kubernetes/kompose><code>Kompose</code></a>
是一个帮助 Docker Compose 用户迁移到 Kubernetes 的工具。</p>
<p>使用 Kompose：</p>
<ul>
<li>将 Docker Compose 文件翻译成 Kubernetes 对象</li>
<li>从本地 Docker 开发转到通过 Kubernetes 管理你的应用程序</li>
<li>转换 Docker Compose v1 或 v2 版本的 <code>yaml</code> 文件或<a href=https://docs.docker.com/compose/bundles/>分布式应用程序包</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-7424d2e36f2d487fc836016d83838bac>14.1 - 从 Docker 命令行映射到 crictl</h1>
<div class="alert alert-secondary callout third-party-content" role=alert><strong>Note:</strong>
This section links to third party projects that provide functionality required by Kubernetes. The Kubernetes project authors aren't responsible for these projects, which are listed alphabetically. To add a project to this list, read the <a href=/docs/contribute/style/content-guide/#third-party-content>content guide</a> before submitting a change. <a href=#third-party-content-disclaimer>More information.</a></div>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong>
<p>此页面已被废弃，将在 Kubernetes 1.27 版本删除。
</div>
<p><code>crictl</code> 是兼容 <a class=glossary-tooltip title="一组与 kubelet 集成的容器运行时 API" data-toggle=tooltip data-placement=top href=/zh/docs/concepts/overview/components/#container-runtime target=_blank aria-label=CRI>CRI</a>的容器运行时的一种命令行接口。
你可以使用它来在 Kubernetes 节点上检视和调试容器运行时和应用。
<code>crictl</code> 及其源代码都托管在
<a href=https://github.com/kubernetes-sigs/cri-tools>cri-tools</a> 仓库中。</p>
<p>本页面提供一份参考资料，用来将 <code>docker</code> 命令行工具的常用命令映射到
<code>crictl</code> 的等价命令。</p>
<h2 id=mapping-from-docker-cli-to-crictl>从 docker 命令行映射到 crictl </h2>
<p>映射表格中列举的确切版本是 <code>docker</code> 命令行的 v1.40 版本和 <code>crictl</code> 的 v1.19.0 版本。
这一列表不是完备的。例如，其中并未包含实验性质的 <code>docker</code> 命令。</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong>
<p><code>crictl</code> 的输出格式类似于 <code>docker</code> 命令行，只是对于某些命令而言会有部分列缺失。
如果你的命令输出会被程序解析，请确保你认真查看了对应的命令输出。
</div>
<h3 id=retrieve-debugging-information>获得调试信息 </h3>
<table><caption style=display:none>docker 命令行与 crictl 的映射 - 获得调试信息</caption>
<thead>
<tr>
<th>docker CLI</th>
<th>crictl</th>
<th>描述</th>
<th>不支持的功能</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>attach</code></td>
<td><code>attach</code></td>
<td>挂接到某运行中的容器</td>
<td><code>--detach-keys</code>, <code>--sig-proxy</code></td>
</tr>
<tr>
<td><code>exec</code></td>
<td><code>exec</code></td>
<td>在运行中的容器内执行命令</td>
<td><code>--privileged</code>, <code>--user</code>, <code>--detach-keys</code></td>
</tr>
<tr>
<td><code>images</code></td>
<td><code>images</code></td>
<td>列举镜像</td>
<td> </td>
</tr>
<tr>
<td><code>info</code></td>
<td><code>info</code></td>
<td>显示系统范围的信息</td>
<td> </td>
</tr>
<tr>
<td><code>inspect</code></td>
<td><code>inspect</code>, <code>inspecti</code></td>
<td>返回容器、镜像或任务的底层信息</td>
<td> </td>
</tr>
<tr>
<td><code>logs</code></td>
<td><code>logs</code></td>
<td>取回容器的日志数据</td>
<td><code>--details</code></td>
</tr>
<tr>
<td><code>ps</code></td>
<td><code>ps</code></td>
<td>列举容器</td>
<td> </td>
</tr>
<tr>
<td><code>stats</code></td>
<td><code>stats</code></td>
<td>显示容器资源用量统计的动态数据流</td>
<td>列：NET/BLOCK I/O、PIDs</td>
</tr>
<tr>
<td><code>version</code></td>
<td><code>version</code></td>
<td>显示运行时（Docker、ContainerD 或其他）的版本信息</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id=perform-changes>执行变更 </h3>
<table><caption style=display:none>docker 命令行与 crictl 的映射 - 执行变更</caption>
<thead>
<tr>
<th>docker CLI</th>
<th>crictl</th>
<th>描述</th>
<th>不支持的功能</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>create</code></td>
<td><code>create</code></td>
<td>创建一个新容器</td>
<td> </td>
</tr>
<tr>
<td><code>kill</code></td>
<td><code>stop</code> (超时值为 0)</td>
<td>杀死一个或多个运行中的容器</td>
<td><code>--signal</code></td>
</tr>
<tr>
<td><code>pull</code></td>
<td><code>pull</code></td>
<td>从某镜像库拉取镜像或仓库</td>
<td><code>--all-tags</code>, <code>--disable-content-trust</code></td>
</tr>
<tr>
<td><code>rm</code></td>
<td><code>rm</code></td>
<td>移除一个或者多个容器</td>
<td> </td>
</tr>
<tr>
<td><code>rmi</code></td>
<td><code>rmi</code></td>
<td>移除一个或者多个镜像</td>
<td> </td>
</tr>
<tr>
<td><code>run</code></td>
<td><code>run</code></td>
<td>在一个新的容器中执行命令</td>
<td> </td>
</tr>
<tr>
<td><code>start</code></td>
<td><code>start</code></td>
<td>启动一个或多个已停止的容器</td>
<td><code>--detach-keys</code></td>
</tr>
<tr>
<td><code>stop</code></td>
<td><code>stop</code></td>
<td>停止一个或多个运行中的容器</td>
<td> </td>
</tr>
<tr>
<td><code>update</code></td>
<td><code>update</code></td>
<td>更新一个或多个容器的配置</td>
<td><code>--restart</code>、<code>--blkio-weight</code> 以 CRI 所不支持的资源约束</td>
</tr>
</tbody>
</table>
<h3 id=supported-only-in-crictl>仅被 crictl 支持的命令 </h3>
<table><caption style=display:none>docker 命令行与 crictl 的映射 - 仅被 crictl 支持的命令</caption>
<thead>
<tr>
<th>crictl</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>imagefsinfo</code></td>
<td>返回镜像文件系统信息</td>
</tr>
<tr>
<td><code>inspectp</code></td>
<td>显示一个或多个 Pod 的状态</td>
</tr>
<tr>
<td><code>port-forward</code></td>
<td>将本地端口转发到 Pod</td>
</tr>
<tr>
<td><code>pods</code></td>
<td>列举 Pod</td>
</tr>
<tr>
<td><code>runp</code></td>
<td>运行一个新的 Pod</td>
</tr>
<tr>
<td><code>rmp</code></td>
<td>删除一个或多个 Pod</td>
</tr>
<tr>
<td><code>stopp</code></td>
<td>停止一个或多个运行中的 Pod</td>
</tr>
</tbody>
</table>
</div>
</main>
</div>
</div>
<footer class=d-print-none>
<div class=footer__links>
<nav>
<a class=text-white href=/zh/docs/home/>主页</a>
<a class=text-white href=/zh/blog/>博客</a>
<a class=text-white href=/zh/training/>培训</a>
<a class=text-white href=/zh/partners/>合作伙伴</a>
<a class=text-white href=/zh/community/>社区</a>
<a class=text-white href=/zh/case-studies/>案例分析</a>
</nav>
</div>
<div class=container-fluid>
<div class=row>
<div class="col-6 col-sm-2 text-xs-center order-sm-2">
<ul class="list-inline mb-0">
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="User mailing list" aria-label="User mailing list">
<a class=text-white target=_blank href=https://discuss.kubernetes.io>
<i class="fa fa-envelope"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Twitter aria-label=Twitter>
<a class=text-white target=_blank href=https://twitter.com/kubernetesio>
<i class="fab fa-twitter"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Calendar aria-label=Calendar>
<a class=text-white target=_blank href="https://calendar.google.com/calendar/embed?src=calendar%40kubernetes.io">
<i class="fas fa-calendar-alt"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Youtube aria-label=Youtube>
<a class=text-white target=_blank href=https://youtube.com/kubernetescommunity>
<i class="fab fa-youtube"></i>
</a>
</li>
</ul>
</div>
<div class="col-6 col-sm-2 text-right text-xs-center order-sm-3">
<ul class="list-inline mb-0">
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub>
<a class=text-white target=_blank href=https://github.com/kubernetes/kubernetes>
<i class="fab fa-github"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Slack aria-label=Slack>
<a class=text-white target=_blank href=https://slack.k8s.io>
<i class="fab fa-slack"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Contribute aria-label=Contribute>
<a class=text-white target=_blank href=https://git.k8s.io/community/contributors/guide>
<i class="fas fa-edit"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Stack Overflow" aria-label="Stack Overflow">
<a class=text-white target=_blank href=https://stackoverflow.com/questions/tagged/kubernetes>
<i class="fab fa-stack-overflow"></i>
</a>
</li>
</ul>
</div>
<div class="col-12 col-sm-8 text-center order-sm-2">
<small class=text-white>&copy; 2023 The Kubernetes Authors | Documentation Distributed under <a href=https://git.k8s.io/website/LICENSE class=light-text>CC BY 4.0</a></small>
<br>
<small class=text-white>Copyright &copy; 2023 The Linux Foundation &reg;. All rights reserved. The Linux Foundation has registered trademarks and uses trademarks. For a list of trademarks of The Linux Foundation, please see our <a href=https://www.linuxfoundation.org/trademark-usage class=light-text>Trademark Usage page</a></small>
<br>
<small class=text-white>ICP license: 京ICP备17074266号-3</small>
</div>
</div>
</div>
</footer>
</div>
<script src=/js/popper-1.14.3.min.js integrity=sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49 crossorigin=anonymous></script>
<script src=/js/bootstrap-4.3.1.min.js integrity=sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM crossorigin=anonymous></script>
<script src=/js/main.min.40616251a9b6e4b689e7769be0340661efa4d7ebb73f957404e963e135b4ed52.js integrity="sha256-QGFiUam25LaJ53ab4DQGYe+k1+u3P5V0BOlj4TW07VI=" crossorigin=anonymous></script>
</body>
</html>