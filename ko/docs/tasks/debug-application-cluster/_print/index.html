<!doctype html><html lang=ko class=no-js>
<head>
<meta name=ROBOTS content="NOINDEX, NOFOLLOW">
<script async src="https://www.googletagmanager.com/gtag/js?id=G-JPP6RFM2BP"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-JPP6RFM2BP')</script>
<link rel=alternate hreflang=zh href=https://kubernetes.io/zh/docs/tasks/debug-application-cluster/>
<link rel=alternate hreflang=ja href=https://kubernetes.io/ja/docs/tasks/debug-application-cluster/>
<link rel=alternate hreflang=fr href=https://kubernetes.io/fr/docs/tasks/debug-application-cluster/>
<link rel=alternate hreflang=de href=https://kubernetes.io/de/docs/tasks/debug-application-cluster/>
<link rel=alternate hreflang=es href=https://kubernetes.io/es/docs/tasks/debug-application-cluster/>
<link rel=alternate hreflang=id href=https://kubernetes.io/id/docs/tasks/debug-application-cluster/>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=generator content="Hugo 0.87.0">
<link rel=canonical type=text/html href=https://kubernetes.io/ko/docs/tasks/debug-application-cluster/>
<link rel="shortcut icon" type=image/png href=/images/favicon.png>
<link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180>
<link rel=manifest href=/manifest.webmanifest>
<link rel=apple-touch-icon href=/images/kubernetes-192x192.png>
<title>모니터링, 로깅, 그리고 디버깅 | Kubernetes</title><meta property="og:title" content="모니터링, 로깅, 그리고 디버깅">
<meta property="og:description" content="모니터링 및 로깅을 설정하여 클러스터 문제를 해결하거나, 컨테이너화된 애플리케이션을 디버깅한다.">
<meta property="og:type" content="website">
<meta property="og:url" content="https://kubernetes.io/ko/docs/tasks/debug-application-cluster/"><meta property="og:site_name" content="Kubernetes">
<meta itemprop=name content="모니터링, 로깅, 그리고 디버깅">
<meta itemprop=description content="모니터링 및 로깅을 설정하여 클러스터 문제를 해결하거나, 컨테이너화된 애플리케이션을 디버깅한다."><meta name=twitter:card content="summary">
<meta name=twitter:title content="모니터링, 로깅, 그리고 디버깅">
<meta name=twitter:description content="모니터링 및 로깅을 설정하여 클러스터 문제를 해결하거나, 컨테이너화된 애플리케이션을 디버깅한다.">
<link href=/scss/main.css rel=stylesheet>
<script src=/js/jquery-3.3.1.min.js integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin=anonymous></script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","url":"https://kubernetes.io","logo":"https://kubernetes.io/images/favicon.png"}</script>
<meta name=theme-color content="#326ce5">
<link rel=stylesheet href=/css/feature-states.css>
<meta name=description content="모니터링 및 로깅을 설정하여 클러스터 문제를 해결하거나, 컨테이너화된 애플리케이션을 디버깅한다.">
<meta property="og:description" content="모니터링 및 로깅을 설정하여 클러스터 문제를 해결하거나, 컨테이너화된 애플리케이션을 디버깅한다.">
<meta name=twitter:description content="모니터링 및 로깅을 설정하여 클러스터 문제를 해결하거나, 컨테이너화된 애플리케이션을 디버깅한다.">
<meta property="og:url" content="https://kubernetes.io/ko/docs/tasks/debug-application-cluster/">
<meta property="og:title" content="모니터링, 로깅, 그리고 디버깅">
<meta name=twitter:title content="모니터링, 로깅, 그리고 디버깅">
<meta name=twitter:image content="https://kubernetes.io/images/favicon.png">
<meta name=twitter:image:alt content="Kubernetes">
<meta property="og:image" content="/images/kubernetes-horizontal-color.png">
<meta property="og:type" content="article">
<script src=/js/script.js></script>
</head>
<body class=td-section>
<header>
<nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar" data-auto-burger=primary>
<a class=navbar-brand href=/ko/></a>
<div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar>
<ul class="navbar-nav mt-2 mt-lg-0">
<li class="nav-item mr-2 mb-lg-0">
<a class="nav-link active" href=/ko/docs/>문서</a>
</li>
<li class="nav-item mr-2 mb-lg-0">
<a class=nav-link href=/ko/blog/>쿠버네티스 블로그</a>
</li>
<li class="nav-item mr-2 mb-lg-0">
<a class=nav-link href=/ko/training/>교육</a>
</li>
<li class="nav-item mr-2 mb-lg-0">
<a class=nav-link href=/ko/partners/>파트너</a>
</li>
<li class="nav-item mr-2 mb-lg-0">
<a class=nav-link href=/ko/community/>커뮤니티</a>
</li>
<li class="nav-item mr-2 mb-lg-0">
<a class=nav-link href=/ko/case-studies/>사례 연구</a>
</li>
<li class="nav-item dropdown">
<a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>
버전
</a>
<div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink>
<a class=dropdown-item href=/releases>Release Information</a>
<a class=dropdown-item href=https://kubernetes.io/ko/docs/tasks/debug-application-cluster/>v1.27</a>
<a class=dropdown-item href=https://v1-26.docs.kubernetes.io/ko/docs/tasks/debug-application-cluster/>v1.26</a>
<a class=dropdown-item href=https://v1-25.docs.kubernetes.io/ko/docs/tasks/debug-application-cluster/>v1.25</a>
<a class=dropdown-item href=https://v1-24.docs.kubernetes.io/ko/docs/tasks/debug-application-cluster/>v1.24</a>
<a class=dropdown-item href=https://v1-23.docs.kubernetes.io/ko/docs/tasks/debug-application-cluster/>v1.23</a>
</div>
</li>
<li class="nav-item dropdown">
<a class="nav-link dropdown-toggle" href=# id=navbarDropdownMenuLink role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>
한국어 Korean
</a>
<div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink>
<a class=dropdown-item href=/zh/docs/tasks/debug-application-cluster/>中文 Chinese</a>
<a class=dropdown-item href=/ja/docs/tasks/debug-application-cluster/>日本語 Japanese</a>
<a class=dropdown-item href=/fr/docs/tasks/debug-application-cluster/>Français</a>
<a class=dropdown-item href=/de/docs/tasks/debug-application-cluster/>Deutsch</a>
<a class=dropdown-item href=/es/docs/tasks/debug-application-cluster/>Español</a>
<a class=dropdown-item href=/id/docs/tasks/debug-application-cluster/>Bahasa Indonesia</a>
</div>
</li>
</ul>
</div>
<button id=hamburger onclick=kub.toggleMenu() data-auto-burger-exclude><div></div></button>
</nav>
</header>
<div class="container-fluid td-outer">
<div class=td-main>
<div class="row flex-xl-nowrap">
<main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main>
<div class=td-content>
<div class="pageinfo pageinfo-primary d-print-none">
<p>
이 섹션의 다중 페이지 출력 화면임.
<a href=# onclick="return print(),!1">여기를 클릭하여 프린트</a>.
</p><p>
<a href=/ko/docs/tasks/debug-application-cluster/>이 페이지의 일반 화면으로 돌아가기</a>.
</p>
</div>
<h1 class=title>모니터링, 로깅, 그리고 디버깅</h1>
<div class=lead>모니터링 및 로깅을 설정하여 클러스터 문제를 해결하거나, 컨테이너화된 애플리케이션을 디버깅한다.</div>
<ul>
<li>1: <a href=#pg-c0ec963f381296ca26b839cdf0a6f242>동작 중인 파드 디버그</a></li>
<li>2: <a href=#pg-9713ac27b6d9e3034033200d968221f2>동작중인 컨테이너의 셸에 접근하기</a></li>
<li>3: <a href=#pg-96b25d30e732385047272b84d3c4188f>리소스 메트릭 파이프라인</a></li>
<li>4: <a href=#pg-9e6e1b706f11386fe2c4b4ffda1409e4>리소스 모니터링 도구</a></li>
<li>5: <a href=#pg-a070b1250ee142402d492b505a56ca83>스테이트풀셋 디버깅하기</a></li>
<li>6: <a href=#pg-06bb252f25983de12f635c806d180d30>초기화 컨테이너(Init Containers) 디버그하기</a></li>
<li>7: <a href=#pg-47290c80fb8b00accec6729f3da49734>클러스터 트러블슈팅</a></li>
<li>8: <a href=#pg-434e0133d71583a27478b10fc1d3d105>트러블슈팅하기</a></li>
<li>9: <a href=#pg-ef360b1f8e65236251826db478cfcab3>파드 실패의 원인 검증하기</a></li>
<li>10: <a href=#pg-858517cd46a1b5a1fd2e650edd785cea>파드와 레플리케이션컨트롤러(ReplicationController) 디버그하기</a></li>
</ul>
<div class=content>
</div>
</div>
<div class=td-content>
<h1 id=pg-c0ec963f381296ca26b839cdf0a6f242>1 - 동작 중인 파드 디버그</h1>
<p>이 페이지는 노드에서 동작 중인(혹은 크래시된) 파드를 디버그하는 방법에 대해 설명한다.</p>
<h2 id=시작하기-전에>시작하기 전에</h2>
<ul>
<li>여러분의 <a class=glossary-tooltip title="파드는 클러스터에서 실행 중인 컨테이너의 집합을 나타낸다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/pods/ target=_blank aria-label=파드>파드</a>는 이미 스케줄링 되어
동작하고 있을 것이다. 만약 파드가 아직 동작중이지 않다면, <a href=/docs/tasks/debug-application-cluster/debug-application/>애플리케이션
트러블슈팅</a>을 참고한다.</li>
<li>일부 고급 디버깅 과정에서는 해당 파드가 어떤 노드에서 동작하고 있는지
알아야 하고, 해당 노드에서 쉘 명령어를 실행시킬 수 있어야 한다.
<code>kubectl</code>을 사용하는 일반적인 디버깅 과정에서는 이러한 접근 권한이 필요하지 않다.</li>
</ul>
<h2 id=examine-pod-logs>파드의 로그 확인하기</h2>
<p>먼저, 확인하고자 하는 컨테이너의 로그를 확인한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl logs <span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>POD_NAME</span><span style=color:#b68;font-weight:700>}</span> <span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>CONTAINER_NAME</span><span style=color:#b68;font-weight:700>}</span>
</code></pre></div><p>만약 컨테이너가 이전에 크래시 되었다면, 다음의 명령을 통해 컨테이너의 크래시 로그를 살펴볼 수 있다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl logs --previous <span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>POD_NAME</span><span style=color:#b68;font-weight:700>}</span> <span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>CONTAINER_NAME</span><span style=color:#b68;font-weight:700>}</span>
</code></pre></div><h2 id=container-exec>exec를 통해 컨테이너 디버깅하기</h2>
<p>만약 <a class=glossary-tooltip title="컨테이너의 저장된 인스턴스이며, 애플리케이션 구동에 필요한 소프트웨어 집합을 가지고 있다." data-toggle=tooltip data-placement=top href="/ko/docs/reference/glossary/?all=true#term-image" target=_blank aria-label="컨테이너 이미지">컨테이너 이미지</a>에
디버깅 도구가 포함되어 있다면, <code>kubectl exec</code>을 통해 특정 컨테이너에서 해당 명령들을
실행할 수 있다. (리눅스나 윈도우 OS를 기반으로 만들어진 이미지에는 대부분 디버깅 도구를 포함하고
있다.)</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#a2f>exec</span> <span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>POD_NAME</span><span style=color:#b68;font-weight:700>}</span> -c <span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>CONTAINER_NAME</span><span style=color:#b68;font-weight:700>}</span> -- <span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>CMD</span><span style=color:#b68;font-weight:700>}</span> <span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>ARG1</span><span style=color:#b68;font-weight:700>}</span> <span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>ARG2</span><span style=color:#b68;font-weight:700>}</span> ... <span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>ARGN</span><span style=color:#b68;font-weight:700>}</span>
</code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> <code>-c ${CONTAINER_NAME}</code> 인자는 선택적이다. 만약 하나의 컨테이너만 포함된 파드라면 해당 옵션을 생략할 수 있다.
</div>
<p>예를 들어, 동작 중인 카산드라 파드의 로그를 살펴보기 위해서는 다음과 같은 명령을 실행할 수 있다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#a2f>exec</span> cassandra -- cat /var/log/cassandra/system.log
</code></pre></div><p><code>kubectl exec</code>에 <code>-i</code>와 <code>-t</code> 옵션을 사용해서 터미널에서 접근할 수 있는 쉘을 실행시킬 수도 있다.
예를 들면 다음과 같다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#a2f>exec</span> -it cassandra -- sh
</code></pre></div><p>더욱 상세한 내용은 다음 <a href=/ko/docs/tasks/debug-application-cluster/get-shell-running-container/>동작중인 컨테이너의 쉘에 접근하기</a>를 참고하라.</p>
<h2 id=ephemeral-container>임시(ephemeral) 디버그 컨테이너를 사용해서 디버깅하기</h2>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.23 [beta]</code>
</div>
<p>컨테이너가 크래시 됐거나
<a href=https://github.com/GoogleContainerTools/distroless>distroless 이미지</a>처럼
컨테이너 이미지에 디버깅 도구를 포함하고 있지 않아 <code>kubectl exec</code>로는 충분하지 않은 경우에는
<a class=glossary-tooltip title="A type of container type that you can temporarily run inside a Pod" data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/pods/ephemeral-containers/ target=_blank aria-label="임시(Ephemeral) 컨테이너">임시(Ephemeral) 컨테이너</a>를 사용하는 것이
인터랙티브한 트러블슈팅에 유용하다.</p>
<h3 id=ephemeral-container-example>임시 컨테이너를 사용한 디버깅 예시</h3>
<p><code>kubectl debug</code> 명령어를 사용해서 동작 중인 파드에 임시 컨테이너를 추가할 수 있다.
먼저, 다음과 같이 파드를 추가한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl run ephemeral-demo --image<span style=color:#666>=</span>k8s.gcr.io/pause:3.1 --restart<span style=color:#666>=</span>Never
</code></pre></div><p>이 섹션의 예시에서는 디버깅 도구가 포함되지 않은 이미지의 사례를 보여드리기 위해
<code>pause</code> 컨테이너 이미지를 사용했는데, 이 대신 어떠한 이미지를 사용해도
될 것이다.</p>
<p>만약 <code>kubectl exec</code>을 통해 쉘을 생성하려 한다면 다음과 같은 에러를
확인할 수 있을 텐데, 그 이유는 이 이미지에 쉘이 존재하지 않기 때문이다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#a2f>exec</span> -it ephemeral-demo -- sh
</code></pre></div><pre><code>OCI runtime exec failed: exec failed: container_linux.go:346: starting container process caused &quot;exec: \&quot;sh\&quot;: executable file not found in $PATH&quot;: unknown
</code></pre><p>이 명령어 대신 <code>kubectl debug</code>을 사용해서 디버깅 컨테이너를 생성할 수 있다.
만약 <code>-i</code>/<code>--interactive</code> 인자를 사용한다면, <code>kubectl</code>은 임시
컨테이너의 콘솔에 자동으로 연결할 것이다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl debug -it ephemeral-demo --image<span style=color:#666>=</span>busybox --target<span style=color:#666>=</span>ephemeral-demo
</code></pre></div><pre><code>Defaulting debug container name to debugger-8xzrl.
If you don't see a command prompt, try pressing enter.
/ #
</code></pre><p>이 명령어는 새로운 busybox 컨테이너를 추가하고 해당 컨테이너로 연결한다. <code>--target</code>
파라미터를 사용하면 다른 컨테이너의 프로세스 네임스페이스를 대상으로 하게 된다. 여기서는
이 옵션이 꼭 필요한데, <code>kubectl run</code>이 생성하는 파드에 대해
<a href=/docs/tasks/configure-pod-container/share-process-namespace/>프로세스 네임스페이스 공유</a>를
활성화하지 않기 때문이다.</p>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> <code>--target</code> 파라미터는 사용 중인 <a class=glossary-tooltip title="컨테이너 런타임은 컨테이너 실행을 담당하는 소프트웨어이다." data-toggle=tooltip data-placement=top href=/ko/docs/setup/production-environment/container-runtimes/ target=_blank aria-label="컨테이너 런타임">컨테이너 런타임</a>에서
지원해야지만 사용할 수 있다. 만일 지원되지 않는다면,
임시 컨테이너가 시작되지 않을 수 있거나 독립적인 프로세스
네임스페이스를 가지고 시작될 수 있다.
</div>
<p><code>kubectl describe</code> 명령을 사용하면 새롭게 생성된 임시 컨테이너의 상태를 확인할 수 있다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe pod ephemeral-demo
</code></pre></div><pre><code>...
Ephemeral Containers:
  debugger-8xzrl:
    Container ID:   docker://b888f9adfd15bd5739fefaa39e1df4dd3c617b9902082b1cfdc29c4028ffb2eb
    Image:          busybox
    Image ID:       docker-pullable://busybox@sha256:1828edd60c5efd34b2bf5dd3282ec0cc04d47b2ff9caa0b6d4f07a21d1c08084
    Port:           &lt;none&gt;
    Host Port:      &lt;none&gt;
    State:          Running
      Started:      Wed, 12 Feb 2020 14:25:42 +0100
    Ready:          False
    Restart Count:  0
    Environment:    &lt;none&gt;
    Mounts:         &lt;none&gt;
...
</code></pre><p>디버깅이 다 끝나면 <code>kubectl delete</code>을 통해 파드를 제거할 수 있다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete pod ephemeral-demo
</code></pre></div><h2 id=파드의-복제본을-이용해서-디버깅하기>파드의 복제본을 이용해서 디버깅하기</h2>
<p>때때로 파드의 설정 옵션에 따라 특정 상황에서 트러블슈팅을 하기가 어려울 수 있다.
예를 들어, 만일 여러분의 컨테이너 이미지가 쉘을 포함하고 있지 않거나, 여러분의
애플리케이션이 컨테이너 시작에서 크래시가 발생한다면 <code>kubectl exec</code>을 이용해서
컨테이너를 트러블슈팅할 수 없을 수 있다. 이러한 상황에서는 <code>kubectl debug</code>을 사용해서
파드의 복제본을 디버깅을 위한 추가적인 설정 옵션과 함께 생성할 수 있다.</p>
<h3 id=새-컨테이너와-함께-파드의-복제본-생성하기>새 컨테이너와 함께 파드의 복제본 생성하기</h3>
<p>만일 여러분의 애플리케이션이 동작은 하고 있지만 예상과는 다르게 동작하는 경우,
파드의 복제본에 새로운 컨테이너를 추가함으로써 추가적인 트러블슈팅 도구들을
파드에 함께 추가할 수 있다.</p>
<p>가령, 여러분의 애플리케이션 컨테이너 이미지는 <code>busybox</code>를 기반으로 하고 있는데
여러분은 <code>busybox</code>에는 없는 디버깅 도구를 필요로 한다고 가정해 보자. 이러한
시나리오는 <code>kubectl run</code> 명령을 통해 시뮬레이션 해볼 수 있다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl run myapp --image<span style=color:#666>=</span>busybox --restart<span style=color:#666>=</span>Never -- sleep 1d
</code></pre></div><p>다음의 명령을 실행시켜 디버깅을 위한 새로운 우분투 컨테이너와 함께 <code>myapp-debug</code>이란
이름의 <code>myapp</code> 컨테이너 복제본을 생성할 수 있다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl debug myapp -it --image<span style=color:#666>=</span>ubuntu --share-processes --copy-to<span style=color:#666>=</span>myapp-debug
</code></pre></div><pre><code>Defaulting debug container name to debugger-w7xmf.
If you don't see a command prompt, try pressing enter.
root@myapp-debug:/#
</code></pre><div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> <ul>
<li>만일 여러분이 새로 생성되는 컨테이너의 이름을 <code>--container</code> 플래그와 함께 지정하지 않는다면,
<code>kubectl debug</code>는 자동으로 새로운 컨테이너 이름을 생성한다.</li>
<li><code>-i</code> 플래그를 사용하면 <code>kubectl debug</code> 명령이 새로운 컨테이너에 기본적으로 연결되게 된다.
이러한 동작은 <code>--attach=false</code>을 지정하여 방지할 수 있다. 만일 여러분의 세션이
연결이 끊어진다면 <code>kubectl attach</code>를 사용해서 다시 연결할 수 있다.</li>
<li><code>--share-processes</code> 옵션은 이 파드에 있는 컨테이너가 해당 파드에 속한 다른 컨테이너의
프로세스를 볼 수 있도록 한다. 이 옵션이 어떻게 동작하는지에 대해 더 알아보기 위해서는
다음의 <a href=/docs/tasks/configure-pod-container/share-process-namespace/>파드의 컨테이너 간 프로세스 네임스페이스 공유</a>를 참고하라.</li>
</ul>
</div>
<p>사용이 모두 끝나면, 디버깅에 사용된 파드를 잊지 말고 정리한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete pod myapp myapp-debug
</code></pre></div><h3 id=명령어를-변경하며-파드의-복제본-생성하기>명령어를 변경하며 파드의 복제본 생성하기</h3>
<p>때때로 컨테이너의 명령어를 변경하는 것이 유용한 경우가 있는데, 예를 들면 디버그 플래그를 추가하기
위해서나 애플리케이션이 크래시 되는 경우이다.</p>
<p>다음의 <code>kubectl run</code> 명령을 통해 즉각적으로 크래시가 발생하는 애플리케이션의
사례를 시뮬레이션해 볼 수 있다.</p>
<pre><code>kubectl run --image=busybox myapp -- false
</code></pre><p><code>kubectl describe pod myapp</code> 명령을 통해 이 컨테이너에 크래시가 발생하고 있음을 확인할 수 있다.</p>
<pre><code>Containers:
  myapp:
    Image:         busybox
    ...
    Args:
      false
    State:          Waiting
      Reason:       CrashLoopBackOff
    Last State:     Terminated
      Reason:       Error
      Exit Code:    1
</code></pre><p>이러한 경우에 <code>kubectl debug</code>을 통해 명령어를 지정함으로써 해당 파드의
복제본을 인터랙티브 쉘로 생성할 수 있다.</p>
<pre><code>kubectl debug myapp -it --copy-to=myapp-debug --container=myapp -- sh
</code></pre><pre><code>If you don't see a command prompt, try pressing enter.
/ #
</code></pre><p>이제 인터랙티브 쉘에 접근할 수 있으니 파일 시스템 경로를 확인하거나
동작 중인 컨테이너의 명령어를 직접 확인하는 등의 작업이 가능하다.</p>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> <ul>
<li>특정 컨테이너의 명령어를 변경하기 위해서는 <code>--container</code> 옵션을 통해 해당 컨테이너의
이름을 지정해야만 한다. 이름을 지정하지 않는다면 <code>kubectl debug</code>은 이전에 지정한 명령어를
그대로 사용해서 컨테이너를 생성할 것이다.</li>
<li>기본적으로 <code>-i</code> 플래그는 <code>kubectl debug</code> 명령이 컨테이너에 바로 연결되도록 한다.
이러한 동작을 방지하기 위해서는 <code>--attach=false</code> 옵션을 지정할 수 있다. 만약 여러분이 세션이
종료된다면 <code>kubectl attach</code> 명령을 통해 다시 연결할 수 있다.</li>
</ul>
</div>
<p>사용이 모두 끝나면, 디버깅에 사용된 파드들을 잊지 말고 정리한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete pod myapp myapp-debug
</code></pre></div><h3 id=컨테이너-이미지를-변경하며-파드의-복제본-생성하기>컨테이너 이미지를 변경하며 파드의 복제본 생성하기</h3>
<p>특정한 경우에 여러분은 제대로 동작하지 않는 파드의 이미지를
기존 프로덕션 컨테이너 이미지에서 디버깅 빌드나 추가적인 도구를 포함한
이미지로 변경하고 싶을 수 있다.</p>
<p>이 사례를 보여주기 위해 <code>kubectl run</code> 명령을 통해 파드를 생성하였다.</p>
<pre><code>kubectl run myapp --image=busybox --restart=Never -- sleep 1d
</code></pre><p>여기서는 <code>kubectl debug</code> 명령을 통해 해당 컨테이너 이미지를 <code>ubuntu</code>로 변경하며
복제본을 생성하였다.</p>
<pre><code>kubectl debug myapp --copy-to=myapp-debug --set-image=*=ubuntu
</code></pre><p><code>--set-image</code>의 문법은 <code>kubectl set image</code>와 동일하게 <code>container_name=image</code>
형식의 문법을 사용한다. <code>*=ubuntu</code>라는 의미는 모든 컨테이너의 이미지를 <code>ubuntu</code>로
변경하겠다는 의미이다.</p>
<p>사용이 모두 끝나면, 디버깅에 사용된 파드를 잊지 말고 정리한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete pod myapp myapp-debug
</code></pre></div><h2 id=node-shell-session>노드의 쉘을 사용해서 디버깅하기</h2>
<p>만약 위의 어떠한 방법도 사용할 수 없다면, 파드가 현재 동작 중인 노드를 찾아
호스트의 네임스페이스로 동작하는 특권 파드를 생성할 수 있다.
다음 <code>kubectl debug</code> 명령을 통해 해당 노드에서 인터랙티브한 쉘을 생성할 수 있다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl debug node/mynode -it --image<span style=color:#666>=</span>ubuntu
</code></pre></div><pre><code>Creating debugging pod node-debugger-mynode-pdx84 with container debugger on node mynode.
If you don't see a command prompt, try pressing enter.
root@ek8s:/#
</code></pre><p>노드에서 디버깅 세션을 생성할 때 유의해야 할 점은 다음과 같다.</p>
<ul>
<li><code>kubectl debug</code>는 노드의 이름에 기반해 새로운 파드의 이름을
자동으로 생성한다.</li>
<li>컨테이너는 호스트 네임스페이스(IPC, 네트워크, PID 네임스페이스)에서 동작한다.</li>
<li>노드의 루트 파일시스템은 <code>/host</code>에 마운트된다.</li>
</ul>
<p>사용이 모두 끝나면, 디버깅에 사용된 파드를 잊지 말고 정리한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete pod node-debugger-mynode-pdx84
</code></pre></div>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-9713ac27b6d9e3034033200d968221f2>2 - 동작중인 컨테이너의 셸에 접근하기</h1>
<p>이 페이지는 동작중인 컨테이너에 접근하기 위해 <code>kubectl exec</code>을 사용하는
방법에 대해 설명한다.</p>
<h2 id=시작하기-전에>시작하기 전에</h2>
<p>쿠버네티스 클러스터가 필요하고, kubectl 커맨드-라인 툴이 클러스터와
통신할 수 있도록 설정되어 있어야 한다. 이 튜토리얼은 컨트롤 플레인 호스트가 아닌 노드가 적어도 2개 포함된 클러스터에서 실행하는 것을 추천한다. 만약, 아직 클러스터를 가지고
있지 않다면,
<a href=/ko/docs/tasks/tools/#minikube>minikube</a>를 사용해서 생성하거나
다음의 쿠버네티스 플레이그라운드 중 하나를 사용할 수 있다.</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=https://labs.play-with-k8s.com/>Play with Kubernetes</a></li>
</ul>
<h2 id=컨테이너의-셸에-접근하기>컨테이너의 셸에 접근하기</h2>
<p>이 예시에서는 하나의 컨테이너를 가진 파드를 생성할 것이다. 이 컨테이너는
nginx 이미지를 실행한다. 해당 파드에 대한 설정 파일은 다음과 같다.</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/ko/examples/application/shell-demo.yaml download=application/shell-demo.yaml><code>application/shell-demo.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('application-shell-demo-yaml')" title="Copy application/shell-demo.yaml to clipboard">
</img>
</div>
<div class=includecode id=application-shell-demo-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>shell-demo<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>shared-data<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>emptyDir</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>shared-data<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/usr/share/nginx/html<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>hostNetwork</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>dnsPolicy</span>:<span style=color:#bbb> </span>Default<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>파드를 생성한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/application/shell-demo.yaml
</code></pre></div><p>다음을 통해 컨테이너가 동작하고 있는지 확인할 수 있다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod shell-demo
</code></pre></div><p>동작중인 컨테이너의 셸에 접근한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#a2f>exec</span> --stdin --tty shell-demo -- /bin/bash
</code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> kubectl 명령어 인자와 사용하고자 하는 명령어의 인자를 구분하기 위해서는 이중 대시(<code>--</code>)를 사용할 수 있다.
</div>
<p>셸에 접근해서 다음처럼 루트 디렉토리를 확인해 볼 수 있다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># Run this inside the container</span>
ls /
</code></pre></div><p>접근한 셸에서 다른 명령어도 한번 실행해 보아라. 다음은 실행해 볼
명령의 예시이다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># You can run these example commands inside the container</span>
ls /
cat /proc/mounts
cat /proc/1/maps
apt-get update
apt-get install -y tcpdump
tcpdump
apt-get install -y lsof
lsof
apt-get install -y procps
ps aux
ps aux | grep nginx
</code></pre></div><h2 id=nginx의-최상단-페이지-작성하기>nginx의 최상단 페이지 작성하기</h2>
<p>앞에서 생성한 파드에 대한 설정을 살펴보아라. 파드에는
<code>emptyDir</code> 볼륨이 사용되었고, 이 컨테이너는 해당 볼륨을
<code>/usr/share/nginx/html</code> 경로에 마운트하였다.</p>
<p>접근한 셸 환경에서 <code>/usr/share/nginx/html</code> 디렉터리에 <code>index.html</code> 파일을
생성해 보아라.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># Run this inside the container</span>
<span style=color:#a2f>echo</span> <span style=color:#b44>&#39;Hello shell demo&#39;</span> &gt; /usr/share/nginx/html/index.html
</code></pre></div><p>셸 환경에서 nginx 서버에 GET 요청을 시도해보면 다음과 같다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># Run this in the shell inside your container</span>
apt-get update
apt-get install curl
curl http://localhost/
</code></pre></div><p>출력 결과는 여러분이 <code>index.html</code> 파일에 작성한 텍스트를 출력할 것이다.</p>
<pre><code>Hello shell demo
</code></pre><p>셸 사용이 모두 끝났다면 <code>exit</code>을 입력해 종료하라.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#a2f>exit</span> <span style=color:#080;font-style:italic># To quit the shell in the container</span>
</code></pre></div><h2 id=컨테이너에서-개별-명령어-실행하기>컨테이너에서 개별 명령어 실행하기</h2>
<p>셸이 아닌 일반적인 커맨드 환경에서 다음처럼 동작중인 컨테이너의
환경 변수를 출력할 수 있다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#a2f>exec</span> shell-demo env
</code></pre></div><p>다른 명령어도 한번 실행해 보아라. 다음은 실행해 볼 명령의 예시이다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#a2f>exec</span> shell-demo -- ps aux
kubectl <span style=color:#a2f>exec</span> shell-demo -- ls /
kubectl <span style=color:#a2f>exec</span> shell-demo -- cat /proc/1/mounts
</code></pre></div>
<h2 id=파드에-한-개-이상의-컨테이너가-있을-경우-셸에-접근하기>파드에 한 개 이상의 컨테이너가 있을 경우 셸에 접근하기</h2>
<p>만일 파드에 한 개 이상의 컨테이너가 있을 경우, <code>kubectl exec</code> 명령어에
<code>--container</code> 혹은 <code>-c</code> 옵션을 사용해서 컨테이너를 지정하라. 예를 들어,
여러분이 my-pod라는 이름의 파드가 있다고 가정해 보자. 이 파드에는 <em>main-app</em> 과
<em>helper-app</em> 이라는 이름의 두 컨테이너가 있다. 다음 명령어는 <em>main-app</em>
컨테이너에 대한 셸에 접근할 것이다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#a2f>exec</span> -i -t my-pod --container main-app -- /bin/bash
</code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> 축약형 옵션인 <code>-i</code> 와 <code>-t</code> 는 각각 <code>--stdin</code> 와 <code>--tty</code> 옵션에 대응된다.
</div>
<h2 id=다음-내용>다음 내용</h2>
<ul>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands/#exec>kubectl exec</a>를 참고한다.</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-96b25d30e732385047272b84d3c4188f>3 - 리소스 메트릭 파이프라인</h1>
<p>컨테이너 CPU 및 메모리 사용량과 같은 리소스 사용량 메트릭은
쿠버네티스의 메트릭 API를 통해 사용할 수 있다. 이 메트릭은
<code>kubectl top</code> 커맨드 사용하여 사용자가 직접적으로 액세스하거나,
Horizontal Pod Autoscaler 같은 클러스터의 컨트롤러에서 결정을 내릴 때 사용될 수 있다.</p>
<h2 id=메트릭-api>메트릭 API</h2>
<p>메트릭 API를 통해, 주어진 노드나 파드에서 현재 사용중인
리소스의 양을 알 수 있다. 이 API는 메트릭 값을 저장하지
않으므로, 예를 들어, 지정된 노드에서 10분 전에 사용된 리소스의 양을
가져오는 것과 같은 일을 할 수는 없다.</p>
<p>이 API와 다른 API는 차이가 없다.</p>
<ul>
<li>다른 쿠버네티스 API의 엔드포인트와 같이 <code>/apis/metrics.k8s.io/</code> 하위 경로에서 발견될 수 있다</li>
<li>동일한 보안, 확장성 및 신뢰성 보장을 제공한다</li>
</ul>
<p><a href=https://github.com/kubernetes/metrics/blob/master/pkg/apis/metrics/v1beta1/types.go>k8s.io/metrics</a>
리포지터리에서 이 API를 정의하고 있다. 여기에서 이 API에 대한 더 상세한 정보를 찾을 수 있다.</p>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> 이 API를 사용하려면 메트릭 서버를 클러스터에 배포해야 한다. 그렇지 않으면 사용할 수 없다.
</div>
<h2 id=리소스-사용량-측정>리소스 사용량 측정</h2>
<h3 id=cpu>CPU</h3>
<p>CPU는 일정 기간 동안
<a href=/ko/docs/concepts/configuration/manage-resources-containers/#cpu%EC%9D%98-%EC%9D%98%EB%AF%B8>CPU 코어</a>에서
평균 사용량으로 리포트된다. 이 값은 커널(리눅스와 윈도우 커널 모두)에서 제공하는
누적 CPU 카운터보다 높은 비율을 적용해서 얻는다.
kubelet은 비율 계산에 사용할 윈도우를 선택한다.</p>
<h3 id=메모리>메모리</h3>
<p>메모리는 메트릭이 수집된 순간 작업 집합으로 리포트 된다.
이상적인 환경에서 "작업 집합(working set)"은 압박(memory pressure)에서 풀려날 수 없는 사용 중인(in-use) 메모리의 양이다.
그러나 작업 집합의 계산은 호스트 OS에 따라 다르며, 일반적으로 휴리스틱스를 사용해서 평가한다.
쿠버네티스는 스왑(swap)을 지원하지 않기 때문에 모든 익명(파일로 백업되지 않은) 메모리를 포함한다.
호스트 OS가 항상 이러한 페이지를 회수할 수 없기 때문에 메트릭에는 일반적으로 일부 캐시된(파일 백업) 메모리도 포함된다.</p>
<h2 id=메트릭-서버>메트릭 서버</h2>
<p><a href=https://github.com/kubernetes-sigs/metrics-server>메트릭 서버</a>는 클러스터 전역에서 리소스 사용량 데이터를 집계한다.
<code>kube-up.sh</code> 스크립트에 의해 생성된 클러스터에는 기본적으로 메트릭 서버가
디플로이먼트 오브젝트로 배포된다. 만약 다른 쿠버네티스 설치 메커니즘을 사용한다면, 제공된
<a href=https://github.com/kubernetes-sigs/metrics-server/releases>디플로이먼트 components.yaml</a> 파일을 사용하여 메트릭 서버를 배포할 수 있다.</p>
<p>메트릭 서버는 각 노드에서 <a href=/docs/reference/command-line-tools-reference/kubelet/>Kubelet</a>에 의해
노출된 Summary API에서 메트릭을 수집하고, <a href=/ko/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/>쿠버네티스 aggregator</a>를
통해 메인 API 서버에 등록된다.</p>
<p><a href=https://github.com/kubernetes/community/blob/master/contributors/design-proposals/instrumentation/metrics-server.md>설계 문서</a>에서
메트릭 서버에 대해 자세하게 배울 수 있다.</p>
<h3 id=요약-summary-api-소스>요약(Summary) API 소스</h3>
<p><a href=/docs/reference/command-line-tools-reference/kubelet/>Kubelet</a>은 노드, 볼륨, 파드, 컨테이너 수준의 통계를 수집하며,
소비자(consumer)가 읽을 수 있도록 이 통계를
<a href=https://github.com/kubernetes/kubernetes/blob/7d309e0104fedb57280b261e5677d919cb2a0e2d/staging/src/k8s.io/kubelet/pkg/apis/stats/v1alpha1/types.go>요약 API</a>에 기록한다.</p>
<p>1.23 이전에는 이러한 자원들은 기본적으로 <a href=https://github.com/google/cadvisor>cAdvisor</a>에 의해 수집되었다.
그러나, 1.23에서 <code>PodAndContainerStatsFromCRI</code> 기능 게이트가 추가되면서, 컨테이너 및 파드 수준 통계를 CRI 구현에서 수집할 수 있게 되었다.
참고: 이를 위해서는 CRI 구현에서도 이 기능을 지원해야 한다(containerd >= 1.6.0, CRI-O >= 1.23.0).</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-9e6e1b706f11386fe2c4b4ffda1409e4>4 - 리소스 모니터링 도구</h1>
<p>애플리케이션을 스케일하여 신뢰할 수 있는 서비스를 제공하려면,
애플리케이션이 배포되었을 때 애플리케이션이 어떻게 동작하는지를 이해해야 한다.
컨테이너, <a href=/ko/docs/concepts/workloads/pods/>파드</a>,
<a href=/ko/docs/concepts/services-networking/service>서비스</a>,
그리고 전체 클러스터의 특성을 검사하여
쿠버네티스 클러스터 내의 애플리케이션 성능을 검사할 수 있다. 쿠버네티스는 각 레벨에서
애플리케이션의 리소스 사용량에 대한 상세 정보를 제공한다.
이 정보는 애플리케이션의 성능을 평가하고
병목 현상을 제거하여 전체 성능을 향상할 수 있게 해준다.</p>
<p>쿠버네티스에서 애플리케이션 모니터링은 단일 모니터링 솔루션에 의존하지 않는다.
신규 클러스터에서는, <a href=#%EB%A6%AC%EC%86%8C%EC%8A%A4-%EB%A9%94%ED%8A%B8%EB%A6%AD-%ED%8C%8C%EC%9D%B4%ED%94%84%EB%9D%BC%EC%9D%B8>리소스 메트릭</a> 또는
<a href=#%EC%99%84%EC%A0%84%ED%95%9C-%EB%A9%94%ED%8A%B8%EB%A6%AD-%ED%8C%8C%EC%9D%B4%ED%94%84%EB%9D%BC%EC%9D%B8>완전한 메트릭</a> 파이프라인으로 모니터링 통계를 수집할 수 있다.</p>
<h2 id=리소스-메트릭-파이프라인>리소스 메트릭 파이프라인</h2>
<p>리소스 메트릭 파이프라인은
<a href=/ko/docs/tasks/run-application/horizontal-pod-autoscale>Horizontal Pod Autoscaler</a>
컨트롤러와 같은 클러스터 구성요소나
<code>kubectl top</code> 유틸리티에 관련되어 있는
메트릭들로 제한된 집합을 제공한다. 이 메트릭은 경량의 단기 인메모리 저장소인
<a href=https://github.com/kubernetes-sigs/metrics-server>metrics-server</a>에
의해서 수집되며 <code>metrics.k8s.io</code> API를 통해 노출된다.</p>
<p>metrics-server는 클러스터 상의 모든 노드를 발견하고 각 노드의
<a href=/docs/reference/command-line-tools-reference/kubelet/>Kubelet</a>에 CPU와 메모리
사용량을 질의한다. Kubelet은 쿠버네티스 마스터와 노드 간의 다리 역할을 해서
머신에서 구동되는 파드와 컨테이너를 관리한다. Kubelet은 각각의 파드를 해당하는
컨테이너로 변환하고 컨테이너 런타임 인터페이스를 통해서 컨테이너 런타임에서
개별 컨테이너의 사용량 통계를 가져온다. Kubelet은 이 정보를 레거시 도커와의
통합을 위해 kubelet에 통합된 cAdvisor를 통해 가져온다. 그 다음으로 취합된 파드
리소스 사용량 통계를 metric-server 리소스 메트릭 API를 통해 노출한다. 이 API는
kubelet의 인증이 필요한 읽기 전용 포트 상의 <code>/metrics/resource/v1beta1</code>에서
제공된다.</p>
<h2 id=완전한-메트릭-파이프라인>완전한 메트릭 파이프라인</h2>
<p>완전한 메트릭 파이프라인은 보다 풍부한 메트릭에 접근할 수 있도록 해준다.
쿠버네티스는 Horizontal Pod Autoscaler와 같은 메커니즘을 활용해서 이런 메트릭에
대한 반응으로 클러스터의 현재 상태를 기반으로 자동으로 스케일링하거나 클러스터를
조정할 수 있다. 모니터링 파이프라인은 kubelet에서 메트릭을 가져와서 쿠버네티스에
<code>custom.metrics.k8s.io</code>와 <code>external.metrics.k8s.io</code> API를 구현한 어댑터를 통해
노출한다.</p>
<p>CNCF 프로젝트인, <a href=https://prometheus.io>프로메테우스</a>는 기본적으로 쿠버네티스, 노드, 프로메테우스 자체를 모니터링할 수 있다.
CNCF 프로젝트가 아닌 완전한 메트릭 파이프라인 프로젝트는 쿠버네티스 문서의 범위가 아니다.</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-a070b1250ee142402d492b505a56ca83>5 - 스테이트풀셋 디버깅하기</h1>
<p>이 문서에서는 스테이트풀셋을 디버깅 방법에 대해 설명한다.</p>
<h2 id=시작하기-전에>시작하기 전에</h2>
<ul>
<li>쿠버네티스 클러스터가 준비되어 있어야 하고, kubectl 커맨드 라인 도구가 클러스터와 통신할 수 있게 사전에 설정되어 있어야 한다.</li>
<li>조사하고자 하는 스테이트풀셋이 사전에 준비되어 있어야 한다.</li>
</ul>
<h2 id=스테이트풀셋-디버깅하기>스테이트풀셋 디버깅하기</h2>
<p>레이블이 <code>app=myapp</code>으로 지정된 스테이트풀셋 파드를 전부 나열하기 위해서는
다음의 명령을 사용할 수 있다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>myapp
</code></pre></div><p>만약 오랜 시간동안 <code>Unknown</code>이나 <code>Terminating</code> 상태에 있는
파드들을 발견하였다면, 이러한 파드들을 어떻게 다루는지 알아보기 위해
<a href=/ko/docs/tasks/run-application/delete-stateful-set/>스테이트풀셋 파드 삭제하기</a>를 참고하길 바란다.
스테이트풀셋에 포함된 개별 파드들을 디버깅하기 위해서는
<a href=/ko/docs/tasks/debug-application-cluster/debug-pod-replication-controller/>파드 디버그하기</a> 가이드를 참고하길 바란다.</p>
<h2 id=다음-내용>다음 내용</h2>
<p><a href=/ko/docs/tasks/debug-application-cluster/debug-init-containers/>초기화 컨테이너(Init container) 디버그하기</a>를 참고길 바란다.</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-06bb252f25983de12f635c806d180d30>6 - 초기화 컨테이너(Init Containers) 디버그하기</h1>
<p>이 페이지는 초기화 컨테이너의 실행과 관련된 문제를
조사하는 방법에 대해 보여준다. 아래 예제의 커맨드 라인은 파드(Pod)를 <code>&lt;pod-name></code> 으로,
초기화 컨테이너를 <code>&lt;init-container-1></code> 과
<code>&lt;init-container-2></code> 로 표시한다.</p>
<h2 id=시작하기-전에>시작하기 전에</h2>
<p><p>쿠버네티스 클러스터가 필요하고, kubectl 커맨드-라인 툴이 클러스터와
통신할 수 있도록 설정되어 있어야 한다. 이 튜토리얼은 컨트롤 플레인 호스트가 아닌 노드가 적어도 2개 포함된 클러스터에서 실행하는 것을 추천한다. 만약, 아직 클러스터를 가지고
있지 않다면,
<a href=/ko/docs/tasks/tools/#minikube>minikube</a>를 사용해서 생성하거나
다음의 쿠버네티스 플레이그라운드 중 하나를 사용할 수 있다.</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=https://labs.play-with-k8s.com/>Play with Kubernetes</a></li>
</ul>
버전 확인을 위해서, 다음 커맨드를 실행 <code>kubectl version</code>.
</p>
<ul>
<li>사용자는 <a href=/ko/docs/concepts/workloads/pods/init-containers/>초기화 컨테이너</a>의
기본 사항에 익숙해야 한다.</li>
<li>사용자는 <a href=/ko/docs/tasks/configure-pod-container/configure-pod-initialization/#%EC%B4%88%EA%B8%B0%ED%99%94-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88%EB%A5%BC-%EA%B0%96%EB%8A%94-%ED%8C%8C%EB%93%9C-%EC%83%9D%EC%84%B1>초기화 컨테이너를 구성</a>해야 한다.</li>
</ul>
<h2 id=초기화-컨테이너의-상태-체크하기>초기화 컨테이너의 상태 체크하기</h2>
<p>사용자 파드의 상태를 표시한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod &lt;pod-name&gt;
</code></pre></div><p>예를 들어, <code>Init:1/2</code> 상태는 두 개의 초기화 컨테이너 중
하나가 성공적으로 완료되었음을 나타낸다.</p>
<pre><code>NAME         READY     STATUS     RESTARTS   AGE
&lt;pod-name&gt;   0/1       Init:1/2   0          7s
</code></pre><p>상태값과 그 의미에 대한 추가 예제는
<a href=#%ED%8C%8C%EB%93%9C%EC%9D%98-%EC%83%81%ED%83%9C-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0>파드 상태 이해하기</a>를 참조한다.</p>
<h2 id=초기화-컨테이너에-대한-상세-정보-조회하기>초기화 컨테이너에 대한 상세 정보 조회하기</h2>
<p>초기화 컨테이너의 실행에 대한 상세 정보를 확인한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe pod &lt;pod-name&gt;
</code></pre></div><p>예를 들어, 2개의 초기화 컨테이너가 있는 파드는 다음과 같이 표시될 수 있다.</p>
<pre><code>Init Containers:
  &lt;init-container-1&gt;:
    Container ID:    ...
    ...
    State:           Terminated
      Reason:        Completed
      Exit Code:     0
      Started:       ...
      Finished:      ...
    Ready:           True
    Restart Count:   0
    ...
  &lt;init-container-2&gt;:
    Container ID:    ...
    ...
    State:           Waiting
      Reason:        CrashLoopBackOff
    Last State:      Terminated
      Reason:        Error
      Exit Code:     1
      Started:       ...
      Finished:      ...
    Ready:           False
    Restart Count:   3
    ...
</code></pre><p>파드 스펙의 <code>status.initContainerStatuses</code> 필드를 읽어서
프로그래밍 방식으로 초기화 컨테이너의 상태를 조회할 수도 있다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod nginx --template <span style=color:#b44>&#39;{{.status.initContainerStatuses}}&#39;</span>
</code></pre></div><p>이 명령은 원시 JSON 방식으로 위와 동일한 정보를 반환한다.</p>
<h2 id=초기화-컨테이너의-로그-조회하기>초기화 컨테이너의 로그 조회하기</h2>
<p>초기화 컨테이너의 로그를 확인하기 위해
파드의 이름과 초기화 컨테이너의 이름을 같이 전달한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl logs &lt;pod-name&gt; -c &lt;init-container-2&gt;
</code></pre></div><p>셸 스크립트를 실행하는 초기화 컨테이너는, 초기화 컨테이너가
실행될 때 명령어를 출력한다. 예를 들어, 스크립트의 시작 부분에
<code>set -x</code> 를 추가하고 실행하여 Bash에서 명령어를 출력할 수 있도록 수행할 수 있다.</p>
<h2 id=파드의-상태-이해하기>파드의 상태 이해하기</h2>
<p><code>Init:</code> 으로 시작하는 파드 상태는 초기화 컨테이너의
실행 상태를 요약한다. 아래 표는 초기화 컨테이너를 디버깅하는
동안 사용자가 확인할 수 있는 몇 가지 상태값의 예이다.</p>
<table>
<thead>
<tr>
<th>상태</th>
<th>의미</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Init:N/M</code></td>
<td>파드가 <code>M</code> 개의 초기화 컨테이너를 갖고 있으며, 현재까지 <code>N</code> 개가 완료.</td>
</tr>
<tr>
<td><code>Init:Error</code></td>
<td>초기화 컨테이너 실행 실패.</td>
</tr>
<tr>
<td><code>Init:CrashLoopBackOff</code></td>
<td>초기화 컨테이너가 반복적으로 실행 실패.</td>
</tr>
<tr>
<td><code>Pending</code></td>
<td>파드가 아직 초기화 컨테이너를 실행하지 않음.</td>
</tr>
<tr>
<td><code>PodInitializing</code> or <code>Running</code></td>
<td>파드가 이미 초기화 컨테이너 실행을 완료.</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-47290c80fb8b00accec6729f3da49734>7 - 클러스터 트러블슈팅</h1>
<p>이 문서는 클러스터 트러블슈팅에 대해 설명한다. 사용자가 겪고 있는 문제의 근본 원인으로서 사용자의 애플리케이션을
이미 배제했다고 가정한다.
애플리케이션 디버깅에 대한 팁은 <a href=/docs/tasks/debug-application-cluster/debug-application/>애플리케이션 트러블슈팅 가이드</a>를 참조한다.
자세한 내용은 <a href=/ko/docs/tasks/debug-application-cluster/troubleshooting/>트러블슈팅 문서</a>를 참조한다.</p>
<h2 id=클러스터-나열하기>클러스터 나열하기</h2>
<p>클러스터에서 가장 먼저 디버그해야 할 것은 노드가 모두 올바르게 등록되었는지 여부이다.</p>
<p>다음을 실행한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get nodes
</code></pre></div><p>그리고 보일 것으로 예상되는 모든 노드가 존재하고 모두 <code>Ready</code> 상태인지 확인한다.</p>
<p>클러스터의 전반적인 상태에 대한 자세한 정보를 얻으려면 다음을 실행할 수 있다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl cluster-info dump
</code></pre></div><h2 id=로그-보기>로그 보기</h2>
<p>현재로서는 클러스터를 더 깊이 파고들려면 관련 머신에서 로그 확인이 필요하다. 관련 로그 파일
위치는 다음과 같다. (systemd 기반 시스템에서는 <code>journalctl</code>을 대신 사용해야 할 수도 있다.)</p>
<h3 id=마스터>마스터</h3>
<ul>
<li><code>/var/log/kube-apiserver.log</code> - API 서버, API 제공을 담당</li>
<li><code>/var/log/kube-scheduler.log</code> - 스케줄러, 스케줄 결정을 담당</li>
<li><code>/var/log/kube-controller-manager.log</code> - 레플리케이션 컨트롤러를 담당하는 컨트롤러</li>
</ul>
<h3 id=워커-노드>워커 노드</h3>
<ul>
<li><code>/var/log/kubelet.log</code> - Kubelet, 노드에서 컨테이너 실행을 담당</li>
<li><code>/var/log/kube-proxy.log</code> - Kube Proxy, 서비스 로드밸런싱을 담당</li>
</ul>
<h2 id=클러스터-장애-모드의-일반적인-개요>클러스터 장애 모드의 일반적인 개요</h2>
<p>아래에 일부 오류 상황 예시 및 문제를 완화하기 위해 클러스터 설정을 조정하는 방법을 나열한다.</p>
<h3 id=근본-원인>근본 원인</h3>
<ul>
<li>VM(들) 종료</li>
<li>클러스터 내 또는 클러스터와 사용자 간의 네트워크 분할</li>
<li>쿠버네티스 소프트웨어의 충돌</li>
<li>데이터 손실 또는 퍼시스턴트 스토리지 사용 불가 (e.g. GCE PD 또는 AWS EBS 볼륨)</li>
<li>운영자 오류, 예를 들면 잘못 구성된 쿠버네티스 소프트웨어 또는 애플리케이션 소프트웨어</li>
</ul>
<h3 id=특정-시나리오>특정 시나리오</h3>
<ul>
<li>API 서버 VM 종료 또는 API 서버 충돌
<ul>
<li>다음의 현상을 유발함
<ul>
<li>새로운 파드, 서비스, 레플리케이션 컨트롤러를 중지, 업데이트 또는 시작할 수 없다.</li>
<li>쿠버네티스 API에 의존하지 않는 기존 파드 및 서비스는 계속 정상적으로 작동할 것이다.</li>
</ul>
</li>
</ul>
</li>
<li>API 서버 백업 스토리지 손실
<ul>
<li>다음의 현상을 유발함
<ul>
<li>API 서버가 구동되지 않을 것이다.</li>
<li>kubelet에 도달할 수 없게 되지만, kubelet이 여전히 동일한 파드를 계속 실행하고 동일한 서비스 프록시를 제공할 것이다.</li>
<li>API 서버를 재시작하기 전에, 수동으로 복구하거나 API서버 상태를 재생성해야 한다.</li>
</ul>
</li>
</ul>
</li>
<li>지원 서비스 (노드 컨트롤러, 레플리케이션 컨트롤러 매니저, 스케쥴러 등) VM 종료 또는 충돌
<ul>
<li>현재 그것들은 API 서버와 같은 위치에 있기 때문에 API 서버와 비슷한 상황을 겪을 것이다.</li>
<li>미래에는 이들도 복제본을 가질 것이며 API서버와 별도로 배치될 수도 있다.</li>
<li>지원 서비스들은 상태(persistent state)를 자체적으로 유지하지는 않는다.</li>
</ul>
</li>
<li>개별 노드 (VM 또는 물리적 머신) 종료
<ul>
<li>다음의 현상을 유발함
<ul>
<li>해당 노드의 파드가 실행을 중지</li>
</ul>
</li>
</ul>
</li>
<li>네트워크 분할
<ul>
<li>다음의 현상을 유발함
<ul>
<li>파티션 A는 파티션 B의 노드가 다운되었다고 생각한다. 파티션 B는 API 서버가 다운되었다고 생각한다. (마스터 VM이 파티션 A에 있다고 가정)</li>
</ul>
</li>
</ul>
</li>
<li>Kubelet 소프트웨어 오류
<ul>
<li>다음의 현상을 유발함
<ul>
<li>충돌한 kubelet은 노드에서 새 파드를 시작할 수 없다.</li>
<li>kubelet이 파드를 삭제할 수도 있고 삭제하지 않을 수도 있다.</li>
<li>노드는 비정상으로 표시된다.</li>
<li>레플리케이션 컨트롤러는 다른 곳에서 새 파드를 시작한다.</li>
</ul>
</li>
</ul>
</li>
<li>클러스터 운영자 오류
<ul>
<li>다음의 현상을 유발함
<ul>
<li>파드, 서비스 등의 손실</li>
<li>API 서버 백업 저장소 분실</li>
<li>API를 읽을 수 없는 사용자</li>
<li>기타</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id=완화>완화</h3>
<ul>
<li>
<p>조치: IaaS VM을 위한 IaaS 공급자의 자동 VM 다시 시작 기능을 사용한다.</p>
<ul>
<li>다음을 완화할 수 있음: API 서버 VM 종료 또는 API 서버 충돌</li>
<li>다음을 완화할 수 있음: 지원 서비스 VM 종료 또는 충돌</li>
</ul>
</li>
<li>
<p>조치: API 서버+etcd가 있는 VM에 IaaS 제공자의 안정적인 스토리지(예: GCE PD 또는 AWS EBS 볼륨)를 사용한다.</p>
<ul>
<li>다음을 완화할 수 있음: API 서버 백업 스토리지 손실</li>
</ul>
</li>
<li>
<p>조치: <a href=/docs/setup/production-environment/tools/kubeadm/high-availability/>고가용성</a> 구성을 사용한다.</p>
<ul>
<li>다음을 완화할 수 있음: 컨트롤 플레인 노드 종료 또는 컨트롤 플레인 구성 요소(스케줄러, API 서버, 컨트롤러 매니저) 충돌
<ul>
<li>동시에 발생하는 하나 이상의 노드 또는 구성 요소 오류를 허용한다.</li>
</ul>
</li>
<li>다음을 완화할 수 있음: API 서버 백업 스토리지(i.e., etcd의 데이터 디렉터리) 손실
<ul>
<li>고가용성 etcd 구성을 사용하고 있다고 가정</li>
</ul>
</li>
</ul>
</li>
<li>
<p>조치: API 서버 PD/EBS 볼륨의 주기적인 스냅샷</p>
<ul>
<li>다음을 완화할 수 있음: API 서버 백업 스토리지 손실</li>
<li>다음을 완화할 수 있음: 일부 운영자 오류 사례</li>
<li>다음을 완화할 수 있음: 일부 쿠버네티스 소프트웨어 오류 사례</li>
</ul>
</li>
<li>
<p>조치: 파드 앞에 레플리케이션 컨트롤러와 서비스 사용</p>
<ul>
<li>다음을 완화할 수 있음: 노드 종료</li>
<li>다음을 완화할 수 있음: Kubelet 소프트웨어 오류</li>
</ul>
</li>
<li>
<p>조치: 예기치 않은 재시작을 허용하도록 설계된 애플리케이션(컨테이너)</p>
<ul>
<li>다음을 완화할 수 있음: 노드 종료</li>
<li>다음을 완화할 수 있음: Kubelet 소프트웨어 오류</li>
</ul>
</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-434e0133d71583a27478b10fc1d3d105>8 - 트러블슈팅하기</h1>
<p>때때로 문제가 발생할 수 있다. 이 가이드는 이러한 상황을 해결하기 위해 작성되었다. 문제 해결에는
다음 두 가지를 참고해 볼 수 있다.</p>
<ul>
<li><a href=/docs/tasks/debug-application-cluster/debug-application/>애플리케이션 트러블슈팅하기</a> - 쿠버네티스에
코드를 배포하였지만 제대로 동작하지 않는 사용자들에게 유용한 가이드이다.</li>
<li><a href=/ko/docs/tasks/debug-application-cluster/debug-cluster/>클러스터 트러블슈팅하기</a> - 쿠버네티스 클러스터에
문제를 겪고 있는 클러스터 관리자 혹은 기분이 나쁜 사람들에게 유용한 가이드이다.</li>
</ul>
<p>여러분이 현재 사용중인 릴리스에 대한 알려진 이슈들을 다음의 <a href=https://github.com/kubernetes/kubernetes/releases>릴리스</a>
페이지에서 확인해 볼 수도 있다.</p>
<h2 id=도움-받기>도움 받기</h2>
<p>여러분의 문제가 위에 소개된 어떠한 가이드로도 해결할 수 없다면,
쿠버네티스 커뮤니티로부터 도움을 받을 수 있는 다양한 방법들을 시도해 볼 수 있다.</p>
<h3 id=질문>질문</h3>
<p>이 사이트의 문서들은 다양한 질문들에 대한 답변을 제공할 수 있도록 구성되어 있다.
<a href=/ko/docs/concepts/>개념</a>은 쿠버네티스의 아키텍처와 각 컴포넌트들이 어떻게 동작하는지에 대해 설명하고,
<a href=/ko/docs/setup/>시작하기</a>는 쿠버네티스를 시작하는 데 유용한 지침들을 제공한다.
<a href=/ko/docs/tasks/>태스크</a>는 흔히 사용되는 작업들을 수행하는 방법에 대해 소개하고,
<a href=/ko/docs/tutorials/>튜토리얼</a>은 실무, 산업 특화 혹은 종단간 개발에 특화된 시나리오를 통해 차근차근 설명한다.
<a href=/ko/docs/reference/>레퍼런스</a> 섹션에서는
<a href=/docs/reference/generated/kubernetes-api/v1.23/>쿠버네티스 API</a>와
<a href=/ko/docs/reference/kubectl/overview/><code>kubectl</code></a>과 같은 커맨드 라인 인터페이스(CLI)에 대한
상세한 설명을 다룬다.</p>
<h2 id=도와주세요-내-질문이-다뤄지지-않았어요-도움이-필요해요>도와주세요! 내 질문이 다뤄지지 않았어요! 도움이 필요해요!</h2>
<h3 id=스택-오버플로우>스택 오버플로우</h3>
<p>여러분들이 겪고 있는 문제와 동일한 문제에 대한 도움을 위해 커뮤니티의 다른 사람들이 이미
질문을 올렸을 수 있다. 쿠버네티스 팀은
<a href=https://stackoverflow.com/questions/tagged/kubernetes>쿠버네티스 태그가 등록된 글</a>들을 모니터링하고 있다.
발생한 문제와 도움이 되는 질문이 없다면,
<a href="https://stackoverflow.com/questions/ask?tags=kubernetes">새로운 질문</a>을 올려라!</p>
<h3 id=슬랙>슬랙</h3>
<p>쿠버네티스 슬랙의 <code>#kubernetes-users</code> 채널을 통해 쿠버네티스 커뮤니티의 여러 사람들을 접할 수도 있다.
쿠버네티스 슬랙을 사용하기 위해서는 등록이 필요한데, 다음을 통해 <a href=https://slack.kubernetes.io>채널 초대 요청</a>을 할 수 있다.
(누구나 가입할 수 있다). 슬랙 채널은 여러분이 어떠한 질문을 할 수 있도록 언제나 열려있다.
가입하고 나면 여러분의 웹 브라우저나 슬랙 앱을 통해 <a href=https://kubernetes.slack.com>쿠버네티스 슬랙</a>
에 참여할 수 있다.</p>
<p>쿠버네티스 슬랙에 참여하게 된다면, 다양한 주제의 흥미와 관련된 여러 채널들에 대해
살펴본다. 가령, 쿠버네티스를 처음 접하는 사람이라면
<a href=https://kubernetes.slack.com/messages/kubernetes-novice><code>#kubernetes-novice</code></a> 채널에 가입할 수 있다. 혹은, 만약 당신이 개발자라면
<a href=https://kubernetes.slack.com/messages/kubernetes-dev><code>#kubernetes-dev</code></a> 채널에 가입할 수 있다.</p>
<p>또한 각 국가 및 사용 언어별 채널들이 여럿 존재한다. 사용하는 언어로 도움을 받거나 정보를
얻기 위해서는 다음의 채널에 참가한다.</p>
<table><caption style=display:none>국가 / 언어별 슬랙 채널</caption>
<thead>
<tr>
<th style=text-align:left>국가</th>
<th style=text-align:left>채널</th>
</tr>
</thead>
<tbody>
<tr>
<td style=text-align:left>China(중국)</td>
<td style=text-align:left><a href=https://kubernetes.slack.com/messages/cn-users><code>#cn-users</code></a>, <a href=https://kubernetes.slack.com/messages/cn-events><code>#cn-events</code></a></td>
</tr>
<tr>
<td style=text-align:left>Finland(핀란드)</td>
<td style=text-align:left><a href=https://kubernetes.slack.com/messages/fi-users><code>#fi-users</code></a></td>
</tr>
<tr>
<td style=text-align:left>France(프랑스)</td>
<td style=text-align:left><a href=https://kubernetes.slack.com/messages/fr-users><code>#fr-users</code></a>, <a href=https://kubernetes.slack.com/messages/fr-events><code>#fr-events</code></a></td>
</tr>
<tr>
<td style=text-align:left>Germany(독일)</td>
<td style=text-align:left><a href=https://kubernetes.slack.com/messages/de-users><code>#de-users</code></a>, <a href=https://kubernetes.slack.com/messages/de-events><code>#de-events</code></a></td>
</tr>
<tr>
<td style=text-align:left>India(인도)</td>
<td style=text-align:left><a href=https://kubernetes.slack.com/messages/in-users><code>#in-users</code></a>, <a href=https://kubernetes.slack.com/messages/in-events><code>#in-events</code></a></td>
</tr>
<tr>
<td style=text-align:left>Italy(이탈리아)</td>
<td style=text-align:left><a href=https://kubernetes.slack.com/messages/it-users><code>#it-users</code></a>, <a href=https://kubernetes.slack.com/messages/it-events><code>#it-events</code></a></td>
</tr>
<tr>
<td style=text-align:left>Japan(일본)</td>
<td style=text-align:left><a href=https://kubernetes.slack.com/messages/jp-users><code>#jp-users</code></a>, <a href=https://kubernetes.slack.com/messages/jp-events><code>#jp-events</code></a></td>
</tr>
<tr>
<td style=text-align:left>Korea(한국)</td>
<td style=text-align:left><a href=https://kubernetes.slack.com/messages/kr-users><code>#kr-users</code></a></td>
</tr>
<tr>
<td style=text-align:left>Netherlands(네덜란드)</td>
<td style=text-align:left><a href=https://kubernetes.slack.com/messages/nl-users><code>#nl-users</code></a></td>
</tr>
<tr>
<td style=text-align:left>Norway(노르웨이)</td>
<td style=text-align:left><a href=https://kubernetes.slack.com/messages/norw-users><code>#norw-users</code></a></td>
</tr>
<tr>
<td style=text-align:left>Poland(폴란드)</td>
<td style=text-align:left><a href=https://kubernetes.slack.com/messages/pl-users><code>#pl-users</code></a></td>
</tr>
<tr>
<td style=text-align:left>Russia(러시아)</td>
<td style=text-align:left><a href=https://kubernetes.slack.com/messages/ru-users><code>#ru-users</code></a></td>
</tr>
<tr>
<td style=text-align:left>Spain(스페인)</td>
<td style=text-align:left><a href=https://kubernetes.slack.com/messages/es-users><code>#es-users</code></a></td>
</tr>
<tr>
<td style=text-align:left>Sweden(스웨덴)</td>
<td style=text-align:left><a href=https://kubernetes.slack.com/messages/se-users><code>#se-users</code></a></td>
</tr>
<tr>
<td style=text-align:left>Turkey(터키)</td>
<td style=text-align:left><a href=https://kubernetes.slack.com/messages/tr-users><code>#tr-users</code></a>, <a href=https://kubernetes.slack.com/messages/tr-events><code>#tr-events</code></a></td>
</tr>
</tbody>
</table>
<h3 id=포럼>포럼</h3>
<p>공식 쿠버네티스 포럼에 참여하는 것도 추천되는 방법이다. <a href=https://discuss.kubernetes.io>discuss.kubernetes.io</a>.</p>
<h3 id=버그와-기능-추가-요청>버그와 기능 추가 요청</h3>
<p>만약 여러분이 버그처럼 보이는 것을 발견했거나, 기능 추가 요청을 하기 위해서는
<a href=https://github.com/kubernetes/kubernetes/issues>GitHub 이슈 트래킹 시스템</a>을 사용한다.</p>
<p>이슈를 작성하기 전에는, 여러분의 이슈가 기존 이슈에서 이미
다뤄졌는지 검색해 본다.</p>
<p>버그를 보고하는 경우에는, 해당 문제를 어떻게 재현할 수 있는지에 관련된 상세한 정보를 포함한다.
포함되어야 하는 정보들은 다음과 같다.</p>
<ul>
<li>쿠버네티스 버전: <code>kubectl version</code></li>
<li>클라우드 프로바이더, OS 배포판, 네트워크 구성, 및 도커 버전</li>
<li>문제를 재현하기 위한 절차</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-ef360b1f8e65236251826db478cfcab3>9 - 파드 실패의 원인 검증하기</h1>
<p>이 페이지는 컨테이너 종료 메시지를 읽고 쓰는
방법을 보여준다.</p>
<p>종료 메시지는 컨테이너가 치명적인 이벤트에 대한 정보를,
대시보드나 모니터링 소프트웨어 도구와 같이
쉽게 조회 및 표시할 수 있는 위치에
기록하는 방법을 제공한다.
대부분의 경우에 종료 메시지에 넣는 정보는
일반
<a href=/ko/docs/concepts/cluster-administration/logging/>쿠버네티스 로그</a>에도 쓰여져야 한다.</p>
<h2 id=시작하기-전에>시작하기 전에</h2>
<p><p>쿠버네티스 클러스터가 필요하고, kubectl 커맨드-라인 툴이 클러스터와
통신할 수 있도록 설정되어 있어야 한다. 이 튜토리얼은 컨트롤 플레인 호스트가 아닌 노드가 적어도 2개 포함된 클러스터에서 실행하는 것을 추천한다. 만약, 아직 클러스터를 가지고
있지 않다면,
<a href=/ko/docs/tasks/tools/#minikube>minikube</a>를 사용해서 생성하거나
다음의 쿠버네티스 플레이그라운드 중 하나를 사용할 수 있다.</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=https://labs.play-with-k8s.com/>Play with Kubernetes</a></li>
</ul>
버전 확인을 위해서, 다음 커맨드를 실행 <code>kubectl version</code>.
</p>
<h2 id=종료-메시지-읽기-및-쓰기>종료 메시지 읽기 및 쓰기</h2>
<p>이 예제에서는, 하나의 컨테이너를 실행하는 파드를 생성한다.
하단의 설정 파일은 컨테이너가 시작될 때 수행하는
명령어를 지정한다.</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/ko/examples/debug/termination.yaml download=debug/termination.yaml><code>debug/termination.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('debug-termination-yaml')" title="Copy debug/termination.yaml to clipboard">
</img>
</div>
<div class=includecode id=debug-termination-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>termination-demo<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>termination-demo-container<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>debian<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;/bin/sh&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;-c&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;sleep 10 &amp;&amp; echo Sleep expired &gt; /dev/termination-log&#34;</span>]<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<ol>
<li>
<p>다음의 YAML 설정 파일에 기반한 파드를 생성한다.</p>
<pre><code> kubectl apply -f https://k8s.io/examples/debug/termination.yaml

YAML 파일에 있는 `command` 와 `args` 필드에서 컨테이너가 10초 간 잠든 뒤에
&quot;Sleep expired&quot; 문자열을 `/dev/termination-log` 파일에 기록하는
것을 확인할 수 있다. 컨테이너는 &quot;Sleep expired&quot; 메시지를
기록한 후에 종료된다.
</code></pre>
</li>
<li>
<p>파드와 관련된 정보를 출력한다.</p>
<pre><code> kubectl get pod termination-demo

파드가 더 이상 실행되지 않을 때까지 앞선 명령어를 반복한다.
</code></pre>
</li>
<li>
<p>파드에 관한 상세 정보를 출력한다.</p>
<pre><code> kubectl get pod termination-demo --output=yaml

결과는 &quot;Sleep expired&quot; 메시지를 포함한다.

 apiVersion: v1
 kind: Pod
 ...
     lastState:
       terminated:
         containerID: ...
         exitCode: 0
         finishedAt: ...
         message: |
           Sleep expired
         ...
</code></pre>
</li>
<li>
<p>종료 메시지만을 포함하는 출력 결과를 보기
위해서는 Go 템플릿을 사용한다.</p>
<pre><code> kubectl get pod termination-demo -o go-template=&quot;{{range .status.containerStatuses}}{{.lastState.terminated.message}}{{end}}&quot;
</code></pre>
</li>
</ol>
<h2 id=종료-메시지-사용자-정의하기>종료 메시지 사용자 정의하기</h2>
<p>쿠버네티스는 컨테이너의 <code>terminationMessagePath</code> 필드에 지정된
종료 메시지 파일에서 종료 메시지를 검색하며, 이 필드의 기본값은
<code>/dev/termination-log</code> 이다. 이 필드를 사용자 정의 함으로써
쿠버네티스가 종료 메시지를 검색할 때 다른 파일을 사용하도록 조정할 수 있다.
쿠버네티스는 지정된 파일의 내용을 사용하여 컨테이너의 성공 및 실패에 대한 상태 메시지를 채운다.</p>
<p>종료 메시지는 assertion failure 메세지처럼 간결한 최종 상태로 생성된다.
kubelet은 4096 바이트보다 긴 메시지를 자른다. 모든 컨테이너의 총 메시지 길이는
12KiB로 제한된다. 기본 종료 메시지 경로는 <code>/dev/termination-log</code>이다.
파드가 시작된 후에는 종료 메시지 경로를 설정할 수 없다.</p>
<p>다음의 예제에서 컨테이너는, 쿠버네티스가 조회할 수 있도록
<code>/tmp/my-log</code> 파일에 종료 메시지를 기록한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>msg-path-demo<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>msg-path-demo-container<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>debian<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>terminationMessagePath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/tmp/my-log&#34;</span><span style=color:#bbb>
</span></code></pre></div><p>또한 사용자는 추가적인 사용자 정의를 위해 컨테이너의 <code>terminationMessagePolicy</code>
필드를 설정할 수 있다. 이 필드의 기본 값은 <code>File</code> 이며,
이는 오직 종료 메시지 파일에서만 종료 메시지가 조회되는 것을 의미한다.
<code>terminationMessagePolicy</code> 필드의 값을 "<code>FallbackToLogsOnError</code> 으로
설정함으로써, 종료 메시지 파일이 비어 있고 컨테이너가 오류와 함께 종료 되었을 경우
쿠버네티스가 컨테이너 로그 출력의 마지막 청크를 사용하도록 지시할 수 있다.
로그 출력은 2048 바이트나 80 행 중 더 작은 값으로 제한된다.</p>
<h2 id=다음-내용>다음 내용</h2>
<ul>
<li><a href=/docs/reference/generated/kubernetes-api/v1.23/#container-v1-core>컨테이너</a>
에 있는 <code>terminationMessagePath</code> 에 대해 읽어보기.</li>
<li><a href=/ko/docs/concepts/cluster-administration/logging/>로그 검색</a>에 대해 배워보기.</li>
<li><a href=https://golang.org/pkg/text/template/>Go 템플릿</a>에 대해 배워보기.</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-858517cd46a1b5a1fd2e650edd785cea>10 - 파드와 레플리케이션컨트롤러(ReplicationController) 디버그하기</h1>
<p>이 페이지에서는 파드와 레플리케이션컨트롤러를 디버깅하는 방법을 소개한다.</p>
<h2 id=시작하기-전에>시작하기 전에</h2>
<p><p>쿠버네티스 클러스터가 필요하고, kubectl 커맨드-라인 툴이 클러스터와
통신할 수 있도록 설정되어 있어야 한다. 이 튜토리얼은 컨트롤 플레인 호스트가 아닌 노드가 적어도 2개 포함된 클러스터에서 실행하는 것을 추천한다. 만약, 아직 클러스터를 가지고
있지 않다면,
<a href=/ko/docs/tasks/tools/#minikube>minikube</a>를 사용해서 생성하거나
다음의 쿠버네티스 플레이그라운드 중 하나를 사용할 수 있다.</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=https://labs.play-with-k8s.com/>Play with Kubernetes</a></li>
</ul>
버전 확인을 위해서, 다음 커맨드를 실행 <code>kubectl version</code>.
</p>
<ul>
<li>사용자는
<a class=glossary-tooltip title="파드는 클러스터에서 실행 중인 컨테이너의 집합을 나타낸다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/pods/ target=_blank aria-label=파드>파드</a> 기본 사항과 파드의<br>
<a href=/ko/docs/concepts/workloads/pods/pod-lifecycle/>라이프사이클</a>에 대해 잘 알고 있어야 한다.</li>
</ul>
<h2 id=파드-디버깅>파드 디버깅</h2>
<p>파드 디버깅의 첫 번째 단계는 파드를 살펴 보는 것이다. 다음의 명령어를
사용하여 파드의 현재 상태와 최근 이벤트를 점검한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe pods <span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>POD_NAME</span><span style=color:#b68;font-weight:700>}</span>
</code></pre></div><p>파드 내부 컨테이너의 상태를 확인한다. 모두 <code>Running</code> 상태인가?
최근에 재시작 되었는가?</p>
<p>파드의 상태에 따라 디버깅을 계속한다.</p>
<h3 id=파드가-pending-상태로-유지>파드가 pending 상태로 유지</h3>
<p>파드가 <code>Pending</code> 상태로 멈춰 있는 경우는, 노드에 스케줄 될 수 없음을 의미한다.
일반적으로 이것은 어떤 유형의 리소스가 부족하거나 스케줄링을 방해하는 다른 요인 때문이다.
상단의 <code>kubectl describe ...</code> 명령의 결과를 확인하자.
파드를 스케줄 할 수 없는 이유에 대한 스케줄러의 메세지가 있어야 한다.
이유는 다음과 같다.</p>
<h4 id=부족한-리소스>부족한 리소스</h4>
<p>사용자 클러스터의 CPU 나 Memory의 공급이 소진되었을 수 있다. 이 경우
몇 가지 방법을 시도할 수 있다.</p>
<ul>
<li>
<p>클러스터에 노드를 더 추가하기.</p>
</li>
<li>
<p>pending 상태인 파드를 위한 공간을 확보하기 위해
<a href=/ko/docs/concepts/workloads/pods/pod-lifecycle/#pod-termination>불필요한 파드 종료하기</a></p>
</li>
<li>
<p>파드가 노드보다 크지 않은지 확인한다. 예를 들어 모든
노드가 <code>cpu:1</code> 의 용량을 가지고 있을 경우, <code>cpu: 1.1</code> 을 요청하는 파드는
절대 스케줄 될 수 없다.</p>
<p>사용자는 <code>kubectl get nodes -o &lt;format></code> 명령으로 노드의
용량을 점검할 수 있다. 다음은 필요한 정보를 추출하는 몇 가지
명령의 예이다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get nodes -o yaml | egrep <span style=color:#b44>&#39;\sname:|cpu:|memory:&#39;</span>
kubectl get nodes -o json | jq <span style=color:#b44>&#39;.items[] | {name: .metadata.name, cap: .status.capacity}&#39;</span>
</code></pre></div><p><a href=/ko/docs/concepts/policy/resource-quotas/>리소스 쿼터</a>
기능은 사용할 수 있는 전체 리소스의 양을 제한하도록 설정할 수 있다.
네임스페이스와 함께 사용하면,
한 팀이 모든 리소스를 점유하는 것을 방지할 수 있다.</p>
</li>
</ul>
<h4 id=hostport-사용하기>hostPort 사용하기</h4>
<p>파드를 <code>hostPort</code> 에 바인딩 할 때 파드를 스케줄링 할 수 있는
위치는 제한되어 있다. 대부분의 경우 <code>hostPort</code> 는 불필요하다. 서비스 오브젝트를
사용하여 파드를 노출하도록 한다. <code>hostPort</code> 가 필요한 경우
컨테이너 클러스터에 있는 노드의 수만큼 파드를 스케줄 할 수 있다.</p>
<h3 id=파드가-waiting-상태로-유지>파드가 waiting 상태로 유지</h3>
<p>파드가 <code>Waiting</code> 상태에서 멈춘 경우, 워커 노드에 스케줄 되었지만, 해당 장비에서 사용할 수 없다.
거듭 강조하지만, <code>kubectl describe ...</code> 의 정보는 유익하게 사용되어야 한다.
<code>Waiting</code> 파드의 가장 일반적인 원인은 이미지를 가져오지 못하는 경우이다.
확인해야 할 3가지 사항이 있다.</p>
<ul>
<li>이미지 이름이 올바른지 확인한다.</li>
<li>이미지를 저장소에 푸시하였는가?</li>
<li>이미지가 풀 될 수 있는지 보기 위해, 사용자의 장비에서 <code>docker pull &lt;image></code> 를 수동으로
실행한다.</li>
</ul>
<h3 id=파드가-손상-crashing-되었거나-양호하지-않을-unhealthy-경우>파드가 손상(crashing)되었거나 양호하지 않을(unhealthy) 경우</h3>
<p>일단 사용자의 파드가 스케줄 되면, <a href=/ko/docs/tasks/debug-application-cluster/debug-running-pod/>구동중인 파드 디버그하기</a>에
기술된 메서드를 디버깅에 사용할 수 있다.</p>
<h2 id=레플리케이션컨트롤러-디버깅>레플리케이션컨트롤러 디버깅</h2>
<p>레플리케이션컨트롤러는 매우 간단하다. 이 오브젝트는 파드를 만들거나
만들 수 없는 경우뿐이다. 만약 파드를 만들 수 없는 경우,
<a href=#%ED%8C%8C%EB%93%9C-%EB%94%94%EB%B2%84%EA%B9%85>위의 지침</a>을 참조하여 파드를 디버그한다.</p>
<p>사용자는 <code>kubectl describe rc ${CONTROLLER_NAME}</code> 을 사용하여 레플리케이션 컨트롤러와
관련된 이벤트를 검사할 수도 있다.</p>
</div>
</main>
</div>
</div>
<footer class=d-print-none>
<div class=footer__links>
<nav>
<a class=text-white href=/ko/docs/home/>홈</a>
<a class=text-white href=/ko/blog/>블로그</a>
<a class=text-white href=/ko/training/>교육</a>
<a class=text-white href=/ko/partners/>파트너</a>
<a class=text-white href=/ko/community/>커뮤니티</a>
<a class=text-white href=/ko/case-studies/>사례 연구</a>
</nav>
</div>
<div class=container-fluid>
<div class=row>
<div class="col-6 col-sm-2 text-xs-center order-sm-2">
<ul class="list-inline mb-0">
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="User mailing list" aria-label="User mailing list">
<a class=text-white target=_blank href=https://discuss.kubernetes.io>
<i class="fa fa-envelope"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Twitter aria-label=Twitter>
<a class=text-white target=_blank href=https://twitter.com/kubernetesio>
<i class="fab fa-twitter"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Calendar aria-label=Calendar>
<a class=text-white target=_blank href="https://calendar.google.com/calendar/embed?src=calendar%40kubernetes.io">
<i class="fas fa-calendar-alt"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Youtube aria-label=Youtube>
<a class=text-white target=_blank href=https://youtube.com/kubernetescommunity>
<i class="fab fa-youtube"></i>
</a>
</li>
</ul>
</div>
<div class="col-6 col-sm-2 text-right text-xs-center order-sm-3">
<ul class="list-inline mb-0">
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub>
<a class=text-white target=_blank href=https://github.com/kubernetes/kubernetes>
<i class="fab fa-github"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Slack aria-label=Slack>
<a class=text-white target=_blank href=https://slack.k8s.io>
<i class="fab fa-slack"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Contribute aria-label=Contribute>
<a class=text-white target=_blank href=https://git.k8s.io/community/contributors/guide>
<i class="fas fa-edit"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Stack Overflow" aria-label="Stack Overflow">
<a class=text-white target=_blank href=https://stackoverflow.com/questions/tagged/kubernetes>
<i class="fab fa-stack-overflow"></i>
</a>
</li>
</ul>
</div>
<div class="col-12 col-sm-8 text-center order-sm-2">
<small class=text-white>&copy; 2023 The Kubernetes Authors | Documentation Distributed under <a href=https://git.k8s.io/website/LICENSE class=light-text>CC BY 4.0</a></small>
<br>
<small class=text-white>Copyright &copy; 2023 The Linux Foundation &reg;. All rights reserved. The Linux Foundation has registered trademarks and uses trademarks. For a list of trademarks of The Linux Foundation, please see our <a href=https://www.linuxfoundation.org/trademark-usage class=light-text>Trademark Usage page</a></small>
<br>
<small class=text-white>ICP license: 京ICP备17074266号-3</small>
</div>
</div>
</div>
</footer>
</div>
<script src=/js/popper-1.14.3.min.js integrity=sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49 crossorigin=anonymous></script>
<script src=/js/bootstrap-4.3.1.min.js integrity=sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM crossorigin=anonymous></script>
<script src=/js/main.min.40616251a9b6e4b689e7769be0340661efa4d7ebb73f957404e963e135b4ed52.js integrity="sha256-QGFiUam25LaJ53ab4DQGYe+k1+u3P5V0BOlj4TW07VI=" crossorigin=anonymous></script>
</body>
</html>