<!doctype html><html lang=ko class=no-js>
<head>
<meta name=ROBOTS content="NOINDEX, NOFOLLOW">
<script async src="https://www.googletagmanager.com/gtag/js?id=G-JPP6RFM2BP"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-JPP6RFM2BP')</script>
<link rel=alternate hreflang=en href=https://kubernetes.io/docs/setup/>
<link rel=alternate hreflang=zh href=https://kubernetes.io/zh/docs/setup/>
<link rel=alternate hreflang=ja href=https://kubernetes.io/ja/docs/setup/>
<link rel=alternate hreflang=fr href=https://kubernetes.io/fr/docs/setup/>
<link rel=alternate hreflang=de href=https://kubernetes.io/de/docs/setup/>
<link rel=alternate hreflang=pt-br href=https://kubernetes.io/pt-br/docs/setup/>
<link rel=alternate hreflang=es href=https://kubernetes.io/es/docs/setup/>
<link rel=alternate hreflang=id href=https://kubernetes.io/id/docs/setup/>
<link rel=alternate hreflang=ru href=https://kubernetes.io/ru/docs/setup/>
<link rel=alternate hreflang=pl href=https://kubernetes.io/pl/docs/setup/>
<link rel=alternate hreflang=uk href=https://kubernetes.io/uk/docs/setup/>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=generator content="Hugo 0.87.0">
<link rel=canonical type=text/html href=https://kubernetes.io/ko/docs/setup/>
<link rel="shortcut icon" type=image/png href=/images/favicon.png>
<link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180>
<link rel=manifest href=/manifest.webmanifest>
<link rel=apple-touch-icon href=/images/kubernetes-192x192.png>
<title>시작하기 | Kubernetes</title><meta property="og:title" content="시작하기">
<meta property="og:description" content="운영 수준의 컨테이너 오케스트레이션">
<meta property="og:type" content="website">
<meta property="og:url" content="https://kubernetes.io/ko/docs/setup/"><meta property="og:site_name" content="Kubernetes">
<meta itemprop=name content="시작하기">
<meta itemprop=description content="운영 수준의 컨테이너 오케스트레이션"><meta name=twitter:card content="summary">
<meta name=twitter:title content="시작하기">
<meta name=twitter:description content="운영 수준의 컨테이너 오케스트레이션">
<link href=/scss/main.css rel=stylesheet>
<script src=/js/jquery-3.3.1.min.js integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin=anonymous></script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","url":"https://kubernetes.io","logo":"https://kubernetes.io/images/favicon.png"}</script>
<meta name=theme-color content="#326ce5">
<link rel=stylesheet href=/css/feature-states.css>
<meta name=description content="본 섹션에는 쿠버네티스를 설정하고 실행하는 다양한 방법이 나열되어 있다. 쿠버네티스를 설치할 때는 유지보수의 용이성, 보안, 제어, 사용 가능한 리소스, 그리고 클러스터를 운영하고 관리하기 위해 필요한 전문성을 기반으로 설치 유형을 선택한다.
쿠버네티스를 다운로드하여 로컬 머신에, 클라우드에, 데이터센터에 쿠버네티스 클러스터를 구축할 수 있다.
쿠버네티스 클러스터를 직접 관리하고 싶지 않다면, 인증된 플랫폼과 같은 매니지드 서비스를 선택할 수도 있다. 광범위한 클라우드 또는 베어 메탈 환경에 걸쳐 사용할 수 있는 표준화된/맞춤형 솔루션도 있다.
학습 환경 쿠버네티스를 배우고 있다면, 쿠버네티스 커뮤니티에서 지원하는 도구나, 로컬 머신에서 쿠버네티스를 설치하기 위한 생태계 내의 도구를 사용한다.">
<meta property="og:description" content="본 섹션에는 쿠버네티스를 설정하고 실행하는 다양한 방법이 나열되어 있다. 쿠버네티스를 설치할 때는 유지보수의 용이성, 보안, 제어, 사용 가능한 리소스, 그리고 클러스터를 운영하고 관리하기 위해 필요한 전문성을 기반으로 설치 유형을 선택한다.
쿠버네티스를 다운로드하여 로컬 머신에, 클라우드에, 데이터센터에 쿠버네티스 클러스터를 구축할 수 있다.
쿠버네티스 클러스터를 직접 관리하고 싶지 않다면, 인증된 플랫폼과 같은 매니지드 서비스를 선택할 수도 있다. 광범위한 클라우드 또는 베어 메탈 환경에 걸쳐 사용할 수 있는 표준화된/맞춤형 솔루션도 있다.
학습 환경 쿠버네티스를 배우고 있다면, 쿠버네티스 커뮤니티에서 지원하는 도구나, 로컬 머신에서 쿠버네티스를 설치하기 위한 생태계 내의 도구를 사용한다.">
<meta name=twitter:description content="본 섹션에는 쿠버네티스를 설정하고 실행하는 다양한 방법이 나열되어 있다. 쿠버네티스를 설치할 때는 유지보수의 용이성, 보안, 제어, 사용 가능한 리소스, 그리고 클러스터를 운영하고 관리하기 위해 필요한 전문성을 기반으로 설치 유형을 선택한다.
쿠버네티스를 다운로드하여 로컬 머신에, 클라우드에, 데이터센터에 쿠버네티스 클러스터를 구축할 수 있다.
쿠버네티스 클러스터를 직접 관리하고 싶지 않다면, 인증된 플랫폼과 같은 매니지드 서비스를 선택할 수도 있다. 광범위한 클라우드 또는 베어 메탈 환경에 걸쳐 사용할 수 있는 표준화된/맞춤형 솔루션도 있다.
학습 환경 쿠버네티스를 배우고 있다면, 쿠버네티스 커뮤니티에서 지원하는 도구나, 로컬 머신에서 쿠버네티스를 설치하기 위한 생태계 내의 도구를 사용한다.">
<meta property="og:url" content="https://kubernetes.io/ko/docs/setup/">
<meta property="og:title" content="시작하기">
<meta name=twitter:title content="시작하기">
<meta name=twitter:image content="https://kubernetes.io/images/favicon.png">
<meta name=twitter:image:alt content="Kubernetes">
<meta property="og:image" content="/images/kubernetes-horizontal-color.png">
<meta property="og:type" content="article">
<script src=/js/script.js></script>
</head>
<body class=td-section>
<header>
<nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar" data-auto-burger=primary>
<a class=navbar-brand href=/ko/></a>
<div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar>
<ul class="navbar-nav mt-2 mt-lg-0">
<li class="nav-item mr-2 mb-lg-0">
<a class="nav-link active" href=/ko/docs/>문서</a>
</li>
<li class="nav-item mr-2 mb-lg-0">
<a class=nav-link href=/ko/blog/>쿠버네티스 블로그</a>
</li>
<li class="nav-item mr-2 mb-lg-0">
<a class=nav-link href=/ko/training/>교육</a>
</li>
<li class="nav-item mr-2 mb-lg-0">
<a class=nav-link href=/ko/partners/>파트너</a>
</li>
<li class="nav-item mr-2 mb-lg-0">
<a class=nav-link href=/ko/community/>커뮤니티</a>
</li>
<li class="nav-item mr-2 mb-lg-0">
<a class=nav-link href=/ko/case-studies/>사례 연구</a>
</li>
<li class="nav-item dropdown">
<a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>
버전
</a>
<div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink>
<a class=dropdown-item href=/releases>Release Information</a>
<a class=dropdown-item href=https://kubernetes.io/ko/docs/setup/>v1.27</a>
<a class=dropdown-item href=https://v1-26.docs.kubernetes.io/ko/docs/setup/>v1.26</a>
<a class=dropdown-item href=https://v1-25.docs.kubernetes.io/ko/docs/setup/>v1.25</a>
<a class=dropdown-item href=https://v1-24.docs.kubernetes.io/ko/docs/setup/>v1.24</a>
<a class=dropdown-item href=https://v1-23.docs.kubernetes.io/ko/docs/setup/>v1.23</a>
</div>
</li>
<li class="nav-item dropdown">
<a class="nav-link dropdown-toggle" href=# id=navbarDropdownMenuLink role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>
한국어 Korean
</a>
<div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink>
<a class=dropdown-item href=/docs/setup/>English</a>
<a class=dropdown-item href=/zh/docs/setup/>中文 Chinese</a>
<a class=dropdown-item href=/ja/docs/setup/>日本語 Japanese</a>
<a class=dropdown-item href=/fr/docs/setup/>Français</a>
<a class=dropdown-item href=/de/docs/setup/>Deutsch</a>
<a class=dropdown-item href=/pt-br/docs/setup/>Português</a>
<a class=dropdown-item href=/es/docs/setup/>Español</a>
<a class=dropdown-item href=/id/docs/setup/>Bahasa Indonesia</a>
<a class=dropdown-item href=/ru/docs/setup/>Русский</a>
<a class=dropdown-item href=/pl/docs/setup/>Polski</a>
<a class=dropdown-item href=/uk/docs/setup/>Українська</a>
</div>
</li>
</ul>
</div>
<button id=hamburger onclick=kub.toggleMenu() data-auto-burger-exclude><div></div></button>
</nav>
</header>
<div class="container-fluid td-outer">
<div class=td-main>
<div class="row flex-xl-nowrap">
<main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main>
<div class=td-content>
<div class="pageinfo pageinfo-primary d-print-none">
<p>
이 섹션의 다중 페이지 출력 화면임.
<a href=# onclick="return print(),!1">여기를 클릭하여 프린트</a>.
</p><p>
<a href=/ko/docs/setup/>이 페이지의 일반 화면으로 돌아가기</a>.
</p>
</div>
<h1 class=title>시작하기</h1>
<ul>
<li>1: <a href=#pg-0b597086a9d1382f86abadcfeab657d6>학습 환경</a></li>
<ul>
</ul>
<li>2: <a href=#pg-4e14853fdaa3bd273f31a60112b9b5ac>프로덕션 환경</a></li>
<ul>
<li>2.1: <a href=#pg-a77d3feb6e6d9978f32fa14622642e9a>컨테이너 런타임</a></li>
<li>2.2: <a href=#pg-00e1646f68aeb89f9722cf6f6cfcad94>배포 도구로 쿠버네티스 설치하기</a></li>
<ul>
<li>2.2.1: <a href=#pg-a16f59f325a17cdeed324d5c889f7f73>kubeadm으로 클러스터 구성하기</a></li>
<ul>
<li>2.2.1.1: <a href=#pg-29e59491dd6118b23072dfe9ebb93323>kubeadm 설치하기</a></li>
<li>2.2.1.2: <a href=#pg-4c656c5eda3e1c06ad1aedebdc04a211>kubeadm API로 컴포넌트 사용자 정의하기</a></li>
<li>2.2.1.3: <a href=#pg-015edbc7cc688d31b1d1edce7c186135>고가용성 토폴로지 선택</a></li>
</ul>
<li>2.2.2: <a href=#pg-478acca1934b6d89a0bc00fb25bfe5b6>Kops로 쿠버네티스 설치하기</a></li>
<li>2.2.3: <a href=#pg-f8b4964187fe973644e06ee629eff1de>Kubespray로 쿠버네티스 설치하기</a></li>
</ul>
<li>2.3: <a href=#pg-d2f55eefe7222b7c637875af9c3ec199>턴키 클라우드 솔루션</a></li>
<li>2.4: <a href=#pg-acce7e24090fea04715a7a516ba3e69b>쿠버네티스에서 윈도우</a></li>
<ul>
<li>2.4.1: <a href=#pg-a307d413f1f7430fced233023087e2a1>쿠버네티스에서 윈도우 컨테이너</a></li>
<li>2.4.2: <a href=#pg-3a51e66c5de55f9093a8dc55742006d3>쿠버네티스에서 윈도우 컨테이너 스케줄링을 위한 가이드</a></li>
</ul>
</ul>
<li>3: <a href=#pg-84b6491601d6a2b3da4cd5a105c866ba>모범 사례</a></li>
<ul>
<li>3.1: <a href=#pg-c797ee17120176c685455db89ae091a9>대형 클러스터에 대한 고려 사항</a></li>
<li>3.2: <a href=#pg-970615c97499e3651fd3a98e0387cefc>여러 영역에서 실행</a></li>
<li>3.3: <a href=#pg-f89867de1d34943f1524f67a241f5cc9>노드 구성 검증하기</a></li>
<li>3.4: <a href=#pg-0394f813094b7a35058dffe5b8bacd20>PKI 인증서 및 요구 사항</a></li>
</ul>
</ul>
<div class=content>
<p>본 섹션에는 쿠버네티스를 설정하고 실행하는 다양한 방법이 나열되어 있다.
쿠버네티스를 설치할 때는 유지보수의 용이성, 보안, 제어, 사용 가능한 리소스, 그리고
클러스터를 운영하고 관리하기 위해 필요한 전문성을 기반으로 설치 유형을 선택한다.</p>
<p><a href=/releases/download/>쿠버네티스를 다운로드</a>하여
로컬 머신에, 클라우드에, 데이터센터에 쿠버네티스 클러스터를 구축할 수 있다.</p>
<p>쿠버네티스 클러스터를 직접 관리하고 싶지 않다면, <a href=/ko/docs/setup/production-environment/turnkey-solutions/>인증된 플랫폼</a>과
같은 매니지드 서비스를 선택할 수도 있다.
광범위한 클라우드 또는 베어 메탈 환경에 걸쳐 사용할 수 있는
표준화된/맞춤형 솔루션도 있다.</p>
<h2 id=학습-환경>학습 환경</h2>
<p>쿠버네티스를 배우고 있다면, 쿠버네티스 커뮤니티에서 지원하는 도구나,
로컬 머신에서 쿠버네티스를 설치하기 위한 생태계 내의 도구를 사용한다.
<a href=/ko/docs/tasks/tools/>도구 설치</a>를 살펴본다.</p>
<h2 id=프로덕션-환경>프로덕션 환경</h2>
<p><a href=/ko/docs/setup/production-environment/>프로덕션 환경</a>을 위한
솔루션을 평가할 때에는, 쿠버네티스 클러스터(또는 <em>추상화된 객체</em>)
운영에 대한 어떤 측면을 스스로 관리하기를 원하는지,
또는 제공자에게 넘기기를 원하는지 고려한다.</p>
<p>클러스터를 직접 관리하는 경우, 공식적으로 지원되는 쿠버네티스 구축 도구는
<a href=/ko/docs/setup/production-environment/tools/kubeadm/>kubeadm</a>이다.</p>
<h2 id=다음-내용>다음 내용</h2>
<ul>
<li><a href=/releases/download/>쿠버네티스를 다운로드</a>한다.</li>
<li><code>kubectl</code>을 포함한 <a href=/ko/docs/tasks/tools/>도구를 설치</a>한다.</li>
<li>새로운 클러스터에 사용할 <a href=/ko/docs/setup/production-environment/container-runtimes/>컨테이너 런타임</a>을 선택한다.</li>
<li>클러스터 구성의 <a href=/ko/docs/setup/best-practices/>모범 사례</a>를 확인한다.</li>
</ul>
<p>쿠버네티스의 <a class=glossary-tooltip title="컨테이너의 라이프사이클을 정의, 배포, 관리하기 위한 API와 인터페이스들을 노출하는 컨테이너 오케스트레이션 레이어." data-toggle=tooltip data-placement=top href="/ko/docs/reference/glossary/?all=true#term-control-plane" target=_blank aria-label="컨트롤 플레인">컨트롤 플레인</a>은
리눅스에서 실행되도록 설계되었다. 클러스터 내에서는 리눅스 또는
다른 운영 체제(예: 윈도우)에서 애플리케이션을 실행할 수 있다.</p>
<ul>
<li><a href=/ko/docs/setup/production-environment/windows/>윈도우 노드를 포함하는 클러스터 구성하기</a>를 살펴본다.</li>
</ul>
</div>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-0b597086a9d1382f86abadcfeab657d6>1 - 학습 환경</h1>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-4e14853fdaa3bd273f31a60112b9b5ac>2 - 프로덕션 환경</h1>
<div class=lead>프로덕션 수준의 쿠버네티스 클러스터 생성</div>
<p>프로덕션 수준의 쿠버네티스 클러스터에는 계획과 준비가 필요하다.
쿠버네티스 클러스터에 중요한 워크로드를 실행하려면 클러스터를 탄력적이도록 구성해야 한다.
이 페이지에서는 프로덕션용 클러스터를 설정하거나 기존 클러스터를 프로덕션용으로 업그레이드하기 위해
수행할 수 있는 단계를 설명한다.
이미 프로덕션 구성 내용에 익숙하여 단지 링크를 찾고 있다면,
<a href=#%EB%8B%A4%EC%9D%8C-%EB%82%B4%EC%9A%A9>다음 내용</a>을 참고한다.</p>
<h2 id=프로덕션-고려-사항>프로덕션 고려 사항</h2>
<p>일반적으로 프로덕션 쿠버네티스 클러스터 환경에는
개인 학습용, 개발용 또는 테스트 환경용 클러스터보다 더 많은 요구 사항이 있다.
프로덕션 환경에는 많은 사용자의 보안 액세스, 일관된 가용성 및
변화하는 요구를 충족하기 위한 리소스가 필요할 수 있다.</p>
<p>프로덕션 쿠버네티스 환경이 상주할 위치(온 프레미스 또는 클라우드)와
직접 처리하거나 다른 사람에게 맡길 관리의 양을 결정할 때,
쿠버네티스 클러스터에 대한 요구 사항이
다음 이슈에 의해 어떻게 영향을 받는지 고려해야 한다.</p>
<ul>
<li>
<p><em>가용성</em>: 단일 머신 쿠버네티스 <a href=/ko/docs/setup/#%ED%95%99%EC%8A%B5-%ED%99%98%EA%B2%BD>학습 환경</a>은 SPOF(Single Point of Failure, 단일 장애 지점) 이슈를 갖고 있다.
고가용성 클러스터를 만드는 것에는 다음과 같은 고려 사항이 있다.</p>
<ul>
<li>컨트롤 플레인과 워크 노드를 분리</li>
<li>컨트롤 플레인 구성요소를 여러 노드에 복제</li>
<li>클러스터의 <a class=glossary-tooltip title="쿠버네티스 API를 제공하는 컨트롤 플레인 컴포넌트." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/overview/components/#kube-apiserver target=_blank aria-label="API 서버">API 서버</a>로 가는 트래픽을 로드밸런싱</li>
<li>워커 노드를 충분히 운영하거나, 워크로드 변경에 따라 빠르게 제공할 수 있도록 보장</li>
</ul>
</li>
<li>
<p><em>스케일링</em>: 프로덕션 쿠버네티스 환경에 들어오는 요청의 양의
일정할 것으로 예상된다면, 필요한 만큼의 용량(capacity)을 증설하고
마무리할 수도 있다. 하지만, 요청의 양이 시간에 따라 점점 증가하거나
계절, 이벤트 등에 의해 극적으로 변동할 것으로 예상된다면,
컨트롤 플레인과 워커 노드로의 요청 증가로 인한 압박을 해소하기 위해 스케일 업 하거나
잉여 자원을 줄이기 위해 스케일 다운 하는 것에 대해 고려해야 한다.</p>
</li>
<li>
<p><em>보안 및 접근 관리</em>: 학습을 위한 쿠버네티스 클러스터에는
완전한 관리 권한을 가질 수 있다. 하지만 중요한 워크로드를 실행하며
두 명 이상의 사용자가 있는 공유 클러스터에는 누가, 그리고 무엇이 클러스터 자원에
접근할 수 있는지에 대해서 보다 정교한 접근 방식이 필요하다.
역할 기반 접근 제어(<a href=/docs/reference/access-authn-authz/rbac/>RBAC</a>) 및
기타 보안 메커니즘을 사용하여, 사용자와 워크로드가 필요한 자원에
액세스할 수 있게 하면서도 워크로드와 클러스터를 안전하게 유지할 수 있다.
<a href=/ko/docs/concepts/policy/>정책</a>과
<a href=/ko/docs/concepts/configuration/manage-resources-containers/>컨테이너 리소스</a>를
관리하여, 사용자 및 워크로드가 접근할 수 있는 자원에 대한 제한을 설정할 수 있다.</p>
</li>
</ul>
<p>쿠버네티스 프로덕션 환경을 직접 구축하기 전에, 이 작업의 일부 또는 전체를
<a href=/ko/docs/setup/production-environment/turnkey-solutions/>턴키 클라우드 솔루션</a>
제공 업체 또는 기타 <a href=/ko/partners/>쿠버네티스 파트너</a>에게
넘기는 것을 고려할 수 있다.
다음과 같은 옵션이 있다.</p>
<ul>
<li><em>서버리스</em>: 클러스터를 전혀 관리하지 않고
타사 장비에서 워크로드를 실행하기만 하면 된다.
CPU 사용량, 메모리 및 디스크 요청과 같은 항목에 대한 요금이 부과된다.</li>
<li><em>관리형 컨트롤 플레인</em>: 쿠버네티스 서비스 공급자가
클러스터 컨트롤 플레인의 확장 및 가용성을 관리하고 패치 및 업그레이드를 처리하도록 한다.</li>
<li><em>관리형 워커 노드</em>: 필요에 맞는 노드 풀을 정의하면,
쿠버네티스 서비스 공급자는 해당 노드의 가용성 및
필요 시 업그레이드 제공을 보장한다.</li>
<li><em>통합</em>: 쿠버네티스를 스토리지, 컨테이너 레지스트리,
인증 방법 및 개발 도구와 같이
사용자가 필요로 하는 여러 서비스를 통합 제공하는 업체도 있다.</li>
</ul>
<p>프로덕션 쿠버네티스 클러스터를 직접 구축하든 파트너와 협력하든,
요구 사항이 <em>컨트롤 플레인</em>, <em>워커 노드</em>,
<em>사용자 접근</em>, <em>워크로드 자원</em>과 관련되기 때문에,
다음 섹션들을 검토하는 것이 바람직하다.</p>
<h2 id=프로덕션-클러스터-구성>프로덕션 클러스터 구성</h2>
<p>프로덕션 수준 쿠버네티스 클러스터에서,
컨트롤 플레인은 다양한 방식으로 여러 컴퓨터에 분산될 수 있는 서비스들을 통해
클러스터를 관리한다.
반면, 각 워커 노드는 쿠버네티스 파드를 실행하도록 구성된 단일 엔티티를 나타낸다.</p>
<h3 id=프로덕션-컨트롤-플레인>프로덕션 컨트롤 플레인</h3>
<p>가장 간단한 쿠버네티스 클러스터는 모든 컨트롤 플레인 및 워커 노드 서비스가
하나의 머신에 실행되는 클러스터이다.
<a href=/ko/docs/concepts/overview/components/>쿠버네티스 컴포넌트</a>
그림에 명시된 대로, 워커 노드를 추가하여 해당 환경을 확장할 수 있다.
클러스터를 단기간만 사용하거나,
심각한 문제가 발생한 경우 폐기하는 것이 가능하다면, 이 방식을 선택할 수 있다.</p>
<p>그러나 더 영구적이고 가용성이 높은 클러스터가 필요한 경우
컨트롤 플레인 확장을 고려해야 한다.
설계 상, 단일 시스템에서 실행되는 단일 시스템 컨트롤 플레인 서비스는
가용성이 높지 않다.
클러스터를 계속 유지하면서 문제가 발생한 경우 복구할 수 있는지 여부가 중요한 경우,
다음 사항들을 고려한다.</p>
<ul>
<li><em>배포 도구 선택</em>: kubeadm, kops, kubespray와 같은 도구를 이용해
컨트롤 플레인을 배포할 수 있다.
<a href=/ko/docs/setup/production-environment/tools/>배포 도구로 쿠버네티스 설치하기</a>에서
여러 배포 도구를 이용한 프로덕션 수준 배포에 대한 팁을 확인한다.
배포 시, 다양한
<a href=/ko/docs/setup/production-environment/container-runtimes/>컨테이너 런타임</a>을 사용할 수 있다.</li>
<li><em>인증서 관리</em>: 컨트롤 플레인 서비스 간의 보안 통신은 인증서를 사용하여 구현된다.
인증서는 배포 중에 자동으로 생성되거나, 또는 자체 인증 기관을 사용하여 생성할 수 있다.
<a href=/ko/docs/setup/best-practices/certificates/>PKI 인증서 및 요구 조건</a>에서
상세 사항을 확인한다.</li>
<li><em>apiserver를 위한 로드밸런서 구성</em>: 여러 노드에서 실행되는 apiserver 서비스 인스턴스에
외부 API 호출을 분산할 수 있도록 로드밸런서를 구성한다.
<a href=/docs/tasks/access-application-cluster/create-external-load-balancer/>외부 로드밸런서 생성하기</a>에서
상세 사항을 확인한다.</li>
<li><em>etcd 서비스 분리 및 백업</em>: etcd 서비스는
다른 컨트롤 플레인 서비스와 동일한 시스템에서 실행되거나,
또는 추가 보안 및 가용성을 위해 별도의 시스템에서 실행될 수 있다.
etcd는 클러스터 구성 데이터를 저장하므로
필요한 경우 해당 데이터베이스를 복구할 수 있도록 etcd 데이터베이스를 정기적으로 백업해야 한다.
<a href=https://etcd.io/docs/v3.4/faq/>etcd FAQ</a>에서 etcd 구성 및 사용 상세를 확인한다.
<a href=/docs/tasks/administer-cluster/configure-upgrade-etcd/>쿠버네티스를 위한 etcd 클러스터 운영하기</a>와
<a href=/docs/setup/production-environment/tools/kubeadm/setup-ha-etcd-with-kubeadm/>kubeadm을 이용하여 고가용성 etcd 생성하기</a>에서
상세 사항을 확인한다.</li>
<li><em>다중 컨트롤 플레인 시스템 구성</em>: 고가용성을 위해,
컨트롤 플레인은 단일 머신으로 제한되지 않아야 한다.
컨트롤 플레인 서비스가 init 서비스(예: systemd)에 의해 실행되는 경우,
각 서비스는 최소 3대의 머신에서 실행되어야 한다.
그러나, 컨트롤 플레인 서비스를 쿠버네티스 상의 파드 형태로 실행하면
각 서비스 복제본 요청이 보장된다.
스케줄러는 내결함성이 있어야 하고, 고가용성은 필요하지 않다.
일부 배포 도구는 쿠버네티스 서비스의 리더 선출을 수행하기 위해
<a href=https://raft.github.io/>Raft</a> 합의 알고리즘을 설정한다.
리더를 맡은 서비스가 사라지면 다른 서비스가 스스로 리더가 되어 인계를 받는다.</li>
<li><em>다중 영역(zone)으로 확장</em>: 클러스터를 항상 사용 가능한 상태로 유지하는 것이 중요하다면
여러 데이터 센터(클라우드 환경에서는 '영역'이라고 함)에서 실행되는
클러스터를 만드는 것이 좋다.
영역의 그룹을 지역(region)이라고 한다.
동일한 지역의 여러 영역에 클러스터를 분산하면
하나의 영역을 사용할 수 없게 된 경우에도 클러스터가 계속 작동할 가능성을 높일 수 있다.
<a href=/ko/docs/setup/best-practices/multiple-zones/>여러 영역에서 실행</a>에서 상세 사항을 확인한다.</li>
<li><em>구동 중인 기능 관리</em>: 클러스터를 계속 유지하려면,
상태 및 보안을 유지하기 위해 수행해야 하는 작업이 있다.
예를 들어 kubeadm으로 클러스터를 생성한 경우,
<a href=/ko/docs/tasks/administer-cluster/kubeadm/kubeadm-certs/>인증서 관리</a>와
<a href=/ko/docs/tasks/administer-cluster/kubeadm/kubeadm-upgrade/>kubeadm 클러스터 업그레이드하기</a>에 대해 도움이 되는 가이드가 있다.
<a href=/ko/docs/tasks/administer-cluster/>클러스터 운영하기</a>에서
더 많은 쿠버네티스 관리 작업을 볼 수 있다.</li>
</ul>
<p>컨트롤 플레인 서비스를 실행할 때 사용 가능한 옵션에 대해 보려면,
<a href=/docs/reference/command-line-tools-reference/kube-apiserver/>kube-apiserver</a>,
<a href=/docs/reference/command-line-tools-reference/kube-controller-manager/>kube-controller-manager</a>,
<a href=/docs/reference/command-line-tools-reference/kube-scheduler/>kube-scheduler</a>를 참조한다.
고가용성 컨트롤 플레인 예제는
<a href=/ko/docs/setup/production-environment/tools/kubeadm/ha-topology/>고가용성 토폴로지를 위한 옵션</a>,
<a href=/docs/setup/production-environment/tools/kubeadm/high-availability/>kubeadm을 이용하여 고가용성 클러스터 생성하기</a>,
<a href=/docs/tasks/administer-cluster/configure-upgrade-etcd/>쿠버네티스를 위한 etcd 클러스터 운영하기</a>를 참조한다.
etcd 백업 계획을 세우려면
<a href=/docs/tasks/administer-cluster/configure-upgrade-etcd/#backing-up-an-etcd-cluster>etcd 클러스터 백업하기</a>를 참고한다.</p>
<h3 id=프로덕션-워커-노드>프로덕션 워커 노드</h3>
<p>프로덕션 수준 워크로드는 복원력이 있어야 하고,
이들이 의존하는 모든 것들(예: CoreDNS)도 복원력이 있어야 한다.
컨트롤 플레인을 자체적으로 관리하든
클라우드 공급자가 대신 수행하도록 하든 상관없이,
워커 노드(간단히 <em>노드</em>라고도 함)를 어떤 방법으로 관리할지 고려해야 한다.</p>
<ul>
<li><em>노드 구성하기</em>: 노드는 물리적 또는 가상 머신일 수 있다.
직접 노드를 만들고 관리하려면 지원되는 운영 체제를 설치한 다음
적절한 <a href=/ko/docs/concepts/overview/components/#%EB%85%B8%EB%93%9C-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8>노드 서비스</a>를 추가하고 실행한다.
다음을 고려해야 한다.
<ul>
<li>워크로드의 요구 사항 (노드가 적절한 메모리, CPU, 디스크 속도, 저장 용량을 갖도록 구성)</li>
<li>일반적인 컴퓨터 시스템이면 되는지, 아니면 GPU, 윈도우 노드, 또는 VM 격리를 필요로 하는 워크로드가 있는지</li>
</ul>
</li>
<li><em>노드 검증하기</em>: <a href=/ko/docs/setup/best-practices/node-conformance/>노드 구성 검증하기</a>에서
노드가 쿠버네티스 클러스터에 조인(join)에 필요한 요구 사항을
만족하는지 확인하는 방법을 알아본다.</li>
<li><em>클러스터에 노드 추가하기</em>: 클러스터를 자체적으로 관리하는 경우,
머신을 준비하고, 클러스터의 apiserver에 이를 수동으로 추가하거나
또는 머신이 스스로 등록하도록 하여 노드를 추가할 수 있다.
이러한 방식으로 노드를 추가하는 방법을 보려면 <a href=/ko/docs/concepts/architecture/nodes/>노드</a> 섹션을 확인한다.</li>
<li><em>클러스터에 윈도우 노드 추가하기</em>: 윈도우 컨테이너로 구현된 워크로드를
실행할 수 있도록, 쿠버네티스는 윈도우 워커 노드를 지원한다.
<a href=/ko/docs/setup/production-environment/windows/>쿠버네티스에서의 윈도우</a>에서 상세 사항을 확인한다.</li>
<li><em>노드 스케일링</em>: 클러스터가 최종적으로 필요로 하게 될 용량만큼
확장하는 것에 대한 계획이 있어야 한다.
실행해야 하는 파드 및 컨테이너 수에 따라 필요한 노드 수를 판별하려면
<a href=/ko/docs/setup/best-practices/cluster-large/>대형 클러스터에 대한 고려 사항</a>을 확인한다.
만약 노드를 직접 관리한다면, 직접 물리적 장비를 구입하고 설치해야 할 수도 있음을 의미한다.</li>
<li><em>노드 자동 스케일링</em>: 대부분의 클라우드 공급자는
비정상 노드를 교체하거나 수요에 따라 노드 수를 늘리거나 줄일 수 있도록
<a href=https://github.com/kubernetes/autoscaler/tree/master/cluster-autoscaler#readme>클러스터 오토스케일러</a>를 지원한다.
<a href=https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/FAQ.md>자주 묻는 질문</a>에서
오토스케일러가 어떻게 동작하는지,
<a href=https://github.com/kubernetes/autoscaler/tree/master/cluster-autoscaler#deployment>배치</a> 섹션에서
각 클라우드 공급자별로 어떻게 구현했는지를 확인한다.
온프레미스의 경우, 필요에 따라 새 노드를 가동하도록
스크립트를 구성할 수 있는 가상화 플랫폼이 있다.</li>
<li><em>노드 헬스 체크 구성</em>: 중요한 워크로드의 경우,
해당 노드에서 실행 중인 노드와 파드의 상태가 정상인지 확인하고 싶을 것이다.
<a href=/docs/tasks/debug-application-cluster/monitor-node-health/>Node Problem Detector</a>
데몬을 사용하면 노드가 정상인지 확인할 수 있다.</li>
</ul>
<h2 id=프로덕션-사용자-관리>프로덕션 사용자 관리</h2>
<p>프로덕션에서는, 클러스터를 한 명 또는 여러 명이 사용하던 모델에서
수십에서 수백 명이 사용하는 모델로 바꿔야 하는 경우가 발생할 수 있다.
학습 환경 또는 플랫폼 프로토타입에서는 모든 작업에 대한 단일 관리 계정으로도
충분할 수 있다. 프로덕션에서는 여러 네임스페이스에 대한, 액세스 수준이
각각 다른 더 많은 계정이 필요하다.</p>
<p>프로덕션 수준의 클러스터를 사용한다는 것은
다른 사용자의 액세스를 선택적으로 허용할 방법을 결정하는 것을 의미한다.
특히 클러스터에 액세스를 시도하는 사용자의 신원을 확인(인증, authentication)하고
요청한 작업을 수행할 권한이 있는지 결정(인가, authorization)하기 위한
다음과 같은 전략을 선택해야 한다.</p>
<ul>
<li><em>인증</em>: apiserver는 클라이언트 인증서, 전달자 토큰, 인증 프록시 또는
HTTP 기본 인증을 사용하여 사용자를 인증할 수 있다.
사용자는 인증 방법을 선택하여 사용할 수 있다.
apiserver는 또한 플러그인을 사용하여
LDAP 또는 Kerberos와 같은 조직의 기존 인증 방법을 활용할 수 있다.
쿠버네티스 사용자를 인증하는 다양한 방법에 대한 설명은
<a href=/docs/reference/access-authn-authz/authentication/>인증</a>을 참조한다.</li>
<li><em>인가</em>: 일반 사용자 인가를 위해, RBAC 와 ABAC 중 하나를 선택하여 사용할 수 있다. <a href=/ko/docs/reference/access-authn-authz/authorization/>인가 개요</a>에서 사용자 계정과 서비스 어카운트 인가를 위한 여러 가지 모드를 확인할 수 있다.
<ul>
<li><em>역할 기반 접근 제어</em> (<a href=/docs/reference/access-authn-authz/rbac/>RBAC</a>): 인증된 사용자에게 특정 권한 집합을 허용하여 클러스터에 대한 액세스를 할당할 수 있다. 특정 네임스페이스(Role) 또는 전체 클러스터(ClusterRole)에 권한을 할당할 수 있다. 그 뒤에 RoleBindings 및 ClusterRoleBindings를 사용하여 해당 권한을 특정 사용자에게 연결할 수 있다.</li>
<li><em>속성 기반 접근 제어</em> (<a href=/docs/reference/access-authn-authz/abac/>ABAC</a>): 클러스터의 리소스 속성을 기반으로 정책을 생성하고 이러한 속성을 기반으로 액세스를 허용하거나 거부할 수 있다. 정책 파일의 각 줄은 버전 관리 속성(apiVersion 및 종류), 그리고 '대상(사용자 또는 그룹)', '리소스 속성', '비 리소스 속성(<code>/version</code> 또는 <code>/apis</code>)' 및 '읽기 전용'과 일치하는 사양 속성 맵을 식별한다. 자세한 내용은 <a href=/docs/reference/access-authn-authz/abac/#examples>예시</a>를 참조한다.</li>
</ul>
</li>
</ul>
<p>프로덕션 쿠버네티스 클러스터에 인증과 인가를 설정할 때, 다음의 사항을 고려해야 한다.</p>
<ul>
<li><em>인가 모드 설정</em>: 쿠버네티스 API 서버(<a href=/docs/reference/command-line-tools-reference/kube-apiserver/>kube-apiserver</a>)를 실행할 때,
<em><code>--authorization-mode</code></em> 플래그를 사용하여 인증 모드를 설정해야 한다.
예를 들어, (*<code>/etc/kubernetes/manifests</code>*에 있는)
<em><code>kube-adminserver.yaml</code></em> 파일 안의 플래그를 <code>Node,RBAC</code>으로 설정할 수 있다.
이렇게 하여 인증된 요청이 Node 인가와 RBAC 인가를 사용할 수 있게 된다.</li>
<li><em>사용자 인증서와 롤 바인딩 생성(RBAC을 사용하는 경우)</em>: RBAC 인증을 사용하는 경우,
사용자는 클러스터 CA가 서명한 CSR(CertificateSigningRequest)을 만들 수 있다.
그 뒤에 각 사용자에게 역할 및 ClusterRoles를 바인딩할 수 있다.
자세한 내용은
<a href=/docs/reference/access-authn-authz/certificate-signing-requests/>인증서 서명 요청</a>을 참조한다.</li>
<li><em>속성을 포함하는 정책 생성(ABAC을 사용하는 경우)</em>: ABAC 인증을 사용하는 경우,
속성의 집합으로 정책을 생성하여, 인증된 사용자 또는 그룹이
특정 리소스(예: 파드), 네임스페이스, 또는 apiGroup에 접근할 수 있도록 한다.
<a href=/docs/reference/access-authn-authz/abac/#examples>예시</a>에서
더 많은 정보를 확인한다.</li>
<li><em>어드미션 컨트롤러 도입 고려</em>:
<a href=/docs/reference/access-authn-authz/authentication/#webhook-token-authentication>웹훅 토큰 인증</a>은
API 서버를 통해 들어오는 요청의 인가에 사용할 수 있는 추가적인 방법이다.
웹훅 및 다른 인가 형식을 사용하려면 API 서버에
<a href=/docs/reference/access-authn-authz/admission-controllers/>어드미션 컨트롤러</a>를
추가해야 한다.</li>
</ul>
<h2 id=워크로드에-자원-제한-걸기>워크로드에 자원 제한 걸기</h2>
<p>프로덕션 워크로드의 요구 사항이
쿠버네티스 컨트롤 플레인 안팎의 압박을 초래할 수 있다.
워크로드의 요구 사항을 충족하도록 클러스터를 구성할 때 다음 항목을 고려한다.</p>
<ul>
<li><em>네임스페이스 제한 설정</em>: 메모리, CPU와 같은 자원의 네임스페이스 별 쿼터를 설정한다.
<a href=/ko/docs/tasks/administer-cluster/manage-resources/>메모리, CPU 와 API 리소스 관리</a>에서
상세 사항을 확인한다.
<a href=/blog/2020/08/14/introducing-hierarchical-namespaces/>계층적 네임스페이스</a>를 설정하여
제한을 상속할 수도 있다.</li>
<li><em>DNS 요청에 대한 대비</em>: 워크로드가 대규모로 확장될 것으로 예상된다면,
DNS 서비스도 확장할 준비가 되어 있어야 한다.
<a href=/docs/tasks/administer-cluster/dns-horizontal-autoscaling/>클러스터의 DNS 서비스 오토스케일링</a>을 확인한다.</li>
<li><em>추가적인 서비스 어카운트 생성</em>: 사용자 계정은 <em>클러스터</em>에서 사용자가 무엇을 할 수 있는지 결정하는 반면에,
서비스 어카운트는 특정 네임스페이스 내의 파드 접근 권한을 결정한다.
기본적으로, 파드는 자신의 네임스페이스의 기본 서비스 어카운트을 이용한다.
<a href=/ko/docs/reference/access-authn-authz/service-accounts-admin/>서비스 어카운트 관리하기</a>에서
새로운 서비스 어카운트을 생성하는 방법을 확인한다. 예를 들어, 다음의 작업을 할 수 있다.
<ul>
<li>파드가 특정 컨테이너 레지스트리에서 이미지를 가져 오는 데 사용할 수 있는 시크릿을 추가한다. <a href=/docs/tasks/configure-pod-container/configure-service-account/>파드를 위한 서비스 어카운트 구성하기</a>에서 예시를 확인한다.</li>
<li>서비스 어카운트에 RBAC 권한을 할당한다. <a href=/docs/reference/access-authn-authz/rbac/#service-account-permissions>서비스어카운트 권한</a>에서 상세 사항을 확인한다.</li>
</ul>
</li>
</ul>
<h2 id=다음-내용>다음 내용</h2>
<ul>
<li>프로덕션 쿠버네티스를 직접 구축할지,
아니면 <a href=/ko/docs/setup/production-environment/turnkey-solutions/>턴키 클라우드 솔루션</a> 또는
<a href=/ko/partners/>쿠버네티스 파트너</a>가 제공하는 서비스를 이용할지 결정한다.</li>
<li>클러스터를 직접 구축한다면,
<a href=/ko/docs/setup/best-practices/certificates/>인증서</a>를 어떻게 관리할지,
<a href=/docs/setup/production-environment/tools/kubeadm/setup-ha-etcd-with-kubeadm/>etcd</a>와
<a href=/ko/docs/setup/production-environment/tools/kubeadm/ha-topology/>API 서버</a>
등의 기능에 대한 고가용성을
어떻게 보장할지를 계획한다.</li>
<li>배포 도구로 <a href=/ko/docs/setup/production-environment/tools/kubeadm/>kubeadm</a>, <a href=/ko/docs/setup/production-environment/tools/kops/>kops</a>, <a href=/ko/docs/setup/production-environment/tools/kubespray/>Kubespray</a> 중
하나를 선택한다.</li>
<li><a href=/docs/reference/access-authn-authz/authentication/>인증</a> 및
<a href=/ko/docs/reference/access-authn-authz/authorization/>인가</a> 방식을 선택하여
사용자 관리 방법을 구성한다.</li>
<li><a href=/ko/docs/tasks/administer-cluster/manage-resources/>자원 제한</a>,
<a href=/docs/tasks/administer-cluster/dns-horizontal-autoscaling/>DNS 오토스케일링</a>,
<a href=/ko/docs/reference/access-authn-authz/service-accounts-admin/>서비스 어카운트</a>를 설정하여
애플리케이션 워크로드의 실행에 대비한다.</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-a77d3feb6e6d9978f32fa14622642e9a>2.1 - 컨테이너 런타임</h1>
<p>파드가 노드에서 실행될 수 있도록 클러스터의 각 노드에
<a class=glossary-tooltip title="컨테이너 런타임은 컨테이너 실행을 담당하는 소프트웨어이다." data-toggle=tooltip data-placement=top href=/ko/docs/setup/production-environment/container-runtimes/ target=_blank aria-label="컨테이너 런타임">컨테이너 런타임</a>을
설치해야 한다. 이 페이지에서는 관련된 항목을 설명하고
노드 설정 관련 작업을 설명한다.</p>
<p>쿠버네티스 1.23에서는
<a class=glossary-tooltip title="Kubelet과 컨테이너 런타임을 통합시키기 위한 API" data-toggle=tooltip data-placement=top href=/ko/docs/concepts/overview/components/#%ec%bb%a8%ed%85%8c%ec%9d%b4%eb%84%88-%eb%9f%b0%ed%83%80%ec%9e%84 target=_blank aria-label="컨테이너 런타임 인터페이스">컨테이너 런타임 인터페이스</a>(CRI) 요구사항을 만족하는
런타임을 사용해야 한다.</p>
<p>더 자세한 정보는 <a href=#cri-versions>CRI 버전 지원</a>을 참조한다.</p>
<p>이 페이지에는 리눅스 환경의 쿠버네티스에서 여러 공통 컨테이너 런타임을 사용하는 방법에 대한
세부 정보가 있다.</p>
<ul>
<li><a href=#containerd>containerd</a></li>
<li><a href=#cri-o>CRI-O</a></li>
<li><a href=#docker>도커 엔진</a></li>
<li><a href=#mcr>미란티스 컨테이너 런타임</a></li>
</ul>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> 다른 운영 체제의 경우, 해당 플랫폼과 관련된 문서를 찾아보자.
</div>
<h2 id=cgroup-드라이버>cgroup 드라이버</h2>
<p>Control group은 프로세스에 할당된 리소스를 제한하는데 사용된다.</p>
<p>리눅스 배포판의 init 시스템이 <a href=https://www.freedesktop.org/wiki/Software/systemd/>systemd</a>인
경우, init 프로세스는 root control group(<code>cgroup</code>)을
생성 및 사용하는 cgroup 관리자로 작동한다.
Systemd는 cgroup과의 긴밀한 통합을 통해 프로세스당 cgroup을 할당한다.
컨테이너 런타임과 kubelet이 <code>cgroupfs</code>를 사용하도록 설정할 수 있다. systemd와 함께
<code>cgroupfs</code>를 사용하면 두 개의 서로 다른 cgroup 관리자가 존재하게 된다는 뜻이다.</p>
<p>단일 cgroup 관리자는 할당되는 리소스가 무엇인지를 단순화하고,
기본적으로 사용할 수 있는 리소스와 사용 중인 리소스를 일관성있게 볼 수 있다.
시스템에 두 개의 cgroup 관리자가 있으면, 이런 리소스도 두 개의 관점에서 보게 된다.
현장에서 사람들은 kubelet과 도커에 <code>cgroupfs</code>를 사용하고,
나머지 프로세스는 <code>systemd</code>를 사용하도록 노드가 설정된 경우, 리소스가 부족할 때
불안정해지는 사례를 보고했다.</p>
<p>컨테이너 런타임과 kubelet이 <code>systemd</code>를 cgroup 드라이버로 사용하도록 설정을 변경하면
시스템이 안정화된다. 도커에 대해 구성하려면, <code>native.cgroupdriver=systemd</code>를 설정한다.</p>
<div class="alert alert-warning caution callout" role=alert>
<strong>주의:</strong> <p>클러스터에 결합되어 있는 노드의 cgroup 관리자를 변경하는 것은 신중하게 수행해야 한다.
하나의 cgroup 드라이버의 의미를 사용하여 kubelet이 파드를 생성해왔다면,
컨테이너 런타임을 다른 cgroup 드라이버로 변경하는 것은 존재하는 기존 파드에 대해 파드 샌드박스 재생성을 시도할 때, 에러가 발생할 수 있다.
kubelet을 재시작하는 것은 에러를 해결할 수 없을 것이다.</p>
<p>자동화가 가능하다면, 업데이트된 구성을 사용하여 노드를 다른 노드로
교체하거나, 자동화를 사용하여 다시 설치한다.</p>
</div>
<h2 id=cgroup-v2>cgroup v2</h2>
<p>cgroup v2는 cgroup Linux API의 다음 버전이다.
cgroup v1과는 다르게 각 컨트롤러마다 다른 계층 대신 단일 계층이 있다.</p>
<p>새 버전은 cgroup v1에 비해 몇 가지 향상된 기능을 제공하며, 개선 사항 중 일부는 다음과 같다.</p>
<ul>
<li>API를 더 쉽고 깔끔하게 사용할 수 있음</li>
<li>컨테이너로의 안전한 하위 트리 위임</li>
<li>압력 중지 정보와 같은 새로운 기능</li>
</ul>
<p>일부 컨트롤러는 cgroup v1에 의해 관리되고 다른 컨트롤러는 cgroup v2에 의해 관리되는 하이브리드 구성을 지원하더라도,
쿠버네티스는 모든 컨트롤러를 관리하기 위해
동일한 cgroup 버전만 지원한다.</p>
<p>systemd가 기본적으로 cgroup v2를 사용하지 않는 경우, 커널 명령줄에 <code>systemd.unified_cgroup_hierarchy=1</code>을
추가하여 cgroup v2를 사용하도록 시스템을 구성할 수 있다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># 이 예제는 리눅스 OS에서 DNF 패키지 관리자를 사용하는 경우에 대한 것이다.</span>
<span style=color:#080;font-style:italic># 리눅스 커널이 사용하는 커맨드 라인을 설정하기 위해 </span>
<span style=color:#080;font-style:italic># 사용자의 시스템이 다른 방법을 사용하고 있을 수도 있다.</span>
sudo dnf install -y grubby <span style=color:#666>&amp;&amp;</span> <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  sudo grubby <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --update-kernel<span style=color:#666>=</span>ALL <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --args<span style=color:#666>=</span><span style=color:#b44>&#34;systemd.unified_cgroup_hierarchy=1&#34;</span>
</code></pre></div><p>커널이 사용하는 커맨드 라인을 업데이트하려면,
변경 사항을 적용하기 위해 노드를 재시작해야 한다.</p>
<p>cgroup v2로 전환할 때 사용자가 노드 또는 컨테이너 내에서
cgroup 파일 시스템에 직접 접근하지 않는 한 사용자 경험에 현저한 차이가 없어야 한다.</p>
<p>cgroup v2를 사용하려면 CRI 런타임에서도 cgroup v2를 지원해야 한다.</p>
<h3 id=kubeadm으로-생성한-클러스터의-드라이버를-systemd-로-변경하기>kubeadm으로 생성한 클러스터의 드라이버를 <code>systemd</code>로 변경하기</h3>
<p>kubeadm으로 생성한 클러스터의 cgroup 드라이버를 <code>systemd</code>로 변경하려면
<a href=/docs/tasks/administer-cluster/kubeadm/configure-cgroup-driver/>변경 가이드</a>를 참고한다.</p>
<h2 id=cri-versions>CRI 버전 지원</h2>
<p>사용할 컨테이너 런타임이 적어도 CRI의 v1alpha2 이상을 지원해야 한다.</p>
<p>쿠버네티스 1.23 버전에서는 기본적으로 CRI API 중 v1을 사용한다.
컨테이너 런타임이 v1 API를 지원하지 않으면,
kubelet은 대신 (사용 중단된) v1alpha2 API를 사용하도록 설정된다.</p>
<h2 id=컨테이너-런타임>컨테이너 런타임</h2>
<div class="alert alert-secondary callout third-party-content" role=alert><strong>참고:</strong>
이 섹션은 쿠버네티스에 필요한 기능을 제공하는 써드파티 프로젝트와 관련이 있다. 쿠버네티스 프로젝트 작성자는 써드파티 프로젝트에 책임이 없다. 이 페이지는 <a href=https://github.com/cncf/foundation/blob/master/website-guidelines.md target=_blank>CNCF 웹사이트 가이드라인</a>에 따라 프로젝트를 알파벳 순으로 나열한다. 이 목록에 프로젝트를 추가하려면 변경사항을 제출하기 전에 <a href=/contribute/style/content-guide/#third-party-content>콘텐츠 가이드</a>를 읽어본다.</div>
<h3 id=containerd>containerd</h3>
<p>이 섹션에는 containerd를 CRI 런타임으로 사용하는 데 필요한 단계가 포함되어 있다.</p>
<p>다음 명령을 사용하여 시스템에 containerd를 설치한다.</p>
<p>필수 구성 요소를 설치 및 구성한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>cat <span style=color:#b44>&lt;&lt;EOF | sudo tee /etc/modules-load.d/containerd.conf
</span><span style=color:#b44>overlay
</span><span style=color:#b44>br_netfilter
</span><span style=color:#b44>EOF</span>

sudo modprobe overlay
sudo modprobe br_netfilter

<span style=color:#080;font-style:italic># 필요한 sysctl 파라미터를 설정하면 재부팅 후에도 유지된다.</span>
cat <span style=color:#b44>&lt;&lt;EOF | sudo tee /etc/sysctl.d/99-kubernetes-cri.conf
</span><span style=color:#b44>net.bridge.bridge-nf-call-iptables  = 1
</span><span style=color:#b44>net.ipv4.ip_forward                 = 1
</span><span style=color:#b44>net.bridge.bridge-nf-call-ip6tables = 1
</span><span style=color:#b44>EOF</span>

<span style=color:#080;font-style:italic># 재부팅하지 않고 sysctl 파라미터 적용</span>
sudo sysctl --system
</code></pre></div><p>containerd를 설치한다.</p>
<ul class="nav nav-tabs" id=tab-cri-containerd-installation role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tab-cri-containerd-installation-0 role=tab aria-controls=tab-cri-containerd-installation-0 aria-selected=true>Linux</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tab-cri-containerd-installation-1 role=tab aria-controls=tab-cri-containerd-installation-1>Windows (PowerShell)</a></li></ul>
<div class=tab-content id=tab-cri-containerd-installation><div id=tab-cri-containerd-installation-0 class="tab-pane show active" role=tabpanel aria-labelledby=tab-cri-containerd-installation-0>
<p><ol>
<li>
<p>공식 도커 리포지터리에서 <code>containerd.io</code> 패키지를 설치한다.
각 리눅스 배포판에 대한 도커 리포지터리를 설정하고
<code>containerd.io</code> 패키지를 설치하는 방법은
<a href=https://docs.docker.com/engine/install/#server>도커 엔진 설치</a>에서 찾을 수 있다.</p>
</li>
<li>
<p>containerd 설정</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>sudo mkdir -p /etc/containerd
containerd config default | sudo tee /etc/containerd/config.toml
</code></pre></div></li>
<li>
<p>containerd 재시작</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>sudo systemctl restart containerd
</code></pre></div></li>
</ol>
</div>
<div id=tab-cri-containerd-installation-1 class=tab-pane role=tabpanel aria-labelledby=tab-cri-containerd-installation-1>
<p><p>PowerShell 세션을 시작하고 <code>$Version</code>을 원하는 버전으로
설정(예: <code>$Version:"1.4.3"</code>)한 후 다음 명령을 실행한다.</p>
<ol>
<li>
<p>containerd 다운로드</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell>curl.exe -L https<span>:</span>//github.com/containerd/containerd/releases/download/v<span style=color:#b8860b>$Version</span>/containerd-<span style=color:#b8860b>$Version</span>-windows-amd64.tar.gz -o <span style=color:#a2f>containerd-windows</span>-amd64.tar.gz
tar.exe xvf .\<span style=color:#a2f>containerd-windows</span>-amd64.tar.gz
</code></pre></div></li>
<li>
<p>추출과 설정</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=color:#a2f>Copy-Item</span> -Path <span style=color:#b44>&#34;.\bin\&#34;</span> -Destination <span style=color:#b44>&#34;$Env:ProgramFiles\containerd&#34;</span> -Recurse -Force
<span style=color:#a2f>cd </span><span style=color:#b8860b>$Env:ProgramFiles</span>\containerd\
.\containerd.exe config <span style=color:#a2f;font-weight:700>default</span> | <span style=color:#a2f>Out-File</span> config.toml -Encoding ascii

<span style=color:#080;font-style:italic># 설정을 검토한다. 설정에 따라 다음을 조정할 수 있다.</span>
<span style=color:#080;font-style:italic># - sandbox_image (쿠버네티스 일시중지 이미지)</span>
<span style=color:#080;font-style:italic># - cni bin 폴더와 conf 폴더 위치</span>
<span style=color:#a2f>Get-Content</span> config.toml

<span style=color:#080;font-style:italic># (선택사항 - 그러나 적극 권장함) Windows 디펜더 검사에서 containerd 제외</span>
<span style=color:#a2f>Add-MpPreference</span> -ExclusionProcess <span style=color:#b44>&#34;$Env:ProgramFiles\containerd\containerd.exe&#34;</span>
</code></pre></div></li>
<li>
<p>containerd 실행</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell>.\containerd.exe --register-service
<span style=color:#a2f>Start-Service</span> containerd
</code></pre></div></li>
</ol>
</div></div>
<h4 id=containerd-systemd><code>systemd</code> cgroup 드라이버의 사용</h4>
<p><code>/etc/containerd/config.toml</code> 의 <code>systemd</code> cgroup 드라이버를 <code>runc</code> 에서 사용하려면, 다음과 같이 설정한다.</p>
<pre><code>[plugins.&quot;io.containerd.grpc.v1.cri&quot;.containerd.runtimes.runc]
  ...
  [plugins.&quot;io.containerd.grpc.v1.cri&quot;.containerd.runtimes.runc.options]
    SystemdCgroup = true
</code></pre><p>이 변경 사항을 적용하는 경우 containerd를 재시작한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>sudo systemctl restart containerd
</code></pre></div><p>kubeadm을 사용하는 경우,
<a href=/ko/docs/setup/production-environment/tools/kubeadm/install-kubeadm/#%EC%BB%A8%ED%8A%B8%EB%A1%A4-%ED%94%8C%EB%A0%88%EC%9D%B8-%EB%85%B8%EB%93%9C%EC%97%90%EC%84%9C-kubelet%EC%9D%B4-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-cgroup-%EB%93%9C%EB%9D%BC%EC%9D%B4%EB%B2%84-%EA%B5%AC%EC%84%B1>kubelet용 cgroup 드라이버</a>를 수동으로 구성한다.</p>
<h3 id=cri-o>CRI-O</h3>
<p>이 섹션은 CRI-O를 컨테이너 런타임으로 설치하는 필수적인 단계를 담고 있다.</p>
<p>시스템에 CRI-O를 설치하기 위해서 다음의 커맨드를 사용한다.</p>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> CRI-O 메이저와 마이너 버전은 쿠버네티스 메이저와 마이너 버전이 일치해야 한다.
더 자세한 정보는 <a href=https://github.com/cri-o/cri-o#compatibility-matrix-cri-o--kubernetes>CRI-O 호환 매트릭스</a>를 본다.
</div>
<p>필수 구성 요소를 설치하고 구성한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># .conf 파일을 만들어 부팅 시 모듈을 로드한다</span>
cat <span style=color:#b44>&lt;&lt;EOF | sudo tee /etc/modules-load.d/crio.conf
</span><span style=color:#b44>overlay
</span><span style=color:#b44>br_netfilter
</span><span style=color:#b44>EOF</span>

sudo modprobe overlay
sudo modprobe br_netfilter

<span style=color:#080;font-style:italic># 요구되는 sysctl 파라미터 설정, 이 설정은 재부팅 간에도 유지된다.</span>
cat <span style=color:#b44>&lt;&lt;EOF | sudo tee /etc/sysctl.d/99-kubernetes-cri.conf
</span><span style=color:#b44>net.bridge.bridge-nf-call-iptables  = 1
</span><span style=color:#b44>net.ipv4.ip_forward                 = 1
</span><span style=color:#b44>net.bridge.bridge-nf-call-ip6tables = 1
</span><span style=color:#b44>EOF</span>

sudo sysctl --system
</code></pre></div><ul class="nav nav-tabs" id=tab-cri-cri-o-installation role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tab-cri-cri-o-installation-0 role=tab aria-controls=tab-cri-cri-o-installation-0 aria-selected=true>Debian</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tab-cri-cri-o-installation-1 role=tab aria-controls=tab-cri-cri-o-installation-1>Ubuntu</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tab-cri-cri-o-installation-2 role=tab aria-controls=tab-cri-cri-o-installation-2>CentOS</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tab-cri-cri-o-installation-3 role=tab aria-controls=tab-cri-cri-o-installation-3>openSUSE Tumbleweed</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tab-cri-cri-o-installation-4 role=tab aria-controls=tab-cri-cri-o-installation-4>Fedora</a></li></ul>
<div class=tab-content id=tab-cri-cri-o-installation><div id=tab-cri-cri-o-installation-0 class="tab-pane show active" role=tabpanel aria-labelledby=tab-cri-cri-o-installation-0>
<p><p>다음의 운영 체제에서 CRI-O를 설치하려면, 환경 변수 <code>OS</code> 를
아래의 표에서 적절한 필드로 설정한다.</p>
<table>
<thead>
<tr>
<th>운영 체제</th>
<th><code>$OS</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>Debian Unstable</td>
<td><code>Debian_Unstable</code></td>
</tr>
<tr>
<td>Debian Testing</td>
<td><code>Debian_Testing</code></td>
</tr>
</tbody>
</table>
<p><br>
그런 다음, <code>$VERSION</code> 을 사용자의 쿠버네티스 버전과 일치하는 CRI-O 버전으로 설정한다.
예를 들어, CRI-O 1.20을 설치하려면, <code>VERSION=1.20</code> 로 설정한다.
사용자의 설치를 특정 릴리스에 고정할 수 있다.
버전 1.20.0을 설치하려면, <code>VERSION=1.20:1.20.0</code> 을 설정한다.
<br></p>
<p>그런 다음, 아래를 실행한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>cat <span style=color:#b44>&lt;&lt;EOF | sudo tee /etc/apt/sources.list.d/devel:kubic:libcontainers:stable.list
</span><span style=color:#b44>deb https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable/$OS/ /
</span><span style=color:#b44>EOF</span>
cat <span style=color:#b44>&lt;&lt;EOF | sudo tee /etc/apt/sources.list.d/devel:kubic:libcontainers:stable:cri-o:$VERSION.list
</span><span style=color:#b44>deb http://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable:/cri-o:/$VERSION/$OS/ /
</span><span style=color:#b44>EOF</span>

curl -L https://download.opensuse.org/repositories/devel:kubic:libcontainers:stable:cri-o:<span style=color:#b8860b>$VERSION</span>/<span style=color:#b8860b>$OS</span>/Release.key | sudo apt-key --keyring /etc/apt/trusted.gpg.d/libcontainers.gpg add -
curl -L https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable/<span style=color:#b8860b>$OS</span>/Release.key | sudo apt-key --keyring /etc/apt/trusted.gpg.d/libcontainers.gpg add -

sudo apt-get update
sudo apt-get install cri-o cri-o-runc
</code></pre></div></div>
<div id=tab-cri-cri-o-installation-1 class=tab-pane role=tabpanel aria-labelledby=tab-cri-cri-o-installation-1>
<p><p>다음의 운영 체제에서 CRI-O를 설치하려면, 환경 변수 <code>OS</code> 를
아래의 표에서 적절한 필드로 설정한다.</p>
<table>
<thead>
<tr>
<th>운영 체제</th>
<th><code>$OS</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>Ubuntu 20.04</td>
<td><code>xUbuntu_20.04</code></td>
</tr>
<tr>
<td>Ubuntu 19.10</td>
<td><code>xUbuntu_19.10</code></td>
</tr>
<tr>
<td>Ubuntu 19.04</td>
<td><code>xUbuntu_19.04</code></td>
</tr>
<tr>
<td>Ubuntu 18.04</td>
<td><code>xUbuntu_18.04</code></td>
</tr>
</tbody>
</table>
<p><br>
그런 다음, <code>$VERSION</code> 을 사용자의 쿠버네티스 버전과 일치하는 CRI-O 버전으로 설정한다.
예를 들어, CRI-O 1.20을 설치하려면, <code>VERSION=1.20</code> 로 설정한다.
사용자의 설치를 특정 릴리스에 고정할 수 있다.
버전 1.20.0을 설치하려면, <code>VERSION=1.20:1.20.0</code> 을 설정한다.
<br></p>
<p>그런 다음, 아래를 실행한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>cat <span style=color:#b44>&lt;&lt;EOF | sudo tee /etc/apt/sources.list.d/devel:kubic:libcontainers:stable.list
</span><span style=color:#b44>deb https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable/$OS/ /
</span><span style=color:#b44>EOF</span>
cat <span style=color:#b44>&lt;&lt;EOF | sudo tee /etc/apt/sources.list.d/devel:kubic:libcontainers:stable:cri-o:$VERSION.list
</span><span style=color:#b44>deb http://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable:/cri-o:/$VERSION/$OS/ /
</span><span style=color:#b44>EOF</span>

curl -L https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable/<span style=color:#b8860b>$OS</span>/Release.key | sudo apt-key --keyring /etc/apt/trusted.gpg.d/libcontainers.gpg add -
curl -L https://download.opensuse.org/repositories/devel:kubic:libcontainers:stable:cri-o:<span style=color:#b8860b>$VERSION</span>/<span style=color:#b8860b>$OS</span>/Release.key | sudo apt-key --keyring /etc/apt/trusted.gpg.d/libcontainers-cri-o.gpg add -

apt-get update
apt-get install cri-o cri-o-runc
</code></pre></div></div>
<div id=tab-cri-cri-o-installation-2 class=tab-pane role=tabpanel aria-labelledby=tab-cri-cri-o-installation-2>
<p><p>다음의 운영 체제에서 CRI-O를 설치하려면, 환경 변수 <code>OS</code> 를
아래의 표에서 적절한 필드로 설정한다.</p>
<table>
<thead>
<tr>
<th>운영 체제</th>
<th><code>$OS</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>Centos 8</td>
<td><code>CentOS_8</code></td>
</tr>
<tr>
<td>Centos 8 Stream</td>
<td><code>CentOS_8_Stream</code></td>
</tr>
<tr>
<td>Centos 7</td>
<td><code>CentOS_7</code></td>
</tr>
</tbody>
</table>
<p><br>
그런 다음, <code>$VERSION</code> 을 사용자의 쿠버네티스 버전과 일치하는 CRI-O 버전으로 설정한다.
예를 들어, CRI-O 1.20을 설치하려면, <code>VERSION=1.20</code> 로 설정한다.
사용자의 설치를 특정 릴리스에 고정할 수 있다.
버전 1.20.0을 설치하려면, <code>VERSION=1.20:1.20.0</code> 을 설정한다.
<br></p>
<p>그런 다음, 아래를 실행한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>sudo curl -L -o /etc/yum.repos.d/devel:kubic:libcontainers:stable.repo https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable/<span style=color:#b8860b>$OS</span>/devel:kubic:libcontainers:stable.repo
sudo curl -L -o /etc/yum.repos.d/devel:kubic:libcontainers:stable:cri-o:<span style=color:#b8860b>$VERSION</span>.repo https://download.opensuse.org/repositories/devel:kubic:libcontainers:stable:cri-o:<span style=color:#b8860b>$VERSION</span>/<span style=color:#b8860b>$OS</span>/devel:kubic:libcontainers:stable:cri-o:<span style=color:#b8860b>$VERSION</span>.repo
sudo yum install cri-o
</code></pre></div></div>
<div id=tab-cri-cri-o-installation-3 class=tab-pane role=tabpanel aria-labelledby=tab-cri-cri-o-installation-3>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>sudo zypper install cri-o
</code></pre></div></div>
<div id=tab-cri-cri-o-installation-4 class=tab-pane role=tabpanel aria-labelledby=tab-cri-cri-o-installation-4>
<p><p><code>$VERSION</code> 을 사용자의 쿠버네티스 버전과 일치하는 CRI-O 버전으로 설정한다.
예를 들어, CRI-O 1.20을 설치하려면, <code>VERSION=1.20</code> 로 설정한다.</p>
<p>사용할 수 있는 버전을 찾으려면 다음을 실행한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>sudo dnf module list cri-o
</code></pre></div><p>CRI-O는 Fedora에서 특정 릴리스를 고정하여 설치하는 방법은 지원하지 않는다.</p>
<p>그런 다음, 아래를 실행한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>sudo dnf module <span style=color:#a2f>enable</span> cri-o:<span style=color:#b8860b>$VERSION</span>
sudo dnf install cri-o
</code></pre></div></div></div>
<p>CRI-O를 시작한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>sudo systemctl daemon-reload
sudo systemctl <span style=color:#a2f>enable</span> crio --now
</code></pre></div><p>자세한 사항은 <a href=https://github.com/cri-o/cri-o/blob/master/install.md>CRI-O 설치 가이드</a>를
참고한다.</p>
<h4 id=cgroup-드라이버-1>cgroup 드라이버</h4>
<p>CRI-O는 기본적으로 systemd cgroup 드라이버를 사용한다. <code>cgroupfs</code> cgroup 드라이버로
전환하려면, <code>/etc/crio/crio.conf</code> 를 수정하거나 <code>/etc/crio/crio.conf.d/02-cgroup-manager.conf</code> 에
드롭-인(drop-in) 구성을 배치한다. 예를 들면, 다음과 같다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-toml data-lang=toml>[crio.runtime]
conmon_cgroup = <span style=color:#b44>&#34;pod&#34;</span>
cgroup_manager = <span style=color:#b44>&#34;cgroupfs&#34;</span>
</code></pre></div><p>또한 <code>cgroupfs</code> 와 함께 CRI-O를 사용할 때 <code>pod</code> 값으로 설정해야 하는
변경된 <code>conmon_cgroup</code> 에 유의한다. 일반적으로 kubelet(일반적으로 kubeadm을 통해 수행됨)과
CRI-O의 cgroup 드라이버 구성을 동기화 상태로
유지해야 한다.</p>
<h3 id=docker>도커 엔진</h3>
<p>도커 엔진은 모든 것을 시작한 컨테이너 런타임이다.
이전에는 간단히 도커로 알려졌던 이 컨테이너 런타임은 다양한 형태로 사용할 수 있다.
<a href=https://docs.docker.com/engine/install/>도커 엔진 설치하기</a>에서
이 런타임 설치의 옵션들을 확인할 수 있다.</p>
<p>도커 엔진은 쿠버네티스 1.23와 직접 호환되며, 이는 사용 중단된 <code>dockershim</code> 컴포넌트를 활용하기 때문에 가능하다.
더 많은 정보와 맥락을 보려면, <a href=/dockershim>Dockershim 사용 중단 FAQ</a>를 참고한다.</p>
<p>지원되는 <a class=glossary-tooltip title="Kubelet과 컨테이너 런타임을 통합시키기 위한 API" data-toggle=tooltip data-placement=top href=/ko/docs/concepts/overview/components/#%ec%bb%a8%ed%85%8c%ec%9d%b4%eb%84%88-%eb%9f%b0%ed%83%80%ec%9e%84 target=_blank aria-label="컨테이너 런타임 인터페이스">컨테이너 런타임 인터페이스</a>(CRI)를 통해
쿠버네티스에서 도커 엔진을 사용할 수 있게 해 주는
써드파티 어댑터를 찾아볼 수도 있다.</p>
<p>다음 CRI 어댑터는 도커 엔진과 함께 동작하도록 설계되었다.</p>
<ul>
<li>미란티스의 <a href=https://github.com/Mirantis/cri-dockerd><code>cri-dockerd</code></a></li>
</ul>
<h3 id=mcr>미란티스 컨테이너 런타임</h3>
<p><a href=https://docs.mirantis.com/mcr/20.10/overview.html>미란티스 컨테이너 런타임</a>(MCR)은 상용 컨테이너 런타임이며
이전에는 도커 엔터프라이즈 에디션으로 알려져 있었다.</p>
<p>오픈소스인 <a href=https://github.com/Mirantis/cri-dockerd><code>cri-dockerd</code></a> 컴포넌트를 이용하여 쿠버네티스에서 미란티스 컨테이너 런타임을 사용할 수 있으며,
이 컴포넌트는 MCR에 포함되어 있다.</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-00e1646f68aeb89f9722cf6f6cfcad94>2.2 - 배포 도구로 쿠버네티스 설치하기</h1>
</div>
<div class=td-content>
<h1 id=pg-a16f59f325a17cdeed324d5c889f7f73>2.2.1 - kubeadm으로 클러스터 구성하기</h1>
</div>
<div class=td-content>
<h1 id=pg-29e59491dd6118b23072dfe9ebb93323>2.2.1.1 - kubeadm 설치하기</h1>
<p><img src=/images/kubeadm-stacked-color.png align=right width=150px></img>
이 페이지에서는 <code>kubeadm</code> 툴박스 설치 방법을 보여준다.
이 설치 프로세스를 수행한 후 kubeadm으로 클러스터를 만드는 방법에 대한 자세한 내용은 <a href=/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/>kubeadm을 사용하여 클러스터 생성하기</a> 페이지를 참고한다.</p>
<h2 id=시작하기-전에>시작하기 전에</h2>
<ul>
<li>호환되는 리눅스 머신. 쿠버네티스 프로젝트는 데비안 기반 배포판, 레드햇 기반 배포판, 그리고 패키지 매니저를 사용하지 않는 경우에 대한 일반적인 가이드를 제공한다.</li>
<li>2 GB 이상의 램을 장착한 머신. (이 보다 작으면 사용자의 앱을 위한 공간이 거의 남지 않음)</li>
<li>2 이상의 CPU.</li>
<li>클러스터의 모든 머신에 걸친 전체 네트워크 연결. (공용 또는 사설 네트워크면 괜찮음)</li>
<li>모든 노드에 대해 고유한 호스트 이름, MAC 주소 및 product_uuid. 자세한 내용은 <a href=#verify-mac-address>여기</a>를 참고한다.</li>
<li>컴퓨터의 특정 포트들 개방. 자세한 내용은 <a href=#check-required-ports>여기</a>를 참고한다.</li>
<li>스왑의 비활성화. kubelet이 제대로 작동하게 하려면 <strong>반드시</strong> 스왑을 사용하지 않도록 설정한다.</li>
</ul>
<h2 id=verify-mac-address>MAC 주소 및 product_uuid가 모든 노드에 대해 고유한지 확인</h2>
<ul>
<li>사용자는 <code>ip link</code> 또는 <code>ifconfig -a</code> 명령을 사용하여 네트워크 인터페이스의 MAC 주소를 확인할 수 있다.</li>
<li>product_uuid는 <code>sudo cat /sys/class/dmi/id/product_uuid</code> 명령을 사용하여 확인할 수 있다.</li>
</ul>
<p>일부 가상 머신은 동일한 값을 가질 수 있지만 하드웨어 장치는 고유한 주소를 가질
가능성이 높다. 쿠버네티스는 이러한 값을 사용하여 클러스터의 노드를 고유하게 식별한다.
이러한 값이 각 노드에 고유하지 않으면 설치 프로세스가
<a href=https://github.com/kubernetes/kubeadm/issues/31>실패</a>할 수 있다.</p>
<h2 id=네트워크-어댑터-확인>네트워크 어댑터 확인</h2>
<p>네트워크 어댑터가 두 개 이상이고, 쿠버네티스 컴포넌트가 디폴트 라우트(default route)에서 도달할 수 없는
경우, 쿠버네티스 클러스터 주소가 적절한 어댑터를 통해 이동하도록 IP 경로를 추가하는 것이 좋다.</p>
<h2 id=iptables가-브리지된-트래픽을-보게-하기>iptables가 브리지된 트래픽을 보게 하기</h2>
<p><code>br_netfilter</code> 모듈이 로드되었는지 확인한다. <code>lsmod | grep br_netfilter</code> 를 실행하면 된다. 명시적으로 로드하려면 <code>sudo modprobe br_netfilter</code> 를 실행한다.</p>
<p>리눅스 노드의 iptables가 브리지된 트래픽을 올바르게 보기 위한 요구 사항으로, <code>sysctl</code> 구성에서 <code>net.bridge.bridge-nf-call-iptables</code> 가 1로 설정되어 있는지 확인해야 한다. 다음은 예시이다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>cat <span style=color:#b44>&lt;&lt;EOF | sudo tee /etc/modules-load.d/k8s.conf
</span><span style=color:#b44>br_netfilter
</span><span style=color:#b44>EOF</span>

cat <span style=color:#b44>&lt;&lt;EOF | sudo tee /etc/sysctl.d/k8s.conf
</span><span style=color:#b44>net.bridge.bridge-nf-call-ip6tables = 1
</span><span style=color:#b44>net.bridge.bridge-nf-call-iptables = 1
</span><span style=color:#b44>EOF</span>
sudo sysctl --system
</code></pre></div><p>자세한 내용은 <a href=/ko/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/#%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%ED%94%8C%EB%9F%AC%EA%B7%B8%EC%9D%B8-%EC%9A%94%EA%B5%AC-%EC%82%AC%ED%95%AD>네트워크 플러그인 요구 사항</a> 페이지를 참고한다.</p>
<h2 id=check-required-ports>필수 포트 확인</h2>
<p><a href=/ko/docs/reference/ports-and-protocols/>필수 포트들</a>은
쿠버네티스 컴포넌트들이 서로 통신하기 위해서 열려 있어야
한다. 다음과 같이 telnet 명령을 이용하여 포트가 열려 있는지 확인해 볼 수 있다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>telnet 127.0.0.1 <span style=color:#666>6443</span>
</code></pre></div><p>사용자가 사용하는 파드 네트워크 플러그인(아래 참조)은 특정 포트를 열어야 할 수도
있다. 이것은 각 파드 네트워크 플러그인마다 다르므로, 필요한 포트에 대한
플러그인 문서를 참고한다.</p>
<h2 id=installing-runtime>런타임 설치</h2>
<p>파드에서 컨테이너를 실행하기 위해, 쿠버네티스는
<a class=glossary-tooltip title="컨테이너 런타임은 컨테이너 실행을 담당하는 소프트웨어이다." data-toggle=tooltip data-placement=top href=/ko/docs/setup/production-environment/container-runtimes/ target=_blank aria-label="컨테이너 런타임">컨테이너 런타임</a>을 사용한다.</p>
<ul class="nav nav-tabs" id=container-runtime role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#container-runtime-0 role=tab aria-controls=container-runtime-0 aria-selected=true>리눅스 노드</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#container-runtime-1 role=tab aria-controls=container-runtime-1>다른 운영 체제</a></li></ul>
<div class=tab-content id=container-runtime><div id=container-runtime-0 class="tab-pane show active" role=tabpanel aria-labelledby=container-runtime-0>
<p><p>기본적으로, 쿠버네티스는
<a class=glossary-tooltip title="Kubelet과 컨테이너 런타임을 통합시키기 위한 API" data-toggle=tooltip data-placement=top href=/ko/docs/concepts/overview/components/#%ec%bb%a8%ed%85%8c%ec%9d%b4%eb%84%88-%eb%9f%b0%ed%83%80%ec%9e%84 target=_blank aria-label="컨테이너 런타임 인터페이스">컨테이너 런타임 인터페이스</a>(CRI)를
사용하여 사용자가 선택한 컨테이너 런타임과 인터페이스한다.</p>
<p>런타임을 지정하지 않으면, kubeadm은 잘 알려진 유닉스 도메인 소켓 목록을 검색하여
설치된 컨테이너 런타임을 자동으로 감지하려고 한다.
다음 표에는 컨테이너 런타임 및 관련 소켓 경로가 나열되어 있다.</p>
<table><caption style=display:none>컨테이너 런타임과 소켓 경로</caption>
<thead>
<tr>
<th>런타임</th>
<th>유닉스 도메인 소켓 경로</th>
</tr>
</thead>
<tbody>
<tr>
<td>도커</td>
<td><code>/var/run/dockershim.sock</code></td>
</tr>
<tr>
<td>containerd</td>
<td><code>/run/containerd/containerd.sock</code></td>
</tr>
<tr>
<td>CRI-O</td>
<td><code>/var/run/crio/crio.sock</code></td>
</tr>
</tbody>
</table>
<p><br>
도커와 containerd가 모두 감지되면 도커가 우선시된다. 이것이 필요한 이유는 도커 18.09에서
도커만 설치한 경우에도 containerd와 함께 제공되므로 둘 다 감지될 수 있기
때문이다.
다른 두 개 이상의 런타임이 감지되면, kubeadm은 오류와 함께 종료된다.</p>
<p>kubelet은 빌트인 <code>dockershim</code> CRI 구현을 통해 도커와 통합된다.</p>
<p>자세한 내용은 <a href=/ko/docs/setup/production-environment/container-runtimes/>컨테이너 런타임</a>을
참고한다.</p>
</div>
<div id=container-runtime-1 class=tab-pane role=tabpanel aria-labelledby=container-runtime-1>
<p><p>기본적으로, kubeadm은 컨테이너 런타임으로 <a class=glossary-tooltip title="Docker는 운영 시스템 수준의 가상화를 제공하는 소프트웨어 기술이며, 컨테이너로도 알려져 있다." data-toggle=tooltip data-placement=top href=https://docs.docker.com/engine/ target=_blank aria-label=도커(Docker)>도커(Docker)</a>를 사용한다.
kubelet은 빌트인 <code>dockershim</code> CRI 구현을 통해 도커와 통합된다.</p>
<p>자세한 내용은 <a href=/ko/docs/setup/production-environment/container-runtimes/>컨테이너 런타임</a>을
참고한다.</p>
</div></div>
<h2 id=kubeadm-kubelet-및-kubectl-설치>kubeadm, kubelet 및 kubectl 설치</h2>
<p>모든 머신에 다음 패키지들을 설치한다.</p>
<ul>
<li>
<p><code>kubeadm</code>: 클러스터를 부트스트랩하는 명령이다.</p>
</li>
<li>
<p><code>kubelet</code>: 클러스터의 모든 머신에서 실행되는 파드와 컨테이너 시작과
같은 작업을 수행하는 컴포넌트이다.</p>
</li>
<li>
<p><code>kubectl</code>: 클러스터와 통신하기 위한 커맨드 라인 유틸리티이다.</p>
</li>
</ul>
<p>kubeadm은 <code>kubelet</code> 또는 <code>kubectl</code> 을 설치하거나 관리하지 <strong>않으므로</strong>, kubeadm이
설치하려는 쿠버네티스 컨트롤 플레인의 버전과 일치하는지
확인해야 한다. 그렇지 않으면, 예상치 못한 버그 동작으로 이어질 수 있는
버전 차이(skew)가 발생할 위험이 있다. 그러나, kubelet과 컨트롤 플레인 사이에 <em>하나의</em>
마이너 버전 차이가 지원되지만, kubelet 버전은 API 서버 버전 보다
높을 수 없다. 예를 들어, 1.7.0 버전의 kubelet은 1.8.0 API 서버와 완전히 호환되어야 하지만,
그 반대의 경우는 아니다.</p>
<p><code>kubectl</code> 설치에 대한 정보는 <a href=/ko/docs/tasks/tools/>kubectl 설치 및 설정</a>을 참고한다.</p>
<div class="alert alert-danger warning callout" role=alert>
<strong>경고:</strong> 이 지침은 모든 시스템 업그레이드에서 모든 쿠버네티스 패키지를 제외한다.
이는 kubeadm 및 쿠버네티스를
<a href=/ko/docs/tasks/administer-cluster/kubeadm/kubeadm-upgrade/>업그레이드 하는 데 특별한 주의</a>가 필요하기 때문이다.
</div>
<p>버전 차이에 대한 자세한 내용은 다음을 참고한다.</p>
<ul>
<li>쿠버네티스 <a href=/ko/releases/version-skew-policy/>버전 및 버전-차이 정책</a></li>
<li>Kubeadm 관련 <a href=/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/#version-skew-policy>버전 차이 정책</a></li>
</ul>
<ul class="nav nav-tabs" id=k8s-install role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#k8s-install-0 role=tab aria-controls=k8s-install-0 aria-selected=true>데비안 기반 배포판</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#k8s-install-1 role=tab aria-controls=k8s-install-1>레드햇 기반 배포판</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#k8s-install-2 role=tab aria-controls=k8s-install-2>패키지 매니저를 사용하지 않는 경우</a></li></ul>
<div class=tab-content id=k8s-install><div id=k8s-install-0 class="tab-pane show active" role=tabpanel aria-labelledby=k8s-install-0>
<p><ol>
<li>
<p><code>apt</code> 패키지 색인을 업데이트하고, 쿠버네티스 <code>apt</code> 리포지터리를 사용하는 데 필요한 패키지를 설치한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>sudo apt-get update
sudo apt-get install -y apt-transport-https ca-certificates curl
</code></pre></div></li>
<li>
<p>구글 클라우드의 공개 사이닝 키를 다운로드 한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>sudo curl -fsSLo /usr/share/keyrings/kubernetes-archive-keyring.gpg https://packages.cloud.google.com/apt/doc/apt-key.gpg
</code></pre></div></li>
<li>
<p>쿠버네티스 <code>apt</code> 리포지터리를 추가한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#a2f>echo</span> <span style=color:#b44>&#34;deb [signed-by=/usr/share/keyrings/kubernetes-archive-keyring.gpg] https://apt.kubernetes.io/ kubernetes-xenial main&#34;</span> | sudo tee /etc/apt/sources.list.d/kubernetes.list
</code></pre></div></li>
<li>
<p><code>apt</code> 패키지 색인을 업데이트하고, kubelet, kubeadm, kubectl을 설치하고 해당 버전을 고정한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>sudo apt-get update
sudo apt-get install -y kubelet kubeadm kubectl
sudo apt-mark hold kubelet kubeadm kubectl
</code></pre></div></li>
</ol>
</div>
<div id=k8s-install-1 class=tab-pane role=tabpanel aria-labelledby=k8s-install-1>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>cat <span style=color:#b44>&lt;&lt;EOF | sudo tee /etc/yum.repos.d/kubernetes.repo
</span><span style=color:#b44>[kubernetes]
</span><span style=color:#b44>name=Kubernetes
</span><span style=color:#b44>baseurl=https://packages.cloud.google.com/yum/repos/kubernetes-el7-\$basearch
</span><span style=color:#b44>enabled=1
</span><span style=color:#b44>gpgcheck=1
</span><span style=color:#b44>repo_gpgcheck=1
</span><span style=color:#b44>gpgkey=https://packages.cloud.google.com/yum/doc/yum-key.gpg https://packages.cloud.google.com/yum/doc/rpm-package-key.gpg
</span><span style=color:#b44>exclude=kubelet kubeadm kubectl
</span><span style=color:#b44>EOF</span>

<span style=color:#080;font-style:italic># permissive 모드로 SELinux 설정(효과적으로 비활성화)</span>
sudo setenforce <span style=color:#666>0</span>
sudo sed -i <span style=color:#b44>&#39;s/^SELINUX=enforcing$/SELINUX=permissive/&#39;</span> /etc/selinux/config

sudo yum install -y kubelet kubeadm kubectl --disableexcludes<span style=color:#666>=</span>kubernetes

sudo systemctl <span style=color:#a2f>enable</span> --now kubelet
</code></pre></div><p><strong>참고:</strong></p>
<ul>
<li>
<p><code>setenforce 0</code> 및 <code>sed ...</code> 를 실행하여 permissive 모드로 SELinux를 설정하면 효과적으로 비활성화된다.
컨테이너가 호스트 파일시스템(예를 들어, 파드 네트워크에 필요한)에 접근하도록 허용하는 데 필요하다.
kubelet에서 SELinux 지원이 개선될 때까지 이 작업을 수행해야 한다.</p>
</li>
<li>
<p>구성 방법을 알고 있는 경우 SELinux를 활성화된 상태로 둘 수 있지만 kubeadm에서 지원하지 않는 설정이 필요할 수 있다.</p>
</li>
</ul>
</div>
<div id=k8s-install-2 class=tab-pane role=tabpanel aria-labelledby=k8s-install-2>
<p><p>CNI 플러그인 설치(대부분의 파드 네트워크에 필요)</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#b8860b>CNI_VERSION</span><span style=color:#666>=</span><span style=color:#b44>&#34;v0.8.2&#34;</span>
<span style=color:#b8860b>ARCH</span><span style=color:#666>=</span><span style=color:#b44>&#34;amd64&#34;</span>
sudo mkdir -p /opt/cni/bin
curl -L <span style=color:#b44>&#34;https://github.com/containernetworking/plugins/releases/download/</span><span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>CNI_VERSION</span><span style=color:#b68;font-weight:700>}</span><span style=color:#b44>/cni-plugins-linux-</span><span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>ARCH</span><span style=color:#b68;font-weight:700>}</span><span style=color:#b44>-</span><span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>CNI_VERSION</span><span style=color:#b68;font-weight:700>}</span><span style=color:#b44>.tgz&#34;</span> | sudo tar -C /opt/cni/bin -xz
</code></pre></div><p>명령어 파일을 다운로드할 디렉터리 정의</p>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> <code>DOWNLOAD_DIR</code> 변수는 쓰기 가능한 디렉터리로 설정되어야 한다.
Flatcar Container Linux를 실행 중인 경우, <code>DOWNLOAD_DIR=/opt/bin</code> 을 설정한다.
</div>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#b8860b>DOWNLOAD_DIR</span><span style=color:#666>=</span>/usr/local/bin
sudo mkdir -p <span style=color:#b8860b>$DOWNLOAD_DIR</span>
</code></pre></div><p>crictl 설치(kubeadm / Kubelet 컨테이너 런타임 인터페이스(CRI)에 필요)</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#b8860b>CRICTL_VERSION</span><span style=color:#666>=</span><span style=color:#b44>&#34;v1.22.0&#34;</span>
<span style=color:#b8860b>ARCH</span><span style=color:#666>=</span><span style=color:#b44>&#34;amd64&#34;</span>
curl -L <span style=color:#b44>&#34;https://github.com/kubernetes-sigs/cri-tools/releases/download/</span><span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>CRICTL_VERSION</span><span style=color:#b68;font-weight:700>}</span><span style=color:#b44>/crictl-</span><span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>CRICTL_VERSION</span><span style=color:#b68;font-weight:700>}</span><span style=color:#b44>-linux-</span><span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>ARCH</span><span style=color:#b68;font-weight:700>}</span><span style=color:#b44>.tar.gz&#34;</span> | sudo tar -C <span style=color:#b8860b>$DOWNLOAD_DIR</span> -xz
</code></pre></div><p><code>kubeadm</code>, <code>kubelet</code>, <code>kubectl</code> 설치 및 <code>kubelet</code> systemd 서비스 추가</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#b8860b>RELEASE</span><span style=color:#666>=</span><span style=color:#b44>&#34;</span><span style=color:#a2f;font-weight:700>$(</span>curl -sSL https://dl.k8s.io/release/stable.txt<span style=color:#a2f;font-weight:700>)</span><span style=color:#b44>&#34;</span>
<span style=color:#b8860b>ARCH</span><span style=color:#666>=</span><span style=color:#b44>&#34;amd64&#34;</span>
<span style=color:#a2f>cd</span> <span style=color:#b8860b>$DOWNLOAD_DIR</span>
sudo curl -L --remote-name-all https://storage.googleapis.com/kubernetes-release/release/<span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>RELEASE</span><span style=color:#b68;font-weight:700>}</span>/bin/linux/<span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>ARCH</span><span style=color:#b68;font-weight:700>}</span>/<span style=color:#666>{</span>kubeadm,kubelet,kubectl<span style=color:#666>}</span>
sudo chmod +x <span style=color:#666>{</span>kubeadm,kubelet,kubectl<span style=color:#666>}</span>

<span style=color:#b8860b>RELEASE_VERSION</span><span style=color:#666>=</span><span style=color:#b44>&#34;v0.4.0&#34;</span>
curl -sSL <span style=color:#b44>&#34;https://raw.githubusercontent.com/kubernetes/release/</span><span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>RELEASE_VERSION</span><span style=color:#b68;font-weight:700>}</span><span style=color:#b44>/cmd/kubepkg/templates/latest/deb/kubelet/lib/systemd/system/kubelet.service&#34;</span> | sed <span style=color:#b44>&#34;s:/usr/bin:</span><span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>DOWNLOAD_DIR</span><span style=color:#b68;font-weight:700>}</span><span style=color:#b44>:g&#34;</span> | sudo tee /etc/systemd/system/kubelet.service
sudo mkdir -p /etc/systemd/system/kubelet.service.d
curl -sSL <span style=color:#b44>&#34;https://raw.githubusercontent.com/kubernetes/release/</span><span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>RELEASE_VERSION</span><span style=color:#b68;font-weight:700>}</span><span style=color:#b44>/cmd/kubepkg/templates/latest/deb/kubeadm/10-kubeadm.conf&#34;</span> | sed <span style=color:#b44>&#34;s:/usr/bin:</span><span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>DOWNLOAD_DIR</span><span style=color:#b68;font-weight:700>}</span><span style=color:#b44>:g&#34;</span> | sudo tee /etc/systemd/system/kubelet.service.d/10-kubeadm.conf
</code></pre></div><p><code>kubelet</code> 활성화 및 시작</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>systemctl <span style=color:#a2f>enable</span> --now kubelet
</code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> Flatcar Container Linux 배포판은 <code>/usr</code> 디렉터리를 읽기 전용 파일시스템으로 마운트한다.
클러스터를 부트스트랩하기 전에, 쓰기 가능한 디렉터리를 구성하기 위한 추가 단계를 수행해야 한다.
쓰기 가능한 디렉터리를 설정하는 방법을 알아 보려면 <a href=/docs/setup/production-environment/tools/kubeadm/troubleshooting-kubeadm/#usr-mounted-read-only/>Kubeadm 문제 해결 가이드</a>를 참고한다.
</div>
</div></div>
<p>kubelet은 이제 kubeadm이 수행할 작업을 알려 줄 때까지 크래시루프(crashloop) 상태로
기다려야 하므로 몇 초마다 다시 시작된다.</p>
<h2 id=cgroup-드라이버-구성>cgroup 드라이버 구성</h2>
<p>컨테이너 런타임과 kubelet은
<a href=/ko/docs/setup/production-environment/container-runtimes/>"cgroup 드라이버"</a>라는 속성을 갖고 있으며,
cgroup 드라이버는 리눅스 머신의 cgroup 관리 측면에 있어서 중요하다.</p>
<div class="alert alert-danger warning callout" role=alert>
<strong>경고:</strong> <p>컨테이너 런타임과 kubelet의 cgroup 드라이버를 일치시켜야 하며, 그렇지 않으면 kubelet 프로세스에 오류가 발생한다.</p>
<p>더 자세한 사항은 <a href=/docs/tasks/administer-cluster/kubeadm/configure-cgroup-driver/>cgroup 드라이버 설정하기</a>를 참고한다.</p>
</div>
<h2 id=문제-해결>문제 해결</h2>
<p>kubeadm에 문제가 있는 경우, <a href=/docs/setup/production-environment/tools/kubeadm/troubleshooting-kubeadm/>문제 해결 문서</a>를 참고한다.</p>
<h2 id=다음-내용>다음 내용</h2>
<ul>
<li><a href=/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/>kubeadm을 사용하여 클러스터 생성</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-4c656c5eda3e1c06ad1aedebdc04a211>2.2.1.2 - kubeadm API로 컴포넌트 사용자 정의하기</h1>
<p>이 페이지는 kubeadm이 배포하는 컴포넌트(component)들을 사용자 정의하는 방법을 다룬다. 컨트롤 플레인 컴포넌트에
대해서는 <code>Cluster Configuration</code> 구조에서 플래그를 사용하거나 노드당 패치를 사용할 수 있다. kubelet과
kube-proxy의 경우, <code>KubeletConfiguration</code>과 <code>KubeProxyConfiguration</code>을 각각 사용할 수 있다.</p>
<p>이 모든 옵션이 kubeadm 구성 API를 통해 가용하다.
구성의 각 필드 상세 사항은
<a href=/docs/reference/config-api/kubeadm-config.v1beta3/>API 참조 페이지</a>에서 찾아볼 수 있다.</p>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> kubeadm의 CoreDNS 디플로이먼트 사용자 정의는 현재 제공되지 않는다.
<code>kube-system/coredns</code> <a class=glossary-tooltip title="키-값 쌍으로 기밀이 아닌 데이터를 저장하는 데 사용하는 API 오브젝트이다. 볼륨에서 환경 변수, 커맨드-라인 인수 또는 구성 파일로 사용될 수 있다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/configuration/configmap/ target=_blank aria-label=컨피그맵>컨피그맵</a>을 수동으로
패치하고, 그 이후에 CoreDNS <a class=glossary-tooltip title="파드는 클러스터에서 실행 중인 컨테이너의 집합을 나타낸다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/pods/ target=_blank aria-label=파드>파드</a>를 다시 생성해야 한다. 또는,
기본 CoreDNS 디플로이먼트를 생략하고 자체 변형(variant)을 배포할 수 있다.
더 자세한 사항은 <a href=/docs/reference/setup-tools/kubeadm/kubeadm-init/#init-phases>kubeadm에서 초기화 단계 사용하기</a>을 참고한다.
</div>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.12 [stable]</code>
</div>
<h2 id=clusterconfiguration-의-플래그로-컨트롤-플레인-사용자-정의하기><code>ClusterConfiguration</code>의 플래그로 컨트롤 플레인 사용자 정의하기</h2>
<p>kubeadm의 <code>ClusterConfiguration</code> 오브젝트는 API 서버, 컨트롤러매니저, 스케줄러, Etcd와 같은 컨트롤 플레인 컴포넌트에 전달되는
기본 플래그를 사용자가 덮어쓸 수 있도록 노출한다.
이 컴포넌트는 다음 구조체를 사용하여 정의된다.</p>
<ul>
<li><code>apiServer</code></li>
<li><code>controllerManager</code></li>
<li><code>scheduler</code></li>
<li><code>etcd</code></li>
</ul>
<p>이 구조체들은 공통 필드인 <code>extraArgs</code>를 포함하며, 이 필드는 <code>키: 값</code> 쌍으로 구성된다.
컨트롤 플레인 컴포넌트를 위한 플래그를 덮어쓰려면 다음을 수행한다.</p>
<ol>
<li>사용자 구성에 적절한 <code>extraArgs</code> 필드를 추가한다.</li>
<li><code>extraArgs</code> 필드에 플래그를 추가한다.</li>
<li><code>kubeadm init</code>에 <code>--config &lt;CONFIG YAML 파일></code> 파라미터를 추가해서 실행한다.</li>
</ol>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> <code>kubeadm config print init-defaults</code>를 실행하고 원하는 파일에 출력을
저장하여 기본값들로 구성된 <code>ClusterConfiguration</code> 오브젝트를 생성할 수 있다.
</div>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> <code>ClusterConfiguration</code> 오브젝트는 현재 kubeadm 클러스터에서 전역(global)으로 사용된다. 즉, 사용자가 추가하는 모든 플래그는
다른 노드에 있는 동일한 컴포넌트에도 모두 적용될 것이다. 다른 노드에서
컴포넌트별로 개별 구성을 적용하려면 <a href=#patches>패치</a>를 사용하면 된다.
</div>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> 플래그(키)를 복제하거나 동일한 플래그 <code>--foo</code>를 여러 번 전달하는 것은 현재 지원하지 않는다.
이 문제를 해결하려면 <a href=#patches>패치</a>를 사용해야 한다.
</div>
<h3 id=apiserver-플래그>APIServer 플래그</h3>
<p>자세한 내용은 <a href=/docs/reference/command-line-tools-reference/kube-apiserver/>kube-apiserver 레퍼런스 문서</a>를 확인한다.</p>
<p>사용 예시:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>kubeadm.k8s.io/v1beta3<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kubernetesVersion</span>:<span style=color:#bbb> </span>v1.16.0<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiServer</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>extraArgs</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>anonymous-auth</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;false&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>enable-admission-plugins</span>:<span style=color:#bbb> </span>AlwaysPullImages,DefaultStorageClass<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>audit-log-path</span>:<span style=color:#bbb> </span>/home/johndoe/audit.log<span style=color:#bbb>
</span></code></pre></div><h3 id=컨트롤러매니저-플래그>컨트롤러매니저 플래그</h3>
<p>자세한 내용은 <a href=/docs/reference/command-line-tools-reference/kube-controller-manager/>kube-controller-manager 레퍼런스 문서</a>를 확인한다.</p>
<p>사용 예시:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>kubeadm.k8s.io/v1beta3<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kubernetesVersion</span>:<span style=color:#bbb> </span>v1.16.0<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>controllerManager</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>extraArgs</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>cluster-signing-key-file</span>:<span style=color:#bbb> </span>/home/johndoe/keys/ca.key<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>deployment-controller-sync-period</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;50&#34;</span><span style=color:#bbb>
</span></code></pre></div><h3 id=스케줄러-플래그>스케줄러 플래그</h3>
<p>자세한 내용은 <a href=/docs/reference/command-line-tools-reference/kube-scheduler/>kube-scheduler 레퍼런스 문서</a>를 확인한다.</p>
<p>사용 예시:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>kubeadm.k8s.io/v1beta3<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kubernetesVersion</span>:<span style=color:#bbb> </span>v1.16.0<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>scheduler</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>extraArgs</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>config</span>:<span style=color:#bbb> </span>/etc/kubernetes/scheduler-config.yaml<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>extraVolumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>schedulerconfig<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>hostPath</span>:<span style=color:#bbb> </span>/home/johndoe/schedconfig.yaml<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/etc/kubernetes/scheduler-config.yaml<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>pathType</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;File&#34;</span><span style=color:#bbb>
</span></code></pre></div><h3 id=etcd-플래그>Etcd 플래그</h3>
<p>자세한 사항은 <a href=https://etcd.io/docs/>etcd 서버 문서</a>를 확인한다.</p>
<p>사용 예시:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>kubeadm.k8s.io/v1beta3<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>etcd</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>local</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>extraArgs</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>election-timeout</span>:<span style=color:#bbb> </span><span style=color:#666>1000</span><span style=color:#bbb>
</span></code></pre></div><h2 id=patches>패치를 통해 컨트롤 플레인 사용자 정의하기</h2>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.22 [beta]</code>
</div>
<p>Kubeadm을 사용하면 패치 파일이 있는 디렉토리를 개별 노드에 대한 <code>InitConfiguration</code>과 <code>JoinConfiguration</code>에
전달할 수 있다. 이 패치는 컨트롤 플레인 컴포넌트 메니패스트가 디스크에 기록되기 전에
최종 사용자 정의 단계로 사용될 수 있다.</p>
<p><code>--config &lt;YOUR CONFIG YAML></code>을 사용하여 이 파일을 <code>kubeadm init</code>에 전달할 수 있다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>kubeadm.k8s.io/v1beta3<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>InitConfiguration<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>patches</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>directory</span>:<span style=color:#bbb> </span>/home/user/somedir<span style=color:#bbb>
</span></code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> <code>kubeadm init</code>의 경우, <code>---</code>로 구분된 <code>ClusterConfiguration</code>과 <code>InitConfiguration</code>을 모두
포함하는 파일을 전달할 수 있다.
</div>
<p><code>--config &lt;YOUR CONFIG YAML></code>을 사용하여 이 파일을 <code>kubeadm join</code>에 전달할 수 있다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>kubeadm.k8s.io/v1beta3<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>JoinConfiguration<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>patches</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>directory</span>:<span style=color:#bbb> </span>/home/user/somedir<span style=color:#bbb>
</span></code></pre></div><p>디렉토리는 <code>target[suffix][+patchtype].extension</code> 형태의 파일을 포함해야 한다.
예를 들면, <code>kube-apiserver0+merge.yaml</code> 또는 단순히 <code>etcd.json</code>의 형태이다.</p>
<ul>
<li><code>target</code>은 <code>kube-apiserver</code>, <code>kube-controller-manager</code>, <code>kube-scheduler</code> 그리고 <code>etcd</code> 중 하나가 될 수 있다.</li>
<li><code>patchtype</code>은 <code>strategic</code>, <code>merge</code> 그리고 <code>json</code> 중 하나가 될 수 있으며
<a href=/docs/tasks/manage-kubernetes-objects/update-api-object-kubectl-patch>kubectl에서 지원하는</a> 패치 형식을 준수해야 한다.
<code>patchtype</code>의 기본값은 <code>strategic</code>이다.</li>
<li><code>extension</code>은 <code>json</code> 또는 <code>yaml</code> 중 하나여야 한다.</li>
<li><code>suffix</code>는 어떤 패치가 먼저 적용되는지를 결정하는 데 사용할 수 있는 영숫자 형태의
선택적 문자열이다.</li>
</ul>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> <code>kubeadm upgrade</code>를 사용하여 kubeadm 노드를 업그레이드하는 경우, 업그레이드 이후에도
사용자 정의를 유지하려면 동일한 패치를 다시 제공해야 한다. 이는 동일한 디렉토리로 지정된 <code>--patches</code>
플래그를 사용하여 처리할 수 있다. <code>kubeadm upgrade</code>는 동일 목적으로 재사용할 수 있는 구성
API 구조를 현재는 지원하지 않는다.
</div>
<h2 id=kubelet-사용자-정의하기>kubelet 사용자 정의하기</h2>
<p>kubelet을 사용자 정의하려면, <code>KubeletConfiguration</code>을 동일한 구성 파일 내에서 <code>---</code>로 구분된 <code>ClusterConfiguration</code>이나 <code>InitConfiguration</code> 다음에 추가하면
된다. 그런 다음 <code>kubeadm init</code>에 해당 파일을 전달한다.</p>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> kubeadm은 클러스터의 모든 노드에 동일한 <code>KubeletConfiguration</code>을 적용한다. 노드별 설정을
적용하려면 kubelet 플래그를 덮어쓰기(overrides)로 사용하여, <code>InitConfiguration</code> 및
<code>JoinConfiguration</code> 모두에서 지원되는 <code>nodeRegistration.kubeletExtraArgs</code>에 전달할 수 있다.
일부 kubelet 플래그는 더 이상 사용되지 않는다(deprecated). 따라서 사용하기 전에 <a href=/docs/reference/command-line-tools-reference/kubelet>kubelet 참조 문서</a>를 통해
상태를 확인해야 한다.
</div>
<p>자세한 사항은 <a href=/docs/setup/production-environment/tools/kubeadm/kubelet-integration>kubeadm을 통해 클러스터의 각 kubelet 구성하기</a>에서 살펴본다.</p>
<h2 id=kube-proxy-사용자-정의하기>kube-proxy 사용자 정의하기</h2>
<p>kube-proxy를 사용자 정의하려면, <code>KubeProxyConfiguration</code>을 <code>---</code>로 구분된 <code>ClusterConfiguration</code>이나 <code>InitConfiguration</code>
다음에 두고 <code>kubeadm init</code>에 전달하면 된다.</p>
<p>자세한 사항은 <a href=/docs/reference/config-api/kubeadm-config.v1beta3/>API 참조 페이지</a>에서 살펴볼 수 있다.</p>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> kubeadm은 kube-proxy를 <a class=glossary-tooltip title="파드의 복제본을 클러스터 노드 집합에서 동작하게 한다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/controllers/daemonset target=_blank aria-label=데몬셋>데몬셋</a>으로 배포한다. 이것은
<code>KubeProxyConfiguration</code>이 클러스터의 모든 kube-proxy 인스턴스에 적용된다는 것을 의미한다.
</div>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-015edbc7cc688d31b1d1edce7c186135>2.2.1.3 - 고가용성 토폴로지 선택</h1>
<p>이 페이지는 고가용성(HA) 쿠버네티스 클러스터의 토플로지를 구성하는 두 가지 선택 사항을 설명한다.</p>
<p>다음과 같이 HA 클러스터를 구성할 수 있다.</p>
<ul>
<li>etcd 노드와 컨트롤 플레인 노드를 함께 위치시키는 중첩된(stacked) 컨트롤 플레인 노드 방식</li>
<li>etcd와 컨트롤 플레인이 분리된 노드에서 운영되는 외부 etcd 노드 방식</li>
</ul>
<p>HA 클러스터를 구성하기 전에 각 토플로지의 장단점을 주의 깊게 고려해야 한다.</p>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> kubeadm은 etcd 클러스터를 정적으로 부트스트랩한다. 자세한 내용은 etcd <a href=https://github.com/etcd-io/etcd/blob/release-3.4/Documentation/op-guide/clustering.md#static>클러스터 구성 가이드</a>
를 읽는다.
</div>
<h2 id=중첩된-etcd-토플로지>중첩된 etcd 토플로지</h2>
<p>중첩된 HA 클러스터는 etcd에서 제공하는 분산 데이터 저장소 클러스터를,
컨트롤 플레인 구성 요소를 실행하는 kubeadm으로 관리되는 노드에 의해서 형성된 클러스터 상단에
중첩하는 <a href=https://en.wikipedia.org/wiki/Network_topology>토플로지</a>이다.</p>
<p>각 컨트롤 플레인 노드는 <code>kube-apiserver</code>, <code>kube-scheduler</code>, <code>kube-controller-manager</code> 인스턴스를 운영한다.
<code>kube-apiserver</code>는 로드 밸런서를 이용하여 워커 노드에 노출되어 있다.</p>
<p>각 컨트롤 플레인 노드는 지역 etcd 맴버를 생성하고
이 etcd 맴버는 오직 해당 노드의 <code>kube-apiserver</code>와 통신한다.
비슷한 방식이 지역의 <code>kube-controller-manager</code>와 <code>kube-scheduler</code>에도 적용된다.</p>
<p>이 토플로지는 컨트롤 플레인과 etcd 맴버가 같은 노드에 묶여 있다.
이는 외부 etcd 노드의 클러스터를 구성하는 것보다는 단순하며 복제 관리도 간단하다.</p>
<p>그러나 중첩된 클러스터는 커플링에 실패할 위험이 있다. 한 노드가 다운되면 etcd 맴버와 컨트롤 플레인을 모두 잃어버리고,
중복성도 손상된다. 더 많은 컨트롤 플레인 노드를 추가하여 이 위험을 완화할 수 있다.</p>
<p>그러므로 HA 클러스터를 위해 최소 3개인 중첩된 컨트롤 플레인 노드를 운영해야 한다.</p>
<p>이는 kubeadm의 기본 토플로지이다. 지역 etcd 맴버는
<code>kubeadm init</code>와 <code>kubeadm join --control-plane</code> 을 이용할 때에 컨트롤 플레인 노드에 자동으로 생성된다.</p>
<p><img src=/images/kubeadm/kubeadm-ha-topology-stacked-etcd.svg alt="중첩된 etcd 토플로지"></p>
<h2 id=외부-etcd-토플로지>외부 etcd 토플로지</h2>
<p>외부 etcd를 이용하는 HA 클러스터는 etcd로 제공한 분산된 데이터 스토리지 클러스터가 컨트롤 플레인 구성 요소를 운영하는 노드로 형성하는 클러스터의 외부에 있는 <a href=https://en.wikipedia.org/wiki/Network_topology>토플로지</a>이다.</p>
<p>중첩된 etcd 토플로지와 유사하게, 외부 etcd 토플로지에 각 컨트롤 플레인 노드는 <code>kube-apiserver</code>, <code>kube-scheduler</code>, <code>kube-controller-manager</code>의 인스턴스를 운영한다. 그리고 <code>kube-apiserver</code>는 로드 밸런서를 이용하여 워커노드에 노출한다. 그러나 etcd 맴버는 분리된 호스트에서 운영되고, 각 etcd 호스트는 각 컨트롤 플레인 노드의 <code>kube-apiserver</code>와 통신한다.</p>
<p>이 토플로지는 컨트롤 플레인과 etcd 맴버를 분리한다. 이는 그러므로
컨트롤 플레인 인스턴스나 etcd 맴버를 잃는 충격이 덜하고,
클러스터 중복성에 있어 중첩된 HA 토플로지만큼 영향을 미치지 않는다.</p>
<p>그러나, 이 토플로지는 중첩된 토플로지에 비해 호스트 개수가 두배나 필요하다.
이 토플로지로 HA 클러스터를 구성하기 위해서는 최소한 3개의 컨트롤 플레인과 3개의 etcd 노드가 필요하다.</p>
<p><img src=/images/kubeadm/kubeadm-ha-topology-external-etcd.svg alt="외부 etcd 토플로지"></p>
<h2 id=다음-내용>다음 내용</h2>
<ul>
<li><a href=/docs/setup/production-environment/tools/kubeadm/high-availability/>kubeadm을 이용하여 고가용성 클러스터 구성하기</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-478acca1934b6d89a0bc00fb25bfe5b6>2.2.2 - Kops로 쿠버네티스 설치하기</h1>
<p>이곳 빠른 시작에서는 사용자가 얼마나 쉽게 AWS에 쿠버네티스 클러스터를 설치할 수 있는지 보여준다.
<a href=https://github.com/kubernetes/kops><code>kops</code></a>라는 이름의 툴을 이용할 것이다.</p>
<p>kops는 자동화된 프로비저닝 시스템인데,</p>
<ul>
<li>완전 자동화된 설치</li>
<li>DNS를 통해 클러스터들의 신원 확인</li>
<li>자체 복구: 모든 자원이 Auto-Scaling Groups에서 실행</li>
<li>다양한 OS 지원(Debian, Ubuntu 16.04 supported, CentOS & RHEL, Amazon Linux and CoreOS) - <a href=https://github.com/kubernetes/kops/blob/master/docs/operations/images.md>images.md</a> 보기</li>
<li>고가용성 지원 - <a href=https://github.com/kubernetes/kops/blob/master/docs/operations/high_availability.md>high_availability.md</a> 보기</li>
<li>직접 프로비저닝 하거나 또는 할 수 있도록 terraform 매니페스트를 생성 - <a href=https://github.com/kubernetes/kops/blob/master/docs/terraform.md>terraform.md</a> 보기</li>
</ul>
<h2 id=시작하기-전에>시작하기 전에</h2>
<ul>
<li>
<p><a href=/ko/docs/tasks/tools/>kubectl</a>을 반드시 설치해야 한다.</p>
</li>
<li>
<p>반드시 64-bit (AMD64 그리고 Intel 64)디바이스 아키텍쳐 위에서 <code>kops</code> 를 <a href=https://github.com/kubernetes/kops#installing>설치</a> 한다.</p>
</li>
<li>
<p><a href=https://docs.aws.amazon.com/polly/latest/dg/setting-up.html>AWS 계정</a>이 있고 <a href=https://docs.aws.amazon.com/general/latest/gr/aws-sec-cred-types.html#access-keys-and-secret-access-keys>IAM 키</a>를 생성하고 <a href=https://docs.aws.amazon.com/cli/latest/userguide/cli-chap-configure.html#cli-quick-configuration>구성</a>해야 한다. IAM 사용자는 <a href=https://github.com/kubernetes/kops/blob/master/docs/getting_started/aws.md#setup-iam-user>적절한 권한</a>이 필요하다.</p>
</li>
</ul>
<h2 id=클러스터-구축>클러스터 구축</h2>
<h3 id=1-5-kops-설치>(1/5) kops 설치</h3>
<h4 id=설치>설치</h4>
<p><a href=https://github.com/kubernetes/kops/releases>releases page</a>에서 kops를 다운로드한다(소스 코드로부터 빌드하는 것도 역시 편리하다).</p>
<ul class="nav nav-tabs" id=kops-installation role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#kops-installation-0 role=tab aria-controls=kops-installation-0 aria-selected=true>macOS</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#kops-installation-1 role=tab aria-controls=kops-installation-1>리눅스</a></li></ul>
<div class=tab-content id=kops-installation><div id=kops-installation-0 class="tab-pane show active" role=tabpanel aria-labelledby=kops-installation-0>
<p><p>최신 버전의 릴리스를 다운받는 명령어:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>curl -LO https://github.com/kubernetes/kops/releases/download/<span style=color:#a2f;font-weight:700>$(</span>curl -s https://api.github.com/repos/kubernetes/kops/releases/latest
| grep tag_name | cut -d <span style=color:#b44>&#39;&#34;&#39;</span> -f 4<span style=color:#a2f;font-weight:700>)</span>/kops-darwin-amd64
</code></pre></div><p>특정 버전을 다운로드 받는다면 명령의 다음 부분을 특정 kops 버전으로 변경한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#a2f;font-weight:700>$(</span>curl -s https://api.github.com/repos/kubernetes/kops/releases/latest | grep tag_name | cut -d <span style=color:#b44>&#39;&#34;&#39;</span> -f 4<span style=color:#a2f;font-weight:700>)</span>
</code></pre></div><p>예를 들어 kops 버전을 v1.20.0을 다운로드 하려면 다음을 입력한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>curl -LO https://github.com/kubernetes/kops/releases/download/v1.20.0/kops-darwin-amd64
</code></pre></div><p>kops 바이너리를 실행 가능하게 만든다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>chmod +x kops-darwin-amd64
</code></pre></div><p>kops 바이너리를 사용자의 PATH로 이동한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>sudo mv kops-darwin-amd64 /usr/local/bin/kops
</code></pre></div><p>사용자는 <a href=https://brew.sh/>Homebrew</a>를 이용해서 kops를 설치할 수 있다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>brew update <span style=color:#666>&amp;&amp;</span> brew install kops
</code></pre></div></div>
<div id=kops-installation-1 class=tab-pane role=tabpanel aria-labelledby=kops-installation-1>
<p><p>최신 릴리스를 다운로드 받는 명령어:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>curl -LO https://github.com/kubernetes/kops/releases/download/<span style=color:#a2f;font-weight:700>$(</span>curl -s https://api.github.com/repos/kubernetes/kops/releases/latest | grep tag_name | cut -d <span style=color:#b44>&#39;&#34;&#39;</span> -f 4<span style=color:#a2f;font-weight:700>)</span>/kops-linux-amd64
</code></pre></div><p>특정 버전의 kops를 다운로드하려면 명령의 다음 부분을 특정 kops 버전으로 변경한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#a2f;font-weight:700>$(</span>curl -s https://api.github.com/repos/kubernetes/kops/releases/latest | grep tag_name | cut -d <span style=color:#b44>&#39;&#34;&#39;</span> -f 4<span style=color:#a2f;font-weight:700>)</span>
</code></pre></div><p>예를 들어 kops 버전을 v1.20.0을 다운로드 하려면 다음을 입력한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>curl -LO https://github.com/kubernetes/kops/releases/download/v1.20.0/kops-linux-amd64
</code></pre></div><p>kops 바이너리를 실행 가능하게 만든다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>chmod +x kops-linux-amd64
</code></pre></div><p>kops 바이너리를 사용자의 PATH로 이동한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>sudo mv kops-linux-amd64 /usr/local/bin/kops
</code></pre></div><p>사용자는 <a href=https://docs.brew.sh/Homebrew-on-Linux>Homebrew</a>를 이용해서 kops를 설치할 수 있다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>brew update <span style=color:#666>&amp;&amp;</span> brew install kops
</code></pre></div></div></div>
<h3 id=2-5-클러스터에-사용할-route53-domain-생성>(2/5) 클러스터에 사용할 route53 domain 생성</h3>
<p>kops는 클러스터 내부와 외부 모두에서 검색을 위해 DNS을 사용하기에 클라이언트에서 쿠버네티스 API 서버에 연결할
수 있다.</p>
<p>이런 클러스터 이름에 kops는 명확한 견해을 가지는데: 반드시 유효한 DNS 이름이어야 한다. 이렇게 함으로써
사용자는 클러스터를 헷갈리지 않을것이고, 동료들과 혼선없이 공유할 수 있으며,
IP를 기억할 필요없이 접근할 수 있다.</p>
<p>그렇게 하고 있겠지만, 클러스터를 구분하기 위해 서브도메인을 활용할 수 있다. 예를 들어
<code>useast1.dev.example.com</code>을 이용한다면, API 서버 엔드포인트는 <code>api.useast1.dev.example.com</code>가 될 것이다.</p>
<p>Route53 hosted zone은 서브도메인도 지원한다. 여러분의 hosted zone은 <code>useast1.dev.example.com</code>,
<code>dev.example.com</code> 그리고 <code>example.com</code> 같은 것도 될 수 있다. kops는 이것들 모두와 잘 동작하며,
사용자는 보통 조직적인 부분을 고려해 결정한다(예를 들어, 사용자가 <code>dev.example.com</code>하위에 레코드를 생성하는것은 허용되지만,
<code>example.com</code>하위에는 그렇지 않을 수 있다).</p>
<p><code>dev.example.com</code>을 hosted zone으로 사용하고 있다고 가정해보자.
보통 사용자는 <a href=https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/CreatingNewSubdomain.html>일반적인 방법</a> 에 따라 생성하거나
<code>aws route53 create-hosted-zone --name dev.example.com --caller-reference 1</code> 와 같은 커맨드를 이용한다.</p>
<p>그 후 도메인 내 레코드들을 확인할 수 있도록 상위 도메인내에 NS 레코드를 생성해야 한다. 여기서는,
<code>dev</code> NS 레코드를 <code>example.com</code>에 생성한다. 만약 이것이 루트 도메인 네임이라면 이 NS 레코드들은
도메인 등록기관을 통해서 생성해야 한다(예를 들어, <code>example.com</code>는 <code>example.com</code>를 구매한 곳에서 설정 할 수 있다).</p>
<p>route53 도메인 설정을 확인한다(문제를 만드는 가장 큰 이유이다!). dig 툴을 실행해서
클러스터 설정이 정확한지 한번 더 확인한다.</p>
<p><code>dig NS dev.example.com</code></p>
<p>당신의 hosted zone용으로 할당된 3~4개의 NS 레코드를 Route53에서 확인할 수 있어야 한다.</p>
<h3 id=3-5-클러스터-상태-저장용-s3-버킷-생성>(3/5) 클러스터 상태 저장용 S3 버킷 생성</h3>
<p>kops는 설치 이후에도 클러스터를 관리할 수 있다. 이를 위해 사용자가 생성한 클러스터의 상태나
사용하는 키 정보들을 지속적으로 추적해야 한다. 이 정보가 S3에 저장된다.
이 버킷의 접근은 S3 권한으로 제어한다.</p>
<p>다수의 클러스터는 동일한 S3 버킷을 이용할 수 있고, 사용자는 이 S3 버킷을 같은 클러스트를
운영하는 동료에게 공유할 수 있다. 하지만 이 S3 버킷에 접근 가능한 사람은 사용자의
모든 클러스터에 관리자 접근이 가능하게 되니, 운영팀 이외로
공유되지 않도록 해야 한다.</p>
<p>그래서 보통 한 운영팀 당 하나의 S3 버킷을 가지도록 하기도 한다.(그리고 종종 운영팀
이름은 위에서 언급한 hosted zone과 동일하게 짓기도 한다!)</p>
<p>우리 예제에서는, <code>dev.example.com</code>를 hosted zone으로 했으니 <code>clusters.dev.example.com</code>를
S3 버킷 이름으로 정하자.</p>
<ul>
<li>
<p><code>AWS_PROFILE</code>를 선언한다. (AWS CLI 동작을 위해 다른 profile을 선택해야 할 경우)</p>
</li>
<li>
<p><code>aws s3 mb s3://clusters.dev.example.com</code>를 이용해 S3 버킷을 생성한다.</p>
</li>
<li>
<p><code>export KOPS_STATE_STORE=s3://clusters.dev.example.com</code> 하면, kops는 이 위치를 기본값으로 인식할 것이다.
이 부분을 bash profile등에 넣어두는것을 권장한다.</p>
</li>
</ul>
<h3 id=4-5-클러스터-설정-구성>(4/5) 클러스터 설정 구성</h3>
<p>클러스터 설정하려면, <code>kops create cluster</code> 를 실행한다:</p>
<p><code>kops create cluster --zones=us-east-1c useast1.dev.example.com</code></p>
<p>kops는 클러스터에 사용될 설정을 생성할것이다. 여기서 주의할 점은 실제 클러스트 리소스가 아닌 <em>설정</em>
만을 생성한다는 것에 주의하자 - 이 부분은 다음 단계에서 <code>kops update cluster</code> 으로
구성해볼 것이다. 그 때 만들어진 설정을 점검하거나 변경할 수 있다.</p>
<p>더 자세한 내용을 알아보기 위한 커맨드가 출력된다.</p>
<ul>
<li>클러스터 조회: <code>kops get cluster</code></li>
<li>클러스트 수정: <code>kops edit cluster useast1.dev.example.com</code></li>
<li>인스턴스 그룹 수정: <code>kops edit ig --name=useast1.dev.example.com nodes</code></li>
<li>마스터 인스턴스 그룹 수정: <code>kops edit ig --name=useast1.dev.example.com master-us-east-1c</code></li>
</ul>
<p>만약 kops사용이 처음이라면, 얼마 걸리지 않으니 이들을 시험해 본다. 인스턴스 그룹은
쿠버네티스 노드로 등록된 인스턴스의 집합을 말한다. AWS상에서는 auto-scaling-groups를
통해 만들어진다. 사용자는 여러 개의 인스턴스 그룹을 관리할 수 있는데,
예를 들어, spot과 on-demand 인스턴스 조합 또는 GPU 와 non-GPU 인스턴스의 조합으로 구성할 수 있다.</p>
<h3 id=5-5-aws에-클러스터-생성>(5/5) AWS에 클러스터 생성</h3>
<p><code>kops update cluster</code>를 실행해 AWS에 클러스터를 생성한다.</p>
<p><code>kops update cluster useast1.dev.example.com --yes</code></p>
<p>실행은 수 초 만에 되지만, 실제로 클러스터가 준비되기 전까지 수 분이 걸릴 수 있다.
언제든 <code>kops update cluster</code>로 클러스터 설정을 변경할 수 있다. 사용자가
변경한 클러스터 설정을 그대로 반영해 줄 것이며, 필요다하면 AWS 나 쿠버네티스를 재설정 해 줄것이다.</p>
<p>예를 들면, <code>kops edit ig nodes</code> 뒤에 <code>kops update cluster --yes</code>를 실행해 설정을 반영한다.
그리고 <code>kops rolling-update cluster</code>로 설정을 즉시 원복시킬 수 있다.</p>
<p><code>--yes</code>를 명시하지 않으면 <code>kops update cluster</code> 커맨드 후 어떤 설정이 변경될지가 표시된다.
운영계 클러스터 관리할 때 사용하기 좋다!</p>
<h3 id=다른-애드온-탐험>다른 애드온 탐험</h3>
<p><a href=/ko/docs/concepts/cluster-administration/addons/>애드온 리스트</a> 에서 쿠버네티스 클러스터용 로깅, 모니터링, 네트워크 정책, 시각화 & 제어 등을 포함한 다른 애드온을 확인해본다.</p>
<h2 id=정리하기>정리하기</h2>
<ul>
<li><code>kops delete cluster useast1.dev.example.com --yes</code> 로 클러스터를 삭제한다.</li>
</ul>
<h2 id=다음-내용>다음 내용</h2>
<ul>
<li>쿠버네티스 <a href=/ko/docs/concepts/>개념</a> 과 <a href=/ko/docs/reference/kubectl/overview/><code>kubectl</code></a>에 대해 더 알아보기.</li>
<li>튜토리얼, 모범사례 및 고급 구성 옵션에 대한 <code>kops</code> <a href=https://kops.sigs.k8s.io/>고급 사용법</a>에 대해 더 자세히 알아본다.</li>
<li>슬랙(Slack)에서 <code>kops</code> 커뮤니티 토론을 할 수 있다: <a href=https://github.com/kubernetes/kops#other-ways-to-communicate-with-the-contributors>커뮤니티 토론</a></li>
<li>문제를 해결하거나 이슈를 제기하여 <code>kops</code> 에 기여한다. <a href=https://github.com/kubernetes/kops/issues>깃헙 이슈</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-f8b4964187fe973644e06ee629eff1de>2.2.3 - Kubespray로 쿠버네티스 설치하기</h1>
<p>이 가이드는 <a href=https://github.com/kubernetes-sigs/kubespray>Kubespray</a>를 이용하여 GCE, Azure, OpenStack, AWS, vSphere, Packet(베어메탈), Oracle Cloud infrastructure(실험적) 또는 베어메탈 등에서 운영되는 쿠버네티스 클러스터를 설치하는 과정을 보여준다.</p>
<p>Kubespray는 <a href=https://docs.ansible.com/>Ansible</a> 플레이북, <a href=https://github.com/kubernetes-sigs/kubespray/blob/master/docs/ansible.md>인벤토리</a>, 프로비저닝 도구와 일반적인 운영체제, 쿠버네티스 클러스터의 설정 관리 작업에 대한 도메인 지식의 결합으로 만들어졌다. Kubespray는 아래와 같은 기능을 제공한다.</p>
<ul>
<li>고가용성을 지닌 클러스터</li>
<li>구성할 수 있는 속성들</li>
<li>대부분의 인기있는 리눅스 배포판들에 대한 지원
<ul>
<li>Ubuntu 16.04, 18.04, 20.04</li>
<li>CentOS/RHEL/Oracle Linux 7, 8</li>
<li>Debian Buster, Jessie, Stretch, Wheezy</li>
<li>Fedora 31, 32</li>
<li>Fedora CoreOS</li>
<li>openSUSE Leap 15</li>
<li>Flatcar Container Linux by Kinvolk</li>
</ul>
</li>
<li>지속적인 통합 (CI) 테스트</li>
</ul>
<p>클러스터를 설치해 줄 도구로 유스케이스와 가장 잘 맞는 것을 고르고 싶다면, kubespray를 <a href=/ko/docs/reference/setup-tools/kubeadm/>kubeadm</a>, <a href=/ko/docs/setup/production-environment/tools/kops/>kops</a>와 <a href=https://github.com/kubernetes-sigs/kubespray/blob/master/docs/comparisons.md>비교한 글</a>을 읽어보자.</p>
<h2 id=클러스터-생성하기>클러스터 생성하기</h2>
<h3 id=1-5-아래의-요건-충족하기>(1/5) 아래의 요건 충족하기</h3>
<p>언더레이(underlay) <a href=https://github.com/kubernetes-sigs/kubespray#requirements>요건</a>을 만족하는 프로비전 한다.</p>
<ul>
<li><strong>Ansible의 명령어를 실행하기 위해 Ansible v 2.9와 Python netaddr 라이브러리가 머신에 설치되어 있어야 한다</strong></li>
<li><strong>Ansible 플레이북을 실행하기 위해 2.11 (혹은 그 이상) 버전의 Jinja가 필요하다</strong></li>
<li>타겟 서버들은 docker 이미지를 풀(pull) 하기 위해 반드시 인터넷에 접속할 수 있어야 한다. 아니라면, 추가적인 설정을 해야 한다 (<a href=https://github.com/kubernetes-sigs/kubespray/blob/master/docs/offline-environment.md>오프라인 환경 확인하기</a>)</li>
<li>타겟 서버들의 <strong>IPv4 포워딩</strong>이 활성화되어야 한다</li>
<li><strong>SSH 키</strong>가 인벤토리의 모든 서버들에 복사되어야 한다</li>
<li><strong>방화벽은 kubespray에 의해 관리되지 않는다</strong>. 사용자는 필요에 따라 적절한 규칙을 구현해야 한다. 디플로이먼트 과정에서의 문제를 방지하려면 방화벽을 비활성화해야 한다</li>
<li>만약 kubespray가 루트가 아닌 사용자 계정에서 실행되었다면, 타겟 서버에서 알맞은 권한 확대 방법이 설정되어야 하며, <code>ansible_become</code> 플래그나 커맨드 파라미터들, <code>--become</code> 또는 <code>-b</code> 가 명시되어야 한다</li>
</ul>
<p>Kubespray는 환경에 맞는 프로비저닝을 돕기 위해 아래와 같은 서비스를 제공한다:</p>
<ul>
<li>아래 클라우드 제공 업체를 위한 <a href=https://www.terraform.io/>Terraform</a> 스크립트:
<ul>
<li><a href=https://github.com/kubernetes-sigs/kubespray/tree/master/contrib/terraform/aws>AWS</a></li>
<li><a href=https://github.com/kubernetes-sigs/kubespray/tree/master/contrib/terraform/openstack>OpenStack</a></li>
<li><a href=https://github.com/kubernetes-sigs/kubespray/tree/master/contrib/terraform/packet>Packet</a></li>
</ul>
</li>
</ul>
<h3 id=2-5-인벤토리-파일-구성하기>(2/5) 인벤토리 파일 구성하기</h3>
<p>서버들을 프로비저닝 한 후, <a href=https://docs.ansible.com/ansible/latest/network/getting_started/first_inventory.html>Ansible의 인벤토리 파일</a>을 만들어야 한다. 수동으로 만들 수도 있고, 동적인 인벤토리 스크립트를 통해 만들 수도 있다. 더 많이 알고싶다면 " <a href=https://github.com/kubernetes-sigs/kubespray/blob/master/docs/getting-started.md#building-your-own-inventory>나만의 인벤토리 만들기</a>" 글을 확인하자.</p>
<h3 id=3-5-클러스터-디플로이먼트-계획하기>(3/5) 클러스터 디플로이먼트 계획하기</h3>
<p>Kubespray에서는 디플로이먼트의 많은 속성들을 사용자가 정의(customize)할 수 있다:</p>
<ul>
<li>디플로이먼트 모드의 선택: kubeadm 또는 그 외</li>
<li>CNI(네트워킹) 플러그인</li>
<li>DNS 설정</li>
<li>컨트롤 플레인 선택: 네이티브/바이너리 또는 컨테이너화 된 것</li>
<li>컴포넌트 버전</li>
<li>Calico 라우터 리플렉터</li>
<li>컴포넌트 런타임 옵션
<ul>
<li><a class=glossary-tooltip title="Docker는 운영 시스템 수준의 가상화를 제공하는 소프트웨어 기술이며, 컨테이너로도 알려져 있다." data-toggle=tooltip data-placement=top href=https://docs.docker.com/engine/ target=_blank aria-label=도커(Docker)>도커(Docker)</a></li>
<li><a class=glossary-tooltip title="A container runtime with an emphasis on simplicity, robustness and portability" data-toggle=tooltip data-placement=top href=https://containerd.io/docs/ target=_blank aria-label=containerd>containerd</a></li>
<li><a class=glossary-tooltip title="A lightweight container runtime specifically for Kubernetes" data-toggle=tooltip data-placement=top href=https://cri-o.io/#what-is-cri-o target=_blank aria-label=CRI-O>CRI-O</a></li>
</ul>
</li>
<li>인증서 생성 방법</li>
</ul>
<p>Kubespray의 <a href=https://docs.ansible.com/ansible/latest/user_guide/playbooks_variables.html>변수 파일들</a>을 사용자가 정의할 수 있다. 만약 Kubespray를 처음 접하는 경우, kubespray의 기본 설정값을 이용해 클러스터를 배포하고 Kubernetes를 탐색하는 것이 좋다.</p>
<h3 id=4-5-클러스터-배포하기>(4/5) 클러스터 배포하기</h3>
<p>다음으로, 클러스터를 배포한다.</p>
<p><a href=https://github.com/kubernetes-sigs/kubespray/blob/master/docs/getting-started.md#starting-custom-deployment>Ansible-플레이북</a>을 이용한 클러스터 디플로이먼트</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>ansible-playbook -i your/inventory/inventory.ini cluster.yml -b -v <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --private-key<span style=color:#666>=</span>~/.ssh/private_key
</code></pre></div><p>규모가 큰 디플로이먼트는 (100개 이상의 노드) 최적의 결과를 얻기 위해 <a href=https://github.com/kubernetes-sigs/kubespray/blob/master/docs/large-deployments.md>특정한 조정</a>을 필요로 할 수도 있다.</p>
<h3 id=5-5-디플로이먼트-검증하기>(5/5) 디플로이먼트 검증하기</h3>
<p>Kubespray는 Netchecker를 사용하여 파드 사이의 연결성과 DNS 해석을 검증할 방법을 제공한다. Netchecker는 netchecker-agents 파드들이 DNS 요청을 해석하고 기본(default) 네임스페이스 내부에서 서로에게 ping을 보낼 수 있도록 보장한다. 그 파드들은 나머지 워크로드의 유사한 동작을 모방하고 클러스터의 상태 표시기 역할을 한다.</p>
<h2 id=클러스터-동작>클러스터 동작</h2>
<p>Kubespray는 클러스터를 관리하기 위한 추가적인 플레이북, <em>scale</em> 과 <em>upgrade</em> 를 제공한다.</p>
<h3 id=클러스터-스케일링하기>클러스터 스케일링하기</h3>
<p>scale 플레이북을 실행해 클러스터에 워커 노드를 추가할 수 있다. 더 자세히 알고 싶다면, "<a href=https://github.com/kubernetes-sigs/kubespray/blob/master/docs/getting-started.md#adding-nodes>노드 추가하기</a>" 문서를 확인하자. remove-node 플레이북을 실행하면 클러스터로부터 워커 노드를 제거할 수 있다. 더 알고 싶다면 "<a href=https://github.com/kubernetes-sigs/kubespray/blob/master/docs/getting-started.md#remove-nodes>노드 제거하기</a>" 문서를 확인하자.</p>
<h3 id=클러스터-업그레이드-하기>클러스터 업그레이드 하기</h3>
<p>upgrade-cluster 플레이북을 실행해 클러스터를 업그레이드 할 수 있다. 더 자세히 알고 싶다면 "<a href=https://github.com/kubernetes-sigs/kubespray/blob/master/docs/upgrades.md>업그레이드</a>" 문서를 확인하자.</p>
<h2 id=클린업>클린업</h2>
<p><a href=https://github.com/kubernetes-sigs/kubespray/blob/master/reset.yml>reset 플레이북</a>을 이용하여 노드들을 리셋하고 Kubespray로 설치된 모든 구성요소를 삭제할 수 있다.</p>
<div class="alert alert-warning caution callout" role=alert>
<strong>주의:</strong> reset 플레이북을 실행할 때, 실수로 프로덕션 클러스터를 타겟으로 삼지 않도록 해야 한다!
</div>
<h2 id=피드백>피드백</h2>
<ul>
<li>Slack 채널: <a href=https://kubernetes.slack.com/messages/kubespray/>#kubespray</a> (<a href=https://slack.k8s.io/>이 곳</a>에서 초대를 받을 수 있다)</li>
<li><a href=https://github.com/kubernetes-sigs/kubespray/issues>GitHub Issues</a></li>
</ul>
<h2 id=다음-내용>다음 내용</h2>
<p>Kubespray의 <a href=https://github.com/kubernetes-sigs/kubespray/blob/master/docs/roadmap.md>로드맵</a>에서 계획중인 작업을 확인해보자.</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-d2f55eefe7222b7c637875af9c3ec199>2.3 - 턴키 클라우드 솔루션</h1>
<p>이 페이지는 인증된 쿠버네티스 솔루션 제공자 목록을 제공한다. 각 제공자
페이지를 통해서, 프로덕션에 준비된 클러스터를 설치 및 설정하는 방법을
학습할 수 있다.</p>
<script>function updateLandscapeSource(a,b){console.log({button:a,shouldUpdateFragment:b});try{if(b)window.location.hash="#"+a.id;else{var c=document.querySelectorAll("#landscape");let b=a.dataset.landscapeTypes,d="https://landscape.cncf.io/card-mode?category="+encodeURIComponent(b)+"&grouping=category&embed=yes";c[0].src=d}}catch(a){console.log({message:"error handling Landscape switch",error:a})}}document.addEventListener("DOMContentLoaded",function(){var c,a;let b=()=>{if(window.location.hash){let a=document.querySelectorAll(".landscape-trigger"+window.location.hash);a.length==1&&(landscapeSource=a[0],console.log("Updating Landscape source based on fragment:",window.location.hash.substring(1)),updateLandscapeSource(landscapeSource,!1))}};if(c=document.querySelectorAll(".landscape-trigger"),c.forEach(a=>{a.onclick=function(){updateLandscapeSource(a,!0)}}),a=document.querySelectorAll(".landscape-trigger.landscape-default"),a.length==1){let b=a[0];updateLandscapeSource(b,!1)}window.addEventListener("hashchange",b,!1),b()})</script><div id=frameHolder>
<iframe frameborder=0 id=landscape scrolling=no src="https://landscape.cncf.io/card-mode?category=certified-kubernetes-hosted&grouping=category&embed=yes" style=width:1px;min-width:100%></iframe>
<script src=https://landscape.cncf.io/iframeResizer.js></script>
</div>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-acce7e24090fea04715a7a516ba3e69b>2.4 - 쿠버네티스에서 윈도우</h1>
</div>
<div class=td-content>
<h1 id=pg-a307d413f1f7430fced233023087e2a1>2.4.1 - 쿠버네티스에서 윈도우 컨테이너</h1>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> <p>본 문서의 영어 원문(<a href=/docs/setup/production-environment/windows/intro-windows-in-kubernetes/>Windows containers in Kubernetes</a>)은 변경되었습니다.</p>
<p>최신 내용은 원문을 통해 확인하시기 바랍니다.</p>
<p>본 문서에 대한 갱신은 기여를 통해 진행되며, 갱신이 완료되면 해당 알림은 제거됩니다.</p>
</div>
<p>윈도우 애플리케이션은 많은 조직에서 실행되는 서비스 및
애플리케이션의 상당 부분을 구성한다.
<a href=https://aka.ms/windowscontainers>윈도우 컨테이너</a>는 프로세스와 패키지 종속성을
캡슐화하는 현대적인 방법을 제공하여, 데브옵스(DevOps)
사례를 더욱 쉽게 사용하고 윈도우 애플리케이션의 클라우드 네이티브 패턴을 따르도록 한다.
쿠버네티스는 사실상의 표준 컨테이너 오케스트레이터가 되었으며,
쿠버네티스 1.14 릴리스에는 쿠버네티스 클러스터의 윈도우 노드에서 윈도우
컨테이너 스케줄링을 위한 프로덕션 지원이 포함되어 있어, 광범위한 윈도우 애플리케이션 생태계가
쿠버네티스의 강력한 기능을 활용할 수 있다. 윈도우 기반 애플리케이션과
리눅스 기반 애플리케이션에 투자한 조직은 워크로드를 관리하기 위해
별도의 오케스트레이터를 찾을 필요가 없으므로,
운영 체제와 관계없이 배포 전반에 걸쳐
운영 효율성이 향상된다.</p>
<h2 id=쿠버네티스의-윈도우-컨테이너>쿠버네티스의 윈도우 컨테이너</h2>
<p>쿠버네티스에서 윈도우 컨테이너 오케스트레이션을 활성화하려면, 기존
리눅스 클러스터에 윈도우 노드를 포함한다. 쿠버네티스의
<a class=glossary-tooltip title="파드는 클러스터에서 실행 중인 컨테이너의 집합을 나타낸다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/pods/ target=_blank aria-label=파드>파드</a>에서 윈도우 컨테이너를 스케줄링하는 것은
리눅스 기반 컨테이너를 스케줄링하는 것과 유사하다.</p>
<p>윈도우 컨테이너를 실행하려면, 쿠버네티스 클러스터에 리눅스를
실행하는 컨트롤 플레인 노드와 사용자의 워크로드 요구에 따라 윈도우 또는 리눅스를
실행하는 워커가 있는 여러 운영 체제가 포함되어 있어야 한다. 윈도우
서버 2019는 윈도우에서
<a href=https://github.com/kubernetes/community/blob/master/contributors/design-proposals/architecture/architecture.md#the-kubernetes-node>쿠버네티스 노드</a>를
활성화하는 유일한 윈도우 운영 체제이다(kubelet,
<a href=https://docs.microsoft.com/ko-kr/virtualization/windowscontainers/deploy-containers/containerd>컨테이너 런타임</a>
및 kube-proxy 포함). 윈도우 배포 채널에 대한 자세한 설명은
<a href=https://docs.microsoft.com/ko-kr/windows-server/get-started-19/servicing-channels-19>Microsoft 문서</a>를 참고한다.</p>
<p><a href=/ko/docs/concepts/overview/components/>마스터 컴포넌트</a>를 포함한
쿠버네티스 컨트롤 플레인은
리눅스에서 계속 실행된다.
윈도우 전용 쿠버네티스 클러스터는 계획이 없다.</p>
<p>이 문서에서 윈도우 컨테이너에 대해 이야기할 때
프로세스 격리된 윈도우 컨테이너를 의미한다.
<a href=https://docs.microsoft.com/ko-kr/virtualization/windowscontainers/manage-containers/hyperv-container>Hyper-V 격리</a>가
있는 윈도우 컨테이너는 향후 릴리스로 계획되어 있다.</p>
<h2 id=지원되는-기능-및-제한>지원되는 기능 및 제한</h2>
<h3 id=지원되는-기능>지원되는 기능</h3>
<h4 id=윈도우-os-버전-지원>윈도우 OS 버전 지원</h4>
<p>쿠버네티스의 윈도우 운영 체제 지원은 다음 표를
참조한다. 단일 이기종 쿠버네티스 클러스터에는 윈도우 및
리눅스 워커 노드가 모두 있을 수 있다. 윈도우 컨테이너는 윈도우 노드에서,
리눅스 컨테이너는 리눅스 노드에서 스케줄되어야 한다.</p>
<table>
<thead>
<tr>
<th>쿠버네티스 버전</th>
<th>윈도우 서버 LTSC 릴리스</th>
<th>윈도우 서버 SAC 릴리스</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><em>Kubernetes v1.20</em></td>
<td>Windows Server 2019</td>
<td>Windows Server ver 1909, Windows Server ver 2004</td>
<td></td>
</tr>
<tr>
<td><em>Kubernetes v1.21</em></td>
<td>Windows Server 2019</td>
<td>Windows Server ver 2004, Windows Server ver 20H2</td>
<td></td>
</tr>
<tr>
<td><em>Kubernetes v1.22</em></td>
<td>Windows Server 2019</td>
<td>Windows Server ver 2004, Windows Server ver 20H2</td>
<td></td>
</tr>
</tbody>
</table>
<p>지원 모델을 포함한 다양한 윈도우 서버
서비스 채널에 대한 정보는
<a href=https://docs.microsoft.com/ko-kr/windows-server/get-started-19/servicing-channels-19>윈도우 서버 서비스 채널</a>에서 확인할 수 있다.</p>
<p>모든 윈도우 고객이 앱의 운영 체제를 자주 업데이트하는 것은
아니다. 애플리케이션 업그레이드를 위해서는 클러스터에 새 노드를
업그레이드하거나 도입하는 것이 필요하다. 이 문서에서
쿠버네티스에서 실행되는 컨테이너의 운영 체제를 업그레이드하기로 선택한
고객을 위해 새 운영 체제 버전에 대한 지원을 추가할 때의 가이드와
단계별 지침을 제공한다. 이 가이드에는 클러스터 노드와 함께 사용자 애플리케이션을
업그레이드하기 위한 권장 업그레이드 절차가 포함된다.
윈도우 노드는 현재 리눅스 노드와 동일한 방식으로 쿠버네티스
<a href=/ko/releases/version-skew-policy/>버전-차이(skew) 정책</a>(노드 대 컨트롤 플레인
버전 관리)을 준수한다.</p>
<p>윈도우 서버 호스트 운영 체제에는
<a href=https://www.microsoft.com/ko-kr/cloud-platform/windows-server-pricing>윈도우 서버</a>
라이선스가 적용된다. 윈도우 컨테이너 이미지에는
<a href=https://docs.microsoft.com/en-us/virtualization/windowscontainers/images-eula>윈도우 컨테이너에 대한 추가 사용 조건</a>이 적용된다.</p>
<p>프로세스 격리가 포함된 윈도우 컨테이너에는 엄격한 호환성 규칙이 있으며,
<a href=https://docs.microsoft.com/ko-kr/virtualization/windowscontainers/deploy-containers/version-compatibility>여기서 호스트 OS 버전은 컨테이너 베이스 이미지 OS 버전과 일치해야 한다</a>.
일단 쿠버네티스에서 Hyper-V 격리가 포함된 윈도우 컨테이너를 지원하면,
제한 및 호환성 규칙이 변경될 것이다.</p>
<h4 id=pause-image>퍼즈(Pause) 이미지</h4>
<p>쿠버네티스는 윈도우 지원을 포함하는 다중 아키텍처 이미지를 유지보수한다.
쿠버네티스 v1.22의 경우 권장 퍼즈 이미지는 <code>k8s.gcr.io/pause:3.5</code>이다.
<a href=https://github.com/kubernetes/kubernetes/tree/master/build/pause>소스 코드</a>는
GitHub에서 찾을 수 있다.</p>
<p>Microsoft는 리눅스, 윈도우 amd64를 지원하는 다중 아키텍처 이미지를 <code>mcr.microsoft.com/oss/kubernetes/pause:3.5</code>에서 유지보수하고 있다.
이 이미지는 쿠버네티스가 유지 관리하는 이미지와 동일한 소스코드에서 생성되었지만, 모든 윈도우 바이너리는 Microsoft에 의해 서명된 <a href=https://docs.microsoft.com/en-us/windows-hardware/drivers/install/authenticode>인증 코드</a>이다.
프로덕션 환경에서 서명된 바이너리가 필요한 경우, Microsoft가 유지 관리하는 이미지를 사용하는 것을 권장한다.</p>
<h4 id=컴퓨트>컴퓨트</h4>
<p>API 및 kubectl의 관점에서, 윈도우 컨테이너는
리눅스 기반 컨테이너와 거의 같은 방식으로 작동한다. 그러나
<a href=#%EC%A0%9C%ED%95%9C>제한 섹션</a>에 요약된 주요 기능에는
몇 가지 눈에 띄는 차이점이 있다.</p>
<p>윈도우에서 주요 쿠버네티스 요소는 리눅스와 동일한 방식으로 작동한다. 이
섹션에서는, 주요 워크로드 인에이블러(enabler) 일부와 이들이 윈도우에 매핑되는 방법에
대해 설명한다.</p>
<ul>
<li>
<p><a href=/ko/docs/concepts/workloads/pods/>파드</a></p>
<p>파드는 쿠버네티스의 기본 빌딩 블록이다 - 쿠버네티스 오브젝트 모델에서
생성하고 배포하는 가장 작고 간단한 단위. 동일한 파드에
윈도우 및 리눅스 컨테이너를 배포할 수 없다. 파드의 모든 컨테이너는
단일 노드로 스케줄되며 각 노드는 특정 플랫폼 및
아키텍처를 나타낸다. 다음과 같은 파드 기능, 속성 및
이벤트가 윈도우 컨테이너에서 지원된다.</p>
<ul>
<li>프로세스 분리 및 볼륨 공유 기능을 갖춘 파드 당 하나 또는 여러 개의 컨테이너</li>
<li>파드 상태 필드</li>
<li>준비성(readiness) 및 활성 프로브(liveness probe)</li>
<li>postStart 및 preStop 컨테이너 라이프사이클 이벤트</li>
<li>컨피그맵(ConfigMap), 시크릿(Secrets): 환경 변수 또는 볼륨으로</li>
<li>EmptyDir</li>
<li>명명된 파이프 호스트 마운트</li>
<li>리소스 제한</li>
</ul>
</li>
<li>
<p><a href=/ko/docs/concepts/workloads/controllers/>컨트롤러</a></p>
<p>쿠버네티스 컨트롤러는 파드의 의도한 상태(desired state)를 처리한다. 윈도우
컨테이너에서 지원되는 워크로드 컨트롤러는 다음과 같다.</p>
<ul>
<li>레플리카셋(ReplicaSet)</li>
<li>레플리케이션컨트롤러(ReplicationController)</li>
<li>디플로이먼트(Deployment)</li>
<li>스테이트풀셋(StatefulSet)</li>
<li>데몬셋(DaemonSet)</li>
<li>잡(Job)</li>
<li>크론잡(CronJob)</li>
</ul>
</li>
<li>
<p><a href=/ko/docs/concepts/services-networking/service/>서비스</a></p>
<p>쿠버네티스 서비스는 논리적인 파드 집합과 그것에(마이크로 서비스라고도 함)
접근하는 정책을 정의하는 추상화 개념이다. 상호-운영 체제
연결을 위해 서비스를 사용할 수 있다. 윈도우에서 서비스는
다음의 유형, 속성 및 기능을 활용할 수 있다.</p>
<ul>
<li>서비스 환경 변수</li>
<li>노드포트(NodePort)</li>
<li>클러스터IP(ClusterIP)</li>
<li>로드밸런서(LoadBalancer)</li>
<li>ExternalName</li>
<li>헤드리스 서비스(Headless services)</li>
</ul>
</li>
</ul>
<p>파드, 컨트롤러 및 서비스는 쿠버네티스에서 윈도우 워크로드를
관리하는데 중요한 요소이다. 그러나 그 자체로는 동적 클라우드 네이티브 환경에서
윈도우 워크로드의 적절한 수명 주기 관리를 수행하기에
충분하지 않다. 다음 기능에 대한 지원이 추가되었다.</p>
<ul>
<li>파드와 컨테이너 메트릭</li>
<li>Horizontal Pod Autoscaler 지원</li>
<li>kubectl Exec</li>
<li>리소스쿼터(Resource Quotas)</li>
<li>스케쥴러 선점(preemption)</li>
</ul>
<h4 id=컨테이너-런타임>컨테이너 런타임</h4>
<h5 id=docker-ee>Docker EE</h5>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.14 [stable]</code>
</div>
<p>Docker EE-basic 19.03 이상은 모든 윈도우 서버 버전에 대해 권장되는
컨테이너 런타임이다. 이것은 kubelet에 포함된 dockershim 코드와 함께 작동한다.</p>
<h5 id=cri-containerd>CRI-ContainerD</h5>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.20 [stable]</code>
</div>
<p><a class=glossary-tooltip title="A container runtime with an emphasis on simplicity, robustness and portability" data-toggle=tooltip data-placement=top href=https://containerd.io/docs/ target=_blank aria-label=ContainerD>ContainerD</a> 1.4.0+는
윈도우 쿠버네티스 노드의 컨테이너 런타임으로도 사용할 수 있다.</p>
<p><a href=/ko/docs/setup/production-environment/container-runtimes/#containerd-%EC%84%A4%EC%B9%98>윈도우에 ContainerD 설치</a>
방법을 확인한다.</p>
<h4 id=퍼시스턴트-스토리지-persistent-storage>퍼시스턴트 스토리지(Persistent Storage)</h4>
<p>쿠버네티스 <a href=/ko/docs/concepts/storage/volumes/>볼륨</a>을 사용하면
데이터 지속성(persistence) 및 파드 볼륨 공유 요구 사항이 있는 복잡한 애플리케이션을
쿠버네티스에 배포할 수 있다. 특정 스토리지 백엔드 또는
프로토콜과 관련된 퍼시스턴트 볼륨 관리에는
볼륨 프로비저닝/디-프로비저닝/크기 조정, 쿠버네티스 노드에 볼륨
연결/분리, 데이터를 유지해야 하는 파드의 개별 컨테이너에 볼륨
마운트/분리와 같은 작업이 포함된다. 특정 스토리지 백엔드 또는
프로토콜에 대해 이러한 볼륨 관리 작업을
구현하는 코드는 쿠버네티스 볼륨
<a href=/ko/docs/concepts/storage/volumes/#%EB%B3%BC%EB%A5%A8-%EC%9C%A0%ED%98%95%EB%93%A4>플러그인</a>의 형태로 제공된다. 다음과 같은
광범위한 쿠버네티스 볼륨 플러그인 클래스가 윈도우에서 지원된다.</p>
<h5 id=인-트리-in-tree-볼륨-플러그인>인-트리(In-tree) 볼륨 플러그인</h5>
<p>인-트리 볼륨 플러그인과 관련된 코드는 핵심 쿠버네티스
코드 베이스의 일부로 제공된다. 인-트리 볼륨 플러그인 배포는
추가 스크립트를 설치하거나 별도의 컨테이너화된 플러그인 컴포넌트를
배포할 필요가 없다. 이러한 플러그인들은
볼륨 프로비저닝/디-프로비저닝, 스토리지 백엔드 볼륨 크기 조정, 쿠버네티스 노드에
볼륨 연결/분리, 파드의 개별 컨테이너에 볼륨 마운트/분리를
처리할 수 있다. 다음의 인-트리 플러그인은 윈도우 노드를 지원한다.</p>
<ul>
<li><a href=/ko/docs/concepts/storage/volumes/#awselasticblockstore>awsElasticBlockStore</a></li>
<li><a href=/ko/docs/concepts/storage/volumes/#azuredisk>azureDisk</a></li>
<li><a href=/ko/docs/concepts/storage/volumes/#azurefile>azureFile</a></li>
<li><a href=/ko/docs/concepts/storage/volumes/#gcepersistentdisk>gcePersistentDisk</a></li>
<li><a href=/ko/docs/concepts/storage/volumes/#vspherevolume>vsphereVolume</a></li>
</ul>
<h5 id=flexvolume-플러그인>FlexVolume 플러그인</h5>
<p><a href=/ko/docs/concepts/storage/volumes/#flexVolume>FlexVolume</a>
플러그인과 관련된 코드는 아웃-오브-트리(out-of-tree) 스크립트 또는 호스트에 직접 배포해야 하는
바이너리로 제공된다. FlexVolume 플러그인은 쿠버네티스 노드에 볼륨
연결/분리 및 파드의 개별 컨테이너에 볼륨 마운트/분리를
처리한다. FlexVolume 플러그인과 관련된 퍼시스턴트 볼륨의
프로비저닝/디-프로비저닝은 일반적으로 FlexVolume 플러그인과는 별도의 외부
프로비저너를 통해 처리될 수 있다. 호스트에서
powershell 스크립트로 배포된 다음의 FlexVolume
<a href=https://github.com/Microsoft/K8s-Storage-Plugins/tree/master/flexvolume/windows>플러그인</a>은
윈도우 노드를 지원한다.</p>
<ul>
<li><a href=https://github.com/microsoft/K8s-Storage-Plugins/tree/master/flexvolume/windows/plugins/microsoft.com~smb.cmd>SMB</a></li>
<li><a href=https://github.com/microsoft/K8s-Storage-Plugins/tree/master/flexvolume/windows/plugins/microsoft.com~iscsi.cmd>iSCSI</a></li>
</ul>
<h5 id=csi-플러그인>CSI 플러그인</h5>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.22 [stable]</code>
</div>
<p><a class=glossary-tooltip title="컨테이너 스토리지 인터페이스(CSI)는 컨테이너에 스토리지 시스템을 노출하는 표준 인터페이스를 정의한다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/storage/volumes/#csi target=_blank aria-label=CSI>CSI</a> 플러그인과
관련된 코드는 일반적으로 컨테이너 이미지로 배포되고 데몬셋(DaemonSets)
및 스테이트풀셋(StatefulSets)과 같은
표준 쿠버네티스 구성을 사용하여 배포되는 아웃-오브-트리 스크립트 및
바이너리로 제공된다. CSI 플러그인은 쿠버네티스에서 볼륨 프로비저닝/디-프로비저닝, 볼륨
크기 조정, 쿠버네티스 노드에 볼륨 연결/분리, 파드의 개별 컨테이너에 볼륨
마운트/분리, 스냅샷 및 복제를 사용하여 퍼시스턴트 데이터 백업/복원과 같은
다양한 볼륨 관리 작업을 처리한다.</p>
<p>CSI 노드 플러그인(특히 블록 디바이스 또는 공유 파일시스템으로 노출된
퍼시스턴트 볼륨과 관련된 플러그인)은 디스크 장치 스캔, 파일 시스템 마운트 등과 같은
다양한 특권이 필요한(privileged) 작업을 수행해야
한다. 이러한 작업은 호스트 운영 체제마다 다르다. 리눅스 워커
노드의 경우 컨테이너화된 CSI 노드 플러그인은 일반적으로 특권을 가진
컨테이너로 배포된다. 윈도우 워커 노드의 경우 컨테이너화된
CSI 노드 플러그인에 대한 특권이 필요한 작업은 커뮤니티에서 관리되고,
각 윈도우 노드에 사전 설치되어야 하는 독립형(stand-alone) 바이너리인
<a href=https://github.com/kubernetes-csi/csi-proxy>csi-proxy</a>를 사용하여 지원된다. 자세한
내용은 배포하려는 CSI 플러그인의 배포 가이드를
참조한다.</p>
<p>윈도우 노드에서 CSI 노드 플러그인은 일반적으로 로컬 스토리지 작업을 처리하는
커뮤니티에서 관리하는 <a href=https://github.com/kubernetes-csi/csi-proxy>csi-proxy</a>에 의해 노출된 API를 호출한다.</p>
<p>설치에 대한 자세한 내용은 윈도우 CSI 플러그인을
배포할 환경의 배포 가이드를 참고한다.
또한 다음 <a href=https://github.com/kubernetes-csi/csi-proxy#installation>설치 단계</a>를 참고할 수도 있다.</p>
<h4 id=네트워킹>네트워킹</h4>
<p>윈도우 컨테이너용 네트워킹은
<a href=/ko/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/>CNI 플러그인</a>을 통해 노출된다.
윈도우 컨테이너는 네트워킹과 관련하여 가상 머신과 유사하게
작동한다. 각 컨테이너에는 Hyper-V 가상 스위치(vSwitch)에 연결된
가상 네트워크 어댑터(vNIC)가 있다. 호스트 네트워킹 서비스(HNS)와
호스트 컴퓨팅 서비스(HCS)는 함께 작동하여 컨테이너를 만들고
컨테이너 vNIC을 네트워크에 연결한다. HCS는 컨테이너 관리를
담당하는 반면 HNS는 다음과 같은 네트워킹 리소스 관리를
담당한다.</p>
<ul>
<li>가상 네트워크(vSwitch 생성 포함)</li>
<li>엔드포인트 / vNIC</li>
<li>네임스페이스</li>
<li>정책(패킷 캡슐화, 로드 밸런싱 규칙, ACL, NAT 규칙 등)</li>
</ul>
<p>다음의 서비스 사양 유형이 지원된다.</p>
<ul>
<li>NodePort</li>
<li>ClusterIP</li>
<li>LoadBalancer</li>
<li>ExternalName</li>
</ul>
<h5 id=네트워크-모드>네트워크 모드</h5>
<p>윈도우는 L2bridge, L2tunnel, Overlay, Transparent 및
NAT의 다섯 가지 네트워킹 드라이버/모드를 지원한다. 윈도우와 리눅스 워커 노드가
있는 이기종 클러스터에서는 윈도우와 리눅스 모두에서 호환되는 네트워킹
솔루션을 선택해야 한다. 윈도우에서 다음과 같은 out-of-tree 플러그인이 지원되며
각 CNI 사용 시 권장 사항이 있다.</p>
<table>
<thead>
<tr>
<th>네트워크 드라이버</th>
<th>설명</th>
<th>컨테이너 패킷 수정</th>
<th>네트워크 플러그인</th>
<th>네트워크 플러그인 특성</th>
</tr>
</thead>
<tbody>
<tr>
<td>L2bridge</td>
<td>컨테이너는 외부 vSwitch에 연결된다. 컨테이너는
언더레이 네트워크에 연결된다. 하지만 인그레스/이그레스시에 재작성되기
때문에 물리적 네트워크가 컨테이너 MAC을 학습할 필요가 없다.
</td>
<td>
MAC은 호스트 MAC에 다시 쓰여지고, IP는 HNS OutboundNAT 정책을 사용하여
호스트 IP에 다시 쓰여질 수 있다.
</td>
<td>
<a href=https://github.com/containernetworking/plugins/tree/master/plugins/main/windows/win-bridge>win-bridge<a>,
<a href=https://github.com/Azure/azure-container-networking/blob/master/docs/cni.md>Azure-CNI</a>,
Flannel 호스트 게이트웨이는 win-bridge를 사용한다.
</td>
<td>
win-bridge는 L2bridge 네트워크 모드를 사용하고,
컨테이너를 호스트의 언더레이에 연결하여 최상의 성능을 제공한다.
노드 간 연결을 위해 사용자 정의 경로(user-defined routes, UDR)가 필요하다.
</td>
</tr>
<tr>
<td>L2Tunnel</td>
<td>
이것은 l2bridge의 특별한 케이스이지만 Azure에서만 사용된다. 모든 패킷은
SDN 정책이 적용되는 가상화 호스트로 전송된다.
</td>
<td>
MAC 재작성되고, 언더레이 네트워크 상에서 IP가 보인다.
</td>
<td>
<a href=https://github.com/Azure/azure-container-networking/blob/master/docs/cni.md>Azure-CNI</a>
</td>
<td>
Azure-CNI를 사용하면 컨테이너를 Azure vNET과 통합할 수 있으며,
<a href=https://azure.microsoft.com/ko-kr/services/virtual-network/>Azure Virtual Network</a>에서
제공하는 기능 집합을 활용할 수 있다.
예를 들어, Azure 서비스에 안전하게 연결하거나 Azure NSG를 사용한다.
<a href=https://docs.microsoft.com/ko-kr/azure/aks/concepts-network#azure-cni-advanced-networking>azure-cni</a>
예제를 참고한다.
</td>
</tr>
<tr>
<td>오버레이(쿠버네티스에서 윈도우용 오버레이 네트워킹은 <b>알파</b> 단계에 있음)</td>
<td>
컨테이너에는 외부 vSwitch에 연결된 vNIC이 제공된다. 각 오버레이
네트워크는 사용자 지정 IP 접두사로 정의된 자체 IP 서브넷을 가져온다. 오버레이
네트워크 드라이버는 VXLAN 캡슐화를 사용한다.
</td>
<td>
외부 헤더로 캡슐화된다.
</td>
<td>
<a href=https://github.com/containernetworking/plugins/tree/master/plugins/main/windows/win-overlay>Win-overlay</a>,
Flannel VXLAN (win-overlay 사용)
</td>
<td>
win-overlay는 가상 컨테이너 네트워크를 호스트의
언더레이에서 격리하려는 경우(예: 보안 상의 이유로) 사용해야 한다. 데이터 센터의 IP에
제한이 있는 경우, (다른 VNID 태그가 있는) 다른 오버레이
네트워크에 IP를 재사용할 수 있다. 이 옵션을 사용하려면
윈도우 서버 2019에서 <a href=https://support.microsoft.com/help/4489899>KB4489899</a>가
필요하다.
</td>
</tr>
<tr>
<td>
Transparent(<a href=https://github.com/openvswitch/ovn-kubernetes>ovn-kubernetes</a>의 특수한 유스케이스)
</td>
<td>
외부 vSwitch가 필요하다. 컨테이너는 논리적 네트워크(논리적 스위치 및 라우터)를
통해 파드 내 통신을 가능하게 하는 외부 vSwitch에
연결된다.
</td>
<td>
패킷은
<a href=https://datatracker.ietf.org/doc/draft-gross-geneve/>GENEVE</a>,
<a href=https://datatracker.ietf.org/doc/draft-davie-stt/>STT</a> 터널링을 통해
캡슐화되는데, 동일한 호스트에 있지 않은 파드에 도달하기 위한 터널링을 한다. <br> 패킷은 ovn 네트워크
컨트롤러에서 제공하는 터널 메타데이터 정보를 통해 전달되거나 삭제된다.
<br>
NAT는 north-south 통신(데이터 센터와 클라이언트, 네트워크 상의 데이터 센터 외부와의 통신)을 위해 수행된다.
</td>
<td>
<a href=https://github.com/openvswitch/ovn-kubernetes>ovn-kubernetes</a>
</td>
<td>
<a href=https://github.com/openvswitch/ovn-kubernetes/tree/master/contrib>Ansible</a>을 통해 배포한다.
분산 ACL은 쿠버네티스 정책을 통해 적용할 수 있다. IPAM을 지원한다.
kube-proxy 없이 로드 밸런싱을 수행할 수 있다. NAT를 수행할 때
iptables/netsh를 사용하지 않고 수행된다.
</td>
</tr>
<tr>
<td>NAT (<b>쿠버네티스에서 사용되지 않음</b>)</td>
<td>
컨테이너에는 내부 vSwitch에 연결된 vNIC이 제공된다. DNS/DHCP는
<a href=https://blogs.technet.microsoft.com/virtualization/2016/05/25/windows-nat-winnat-capabilities-and-limitations>WinNAT</a>라는
내부 컴포넌트를 사용하여 제공된다.
</td>
<td>
MAC 및 IP는 호스트 MAC/IP에 다시 작성된다.
</td>
<td>
<a href=https://github.com/Microsoft/windows-container-networking/tree/master/plugins/nat>nat</a>
</td>
<td>
완전성을 위해 여기에 포함되었다.
</td>
</tr>
</tbody>
</table>
<p>위에서 설명한대로 <a href=https://github.com/coreos/flannel>플란넬(Flannel)</a> CNI
<a href=https://github.com/containernetworking/plugins/tree/master/plugins/meta/flannel>메타 플러그인</a>은
<a href=https://github.com/coreos/flannel/blob/master/Documentation/backends.md#vxlan>VXLAN 네트워크 백엔드</a>
(<strong>alpha 지원</strong>, win-overlay에 위임) 및
<a href=https://github.com/coreos/flannel/blob/master/Documentation/backends.md#host-gw>host-gateway network backend</a>
(안정적인 지원, win-bridge에 위임)를 통해
<a href=https://github.com/containernetworking/plugins/tree/master/plugins/meta/flannel#windows-support-experimental>윈도우</a>에서도
지원된다. 이 플러그인은 자동 노드 서브넷
임대 할당과 HNS 네트워크 생성을 위해 윈도우 (Flanneld)에서
Flannel 데몬과 함께 작동하도록 참조 CNI 플러그인 (win-overlay, win-bridge)
중 하나에 대한 위임을 지원한다. 이 플러그인은 자체
구성 파일 (cni.conf)을 읽고, 이를 FlannelD 생성하는 subnet.env 파일의 환경 변수와
함께 집계한다. 이후 네트워크 연결을 위한
참조 CNI 플러그인 중 하나에 위임하고 노드 할당 서브넷을 포함하는 올바른
구성을 IPAM 플러그인 (예: 호스트-로컬)으로
보낸다.</p>
<p>노드, 파드, 서비스 오브젝트의 경우 TCP/UDP 트래픽에 대해 다음
네트워크 흐름이 지원된다.</p>
<ul>
<li>파드 -> 파드(IP)</li>
<li>파드 -> 파드(Name)</li>
<li>파드 -> 서비스(Cluster IP)</li>
<li>파드 -> 서비스(PQDN, 단 "."이 없는 경우에만)</li>
<li>파드 -> 서비스(FQDN)</li>
<li>파드 -> External(IP)</li>
<li>파드 -> External(DNS)</li>
<li>노드 -> 파드</li>
<li>파드 -> 노드</li>
</ul>
<h5 id=ip-주소-관리-ipam>IP 주소 관리(IPAM)</h5>
<p>윈도우에서는 다음 IPAM 옵션이 지원된다.</p>
<ul>
<li><a href=https://github.com/containernetworking/plugins/tree/master/plugins/ipam/host-local>호스트-로컬</a></li>
<li>HNS IPAM(Inbox 플랫폼 IPAM, 이것은 IPAM이 설정되지 않은 경우 폴백(fallback)이다)</li>
<li><a href=https://github.com/Azure/azure-container-networking/blob/master/docs/ipam.md>Azure-vnet-ipam</a>(azure-cni 전용)</li>
</ul>
<h5 id=로드-밸런싱과-서비스>로드 밸런싱과 서비스</h5>
<p>윈도우에서는 다음 설정을 사용하여 서비스 및 로드 밸런싱 동작을
구성할 수 있다.</p>
<table><caption style=display:none>윈도우 서비스 구성</caption>
<thead>
<tr>
<th>기능</th>
<th>설명</th>
<th>지원되는 쿠버네티스 버전</th>
<th>지원되는 윈도우 OS 빌드</th>
<th>활성화하는 방법</th>
</tr>
<thead>
<tbody>
<tr>
<td>세션 어피니티</td>
<td>
특정 클라이언트의 연결이 매번 동일한 파드로
전달되도록 한다.
</td>
<td>v1.20 이상</td>
<td>
<a href=https://blogs.windows.com/windowsexperience/2020/01/28/announcing-windows-server-vnext-insider-preview-build-19551/>윈도우 서버 vNext Insider Preview Build 19551</a> (또는 그 이상)
</td>
<td>
<code>service.spec.sessionAffinity</code>를 "ClientIP"로 설정
</td>
</tr>
<tr>
<td>직접 서버 반환 (DSR) </td>
<td>
IP 주소 수정 및 LBNAT가 컨테이너 vSwitch 포트에서 직접
발생하는 로드 밸런싱 모드. 서비스 트래픽은 소스 IP가 원래 파드 IP로
설정된 상태로 도착한다.
</td>
<td>v1.20 이상</td>
<td>
윈도우 서버 2019
</td>
<td>
kube-proxy에서 다음 플래그를 설정한다.
<code>--feature-gates="WinDSR=true" --enable-dsr=true</code>
</td>
</tr>
<tr>
<td>대상 보존(Preserve-Destination)</td>
<td>
서비스 트래픽의 DNAT를 스킵하여, 백엔드 파드에 도달하는 패킷에서 대상
서비스의 가상 IP를 보존한다. 또한 노드-노드 전달을 비활성화한다.
</td>
<td>v1.20 이상</td>
<td>윈도우 서버, 버전 1903 (또는 그 이상)</td>
<td>
서비스 어노테이션에서 <code>"preserve-destination": "true"</code>를 설정하고
kube-proxy에서 DSR을 활성화한다.
</td>
</tr>
<tr>
<td>IPv4/IPv6 이중 스택 네트워킹</td>
<td>
클러스터 내/외부 기본 IPv4-to-IPv4 통신과 함께
IPv6-to-IPv6 통신
</td>
<td>v1.19 이상</td>
<td>윈도우 서버, 버전 2004 (또는 그 이상)</td>
<td>
<a href=#ipv4ipv6-dual-stack>IPv4/IPv6 이중 스택</a>을 참고한다.
</td>
</tr>
<tr>
<td>클라이언트 IP 보존</td>
<td>
인그레스 트래픽의 소스 IP가 유지되도록 한다. 또한
노드-노드 전달을 비활성화한다.
</td>
<td>v1.20 이상</td>
<td>윈도우 서버, 버전 2019 (또는 그 이상)</td>
<td>
<code>service.spec.externalTrafficPolicy</code>를 "Local"로 설정하고
kube-proxy에서 DSR을 활성화한다.
</td>
</tr>
</tbody>
</table>
<h4 id=ipv4-ipv6-이중-스택>IPv4/IPv6 이중 스택</h4>
<p><code>IPv6DualStack</code> <a href=/ko/docs/reference/command-line-tools-reference/feature-gates/>기능 게이트</a>를
사용하여 <code>l2bridge</code> 네트워크에 IPv4/IPv6 이중 스택 네트워킹을 활성화할 수 있다. 자세한 내용은
<a href=/ko/docs/concepts/services-networking/dual-stack/#ipv4-ipv6-%EC%9D%B4%EC%A4%91-%EC%8A%A4%ED%83%9D-%ED%99%9C%EC%84%B1%ED%99%94>IPv4/IPv6 이중 스택 활성화</a>를
참조한다.</p>
<p>윈도우에서 쿠버네티스와 함께 IPv6를 사용하려면 윈도우 서버 버전 2004
(커널 버전 10.0.19041.610) 이상이 필요하다.</p>
<p>윈도우의 오버레이(VXLAN) 네트워크는 현재 이중 스택 네트워킹을 지원하지 않는다.</p>
<h3 id=제한>제한</h3>
<p>윈도우는 쿠버네티스 아키텍처 및 컴포넌트 매트릭스에서 워커
노드로만 지원된다. 즉, 쿠버네티스 클러스터에는 항상 리눅스 마스터 노드가 반드시
포함되어야 하고, 0개 이상의 리눅스 워커 노드 및 0개 이상의 윈도우
워커 노드가 포함된다.</p>
<h4 id=자원-관리>자원 관리</h4>
<p>리눅스 cgroup은 리눅스에서 리소스 제어를 위한 파드 경계로 사용된다.
컨테이너는 네트워크, 프로세스 및 파일시스템 격리를 위해 해당
경계 내에 생성된다. cgroups API는 cpu/io/memory 통계를 수집하는 데 사용할 수 있다.
반대로 윈도우는 시스템 네임스페이스 필터가 있는 컨테이너별로 잡(Job)
오브젝트를 사용하여 컨테이너의 모든 프로세스를 포함하고 호스트와의
논리적 격리를 제공한다. 네임스페이스 필터링 없이 윈도우 컨테이너를
실행할 수 있는 방법은 없다. 즉, 시스템 권한은 호스트 컨텍스트에서 삽입될(assert) 수 없으므로
권한이 있는(privileged) 컨테이너는 윈도우에서 사용할 수 없다. 보안 계정
매니져(Security Account Manager, SAM)가 분리되어 있으므로
컨테이너는 호스트의 ID를 가정할 수 없다.</p>
<h4 id=자원-예약>자원 예약</h4>
<h5 id=메모리-예약>메모리 예약</h5>
<p>윈도우에는 리눅스에는 있는 메모리 부족 프로세스 킬러가 없다. 윈도우는
모든 사용자-모드 메모리 할당을 항상 가상 메모리처럼 처리하며, 페이지파일이
필수이다. 결과적으로 윈도우에서는 리눅스에서 발생할 수 있는
메모리 부족 상태에 도달하지 않으며, 프로세스는 메모리 부족(out of memory, OOM) 종료를
겪는 대신 디스크로 페이징한다. 메모리가 오버프로비저닝되고
모든 물리 메모리가 고갈되면 페이징으로 인해 성능이 저하될 수 있다.</p>
<p>kubelet 파라미터 <code>--kubelet-reserve</code> 를 사용하여 메모리 사용량을
합리적인 범위 내로 유지할 수 있으며, <code>--system-reserve</code> 를 사용하여
노드(컨테이너 외부)의 메모리 사용량을 예약할 수 있다. 이들을 사용하면 그만큼
<a href=/docs/tasks/administer-cluster/reserve-compute-resources/#node-allocatable>노드 할당(NodeAllocatable)</a>은 줄어든다.</p>
<p>워크로드를 배포할 때, 컨테이너에 리소스 제한을
걸어라(제한만 설정하거나, 제한이 요청과 같아야 함). 이 또한 NodeAllocatable에서 차감되며,
메모리가 꽉 찬 노드에 스케줄러가 파드를 할당하지 않도록 제한한다.</p>
<p>오버프로비저닝을 방지하는 가장 좋은 방법은 윈도우, 도커, 그리고
쿠버네티스 프로세스를 위해 최소 2GB 이상의 시스템 예약 메모리로
kubelet을 설정하는 것이다.</p>
<h5 id=cpu-예약>CPU 예약</h5>
<p>윈도우, 도커, 그리고 다른 쿠버네티스 호스트 프로세스가 이벤트에
잘 응답할 수 있도록, CPU의 일정 비율을 예약하는 것이
좋다. 이 값은 윈도우 노드에 있는 CPU 코어 수에
따라 조정해야 한다. 이 비율을 결정하려면, 각 노드의
최대 파드 밀도(density)를 관찰하고, 시스템 서비스의 CPU
사용량을 모니터링하여 워크로드 요구사항을 충족하는 값을 선택해야 한다.</p>
<p>kubelet 파라미터 <code>--kubelet-reserve</code> 를 사용하여 CPU 사용량을
합리적인 범위 내로 유지할 수 있으며, <code>--system-reserve</code> 를 사용하여
노드 (컨테이너 외부) 의 CPU 사용량을 예약할 수 있다. 이들을 사용하면 그만큼
<a href=/docs/tasks/administer-cluster/reserve-compute-resources/#node-allocatable>노드 할당(NodeAllocatable)</a>은 줄어든다.</p>
<h4 id=기능-제한>기능 제한</h4>
<ul>
<li>TerminationGracePeriod: 구현되지 않음</li>
<li>단일 파일 매핑: CRI-ContainerD로 구현 예정</li>
<li>종료 메시지: CRI-ContainerD로 구현 예정</li>
<li>특권을 가진(Privileged) 컨테이너: 현재 윈도우 컨테이너에서 지원되지 않음</li>
<li>HugePages: 현재 윈도우 컨테이너에서 지원되지 않음</li>
<li>기존 노드 문제 감지기는 리눅스 전용이며 특권을 가진
컨테이너가 필요하다. 윈도우에서 특권을 가진 컨테이너를 지원하지 않기 때문에
일반적으로 윈도우에서 이 기능이 사용될 것으로 예상하지 않는다.</li>
<li>공유 네임스페이스의 모든 기능이 지원되는 것은 아니다. (자세한 내용은
API 섹션 참조).</li>
</ul>
<h4 id=각-플래그의-리눅스와의-차이점>각 플래그의 리눅스와의 차이점</h4>
<p>윈도우 노드에서의 kubelet 플래그의 동작은 아래에 설명된 대로 다르게 동작한다.</p>
<ul>
<li>
<p><code>--kubelet-reserve</code>, <code>--system-reserve</code>, <code>--eviction-hard</code> 플래그는
Node Allocatable 업데이트</p>
</li>
<li>
<p><code>--enforce-node-allocable</code>을 사용한 축출(Eviction)은 구현되지 않았다.</p>
</li>
<li>
<p><code>--eviction-hard</code>와 <code>--eviction-soft</code>를 사용한 축출은 구현되지 않았다.</p>
</li>
<li>
<p>MemoryPressure 조건은 구현되지 않았다.</p>
</li>
<li>
<p>kubelet이 취한 OOM 축출 조치가 없다.</p>
</li>
<li>
<p>윈도우 노드에서 실행되는 Kubelet에는 메모리 제한이 없다.
<code>--kubelet-reserve</code>와 <code>--system-reserve</code>는 호스트에서 실행되는 kubelet 또는
프로세스에 제한을 설정하지 않는다. 이는 호스트의 kubelet 또는 프로세스가
node-allocatable 및 스케줄러 외부에서 메모리 리소스 부족을 유발할 수 있음을
의미한다.</p>
</li>
<li>
<p>kubelet 프로세스의 우선 순위를 설정하는 추가 플래그는
<code>--windows-priorityclass</code>라는 윈도우 노드에서 사용할 수 있다. 이 플래그를 사용하면
kubelet 프로세스가 윈도우 호스트에서 실행중인 다른 프로세스와 비교할 때 더 많은 CPU 시간
슬라이스을 얻을 수 있다. 허용되는 값과 그 의미에 대한 자세한 내용은
<a href=https://docs.microsoft.com/en-us/windows/win32/procthread/scheduling-priorities#priority-class>윈도우 우선순위 클래스</a>에서
확인할 수 있다.
kubelet이 항상 충분한 CPU주기를 갖도록 하려면
이 플래그를 <code>ABOVE_NORMAL_PRIORITY_CLASS</code> 이상으로 설정하는 것이 좋다.</p>
</li>
</ul>
<h4 id=스토리지>스토리지</h4>
<p>윈도우에는 컨테이너 계층을 마운트하고 NTFS를 기반으로 하는 복제 파일시스템을
만드는 레이어드(layered) 파일시스템 드라이버가 있다. 컨테이너의 모든 파일 경로는
해당 컨테이너의 컨텍스트 내에서만 확인된다.</p>
<ul>
<li>
<p>도커 볼륨 마운트는 개별 파일이 아닌 컨테이너의
디렉터리만 대상으로 할 수 있다. 이 제한은 CRI-containerD에는 존재하지 않는다.</p>
</li>
<li>
<p>볼륨 마운트는 파일이나 디렉터리를 호스트 파일시스템으로 다시
투영할 수 없다.</p>
</li>
<li>
<p>읽기 전용 파일시스템은 윈도우 레지스트리 및 SAM 데이터베이스에 항상
쓰기 접근이 필요하기 때문에 지원되지 않는다. 그러나 읽기 전용
볼륨은 지원된다.</p>
</li>
<li>
<p>볼륨 사용자 마스크(user-masks) 및 권한은 사용할 수 없다. SAM은
호스트와 컨테이너 간에 공유되지 않기 때문에 이들 간에 매핑이 없다. 모든
권한은 컨테이너 컨텍스트 내에서 해결된다.</p>
</li>
</ul>
<p>결과적으로, 다음 스토리지 기능은 윈도우 노드에서 지원되지 않는다.</p>
<ul>
<li>볼륨 하위 경로(subpath) 마운트. 전체 볼륨만 윈도우 컨테이너에 마운트할 수 있다.</li>
<li>시크릿에 대한 하위 경로 볼륨 마운트</li>
<li>호스트 마운트 프로젝션</li>
<li>DefaultMode(UID/GID 종속성에 기인함)</li>
<li>읽기 전용 루트 파일시스템. 매핑된 볼륨은 여전히 읽기 전용을 지원한다.</li>
<li>블록 디바이스 매핑</li>
<li>저장 매체로서의 메모리</li>
<li>uui/guid, 사용자별 리눅스 파일시스템 권한과 같은 파일시스템 기능</li>
<li>NFS 기반 스토리지/볼륨 지원</li>
<li>마운트된 볼륨 확장(resizefs)</li>
</ul>
<h4 id=네트워킹-제한>네트워킹</h4>
<p>윈도우 컨테이너 네트워킹은 리눅스 네트워킹과 몇 가지 중요한 면에서
다르다. <a href=https://docs.microsoft.com/ko-kr/virtualization/windowscontainers/container-networking/architecture>윈도우 컨테이너 네트워킹에 대한 Microsoft 문서</a>에는
추가 세부 정보와 배경이 포함되어 있다.</p>
<p>윈도우 호스트 네트워킹 서비스와 가상 스위치는 네임스페이스를
구현하고 파드 또는 컨테이너에 필요한 가상 NIC을 만들 수 있다. 그러나
DNS, 라우트, 메트릭과 같은 많은 구성은 리눅스에서와 같이 /etc/... 파일이
아닌 윈도우 레지스트리 데이터베이스에 저장된다. 컨테이너의
윈도우 레지스트리는 호스트 레지스트리와 별개이므로 호스트에서
컨테이너로 /etc/resolv.conf를 매핑하는 것과 같은 개념은 리눅스에서와
동일한 효과를 갖지 않는다. 해당 컨테이너의 컨텍스트에서 실행되는 윈도우 API를
사용하여 구성해야 한다. 따라서 CNI 구현에서는 파일 매핑에 의존하는
대신 HNS를 호출하여 네트워크 세부 정보를 파드 또는 컨테이너로
전달해야 한다.</p>
<p>다음 네트워킹 기능은 윈도우 노드에서 지원되지 않는다.</p>
<ul>
<li>
<p>윈도우 파드에서는 호스트 네트워킹 모드를 사용할 수 없다.</p>
</li>
<li>
<p>노드 자체에서 로컬 NodePort 접근은 실패한다. (다른 노드 또는
외부 클라이언트에서는 가능)</p>
</li>
<li>
<p>노드에서 서비스 VIP에 접근하는 것은 향후 윈도우 서버 릴리스에서
사용할 수 있다.</p>
</li>
<li>
<p>한 서비스는 최대 64개의 백엔드 파드 또는 고유한 목적지 IP를 지원할 수 있다.</p>
</li>
<li>
<p>kube-proxy의 오버레이 네트워킹 지원은 베타 기능이다. 또한
윈도우 서버 2019에 <a href=https://support.microsoft.com/ko-kr/help/4482887/windows-10-update-kb4482887>KB4482887</a>을
설치해야 한다.</p>
</li>
<li>
<p>비-DSR 모드의 로컬 트래픽 정책</p>
</li>
<li>
<p>오버레이 네트워크에 연결된 윈도우 컨테이너는
IPv6 스택을 통한 통신을 지원하지 않는다. 이 네트워크 드라이버가 IPv6 주소를
사용하고 kubelet, kube-proxy 및 CNI 플러그인에서 후속 쿠버네티스 작업을
사용할 수 있도록 하는데 필요한 뛰어난 윈도우 플랫폼 작업이 있다.</p>
</li>
<li>
<p>win-overlay, win-bridge, Azure-CNI 플러그인을 통해
ICMP 프로토콜을 사용하는 아웃바운드 통신. 특히, 윈도우 데이터 플레인
(<a href=https://www.microsoft.com/en-us/research/project/azure-virtual-filtering-platform/>VFP</a>)은
ICMP 패킷 치환을 지원하지 않는다. 이것은 다음을 의미한다.</p>
<ul>
<li>
<p>동일한 네트워크(예: ping을 통한 파드 간 통신) 내의 목적지로 전달되는
ICMP 패킷은 예상대로 제한 없이 작동한다.</p>
</li>
<li>
<p>TCP/UDP 패킷은 예상대로 제한 없이 작동한다.</p>
</li>
<li>
<p>원격 네트워크를 통과하도록 지정된 ICMP 패킷(예: ping을 통한
파드에서 외부 인터넷으로의 통신)은 치환될 수 없으므로
소스로 다시 라우팅되지 않는다.</p>
</li>
<li>
<p>TCP/UDP 패킷은 여전히 치환될 수 있기 때문에
<code>ping &lt;destination></code>을 <code>curl &lt;destination></code>으로 대체하여
외부와의 연결을 디버깅할 수 있다.</p>
</li>
</ul>
</li>
</ul>
<p>해당 기능은 쿠버네티스 v1.15에 추가되었다.</p>
<ul>
<li><code>kubectl port-forward</code></li>
</ul>
<h5 id=cni-플러그인>CNI 플러그인</h5>
<ul>
<li>
<p>윈도우 참조 네트워크 플러그인 win-bridge와 win-overlay는
현재 "CHECK" 구현 누락으로 인해 <a href=https://github.com/containernetworking/cni/blob/master/SPEC.md>CNI 사양</a>
v0.4.0을 구현하지 않는다.</p>
</li>
<li>
<p>Flannel VXLAN CNI는 윈도우에서 다음과 같은 제한이 있다.</p>
<ol>
<li>
<p>노드-파드 연결은 설계상 불가능하다. Flannel v0.12.0(또는 그 이상)이
있는 로컬 파드에서만 가능하다.</p>
</li>
<li>
<p>VNI 4096와 UDP 4789 포트 사용은 제한된다. VNI 제한은
작업 중이며 향후 릴리스(오픈 소스 flannel 변경)에서
구현될 것이다. 이러한 파라미터에 대한 자세한 내용은 공식
<a href=https://github.com/coreos/flannel/blob/master/Documentation/backends.md#vxlan>Flannel VXLAN</a>
백엔드 문서를 참고한다.</p>
</li>
</ol>
</li>
</ul>
<h5 id=dns-limitations>DNS</h5>
<ul>
<li>
<p>ClusterFirstWithHostNet은 DNS에서 지원되지 않는다. 윈도우는
'.'이 있는 모든 이름을 FQDN으로 처리하고 PQDN 확인을 건너뛴다.</p>
</li>
<li>
<p>리눅스에서는 PQDN을 확인하려고 할 때 사용되는 DNS 접미사 목록이
있다. 윈도우에서는 해당 파드의 네임스페이스(예: mydns.svc.cluster.local)와
연결된 DNS 접미사인 DNS 접미사 1개만 있다.
윈도우는 FQDN과 서비스 또는 해당 접미사만으로 확인할 수 있는 이름을 확인할 수
있다. 예를 들어, 디폴트 네임스페이스에서 생성된 파드에는 DNS
접미사 <code>default.svc.cluster.local</code>이 있다. 윈도우 파드에서는
<code>kubernetes.default.svc.cluster.local</code> 및 <code>kubernetes</code>를 모두 확인할 수
있지만 <code>kubernetes.default</code> 또는 <code>kubernetes.default.svc</code>와 같은 중간 항목은 확인할 수 없다.</p>
</li>
<li>
<p>윈도우에서는 사용할 수 있는 여러 가지의 DNS 리졸버(resolver)가 있다. 이들은
약간 다른 동작을 제공하므로, 이름 쿼리 확인을 위해 <code>Resolve-DNSName</code> 유틸리티를
사용하는 것이 좋다.</p>
</li>
</ul>
<h5 id=ipv6>IPv6</h5>
<p>윈도우의 쿠버네티스는 단일 스택 "IPv6 전용" 네트워킹을 지원하지 않는다.
그러나 단일 제품군 서비스를 사용하는 파드와 노드에 대한 이중 스택 IPv4/IPv6 네트워킹이
지원된다.
자세한 내용은 <a href=#ipv4ipv6-%EC%9D%B4%EC%A4%91-%EC%8A%A4%ED%83%9D>IPv4/IPv6 이중 스택 네트워킹</a>을 참고한다.</p>
<h5 id=세션-어피니티-affinity>세션 어피니티(affinity)</h5>
<p><code>service.spec.sessionAffinityConfig.clientIP.timeoutSeconds</code>를 사용하는
윈도우 서비스의 최대 세션 고정(sticky) 시간 설정은 지원되지 않는다.</p>
<h5 id=보안>보안</h5>
<p>시크릿(Secret)은 노드의 볼륨(리눅스의 tmpfs/in-memory와
비교)에 일반 텍스트로 작성된다. 이는 고객이 두 가지 작업을 수행해야 함을 의미한다.</p>
<ol>
<li>파일 ACL을 사용하여 시크릿 파일 위치를 보호한다.</li>
<li><a href=https://docs.microsoft.com/ko-kr/windows/security/information-protection/bitlocker/bitlocker-how-to-deploy-on-windows-server>BitLocker</a>를
사용한 볼륨-레벨 암호화를 사용한다.</li>
</ol>
<p><a href=/ko/docs/tasks/configure-pod-container/configure-runasusername/>RunAsUsername</a>은
컨테이너 프로세스를 노드 기본 사용자로 실행하기 위해 윈도우 파드 또는
컨테이너에 지정할 수 있다. 이것은
<a href=/ko/docs/concepts/policy/pod-security-policy/#%EC%82%AC%EC%9A%A9%EC%9E%90-%EB%B0%8F-%EA%B7%B8%EB%A3%B9>RunAsUser</a>와 거의 동일하다.</p>
<p>SELinux, AppArmor, Seccomp, 기능(POSIX 기능)과 같은
리눅스 특유의 파드 시큐리티 컨텍스트 권한은 지원하지 않는다.</p>
<p>또한 이미 언급했듯이 특권을 가진 컨테이너는 윈도우에서 지원되지
않는다.</p>
<h4 id=api>API</h4>
<p>대부분의 Kubernetes API가 윈도우에서 작동하는 방식은 차이가 없다.
중요한 차이점은 OS와 컨테이너 런타임의 차이로
귀결된다. 특정 상황에서 파드 또는 컨테이너와 같은 워크로드 API의
일부 속성은 리눅스에서 구현되고 윈도우에서 실행되지 않는다는 가정 하에
설계되었다.</p>
<p>높은 수준에서 이러한 OS 개념은 다르다.</p>
<ul>
<li>
<p>ID - 리눅스는 정수형으로 표시되는 userID(UID) 및 groupID(GID)를
사용한다. 사용자와 그룹 이름은 정식 이름이 아니다. UID+GID에 대한
<code>/etc/groups</code> 또는 <code>/etc/passwd</code>의 별칭일 뿐이다. 윈도우는 윈도우
보안 계정 관리자(Security Account Manager, SAM) 데이터베이스에
저장된 더 큰 이진 보안 식별자(SID)를 사용한다. 이 데이터베이스는 호스트와
컨테이너 간에 또는 컨테이너들 간에 공유되지 않는다.</p>
</li>
<li>
<p>파일 퍼미션 - 윈도우는 권한 및 UUID+GID의 비트 마스크(bitmask) 대신
SID를 기반으로 하는 접근 제어 목록을 사용한다.</p>
</li>
<li>
<p>파일 경로 - 윈도우의 규칙은 <code>/</code> 대신 <code>\</code>를 사용하는 것이다. Go IO
라이브러리는 두 가지 파일 경로 분리자를 모두 허용한다. 하지만, 컨테이너
내부에서 해석되는 경로 또는 커맨드 라인을 설정할 때 <code>\</code>가 필요할 수
있다.</p>
</li>
<li>
<p>신호(Signals) - 윈도우 대화형(interactive) 앱은 종료를 다르게 처리하며, 다음 중
하나 이상을 구현할 수 있다.</p>
<ul>
<li>
<p>UI 스레드는 <code>WM_CLOSE</code>를 포함하여 잘 정의된(well-defined) 메시지를 처리한다.</p>
</li>
<li>
<p>콘솔 앱은 컨트롤 핸들러(Control Handler)를 사용하여 ctrl-c 또는 ctrl-break를 처리한다.</p>
</li>
<li>
<p>서비스는 <code>SERVICE_CONTROL_STOP</code> 제어 코드를 수용할 수 있는
Service Control Handler 함수를 등록한다.</p>
</li>
</ul>
</li>
</ul>
<p>종료 코드는 0일 때 성공, 0이 아닌 경우 실패인 동일한 규칙을 따른다.
특정 오류 코드는 윈도우와 리눅스에서 다를 수 있다. 그러나
쿠버네티스 컴포넌트(kubelet, kube-proxy)에서 전달된 종료 코드는
변경되지 않는다.</p>
<h5 id=v1-container>V1.Container</h5>
<ul>
<li>
<p>V1.Container.ResourceRequirements.limits.cpu 및
V1.Container.ResourceRequirements.limits.memory - 윈도우는 CPU 할당에 하드
리밋(hard limit)을 사용하지 않는다. 대신 공유 시스템이 사용된다. 밀리코어를
기반으로 하는 기존 필드는 윈도우 스케줄러가 뒤따르는 상대적인 공유로
스케일된다.
<a href=https://github.com/kubernetes/kubernetes/blob/master/pkg/kubelet/kuberuntime/helpers_windows.go>참고: kuberuntime/helpers_windows.go</a>,
<a href=https://docs.microsoft.com/ko-kr/virtualization/windowscontainers/manage-containers/resource-controls>참고: Microsoft 문서 내 리소스 제어</a></p>
<ul>
<li>Huge page는 윈도우 컨테이너 런타임에서 구현되지 않으며,
사용할 수 없다. 컨테이너에 대해 구성할 수 없는
<a href=https://docs.microsoft.com/en-us/windows/desktop/Memory/large-page-support>사용자 권한(privilege) 어설트</a>가
필요하다.</li>
</ul>
</li>
<li>
<p>V1.Container.ResourceRequirements.requests.cpu 및
V1.Container.ResourceRequirements.requests.memory - 노드의 사용 가능한
리소스에서 요청(requests)을 빼서, 노드에 대한 오버 프로비저닝을 방지하는데 사용할 수
있다. 그러나 오버 프로비저닝된 노드에서 리소스를 보장하는 데는
사용할 수 없다. 운영자가 오버 프로비저닝을 완전히 피하려는 경우
모범 사례로 모든 컨테이너에 적용해야 한다.</p>
</li>
<li>
<p>V1.Container.SecurityContext.allowPrivilegeEscalation - 윈도우에서는
불가능하며, 어떤 기능도 연결되지 않는다.</p>
</li>
<li>
<p>V1.Container.SecurityContext.Capabilities - POSIX 기능은 윈도우에서
구현되지 않는다.</p>
</li>
<li>
<p>V1.Container.SecurityContext.privileged - 윈도우는 특권을 가진 컨테이너를
지원하지 않는다.</p>
</li>
<li>
<p>V1.Container.SecurityContext.procMount - 윈도우에는 /proc 파일시스템이 없다.</p>
</li>
<li>
<p>V1.Container.SecurityContext.readOnlyRootFilesystem - 윈도우에서는 불가능하며,
레지스트리 및 시스템 프로세스가 컨테이너 내부에서 실행되려면 쓰기 권한이
필요하다.</p>
</li>
<li>
<p>V1.Container.SecurityContext.runAsGroup - 윈도우에서는 불가능하며, GID 지원이 없다.</p>
</li>
<li>
<p>V1.Container.SecurityContext.runAsNonRoot - 윈도우에는 root 사용자가
없다. 가장 가까운 항목은 노드에 존재하지 않는 아이덴티티(identity)인
ContainerAdministrator이다.</p>
</li>
<li>
<p>V1.Container.SecurityContext.runAsUser - 윈도우에서는 불가능하며, 정수값으로의 UID
지원이 없다.</p>
</li>
<li>
<p>V1.Container.SecurityContext.seLinuxOptions - 윈도우에서는 불가능하며, SELinux가 없다.</p>
</li>
<li>
<p>V1.Container.terminationMessagePath - 윈도우가 단일 파일 매핑을 지원하지
않는다는 점에서 몇 가지 제한이 있다. 기본값은 /dev/termination-log이며, 기본적으로 윈도우에 존재하지 않기 때문에
작동한다.</p>
</li>
</ul>
<h5 id=v1-pod>V1.Pod</h5>
<ul>
<li>
<p>V1.Pod.hostIPC, v1.pod.hostpid - 윈도우에서 호스트 네임스페이스 공유가 불가능하다.</p>
</li>
<li>
<p>V1.Pod.hostNetwork - 호스트 네트워크를 공유하기 위한 윈도우 OS 지원이 없다.</p>
</li>
<li>
<p>V1.Pod.dnsPolicy - ClusterFirstWithHostNet - 윈도우에서 호스트 네트워킹이 지원되지 않기 때문에
지원되지 않는다.</p>
</li>
<li>
<p>V1.Pod.podSecurityContext - 아래 V1.PodSecurityContext 내용을 참고한다.</p>
</li>
<li>
<p>V1.Pod.shareProcessNamespace - 이것은 베타 기능이며, 윈도우에서 구현되지 않은
리눅스 네임스페이스에 따라 다르다. 윈도우는 프로세스 네임스페이스 또는
컨테이너의 루트 파일시스템을 공유할 수 없다. 네트워크만 공유할 수
있다.</p>
</li>
<li>
<p>V1.Pod.terminationGracePeriodSeconds - 이것은 윈도우의 도커에서
완전히 구현되지 않았다.
<a href=https://github.com/moby/moby/issues/25982>참조</a>의 내용을 참고한다. 현재 동작은
<code>ENTRYPOINT</code> 프로세스가 <code>CTRL_SHUTDOWN_EVENT</code>로 전송된 다음, 윈도우가 기본적으로 5초를
기다린 후, 마지막으로 정상적인 윈도우 종료 동작을 사용하여 모든 프로세스를
종료하는 것이다. 5초 기본값은 실제로
<a href=https://github.com/moby/moby/issues/25982#issuecomment-426441183>컨테이너 내부</a>
윈도우 레지스트리에 있으므로 컨테이너를 빌드할 때 재정의 할 수 있다.</p>
</li>
<li>
<p>V1.Pod.volumeDevices - 이것은 베타 기능이며, 윈도우에서 구현되지
않는다. 윈도우는 원시 블록 장치(raw block device)를 파드에 연결할 수 없다.</p>
</li>
<li>
<p>V1.Pod.volumes - EmptyDir, 시크릿, 컨피그맵, HostPath - 모두 작동하며
TestGrid에 테스트가 있다.</p>
<ul>
<li>V1.emptyDirVolumeSource - 노드 기본 매체는 윈도우의 디스크이다.
윈도우에는 내장 RAM 디스크가 없기 때문에 메모리는 지원되지 않는다.</li>
</ul>
</li>
<li>
<p>V1.VolumeMount.mountPropagation - 마운트 전파(propagation)는 윈도우에서 지원되지 않는다.</p>
</li>
</ul>
<h5 id=v1-podsecuritycontext>V1.PodSecurityContext</h5>
<p>PodSecurityContext 필드는 윈도우에서 작동하지 않는다. 참조를 위해 여기에
나열한다.</p>
<ul>
<li>
<p>V1.PodSecurityContext.SELinuxOptions - SELinux는 윈도우에서 사용할 수 없다.</p>
</li>
<li>
<p>V1.PodSecurityContext.RunAsUser - 윈도우에서는 사용할 수 없는 UID를 제공한다.</p>
</li>
<li>
<p>V1.PodSecurityContext.RunAsGroup - 윈도우에서는 사용할 수 없는 GID를 제공한다.</p>
</li>
<li>
<p>V1.PodSecurityContext.RunAsNonRoot - 윈도우에는 root 사용자가 없다. 가장
가까운 항목은 노드에 존재하지 않는 아이덴티티인
ContainerAdministrator이다.</p>
</li>
<li>
<p>V1.PodSecurityContext.SupplementalGroups - 윈도우에서는 사용할 수 없는 GID를 제공한다.</p>
</li>
<li>
<p>V1.PodSecurityContext.Sysctls - 이것들은 리눅스 sysctl 인터페이스의
일부이다. 윈도우에는 이에 상응하는 것이 없다.</p>
</li>
</ul>
<h4 id=운영-체제-버전-제한>운영 체제 버전 제한</h4>
<p>윈도우에는 호스트 OS 버전이 컨테이너 베이스 이미지 OS 버전과 일치해야 하는
엄격한 호환성 규칙이 있다. 윈도우 서버 2019의 컨테이너
운영 체제가 있는 윈도우 컨테이너만 지원된다. 윈도우 컨테이너 이미지 버전의 일부
이전 버전과의 호환성을 가능하게 하는 컨테이너의 Hyper-V 격리는
향후 릴리스로 계획되어 있다.</p>
<h2 id=troubleshooting>도움 받기 및 트러블슈팅</h2>
<p>쿠버네티스 클러스터 트러블슈팅을 위한 기본
도움말은 이
<a href=/ko/docs/tasks/debug-application-cluster/troubleshooting/>섹션</a>에서 먼저 찾아야 한다. 이
섹션에는 몇 가지 추가 윈도우 관련 트러블슈팅 도움말이 포함되어 있다.
로그는 쿠버네티스에서 트러블슈팅하는데 중요한 요소이다. 다른
기여자로부터 트러블슈팅 지원을 구할 때마다 이를 포함해야
한다. SIG-Windows
<a href=https://github.com/kubernetes/community/blob/master/sig-windows/CONTRIBUTING.md#gathering-logs>로그 수집에 대한 기여 가이드</a>의 지침을 따른다.</p>
<ul>
<li>
<p>start.ps1이 성공적으로 완료되었는지 어떻게 알 수 있는가?</p>
<p>kubelet, kube-proxy 및 (Flannel을 네트워킹 솔루션으로
선택한 경우) 노드에서 실행 중인 flanneld 호스트 에이전트 프로세스를
확인할 수 있어야 하는데, 별도의 PowerShell 윈도우에서 실행 중인 로그가 표시된다. 또한
윈도우 노드는 쿠버네티스 클러스터에서 "Ready"로 조회되어야
한다.</p>
</li>
<li>
<p>백그라운드에서 서비스로 실행되도록 쿠버네티스 노드 프로세스를 구성할 수 있는가?</p>
<p>Kubelet 및 kube-proxy는 이미 기본 윈도우 서비스로 실행되도록
구성되어 있으며, 실패(예: 프로세스 충돌) 시 서비스를
자동으로 다시 시작하여 복원력(resiliency)을
제공한다. 이러한 노드 컴포넌트를 서비스로 구성하기 위한
두 가지 옵션이 있다.</p>
<ul>
<li>
<p>네이티브 윈도우 서비스</p>
<p>Kubelet와 kube-proxy는 <code>sc.exe</code>를 사용하여 네이티브 윈도우 서비스로 실행될 수 있다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=color:#080;font-style:italic># 두 개의 개별 명령으로 kubelet 및 kube-proxy에 대한 서비스 생성</span>
sc.exe create &lt;컴포넌트_명&gt; binPath= <span style=color:#b44>&#34;&lt;바이너리_경로&gt; --service &lt;다른_인자&gt;&#34;</span>

<span style=color:#080;font-style:italic># 인자에 공백이 포함된 경우 이스케이프 되어야 한다.</span>
sc.exe create kubelet binPath= <span style=color:#b44>&#34;C:\kubelet.exe --service --hostname-override &#39;minion&#39; &lt;다른_인자&gt;&#34;</span>

<span style=color:#080;font-style:italic># 서비스 시작</span>
<span style=color:#a2f>Start-Service</span> kubelet
<span style=color:#a2f>Start-Service</span> <span style=color:#a2f>kube-proxy</span>

<span style=color:#080;font-style:italic># 서비스 중지</span>
<span style=color:#a2f>Stop-Service</span> kubelet (-Force)
<span style=color:#a2f>Stop-Service</span> <span style=color:#a2f>kube-proxy</span> (-Force)

<span style=color:#080;font-style:italic># 서비스 상태 질의</span>
<span style=color:#a2f>Get-Service</span> kubelet
<span style=color:#a2f>Get-Service</span> <span style=color:#a2f>kube-proxy</span>
</code></pre></div></li>
<li>
<p>nssm.exe 사용</p>
<p>또한 언제든지 <a href=https://nssm.cc/>nssm.exe</a>와 같은
대체 서비스 관리자를 사용하여 백그라운드에서 이러한 프로세스(flanneld, kubelet,
kube-proxy)를 실행할 수 있다. 이
<a href=https://github.com/Microsoft/SDN/tree/master/Kubernetes/flannel/register-svc.ps1>샘플 스크립트</a>를 사용하여
백그라운드에서 윈도우 서비스로 실행하기 위해 <code>nssm.exe</code>를 활용하여 kubelet, kube-proxy,
<code>flanneld.exe</code>를 등록할 수 있다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=color:#a2f>register-svc</span>.ps1 -NetworkMode &lt;네트워크 모드&gt; -ManagementIP &lt;윈도우 노드 IP&gt; -ClusterCIDR &lt;클러스터 서브넷&gt; -KubeDnsServiceIP &lt;<span style=color:#a2f>Kube-dns</span> 서비스 IP&gt; -LogDir &lt;로그 위치 디렉터리&gt;
</code></pre></div><p>파라미터 설명은 아래와 같다.</p>
<ul>
<li><code>NetworkMode</code>: 네트워크 모드 l2bridge(flannel host-gw,
기본값이기도 함) 또는 네트워크 솔루션으로 선택한 오버레이(flannel vxlan)</li>
<li><code>ManagementIP</code>: 윈도우 노드에 할당된 IP 주소. <code>ipconfig</code>를 사용하여
찾을 수 있다.</li>
<li><code>ClusterCIDR</code>: 클러스터 서브넷 범위. (기본값 10.244.0.0/16)</li>
<li><code>KubeDnsServiceIP</code>: 쿠버네티스 DNS 서비스 IP (기본값 10.96.0.10)</li>
<li><code>LogDir</code>: kubelet 및 kube-proxy 로그가 각각의 출력 파일로
리다이렉션되는 디렉터리(기본값 C:\k)</li>
</ul>
<p>위에 언급된 스크립트가 적합하지 않은 경우, 다음 예제를 사용하여
<code>nssm.exe</code>를 수동으로 구성할 수 있다.</p>
<p>flanneld.exe를 등록한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell>nssm install flanneld C:\flannel\flanneld.exe
nssm <span style=color:#a2f>set </span>flanneld AppParameters --kubeconfig<span style=color:#666>-file</span>=c:\k\config --iface=&lt;ManagementIP&gt; --ip-masq=1 --kube-subnet-mgr=1
nssm <span style=color:#a2f>set </span>flanneld AppEnvironmentExtra NODE_NAME=&lt;hostname&gt;
nssm <span style=color:#a2f>set </span>flanneld AppDirectory C:\flannel
nssm <span style=color:#a2f>start </span>flanneld
</code></pre></div><p>kubelet.exe를 등록한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell>nssm install kubelet C:\k\kubelet.exe
nssm <span style=color:#a2f>set </span>kubelet AppParameters --hostname-override=&lt;hostname&gt; --v=6 --pod-infra-container-image=k8s.gcr.io/pause<span>:</span>3.5 --resolv-conf=<span style=color:#b44>&#34;&#34;</span> --allow-privileged=true --enable-debugging-handlers --cluster-dns=&lt;<span style=color:#a2f>DNS-service</span>-IP&gt; --cluster-domain=cluster.local --kubeconfig=c:\k\config --hairpin-mode=<span style=color:#a2f>promiscuous-bridge</span> --image-pull-progress-deadline=20m --cgroups-per-qos=false  --log-dir=&lt;log directory&gt; --logtostderr=false --enforce-node-allocatable=<span style=color:#b44>&#34;&#34;</span> --network-plugin=cni --cni-bin-dir=c:\k\cni --cni-conf-dir=c:\k\cni\config
nssm <span style=color:#a2f>set </span>kubelet AppDirectory C:\k
nssm <span style=color:#a2f>start </span>kubelet
</code></pre></div><p>kube-proxy.exe를 등록한다(l2bridge / host-gw).</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell>nssm install <span style=color:#a2f>kube-proxy</span> C:\k\<span style=color:#a2f>kube-proxy</span>.exe
nssm <span style=color:#a2f>set kube-proxy</span> AppDirectory c:\k
nssm <span style=color:#a2f>set kube-proxy</span> AppParameters --v=4 --proxy-mode=kernelspace --hostname-override=&lt;hostname&gt;--kubeconfig=c:\k\config --enable-dsr=false --log-dir=&lt;log directory&gt; --logtostderr=false
nssm.exe <span style=color:#a2f>set kube-proxy</span> AppEnvironmentExtra KUBE_NETWORK=cbr0
nssm <span style=color:#a2f>set kube-proxy</span> DependOnService kubelet
nssm <span style=color:#a2f>start kube-proxy</span>
</code></pre></div><p>kube-proxy.exe를 등록한다(overlay / vxlan).</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell>nssm install <span style=color:#a2f>kube-proxy</span> C:\k\<span style=color:#a2f>kube-proxy</span>.exe
nssm <span style=color:#a2f>set kube-proxy</span> AppDirectory c:\k
nssm <span style=color:#a2f>set kube-proxy</span> AppParameters --v=4 --proxy-mode=kernelspace --feature-gates=<span style=color:#b44>&#34;WinOverlay=true&#34;</span> --hostname-override=&lt;hostname&gt; --kubeconfig=c:\k\config --network-name=vxlan0 --source-vip=&lt;<span style=color:#a2f>source-vip</span>&gt; --enable-dsr=false --log-dir=&lt;log directory&gt; --logtostderr=false
nssm <span style=color:#a2f>set kube-proxy</span> DependOnService kubelet
nssm <span style=color:#a2f>start kube-proxy</span>
</code></pre></div><p>초기 트러블슈팅을 위해 <a href=https://nssm.cc/>nssm.exe</a>에서
다음 플래그를 사용하여 stdout 및 stderr을 출력 파일로 리다이렉션할 수 있다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell>nssm <span style=color:#a2f>set </span>&lt;Service Name&gt; AppStdout C:\k\mysvc.log
nssm <span style=color:#a2f>set </span>&lt;Service Name&gt; AppStderr C:\k\mysvc.log
</code></pre></div><p>자세한 내용은 공식 <a href=https://nssm.cc/usage>nssm 사용</a> 문서를 참고한다.</p>
</li>
</ul>
</li>
<li>
<p>내 윈도우 파드에 네트워크 연결이 없다.</p>
<p>가상 머신을 사용하는 경우, 모든 VM 네트워크 어댑터에서 MAC 스푸핑이
활성화되어 있는지 확인한다.</p>
</li>
<li>
<p>내 윈도우 파드가 외부 리소스를 ping 할 수 없다.</p>
<p>윈도우 파드에는 현재 ICMP 프로토콜용으로 프로그래밍된 아웃바운드
규칙이 없다. 그러나 TCP/UDP는 지원된다. 클러스터 외부 리소스에 대한 연결을
시연하려는 경우, <code>ping &lt;IP></code>를 해당 <code>curl &lt;IP></code>명령으로
대체한다.</p>
<p>여전히 문제가 발생하는 경우,
<a href=https://github.com/Microsoft/SDN/blob/master/Kubernetes/flannel/l2bridge/cni/config/cni.conf>cni.conf</a>의
네트워크 구성에 특별히 추가 확인이 필요하다. 언제든지 이 정적 파일을 편집할 수 있다. 구성
업데이트는 새로 생성된 모든 쿠버네티스 리소스에 적용된다.</p>
<p>쿠버네티스 네트워킹 요구 사항 중
하나(<a href=/ko/docs/concepts/cluster-administration/networking/>쿠버네티스 모델</a>)는
클러스터 통신이 내부적으로 NAT 없이 발생하는 것이다. 이 요구 사항을
준수하기 위해 아웃바운드 NAT가 발생하지 않도록 하는 모든 통신에 대한
<a href=https://github.com/Microsoft/SDN/blob/master/Kubernetes/flannel/l2bridge/cni/config/cni.conf#L20>ExceptionList</a>가
있다. 그러나
이것은 쿼리하려는 외부 IP를 ExceptionList에서
제외해야 함도 의미한다. 그래야만 윈도우 파드에서 발생하는 트래픽이 제대로 SNAT 되어
외부에서 응답을 받는다. 이와 관련하여 <code>cni.conf</code>의 ExceptionList는 다음과
같아야 한다.</p>
<pre><code class=language-conf data-lang=conf>&quot;ExceptionList&quot;: [
    &quot;10.244.0.0/16&quot;,  # 클러스터 서브넷
    &quot;10.96.0.0/12&quot;,   # 서비스 서브넷
    &quot;10.127.130.0/24&quot; # 관리(호스트) 서브넷
]
</code></pre></li>
<li>
<p>내 윈도우 노드가 NodePort 서비스에 접근할 수 없다.</p>
<p>노드 자체에서는 로컬 NodePort 접근이 실패한다. 이것은 알려진
제약사항이다. NodePort 접근은 다른 노드 또는 외부 클라이언트에서는 가능하다.</p>
</li>
<li>
<p>컨테이너의 vNIC 및 HNS 엔드포인트가 삭제되었다.</p>
<p>이 문제는 <code>hostname-override</code> 파라미터가
<a href=/ko/docs/reference/command-line-tools-reference/kube-proxy/>kube-proxy</a>에
전달되지 않은 경우 발생할 수 있다.
이를 해결하려면 사용자는 다음과 같이 hostname을 kube-proxy에 전달해야 한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell>C:\k\<span style=color:#a2f>kube-proxy</span>.exe --hostname-override=$(hostname)
</code></pre></div></li>
<li>
<p>플란넬(flannel)을 사용하면 클러스터에 다시 조인(join)한 후 노드에 이슈가 발생한다.</p>
<p>이전에 삭제된 노드가 클러스터에 다시 조인될 때마다,
flannelD는 새 파드 서브넷을 노드에 할당하려고 한다. 사용자는 다음 경로에서
이전 파드 서브넷 구성 파일을 제거해야 한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=color:#a2f>Remove-Item</span> C:\k\SourceVip.json
<span style=color:#a2f>Remove-Item</span> C:\k\SourceVipRequest.json
</code></pre></div></li>
<li>
<p><code>start.ps1</code>을 시작한 후, flanneld가 "Waiting for the Network
to be created"에서 멈춘다.</p>
<p>이 <a href=https://github.com/coreos/flannel/issues/1066>이슈</a>에
대한 수많은 보고가 있다. 플란넬 네트워크의
관리 IP가 설정될 때의 타이밍 이슈일 가능성이 높다. 해결
방법은 start.ps1을 다시 시작하거나 다음과 같이 수동으로 다시 시작하는 것이다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=color:#a2f>PS </span>C:&gt; <span style=color:#800>[Environment]</span>::SetEnvironmentVariable(<span style=color:#b44>&#34;NODE_NAME&#34;</span>, <span style=color:#b44>&#34;&lt;Windows_Worker_Hostname&gt;&#34;</span>)
<span style=color:#a2f>PS </span>C:&gt; C:\flannel\flanneld.exe --kubeconfig<span style=color:#666>-file</span>=c:\k\config --iface=&lt;Windows_Worker_Node_IP&gt; --ip-masq=1 --kube-subnet-mgr=1
</code></pre></div></li>
<li>
<p><code>/run/flannel/subnet.env</code> 누락으로 인해 윈도우 파드를 시작할 수 없다.</p>
<p>이것은 플란넬이 제대로 실행되지 않았음을 나타낸다. flanneld.exe를
다시 시작하거나 쿠버네티스 마스터의
<code>/run/flannel/subnet.env</code>에서 윈도우 워커 노드의
<code>C:\run\flannel\subnet.env</code>로 파일을 수동으로 복사할 수 있고,
<code>FLANNEL_SUBNET</code> 행을 다른 숫자로 수정한다. 예를 들어, 다음은 노드 서브넷
10.244.4.1/24가 필요한 경우이다.</p>
<pre><code class=language-none data-lang=none>FLANNEL_NETWORK=10.244.0.0/16
FLANNEL_SUBNET=10.244.4.1/24
FLANNEL_MTU=1500
FLANNEL_IPMASQ=true
</code></pre></li>
<li>
<p>내 윈도우 노드가 서비스 IP를 사용하여 내 서비스에 접근할 수 없다.</p>
<p>이는 윈도우에서 현재 네트워킹 스택의 알려진 제약 사항이다.
그러나 윈도우 파드는 서비스 IP에 접근할 수 있다.</p>
</li>
<li>
<p>kubelet을 시작할 때 네트워크 어댑터를 찾을 수 없다.</p>
<p>윈도우 네트워킹 스택에는 쿠버네티스 네트워킹이 작동하기 위한
가상 어댑터가 필요하다. 다음 명령이 (어드민 셸에서) 결과를 반환하지
않으면, Kubelet이 작동하는데 필요한 필수 구성 요소인 가상 네트워크 생성이
실패한 것이다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=color:#a2f>Get-HnsNetwork</span> | ? Name <span style=color:#666>-ieq</span> <span style=color:#b44>&#34;cbr0&#34;</span>
<span style=color:#a2f>Get-NetAdapter</span> | ? Name <span style=color:#666>-Like</span> <span style=color:#b44>&#34;vEthernet (Ethernet*&#34;</span>
</code></pre></div><p>호스트 네트워크 어댑터가 "Ethernet"이 아닌 경우,
종종 start.ps1 스크립트의
<a href=https://github.com/microsoft/SDN/blob/master/Kubernetes/flannel/start.ps1#L7>InterfaceName</a>
파라미터를 수정하는 것이 좋다. 그렇지 않으면 <code>start-kubelet.ps1</code>
스크립트의 출력을 참조하여 가상 네트워크 생성 중에 오류가 있는지 확인한다.</p>
</li>
<li>
<p>내 파드가 "Container Creating"에서 멈췄거나 계속해서 다시 시작된다.</p>
<p>퍼즈 이미지가 OS 버전과 호환되는지 확인한다.
<a href=https://docs.microsoft.com/en-us/virtualization/windowscontainers/kubernetes/deploying-resources>지침</a>에서는
OS와 컨테이너가 모두 버전 1803이라고 가정한다. 이후 버전의
윈도우가 있는 경우, Insider 빌드와 같이 그에 따라 이미지를
조정해야 한다. 이미지는 Microsoft의
<a href=https://hub.docker.com/u/microsoft/>도커 리포지터리</a>를 참조한다.
그럼에도 불구하고, 퍼즈 이미지 Dockerfile과 샘플 서비스는 이미지가
:latest로 태그될 것으로 예상한다.</p>
</li>
<li>
<p>DNS 확인(resolution)이 제대로 작동하지 않는다.</p>
<p><a href=#dns-limitations>윈도우에 대한 DNS 제한</a>을 확인한다.</p>
</li>
<li>
<p><code>kubectl port-forward</code>가 "unable to do port forwarding: wincat not found"로 실패한다.</p>
<p>이는 쿠버네티스 1.15 및 퍼즈 인프라 컨테이너
<code>mcr.microsoft.com/oss/kubernetes/pause:1.4.1</code>에서 구현되었다.
해당 버전 또는 최신 버전을 사용해야 한다. 자체 퍼즈
인프라 컨테이너를 빌드하려면
<a href=https://github.com/kubernetes-sigs/sig-windows-tools/tree/master/cmd/wincat>wincat</a>을 포함해야 한다.</p>
<p>윈도우에서 포트 포워딩을 지원하려면 <a href=#pause-image>퍼즈 인프라 컨테이너</a>를 이용하기 위해서
wincat.exe가 필요하다.
윈도우 OS 버전과 호환되는 지원되는 이미지를 사용하고 있는지 확인해야 한다.
자신만의 퍼즈 인프라 컨테이너를 구축하려면
<a href=https://github.com/kubernetes/kubernetes/tree/master/build/pause/windows/wincat>wincat</a>을 포함해야 한다.</p>
</li>
<li>
<p>내 윈도우 서버 노드가 프록시 뒤에 있기 때문에 내 쿠버네티스
설치가 실패한다.</p>
<p>프록시 뒤에 있는 경우 다음 PowerShell 환경 변수를
정의해야 한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-PowerShell data-lang=PowerShell><span style=color:#800>[Environment]</span>::SetEnvironmentVariable(<span style=color:#b44>&#34;HTTP_PROXY&#34;</span>, <span style=color:#b44>&#34;http://proxy.example.com:80/&#34;</span>, <span style=color:#800>[EnvironmentVariableTarget]</span>::Machine)
<span style=color:#800>[Environment]</span>::SetEnvironmentVariable(<span style=color:#b44>&#34;HTTPS_PROXY&#34;</span>, <span style=color:#b44>&#34;http://proxy.example.com:443/&#34;</span>, <span style=color:#800>[EnvironmentVariableTarget]</span>::Machine)
</code></pre></div></li>
<li>
<p>퍼즈(<code>pause</code>) 컨테이너란 무엇인가?</p>
<p>쿠버네티스 파드에서는 컨테이너 엔드포인트를 호스팅하기 위해
먼저 인프라 또는 "퍼즈" 컨테이너가 생성된다. 인프라 및 워커 컨테이너를 포함하여
동일한 파드에 속하는 컨테이너는 공통 네트워크 네임스페이스 및
엔드포인트(동일한 IP 및 포트 공간)를 공유한다. 네트워크 구성을 잃지 않고
워커 컨테이너가 충돌하거나 다시 시작되도록 하려면 퍼즈 컨테이너가
필요하다.</p>
<p>퍼즈 이미지 추천 버전을 찾기 위해서는
<a href=#pause-image>퍼즈 이미지</a>를 참고한다.</p>
</li>
</ul>
<h3 id=추가-조사>추가 조사</h3>
<p>이러한 단계로 문제가 해결되지 않으면, 다음을 통해 쿠버네티스의 윈도우 노드에서
윈도우 컨테이너를 실행하는데 도움을 받을 수 있다.</p>
<ul>
<li>
<p>스택오버플로우 <a href=https://stackoverflow.com/questions/tagged/windows-server-container>윈도우 서버 컨테이너</a> 주제</p>
</li>
<li>
<p>쿠버네티스 공식 포럼 <a href=https://discuss.kubernetes.io/>discuss.kubernetes.io</a></p>
</li>
<li>
<p>쿠버네티스 슬랙 <a href=https://kubernetes.slack.com/messages/sig-windows>#SIG-Windows Channel</a></p>
</li>
</ul>
<h2 id=이슈-리포팅-및-기능-요청>이슈 리포팅 및 기능 요청</h2>
<p>버그처럼 보이는 부분이 있거나 기능
요청을 하고 싶다면,
<a href=https://github.com/kubernetes/kubernetes/issues>GitHub 이슈 트래킹 시스템</a>을
활용한다.
<a href=https://github.com/kubernetes/kubernetes/issues/new/choose>GitHub</a>에서 이슈를 열고
SIG-Windows에 할당할 수 있다. 먼저 이전에 보고된 이슈 목록을 검색하고
이슈에 대한 경험을 언급하고 추가 로그를
첨부해야 한다. SIG-Windows 슬랙은 티켓을 만들기 전에 초기 지원 및
트러블슈팅 아이디어를 얻을 수 있는 좋은 방법이기도 하다.</p>
<p>버그를 제출하는 경우, 다음과 같이 문제를 재현하는 방법에 대한 자세한 정보를
포함한다.</p>
<ul>
<li>쿠버네티스 버전: kubectl version</li>
<li>환경 세부사항: 클라우드 공급자, OS 배포판, 네트워킹 선택 및
구성, 도커 버전</li>
<li>문제를 재현하기 위한 세부 단계</li>
<li><a href=https://github.com/kubernetes/community/blob/master/sig-windows/CONTRIBUTING.md#gathering-logs>관련 로그</a></li>
<li>SIG-Windows 회원의 주의를 끌 수 있도록 <code>/sig windows</code>로 이슈에 대해 어노테이션을 달아
이슈에 sig/windows 태그를 지정한다.</li>
</ul>
<h2 id=다음-내용>다음 내용</h2>
<p>로드맵에는 많은 기능이 있다. 요약된 높은 수준의
목록이 아래에 포함되어 있지만,
<a href=https://github.com/orgs/kubernetes/projects/8>로드맵 프로젝트</a>를 보고
<a href=https://github.com/kubernetes/community/blob/master/sig-windows/>기여</a>하여
윈도우 지원을 개선하는데 도움이 주는 것이 좋다.</p>
<h3 id=hyper-v-격리-isolation>Hyper-V 격리(isolation)</h3>
<p>쿠버네티스에서 윈도우 컨테이너에 대해 다음 유스케이스를 사용하려면
Hyper-V 격리가 필요하다.</p>
<ul>
<li>
<p>추가 보안을 위해 파드 간 하이퍼바이저 기반 격리</p>
</li>
<li>
<p>하위 호환성을 통해 컨테이너를 다시 빌드할 필요 없이 노드에서
최신 윈도우 서버 버전을 실행할 수 있다.</p>
</li>
<li>
<p>파드에 대한 특정 CPU/NUMA 설정</p>
</li>
<li>
<p>메모리 격리 및 예약</p>
</li>
</ul>
<p>Hyper-V 격리 지원은 이후 릴리스에 추가되며
CRI-Containerd가 필요하다.</p>
<h3 id=kubeadm-및-클러스터-api를-사용한-배포>kubeadm 및 클러스터 API를 사용한 배포</h3>
<p>Kubeadm은 사용자가 쿠버네티스 클러스터를 배포하기 위한 사실상의 표준이
되고 있다. kubeadm의 윈도우 노드 지원은 현재 작업 중이지만
<a href=/ko/docs/tasks/administer-cluster/kubeadm/adding-windows-nodes/>여기</a>에서
가이드를 사용할 수 있다.
또한 윈도우 노드가 적절하게 프로비저닝되도록 클러스터 API에
투자하고 있다.</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-3a51e66c5de55f9093a8dc55742006d3>2.4.2 - 쿠버네티스에서 윈도우 컨테이너 스케줄링을 위한 가이드</h1>
<p>많은 조직에서 실행하는 서비스와 애플리케이션의 상당 부분이 윈도우 애플리케이션으로 구성된다.
이 가이드는 쿠버네티스에서 윈도우 컨테이너를 구성하고 배포하는 단계를 안내한다.</p>
<h2 id=목표>목표</h2>
<ul>
<li>윈도우 노드에서 윈도우 컨테이너를 실행하는 예시 디플로이먼트를 구성한다.</li>
<li>(선택) 그룹 매니지드 서비스 어카운트(GMSA)를 이용한 사용자 파드를 위한 액티브 디렉터리 신원(Active Directory Identity)을 구성한다.</li>
</ul>
<h2 id=시작하기-전에>시작하기 전에</h2>
<ul>
<li>컨트롤 플레인과 <a href=/ko/docs/tasks/administer-cluster/kubeadm/adding-windows-nodes/>윈도우 서버로 운영되는 워커 노드</a>를
포함하는 쿠버네티스 클러스터를 생성한다.</li>
<li>쿠버네티스에서 서비스와 워크로드를 생성하고 배포하는 것은 리눅스나 윈도우 컨테이너
모두 비슷한 방식이라는 것이 중요하다.
<a href=/ko/docs/reference/kubectl/overview/>Kubectl 커맨드</a>로 클러스터에 접속하는 것은 동일하다.
아래 단원의 예시를 통해 윈도우 컨테이너와 좀 더 빨리 친숙해질 수 있다.</li>
</ul>
<h2 id=시작하기-윈도우-컨테이너-배포하기>시작하기: 윈도우 컨테이너 배포하기</h2>
<p>쿠버네티스에서 윈도우 컨테이너를 배포하려면, 먼저 예시 애플리케이션을 생성해야 한다.
아래 예시 YAML 파일은 간단한 웹서버 애플리케이션을 생성한다.
아래 내용으로 채운 서비스 스펙을 <code>win-webserver.yaml</code>로 생성하자.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>win-webserver<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>win-webserver<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 이 서비스에서 제공하는 포트</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>win-webserver<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>NodePort<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>win-webserver<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>win-webserver<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>2</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>win-webserver<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>win-webserver<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>win-webserver<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>windowswebserver<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>mcr.microsoft.com/windows/servercore:ltsc2019<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- powershell.exe<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- -command<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:#b44>&#34;&lt;#code used from https://gist.github.com/19WAS85/5424431#&gt; ; $$listener = New-Object System.Net.HttpListener ; $$listener.Prefixes.Add(&#39;http://*:80/&#39;) ; $$listener.Start() ; $$callerCounts = @{} ; Write-Host(&#39;Listening at http://*:80/&#39;) ; while ($$listener.IsListening) { ;$$context = $$listener.GetContext() ;$$requestUrl = $$context.Request.Url ;$$clientIP = $$context.Request.RemoteEndPoint.Address ;$$response = $$context.Response ;Write-Host &#39;&#39; ;Write-Host(&#39;&gt; {0}&#39; -f $$requestUrl) ;  ;$$count = 1 ;$$k=$$callerCounts.Get_Item($$clientIP) ;if ($$k -ne $$null) { $$count += $$k } ;$$callerCounts.Set_Item($$clientIP, $$count) ;$$ip=(Get-NetAdapter | Get-NetIpAddress); $$header=&#39;&lt;html&gt;&lt;body&gt;&lt;H1&gt;Windows Container Web Server&lt;/H1&gt;&#39; ;$$callerCountsString=&#39;&#39; ;$$callerCounts.Keys | % { $$callerCountsString+=&#39;&lt;p&gt;IP {0} callerCount {1} &#39; -f $$ip[1].IPAddress,$$callerCounts.Item($$_) } ;$$footer=&#39;&lt;/body&gt;&lt;/html&gt;&#39; ;$$content=&#39;{0}{1}{2}&#39; -f $$header,$$callerCountsString,$$footer ;Write-Output $$content ;$$buffer = [System.Text.Encoding]::UTF8.GetBytes($$content) ;$$response.ContentLength64 = $$buffer.Length ;$$response.OutputStream.Write($$buffer, 0, $$buffer.Length) ;$$response.Close() ;$$responseStatus = $$response.StatusCode ;Write-Host(&#39;&lt; {0}&#39; -f $$responseStatus)  } ; &#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>nodeSelector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>kubernetes.io/os</span>:<span style=color:#bbb> </span>windows<span style=color:#bbb>
</span></code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> 포트 매핑도 지원하지만, 간략한 예시를 위해
컨테이너 포트 80을 직접 서비스로 노출한다.
</div>
<ol>
<li>
<p>모든 노드가 건강한지 확인한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl get nodes
</code></pre></div></li>
<li>
<p>서비스를 배포하고 파드 갱신을 지켜보자.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl apply -f win-webserver.yaml
kubectl get pods -o wide -w
</code></pre></div><p>이 서비스가 정확히 배포되면 모든 파드는 Ready로 표기된다. 지켜보기를 중단하려면, Ctrl+C 를 누르자.</p>
</li>
<li>
<p>이 디플로이먼트가 성공적인지 확인한다. 다음을 검토하자.</p>
<ul>
<li>윈도우 노드에 파드당 두 컨테이너가 존재하는지 확인하려면, <code>docker ps</code>를 사용한다.</li>
<li>리눅스 컨트롤 플레인 노드에서 나열된 두 파드가 존재하는지 확인하려면, <code>kubectl get pods</code>를 사용한다.</li>
<li>네트워크를 통한 노드에서 파드로의 통신이 되는지 확인하려면, 리눅스 컨트롤 플레인 노드에서 <code>curl</code>을
파드 IP 주소의 80 포트로 실행하여 웹 서버 응답을 확인한다.</li>
<li>파드 간 통신이 되는지 확인하려면, <code>docker exec</code> 나 <code>kubectl exec</code>를 이용해 파드 간에
핑(ping)한다(윈도우 노드가 2대 이상이라면, 서로 다른 노드에 있는 파드 간 통신도 확인할 수 있다).</li>
<li>서비스에서 파드로의 통신이 되는지 확인하려면, 리눅스 컨트롤 플레인 노드와 독립 파드에서 <code>curl</code>을 가상 서비스
IP 주소(<code>kubectl get services</code>로 볼 수 있는)로 실행한다.</li>
<li>서비스 검색(discovery)이 되는지 확인하려면, 쿠버네티스 <a href=/ko/docs/concepts/services-networking/dns-pod-service/#%EC%84%9C%EB%B9%84%EC%8A%A4>기본 DNS 접미사</a>와 서비스 이름으로 <code>curl</code>을 실행한다.</li>
<li>인바운드 연결이 되는지 확인하려면, 클러스터 외부 장비나 리눅스 컨트롤 플레인 노드에서 NodePort로 <code>curl</code>을 실행한다.</li>
<li>아웃바운드 연결이 되는지 확인하려면, <code>kubectl exec</code>를 이용해서 파드에서 외부 IP 주소로 <code>curl</code>을 실행한다.</li>
</ul>
</li>
</ol>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> 윈도우 컨테이너 호스트는 현재 윈도우 네트워킹 스택의 플랫폼 제한으로 인해, 그 안에서 스케줄링하는 서비스의 IP 주소로 접근할 수 없다.
윈도우 파드만 서비스 IP 주소로 접근할 수 있다.
</div>
<h2 id=가시성>가시성</h2>
<h3 id=워크로드에서-로그-캡쳐하기>워크로드에서 로그 캡쳐하기</h3>
<p>로그는 가시성의 중요한 요소이다. 로그는 사용자가 워크로드의 운영측면을
파악할 수 있도록 하며 문제 해결의 핵심 요소이다.
윈도우 컨테이너, 그리고 윈도우 컨테이너 내의 워크로드는 리눅스 컨테이너와는 다르게 동작하기 때문에,
사용자가 로그를 수집하기 어려웠고 이로 인해 운영 가시성이 제한되어 왔다.
예를 들어 윈도우 워크로드는 일반적으로 ETW(Event Tracing for Windows)에 로그인하거나
애플리케이션 이벤트 로그에 항목을 푸시하도록 구성한다.
Microsoft의 오픈 소스 도구인 <a href=https://github.com/microsoft/windows-container-tools/tree/master/LogMonitor>LogMonitor</a>는
윈도우 컨테이너 안에 구성된 로그 소스를 모니터링하는 권장하는 방법이다.
LogMonitor는 이벤트 로그, ETW 공급자 그리고 사용자 정의 애플리케이션 로그 모니터링을 지원하고
<code>kubectl logs &lt;pod></code> 에 의한 사용을 위해 STDOUT으로 파이프한다.</p>
<p>LogMonitor GitHub 페이지의 지침에 따라 모든 컨테이너 바이너리와 설정 파일을 복사하고,
LogMonitor가 로그를 STDOUT으로 푸시할 수 있도록 필요한 엔트리포인트를 추가한다.</p>
<h2 id=설정-가능한-컨테이너-username-사용하기>설정 가능한 컨테이너 username 사용하기</h2>
<p>쿠버네티스 v1.16 부터, 윈도우 컨테이너는 이미지 기본 값과는 다른 username으로 엔트리포인트와 프로세스를
실행하도록 설정할 수 있다.
이 방식은 리눅스 컨테이너에서 지원되는 방식과는 조금 차이가 있다.
<a href=/ko/docs/tasks/configure-pod-container/configure-runasusername/>여기</a>에서 이에 대해 추가적으로 배울 수 있다.</p>
<h2 id=그룹-매니지드-서비스-어카운트를-이용하여-워크로드-신원-관리하기>그룹 매니지드 서비스 어카운트를 이용하여 워크로드 신원 관리하기</h2>
<p>쿠버네티스 v1.14부터 윈도우 컨테이너 워크로드는 그룹 매니지드 서비스 어카운트(GMSA, Group Managed Service Account)를 이용하여 구성할 수 있다.
그룹 매니지드 서비스 어카운트는 액티브 디렉터리 어카운트의 특정한 종류로 자동 암호 관리 기능,
단순화된 서비스 주체 이름(SPN, simplified service principal name), 여러 서버의 다른 관리자에게 관리를 위임하는 기능을 제공한다.
GMSA로 구성한 컨테이너는 GMSA로 구성된 신원을 들고 있는 동안 외부 액티브 디렉터리 도메인 리소스를 접근할 수 있다.
윈도우 컨테이너를 위한 GMSA를 이용하고 구성하는 방법은 <a href=/ko/docs/tasks/configure-pod-container/configure-gmsa/>여기</a>에서 알아보자.</p>
<h2 id=테인트-taint-와-톨러레이션-toleration>테인트(Taint)와 톨러레이션(Toleration)</h2>
<p>오늘날 사용자는 리눅스와 윈도우 워크로드를 (동일한 OS를 실행하는) 적절한 노드에 할당되도록 하기 위해 테인트와
노드셀렉터(nodeSelector)의 조합을 이용해야 한다.
이것은 윈도우 사용자에게만 부담을 줄 것으로 보인다. 아래는 권장되는 방식의 개요인데,
이것의 주요 목표 중에 하나는 이 방식이 기존 리눅스 워크로드와 호환되어야 한다는 것이다.
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> <p><code>IdentifyPodOS</code> <a href=/ko/docs/reference/command-line-tools-reference/feature-gates/>기능 게이트</a>가 활성화되어 있으면,
파드의 컨테이너가 어떤 운영 체제용인지를 파드의 <code>.spec.os.name</code>에 설정할 수 있다(그리고 설정해야 한다).
리눅스 컨테이너를 실행하는 파드에는 <code>.spec.os.name</code>을 <code>linux</code>로 설정한다.
윈도우 컨테이너를 실행하는 파드에는 <code>.spec.os.name</code>을
<code>windows</code>로 설정한다.</p>
<p>스케줄러는 파드를 노드에 할당할 때 <code>.spec.os.name</code> 필드의 값을 사용하지 않는다.
컨트롤 플레인이 파드를 적절한 운영 체제가 실행되고 있는 노드에 배치하도록 하려면,
<a href=/ko/docs/concepts/scheduling-eviction/assign-pod-node/>파드를 노드에 할당</a>하는
일반적인 쿠버네티스 메카니즘을 사용해야 한다.
<code>.spec.os.name</code> 필드는 윈도우 파드의 스케줄링에는 영향을 미치지 않기 때문에,
윈도우 파드가 적절한 윈도우 노드에 할당되도록 하려면 테인트,
톨러레이션 및 노드 셀렉터가 여전히 필요하다.</p>
</div></p>
<h3 id=특정-os-워크로드를-적절한-컨테이너-호스트에서-처리하도록-보장하기>특정 OS 워크로드를 적절한 컨테이너 호스트에서 처리하도록 보장하기</h3>
<p>사용자는 테인트와 톨러레이션을 이용하여 윈도우 컨테이너가 적절한 호스트에서 스케줄링되기를 보장할 수 있다.
오늘날 모든 쿠버네티스 노드는 다음 기본 레이블을 가지고 있다.</p>
<ul>
<li>kubernetes.io/os = [windows|linux]</li>
<li>kubernetes.io/arch = [amd64|arm64|...]</li>
</ul>
<p>파드 사양에 노드 셀렉터를 <code>"kubernetes.io/os": windows</code>와 같이 지정하지 않았다면,
그 파드는 리눅스나 윈도우, 아무 호스트에나 스케줄링될 수 있다.
윈도우 컨테이너는 윈도우에서만 운영될 수 있고 리눅스 컨테이너는 리눅스에서만 운영될 수 있기 때문에 이는 문제를 일으킬 수 있다.
가장 좋은 방법은 노드 셀렉터를 사용하는 것이다.</p>
<p>그러나 많은 경우 사용자는 이미 존재하는 대량의 리눅스 컨테이너용 디플로이먼트를 가지고 있을 뿐만 아니라,
헬름(Helm) 차트 커뮤니티 같은 상용 구성의 에코시스템이나, 오퍼레이터(Operator) 같은 프로그래밍 방식의 파드 생성 사례가 있음을 알고 있다.
이런 상황에서는 노드 셀렉터를 추가하는 구성 변경을 망설일 수 있다.
이에 대한 대안은 테인트를 사용하는 것이다. Kubelet은 등록하는 동안 테인트를 설정할 수 있기 때문에,
윈도우에서만 운영할 때에 자동으로 테인트를 추가하기 쉽다.</p>
<p>예를 들면, <code>--register-with-taints='os=windows:NoSchedule'</code></p>
<p>모든 윈도우 노드에 테인트를 추가하여 아무 것도 거기에 스케줄링하지 않게 될 것이다(존재하는 리눅스 파드를 포함하여).
윈도우 파드가 윈도우 노드에 스케줄링되도록 하려면,
윈도우 노드가 선택되도록 하기 위한 노드 셀렉터 및 적합하게 일치하는 톨러레이션이 모두 필요하다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>nodeSelector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubernetes.io/os</span>:<span style=color:#bbb> </span>windows<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>node.kubernetes.io/windows-build</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;10.0.17763&#39;</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>tolerations</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;os&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;Equal&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;windows&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>effect</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;NoSchedule&#34;</span><span style=color:#bbb>
</span></code></pre></div><h3 id=동일-클러스터에서-여러-윈도우-버전을-조작하는-방법>동일 클러스터에서 여러 윈도우 버전을 조작하는 방법</h3>
<p>파드에서 사용하는 윈도우 서버 버전은 노드의 윈도우 서버 버전과 일치해야 한다. 만약 동일한 클러스터에서 여러 윈도우
서버 버전을 사용하려면, 추가로 노드 레이블과 nodeSelectors를 설정해야 한다.</p>
<p>쿠버네티스 1.17은 이것을 단순화하기 위해 새로운 레이블인 <code>node.kubernetes.io/windows-build</code> 를 자동으로 추가한다.
만약 이전 버전을 실행 중인 경우, 이 레이블을 윈도우 노드에 수동으로 추가하는 것을 권장한다.</p>
<p>이 레이블은 호환성을 위해 일치시켜야 하는 윈도우 메이저, 마이너 및 빌드 번호를 나타낸다.
각 윈도우 서버 버전에 대해 현재 사용하고 있는 빌드 번호는 다음과 같다.</p>
<table>
<thead>
<tr>
<th>제품 이름</th>
<th>빌드 번호</th>
</tr>
</thead>
<tbody>
<tr>
<td>윈도우 서버 2019</td>
<td>10.0.17763</td>
</tr>
<tr>
<td>윈도우 서버 버전 1809</td>
<td>10.0.17763</td>
</tr>
<tr>
<td>윈도우 서버 버전 1903</td>
<td>10.0.18362</td>
</tr>
</tbody>
</table>
<h3 id=runtimeclass로-단순화>RuntimeClass로 단순화</h3>
<p><a href=/ko/docs/concepts/containers/runtime-class/>런타임클래스(RuntimeClass)</a>를 사용해서 테인트(taint)와 톨러레이션(toleration)을 사용하는 프로세스를 간소화 할 수 있다.
클러스터 관리자는 이 테인트와 톨러레이션을 캡슐화하는 데 사용되는 <code>RuntimeClass</code> 오브젝트를 생성할 수 있다.</p>
<ol>
<li>이 파일을 <code>runtimeClasses.yml</code> 로 저장한다. 여기에는 윈도우 OS,
아키텍처 및 버전에 적합한 <code>nodeSelector</code> 가 포함되어 있다.</li>
</ol>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>node.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>RuntimeClass<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>windows-2019<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>handler</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;docker&#39;</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>scheduling</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>nodeSelector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubernetes.io/os</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;windows&#39;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubernetes.io/arch</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;amd64&#39;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>node.kubernetes.io/windows-build</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;10.0.17763&#39;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>tolerations</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>effect</span>:<span style=color:#bbb> </span>NoSchedule<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>os<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span>Equal<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;windows&#34;</span><span style=color:#bbb>
</span></code></pre></div><ol start=2>
<li>클러스터 관리자로 <code>kubectl create -f runtimeClasses.yml</code> 를 실행해서 사용한다.</li>
<li>파드 사양에 적합한 <code>runtimeClassName: windows-2019</code> 를 추가한다.</li>
</ol>
<p>예시:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>iis-2019<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>iis-2019<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>iis-2019<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>iis-2019<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>runtimeClassName</span>:<span style=color:#bbb> </span>windows-2019<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>iis<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>mcr.microsoft.com/windows/servercore/iis:windowsservercore-ltsc2019<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>800Mi<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span>.1<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>300Mi<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>iis-2019<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>iis<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>LoadBalancer<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>iis-2019<span style=color:#bbb>
</span></code></pre></div>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-84b6491601d6a2b3da4cd5a105c866ba>3 - 모범 사례</h1>
</div>
<div class=td-content>
<h1 id=pg-c797ee17120176c685455db89ae091a9>3.1 - 대형 클러스터에 대한 고려 사항</h1>
<p>클러스터는 <a class=glossary-tooltip title="컨테이너의 라이프사이클을 정의, 배포, 관리하기 위한 API와 인터페이스들을 노출하는 컨테이너 오케스트레이션 레이어." data-toggle=tooltip data-placement=top href="/ko/docs/reference/glossary/?all=true#term-control-plane" target=_blank aria-label="컨트롤 플레인">컨트롤 플레인</a>에서 관리하는
쿠버네티스 에이전트를 실행하는 <a class=glossary-tooltip title="노드는 쿠버네티스의 작업 장비(worker machine)이다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/architecture/nodes/ target=_blank aria-label=노드>노드</a>(물리
또는 가상 머신)의 집합이다.
쿠버네티스 v1.23는 노드 5,000개까지의 클러스터를 지원한다. 보다 정확하게는,
쿠버네티스는 다음 기준을 <em>모두</em> 만족하는 설정을 수용하도록 설계되었다.</p>
<ul>
<li>노드 당 파드 110 개 이하</li>
<li>노드 5,000개 이하</li>
<li>전체 파드 150,000개 이하</li>
<li>전체 컨테이너 300,000개 이하</li>
</ul>
<p>노드를 추가하거나 제거하여 클러스터를 확장할 수 있다. 이를 수행하는 방법은
클러스터 배포 방법에 따라 다르다.</p>
<h2 id=quota-issues>클라우드 프로바이더 리소스 쿼터</h2>
<p>여러 노드를 가지는 클러스터를 만들 때, 클라우드 프로바이더 쿼터 이슈를 피하기 위해
고려할 점은 다음과 같다.</p>
<ul>
<li>다음과 같은 클라우드 리소스에 대한 쿼터 증가를 요청한다.
<ul>
<li>컴퓨터 인스턴스</li>
<li>CPU</li>
<li>스토리지 볼륨</li>
<li>사용 중인 IP 주소</li>
<li>패킷 필터링 규칙 세트</li>
<li>로드밸런서 개수</li>
<li>로그 스트림</li>
</ul>
</li>
<li>일부 클라우드 프로바이더는 새로운 인스턴스 생성 속도에 상한이 있어, 클러스터 확장 작업 간 새로운 노드를 일괄적으로 배치하고, 배치 간에 일시 중지한다.</li>
</ul>
<h2 id=컨트롤-플레인-컴포넌트>컨트롤 플레인 컴포넌트</h2>
<p>대규모 클러스터의 경우, 충분한 컴퓨트 및 기타 리소스가 있는 컨트롤 플레인이
필요하다.</p>
<p>일반적으로 장애 영역 당 하나 또는 두 개의 컨트롤 플레인 인스턴스를
실행하고, 해당 인스턴스를 수직으로(vertically) 먼저 확장한 다음 (수직) 규모로 하락하는
지점에 도달한 후 수평으로(horizontally) 확장한다.</p>
<p>내결함성을 제공하려면 장애 영역 당 하나 이상의 인스턴스를 실행해야 한다. 쿠버네티스
노드는 동일한 장애 영역에 있는 컨트롤 플레인 엔드포인트로 트래픽을
자동으로 조정하지 않는다. 그러나, 클라우드 프로바이더는 이를 수행하기 위한 자체 메커니즘을 가지고 있을 수 있다.</p>
<p>예를 들어, 관리형 로드 밸런서를 사용하여 장애 영역 <em>A</em> 의
kubelet 및 파드에서 시작되는 트래픽을 전송하도록 로드 밸런서를 구성하고, 해당 트래픽을
<em>A</em> 영역에 있는 컨트롤 플레인 호스트로만 전달한다. 단일 컨트롤 플레인 호스트 또는
엔드포인트 장애 영역 <em>A</em> 이 오프라인이 되면, 영역 <em>A</em> 의 노드에 대한
모든 컨트롤 플레인 트래픽이 이제 영역간에 전송되고 있음을 의미한다. 각 영역에서 여러 컨트롤 플레인 호스트를
실행하면 가용성이 낮아진다.</p>
<h3 id=etcd-저장소>etcd 저장소</h3>
<p>큰 클러스터의 성능 향상을 위해, 사용자는 이벤트 오브젝트를 각각의
전용 etcd 인스턴스에 저장한다.</p>
<p>클러스터 생성시의 부가 스트립트이다.
클러스터 생성 시에 (사용자 도구를 사용하여) 다음을 수행할 수 있다.</p>
<ul>
<li>추가 etcd 인스턴스 시작 및 설정</li>
<li>이벤트를 저장하기 위한 <a class=glossary-tooltip title="쿠버네티스 API를 제공하는 컨트롤 플레인 컴포넌트." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/overview/components/#kube-apiserver target=_blank aria-label="API server">API server</a> 설정</li>
</ul>
<p><a href=/docs/tasks/administer-cluster/configure-upgrade-etcd/>쿠버네티스를 위한 etcd 클러스터 운영하기</a>와
<a href=/docs/setup/production-environment/tools/kubeadm/setup-ha-etcd-with-kubeadm/>kubeadm을 이용하여 고가용성 etcd 생성하기</a>에서
큰 클러스터를 위한 etcd를 설정하고 관리하는 방법에 대한 상세 사항을 확인한다.</p>
<h2 id=애드온-리소스>애드온 리소스</h2>
<p>쿠버네티스 <a href=/ko/docs/concepts/configuration/manage-resources-containers/>리소스 제한</a>은
파드와 컨테이너가 다른 컴포넌트에 영향을 줄 수 있는 메모리 누수 및 기타 방식의 영향을
최소화하는 데 도움이 된다. 이러한 리소스 제한은 애플리케이션 워크로드에 적용될 수 있는 것처럼
<a class=glossary-tooltip title="Resources that extend the functionality of Kubernetes." data-toggle=tooltip data-placement=top href=/docs/concepts/cluster-administration/addons/ target=_blank aria-label=애드온>애드온</a> 리소스에도 적용될 수 있다.</p>
<p>예를 들어, 로깅 컴포넌트에 대한 CPU 및 메모리 제한을 설정할 수 있다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>fluentd-cloud-logging<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>fluent/fluentd-kubernetes-daemonset:v1<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span>100m<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>200Mi<span style=color:#bbb>
</span></code></pre></div><p>애드온의 기본 제한은 일반적으로 중소형 쿠버네티스 클러스터에서
각 애드온을 실행한 경험에서 수집된 데이터를 기반으로 한다. 대규모 클러스터에서
실행할 때, 애드온은 종종 기본 제한보다 많은 리소스를 소비한다.
이러한 값을 조정하지 않고 대규모 클러스터를 배포하면, 애드온이
메모리 제한에 계속 도달하기 때문에 지속적으로 종료될 수 있다.
또는, 애드온이 실행될 수 있지만 CPU 시간 슬라이스 제한으로 인해
성능이 저하된다.</p>
<p>클러스터 애드온 리소스 문제가 발생하지 않도록, 노드가 많은 클러스터를
만들 때, 다음 사항을 고려한다.</p>
<ul>
<li>일부 애드온은 수직으로 확장된다. 클러스터 또는 전체 장애 영역을
제공하는 애드온 레플리카가 하나 있다. 이러한 애드온의 경우, 클러스터를 확장할 때
요청과 제한을 늘린다.</li>
<li>많은 애드온은 수평으로 확장된다. 더 많은 파드를 실행하여 용량을 추가하지만,
매우 큰 클러스터에서는 CPU 또는 메모리 제한을 약간 높여야 할 수도 있다.
VerticalPodAutoscaler는 <em>recommender</em> 모드에서 실행되어 요청 및 제한에 대한
제안 수치를 제공할 수 있다.</li>
<li>일부 애드온은 <a class=glossary-tooltip title="파드의 복제본을 클러스터 노드 집합에서 동작하게 한다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/controllers/daemonset target=_blank aria-label=데몬셋(DaemonSet)>데몬셋(DaemonSet)</a>에 의해 제어되는 노드 당 하나의 복사본으로 실행된다(예: 노드 수준 로그 수집기). 수평
확장 애드온의 경우와 유사하게, CPU 또는 메모리 제한을 약간 높여야
할 수도 있다.</li>
</ul>
<h2 id=다음-내용>다음 내용</h2>
<p><code>VerticalPodAutoscaler</code> 는 리소스 요청 및 파드 제한을 관리하는 데 도움이 되도록
클러스터에 배포할 수 있는 사용자 정의 리소스이다.
클러스터에 중요한 애드온을 포함하여 클러스터 컴포넌트를 확장하는 방법에 대한
자세한 내용은 <a href=https://github.com/kubernetes/autoscaler/tree/master/vertical-pod-autoscaler#readme>Vertical Pod Autoscaler</a>를
방문하여 배워본다.</p>
<p><a href=https://github.com/kubernetes/autoscaler/tree/master/cluster-autoscaler#readme>클러스터 오토스케일러</a>는
여러 클라우드 프로바이더와 통합되어 클러스터의 리소스 요구 수준에 맞는
노드 수를 실행할 수 있도록 도와준다.</p>
<p><a href=https://github.com/kubernetes/autoscaler/tree/master/addon-resizer#readme>addon resizer</a>는
클러스터 스케일이 변경될 때 자동으로 애드온 크기를 조정할 수 있도록 도와준다.</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-970615c97499e3651fd3a98e0387cefc>3.2 - 여러 영역에서 실행</h1>
<p>이 페이지에서는 여러 영역에서 쿠버네티스를 실행하는 방법을 설명한다.</p>
<h2 id=배경>배경</h2>
<p>쿠버네티스는 단일 쿠버네티스 클러스터가 여러 장애 영역에서
실행될 수 있도록 설계되었다. 일반적으로 이러한 영역은 <em>지역(region)</em> 이라는
논리적 그룹 내에 적합하다. 주요 클라우드 제공자는 지역을 일관된 기능 집합을
제공하는 장애 영역 집합(<em>가용성 영역</em> 이라고도 함)으로
정의한다. 지역 내에서 각 영역은 동일한 API 및
서비스를 제공한다.</p>
<p>일반적인 클라우드 아키텍처는 한 영역의 장애가 다른 영역의 서비스도
손상시킬 가능성을 최소화하는 것을 목표로 한다.</p>
<h2 id=컨트롤-플레인-동작>컨트롤 플레인 동작</h2>
<p>모든 <a href=/ko/docs/concepts/overview/components/#%EC%BB%A8%ED%8A%B8%EB%A1%A4-%ED%94%8C%EB%A0%88%EC%9D%B8-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8>컨트롤 플레인 컴포넌트</a>는
컴포넌트별로 복제되는 교환 가능한 리소스 풀로 실행을
지원한다.</p>
<p>클러스터 컨트롤 플레인을 배포할 때, 여러 장애 영역에
컨트롤 플레인 컴포넌트의 복제본을 배치한다. 가용성이
중요한 문제인 경우, 3개 이상의 장애 영역을 선택하고
각 개별 컨트롤 플레인 컴포넌트(API 서버, 스케줄러, etcd,
클러스터 컨트롤러 관리자)를 3개 이상의 장애 영역에 복제한다.
클라우드 컨트롤러 관리자를 실행 중인 경우 선택한
모든 장애 영역에 걸쳐 이를 복제해야 한다.</p>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> 쿠버네티스는 API 서버 엔드포인트에 대한 교차 영역 복원성을 제공하지
않는다. DNS 라운드-로빈, SRV 레코드 또는 상태 확인 기능이 있는
써드파티 로드 밸런싱 솔루션을 포함하여 다양한 기술을 사용하여
클러스터 API 서버의 가용성을 향상시킬 수 있다.
</div>
<h2 id=노드-동작>노드 동작</h2>
<p>쿠버네티스는 클러스터의 여러 노드에 걸쳐
워크로드 리소스(예: <a class=glossary-tooltip title="클러스터에서 복제된 애플리케이션을 관리한다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/controllers/deployment/ target=_blank aria-label=디플로이먼트(Deployment)>디플로이먼트(Deployment)</a>
또는 <a class=glossary-tooltip title="내구성이 있는 스토리지와 파드별로 지속성 식별자를 사용해서 파드 집합의 디플로이먼트와 스케일링을 관리한다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/controllers/statefulset/ target=_blank aria-label=스테이트풀셋(StatefulSet)>스테이트풀셋(StatefulSet)</a>)에
대한 파드를 자동으로 분배한다. 이러한 분배는
실패에 대한 영향을 줄이는 데 도움이 된다.</p>
<p>노드가 시작되면, 각 노드의 kubelet이 쿠버네티스 API에서
특정 kubelet을 나타내는 노드 오브젝트에
<a class=glossary-tooltip title="사용자에게 의미 있고 관련성 높은 특징으로 식별할 수 있도록 오브젝트에 태그를 붙인다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/overview/working-with-objects/labels target=_blank aria-label=레이블>레이블</a>을 자동으로 추가한다.
이러한 레이블에는
<a href=/ko/docs/reference/labels-annotations-taints/#topologykubernetesiozone>영역 정보</a>가 포함될 수 있다.</p>
<p>클러스터가 여러 영역 또는 지역에 걸쳐있는 경우,
<a href=/ko/docs/concepts/workloads/pods/pod-topology-spread-constraints/>파드 토폴로지 분배 제약 조건</a>과
함께 노드 레이블을 사용하여
파드가 장애 도메인(지역, 영역, 특정 노드) 간 클러스터에
분산되는 방식을 제어할 수 있다.
이러한 힌트를 통해
<a class=glossary-tooltip title="노드가 배정되지 않은 새로 생성된 파드를 감지하고, 실행할 노드를 선택하는 컨트롤 플레인 컴포넌트." data-toggle=tooltip data-placement=top href=/docs/reference/command-line-tools-reference/kube-scheduler/ target=_blank aria-label=스케줄러>스케줄러</a>는
더 나은 예상 가용성을 위해 파드를 배치할 수 있으므로, 상관 관계가 있는
오류가 전체 워크로드에 영향을 미칠 위험을 줄일 수 있다.</p>
<p>예를 들어, 가능할 때마다 스테이트풀셋의
3개 복제본이 모두 서로 다른 영역에서 실행되도록 제약 조건을
설정할 수 있다. 각 워크로드에 사용 중인
가용 영역을 명시적으로 정의하지 않고 이를 선언적으로
정의할 수 있다.</p>
<h3 id=여러-영역에-노드-분배>여러 영역에 노드 분배</h3>
<p>쿠버네티스의 코어는 사용자를 위해 노드를 생성하지 않는다. 사용자가 직접 수행하거나,
<a href=https://cluster-api.sigs.k8s.io/>클러스터 API</a>와 같은 도구를 사용하여
사용자 대신 노드를 관리해야 한다.</p>
<p>클러스터 API와 같은 도구를 사용하면 여러 장애 도메인에서
클러스터의 워커 노드로 실행할 머신 집합과 전체 영역 서비스 중단 시
클러스터를 자동으로 복구하는 규칙을 정의할 수 있다.</p>
<h2 id=파드에-대한-수동-영역-할당>파드에 대한 수동 영역 할당</h2>
<p>생성한 파드와 디플로이먼트, 스테이트풀셋, 잡(Job)과
같은 워크로드 리소스의 파드 템플릿에 <a href=/ko/docs/concepts/scheduling-eviction/assign-pod-node/#%EB%85%B8%EB%93%9C-%EC%85%80%EB%A0%89%ED%84%B0-nodeselector>노드 셀렉터 제약 조건</a>을
적용할 수 있다.</p>
<h2 id=영역에-대한-스토리지-접근>영역에 대한 스토리지 접근</h2>
<p>퍼시스턴트 볼륨이 생성되면, <code>PersistentVolumeLabel</code>
<a href=/docs/reference/access-authn-authz/admission-controllers/>어드미션 컨트롤러</a>는
특정 영역에 연결된 모든 퍼시스턴트볼륨(PersistentVolume)에 영역 레이블을 자동으로
추가한다. 그런 다음 <a class=glossary-tooltip title="노드가 배정되지 않은 새로 생성된 파드를 감지하고, 실행할 노드를 선택하는 컨트롤 플레인 컴포넌트." data-toggle=tooltip data-placement=top href=/docs/reference/command-line-tools-reference/kube-scheduler/ target=_blank aria-label=스케줄러>스케줄러</a>는
<code>NoVolumeZoneConflict</code> 프레디케이트(predicate)를 통해 주어진 퍼시스턴트볼륨을 요구하는 파드가
해당 볼륨과 동일한 영역에만 배치되도록 한다.</p>
<p>해당 클래스의 스토리지가 사용할 수 있는 장애 도메인(영역)을 지정하는
퍼시스턴트볼륨클레임(PersistentVolumeClaims)에 대한
<a class=glossary-tooltip title="스토리지클래스는 관리자가 사용 가능한 다양한 스토리지 유형을 설명할 수 있는 방법을 제공한다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/storage/storage-classes target=_blank aria-label=스토리지클래스(StorageClass)>스토리지클래스(StorageClass)</a>를 지정할 수 있다.
장애 도메인 또는 영역을 인식하는 스토리지클래스 구성에 대한 자세한 내용은
<a href=/ko/docs/concepts/storage/storage-classes/#%ED%97%88%EC%9A%A9%EB%90%9C-%ED%86%A0%ED%8F%B4%EB%A1%9C%EC%A7%80>허용된 토폴로지</a>를 참고한다.</p>
<h2 id=네트워킹>네트워킹</h2>
<p>쿠버네티스가 스스로 영역-인지(zone-aware) 네트워킹을 포함하지는 않는다.
<a href=/ko/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/>네트워크 플러그인</a>을
사용하여 클러스터 네트워킹을 구성할 수 있으며, 해당 네트워크 솔루션에는 영역별 요소가
있을 수 있다. 예를 들어, 클라우드 제공자가
<code>type=LoadBalancer</code> 를 사용하여 서비스를 지원하는 경우, 로드 밸런서는 지정된 연결을 처리하는
로드 밸런서 요소와 동일한 영역에서 실행 중인 파드로만 트래픽을 보낼 수 있다.
자세한 내용은 클라우드 제공자의 문서를 확인한다.</p>
<p>사용자 정의 또는 온-프레미스 배포의 경우, 비슷한 고려 사항이 적용된다.
다른 장애 영역 처리를 포함한 <a class=glossary-tooltip title="네트워크 서비스로 파드 집합에서 실행 중인 애플리케이션을 노출하는 방법" data-toggle=tooltip data-placement=top href=/ko/docs/concepts/services-networking/service/ target=_blank aria-label=서비스>서비스</a>와
<a class=glossary-tooltip title="클러스터 내의 서비스에 대한 외부 접근을 관리하는 API 오브젝트이며, 일반적으로 HTTP를 관리함." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/services-networking/ingress/ target=_blank aria-label=인그레스(Ingress)>인그레스(Ingress)</a> 동작은
클러스터가 설정된 방식에 명확히 의존한다.</p>
<h2 id=장애-복구>장애 복구</h2>
<p>클러스터를 설정할 때, 한 지역의 모든 장애 영역이 동시에
오프라인 상태가 되는 경우 설정에서 서비스를 복원할 수 있는지
여부와 방법을 고려해야 할 수도 있다. 예를 들어, 영역에서 파드를 실행할 수 있는
노드가 적어도 하나 이상 있어야 하는가?
클러스터에 중요한 복구 작업이 클러스터에
적어도 하나 이상의 정상 노드에 의존하지 않는지 확인한다. 예를 들어, 모든 노드가
비정상인 경우, 하나 이상의 노드를 서비스할 수 있을 만큼 복구를 완료할 수 있도록 특별한
<a class=glossary-tooltip title="세 가지 필수 속성: 키(key), 값(value), 효과(effect)로 구성된 코어 오브젝트. 톨러레이션은 매칭되는 테인트(taint)를 가진 노드나 노드 그룹에 파드가 스케줄링되는 것을 활성화한다." data-toggle=tooltip data-placement=top href=/ko/docs/concepts/scheduling-eviction/taint-and-toleration/ target=_blank aria-label=톨러레이션(toleration)>톨러레이션(toleration)</a>으로
복구 작업을 실행해야 할 수 있다.</p>
<p>쿠버네티스는 이 문제에 대한 답을 제공하지 않는다. 그러나,
고려해야 할 사항이다.</p>
<h2 id=다음-내용>다음 내용</h2>
<p>스케줄러가 구성된 제약 조건을 준수하면서, 클러스터에 파드를 배치하는 방법을 알아보려면,
<a href=/ko/docs/concepts/scheduling-eviction/>스케줄링과 축출(eviction)</a>을 참고한다.</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-f89867de1d34943f1524f67a241f5cc9>3.3 - 노드 구성 검증하기</h1>
<h2 id=노드-적합성-테스트>노드 적합성 테스트</h2>
<p><em>노드 적합성 테스트</em> 는 노드의 시스템 검증과 기능 테스트를 제공하기 위해 컨테이너화된 테스트 프레임워크이다.
테스트는 노드가 쿠버네티스를 위한 최소 요구조건을 만족하는지를 검증한다. 그리고 테스트를 통과한 노드는 쿠버네티스 클러스터에 참
여할 자격이 주어진다.</p>
<h2 id=노드-필수-구성-요소>노드 필수 구성 요소</h2>
<p>노드 적합성 테스트를 실행하기 위해서는, 해당 노드는 표준 쿠버네티스 노드로서 동일한 전제조건을 만족해야 한다.
노드는 최소한 아래 데몬들이 설치되어 있어야 한다.</p>
<ul>
<li>컨테이너 런타임 (Docker)</li>
<li>Kubelet</li>
</ul>
<h2 id=노드-적합성-테스트-실행>노드 적합성 테스트 실행</h2>
<p>노드 적합성 테스트는 다음 순서로 진행된다.</p>
<ol>
<li>kubelet에 대한 <code>--kubeconfig</code> 옵션의 값을 계산한다. 예를 들면, 다음과 같다.
<code>--kubeconfig = / var / lib / kubelet / config.yaml</code>.
테스트 프레임워크는 kubelet을 테스트하기 위해 로컬 컨트롤 플레인을 시작하기 때문에,
<code>http://localhost:8080</code> 을 API 서버의 URL로 사용한다.
사용할 수 있는 kubelet 커맨드 라인 파라미터가 몇 개 있다.</li>
</ol>
<ul>
<li><code>--pod-cidr</code>: <code>kubenet</code>을 사용 중이라면, 임의의 CIDR을 Kubelet에 지정해주어야 한다. 예) <code>--pod-cidr=10.180.0.0/24</code>.</li>
<li><code>--cloud-provider</code>: <code>--cloud-provider=gce</code>를 사용 중이라면, 테스트 실행 시에는 제거해야 한다.</li>
</ul>
<ol start=2>
<li>다음 커맨드로 노드 적합성 테스트를 실행한다.</li>
</ol>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># $CONFIG_DIR는 Kublet의 파드 매니페스트 경로이다.</span>
<span style=color:#080;font-style:italic># $LOG_DIR는 테스트 출력 경로이다.</span>
sudo docker run -it --rm --privileged --net<span style=color:#666>=</span>host <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  -v /:/rootfs -v <span style=color:#b8860b>$CONFIG_DIR</span>:<span style=color:#b8860b>$CONFIG_DIR</span> -v <span style=color:#b8860b>$LOG_DIR</span>:/var/result <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  k8s.gcr.io/node-test:0.2
</code></pre></div><h2 id=다른-아키텍처에서-노드-적합성-테스트-실행>다른 아키텍처에서 노드 적합성 테스트 실행</h2>
<p>쿠버네티스는 다른 아키텍쳐용 노드 적합성 테스트 Docker 이미지도 제공한다.</p>
<table>
<thead>
<tr>
<th>Arch</th>
<th style=text-align:center>Image</th>
</tr>
</thead>
<tbody>
<tr>
<td>amd64</td>
<td style=text-align:center>node-test-amd64</td>
</tr>
<tr>
<td>arm</td>
<td style=text-align:center>node-test-arm</td>
</tr>
<tr>
<td>arm64</td>
<td style=text-align:center>node-test-arm64</td>
</tr>
</tbody>
</table>
<h2 id=선택된-테스트-실행>선택된 테스트 실행</h2>
<p>특정 테스트만 실행하기 위해서는 환경 변수 <code>FOCUS</code>에 테스트하고자 하는 테스트를 정규식으로 지정한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>sudo docker run -it --rm --privileged --net<span style=color:#666>=</span>host <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  -v /:/rootfs:ro -v <span style=color:#b8860b>$CONFIG_DIR</span>:<span style=color:#b8860b>$CONFIG_DIR</span> -v <span style=color:#b8860b>$LOG_DIR</span>:/var/result <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  -e <span style=color:#b8860b>FOCUS</span><span style=color:#666>=</span>MirrorPod <span style=color:#b62;font-weight:700>\ </span><span style=color:#080;font-style:italic># MirrorPod 테스트만 실행</span>
  k8s.gcr.io/node-test:0.2
</code></pre></div><p>특정 테스트를 건너뛰기 위해서는, 환경 변수 <code>SKIP</code>에 건너뛰고자 하는 테스트를 정규식으로 지정한다.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>sudo docker run -it --rm --privileged --net<span style=color:#666>=</span>host <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  -v /:/rootfs:ro -v <span style=color:#b8860b>$CONFIG_DIR</span>:<span style=color:#b8860b>$CONFIG_DIR</span> -v <span style=color:#b8860b>$LOG_DIR</span>:/var/result <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  -e <span style=color:#b8860b>SKIP</span><span style=color:#666>=</span>MirrorPod <span style=color:#b62;font-weight:700>\ </span><span style=color:#080;font-style:italic># MirrorPod 테스트만 건너뛰고 모든 적합성 테스트를 실행한다</span>
  k8s.gcr.io/node-test:0.2
</code></pre></div><p>노드 적합성 테스트는 <a href=https://github.com/kubernetes/community/blob/master/contributors/devel/sig-node/e2e-node-tests.md>노드 e2e 테스트</a>를 컨테이너화한 버전이다.
기본적으로, 모든 적합성 테스트를 실행한다.</p>
<p>이론적으로, 컨테이너와 필요한 볼륨을 적절히 설정했다면 어떤 노드 e2e 테스트도 수행할 수 있다.
하지만, 적합성 테스트가 아닌 테스트들은 훨씬 복잡한 설정이 필요하기 때문에 <strong>적합성 테스트만 실행하기를 강하게 추천한다.</strong></p>
<h2 id=주의-사항>주의 사항</h2>
<ul>
<li>테스트 후, 노드 적합성 테스트 이미지 및 기능 테스트에 사용된 이미지들을 포함하여 몇 개의 Docker 이미지들이 노드에 남는다.</li>
<li>테스트 후, 노드에 죽은 컨테이너가 남는다. 기능 테스트 도중에 생성된 컨테이너들이다.</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-0394f813094b7a35058dffe5b8bacd20>3.4 - PKI 인증서 및 요구 사항</h1>
<p>쿠버네티스는 TLS를 통한 인증을 위해서 PKI 인증서가 필요하다.
만약 <a href=/ko/docs/reference/setup-tools/kubeadm/>kubeadm</a>으로 쿠버네티스를 설치한다면, 클러스터에 필요한 인증서는 자동으로 생성된다.
또한 더 안전하게 자신이 소유한 인증서를 생성할 수 있다. 이를 테면, 개인키를 API 서버에 저장하지 않으므로 더 안전하게 보관할 수 있다.
이 페이지는 클러스터가 필요로 하는 인증서에 대해서 설명한다.</p>
<h2 id=클러스터에서-인증서가-이용되는-방식>클러스터에서 인증서가 이용되는 방식</h2>
<p>쿠버네티스는 다음 작업에서 PKI를 필요로 한다.</p>
<ul>
<li>kubelet에서 API 서버 인증서를 인증시 사용하는 클라이언트 인증서</li>
<li>API 서버 엔드포인트를 위한 서버 인증서</li>
<li>API 서버에 클러스터 관리자 인증을 위한 클라이언트 인증서</li>
<li>API 서버에서 kubelet과 통신을 위한 클라이언트 인증서</li>
<li>API 서버에서 etcd 간의 통신을 위한 클라이언트 인증서</li>
<li>컨트롤러 매니저와 API 서버 간의 통신을 위한 클라이언트 인증서/kubeconfig</li>
<li>스케줄러와 API 서버간 통신을 위한 클라이언트 인증서/kubeconfig</li>
<li><a href=/docs/tasks/extend-kubernetes/configure-aggregation-layer/>front-proxy</a>를 위한 클라이언트와 서버 인증서</li>
</ul>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> <code>front-proxy</code> 인증서는 kube-proxy에서 <a href=/ko/docs/tasks/extend-kubernetes/setup-extension-api-server/>API 서버 확장</a>을 지원할 때만 kube-proxy에서 필요하다.
</div>
<p>etcd 역시 클라이언트와 피어 간에 상호 TLS 인증을 구현한다.</p>
<h2 id=인증서를-저장하는-위치>인증서를 저장하는 위치</h2>
<p>만약 쿠버네티스를 kubeadm으로 설치했다면, 대부분의 인증서는 <code>/etc/kubernetes/pki</code>에 저장된다. 이 문서에 언급된 모든 파일 경로는 그 디렉터리에 상대적이나, kubeadm이 <code>/etc/kubernetes</code>에 저장하는 사용자 어카운트 인증서는 예외이다.</p>
<h2 id=인증서-수동-설정>인증서 수동 설정</h2>
<p>필요한 인증서를 kubeadm으로 생성하기 싫다면, 단일 루트 CA를 이용하거나 모든 인증서를 제공하여 생성할 수 있다. 소유한 인증기관을 이용해서 생성하는 방법에 대해서는 <a href=/ko/docs/tasks/administer-cluster/certificates/>인증서</a>를 살펴본다.
인증서를 관리하는 방법에 대해서는 <a href=/ko/docs/tasks/administer-cluster/kubeadm/kubeadm-certs/>kubeadm을 사용한 인증서 관리</a>를 살펴본다.</p>
<h3 id=단일-루트-ca>단일 루트 CA</h3>
<p>관리자에 의해 제어되는 단일 루트 CA를 만들 수 있다. 이 루트 CA는 여러 중간 CA를 생성할 수 있고, 모든 추가 생성에 관해서도 쿠버네티스 자체에 위임할 수 있다.</p>
<p>필요 CA:</p>
<table>
<thead>
<tr>
<th>경로</th>
<th>기본 CN</th>
<th>설명</th>
</tr>
</thead>
<tbody>
<tr>
<td>ca.crt,key</td>
<td>kubernetes-ca</td>
<td>쿠버네티스 일반 CA</td>
</tr>
<tr>
<td>etcd/ca.crt,key</td>
<td>etcd-ca</td>
<td>모든 etcd 관련 기능을 위해서</td>
</tr>
<tr>
<td>front-proxy-ca.crt,key</td>
<td>kubernetes-front-proxy-ca</td>
<td><a href=/docs/tasks/extend-kubernetes/configure-aggregation-layer/>front-end proxy</a> 위해서</td>
</tr>
</tbody>
</table>
<p>위의 CA외에도, 서비스 계정 관리를 위한 공개/개인 키 쌍인 <code>sa.key</code> 와 <code>sa.pub</code> 을 얻는 것이 필요하다.
다음은 이전 표에 나온 CA 키와 인증서 파일을 보여준다.</p>
<pre><code>/etc/kubernetes/pki/ca.crt
/etc/kubernetes/pki/ca.key
/etc/kubernetes/pki/etcd/ca.crt
/etc/kubernetes/pki/etcd/ca.key
/etc/kubernetes/pki/front-proxy-ca.crt
/etc/kubernetes/pki/front-proxy-ca.key
</code></pre><h3 id=모든-인증서>모든 인증서</h3>
<p>이런 개인키를 API 서버에 복사하기 원치 않는다면, 모든 인증서를 스스로 생성할 수 있다.</p>
<p>필요한 인증서:</p>
<table>
<thead>
<tr>
<th>기본 CN</th>
<th>부모 CA</th>
<th>O (주체에서)</th>
<th>종류</th>
<th>호스트 (SAN)</th>
</tr>
</thead>
<tbody>
<tr>
<td>kube-etcd</td>
<td>etcd-ca</td>
<td></td>
<td>server, client</td>
<td><code>&lt;hostname></code>, <code>&lt;Host_IP></code>, <code>localhost</code>, <code>127.0.0.1</code></td>
</tr>
<tr>
<td>kube-etcd-peer</td>
<td>etcd-ca</td>
<td></td>
<td>server, client</td>
<td><code>&lt;hostname></code>, <code>&lt;Host_IP></code>, <code>localhost</code>, <code>127.0.0.1</code></td>
</tr>
<tr>
<td>kube-etcd-healthcheck-client</td>
<td>etcd-ca</td>
<td></td>
<td>client</td>
<td></td>
</tr>
<tr>
<td>kube-apiserver-etcd-client</td>
<td>etcd-ca</td>
<td>system:masters</td>
<td>client</td>
<td></td>
</tr>
<tr>
<td>kube-apiserver</td>
<td>kubernetes-ca</td>
<td></td>
<td>server</td>
<td><code>&lt;hostname></code>, <code>&lt;Host_IP></code>, <code>&lt;advertise_IP></code>, <code>[1]</code></td>
</tr>
<tr>
<td>kube-apiserver-kubelet-client</td>
<td>kubernetes-ca</td>
<td>system:masters</td>
<td>client</td>
<td></td>
</tr>
<tr>
<td>front-proxy-client</td>
<td>kubernetes-front-proxy-ca</td>
<td></td>
<td>client</td>
<td></td>
</tr>
</tbody>
</table>
<p>[1]: 클러스터에 접속한 다른 IP 또는 DNS 이름(<a href=/ko/docs/reference/setup-tools/kubeadm/>kubeadm</a>이 사용하는
로드 밸런서 안정 IP 또는 DNS 이름, <code>kubernetes</code>, <code>kubernetes.default</code>, <code>kubernetes.default.svc</code>,
<code>kubernetes.default.svc.cluster</code>, <code>kubernetes.default.svc.cluster.local</code>)</p>
<p><code>kind</code>는 하나 이상의 <a href=https://godoc.org/k8s.io/api/certificates/v1beta1#KeyUsage>x509 키 사용</a> 종류를 가진다.</p>
<table>
<thead>
<tr>
<th>종류</th>
<th>키 사용</th>
</tr>
</thead>
<tbody>
<tr>
<td>server</td>
<td>digital signature, key encipherment, server auth</td>
</tr>
<tr>
<td>client</td>
<td>digital signature, key encipherment, client auth</td>
</tr>
</tbody>
</table>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> 위에 나열된 호스트/SAN은 작업 중인 클러스터를 획득하는데 권장된다. 특정 설정이 필요한 경우, 모든 서버 인증서에 SAN을 추가할 수 있다.
</div>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> <p>kubeadm 사용자만 해당:</p>
<ul>
<li>개인 키 없이 클러스터 CA 인증서에 복사하는 시나리오는 kubeadm 문서에서 외부 CA라고 한다.</li>
<li>위 목록을 kubeadm이 생성한 PKI와 비교하는 경우, <code>kube-etcd</code>, <code>kube-etcd-peer</code> 와 <code>kube-etcd-healthcheck-client</code> 인증서는
외부 etcd 케이스에서는 생성하지 않는 것을 알고 있어야 한다.</li>
</ul>
</div>
<h3 id=certificate-paths>인증서 파일 경로</h3>
<p>인증서는 권고하는 파일 경로에 존재해야 한다(<a href=/ko/docs/reference/setup-tools/kubeadm/>kubeadm</a>에서 사용되는 것처럼).
경로는 위치에 관계없이 주어진 파라미터를 사용하여 지정해야 한다.</p>
<table>
<thead>
<tr>
<th>기본 CN</th>
<th>권고되는 키 파일 경로</th>
<th>권고하는 인증서 파일 경로</th>
<th>명령어</th>
<th>키 파라미터</th>
<th>인증서 파라미터</th>
</tr>
</thead>
<tbody>
<tr>
<td>etcd-ca</td>
<td>etcd/ca.key</td>
<td>etcd/ca.crt</td>
<td>kube-apiserver</td>
<td></td>
<td>--etcd-cafile</td>
</tr>
<tr>
<td>kube-apiserver-etcd-client</td>
<td>apiserver-etcd-client.key</td>
<td>apiserver-etcd-client.crt</td>
<td>kube-apiserver</td>
<td>--etcd-keyfile</td>
<td>--etcd-certfile</td>
</tr>
<tr>
<td>kubernetes-ca</td>
<td>ca.key</td>
<td>ca.crt</td>
<td>kube-apiserver</td>
<td></td>
<td>--client-ca-file</td>
</tr>
<tr>
<td>kubernetes-ca</td>
<td>ca.key</td>
<td>ca.crt</td>
<td>kube-controller-manager</td>
<td>--cluster-signing-key-file</td>
<td>--client-ca-file, --root-ca-file, --cluster-signing-cert-file</td>
</tr>
<tr>
<td>kube-apiserver</td>
<td>apiserver.key</td>
<td>apiserver.crt</td>
<td>kube-apiserver</td>
<td>--tls-private-key-file</td>
<td>--tls-cert-file</td>
</tr>
<tr>
<td>kube-apiserver-kubelet-client</td>
<td>apiserver-kubelet-client.key</td>
<td>apiserver-kubelet-client.crt</td>
<td>kube-apiserver</td>
<td>--kubelet-client-key</td>
<td>--kubelet-client-certificate</td>
</tr>
<tr>
<td>front-proxy-ca</td>
<td>front-proxy-ca.key</td>
<td>front-proxy-ca.crt</td>
<td>kube-apiserver</td>
<td></td>
<td>--requestheader-client-ca-file</td>
</tr>
<tr>
<td>front-proxy-ca</td>
<td>front-proxy-ca.key</td>
<td>front-proxy-ca.crt</td>
<td>kube-controller-manager</td>
<td></td>
<td>--requestheader-client-ca-file</td>
</tr>
<tr>
<td>front-proxy-client</td>
<td>front-proxy-client.key</td>
<td>front-proxy-client.crt</td>
<td>kube-apiserver</td>
<td>--proxy-client-key-file</td>
<td>--proxy-client-cert-file</td>
</tr>
<tr>
<td>etcd-ca</td>
<td>etcd/ca.key</td>
<td>etcd/ca.crt</td>
<td>etcd</td>
<td></td>
<td>--trusted-ca-file, --peer-trusted-ca-file</td>
</tr>
<tr>
<td>kube-etcd</td>
<td>etcd/server.key</td>
<td>etcd/server.crt</td>
<td>etcd</td>
<td>--key-file</td>
<td>--cert-file</td>
</tr>
<tr>
<td>kube-etcd-peer</td>
<td>etcd/peer.key</td>
<td>etcd/peer.crt</td>
<td>etcd</td>
<td>--peer-key-file</td>
<td>--peer-cert-file</td>
</tr>
<tr>
<td>etcd-ca</td>
<td></td>
<td>etcd/ca.crt</td>
<td>etcdctl</td>
<td></td>
<td>--cacert</td>
</tr>
<tr>
<td>kube-etcd-healthcheck-client</td>
<td>etcd/healthcheck-client.key</td>
<td>etcd/healthcheck-client.crt</td>
<td>etcdctl</td>
<td>--key</td>
<td>--cert</td>
</tr>
</tbody>
</table>
<p>서비스 계정 키 쌍에도 동일한 고려 사항이 적용된다.</p>
<table>
<thead>
<tr>
<th>개인키 경로</th>
<th>공개 키 경로</th>
<th>명령어</th>
<th>파라미터</th>
</tr>
</thead>
<tbody>
<tr>
<td>sa.key</td>
<td></td>
<td>kube-controller-manager</td>
<td>--service-account-private-key-file</td>
</tr>
<tr>
<td></td>
<td>sa.pub</td>
<td>kube-apiserver</td>
<td>--service-account-key-file</td>
</tr>
</tbody>
</table>
<p>다음은 키와 인증서를 모두 생성할 때에 제공해야 하는 <a href=#certificate-paths>이전 표에 있는</a> 파일의 경로를 보여준다.</p>
<pre><code>/etc/kubernetes/pki/etcd/ca.key
/etc/kubernetes/pki/etcd/ca.crt
/etc/kubernetes/pki/apiserver-etcd-client.key
/etc/kubernetes/pki/apiserver-etcd-client.crt
/etc/kubernetes/pki/ca.key
/etc/kubernetes/pki/ca.crt
/etc/kubernetes/pki/apiserver.key
/etc/kubernetes/pki/apiserver.crt
/etc/kubernetes/pki/apiserver-kubelet-client.key
/etc/kubernetes/pki/apiserver-kubelet-client.crt
/etc/kubernetes/pki/front-proxy-ca.key
/etc/kubernetes/pki/front-proxy-ca.crt
/etc/kubernetes/pki/front-proxy-client.key
/etc/kubernetes/pki/front-proxy-client.crt
/etc/kubernetes/pki/etcd/server.key
/etc/kubernetes/pki/etcd/server.crt
/etc/kubernetes/pki/etcd/peer.key
/etc/kubernetes/pki/etcd/peer.crt
/etc/kubernetes/pki/etcd/healthcheck-client.key
/etc/kubernetes/pki/etcd/healthcheck-client.crt
/etc/kubernetes/pki/sa.key
/etc/kubernetes/pki/sa.pub
</code></pre><h2 id=각-사용자-계정을-위한-인증서-설정하기>각 사용자 계정을 위한 인증서 설정하기</h2>
<p>반드시 이런 관리자 계정과 서비스 계정을 설정해야 한다.</p>
<table>
<thead>
<tr>
<th>파일명</th>
<th>자격증명 이름</th>
<th>기본 CN</th>
<th>O (주체에서)</th>
</tr>
</thead>
<tbody>
<tr>
<td>admin.conf</td>
<td>default-admin</td>
<td>kubernetes-admin</td>
<td>system:masters</td>
</tr>
<tr>
<td>kubelet.conf</td>
<td>default-auth</td>
<td>system:node:<code>&lt;nodeName></code> (note를 보자)</td>
<td>system:nodes</td>
</tr>
<tr>
<td>controller-manager.conf</td>
<td>default-controller-manager</td>
<td>system:kube-controller-manager</td>
<td></td>
</tr>
<tr>
<td>scheduler.conf</td>
<td>default-scheduler</td>
<td>system:kube-scheduler</td>
<td></td>
</tr>
</tbody>
</table>
<div class="alert alert-info note callout" role=alert>
<strong>참고:</strong> <code>kubelet.conf</code>을 위한 <code>&lt;nodeName></code>값은 API 서버에 등록된 것처럼 kubelet에 제공되는 노드 이름 값과 <strong>반드시</strong> 정확히 일치해야 한다. 더 자세한 내용은 <a href=/docs/reference/access-authn-authz/node/>노드 인증</a>을 살펴보자.
</div>
<ol>
<li>
<p>각 환경 설정에 대해 주어진 CN과 O를 이용하여 x509 인증서와 키쌍을 생성한다.</p>
</li>
<li>
<p>각 환경 설정에 대해 다음과 같이 <code>kubectl</code>를 실행한다.</p>
</li>
</ol>
<pre><code>KUBECONFIG=&lt;filename&gt; kubectl config set-cluster default-cluster --server=https://&lt;host ip&gt;:6443 --certificate-authority &lt;path-to-kubernetes-ca&gt; --embed-certs
KUBECONFIG=&lt;filename&gt; kubectl config set-credentials &lt;credential-name&gt; --client-key &lt;path-to-key&gt;.pem --client-certificate &lt;path-to-cert&gt;.pem --embed-certs
KUBECONFIG=&lt;filename&gt; kubectl config set-context default-system --cluster default-cluster --user &lt;credential-name&gt;
KUBECONFIG=&lt;filename&gt; kubectl config use-context default-system
</code></pre><p>이 파일들은 다음과 같이 사용된다.</p>
<table>
<thead>
<tr>
<th>파일명</th>
<th>명령어</th>
<th>설명</th>
</tr>
</thead>
<tbody>
<tr>
<td>admin.conf</td>
<td>kubectl</td>
<td>클러스터 관리자를 설정한다.</td>
</tr>
<tr>
<td>kubelet.conf</td>
<td>kubelet</td>
<td>클러스터 각 노드를 위해 필요하다.</td>
</tr>
<tr>
<td>controller-manager.conf</td>
<td>kube-controller-manager</td>
<td>반드시 매니페스트를 <code>manifests/kube-controller-manager.yaml</code>에 추가해야 한다.</td>
</tr>
<tr>
<td>scheduler.conf</td>
<td>kube-scheduler</td>
<td>반드시 매니페스트를 <code>manifests/kube-scheduler.yaml</code>에 추가해야 한다.</td>
</tr>
</tbody>
</table>
<p>다음의 파일은 이전 표에 나열된 파일의 전체 경로를 보여준다.</p>
<pre><code>/etc/kubernetes/admin.conf
/etc/kubernetes/kubelet.conf
/etc/kubernetes/controller-manager.conf
/etc/kubernetes/scheduler.conf
</code></pre>
</div>
</main>
</div>
</div>
<footer class=d-print-none>
<div class=footer__links>
<nav>
<a class=text-white href=/ko/docs/home/>홈</a>
<a class=text-white href=/ko/blog/>블로그</a>
<a class=text-white href=/ko/training/>교육</a>
<a class=text-white href=/ko/partners/>파트너</a>
<a class=text-white href=/ko/community/>커뮤니티</a>
<a class=text-white href=/ko/case-studies/>사례 연구</a>
</nav>
</div>
<div class=container-fluid>
<div class=row>
<div class="col-6 col-sm-2 text-xs-center order-sm-2">
<ul class="list-inline mb-0">
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="User mailing list" aria-label="User mailing list">
<a class=text-white target=_blank href=https://discuss.kubernetes.io>
<i class="fa fa-envelope"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Twitter aria-label=Twitter>
<a class=text-white target=_blank href=https://twitter.com/kubernetesio>
<i class="fab fa-twitter"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Calendar aria-label=Calendar>
<a class=text-white target=_blank href="https://calendar.google.com/calendar/embed?src=calendar%40kubernetes.io">
<i class="fas fa-calendar-alt"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Youtube aria-label=Youtube>
<a class=text-white target=_blank href=https://youtube.com/kubernetescommunity>
<i class="fab fa-youtube"></i>
</a>
</li>
</ul>
</div>
<div class="col-6 col-sm-2 text-right text-xs-center order-sm-3">
<ul class="list-inline mb-0">
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub>
<a class=text-white target=_blank href=https://github.com/kubernetes/kubernetes>
<i class="fab fa-github"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Slack aria-label=Slack>
<a class=text-white target=_blank href=https://slack.k8s.io>
<i class="fab fa-slack"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Contribute aria-label=Contribute>
<a class=text-white target=_blank href=https://git.k8s.io/community/contributors/guide>
<i class="fas fa-edit"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Stack Overflow" aria-label="Stack Overflow">
<a class=text-white target=_blank href=https://stackoverflow.com/questions/tagged/kubernetes>
<i class="fab fa-stack-overflow"></i>
</a>
</li>
</ul>
</div>
<div class="col-12 col-sm-8 text-center order-sm-2">
<small class=text-white>&copy; 2023 The Kubernetes Authors | Documentation Distributed under <a href=https://git.k8s.io/website/LICENSE class=light-text>CC BY 4.0</a></small>
<br>
<small class=text-white>Copyright &copy; 2023 The Linux Foundation &reg;. All rights reserved. The Linux Foundation has registered trademarks and uses trademarks. For a list of trademarks of The Linux Foundation, please see our <a href=https://www.linuxfoundation.org/trademark-usage class=light-text>Trademark Usage page</a></small>
<br>
<small class=text-white>ICP license: 京ICP备17074266号-3</small>
</div>
</div>
</div>
</footer>
</div>
<script src=/js/popper-1.14.3.min.js integrity=sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49 crossorigin=anonymous></script>
<script src=/js/bootstrap-4.3.1.min.js integrity=sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM crossorigin=anonymous></script>
<script src=/js/main.min.40616251a9b6e4b689e7769be0340661efa4d7ebb73f957404e963e135b4ed52.js integrity="sha256-QGFiUam25LaJ53ab4DQGYe+k1+u3P5V0BOlj4TW07VI=" crossorigin=anonymous></script>
</body>
</html>