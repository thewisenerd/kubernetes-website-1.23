<!doctype html><html lang=pt-br class=no-js>
<head>
<meta name=ROBOTS content="NOINDEX, NOFOLLOW">
<script async src="https://www.googletagmanager.com/gtag/js?id=G-JPP6RFM2BP"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-JPP6RFM2BP')</script>
<link rel=alternate hreflang=en href=https://kubernetes.io/docs/reference/>
<link rel=alternate hreflang=zh href=https://kubernetes.io/zh/docs/reference/>
<link rel=alternate hreflang=ko href=https://kubernetes.io/ko/docs/reference/>
<link rel=alternate hreflang=ja href=https://kubernetes.io/ja/docs/reference/>
<link rel=alternate hreflang=fr href=https://kubernetes.io/fr/docs/reference/>
<link rel=alternate hreflang=de href=https://kubernetes.io/de/docs/reference/>
<link rel=alternate hreflang=es href=https://kubernetes.io/es/docs/reference/>
<link rel=alternate hreflang=id href=https://kubernetes.io/id/docs/reference/>
<link rel=alternate hreflang=ru href=https://kubernetes.io/ru/docs/reference/>
<link rel=alternate hreflang=pl href=https://kubernetes.io/pl/docs/reference/>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=generator content="Hugo 0.87.0">
<link rel=canonical type=text/html href=https://kubernetes.io/pt-br/docs/reference/>
<link rel="shortcut icon" type=image/png href=/images/favicon.png>
<link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180>
<link rel=manifest href=/manifest.webmanifest>
<link rel=apple-touch-icon href=/images/kubernetes-192x192.png>
<title>Referência | Kubernetes</title><meta property="og:title" content="Referência">
<meta property="og:description" content="Orquestração de contêineres em nível de produção">
<meta property="og:type" content="website">
<meta property="og:url" content="https://kubernetes.io/pt-br/docs/reference/"><meta property="og:site_name" content="Kubernetes">
<meta itemprop=name content="Referência">
<meta itemprop=description content="Orquestração de contêineres em nível de produção"><meta name=twitter:card content="summary">
<meta name=twitter:title content="Referência">
<meta name=twitter:description content="Orquestração de contêineres em nível de produção">
<link href=/scss/main.css rel=stylesheet>
<script src=/js/jquery-3.3.1.min.js integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin=anonymous></script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","url":"https://kubernetes.io","logo":"https://kubernetes.io/images/favicon.png"}</script>
<meta name=theme-color content="#326ce5">
<link rel=stylesheet href=/css/feature-states.css>
<meta name=description content="Esta seção da documentação do Kubernetes contém referências.
Referência da API  Visão geral da API do Kubernetes - Visão geral da API para Kubernetes. Referência da API Kubernetes v1.27  Biblioteca de clientes da API Para chamar a API Kubernetes de uma linguagem de programação, você pode usar bibliotecas de clientes. Bibliotecas oficialmente suportadas:
 Biblioteca do cliente Kubernetes em Go Biblioteca do cliente Kubernetes em Python Biblioteca do cliente Kubernetes em Java Biblioteca do cliente Kubernetes em JavaScript  Referência da CLI  kubectl - Ferramenta CLI principal para executar comandos e gerenciar clusters do Kubernetes.">
<meta property="og:description" content="Esta seção da documentação do Kubernetes contém referências.
Referência da API  Visão geral da API do Kubernetes - Visão geral da API para Kubernetes. Referência da API Kubernetes v1.27  Biblioteca de clientes da API Para chamar a API Kubernetes de uma linguagem de programação, você pode usar bibliotecas de clientes. Bibliotecas oficialmente suportadas:
 Biblioteca do cliente Kubernetes em Go Biblioteca do cliente Kubernetes em Python Biblioteca do cliente Kubernetes em Java Biblioteca do cliente Kubernetes em JavaScript  Referência da CLI  kubectl - Ferramenta CLI principal para executar comandos e gerenciar clusters do Kubernetes.">
<meta name=twitter:description content="Esta seção da documentação do Kubernetes contém referências.
Referência da API  Visão geral da API do Kubernetes - Visão geral da API para Kubernetes. Referência da API Kubernetes v1.27  Biblioteca de clientes da API Para chamar a API Kubernetes de uma linguagem de programação, você pode usar bibliotecas de clientes. Bibliotecas oficialmente suportadas:
 Biblioteca do cliente Kubernetes em Go Biblioteca do cliente Kubernetes em Python Biblioteca do cliente Kubernetes em Java Biblioteca do cliente Kubernetes em JavaScript  Referência da CLI  kubectl - Ferramenta CLI principal para executar comandos e gerenciar clusters do Kubernetes.">
<meta property="og:url" content="https://kubernetes.io/pt-br/docs/reference/">
<meta property="og:title" content="Referência">
<meta name=twitter:title content="Referência">
<meta name=twitter:image content="https://kubernetes.io/images/favicon.png">
<meta name=twitter:image:alt content="Kubernetes">
<meta property="og:image" content="/images/kubernetes-horizontal-color.png">
<meta property="og:type" content="article">
<script src=/js/script.js></script>
</head>
<body class=td-section>
<header>
<nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar" data-auto-burger=primary>
<a class=navbar-brand href=/pt-br/></a>
<div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar>
<ul class="navbar-nav mt-2 mt-lg-0">
<li class="nav-item mr-2 mb-lg-0">
<a class="nav-link active" href=/pt-br/docs/>Documentação</a>
</li>
<li class="nav-item mr-2 mb-lg-0">
<a class=nav-link href=/pt-br/blog/>Kubernetes Blog</a>
</li>
<li class="nav-item mr-2 mb-lg-0">
<a class=nav-link href=/pt-br/partners/>Parceiros</a>
</li>
<li class="nav-item mr-2 mb-lg-0">
<a class=nav-link href=/pt-br/community/>Comunidade</a>
</li>
<li class="nav-item mr-2 mb-lg-0">
<a class=nav-link href=/pt-br/case-studies/>Casos de estudo</a>
</li>
<li class="nav-item dropdown">
<a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>
Versões
</a>
<div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink>
<a class=dropdown-item href=/releases>Release Information</a>
<a class=dropdown-item href=https://kubernetes.io/pt-br/docs/reference/>v1.27</a>
<a class=dropdown-item href=https://v1-26.docs.kubernetes.io/pt-br/docs/reference/>v1.26</a>
<a class=dropdown-item href=https://v1-25.docs.kubernetes.io/pt-br/docs/reference/>v1.25</a>
<a class=dropdown-item href=https://v1-24.docs.kubernetes.io/pt-br/docs/reference/>v1.24</a>
<a class=dropdown-item href=https://v1-23.docs.kubernetes.io/pt-br/docs/reference/>v1.23</a>
</div>
</li>
<li class="nav-item dropdown">
<a class="nav-link dropdown-toggle" href=# id=navbarDropdownMenuLink role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>
Português
</a>
<div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink>
<a class=dropdown-item href=/docs/reference/>English</a>
<a class=dropdown-item href=/zh/docs/reference/>中文 Chinese</a>
<a class=dropdown-item href=/ko/docs/reference/>한국어 Korean</a>
<a class=dropdown-item href=/ja/docs/reference/>日本語 Japanese</a>
<a class=dropdown-item href=/fr/docs/reference/>Français</a>
<a class=dropdown-item href=/de/docs/reference/>Deutsch</a>
<a class=dropdown-item href=/es/docs/reference/>Español</a>
<a class=dropdown-item href=/id/docs/reference/>Bahasa Indonesia</a>
<a class=dropdown-item href=/ru/docs/reference/>Русский</a>
<a class=dropdown-item href=/pl/docs/reference/>Polski</a>
</div>
</li>
</ul>
</div>
<button id=hamburger onclick=kub.toggleMenu() data-auto-burger-exclude><div></div></button>
</nav>
</header>
<div class="container-fluid td-outer">
<div class=td-main>
<div class="row flex-xl-nowrap">
<main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main>
<div class=td-content>
<div class="pageinfo pageinfo-primary d-print-none">
<p>
Essa é a versão completa de impressão dessa seção
<a href=# onclick="return print(),!1">Clique aqui para imprimir</a>.
</p><p>
<a href=/pt-br/docs/reference/>Retornar à visualização normal</a>.
</p>
</div>
<h1 class=title>Referência</h1>
<ul>
<li>1: <a href=#pg-2b03679960950df772fb4fe7d78427b9>Glossário</a></li>
<li>2: <a href=#pg-a6264859a5ad6e2f4a6e4cff9ce4fa8b>Autenticação</a></li>
<li>3: <a href=#pg-de45b6ca7419a0e308044425b2ac52bb>Autenticando com Tokens de Inicialização</a></li>
<li>4: <a href=#pg-df8ff2190764e70c3de2015e2cb46b14>Portas e protocolos</a></li>
<li>5: <a href=#pg-03460a7254c6c73eb2a1bb3dd7d25910>kubectl CLI</a></li>
<ul>
<li>5.1: <a href=#pg-8aba901ac13f124e5782b90ddb166ee2>kubectl Cheat Sheet</a></li>
</ul>
<li>6: <a href=#pg-4f002b9458521ca7afd32176fd590646>Ferramentas</a></li>
</ul>
<div class=content>
<p>Esta seção da documentação do Kubernetes contém referências.</p>
<h2 id=referência-da-api>Referência da API</h2>
<ul>
<li><a href=/docs/reference/using-api/api-overview/>Visão geral da API do Kubernetes</a> - Visão geral da API para Kubernetes.</li>
<li><a href=/docs/reference/generated/kubernetes-api/v1.27/>Referência da API Kubernetes v1.27</a></li>
</ul>
<h2 id=biblioteca-de-clientes-da-api>Biblioteca de clientes da API</h2>
<p>Para chamar a API Kubernetes de uma linguagem de programação, você pode usar
<a href=/docs/reference/using-api/client-libraries/>bibliotecas de clientes</a>. Bibliotecas oficialmente suportadas:</p>
<ul>
<li><a href=https://github.com/kubernetes/client-go/>Biblioteca do cliente Kubernetes em Go</a></li>
<li><a href=https://github.com/kubernetes-client/python>Biblioteca do cliente Kubernetes em Python</a></li>
<li><a href=https://github.com/kubernetes-client/java>Biblioteca do cliente Kubernetes em Java</a></li>
<li><a href=https://github.com/kubernetes-client/javascript>Biblioteca do cliente Kubernetes em JavaScript</a></li>
</ul>
<h2 id=referência-da-cli>Referência da CLI</h2>
<ul>
<li><a href=/docs/reference/kubectl/overview/>kubectl</a> - Ferramenta CLI principal para executar comandos e gerenciar clusters do Kubernetes.
<ul>
<li><a href=/docs/reference/kubectl/jsonpath/>JSONPath</a> - Guia de sintaxe para usar <a href=http://goessner.net/articles/JsonPath/>Expressões JSONPath</a> com o kubectl.</li>
</ul>
</li>
<li><a href=/docs/reference/setup-tools/kubeadm/kubeadm/>kubeadm</a> - Ferramenta CLI para provisionar facilmente um cluster Kubernetes seguro.</li>
</ul>
<h2 id=referência-de-configuração>Referência de configuração</h2>
<ul>
<li><a href=/docs/reference/command-line-tools-reference/kubelet/>kubelet</a> - O principal <em>agente do nó</em> que é executado em cada nó. O kubelet usa um conjunto de PodSpecs e garante que os contêineres descritos estejam funcionando e saudáveis.</li>
<li><a href=/docs/reference/command-line-tools-reference/kube-apiserver/>kube-apiserver</a> - API REST que valida e configura dados para objetos de API, como pods, serviços, controladores de replicação.</li>
<li><a href=/docs/reference/command-line-tools-reference/kube-controller-manager/>kube-controller-manager</a> - Daemon que incorpora os principais loops de controle enviados com o Kubernetes.</li>
<li><a href=/docs/reference/command-line-tools-reference/kube-proxy/>kube-proxy</a> - É possível fazer o encaminhamento de fluxo TCP/UDP de forma simples ou utilizando o algoritimo de Round Robin encaminhando através de um conjunto de back-ends.</li>
<li><a href=/docs/reference/command-line-tools-reference/kube-scheduler/>kube-scheduler</a> - Agendador que gerencia disponibilidade, desempenho e capacidade.</li>
</ul>
<h2 id=documentos-de-design>Documentos de design</h2>
<p>Um arquivo dos documentos de design para as funcionalidades do Kubernetes. Bons pontos de partida são <a href=https://git.k8s.io/community/contributors/design-proposals/architecture/architecture.md>Arquitetura Kubernetes</a> e <a href=https://git.k8s.io/community/contributors/design-proposals>Visão geral do design do Kubernetes</a>.</p>
</div>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-2b03679960950df772fb4fe7d78427b9>1 - Glossário</h1>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-a6264859a5ad6e2f4a6e4cff9ce4fa8b>2 - Autenticação</h1>
<p>Essa página demonstra uma visão geral sobre autenticação</p>
<h2 id=usuários-no-kubernetes>Usuários no Kubernetes</h2>
<p>Todos os clusters Kubernetes possuem duas categorias de usuários: contas de serviço gerenciadas pelo Kubernetes e usuários normais.</p>
<p>Assume-se que um serviço independente do cluster gerencia usuários normais das seguintes formas:</p>
<ul>
<li>Um administrador distribuindo chaves privadas</li>
<li>Uma base de usuários como Keystone <p>Keystone é o serviço de identidade usado pelo OpenStack para autenticação (authN) e autorização de alto nível (authZ). Atualmente, ele oferece suporte a authN com base em token e autorização de serviço do usuário. Recentemente, foi reprojetado para permitir a expansão para oferecer suporte a serviços externos de proxy e mecanismos AuthN / AuthZ, como oAuth, SAML e openID em versões futuras.</p> ou Google Accounts</li>
<li>Um arquivo com uma lista de nomes de usuários e senhas</li>
</ul>
<p>Neste quesito, <em>Kubernetes não possui objetos que possam representar as contas de um usuário normal.</em> Usuários normais não podem ser adicionados ao <em>cluster</em> através de uma chamada para a API.</p>
<p>Apesar de um usuário normal não poder ser adicionado através de uma chamada para a API, qualquer usuário que apresente um certificado válido e assinado pela autoridade de certificados (CA) do <em>cluster</em> é considerado autenticado. Nesta configuração, Kubernetes determina o nome do usuário baseado no campo de nome comum no sujeito (<em>subject</em>) do certificado (por exemplo: "/CN=bob"). A partir daí, o subsistema de controle de acesso baseado em função (RBAC) determina se o usuário é autorizado a realizar uma operação específica sobre o recurso. Para mais detalhes, veja a referência sobre o tópico de usuários normais dentro de <a href=/docs/reference/access-authn-authz/certificate-signing-requests/#normal-user>requisição de certificado</a>.</p>
<p>Em contraste a usuários normais, contas de serviço são considerados usuários gerenciados pela API do Kubernetes. Elas estão vinculadas à <em>namespaces</em> específicas e criadas automaticamente pelo servidor de API ou manualmente através de chamadas da API. Contas de serviço estão ligadas a um conjunto de credenciais armazenados como <code>Secrets</code>, aos quais são montados dentro dos <em>pods</em> assim permitindo que processos internos ao <em>cluster</em> comuniquem-se com a API do Kubernetes.</p>
<p>Requisições para a API estão ligadas a um usuário normal, conta de serviço ou serão tratadas como <a href=#anonymous-requests>requisições anônimas</a>. Isto significa que cada processo dentro ou fora do <em>cluster</em>, desde um usuário humano utilizando o <code>kubectl</code> de uma estação de trabalho, a <code>kubelets</code> rodando nos nós, a membros da camada de gerenciamento (s/painel de controle) devem autenticar-se ao realizarem suas requisições para o servidor API ou serão tratados como usuário anônimo.</p>
<h2 id=estratégias-de-autenticação>Estratégias de autenticação</h2>
<p>Kubernetes usa certificados de clientes, <em>bearer Token</em>, um proxy realizando autenticação, ou uma autenticação básica HTTP para autenticar requisições para o servidor de API através de plugins. Como requisições HTTP são feitas no servidor de API, plugins tentam associar os seguintes atributos junto a requisição:</p>
<ul>
<li>Username <p>Um nome de usuário é um nome que identifica exclusivamente alguém em um sistema de computador. Por exemplo, um computador pode ser configurado com várias contas, com nomes de usuário diferentes para cada conta. Muitos sites permitem que os usuários escolham um nome de usuário para que possam personalizar suas configurações ou configurar uma conta online. Por exemplo, seu banco pode permitir que você escolha um nome de usuário para acessar suas informações bancárias. Você pode precisar escolher um nome de usuário para postar mensagens em um determinado quadro de mensagens na web. Os serviços de e-mail, como o Hotmail, exigem que os usuários escolham um nome de usuário para usar o serviço.</p>
<p>Um nome de usuário geralmente é pareado com uma senha. Essa combinação de nome de usuário / senha é conhecida como login e geralmente é necessária para que os usuários façam login em sites. Por exemplo, para acessar seu e-mail pela Web, é necessário inserir seu nome de usuário e senha. Depois de fazer o login, seu nome de usuário pode aparecer na tela, mas sua senha é mantida em segredo. Ao manter sua senha privada, as pessoas podem criar contas seguras para vários sites. A maioria dos nomes de usuário pode conter letras e números, mas não espaços. Quando você escolhe um nome de usuário para uma conta de e-mail, a parte antes de "@" é o seu nome de usuário.</p>: um valor (String) que identifica o usuário final. Valores comuns podem ser <code>kube-admin</code> ou <code>jane@example.com</code></li>
<li>UID <p>Um identificador exclusivo (UID) é uma sequência numérica ou alfanumérica associada a uma única entidade em um determinado sistema. Os UIDs tornam possível endereçar essa entidade para que ela possa ser acessada e interagida. Cada usuário é identificado no sistema por seu UID e os nomes de usuário geralmente são usados apenas como uma interface para humanos.</p>
: um valor (String) que identifica o usuário final e tenta ser mais consistente e único do que username.</li>
<li>Groups: Um conjunto de valores em que cada item indica a associação de um usuário à uma coleção lógica de usuários. Valores comuns podem ser <code>system:masters</code> ou <code>devops-team</code>.</li>
<li>Campos extras: um mapa que pode conter uma lista de atributos que armazena informações adicionais em que autorizadores podem achar útil.</li>
</ul>
<p>Todos os valores são transparentes para o sistema de autenticação e somente trazem significado quando interpretados por um <a href=/docs/reference/access-authn-authz/authorization/>autorizador</a>.</p>
<p>É possível habilitar múltiplos métodos de autenticação. Deve-se normalmente usar pelo menos dois métodos:</p>
<ul>
<li><em>Tokens</em> para contas de serviço;</li>
<li>Pelo menos um outro método de autenticação para usuários.</li>
</ul>
<p>Quando múltiplos módulos de autenticação estão habilitados, o primeiro módulo a autenticar com sucesso uma requisição termina, o fluxo de avaliação da mesma.</p>
<p>O servidor de API não garante a ordem em que os autenticadores são processados.</p>
<p>O grupo <code>system:authenticated</code> é incluído na lista de grupos de todos os usuários autenticados.</p>
<p>Integrações com outros protocolos de autenticação, como LDAP <p>Abreviatura para "Lightweight Directory Access Protocol". Se você deseja disponibilizar informações de diretório na Internet, esta é a maneira de fazê-lo. O LDAP é uma versão simplificada de um padrão de diretório anterior denominado X.500. O que torna o LDAP tão útil é que ele funciona muito bem em redes TCP / IP (ao contrário do X.500), de modo que as informações podem ser acessadas por meio do LDAP por qualquer pessoa com uma conexão à Internet. Também é um protocolo aberto, o que significa que os diretórios podem ser armazenados em qualquer tipo de máquina (por exemplo, Windows 2000, Red Hat Linux, Mac OS X).</p>
<p>Para dar uma ideia de como um diretório LDAP é organizado, aqui estão os diferentes níveis de uma hierarquia de árvore LDAP simples:</p>
<p>O diretório raiz
Países
Organizações
Divisões, departamentos, etc.
Indivíduos
Recursos individuais, como arquivos e impressoras.
A maior parte da conectividade LDAP é feita nos bastidores, então o usuário típico provavelmente não notará ao navegar na web. No entanto, é uma boa tecnologia para se conhecer. Se nada mais, é outro termo para impressionar seus pais.</p>, SAML <p>SAML significa Linguagem de Marcação para Asserção de Segurança. É um padrão aberto baseado em XML para transferência de dados de identidade entre duas partes: um provedor de identidade (IdP) e um provedor de serviços (SP).</p>
<p>Provedor de identidade - executa autenticação e passa a identidade do usuário e o nível de autorização para o provedor de serviços.</p>
<p>Provedor de serviços - confia no provedor de identidade e autoriza o usuário fornecido a acessar o recurso solicitado.</p>
<p>A autenticação de logon único SAML normalmente envolve um provedor de serviços e um provedor de identidade. O fluxo do processo geralmente envolve os estágios de estabelecimento de confiança e fluxo de autenticação.</p>
<p>Considere este exemplo:</p>
<p>Nosso provedor de identidade é Auth0
Nosso provedor de serviços é um serviço fictício, Zagadat
Nota: O provedor de identidade pode ser qualquer plataforma de gerenciamento de identidade.</p>
<p>Agora, um usuário está tentando obter acesso ao Zagadat usando a autenticação SAML.</p>
<p>Este é o fluxo do processo:</p>
<p>O usuário tenta fazer login no Zagadat a partir de um navegador.
O Zagadat responde gerando uma solicitação SAML.</p>, Kerberos <p>Kerberos é um protocolo de rede que usa criptografia de chave secreta para autenticar aplicativos cliente-servidor. O Kerberos solicita um tíquete criptografado por meio de uma sequência de servidor autenticada para usar os serviços.</p>
<p>Kerberos foi desenvolvido pelo Project Athena - um projeto conjunto entre o Massachusetts Institute of Technology (MIT), Digital Equipment Corporation e IBM que funcionou entre 1983 e 1991.</p>
<p>Um servidor de autenticação usa um tíquete Kerberos para conceder acesso ao servidor e, em seguida, cria uma chave de sessão com base na senha do solicitante e outro valor aleatório. O tíquete de concessão de tíquete (TGT) é enviado ao servidor de concessão de tíquete (TGS), que é necessário para usar o mesmo servidor de autenticação.</p>
<p>O solicitante recebe uma chave TGS criptografada com um registro de data e hora e um tíquete de serviço, que é retornado ao solicitante e descriptografado. O solicitante envia ao TGS essas informações e encaminha a chave criptografada ao servidor para obter o serviço desejado. Se todas as ações forem tratadas corretamente, o servidor aceita o tíquete e realiza o atendimento ao usuário desejado, que deve descriptografar a chave, verificar a data e hora e entrar em contato com o centro de distribuição para obter as chaves de sessão. Essa chave de sessão é enviada ao solicitante, que descriptografa o tíquete.</p>
<p>Se as chaves e o carimbo de data / hora forem válidos, a comunicação cliente-servidor continuará. O tíquete TGS tem carimbo de data / hora, o que permite solicitações simultâneas dentro do período de tempo alocado.</p>, alternate x509 schemes <p>X.509 é um formato padrão para certificados de chave pública, documentos digitais que associam com segurança pares de chaves criptográficas a identidades como sites, indivíduos ou organizações.</p>
<p>Introduzido pela primeira vez em 1988 junto com os padrões X.500 para serviços de diretório eletrônico, o X.509 foi adaptado para uso na Internet pelo grupo de trabalho Public-Key Infrastructure (X.509) (PKIX) da IETF. O RFC 5280 define o perfil do certificado X.509 v3, a lista de revogação de certificado X.509 v2 (CRL) e descreve um algoritmo para a validação do caminho do certificado X.509.</p>
<p>As aplicações comuns de certificados X.509 incluem:</p>
<pre><code>- SSL / TLS e HTTPS para navegação na web autenticada e criptografada
- E-mail assinado e criptografado por meio do protocolo S / MIME
- Assinatura de código
- Assinatura de documento
- Autenticação de cliente
- Identificação eletrônica emitida pelo governo
</code></pre>, etc, podem ser alcançadas utilizando-se de um <a href=#autenticando-com-proxy>proxy</a> ou <a href=#token-de-autentica%C3%A7%C3%A3o-via-webhook>webhook</a> de autenticação.</p>
<h3 id=certificados-de-cliente-x509>Certificados de cliente X509</h3>
<p>Autenticação via certificados de cliente pode ser habilitada ao passar a opção <code>--client-ca-file=ARQUIVO</code> para o servidor de API. O arquivo referenciado deve conter um ou mais autoridades de certificação usadas para validar o certificado de cliente passado para o servidor de API. Se o certificado de cliente é apresentado e verificado, o <em>common name</em> <p>O nome comum é normalmente composto de Host + Nome de domínio e será semelhante a <a href=http://www.seusite.com>www.seusite.com</a> ou seusite.com. Os certificados de servidor SSL são específicos para o nome comum para o qual foram emitidos no nível do host.</p>
<p>O nome comum deve ser igual ao endereço da Web que você acessará ao se conectar a um site seguro. Por exemplo, um certificado de servidor SSL para o domínio domínio.com receberá um aviso do navegador se o acesso a um site chamado <a href=http://www.domain.com>www.domain.com</a> ou secure.domain.com, pois <a href=http://www.domain.com>www.domain.com</a> e secure.domain.com são diferentes de dominio.com. Você precisaria criar um CSR para o nome comum correto.</p> do sujeito é usado como o nome de usuário para a requisição. A partir da versão 1.4, certificados de cliente podem também indicar o pertencimento de um usuário a um grupo utilizando o campo de organização do certificado. Para incluir múltiplos grupos para o usuário, deve-se incluir múltiplos campos de organização no certificado.</p>
<p>Por exemplo, utilizando o comando de linha <code>openssl</code> para gerar uma requisição de assinatura de certificado:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>openssl req -new -key jbeda.pem -out jbeda-csr.pem -subj <span style=color:#b44>&#34;/CN=jbeda/O=app1/O=app2&#34;</span>
</code></pre></div><p>Isto criaria um arquivo de tipo CSR (requisição de assinatura de certificado) para o usuário "jbeda" pertencendo a dois grupos: "app1" e "app2".</p>
<p>Veja como gerar um certificado de cliente em <a href=/docs/concepts/cluster-administration/certificates/>Gerenciando Certificados</a></p>
<h3 id=arquivo-estático-de-token>Arquivo estático de Token</h3>
<p>O servidor de API lê <em>bearer tokens</em> de um arquivo quando recebe uma requisição contendo a opção <code>--token-auth-file=ARQUIVO</code> via linha de comando. Atualmente, tokens têm duração indefinida, e a lista de tokens não pode ser modificada sem reiniciar o servidor de API.</p>
<p>O arquivo de token é do tipo CSV contendo no mínimo 3 colunas: token, nome de usuário, identificador de usuário (uid), seguido pelos nomes de grupos (opcional).</p>
<div class="alert alert-info note callout" role=alert>
<strong>Nota:</strong> <p>Se uma entrada possuir mais de um grupo, a coluna deve ser cercada por aspas duplas, por exemplo:</p>
<pre><code class=language-conf data-lang=conf>token,usuario,uid,&quot;grupo1,grupo2,grupo3&quot;
</code></pre>
</div>
<h4 id=adicionando-um-bearer-token-em-uma-requisição>Adicionando um <em>bearer token</em> em uma requisição</h4>
<p>Quando utilizando-se de <em>bearer token</em> para autenticação de um cliente HTTP, o servidor de API espera um cabeçalho <code>Authorization</code> com um valor <code>Bearer TOKEN</code>. O token deve ser uma sequência de caracteres que pode ser colocada como valor em um cabeçalho HTTP não utilizando-se mais do que as facilidades de codificação e citação de HTTP. Por exemplo, se o valor de um token é <code>31ada4fd-adec-460c-809a-9e56ceb75269</code> então iria aparecer dentro de um cabeçalho HTTP como:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-http data-lang=http><span>Authorization: Bearer 31ada4fd-adec-460c-809a-9e56ceb75269
</span></code></pre></div><h3 id=tokens-de-inicialização>Tokens de inicialização</h3>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.18 [stable]</code>
</div>
<p>Para permitir a inicialização simplificada para novos <em>clusters</em>, Kubernetes inclui um token dinamicamente gerenciado denominado <em>Bootstrap Token</em>. Estes <em>tokens</em> são armazenados como Secrets dentro do namespace <code>kube-system</code>, onde eles podem ser dinamicamente criados e gerenciados. O componente Gerenciador de Controle (Controller Manager) possui um controlador "TokenCleaner" que apaga os <em>tokens</em> de inicialização expirados.</p>
<p>Os <em>tokens</em> seguem o formato <code>[a-z0-9]{6}.[a-z0-9]{16}</code>. O primeiro componente é um identificador do <em>token</em> e o segundo é o segredo. Você pode especificar o <em>token</em> como um cabeçalho HTTP como:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-http data-lang=http><span>Authorization: Bearer 781292.db7bc3a58fc5f07e
</span></code></pre></div><p>Deve-se habilitar os <em>tokens</em> de inicialização com a opção <code>--enable-bootstrap-token-auth</code> no servidor de API. Deve-se habilitar o controlador <code>TokenCleaner</code> através da opção <code>--controllers</code> no Gerenciador de Controle. Isso é feito, por exemplo, como: <code>--controllers=*,tokencleaner</code>. O <code>kubeadm</code>, por exemplo, irá realizar isso caso seja utilizado para a inicialização do cluster.</p>
<p>O autenticador o autentica como <code>system:bootstrap:&lt;Token ID></code> e é incluído no grupo <code>system:bootstrappers</code>. O nome e grupo são intencionalmente limitados para desencorajar usuários a usarem estes <em>tokens</em> após inicialização. Os nomes de usuários e grupos podem ser utilizados (e são utilizados pelo <code>kubeadm</code>) para elaborar as políticas de autorização para suportar a inicialização de um cluster.</p>
<p>Por favor veja <a href=/docs/reference/access-authn-authz/bootstrap-tokens/>Bootstrap Tokens</a> para documentação detalhada sobre o autenticador e controladores de <em>Token</em> de inicialização, bem como gerenciar estes <em>tokens</em> com <code>kubeadm</code>.</p>
<h3 id=tokens-de-contas-de-serviço>Tokens de Contas de serviço</h3>
<p>Uma conta de serviço é um autenticador habilitado automaticamente que usa bearer tokens para verificar as requisições. O plugin aceita dois parâmetros opcionais:</p>
<ul>
<li><code>--service-account-key-file</code> Um arquivo contendo uma chave codificada no formato PEM para assinar <em>bearer tokens</em>. Se não especificado, a chave privada de TLS no servidor de API será utilizada</li>
<li><code>--service-account-lookup</code> Se habilitado, <em>tokens</em> deletados do servidor de API serão revogados.</li>
</ul>
<p>Contas de serviço são normalmente criadas automaticamente pelo servidor de API e associada a <em>pods</em> rodando no cluster através do controlador de admissão <a href=/docs/reference/access-authn-authz/admission-controllers/>Admission Controller</a> de <code>ServiceAccount</code>. Os tokens de contas de serviços são montados nos Pods, em localizações já pré definidas e conhecidas e permitem processos dentro do cluster a se comunicarem com o servidor de API. Contas podem ser explicitamente associadas com <em>pods</em> utilizando o campo <code>serviceAccountName</code> na especificação do pod (<code>PodSpec</code>):</p>
<div class="alert alert-info note callout" role=alert>
<strong>Nota:</strong> <code>serviceAccountName</code> é normalmente omitida por ser feito automaticamente
</div>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1 <span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-deployment<span style=color:#bbb>
</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>   </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>   </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span><span style=color:#bbb>   </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>serviceAccountName</span>:<span style=color:#bbb> </span>bob-the-bot<span style=color:#bbb>
</span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>     </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>       </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.14.2<span style=color:#bbb>
</span></code></pre></div><p>Os <em>tokens</em> de contas de serviço são perfeitamente válidos para ser usados fora do cluster e podem ser utilizados para criar identidades para processos de longa duração que desejem comunicar-se com a API do Kubernetes. Para criar manualmente uma conta de serviço, utilize-se simplesmente o comando <code>kubectl create serviceaccount (NOME)</code>. Isso cria uma conta de serviço e um segredo associado a ela no namespace atual.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl create serviceaccount jenkins
</code></pre></div><pre><code class=language-none data-lang=none>serviceaccount &quot;jenkins&quot; created
</code></pre><p>Verificando um segredo associado:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl get serviceaccounts jenkins -o yaml
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ServiceAccount<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb> </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>secrets</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>jenkins-token-1yvwg<span style=color:#bbb>
</span></code></pre></div><p>O segredo criado irá armazenar a autoridade de certificado do servidor de API e um JSON Web Token (JWT) digitalmente assinado.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl get secret jenkins-token-1yvwg -o yaml
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>ca.crt</span>:<span style=color:#bbb> </span>(APISERVER&#39;S CA BASE64 ENCODED)<span style=color:#bbb>
</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>ZGVmYXVsdA==<span style=color:#bbb>
</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>token</span>:<span style=color:#bbb> </span>(BEARER TOKEN BASE64 ENCODED)<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb> </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>kubernetes.io/service-account-token<span style=color:#bbb>
</span></code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>Nota:</strong> Valores são codificados em base64 porque segredos são sempre codificados neste formato.
</div>
<p>O JWT assinado pode ser usado como um <em>bearer token</em> para autenticar-se como a conta de serviço. Veja <a href=#adicionando-um-bearer-token-em-uma-requisi%C3%A7%C3%A3o>acima</a> como o <em>token</em> pode ser incluído em uma requisição. Normalmente esses segredos são montados no pod para um acesso interno ao cluster ao servidor de API, porém pode ser utilizado fora do cluster também.</p>
<p>Contas de serviço são autenticadas com o nome de usuário <code>system:serviceaccount:(NAMESPACE):(SERVICEACCOUNT)</code> e são atribuídas aos grupos <code>system:serviceaccounts</code> e <code>system:serviceaccounts:(NAMESPACE)</code>.</p>
<p>AVISO: porque os <em>tokens</em> das contas de serviço são armazenados em segredos, qualquer usuário com acesso de leitura a esses segredos podem autenticar-se como a conta de serviço. Tome cuidado quando conceder permissões a contas de serviços e capacidade de leitura de segredos.</p>
<h3 id=tokens-openid-connect>Tokens OpenID Connect</h3>
<p><a href=https://openid.net/connect/>OpenID Connect</a> é uma variação do framework de autorização OAuth2 que suporta provedores como Azure Active Directory, Salesforce, e Google. A principal extensão do OAuth2 é um campo adicional de <em>token</em> de acesso chamado <a href=https://openid.net/specs/openid-connect-core-1_0.html#IDToken>ID Token</a>. Este <em>token</em> é um tipo de JSON Web Token (JWT) com campos bem definidos, como usuário, e-mail e é assinado pelo servidor de autorização.</p>
<p>Para identificar o usuário, o autenticador usa o <code>id_token</code> (e não <code>access_token</code>) do <em>bearer token</em> da resposta de autorização do OAuth2 <a href=https://openid.net/specs/openid-connect-core-1_0.html#TokenResponse>token response</a>. Veja <a href=#adicionando-um-bearer-token-em-uma-requisi%C3%A7%C3%A3o>acima</a> como incluir um <em>token</em> em uma requisição.</p>
<figure>
<div class=mermaid>
sequenceDiagram
participant usuário as Usuário
participant IDP as Provedor<br> de Identidade
participant kube as Kubectl
participant API as API Server
usuário ->> IDP: 1. Realizar Login no IdP
activate IDP
IDP -->> usuário: 2. Fornece access_token,<br>id_token, e refresh_token
deactivate IDP
activate usuário
usuário ->> kube: 3. Entrar Kubectl<br> com --token sendo id_token<br>ou adiciona tokens no arquivo .kube/config
deactivate usuário
activate kube
kube ->> API: 4. Emite requisição incluindo o cabeçalho HTTP Authorization: Bearer...
deactivate kube
activate API
API ->> API: 5. O token do tipo JWT possui assinatura válida ?
API ->> API: 6. O token está expirado ? (iat+exp)
API ->> API: 7. Usuário autorizado ?
API -->> kube: 8. Autorizado: Realiza<br>ação e retorna resultado
deactivate API
activate kube
kube --x usuário: 9. Retorna resultado
deactivate kube
</div>
</figure>
<noscript>
<div class="alert alert-secondary callout" role=alert>
<em class=javascript-required>JavaScript must be <a href=https://www.enable-javascript.com/>enabled</a> to view this content</em>
</div>
</noscript>
<ol>
<li>Login no seu provedor de identidade.</li>
<li>Seu provedor de identidade ira fornecer um <code>access_token</code>, <code>id_token</code> e um <code>refresh_token</code>.</li>
<li>Quando utilizando <code>kubectl</code>, utilize do seu <code>id_token</code> com a opção <code>--token</code> ou adicione o token diretamente no seu arquivo de configuração <code>kubeconfig</code>.</li>
<li><code>kubectl</code> envia o seu <code>id_token</code> em um cabeçalho HTTP chamado <em>Authorization</em> para o servidor de API.</li>
<li>O servidor de API irá garantir que a assinatura do token JWT é válida, verificando-o em relação ao certificado mencionado na configuração.</li>
<li>Verificação para garantir que o<code>id_token</code> não esteja expirado.</li>
<li>Garantir que o usuário é autorizado.</li>
<li>Uma vez autorizado o servidor de API retorna a resposta para o <code>kubectl</code>.</li>
<li><code>kubectl</code> fornece retorno ao usuário.</li>
</ol>
<p>Uma vez que todos os dados necessários para determinar sua identidade encontram-se no <code>id_token</code>, Kubernetes não precisa realizar outra chamada para o provedor de identidade. Em um modelo onde cada requisição não possui estado, isso fornece uma solução escalável para autenticação. Isso, porem, apresenta alguns desafios:</p>
<ol>
<li>Kubernetes não possui uma "interface web" para disparar o processo de autenticação. Não há browser ou interface para coletar credenciais que são necessárias para autenticar-se primeiro no seu provedor de identidade.</li>
<li>O <code>id_token</code> não pode ser revogado, funcionando como um certificado, portanto deve possuir curta validade (somente alguns minutos) o que pode tornar a experiência um pouco desconfortável, fazendo com que se requisite um novo <em>token</em> toda vez em um curto intervalo (poucos minutos de validade do <em>token</em>)</li>
<li>Para autenticar-se ao dashboard Kubernetes, você deve executar o comando <code>kubectl proxy</code> ou um proxy reverso que consiga injetar o <code>id_token</code>.</li>
</ol>
<h4 id=configurando-o-servidor-de-api>Configurando o Servidor de API</h4>
<p>Para habilitar o plugin de autorização, configure as seguintes opções no servidor de API:</p>
<table>
<thead>
<tr>
<th>Parâmetro</th>
<th>Descrição</th>
<th>Exemplo</th>
<th>Obrigatório</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>--oidc-issuer-url</code></td>
<td>URL do provedor que permite ao servidor de API descobrir chaves públicas de assinatura. Somente URLs que usam o esquema <code>https://</code> são aceitas. Isto normalmente é o endereço de descoberta do provedor sem o caminho, por exemplo "https://accounts.google.com" ou "https://login.salesforce.com". Esta URL deve apontar para o nível abaixo do caminho .well-known/openid-configuration</td>
<td>Se o valor da URL de descoberta é <code>https://accounts.google.com/.well-known/openid-configuration</code>, entao o valor deve ser <code>https://accounts.google.com</code></td>
<td>Sim</td>
</tr>
<tr>
<td><code>--oidc-client-id</code></td>
<td>Identificador do cliente para o qual todos os tokens são gerados.</td>
<td>kubernetes</td>
<td>Sim</td>
</tr>
<tr>
<td><code>--oidc-username-claim</code></td>
<td>Atributo do JWT a ser usado como nome de usuário. Por padrão o valor <code>sub</code>, o qual é esperado que seja um identificador único do usuário final. Administradores podem escolher outro atributo, como <code>email</code> ou <code>name</code>, dependendo de seu provedor de identidade. No entanto, outros atributos além de <code>email</code> serão prefixados com a URL do emissor issuer URL para prevenir conflitos de nome com outros plugins.</td>
<td>sub</td>
<td>Não</td>
</tr>
<tr>
<td><code>--oidc-username-prefix</code></td>
<td>Prefixos adicionados ao atributo de nome de usuário para prevenir conflitos de nomes existentes (como por exemplo usuários <code>system:</code>). Por exemplo, o valor <code>oidc:</code> irá criar usuários como <code>oidc:jane.doe</code>. Se esta opção não for fornecida <code>--oidc-username-claim</code> e um valor diferente de <code>email</code> irá conter um prefixo padrão com o valor de <code>( Issuer URL )#</code> onde <code>( Issuer URL )</code> era o valor da opção <code>--oidc-issuer-url</code>. O valor <code>-</code> pode ser utilizado para desabilitar todos os prefixos.</td>
<td><code>oidc:</code></td>
<td>Não</td>
</tr>
<tr>
<td><code>--oidc-groups-claim</code></td>
<td>Atributo do JWT a ser utilizado para mapear os grupos dos usuários. Se o atributo está presente, ele deve ser do tipo vetor de Strings.</td>
<td>groups</td>
<td>Não</td>
</tr>
<tr>
<td><code>--oidc-groups-prefix</code></td>
<td>Prefixo adicionados ao atributo de grupo para prevenir conflitos de nomes existentes (como por exemplo <code>system:</code> grupos). Por exemplo, o valor <code>oidc:</code> irá criar nomes de grupos como <code>oidc:engineering</code> e <code>oidc:infra</code>.</td>
<td><code>oidc:</code></td>
<td>Não</td>
</tr>
<tr>
<td><code>--oidc-required-claim</code></td>
<td>Um par de chave=valor que descreve atributos obrigatórios no <em>ID Token</em>. Se configurado, a presença do atributo é verificado dentro do <em>ID Token</em> com um valor relacionado. Repita esta opção para configurar múltiplos atributos obrigatórios.</td>
<td><code>claim=value</code></td>
<td>Não</td>
</tr>
<tr>
<td><code>--oidc-ca-file</code></td>
<td>O caminho para o arquivo de certificado da autoridade de certificados (CA) que assinou o certificado do provedor de identidades.</td>
<td><code>/etc/kubernetes/ssl/kc-ca.pem</code></td>
<td>Não</td>
</tr>
</tbody>
</table>
<p>É importante ressaltar que o servidor de API não é um cliente Oauth2, ao contrário, ele só pode ser configurado para confiar em um emissor. Isso permite o uso de emissores públicos, como Google, sem confiar em credenciais emitidas por terceiros. Administradores que desejam utilizar-se de múltiplos clientes OAuth2 devem explorar provedores os quais suportam atributos <code>azp</code> (parte autorizada), que é um mecanismo para permitir um cliente a emitir tokens em nome de outro.</p>
<p>Kubernetes não oferece um provedor de identidade OpenID Connect. Pode-se utilizar provedores públicos existentes como Google ou <a href=https://connect2id.com/products/nimbus-oauth-openid-connect-sdk/openid-connect-providers>outros</a>. Ou, pode-se rodar o próprio provedor de identidade no cluster, como <a href=https://dexidp.io/>dex</a>,
<a href=https://github.com/keycloak/keycloak>Keycloak</a>,
CloudFoundry <a href=https://github.com/cloudfoundry/uaa>UAA</a>, ou
Tremolo Security's <a href=https://github.com/tremolosecurity/openunison>OpenUnison</a>.</p>
<p>Para um provedor de identidades funcionar no Kubernetes, ele deve:</p>
<ol>
<li>Suportar o framework <a href=https://openid.net/specs/openid-connect-discovery-1_0.html>OpenID connect discovery</a>; Nem todos suportam.</li>
<li>Executar TLS com cifras criptográficas não obsoletos.</li>
<li>Possuir certificados assinados por uma Autoridade certificadora (mesmo que o CA não seja comercial ou seja auto-assinado)</li>
</ol>
<p>Uma nota sobre o requisito #3 acima. Se você instalar o seu próprio provedor de identidades (ao invés de utilizar um provedor como Google ou Microsoft) você DEVE ter o certificado web do seu provedor de identidades assinado por um certificado contendo a opção <code>CA</code> configurada para <code>TRUE</code>, mesmo que seja um certificado auto assinado. Isso deve-se a implementação do cliente TLS em Golang que é bastante restrito quanto aos padrões em torno da validação de certificados. Se você não possui um CA em fácil alcance, você pode usar <a href=https://github.com/dexidp/dex/blob/master/examples/k8s/gencert.sh>este script</a> criado pelo time Dex para criar um simples CA, um par de chaves e certificado assinados.
Ou você pode usar <a href=https://raw.githubusercontent.com/TremoloSecurity/openunison-qs-kubernetes/master/src/main/bash/makessl.sh>este script similar</a> o qual gera certificados SHA256 com uma vida mais longa e tamanho maior de chave.</p>
<p>Instruções de configuração para sistemas específicos podem ser encontrados em:</p>
<ul>
<li><a href=https://docs.cloudfoundry.org/concepts/architecture/uaa.html>UAA</a></li>
<li><a href=https://dexidp.io/docs/kubernetes/>Dex</a></li>
<li><a href=https://www.tremolosecurity.com/orchestra-k8s/>OpenUnison</a></li>
</ul>
<h4 id=utilizando-kubectl>Utilizando kubectl</h4>
<h5 id=opção-1-autenticador-oidc>Opção 1 - Autenticador OIDC</h5>
<p>A primeira opção é utilizar-se do autenticador <code>oidc</code> do kubectl, o qual define o valor do <code>id_token</code> como um <em>bearer token</em> para todas as requisições e irá atualizar o token quando o mesmo expirar. Após você efetuar o login no seu provedor, utilize o kubectl para adicionar os seus <code>id_token</code>, <code>refresh_token</code>, <code>client_id</code>, e <code>client_secret</code> para configurar o plugin.</p>
<p>Provedores os quais não retornem um <code>id_token</code> como parte da sua resposta de <em>refresh token</em> não são suportados por este plugin e devem utilizar a opção 2 abaixo.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl config set-credentials USER_NAME <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --auth-provider<span style=color:#666>=</span>oidc <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --auth-provider-arg<span style=color:#666>=</span>idp-issuer-url<span style=color:#666>=(</span> issuer url <span style=color:#666>)</span> <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --auth-provider-arg<span style=color:#666>=</span>client-id<span style=color:#666>=(</span> your client id <span style=color:#666>)</span> <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --auth-provider-arg<span style=color:#666>=</span>client-secret<span style=color:#666>=(</span> your client secret <span style=color:#666>)</span> <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --auth-provider-arg<span style=color:#666>=</span>refresh-token<span style=color:#666>=(</span> your refresh token <span style=color:#666>)</span> <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --auth-provider-arg<span style=color:#666>=</span>idp-certificate-authority<span style=color:#666>=(</span> path to your ca certificate <span style=color:#666>)</span> <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --auth-provider-arg<span style=color:#666>=</span>id-token<span style=color:#666>=(</span> your id_token <span style=color:#666>)</span>
</code></pre></div><p>Um exemplo, executando o comando abaixo após autenticar-se no seu provedor de identidades:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl config set-credentials mmosley  <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>       --auth-provider<span style=color:#666>=</span>oidc  <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>       --auth-provider-arg<span style=color:#666>=</span>idp-issuer-url<span style=color:#666>=</span>https://oidcidp.tremolo.lan:8443/auth/idp/OidcIdP  <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>       --auth-provider-arg<span style=color:#666>=</span>client-id<span style=color:#666>=</span>kubernetes  <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>       --auth-provider-arg<span style=color:#666>=</span>client-secret<span style=color:#666>=</span>1db158f6-177d-4d9c-8a8b-d36869918ec5  <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>       --auth-provider-arg<span style=color:#666>=</span>refresh-token<span style=color:#666>=</span>q1bKLFOyUiosTfawzA93TzZIDzH2TNa2SMm0zEiPKTUwME6BkEo6Sql5yUWVBSWpKUGphaWpxSVAfekBOZbBhaEW+VlFUeVRGcluyVF5JT4+haZmPsluFoFu5XkpXk5BXqHega4GAXlF+ma+vmYpFcHe5eZR+slBFpZKtQA<span style=color:#666>=</span> <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>       --auth-provider-arg<span style=color:#666>=</span>idp-certificate-authority<span style=color:#666>=</span>/root/ca.pem <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>       --auth-provider-arg<span style=color:#666>=</span>id-token<span style=color:#666>=</span>eyJraWQiOiJDTj1vaWRjaWRwLnRyZW1vbG8ubGFuLCBPVT1EZW1vLCBPPVRybWVvbG8gU2VjdXJpdHksIEw9QXJsaW5ndG9uLCBTVD1WaXJnaW5pYSwgQz1VUy1DTj1rdWJlLWNhLTEyMDIxNDc5MjEwMzYwNzMyMTUyIiwiYWxnIjoiUlMyNTYifQ.eyJpc3MiOiJodHRwczovL29pZGNpZHAudHJlbW9sby5sYW46ODQ0My9hdXRoL2lkcC9PaWRjSWRQIiwiYXVkIjoia3ViZXJuZXRlcyIsImV4cCI6MTQ4MzU0OTUxMSwianRpIjoiMm96US15TXdFcHV4WDlHZUhQdy1hZyIsImlhdCI6MTQ4MzU0OTQ1MSwibmJmIjoxNDgzNTQ5MzMxLCJzdWIiOiI0YWViMzdiYS1iNjQ1LTQ4ZmQtYWIzMC0xYTAxZWU0MWUyMTgifQ.w6p4J_6qQ1HzTG9nrEOrubxIMb9K5hzcMPxc9IxPx2K4xO9l-oFiUw93daH3m5pluP6K7eOE6txBuRVfEcpJSwlelsOsW8gb8VJcnzMS9EnZpeA0tW_p-mnkFc3VcfyXuhe5R3G7aa5d8uHv70yJ9Y3-UhjiN9EhpMdfPAoEB9fYKKkJRzF7utTTIPGrSaSU6d2pcpfYKaxIwePzEkT4DfcQthoZdy9ucNvvLoi1DIC-UocFD8HLs8LYKEqSxQvOcvnThbObJ9af71EwmuE21fO5KzMW20KtAeget1gnldOosPtz1G5EwvaQ401-RPQzPGMVBld0_zMCAwZttJ4knw
</code></pre></div><p>O qual irá produzir a configuração abaixo:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>users</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mmosley<span style=color:#bbb>
</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>user</span>:<span style=color:#bbb>
</span><span style=color:#bbb>   </span><span style=color:green;font-weight:700>auth-provider</span>:<span style=color:#bbb>
</span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>config</span>:<span style=color:#bbb>
</span><span style=color:#bbb>       </span><span style=color:green;font-weight:700>client-id</span>:<span style=color:#bbb> </span>kubernetes<span style=color:#bbb>
</span><span style=color:#bbb>       </span><span style=color:green;font-weight:700>client-secret</span>:<span style=color:#bbb> </span>1db158f6-177d-4d9c-8a8b-d36869918ec5<span style=color:#bbb>
</span><span style=color:#bbb>       </span><span style=color:green;font-weight:700>id-token</span>:<span style=color:#bbb> </span>eyJraWQiOiJDTj1vaWRjaWRwLnRyZW1vbG8ubGFuLCBPVT1EZW1vLCBPPVRybWVvbG8gU2VjdXJpdHksIEw9QXJsaW5ndG9uLCBTVD1WaXJnaW5pYSwgQz1VUy1DTj1rdWJlLWNhLTEyMDIxNDc5MjEwMzYwNzMyMTUyIiwiYWxnIjoiUlMyNTYifQ.eyJpc3MiOiJodHRwczovL29pZGNpZHAudHJlbW9sby5sYW46ODQ0My9hdXRoL2lkcC9PaWRjSWRQIiwiYXVkIjoia3ViZXJuZXRlcyIsImV4cCI6MTQ4MzU0OTUxMSwianRpIjoiMm96US15TXdFcHV4WDlHZUhQdy1hZyIsImlhdCI6MTQ4MzU0OTQ1MSwibmJmIjoxNDgzNTQ5MzMxLCJzdWIiOiI0YWViMzdiYS1iNjQ1LTQ4ZmQtYWIzMC0xYTAxZWU0MWUyMTgifQ.w6p4J_6qQ1HzTG9nrEOrubxIMb9K5hzcMPxc9IxPx2K4xO9l-oFiUw93daH3m5pluP6K7eOE6txBuRVfEcpJSwlelsOsW8gb8VJcnzMS9EnZpeA0tW_p-mnkFc3VcfyXuhe5R3G7aa5d8uHv70yJ9Y3-UhjiN9EhpMdfPAoEB9fYKKkJRzF7utTTIPGrSaSU6d2pcpfYKaxIwePzEkT4DfcQthoZdy9ucNvvLoi1DIC-UocFD8HLs8LYKEqSxQvOcvnThbObJ9af71EwmuE21fO5KzMW20KtAeget1gnldOosPtz1G5EwvaQ401-RPQzPGMVBld0_zMCAwZttJ4knw<span style=color:#bbb>
</span><span style=color:#bbb>       </span><span style=color:green;font-weight:700>idp-certificate-authority</span>:<span style=color:#bbb> </span>/root/ca.pem<span style=color:#bbb>
</span><span style=color:#bbb>       </span><span style=color:green;font-weight:700>idp-issuer-url</span>:<span style=color:#bbb> </span>https://oidcidp.tremolo.lan:8443/auth/idp/OidcIdP<span style=color:#bbb>
</span><span style=color:#bbb>       </span><span style=color:green;font-weight:700>refresh-token</span>:<span style=color:#bbb> </span>q1bKLFOyUiosTfawzA93TzZIDzH2TNa2SMm0zEiPKTUwME6BkEo6Sql5yUWVBSWpKUGphaWpxSVAfekBOZbBhaEW+VlFUeVRGcluyVF5JT4+haZmPsluFoFu5XkpXk5BXq<span style=color:#bbb>
</span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>oidc<span style=color:#bbb>
</span></code></pre></div><p>Uma vez que seu <code>id_token</code> expire, <code>kubectl</code> irá tentar atualizar o seu <code>id_token</code> utilizando-se do seu <code>refresh_token</code> e <code>client_secret</code> armazenando os novos valores para <code>refresh_token</code> e <code>id_token</code> no seu arquivo de configuração <code>.kube/config</code>.</p>
<h5 id=opção-2-utilize-a-opção-token>Opção 2 - Utilize a opção <code>--token</code></h5>
<p>O comando <code>kubectl</code> o permite passar o valor de um token utilizando a opção <code>--token</code>. Copie e cole o valor do seu <code>id_token</code> nesta opção:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl --token<span style=color:#666>=</span>eyJhbGciOiJSUzI1NiJ9.eyJpc3MiOiJodHRwczovL21sYi50cmVtb2xvLmxhbjo4MDQzL2F1dGgvaWRwL29pZGMiLCJhdWQiOiJrdWJlcm5ldGVzIiwiZXhwIjoxNDc0NTk2NjY5LCJqdGkiOiI2RDUzNXoxUEpFNjJOR3QxaWVyYm9RIiwiaWF0IjoxNDc0NTk2MzY5LCJuYmYiOjE0NzQ1OTYyNDksInN1YiI6Im13aW5kdSIsInVzZXJfcm9sZSI6WyJ1c2VycyIsIm5ldy1uYW1lc3BhY2Utdmlld2VyIl0sImVtYWlsIjoibXdpbmR1QG5vbW9yZWplZGkuY29tIn0.f2As579n9VNoaKzoF-dOQGmXkFKf1FMyNV0-va_B63jn-_n9LGSCca_6IVMP8pO-Zb4KvRqGyTP0r3HkHxYy5c81AnIh8ijarruczl-TK_yF5akjSTHFZD-0gRzlevBDiH8Q79NAr-ky0P4iIXS8lY9Vnjch5MF74Zx0c3alKJHJUnnpjIACByfF2SCaYzbWFMUNat-K1PaUk5-ujMBG7yYnr95xD-63n8CO8teGUAAEMx6zRjzfhnhbzX-ajwZLGwGUBT4WqjMs70-6a7_8gZmLZb2az1cZynkFRj2BaCkVT3A2RrjeEwZEtGXlMqKJ1_I2ulrOVsYx01_yD35-rw get nodes
</code></pre></div><h3 id=token-de-autenticação-via-webhook>Token de autenticação via Webhook</h3>
<p>Webhook de autenticação é usado para verificar <em>bearer tokens</em></p>
<ul>
<li><code>--authentication-token-webhook-config-file</code> arquivo de configuração descrevendo como acessar o serviço remoto de webhook.</li>
<li><code>--authentication-token-webhook-cache-ttl</code> por quanto tempo guardar em cache decisões de autenticação. Configuração padrão definida para dois minutos.</li>
<li><code>--authentication-token-webhook-version</code> determina quando usar o apiVersion <code>authentication.k8s.io/v1beta1</code> ou <code>authentication.k8s.io/v1</code> para objetos <code>TokenReview</code> quando enviar/receber informações do webhook. Valor padrão <code>v1beta1</code>.</li>
</ul>
<p>O arquivo de configuração usa o formato de arquivo do <a href=/docs/concepts/configuration/organize-cluster-access-kubeconfig/>kubeconfig</a>. Dentro do arquivo, <code>clusters</code> refere-se ao serviço remoto e <code>users</code> refere-se ao servidor de API do webhook. Um exemplo seria:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#080;font-style:italic># versão da API do Kubernetes</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># tipo do objeto da API</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Config<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># clusters refere-se ao serviço remoto</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>clusters</span>:<span style=color:#bbb>
</span><span style=color:#bbb> </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>name-of-remote-authn-service<span style=color:#bbb>
</span><span style=color:#bbb>   </span><span style=color:green;font-weight:700>cluster</span>:<span style=color:#bbb>
</span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>certificate-authority</span>:<span style=color:#bbb> </span>/path/to/ca.pem        <span style=color:#bbb> </span><span style=color:#080;font-style:italic># CA para verificar o serviço remoto</span><span style=color:#bbb>
</span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>server</span>:<span style=color:#bbb> </span>https://authn.example.com/authenticate<span style=color:#bbb> </span><span style=color:#080;font-style:italic># URL para procurar o serviço remoto. Deve utilizar &#39;https&#39;.</span><span style=color:#bbb>
</span><span style=color:#bbb> 
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># users refere-se a configuração do webhook do servidor de  API</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>users</span>:<span style=color:#bbb>
</span><span style=color:#bbb> </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>name-of-api-server<span style=color:#bbb>
</span><span style=color:#bbb>   </span><span style=color:green;font-weight:700>user</span>:<span style=color:#bbb>
</span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>client-certificate</span>:<span style=color:#bbb> </span>/path/to/cert.pem<span style=color:#bbb> </span><span style=color:#080;font-style:italic># certificado para ser utilizado pelo plugin de webhook</span><span style=color:#bbb>
</span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>client-key</span>:<span style=color:#bbb> </span>/path/to/key.pem         <span style=color:#bbb> </span><span style=color:#080;font-style:italic># chave referente ao certificado</span><span style=color:#bbb>
</span><span style=color:#bbb> 
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># arquivos kubeconfig requerem um contexto. Especifique um para o servidor de API.</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>current-context</span>:<span style=color:#bbb> </span>webhook<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>contexts</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>context</span>:<span style=color:#bbb>
</span><span style=color:#bbb>   </span><span style=color:green;font-weight:700>cluster</span>:<span style=color:#bbb> </span>name-of-remote-authn-service<span style=color:#bbb>
</span><span style=color:#bbb>   </span><span style=color:green;font-weight:700>user</span>:<span style=color:#bbb> </span>name-of-api-server<span style=color:#bbb>
</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>webhook<span style=color:#bbb>
</span></code></pre></div><p>Quando um cliente tenta autenticar-se com o servidor de API utilizando um <em>bearer token</em> como discutido <a href=#adicionando-um-bearer-token-em-uma-requisi%C3%A7%C3%A3o>acima</a>, o webhook de autenticação envia um objeto JSON serializado do tipo <code>TokenReview</code> contendo o valor do <em>token</em> para o serviço remoto.</p>
<p>Note que objetos de API do tipo <em>webhook</em> estão sujeitos às mesmas <a href=/docs/concepts/overview/kubernetes-api/>regras de compatibilidade de versão</a> como outros objetos de API Kubernetes.
Implementadores devem verificar o campo de versão da API (<code>apiVersion</code>) da requisição para garantir a correta deserialização e <strong>devem</strong> responder com um objeto do tipo <code>TokenReview</code> da mesma versão da requisição.</p>
<ul class="nav nav-tabs" id=tokenreview-request role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tokenreview-request-0 role=tab aria-controls=tokenreview-request-0 aria-selected=true>authentication.k8s.io/v1</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tokenreview-request-1 role=tab aria-controls=tokenreview-request-1>authentication.k8s.io/v1beta1</a></li></ul>
<div class=tab-content id=tokenreview-request><div id=tokenreview-request-0 class="tab-pane show active" role=tabpanel aria-labelledby=tokenreview-request-0>
<p><div class="alert alert-info note callout" role=alert>
<strong>Nota:</strong> <p>O servidor de API Kubernetes envia por padrão revisão de tokens para a API <code>authentication.k8s.io/v1beta1</code> para fins de compatibilidade com versões anteriores.</p>
<p>Para optar receber revisão de tokens de versão <code>authentication.k8s.io/v1</code>, o servidor de API deve ser inicializado com a opção <code>--authentication-token-webhook-version=v1</code>.</p>
</div>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>{<span style=color:#bbb>
</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>&#34;apiVersion&#34;: </span><span style=color:#b44>&#34;authentication.k8s.io/v1&#34;</span>,<span style=color:#bbb>
</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>&#34;kind&#34;: </span><span style=color:#b44>&#34;TokenReview&#34;</span>,<span style=color:#bbb>
</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>&#34;spec&#34;: </span>{<span style=color:#bbb>
</span><span style=color:#bbb>   </span><span style=color:#080;font-style:italic># Bearer token opaco enviado para o servidor de API</span><span style=color:#bbb>
</span><span style=color:#bbb>   </span><span style=color:green;font-weight:700>&#34;token&#34;: </span><span style=color:#b44>&#34;014fbff9a07c...&#34;</span>,<span style=color:#bbb>
</span><span style=color:#bbb> 
</span><span style=color:#bbb>   </span><span style=color:#080;font-style:italic># Lista opcional de identificadores de audiência para o servidor ao qual o token foi apresentado</span><span style=color:#bbb>
</span><span style=color:#bbb>   </span><span style=color:#080;font-style:italic># Autenticadores de token  sensíveis a audiência (por exemplo, autenticadores de token OIDC)</span><span style=color:#bbb>
</span><span style=color:#bbb>   </span><span style=color:#080;font-style:italic># deve-se verificar que o token foi direcionado a pelo menos um membro da lista de audiência</span><span style=color:#bbb>
</span><span style=color:#bbb>   </span><span style=color:#080;font-style:italic># e retornar a interseção desta lista a audiência válida para o token no estado da resposta</span><span style=color:#bbb>
</span><span style=color:#bbb>   </span><span style=color:#080;font-style:italic># Isto garante com que o token é válido para autenticar-se no servidor ao qual foi apresentado</span><span style=color:#bbb>
</span><span style=color:#bbb>   </span><span style=color:#080;font-style:italic># Se nenhuma audiência for especificada, o token deve ser validado para autenticar-se ao servidor de API do Kubernetes</span><span style=color:#bbb>
</span><span style=color:#bbb>   </span><span style=color:green;font-weight:700>&#34;audiences&#34;: </span>[<span style=color:#b44>&#34;https://myserver.example.com&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;https://myserver.internal.example.com&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb> </span>}<span style=color:#bbb>
</span><span style=color:#bbb></span>}<span style=color:#bbb>
</span></code></pre></div></div>
<div id=tokenreview-request-1 class=tab-pane role=tabpanel aria-labelledby=tokenreview-request-1>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>{<span style=color:#bbb>
</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>&#34;apiVersion&#34;: </span><span style=color:#b44>&#34;authentication.k8s.io/v1beta1&#34;</span>,<span style=color:#bbb>
</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>&#34;kind&#34;: </span><span style=color:#b44>&#34;TokenReview&#34;</span>,<span style=color:#bbb>
</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>&#34;spec&#34;: </span>{<span style=color:#bbb>
</span><span style=color:#bbb>   </span><span style=color:#080;font-style:italic># Bearer token opaco enviado para o servidor de API</span><span style=color:#bbb>
</span><span style=color:#bbb>   </span><span style=color:green;font-weight:700>&#34;token&#34;: </span><span style=color:#b44>&#34;014fbff9a07c...&#34;</span>,<span style=color:#bbb>
</span><span style=color:#bbb> 
</span><span style=color:#bbb>   </span><span style=color:#080;font-style:italic># Lista opcional de identificadores de audiência para o servidor ao qual o token foi apresentado</span><span style=color:#bbb>
</span><span style=color:#bbb>   </span><span style=color:#080;font-style:italic># Autenticadores de token  sensíveis a audiência (por exemplo, autenticadores de token OIDC)</span><span style=color:#bbb>
</span><span style=color:#bbb>   </span><span style=color:#080;font-style:italic># deve-se verificar que o token foi direcionado a pelo menos um membro da lista de audiência</span><span style=color:#bbb>
</span><span style=color:#bbb>   </span><span style=color:#080;font-style:italic># e retornar a interseção desta lista a audiência válida para o token no estado da resposta</span><span style=color:#bbb>
</span><span style=color:#bbb>   </span><span style=color:#080;font-style:italic># Isto garante com que o token é válido para autenticar-se no servidor ao qual foi apresentado</span><span style=color:#bbb>
</span><span style=color:#bbb>   </span><span style=color:#080;font-style:italic># Se nenhuma audiência for especificada, o token deve ser validado para autenticar-se ao servidor de API do Kubernetes</span><span style=color:#bbb>
</span><span style=color:#bbb>   </span><span style=color:green;font-weight:700>&#34;audiences&#34;: </span>[<span style=color:#b44>&#34;https://myserver.example.com&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;https://myserver.internal.example.com&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb> </span>}<span style=color:#bbb>
</span><span style=color:#bbb></span>}<span style=color:#bbb>
</span></code></pre></div></div></div>
<p>É esperado que o serviço remoto preencha o campo <code>status</code> da requisição para indicar o sucesso do login.
O campo <code>spec</code> do corpo de resposta é ignorado e pode ser omitido.
O serviço remoto deverá retornar uma resposta usando a mesma versão de API do objeto <code>TokenReview</code> que foi recebido.
Uma validação bem sucedida deveria retornar:</p>
<ul class="nav nav-tabs" id=tokenreview-response-success role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tokenreview-response-success-0 role=tab aria-controls=tokenreview-response-success-0 aria-selected=true>authentication.k8s.io/v1</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tokenreview-response-success-1 role=tab aria-controls=tokenreview-response-success-1>authentication.k8s.io/v1beta1</a></li></ul>
<div class=tab-content id=tokenreview-response-success><div id=tokenreview-response-success-0 class="tab-pane show active" role=tabpanel aria-labelledby=tokenreview-response-success-0>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>{<span style=color:#bbb>
</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>&#34;apiVersion&#34;: </span><span style=color:#b44>&#34;authentication.k8s.io/v1&#34;</span>,<span style=color:#bbb>
</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>&#34;kind&#34;: </span><span style=color:#b44>&#34;TokenReview&#34;</span>,<span style=color:#bbb>
</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>&#34;status&#34;: </span>{<span style=color:#bbb>
</span><span style=color:#bbb>   </span><span style=color:green;font-weight:700>&#34;authenticated&#34;: </span><span style=color:#a2f;font-weight:700>true</span>,<span style=color:#bbb>
</span><span style=color:#bbb>   </span><span style=color:green;font-weight:700>&#34;user&#34;: </span>{<span style=color:#bbb>
</span><span style=color:#bbb>     </span><span style=color:#080;font-style:italic># Obrigatório</span><span style=color:#bbb>
</span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>&#34;username&#34;: </span><span style=color:#b44>&#34;janedoe@example.com&#34;</span>,<span style=color:#bbb>
</span><span style=color:#bbb>     </span><span style=color:#080;font-style:italic># Opcional</span><span style=color:#bbb>
</span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>&#34;uid&#34;: </span><span style=color:#b44>&#34;42&#34;</span>,<span style=color:#bbb>
</span><span style=color:#bbb>     </span><span style=color:#080;font-style:italic># Opcional: lista de grupos associados</span><span style=color:#bbb>
</span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>&#34;groups&#34;: </span>[<span style=color:#b44>&#34;developers&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;qa&#34;</span>],<span style=color:#bbb>
</span><span style=color:#bbb>     </span><span style=color:#080;font-style:italic># Opcional: informação adicional  provida pelo autenticador.</span><span style=color:#bbb>
</span><span style=color:#bbb>     </span><span style=color:#080;font-style:italic># Isto não deve conter dados confidenciais, pois pode ser registrados em logs ou em objetos de API e estarão disponíveis para webhooks de admissão</span><span style=color:#bbb>
</span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>&#34;extra&#34;: </span>{<span style=color:#bbb>
</span><span style=color:#bbb>       </span><span style=color:green;font-weight:700>&#34;extrafield1&#34;: </span>[<span style=color:#bbb>
</span><span style=color:#bbb>         </span><span style=color:#b44>&#34;extravalue1&#34;</span>,<span style=color:#bbb>
</span><span style=color:#bbb>         </span><span style=color:#b44>&#34;extravalue2&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>       </span>]<span style=color:#bbb>
</span><span style=color:#bbb>     </span>}<span style=color:#bbb>
</span><span style=color:#bbb>   </span>},<span style=color:#bbb>
</span><span style=color:#bbb>   </span><span style=color:#080;font-style:italic># Lista opcional de Autenticadores de token  sensíveis a audiência que podem ser retornados,</span><span style=color:#bbb>
</span><span style=color:#bbb>   </span><span style=color:#080;font-style:italic># contendo as audiências da lista `spec.audiences` válido para o token apresentado.</span><span style=color:#bbb>
</span><span style=color:#bbb>   </span><span style=color:#080;font-style:italic># Se este campo for omitido, o token é considerado válido para autenticar-se no servidor de API Kubernetes</span><span style=color:#bbb>
</span><span style=color:#bbb>   </span><span style=color:green;font-weight:700>&#34;audiences&#34;: </span>[<span style=color:#b44>&#34;https://myserver.example.com&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb> </span>}<span style=color:#bbb>
</span><span style=color:#bbb></span>}<span style=color:#bbb>
</span></code></pre></div></div>
<div id=tokenreview-response-success-1 class=tab-pane role=tabpanel aria-labelledby=tokenreview-response-success-1>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>{<span style=color:#bbb>
</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>&#34;apiVersion&#34;: </span><span style=color:#b44>&#34;authentication.k8s.io/v1beta1&#34;</span>,<span style=color:#bbb>
</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>&#34;kind&#34;: </span><span style=color:#b44>&#34;TokenReview&#34;</span>,<span style=color:#bbb>
</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>&#34;status&#34;: </span>{<span style=color:#bbb>
</span><span style=color:#bbb>   </span><span style=color:green;font-weight:700>&#34;authenticated&#34;: </span><span style=color:#a2f;font-weight:700>true</span>,<span style=color:#bbb>
</span><span style=color:#bbb>   </span><span style=color:green;font-weight:700>&#34;user&#34;: </span>{<span style=color:#bbb>
</span><span style=color:#bbb>     </span><span style=color:#080;font-style:italic># Obrigatório</span><span style=color:#bbb>
</span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>&#34;username&#34;: </span><span style=color:#b44>&#34;janedoe@example.com&#34;</span>,<span style=color:#bbb>
</span><span style=color:#bbb>     </span><span style=color:#080;font-style:italic># Opcional</span><span style=color:#bbb>
</span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>&#34;uid&#34;: </span><span style=color:#b44>&#34;42&#34;</span>,<span style=color:#bbb>
</span><span style=color:#bbb>     </span><span style=color:#080;font-style:italic># Opcional: lista de grupos associados</span><span style=color:#bbb>
</span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>&#34;groups&#34;: </span>[<span style=color:#b44>&#34;developers&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;qa&#34;</span>],<span style=color:#bbb>
</span><span style=color:#bbb>     </span><span style=color:#080;font-style:italic># Opcional: informação adicional  provida pelo autenticador.</span><span style=color:#bbb>
</span><span style=color:#bbb>     </span><span style=color:#080;font-style:italic># Isto não deve conter dados confidenciais, pois pode ser registrados em logs ou em objetos de API e estarão disponíveis para webhooks de admissão</span><span style=color:#bbb>
</span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>&#34;extra&#34;: </span>{<span style=color:#bbb>
</span><span style=color:#bbb>       </span><span style=color:green;font-weight:700>&#34;extrafield1&#34;: </span>[<span style=color:#bbb>
</span><span style=color:#bbb>         </span><span style=color:#b44>&#34;extravalue1&#34;</span>,<span style=color:#bbb>
</span><span style=color:#bbb>         </span><span style=color:#b44>&#34;extravalue2&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>       </span>]<span style=color:#bbb>
</span><span style=color:#bbb>     </span>}<span style=color:#bbb>
</span><span style=color:#bbb>   </span>},<span style=color:#bbb>
</span><span style=color:#bbb>   </span><span style=color:#080;font-style:italic># Lista opcional de Autenticadores de token  sensíveis a audiência que podem ser retornados,</span><span style=color:#bbb>
</span><span style=color:#bbb>   </span><span style=color:#080;font-style:italic># contendo as audiências da lista `spec.audiences` válido para o token apresentado.</span><span style=color:#bbb>
</span><span style=color:#bbb>   </span><span style=color:#080;font-style:italic># Se este campo for omitido, o token é considerado válido para autenticar-se no servidor de API Kubernetes</span><span style=color:#bbb>
</span><span style=color:#bbb>   </span><span style=color:green;font-weight:700>&#34;audiences&#34;: </span>[<span style=color:#b44>&#34;https://myserver.example.com&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb> </span>}<span style=color:#bbb>
</span><span style=color:#bbb></span>}<span style=color:#bbb>
</span></code></pre></div></div></div>
<p>Uma requisição mal sucedida retornaria:</p>
<ul class="nav nav-tabs" id=tokenreview-response-error role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tokenreview-response-error-0 role=tab aria-controls=tokenreview-response-error-0 aria-selected=true>authentication.k8s.io/v1</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tokenreview-response-error-1 role=tab aria-controls=tokenreview-response-error-1>authentication.k8s.io/v1beta1</a></li></ul>
<div class=tab-content id=tokenreview-response-error><div id=tokenreview-response-error-0 class="tab-pane show active" role=tabpanel aria-labelledby=tokenreview-response-error-0>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>{<span style=color:#bbb>
</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>&#34;apiVersion&#34;: </span><span style=color:#b44>&#34;authentication.k8s.io/v1&#34;</span>,<span style=color:#bbb>
</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>&#34;kind&#34;: </span><span style=color:#b44>&#34;TokenReview&#34;</span>,<span style=color:#bbb>
</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>&#34;status&#34;: </span>{<span style=color:#bbb>
</span><span style=color:#bbb>   </span><span style=color:green;font-weight:700>&#34;authenticated&#34;: </span><span style=color:#a2f;font-weight:700>false</span>,<span style=color:#bbb>
</span><span style=color:#bbb>   </span><span style=color:#080;font-style:italic># Opcionalmente inclui detalhes sobre o porque a autenticação falhou</span><span style=color:#bbb>
</span><span style=color:#bbb>   </span><span style=color:#080;font-style:italic># Se nenhum erro é fornecido, a API irá retornar uma mensagem genérica de &#34;Não autorizado&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>   </span><span style=color:#080;font-style:italic># O campo de erro é ignorado quando authenticated=true.</span><span style=color:#bbb>
</span><span style=color:#bbb>   </span><span style=color:green;font-weight:700>&#34;error&#34;: </span><span style=color:#b44>&#34;Credenciais expiradas&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb> </span>}<span style=color:#bbb>
</span><span style=color:#bbb></span>}<span style=color:#bbb>
</span></code></pre></div></div>
<div id=tokenreview-response-error-1 class=tab-pane role=tabpanel aria-labelledby=tokenreview-response-error-1>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>{<span style=color:#bbb>
</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>&#34;apiVersion&#34;: </span><span style=color:#b44>&#34;authentication.k8s.io/v1beta1&#34;</span>,<span style=color:#bbb>
</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>&#34;kind&#34;: </span><span style=color:#b44>&#34;TokenReview&#34;</span>,<span style=color:#bbb>
</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>&#34;status&#34;: </span>{<span style=color:#bbb>
</span><span style=color:#bbb>   </span><span style=color:green;font-weight:700>&#34;authenticated&#34;: </span><span style=color:#a2f;font-weight:700>false</span>,<span style=color:#bbb>
</span><span style=color:#bbb>   </span><span style=color:#080;font-style:italic># Opcionalmente inclui detalhes sobre o porque a autenticação falhou</span><span style=color:#bbb>
</span><span style=color:#bbb>   </span><span style=color:#080;font-style:italic># Se nenhum erro é fornecido, a API irá retornar uma mensagem genérica de &#34;Não autorizado&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>   </span><span style=color:#080;font-style:italic># O campo de erro é ignorado quando authenticated=true.</span><span style=color:#bbb>
</span><span style=color:#bbb>   </span><span style=color:green;font-weight:700>&#34;error&#34;: </span><span style=color:#b44>&#34;Credenciais expiradas&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb> </span>}<span style=color:#bbb>
</span><span style=color:#bbb></span>}<span style=color:#bbb>
</span></code></pre></div></div></div>
<h3 id=autenticando-com-proxy>Autenticando com Proxy</h3>
<p>O servidor de API pode ser configurado para identificar usuários através de valores de cabeçalho de requisição, como por exemplo <code>X-Remote-User</code>.
Isto é projetado para o uso em combinação com um proxy de autenticação, o qual irá atribuir o valor do cabeçalho da requisição.</p>
<ul>
<li>
<p><code>--requestheader-username-headers</code> Obrigatório, não faz distinção entre caracteres maiúsculos/minúsculos. Nomes de cabeçalhos a serem verificados, em ordem, para a identidade do usuário. O primeiro cabeçalho contendo um valor será usado para o nome do usuário.</p>
</li>
<li>
<p><code>--requestheader-group-headers</code> 1.6+. Opcional, não faz distinção entre caracteres maiúsculos/minúsculos. "X-Remote-Group" é recomendado. Nomes de cabeçalhos a serem verificados, em ordem, para os grupos do usuário. Todos os valores especificados em todos os cabeçalhos serão utilizados como nome dos grupos do usuário.</p>
</li>
<li>
<p><code>--requestheader-extra-headers-prefix</code> 1.6+. Opcional, não faz distinção entre caracteres maiúsculos/minúsculos. "X-Remote-Extra-" é recomendado. Prefixos de cabeçalhos para serem utilizados para definir informações extras sobre o usuário (normalmente utilizado por um plugin de autorização). Todos os cabeçalhos que começam com qualquer um dos prefixos especificados têm o prefixo removido. O restante do nome do cabeçalho é transformado em letra minúscula, decodificado <a href=https://tools.ietf.org/html/rfc3986#section-2.1>percent-decoded</a> e torna-se uma chave extra, e o valor do cabeçalho torna-se um valor extra.</p>
</li>
</ul>
<div class="alert alert-info note callout" role=alert>
<strong>Nota:</strong> Antes da versão 1.11.3 (e 1.10.7, 1.9.11), a chave extra só poderia conter caracteres os quais fossem <a href=https://tools.ietf.org/html/rfc7230#section-3.2.6>legais em rótulos de cabeçalhos HTTP</a>.
</div>
<p>Por exemplo, com esta configuração:</p>
<pre><code>--requestheader-username-headers=X-Remote-User
--requestheader-group-headers=X-Remote-Group
--requestheader-extra-headers-prefix=X-Remote-Extra-
</code></pre><p>e esta requisição:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-http data-lang=http><span style=color:#00a000>GET</span> <span style=color:#00f;font-weight:700>/</span> <span style=color:#a2f;font-weight:700>HTTP</span><span style=color:#666>/</span><span style=color:#666>1.1</span>
X-Remote-User<span style=color:#666>:</span> fido
X-Remote-Group<span style=color:#666>:</span> dogs
X-Remote-Group<span style=color:#666>:</span> dachshunds
X-Remote-Extra-Acme.com%2Fproject<span style=color:#666>:</span> some-project
X-Remote-Extra-Scopes<span style=color:#666>:</span> openid
X-Remote-Extra-Scopes<span style=color:#666>:</span> profile
</code></pre></div><p>resultaria nesta informação de usuário:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>fido<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>groups</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- dogs<span style=color:#bbb>
</span><span style=color:#bbb></span>- dachshunds<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>extra</span>:<span style=color:#bbb>
</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>acme.com/project</span>:<span style=color:#bbb>
</span><span style=color:#bbb> </span>- some-project<span style=color:#bbb>
</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>scopes</span>:<span style=color:#bbb>
</span><span style=color:#bbb> </span>- openid<span style=color:#bbb>
</span><span style=color:#bbb> </span>- profile<span style=color:#bbb>
</span></code></pre></div><p>Para prevenir falsificação de cabeçalhos, o proxy de autenticação deverá apresentar um certificado de cliente válido para o servidor de API para que possa ser validado com a autoridade de certificados (CA) antes que os cabeçalhos de requisições sejam verificados. AVISO: <strong>não</strong> re-utilize uma autoridade de certificados (CA) que esteja sendo utilizado em um contexto diferente ao menos que você entenda os riscos e os mecanismos de proteção da utilização de uma autoridade de certificados.</p>
<ul>
<li>
<p><code>--requestheader-client-ca-file</code> Obrigatório. Pacote de certificados no formato PEM. Um certificado válido deve ser apresentado e validado com a autoridade de certificados no arquivo especificado antes da verificação de cabeçalhos de requisição para os nomes do usuário.</p>
</li>
<li>
<p><code>--requestheader-allowed-names</code> Opcional. Lista de valores de nomes comuns (CNs). Se especificado, um certificado de cliente válido contendo uma lista de nomes comuns denominados deve ser apresentado na verificação de cabeçalhos de requisição para os nomes do usuário. Se vazio, qualquer valor de nomes comuns será permitido.</p>
</li>
</ul>
<h2 id=requisições-anônimas>Requisições anônimas</h2>
<p>Quando habilitado, requisições que não são rejeitadas por outros métodos de autenticação configurados são tratadas como requisições anônimas e são dadas o nome de usuário <code>system:anonymous</code> e filiação ao grupo <code>system:unauthenticated</code>.</p>
<p>Por exemplo, uma requisição especificando um <em>bearer token</em> invalido chega a um servidor com token de autenticação configurado e acesso anônimo habilitado e receberia um erro de acesso não autorizado <code>401 Unauthorized</code>. Já uma requisição não especificando nenhum <em>bearer token</em> seria tratada como uma requisição anônima.</p>
<p>Nas versões 1.5.1-1.5.x, acesso anônimo é desabilitado por padrão e pode ser habilitado passando a opção <code>--anonymous-auth=true</code> durante a inicialização do servidor de API.</p>
<p>Na versão 1.6 e acima, acesso anônimo é habilitado por padrão se um modo de autorização diferente de <code>AlwaysAllow</code> é utilizado e pode ser desabilitado passando a opção <code>--anonymous-auth=false</code> durante a inicialização do servidor de API.
Começando na versão 1.6, os autorizadores <em>ABAC (Controle de Acesso Baseado em Atributos)</em> e <em>RBAC (Controle de Acesso Baseado em Função)</em> requerem autorização explícita do usuário <code>system:anonymous</code> e do grupo <code>system:unauthenticated</code>, portanto, regras de políticas legadas que permitam acesso a usuário <code>*</code> e grupo <code>*</code> nao incluíram usuários anônimos.</p>
<h2 id=personificação-de-usuário>Personificação de usuário</h2>
<p>Um usuário pode agir como outro através de cabeçalhos de personificação. Os mesmos permitem que requisições manualmente sobrescrevam as informações ao quais o usuário irá se autenticar como. Por exemplo, um administrador pode utilizar-se desta funcionalidade para investigar um problema com uma política de autorização e assim, temporariamente, personificar um outro usuário e ver se/como sua requisição está sendo negada.</p>
<p>Requisições de personificação primeiramente são autenticadas como o usuário requerente, então trocando para os detalhes de informação do usuário personificado.</p>
<p>O fluxo é:</p>
<ul>
<li>Um usuário faz uma chamada de API com suas credenciais <em>e</em> cabeçalhos de personificação.</li>
<li>O servidor de API autentica o usuário.</li>
<li>O servidor de API garante que o usuário autenticado possui permissão de personificação.</li>
<li>Detalhes de informação do usuário da requisição tem seus valores substituídos com os detalhes de personificação.</li>
<li>A requisição é avaliada e a autorização é feita sobre os detalhes do usuário personificado.</li>
</ul>
<p>Os seguintes cabeçalhos HTTP podem ser usados para realizar uma requisição de personificação:</p>
<ul>
<li><code>Impersonate-User</code>: O nome do usuário para se executar ações em seu nome.</li>
<li><code>Impersonate-Group</code>: Um nome de grupo para se executar ações em seu nome. Pode ser especificado múltiplas vezes para fornecer múltiplos grupos. Opcional. Requer "Impersonate-User".</li>
<li><code>Impersonate-Extra-( extra name )</code>: Um cabeçalho dinâmico usado para associar campos extras do usuário. Opcional. Requer "Impersonate-User". Para que seja preservado consistentemente, <code>( extra name )</code> deve ser somente minúsculo, e qualquer caracter que não seja <a href=https://tools.ietf.org/html/rfc7230#section-3.2.6>legal em rótulos de cabeçalhos HTTP</a> DEVE ser utf8 e <a href=https://tools.ietf.org/html/rfc3986#section-2.1>codificado</a>.</li>
</ul>
<div class="alert alert-info note callout" role=alert>
<strong>Nota:</strong> Antes da versão 1.11.3 (e 1.10.7, 1.9.11), <code>( extra name )</code> só poderia conter caracteres que fossem <a href=https://tools.ietf.org/html/rfc7230#section-3.2.6>legais em rótulos de cabeçalhos HTTP</a>.
</div>
<p>Um exemplo de conjunto de cabeçalhos HTTP:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-http data-lang=http><span>Impersonate-User: jane.doe@example.com
</span><span>Impersonate-Group: developers
</span><span>Impersonate-Group: admins
</span><span>Impersonate-Extra-dn: cn=jane,ou=engineers,dc=example,dc=com
</span><span>Impersonate-Extra-acme.com%2Fproject: some-project
</span><span>Impersonate-Extra-scopes: view
</span><span>Impersonate-Extra-scopes: development
</span></code></pre></div><p>Quando utilizando-se o <code>kubectl</code> especifique a opção <code>--as</code> para determinar o cabeçalho <code>Impersonate-User</code>, especifique a opção <code>--as-group</code> para determinar o cabeçalho <code>Impersonate-Group</code>.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl drain mynode
</code></pre></div><pre><code class=language-none data-lang=none>Error from server (Forbidden): User &quot;clark&quot; cannot get nodes at the cluster scope. (get nodes mynode)
</code></pre><p>Especificando as opções <code>--as</code> e <code>--as-group</code>:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl drain mynode --as<span style=color:#666>=</span>superman --as-group<span style=color:#666>=</span>system:masters
</code></pre></div><pre><code class=language-none data-lang=none>node/mynode cordoned
node/mynode drained
</code></pre><p>Para personificar um usuário, grupo ou especificar campos extras, o usuário efetuando a personificação deve possuir a permissão de executar o verbo "impersonate" no tipo de atributo sendo personificado ("user", "group", etc.). Para clusters com o plugin de autorização <em>RBAC</em> habilitados, a seguinte ClusterRole abrange as regras necessárias para definir os cabeçalhos de personificação de usuário e grupo:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>impersonator<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;users&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;groups&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;serviceaccounts&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;impersonate&#34;</span>]<span style=color:#bbb>
</span></code></pre></div><p>Campos extras são avaliados como sub-recursos de um recurso denominado "userextras". Para permitir ao usuário que utilize os cabeçalhos de personificação para o campo extra "scopes", o usuário deve receber a seguinte permissão:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>scopes-impersonator<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># Pode definir o cabeçalho &#34;Impersonate-Extra-scopes&#34;.</span><span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;authentication.k8s.io&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;userextras/scopes&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;impersonate&#34;</span>]<span style=color:#bbb>
</span></code></pre></div><p>Os valores dos cabeçalhos de personificação podem também ser restringidos ao limitar o conjunto de nomes de recursos (<code>resourceNames</code>) que um recurso pode ter.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>limited-impersonator<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># Pode personificar o usuário &#34;jane.doe@example.com&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;users&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;impersonate&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>resourceNames</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;jane.doe@example.com&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb> 
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># Pode assumir os grupos &#34;developers&#34; and &#34;admins&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;groups&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;impersonate&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>resourceNames</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;developers&#34;</span>,<span style=color:#b44>&#34;admins&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb> 
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># Pode personificar os campos extras &#34;scopes&#34; com valores &#34;view&#34; e &#34;development&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;authentication.k8s.io&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;userextras/scopes&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;impersonate&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>resourceNames</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;view&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;development&#34;</span>]<span style=color:#bbb>
</span></code></pre></div><h2 id=plugins-de-credenciais-client-go>Plugins de credenciais client-go</h2>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.11 [beta]</code>
</div>
<p>Ferramentas como <code>kubectl</code> e <code>kubelet</code> utilizando-se do <code>k8s.io/client-go</code> são capazes de executar um comando externo para receber credenciais de usuário.</p>
<p>Esta funcionalidade é direcionada à integração do lado cliente, com protocolos de autenticação não suportados nativamente pelo <code>k8s.io/client-go</code> como: LDAP, Kerberos, OAuth2, SAML, etc. O plugin implementa a lógica específica do protocolo e então retorna credenciais opacas para serem utilizadas. Quase todos os casos de usos de plugins de credenciais requerem um componente de lado do servidor com suporte para um <a href=#token-de-autentica%C3%A7%C3%A3o-via-webhook>autenticador de token webhook</a> para interpretar o formato das credenciais produzidas pelo plugin cliente.</p>
<h3 id=exemplo-de-caso-de-uso>Exemplo de caso de uso</h3>
<p>Num caso de uso hipotético, uma organização executaria um serviço externo que efetuaria a troca de credenciais LDAP por tokens assinados para um usuário específico. Este serviço seria também capaz de responder requisições do <a href=#token-de-autentica%C3%A7%C3%A3o-via-webhook>autenticador de token webhook</a> para validar tokens. Usuários seriam obrigados a instalar um plugin de credencial em sua estação de trabalho.</p>
<p>Para autenticar na API:</p>
<ul>
<li>O usuário entra um comando <code>kubectl</code>.</li>
<li>O plugin de credencial solicita ao usuário a entrada de credenciais LDAP e efetua troca das credenciais por um token via um serviço externo.</li>
<li>O plugin de credenciais retorna um token para o client-go, o qual o utiliza como um bearer token no servidor de API.</li>
<li>O servidor de API usa o <a href=#token-de-autentica%C3%A7%C3%A3o-via-webhook>autenticador de token webhook</a> para submeter um objeto <code>TokenReview</code> para o serviço externo.</li>
<li>O serviço externo verifica a assinatura do token e retorna o nome e grupos do usuário.</li>
</ul>
<h3 id=configuração>Configuração</h3>
<p>plugins de credencial são configurados através de <a href=/docs/tasks/access-application-cluster/configure-access-multiple-clusters/>arquivos de configuração do kubectl</a> como parte dos campos de usuário.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Config<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>users</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-user<span style=color:#bbb>
</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>user</span>:<span style=color:#bbb>
</span><span style=color:#bbb>   </span><span style=color:green;font-weight:700>exec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>     </span><span style=color:#080;font-style:italic># Comando a ser executado. Obrigatório.</span><span style=color:#bbb>
</span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;example-client-go-exec-plugin&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb> 
</span><span style=color:#bbb>     </span><span style=color:#080;font-style:italic># Versão da API a ser utilizada quando decodificar o recurso  ExecCredentials. Obrigatório</span><span style=color:#bbb>
</span><span style=color:#bbb>     </span><span style=color:#080;font-style:italic>#</span><span style=color:#bbb>
</span><span style=color:#bbb>     </span><span style=color:#080;font-style:italic># A versão da API retornada pelo plugin DEVE ser a mesma versão listada aqui.</span><span style=color:#bbb>
</span><span style=color:#bbb>     </span><span style=color:#080;font-style:italic>#</span><span style=color:#bbb>
</span><span style=color:#bbb>     </span><span style=color:#080;font-style:italic># Para integrar com ferramentas que suportem múltiplas versões (tal como client.authentication.k8s.io/v1alpha1),</span><span style=color:#bbb>
</span><span style=color:#bbb>     </span><span style=color:#080;font-style:italic># defina uma variável de ambiente ou passe um argumento para a ferramenta que indique qual versão o plugin de execução deve esperar.</span><span style=color:#bbb>
</span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;client.authentication.k8s.io/v1beta1&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb> 
</span><span style=color:#bbb>     </span><span style=color:#080;font-style:italic># Variáveis de ambiente a serem configuradas ao executar o plugin. Opcional</span><span style=color:#bbb>
</span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
</span><span style=color:#bbb>     </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;FOO&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>       </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;bar&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb> 
</span><span style=color:#bbb>     </span><span style=color:#080;font-style:italic># Argumentos a serem passados ao executar o plugin. Opcional</span><span style=color:#bbb>
</span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb>
</span><span style=color:#bbb>     </span>- <span style=color:#b44>&#34;arg1&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>     </span>- <span style=color:#b44>&#34;arg2&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb> 
</span><span style=color:#bbb>     </span><span style=color:#080;font-style:italic># Texto exibido para o usuário quando o executável não parece estar presente. Opcional</span><span style=color:#bbb>
</span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>installHint</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span><span style=color:#b44;font-style:italic>       </span><span style=color:#bbb>       </span><span style=color:green;font-weight:700>example-client-go-exec-plugin é necessário para autenticar no cluster atual. Pode ser instalado via</span>:<span style=color:#bbb>
</span><span style=color:#bbb> 
</span><span style=color:#bbb>       </span><span style=color:green;font-weight:700>Em macOS</span>:<span style=color:#bbb> </span>brew install example-client-go-exec-plugin<span style=color:#bbb>
</span><span style=color:#bbb> 
</span><span style=color:#bbb>       </span><span style=color:green;font-weight:700>Em Ubuntu</span>:<span style=color:#bbb> </span>apt-get install example-client-go-exec-plugin<span style=color:#bbb>
</span><span style=color:#bbb> 
</span><span style=color:#bbb>       </span><span style=color:green;font-weight:700>Em Fedora</span>:<span style=color:#bbb> </span>dnf install example-client-go-exec-plugin<span style=color:#bbb>
</span><span style=color:#bbb> 
</span><span style=color:#bbb>       </span>...<span style=color:#bbb>
</span><span style=color:#bbb> 
</span><span style=color:#bbb>     </span><span style=color:#080;font-style:italic># Deve-se ou não fornecer informações do cluster, que podem potencialmente conter grande quantidade de dados do CA,</span><span style=color:#bbb>
</span><span style=color:#bbb>     </span><span style=color:#080;font-style:italic># para esse plugin de execução como parte da variável de ambiente KUBERNETES_EXEC_INFO</span><span style=color:#bbb>
</span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>provideClusterInfo</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>clusters</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-cluster<span style=color:#bbb>
</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>cluster</span>:<span style=color:#bbb>
</span><span style=color:#bbb>   </span><span style=color:green;font-weight:700>server</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;https://172.17.4.100:6443&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>   </span><span style=color:green;font-weight:700>certificate-authority</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/etc/kubernetes/ca.pem&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>   </span><span style=color:green;font-weight:700>extensions</span>:<span style=color:#bbb>
</span><span style=color:#bbb>   </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>client.authentication.k8s.io/exec<span style=color:#bbb> </span><span style=color:#080;font-style:italic># nome de extensão reservado para configuração exclusiva do cluster</span><span style=color:#bbb>
</span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>extension</span>:<span style=color:#bbb>
</span><span style=color:#bbb>       </span><span style=color:green;font-weight:700>arbitrary</span>:<span style=color:#bbb> </span>config<span style=color:#bbb>
</span><span style=color:#bbb>       </span><span style=color:green;font-weight:700>this</span>:<span style=color:#bbb> </span>pode ser fornecido através da variável de ambiente KUBERNETES_EXEC_INFO na configuracao de provideClusterInfo<span style=color:#bbb>
</span><span style=color:#bbb>       </span><span style=color:green;font-weight:700>you</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;coloque&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;qualquer&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;coisa&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;aqui&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>contexts</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-cluster<span style=color:#bbb>
</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>context</span>:<span style=color:#bbb>
</span><span style=color:#bbb>   </span><span style=color:green;font-weight:700>cluster</span>:<span style=color:#bbb> </span>my-cluster<span style=color:#bbb>
</span><span style=color:#bbb>   </span><span style=color:green;font-weight:700>user</span>:<span style=color:#bbb> </span>my-user<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>current-context</span>:<span style=color:#bbb> </span>my-cluster<span style=color:#bbb>
</span></code></pre></div><p>Os caminhos relativos do comando são interpretados como relativo ao diretório do arquivo de configuração. Se
KUBECONFIG está configurado para o caminho <code>/home/jane/kubeconfig</code> e o comando executado é <code>./bin/example-client-go-exec-plugin</code>,
o binario <code>/home/jane/bin/example-client-go-exec-plugin</code> será executado.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-user<span style=color:#bbb>
</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>user</span>:<span style=color:#bbb>
</span><span style=color:#bbb>   </span><span style=color:green;font-weight:700>exec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>     </span><span style=color:#080;font-style:italic># Caminho relativo para o diretorio do kubeconfig</span><span style=color:#bbb>
</span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;./bin/example-client-go-exec-plugin&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;client.authentication.k8s.io/v1beta1&#34;</span><span style=color:#bbb>
</span></code></pre></div><h3 id=formatos-de-entrada-e-saída>Formatos de entrada e saída</h3>
<p>O comando executado imprime um objeto <code>ExecCredential</code> para o <code>stdout</code>. <code>k8s.io/client-go</code>
autentica na API do Kubernetes utilizando as credenciais retornadas no <code>status</code>.</p>
<p>Quando executando uma sessão interativa, <code>stdin</code> é exposto diretamente para o plugin. plugins devem utilizar
um <a href=https://godoc.org/golang.org/x/crypto/ssh/terminal#IsTerminal>TTY check</a> para determinar se é
apropriado solicitar um usuário interativamente.</p>
<p>Para usar credenciais do tipo <em>bearer token</em>, o plugin retorna um token no status do objeto <code>ExecCredential</code>.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
 <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;client.authentication.k8s.io/v1beta1&#34;</span>,
 <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;ExecCredential&#34;</span>,
 <span style=color:green;font-weight:700>&#34;status&#34;</span>: {
   <span style=color:green;font-weight:700>&#34;token&#34;</span>: <span style=color:#b44>&#34;my-bearer-token&#34;</span>
 }
}
</code></pre></div><p>Alternativamente, um certificado de cliente e chave codificados em PEM podem ser retornados para serem utilizados em autenticação de cliente TLS.
Se o plugin retornar um certificado e chave diferentes numa chamada subsequente, <code>k8s.io/client-go</code>
Irá fechar conexões existentes com o servidor para forçar uma nova troca TLS.</p>
<p>Se especificado, <code>clientKeyData</code> e <code>clientCertificateData</code> devem ambos estar presentes.</p>
<p><code>clientCertificateData</code> pode conter certificados intermediários adicionais a serem enviados para o servidor.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
 <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;client.authentication.k8s.io/v1beta1&#34;</span>,
 <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;ExecCredential&#34;</span>,
 <span style=color:green;font-weight:700>&#34;status&#34;</span>: {
   <span style=color:green;font-weight:700>&#34;clientCertificateData&#34;</span>: <span style=color:#b44>&#34;-----BEGIN CERTIFICATE-----\n...\n-----END CERTIFICATE-----&#34;</span>,
   <span style=color:green;font-weight:700>&#34;clientKeyData&#34;</span>: <span style=color:#b44>&#34;-----BEGIN RSA PRIVATE KEY-----\n...\n-----END RSA PRIVATE KEY-----&#34;</span>
 }
}
</code></pre></div><p>Opcionalmente, a resposta pode incluir a validade da credencial em formato
RFC3339 de data/hora. A presença ou ausência de validade pode ter o seguinte impacto:</p>
<ul>
<li>
<p>Se uma validade está incluída, o <em>bearer token</em> e as credenciais TLS são guardadas em cache até
a o tempo de expiração é atingido ou se o servidor responder com um codigo de status HTTP 401
ou se o processo terminar.</p>
</li>
<li>
<p>Se uma validate está ausente, o <em>bearer token</em> e as credenciais TLS são guardadas em cache até
o servidor responder com um código de status HTTP 401 ou até o processo terminar.</p>
</li>
</ul>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
 <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;client.authentication.k8s.io/v1beta1&#34;</span>,
 <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;ExecCredential&#34;</span>,
 <span style=color:green;font-weight:700>&#34;status&#34;</span>: {
   <span style=color:green;font-weight:700>&#34;token&#34;</span>: <span style=color:#b44>&#34;my-bearer-token&#34;</span>,
   <span style=color:green;font-weight:700>&#34;expirationTimestamp&#34;</span>: <span style=color:#b44>&#34;2018-03-05T17:30:20-08:00&#34;</span>
 }
}
</code></pre></div><p>Para habilitar o plugin de execução para obter informações específicas do cluster, define <code>provideClusterInfo</code> no campo <code>user.exec</code>
dentro do arquivo de configuração <a href=/docs/concepts/configuration/organize-cluster-access-kubeconfig/>kubeconfig</a>.
O plugin irá então prover a variável de ambiente <code>KUBERNETES_EXEC_INFO</code>.
As informações desta variável de ambiente podem ser utilizadas para executar lógicas de aquisição
de credentiais específicas do cluster.
O manifesto <code>ExecCredential</code> abaixo descreve um exemplo de informação de cluster.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
 <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;client.authentication.k8s.io/v1beta1&#34;</span>,
 <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;ExecCredential&#34;</span>,
 <span style=color:green;font-weight:700>&#34;spec&#34;</span>: {
   <span style=color:green;font-weight:700>&#34;cluster&#34;</span>: {
     <span style=color:green;font-weight:700>&#34;server&#34;</span>: <span style=color:#b44>&#34;https://172.17.4.100:6443&#34;</span>,
     <span style=color:green;font-weight:700>&#34;certificate-authority-data&#34;</span>: <span style=color:#b44>&#34;LS0t...&#34;</span>,
     <span style=color:green;font-weight:700>&#34;config&#34;</span>: {
       <span style=color:green;font-weight:700>&#34;arbitrary&#34;</span>: <span style=color:#b44>&#34;config&#34;</span>,
       <span style=color:green;font-weight:700>&#34;this&#34;</span>: <span style=color:#b44>&#34;pode ser fornecido por meio da variável de ambiente KUBERNETES_EXEC_INFO na configuração de provideClusterInfo&#34;</span>,
       <span style=color:green;font-weight:700>&#34;you&#34;</span>: [<span style=color:#b44>&#34;coloque&#34;</span>, <span style=color:#b44>&#34;qualquer&#34;</span>, <span style=color:#b44>&#34;coisa&#34;</span>, <span style=color:#b44>&#34;aqui&#34;</span>]
     }
   }
 }
}
</code></pre></div>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-de45b6ca7419a0e308044425b2ac52bb>3 - Autenticando com Tokens de Inicialização</h1>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.18 [stable]</code>
</div>
<p>Os tokens de inicialização são um <em>bearer token</em> simples que devem ser utilizados
ao criar novos clusters ou para quando novos nós são registrados a clusters existentes. Eles foram construídos
para suportar a ferramenta <a href=/docs/reference/setup-tools/kubeadm/>kubeadm</a>, mas podem ser utilizados em outros contextos para usuários que desejam inicializar clusters sem utilizar o <code>kubeadm</code>.
Foram também construídos para funcionar, via políticas RBAC, com o sistema de <a href=/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/>Inicialização do Kubelet via TLS</a>.</p>
<h2 id=visão-geral-dos-tokens-de-inicialização>Visão geral dos tokens de inicialização</h2>
<p>Os tokens de inicialização são definidos com um tipo especifico de <em>secrets</em> (<code>bootstrap.kubernetes.io/token</code>) que existem no namespace <code>kube-system</code>. Estes <em>secrets</em> são então lidos pelo autenticador de inicialização do servidor de API.
Tokens expirados são removidos pelo controlador <em>TokenCleaner</em> no gerenciador de controle - kube-controller-manager.
Os tokens também são utilizados para criar uma assinatura para um ConfigMap específico usado no processo de descoberta através de um controlador denominado <code>BootstrapSigner</code>.</p>
<h2 id=formato-do-token>Formato do Token</h2>
<p>Tokens de inicialização tem o formato <code>abcdef.0123456789abcdef</code>. Mais formalmente, eles devem corresponder a expressão regular <code>[a-z0-9]{6}\.[a-z0-9]{16}</code>.</p>
<p>A primeira parte do token é um identificador ("Token ID") e é considerado informação pública.
Ele é utilizado para se referir a um token sem vazar a parte secreta usada para autenticação.
A segunda parte é o <em>secret</em> do token e somente deve ser compartilhado com partes confiáveis.</p>
<h2 id=habilitando-autenticação-com-tokens-de-inicialização>Habilitando autenticação com tokens de inicialização</h2>
<p>O autenticador de tokens de inicialização pode ser habilitado utilizando a seguinte opção no servidor de API:</p>
<pre><code>--enable-bootstrap-token-auth
</code></pre><p>Quando habilitado, tokens de inicialização podem ser utilizado como credenciais <em>bearer token</em>
para autenticar requisições no servidor de API.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-http data-lang=http><span>Authorization: Bearer 07401b.f395accd246ae52d
</span></code></pre></div><p>Tokens são autenticados como o usuário <code>system:bootstrap:&lt;token id></code> e são membros
do grupo <code>system:bootstrappers</code>. Grupos adicionais podem ser
especificados dentro do <em>secret</em> do token.</p>
<p>Tokens expirados podem ser removidos automaticamente ao habilitar o controlador <code>tokencleaner</code>
do gerenciador de controle - kube-controller-manager.</p>
<pre><code>--controllers=*,tokencleaner
</code></pre><h2 id=formato-do-secret-dos-tokens-de-inicialização>Formato do <em>secret</em> dos tokens de inicialização</h2>
<p>Cada token válido possui um <em>secret</em> no namespace <code>kube-system</code>. Você pode
encontrar a documentação completa <a href=https://github.com/kubernetes/community/blob/master/contributors/design-proposals/cluster-lifecycle/bootstrap-discovery.md>aqui</a>.</p>
<p>Um <em>secret</em> de token se parece com o exemplo abaixo:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb> </span><span style=color:#080;font-style:italic># Nome DEVE seguir o formato &#34;bootstrap-token-&lt;token id&gt;&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>bootstrap-token-07401b<span style=color:#bbb>
</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>kube-system<span style=color:#bbb>
</span><span style=color:#bbb> 
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># Tipo DEVE ser &#39;bootstrap.kubernetes.io/token&#39;</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>bootstrap.kubernetes.io/token<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>stringData</span>:<span style=color:#bbb>
</span><span style=color:#bbb> </span><span style=color:#080;font-style:italic># Descrição legível. Opcional.</span><span style=color:#bbb>
</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>description</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;The default bootstrap token generated by &#39;kubeadm init&#39;.&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb> 
</span><span style=color:#bbb> </span><span style=color:#080;font-style:italic># identificador do token e _secret_. Obrigatório.</span><span style=color:#bbb>
</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>token-id</span>:<span style=color:#bbb> </span>07401b<span style=color:#bbb>
</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>token-secret</span>:<span style=color:#bbb> </span>f395accd246ae52d<span style=color:#bbb>
</span><span style=color:#bbb> 
</span><span style=color:#bbb> </span><span style=color:#080;font-style:italic># Validade. Opcional.</span><span style=color:#bbb>
</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>expiration</span>:<span style=color:#bbb> </span>2017-03-10T03:22:11Z<span style=color:#bbb>
</span><span style=color:#bbb> 
</span><span style=color:#bbb> </span><span style=color:#080;font-style:italic># Usos permitidos.</span><span style=color:#bbb>
</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>usage-bootstrap-authentication</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>usage-bootstrap-signing</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb> 
</span><span style=color:#bbb> </span><span style=color:#080;font-style:italic># Grupos adicionais para autenticar o token. Devem começar com &#34;system:bootstrappers:&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>auth-extra-groups</span>:<span style=color:#bbb> </span>system:bootstrappers:worker,system:bootstrappers:ingress<span style=color:#bbb>
</span></code></pre></div><p>O tipo do <em>secret</em> deve ser <code>bootstrap.kubernetes.io/token</code> e o nome deve seguir o formato <code>bootstrap-token-&lt;token id></code>. Ele também tem que existir no namespace <code>kube-system</code>.</p>
<p>Os membros listados em <code>usage-bootstrap-*</code> indicam qual a intenção de uso deste <em>secret</em>. O valor <code>true</code> deve ser definido para que seja ativado.</p>
<ul>
<li><code>usage-bootstrap-authentication</code> indica que o token pode ser utilizado para autenticar no servidor de API como um <em>bearer token</em>.</li>
<li><code>usage-bootstrap-signing</code> indica que o token pode ser utilizado para assinar o ConfigMap <code>cluster-info</code> como descrito abaixo.</li>
</ul>
<p>O campo <code>expiration</code> controla a expiração do token. Tokens expirados são
rejeitados quando usados para autenticação e ignorados durante assinatura de ConfigMaps.
O valor de expiração é codificado como um tempo absoluto UTC utilizando a RFC3339. Para automaticamente
remover tokens expirados basta habilitar o controlador <code>tokencleaner</code>.</p>
<h2 id=gerenciamento-de-tokens-com-kubeadm>Gerenciamento de tokens com kubeadm</h2>
<p>Você pode usar a ferramenta <code>kubeadm</code> para gerenciar tokens em um cluster. Veja <a href=/docs/reference/setup-tools/kubeadm/kubeadm-token/>documentação de tokens kubeadm</a> para mais detalhes.</p>
<h2 id=assinatura-de-configmap>Assinatura de ConfigMap</h2>
<p>Além de autenticação, os tokens podem ser utilizados para assinar um ConfigMap. Isto pode
ser utilizado em estágio inicial do processo de inicialização de um cluster, antes que o cliente confie
no servidor de API. O Configmap assinado pode ser autenticado por um token compartilhado.</p>
<p>Habilite a assinatura de ConfigMap ao habilitar o controlador <code>bootstrapsigner</code> no gerenciador de controle - kube-controller-manager.</p>
<pre><code>--controllers=*,bootstrapsigner
</code></pre><p>O ConfigMap assinado é o <code>cluster-info</code> no namespace <code>kube-public</code>.
No fluxo típico, um cliente lê o ConfigMap enquanto ainda não autenticado
e ignora os erros da camada de transporte seguro (TLS).
Ele então valida o conteúdo do ConfigMap ao verificar a assinatura contida no ConfigMap.</p>
<p>O ConfigMap pode se parecer com o exemplo abaixo:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cluster-info<span style=color:#bbb>
</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>kube-public<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>jws-kubeconfig-07401b</span>:<span style=color:#bbb> </span>eyJhbGciOiJIUzI1NiIsImtpZCI6IjA3NDAxYiJ9..tYEfbo6zDNo40MQE07aZcQX2m3EB2rO3NuXtxVMYm9U<span style=color:#bbb>
</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>kubeconfig</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span><span style=color:#b44;font-style:italic>   apiVersion: v1
</span><span style=color:#b44;font-style:italic>   clusters:
</span><span style=color:#b44;font-style:italic>   - cluster:
</span><span style=color:#b44;font-style:italic>       certificate-authority-data: &lt;really long certificate data&gt;
</span><span style=color:#b44;font-style:italic>       server: https://10.138.0.2:6443
</span><span style=color:#b44;font-style:italic>     name: &#34;&#34;
</span><span style=color:#b44;font-style:italic>   contexts: []
</span><span style=color:#b44;font-style:italic>   current-context: &#34;&#34;
</span><span style=color:#b44;font-style:italic>   kind: Config
</span><span style=color:#b44;font-style:italic>   preferences: {}
</span><span style=color:#b44;font-style:italic>   users: []</span><span style=color:#bbb>   
</span></code></pre></div><p>O membro <code>kubeconfig</code> do ConfigMap é um arquivo de configuração contendo somente
as informações do cluster preenchidas. A informação chave sendo comunicada aqui
está em <code>certificate-authority-data</code>. Isto poderá ser expandido no futuro.</p>
<p>A assinatura é feita utilizando-se assinatura JWS em modo "separado". Para validar
a assinatura, o usuário deve codificar o conteúdo do <code>kubeconfig</code> de acordo com as regras do JWS
(codificando em base64 e descartando qualquer <code>=</code> ao final). O conteúdo codificado
e então usado para formar um JWS inteiro, inserindo-o entre os 2 pontos. Você pode
verificar o JWS utilizando o esquema <code>HS256</code> (HMAC-SHA256) com o token completo
(por exemplo: <code>07401b.f395accd246ae52d</code>) como o <em>secret</em> compartilhado. Usuários <em>devem</em>
verificar que o algoritmo HS256 (que é um método de assinatura simétrica) está sendo utilizado.</p>
<div class="alert alert-danger warning callout" role=alert>
<strong>Aviso:</strong> Qualquer parte em posse de um token de inicialização pode criar uma assinatura válida
daquele token. Não é recomendável, quando utilizando assinatura de ConfigMap, que se compartilhe
o mesmo token com muitos clientes, uma vez que um cliente comprometido pode abrir brecha para potenciais
"homem no meio" entre outro cliente que confia na assinatura para estabelecer inicialização via camada de transporte seguro (TLS).
</div>
<p>Consulte a seção de <a href=/docs/reference/setup-tools/kubeadm/implementation-details/>detalhes de implementação do kubeadm</a> para mais informações.</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-df8ff2190764e70c3de2015e2cb46b14>4 - Portas e protocolos</h1>
<p>Quando o Kubernetes está sendo executado em um ambiente com uma rede mais restritiva,
como por exemplo um data center on-premises com firewalls de rede físicos ou redes virtuais em nuvens públicas,
é útil saber quais portas e protocolos são utilizados pelos componentes do Kubernetes.</p>
<h2 id=camada-de-gerenciamento>Camada de gerenciamento</h2>
<table>
<thead>
<tr>
<th>Protocolo</th>
<th>Direção</th>
<th>Intervalo de Portas</th>
<th>Propósito</th>
<th>Utilizado por</th>
</tr>
</thead>
<tbody>
<tr>
<td>TCP</td>
<td>Entrada</td>
<td>6443</td>
<td>Servidor da API do Kubernetes</td>
<td>Todos</td>
</tr>
<tr>
<td>TCP</td>
<td>Entrada</td>
<td>2379-2380</td>
<td>API servidor-cliente do etcd</td>
<td>kube-apiserver, etcd</td>
</tr>
<tr>
<td>TCP</td>
<td>Entrada</td>
<td>10250</td>
<td>API do kubelet</td>
<td>kubeadm, Camada de gerenciamento</td>
</tr>
<tr>
<td>TCP</td>
<td>Entrada</td>
<td>10259</td>
<td>kube-scheduler</td>
<td>kubeadm</td>
</tr>
<tr>
<td>TCP</td>
<td>Entrada</td>
<td>10257</td>
<td>kube-controller-manager</td>
<td>kubeadm</td>
</tr>
</tbody>
</table>
<p>Embora as portas do etcd estejam inclusas na seção da Camada de gerenciamento, você também
pode hospedar o seu próprio cluster etcd externamente ou em portas customizadas.</p>
<h2 id=node>Nós de processamento</h2>
<table>
<thead>
<tr>
<th>Protocolo</th>
<th>Direção</th>
<th>Intervalo de Portas</th>
<th>Propósito</th>
<th>Utilizado por</th>
</tr>
</thead>
<tbody>
<tr>
<td>TCP</td>
<td>Entrada</td>
<td>10250</td>
<td>API do Kubelet</td>
<td>O próprio, Camada de gerenciamento</td>
</tr>
<tr>
<td>TCP</td>
<td>Entrada</td>
<td>30000-32767</td>
<td>Serviços NodePort†</td>
<td>Todos</td>
</tr>
</tbody>
</table>
<p>† Intervalo padrão de portas para os <a href=/docs/concepts/services-networking/service/>serviços NodePort</a>.</p>
<p>Todas as portas padrão podem ser sobrescritas. Quando portas customizadas são utilizadas, essas portas
precisam estar abertas, ao invés das mencionadas aqui.</p>
<p>Um exemplo comum é a porta do servidor da API, que as vezes é trocado para a porta 433.
Com isso, a porta padrão é mantida e o servidor da API é colocado atrás de um balanceador de carga
que escuta na porta 433 e faz o roteamento das requisições para o servidor da API na porta padrão.</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-03460a7254c6c73eb2a1bb3dd7d25910>5 - kubectl CLI</h1>
</div>
<div class=td-content>
<h1 id=pg-8aba901ac13f124e5782b90ddb166ee2>5.1 - kubectl Cheat Sheet</h1>
<p>Veja também: <a href=/docs/reference/kubectl/overview/>Visão geral do Kubectl</a> e <a href=/docs/reference/kubectl/jsonpath>JsonPath Guide</a>.</p>
<p>Esta página é uma visão geral do comando <code>kubectl</code>.</p>
<h1 id=kubectl-cheat-sheet>kubectl - Cheat Sheet</h1>
<h2 id=kubectl-autocomplete>Kubectl Autocomplete</h2>
<h3 id=bash>BASH</h3>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#a2f>source</span> &lt;<span style=color:#666>(</span>kubectl completion bash<span style=color:#666>)</span> <span style=color:#080;font-style:italic># configuração de autocomplete no bash do shell atual, o pacote bash-completion precisa ter sido instalado primeiro.</span>
<span style=color:#a2f>echo</span> <span style=color:#b44>&#34;source &lt;(kubectl completion bash)&#34;</span> &gt;&gt; ~/.bashrc <span style=color:#080;font-style:italic># para adicionar o autocomplete permanentemente no seu shell bash.</span>
</code></pre></div><p>Você também pode usar uma abreviação para o atalho para <code>kubectl</code> que também funciona com o auto completar:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#a2f>alias</span> <span style=color:#b8860b>k</span><span style=color:#666>=</span>kubectl
<span style=color:#a2f>complete</span> -F __start_kubectl k
</code></pre></div><h3 id=zsh>ZSH</h3>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#a2f>source</span> &lt;<span style=color:#666>(</span>kubectl completion zsh<span style=color:#666>)</span>  <span style=color:#080;font-style:italic># configuração para usar autocomplete no terminal zsh no shell atual</span>
<span style=color:#a2f>echo</span> <span style=color:#b44>&#34;if [ </span><span style=color:#b8860b>$commands</span><span style=color:#b44>[kubectl] ]; then source &lt;(kubectl completion zsh); fi&#34;</span> &gt;&gt; ~/.zshrc <span style=color:#080;font-style:italic># adicionar auto completar permanentemente para o seu shell zsh</span>
</code></pre></div><h2 id=contexto-e-configuração-do-kubectl>Contexto e Configuração do Kubectl</h2>
<p>Defina com qual cluster Kubernetes o <code>kubectl</code> se comunica e modifique os detalhes da configuração.
Veja a documentação <a href=/docs/tasks/access-application-cluster/configure-access-multiple-clusters/>Autenticando entre clusters com o kubeconfig</a> para
informações detalhadas do arquivo de configuração.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl config view <span style=color:#080;font-style:italic># Mostrar configurações do kubeconfig mergeadas.</span>

<span style=color:#080;font-style:italic># use vários arquivos kubeconfig ao mesmo tempo e visualize a configuração mergeada</span>
<span style=color:#b8860b>KUBECONFIG</span><span style=color:#666>=</span>~/.kube/config:~/.kube/kubconfig2 

kubectl config view

<span style=color:#080;font-style:italic># obtenha a senha para o usuário e2e</span>
kubectl config view -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.users[?(@.name == &#34;e2e&#34;)].user.password}&#39;</span>

kubectl config view -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.users[].name}&#39;</span>    <span style=color:#080;font-style:italic># exibir o primeiro usuário</span>
kubectl config view -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.users[*].name}&#39;</span>   <span style=color:#080;font-style:italic># obtenha uma lista de usuários</span>
kubectl config get-contexts                          <span style=color:#080;font-style:italic># exibir lista de contextos</span>
kubectl config current-context                       <span style=color:#080;font-style:italic># exibir o contexto atual</span>
kubectl config use-context my-cluster-name           <span style=color:#080;font-style:italic># defina o contexto padrão como my-cluster-name</span>

<span style=color:#080;font-style:italic># adicione um novo cluster ao seu kubeconfig que suporte autenticação básica</span>
kubectl config set-credentials kubeuser/foo.kubernetes.com --username<span style=color:#666>=</span>kubeuser --password<span style=color:#666>=</span>kubepassword

<span style=color:#080;font-style:italic># salve o namespace permanentemente para todos os comandos subsequentes do kubectl nesse contexto.</span>
kubectl config set-context --current --namespace<span style=color:#666>=</span>ggckad-s2

<span style=color:#080;font-style:italic># defina um contexto utilizando um nome de usuário e o namespace.</span>
kubectl config set-context gce --user<span style=color:#666>=</span>cluster-admin --namespace<span style=color:#666>=</span>foo <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  <span style=color:#666>&amp;&amp;</span> kubectl config use-context gce
 
kubectl config <span style=color:#a2f>unset</span> users.foo                       <span style=color:#080;font-style:italic># excluir usuário foo</span>
</code></pre></div><h2 id=aplicar>Aplicar</h2>
<p><code>apply</code> gerencia aplicações através de arquivos que definem os recursos do Kubernetes. Ele cria e atualiza recursos em um cluster através da execução <code>kubectl apply</code>.
Esta é a maneira recomendada de gerenciar aplicações Kubernetes em ambiente de produção. Veja a <a href=https://kubectl.docs.kubernetes.io>documentação do Kubectl</a>.</p>
<h2 id=criando-objetos>Criando objetos</h2>
<p>Manifestos Kubernetes podem ser definidos em YAML ou JSON. A extensão de arquivo <code>.yaml</code>,
<code>.yml</code>, e <code>.json</code> pode ser usado.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl apply -f ./my-manifest.yaml            <span style=color:#080;font-style:italic># criar recurso(s)</span>
kubectl apply -f ./my1.yaml -f ./my2.yaml      <span style=color:#080;font-style:italic># criar a partir de vários arquivos</span>
kubectl apply -f ./dir                         <span style=color:#080;font-style:italic># criar recurso(s) em todos os arquivos de manifesto no diretório</span>
kubectl apply -f https://git.io/vPieo          <span style=color:#080;font-style:italic># criar recurso(s) a partir de URL</span>
kubectl create deployment nginx --image<span style=color:#666>=</span>nginx  <span style=color:#080;font-style:italic># iniciar uma única instância do nginx</span>
kubectl explain pods,svc                       <span style=color:#080;font-style:italic># obtenha a documentação de manifesto do pod</span>

<span style=color:#080;font-style:italic># Crie vários objetos YAML a partir de stdin</span>
cat <span style=color:#b44>&lt;&lt;EOF | kubectl apply -f -
</span><span style=color:#b44>apiVersion: v1
</span><span style=color:#b44>kind: Pod
</span><span style=color:#b44>metadata:
</span><span style=color:#b44>  name: busybox-sleep
</span><span style=color:#b44>spec:
</span><span style=color:#b44>  containers:
</span><span style=color:#b44>  - name: busybox
</span><span style=color:#b44>    image: busybox
</span><span style=color:#b44>    args:
</span><span style=color:#b44>    - sleep
</span><span style=color:#b44>    - &#34;1000000&#34;
</span><span style=color:#b44>---
</span><span style=color:#b44>apiVersion: v1
</span><span style=color:#b44>kind: Pod
</span><span style=color:#b44>metadata:
</span><span style=color:#b44>  name: busybox-sleep-less
</span><span style=color:#b44>spec:
</span><span style=color:#b44>  containers:
</span><span style=color:#b44>  - name: busybox
</span><span style=color:#b44>    image: busybox
</span><span style=color:#b44>    args:
</span><span style=color:#b44>    - sleep
</span><span style=color:#b44>    - &#34;1000&#34;
</span><span style=color:#b44>EOF</span>

<span style=color:#080;font-style:italic># Crie um segredo com várias chaves</span>
cat <span style=color:#b44>&lt;&lt;EOF | kubectl apply -f -
</span><span style=color:#b44>apiVersion: v1
</span><span style=color:#b44>kind: Secret
</span><span style=color:#b44>metadata:
</span><span style=color:#b44>  name: mysecret
</span><span style=color:#b44>type: Opaque
</span><span style=color:#b44>data:
</span><span style=color:#b44>  password: $(echo -n &#34;s33msi4&#34; | base64 -w0)
</span><span style=color:#b44>  username: $(echo -n &#34;jane&#34; | base64 -w0)
</span><span style=color:#b44>EOF</span>

</code></pre></div><h2 id=visualizando-e-localizando-recursos>Visualizando e Localizando Recursos</h2>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#080;font-style:italic># Obter comandos com saída simples</span>
kubectl get services                          <span style=color:#080;font-style:italic># Listar todos os serviços do namespace</span>
kubectl get pods --all-namespaces             <span style=color:#080;font-style:italic># Listar todos os pods em todos namespaces</span>
kubectl get pods -o wide                      <span style=color:#080;font-style:italic># Listar todos os pods no namespace atual, com mais detalhes</span>
kubectl get deployment my-dep                 <span style=color:#080;font-style:italic># Listar um deployment específico</span>
kubectl get pods                              <span style=color:#080;font-style:italic># Listar todos os pods no namespace</span>
kubectl get pod my-pod -o yaml                <span style=color:#080;font-style:italic># Obter o YAML de um pod</span>

<span style=color:#080;font-style:italic># Descrever comandos com saída detalhada</span>
kubectl describe nodes my-node
kubectl describe pods my-pod

<span style=color:#080;font-style:italic># Listar serviços classificados por nome</span>
kubectl get services --sort-by<span style=color:#666>=</span>.metadata.name

<span style=color:#080;font-style:italic># Listar pods classificados por contagem de reinicializações</span>
kubectl get pods --sort-by<span style=color:#666>=</span><span style=color:#b44>&#39;.status.containerStatuses[0].restartCount&#39;</span>

<span style=color:#080;font-style:italic># Listar PersistentVolumes classificado por capacidade</span>
kubectl get pv --sort-by<span style=color:#666>=</span>.spec.capacity.storage

<span style=color:#080;font-style:italic># Obtenha a versão da label de todos os pods com a label app=cassandra</span>
kubectl get pods --selector<span style=color:#666>=</span><span style=color:#b8860b>app</span><span style=color:#666>=</span>cassandra -o <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.items[*].metadata.labels.version}&#39;</span>

<span style=color:#080;font-style:italic># Obter todos os nós workers (use um seletor para excluir resultados que possuem uma label</span>
<span style=color:#080;font-style:italic># nomeado &#39;node-role.kubernetes.io/master&#39;)</span>
kubectl get node --selector<span style=color:#666>=</span><span style=color:#b44>&#39;!node-role.kubernetes.io/master&#39;</span>

<span style=color:#080;font-style:italic># Obter todos os pods em execução no namespace</span>
kubectl get pods --field-selector<span style=color:#666>=</span>status.phase<span style=color:#666>=</span>Running

<span style=color:#080;font-style:italic># Obter ExternalIPs de todos os nós</span>
kubectl get nodes -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.items[*].status.addresses[?(@.type==&#34;ExternalIP&#34;)].address}&#39;</span>

<span style=color:#080;font-style:italic># Listar nomes de pods pertencentes a um RC particular </span>
<span style=color:#080;font-style:italic># O comando &#34;jq&#34; é útil para transformações que são muito complexas para jsonpath, pode ser encontrado em https://stedolan.github.io/jq/</span>
<span style=color:#b8860b>sel</span><span style=color:#666>=</span><span style=color:#b68;font-weight:700>${</span><span style=color:#a2f;font-weight:700>$(</span>kubectl get rc my-rc --output<span style=color:#666>=</span>json | jq -j <span style=color:#b44>&#39;.spec.selector | to_entries | .[] | &#34;\(.key)=\(.value),&#34;&#39;</span><span style=color:#a2f;font-weight:700>)</span>%?<span style=color:#b68;font-weight:700>}</span>
<span style=color:#a2f>echo</span> <span style=color:#a2f;font-weight:700>$(</span>kubectl get pods --selector<span style=color:#666>=</span><span style=color:#b8860b>$sel</span> --output<span style=color:#666>=</span><span style=color:#b8860b>jsonpath</span><span style=color:#666>={</span>.items..metadata.name<span style=color:#666>}</span><span style=color:#a2f;font-weight:700>)</span>

<span style=color:#080;font-style:italic># Mostrar marcadores para todos os pods(ou qualquer outro objeto Kubernetes que suporte rotulagem)</span>
kubectl get pods --show-labels

<span style=color:#080;font-style:italic># Verifique quais nós estão prontos</span>
<span style=color:#b8860b>JSONPATH</span><span style=color:#666>=</span><span style=color:#b44>&#39;{range .items[*]}{@.metadata.name}:{range @.status.conditions[*]}{@.type}={@.status};{end}{end}&#39;</span> <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span> <span style=color:#666>&amp;&amp;</span> kubectl get nodes -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#34;</span><span style=color:#b8860b>$JSONPATH</span><span style=color:#b44>&#34;</span> | grep <span style=color:#b44>&#34;Ready=True&#34;</span>

<span style=color:#080;font-style:italic># Listar todos os segredos atualmente em uso por um pod</span>
kubectl get pods -o json | jq <span style=color:#b44>&#39;.items[].spec.containers[].env[]?.valueFrom.secretKeyRef.name&#39;</span> | grep -v null | sort | uniq

<span style=color:#080;font-style:italic># Listar todos os containerIDs de initContainer de todos os pods</span>
<span style=color:#080;font-style:italic># Útil ao limpar contêineres parados, evitando a remoção de initContainers.</span>
kubectl get pods --all-namespaces -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{range .items[*].status.initContainerStatuses[*]}{.containerID}{&#34;\n&#34;}{end}&#39;</span> | cut -d/ -f3

<span style=color:#080;font-style:italic># Listar eventos classificados por timestamp</span>
kubectl get events --sort-by<span style=color:#666>=</span>.metadata.creationTimestamp

<span style=color:#080;font-style:italic># Compara o estado atual do cluster com o estado em que o cluster estaria se o manifesto fosse aplicado.</span>
kubectl diff -f ./my-manifest.yaml
</code></pre></div><h2 id=atualizando-recursos>Atualizando Recursos</h2>
<p>A partir da versão 1.11 <code>rolling-update</code> foi descontinuado (veja <a href=https://github.com/kubernetes/kubernetes/blob/master/CHANGELOG/CHANGELOG-1.11.md>CHANGELOG-1.11.md</a>), utilize o comando <code>rollout</code> no lugar deste.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl <span style=color:#a2f>set</span> image deployment/frontend <span style=color:#b8860b>www</span><span style=color:#666>=</span>image:v2               <span style=color:#080;font-style:italic># Aplica o rollout nos containers &#34;www&#34; do deployment &#34;frontend&#34;, atualizando a imagem</span>
kubectl rollout <span style=color:#a2f>history</span> deployment/frontend                      <span style=color:#080;font-style:italic># Verifica o histórico do deployment, incluindo a revisão</span>
kubectl rollout undo deployment/frontend                         <span style=color:#080;font-style:italic># Rollback para o deployment anterior</span>
kubectl rollout undo deployment/frontend --to-revision<span style=color:#666>=</span><span style=color:#666>2</span>         <span style=color:#080;font-style:italic># Rollback para uma revisão específica</span>
kubectl rollout status -w deployment/frontend                    <span style=color:#080;font-style:italic># Acompanhe o status de atualização do &#34;frontend&#34; até sua conclusão sem interrupção </span>
kubectl rollout restart deployment/frontend                      <span style=color:#080;font-style:italic># Reinício contínuo do deployment &#34;frontend&#34;</span>


<span style=color:#080;font-style:italic># versão inicial descontinuada 1.11</span>
kubectl rolling-update frontend-v1 -f frontend-v2.json           <span style=color:#080;font-style:italic># (descontinuada) Atualização contínua dos pods de frontend-v1</span>
kubectl rolling-update frontend-v1 frontend-v2 --image<span style=color:#666>=</span>image:v2  <span style=color:#080;font-style:italic># (descontinuada) Altera o nome do recurso e atualiza a imagem</span>
kubectl rolling-update frontend --image<span style=color:#666>=</span>image:v2                 <span style=color:#080;font-style:italic># (descontinuada) Atualize a imagem dos pods do frontend</span>
kubectl rolling-update frontend-v1 frontend-v2 --rollback        <span style=color:#080;font-style:italic># (descontinuada) Interromper o lançamento existente em andamento</span>

cat pod.json | kubectl replace -f -                              <span style=color:#080;font-style:italic># Substitua um pod com base no JSON passado para std</span>

<span style=color:#080;font-style:italic># Força a substituição, exclui e recria o recurso. Causará uma interrupção do serviço.</span>
kubectl replace --force -f ./pod.json

<span style=color:#080;font-style:italic># Crie um serviço para um nginx replicado, que serve na porta 80 e se conecta aos contêineres na porta 8000</span>
kubectl expose rc nginx --port<span style=color:#666>=</span><span style=color:#666>80</span> --target-port<span style=color:#666>=</span><span style=color:#666>8000</span>

<span style=color:#080;font-style:italic># Atualizar a versão da imagem (tag) de um pod de contêiner único para a v4</span>
kubectl get pod mypod -o yaml | sed <span style=color:#b44>&#39;s/\(image: myimage\):.*$/\1:v4/&#39;</span> | kubectl replace -f -

kubectl label pods my-pod new-label<span style=color:#666>=</span>awesome                      <span style=color:#080;font-style:italic># Adicionar uma label</span>
kubectl annotate pods my-pod icon-url<span style=color:#666>=</span>http://goo.gl/XXBTWq       <span style=color:#080;font-style:italic># Adicionar uma anotação</span>
kubectl autoscale deployment foo --min<span style=color:#666>=</span><span style=color:#666>2</span> --max<span style=color:#666>=</span><span style=color:#666>10</span>                <span style=color:#080;font-style:italic># Escalar automaticamente um deployment &#34;foo&#34;</span>
</code></pre></div><h2 id=recursos-de-correção>Recursos de Correção</h2>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#080;font-style:italic># Atualizar parcialmente um nó</span>
kubectl patch node k8s-node-1 -p <span style=color:#b44>&#39;{&#34;spec&#34;:{&#34;unschedulable&#34;:true}}&#39;</span>

<span style=color:#080;font-style:italic># Atualizar a imagem de um contêiner; spec.containers[*].name é obrigatório porque é uma chave de mesclagem</span>
kubectl patch pod valid-pod -p <span style=color:#b44>&#39;{&#34;spec&#34;:{&#34;containers&#34;:[{&#34;name&#34;:&#34;kubernetes-serve-hostname&#34;,&#34;image&#34;:&#34;new image&#34;}]}}&#39;</span>

<span style=color:#080;font-style:italic># Atualizar a imagem de um contêiner usando um patch json com matrizes posicionais</span>
kubectl patch pod valid-pod --type<span style=color:#666>=</span><span style=color:#b44>&#39;json&#39;</span> -p<span style=color:#666>=</span><span style=color:#b44>&#39;[{&#34;op&#34;: &#34;replace&#34;, &#34;path&#34;: &#34;/spec/containers/0/image&#34;, &#34;value&#34;:&#34;new image&#34;}]&#39;</span>

<span style=color:#080;font-style:italic># Desative um livenessProbe de deployment usando um patch json com matrizes posicionais</span>
kubectl patch deployment valid-deployment  --type json   -p<span style=color:#666>=</span><span style=color:#b44>&#39;[{&#34;op&#34;: &#34;remove&#34;, &#34;path&#34;: &#34;/spec/template/spec/containers/0/livenessProbe&#34;}]&#39;</span>

<span style=color:#080;font-style:italic># Adicionar um novo elemento a uma matriz posicional</span>
kubectl patch sa default --type<span style=color:#666>=</span><span style=color:#b44>&#39;json&#39;</span> -p<span style=color:#666>=</span><span style=color:#b44>&#39;[{&#34;op&#34;: &#34;add&#34;, &#34;path&#34;: &#34;/secrets/1&#34;, &#34;value&#34;: {&#34;name&#34;: &#34;whatever&#34; } }]&#39;</span>
</code></pre></div><h2 id=editando-recursos>Editando Recursos</h2>
<p>Edite qualquer recurso da API no seu editor preferido.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl edit svc/docker-registry                      <span style=color:#080;font-style:italic># Edite o serviço chamado docker-registry</span>
<span style=color:#b8860b>KUBE_EDITOR</span><span style=color:#666>=</span><span style=color:#b44>&#34;nano&#34;</span> kubectl edit svc/docker-registry   <span style=color:#080;font-style:italic># Use um editor alternativo</span>
</code></pre></div><h2 id=escalando-recursos>Escalando Recursos</h2>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl scale --replicas<span style=color:#666>=</span><span style=color:#666>3</span> rs/foo                                 <span style=color:#080;font-style:italic># Escale um replicaset chamado &#39;foo&#39; para 3</span>
kubectl scale --replicas<span style=color:#666>=</span><span style=color:#666>3</span> -f foo.yaml                            <span style=color:#080;font-style:italic># Escale um recurso especificado em &#34;foo.yaml&#34; para 3</span>
kubectl scale --current-replicas<span style=color:#666>=</span><span style=color:#666>2</span> --replicas<span style=color:#666>=</span><span style=color:#666>3</span> deployment/mysql  <span style=color:#080;font-style:italic># Se o tamanho atual do deployment chamado mysql for dois, assim escale para 3</span>
kubectl scale --replicas<span style=color:#666>=</span><span style=color:#666>5</span> rc/foo rc/bar rc/baz                   <span style=color:#080;font-style:italic># Escalar vários replicaset</span>
</code></pre></div><h2 id=exclusão-de-recursos>Exclusão de Recursos</h2>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl delete -f ./pod.json                                              <span style=color:#080;font-style:italic># Exclua um pod usando o tipo e o nome especificados em pod.json</span>
kubectl delete pod,service baz foo                                        <span style=color:#080;font-style:italic># Excluir pods e serviços com os mesmos nomes &#34;baz&#34; e &#34;foo&#34;</span>
kubectl delete pods,services -l <span style=color:#b8860b>name</span><span style=color:#666>=</span>myLabel                              <span style=color:#080;font-style:italic># Excluir pods e serviços com o nome da label = myLabel</span>
kubectl -n my-ns delete pod,svc --all                                     <span style=color:#080;font-style:italic># Exclua todos os pods e serviços no namespace my-ns,</span>
<span style=color:#080;font-style:italic># Excluir todos os pods que correspondem ao awk pattern1 ou pattern2</span>
kubectl get pods  -n mynamespace --no-headers<span style=color:#666>=</span><span style=color:#a2f>true</span> | awk <span style=color:#b44>&#39;/pattern1|pattern2/{print $1}&#39;</span> | xargs  kubectl delete -n mynamespace pod
</code></pre></div><h2 id=interagindo-com-pods-em-execução>Interagindo com Pods em execução</h2>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl logs my-pod                                 <span style=color:#080;font-style:italic># despejar logs de pod (stdout)</span>
kubectl logs -l <span style=color:#b8860b>name</span><span style=color:#666>=</span>myLabel                        <span style=color:#080;font-style:italic># despejar logs de pod, com a label de name=myLabel (stdout)</span>
kubectl logs my-pod --previous                      <span style=color:#080;font-style:italic># despejar logs de pod (stdout) para a instância anterior de um contêiner</span>
kubectl logs my-pod -c my-container                 <span style=color:#080;font-style:italic># despejar logs de um específico contêiner em um pod (stdout, no caso de vários contêineres)</span>
kubectl logs -l <span style=color:#b8860b>name</span><span style=color:#666>=</span>myLabel -c my-container        <span style=color:#080;font-style:italic># despejar logs de pod, com nome da label = myLabel (stdout)</span>
kubectl logs my-pod -c my-container --previous      <span style=color:#080;font-style:italic># despejar logs de um contêiner específico em um pod (stdout, no caso de vários contêineres) para uma instanciação anterior de um contêiner</span>
kubectl logs -f my-pod                              <span style=color:#080;font-style:italic># Fluxo de logs de pod (stdout)</span>
kubectl logs -f my-pod -c my-container              <span style=color:#080;font-style:italic># Fluxo de logs para um específico contêiner em um pod (stdout, caixa com vários contêineres)</span>
kubectl logs -f -l <span style=color:#b8860b>name</span><span style=color:#666>=</span>myLabel --all-containers    <span style=color:#080;font-style:italic># transmitir todos os logs de pods com a label name=myLabel (stdout)</span>
kubectl run -i --tty busybox --image<span style=color:#666>=</span>busybox -- sh  <span style=color:#080;font-style:italic># Executar pod como shell interativo</span>
kubectl run nginx --image<span style=color:#666>=</span>nginx --restart<span style=color:#666>=</span>Never -n 
mynamespace                                         <span style=color:#080;font-style:italic># Execute o pod nginx em um namespace específico</span>
kubectl run nginx --image<span style=color:#666>=</span>nginx --restart<span style=color:#666>=</span>Never     <span style=color:#080;font-style:italic># Execute o pod nginx e salve suas especificações em um arquivo chamado pod.yaml</span>
--dry-run -o yaml &gt; pod.yaml

kubectl attach my-pod -i                            <span style=color:#080;font-style:italic># Anexar ao contêiner em execução</span>
kubectl port-forward my-pod 5000:6000               <span style=color:#080;font-style:italic># Ouça na porta 5000 na máquina local e encaminhe para a porta 6000 no my-pod</span>
kubectl <span style=color:#a2f>exec</span> my-pod -- ls /                         <span style=color:#080;font-style:italic># Executar comando no pod existente (1 contêiner)</span>
kubectl <span style=color:#a2f>exec</span> my-pod -c my-container -- ls /         <span style=color:#080;font-style:italic># Executar comando no pod existente (pod com vários contêineres)</span>
kubectl top pod POD_NAME --containers               <span style=color:#080;font-style:italic># Mostrar métricas para um determinado pod e seus contêineres</span>
</code></pre></div><h2 id=interagindo-com-nós-e-cluster>Interagindo com Nós e Cluster</h2>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl cordon my-node                                                <span style=color:#080;font-style:italic># Marcar o nó my-node como não agendável</span>
kubectl drain my-node                                                 <span style=color:#080;font-style:italic># Drene o nó my-node na preparação para manutenção</span>
kubectl uncordon my-node                                              <span style=color:#080;font-style:italic># Marcar nó my-node como agendável</span>
kubectl top node my-node                                              <span style=color:#080;font-style:italic># Mostrar métricas para um determinado nó</span>
kubectl cluster-info                                                  <span style=color:#080;font-style:italic># Exibir endereços da master e serviços</span>
kubectl cluster-info dump                                             <span style=color:#080;font-style:italic># Despejar o estado atual do cluster no stdout</span>
kubectl cluster-info dump --output-directory<span style=color:#666>=</span>/path/to/cluster-state   <span style=color:#080;font-style:italic># Despejar o estado atual do cluster em /path/to/cluster-state</span>

<span style=color:#080;font-style:italic># Se uma `taint` com essa chave e efeito já existir, seu valor será substituído conforme especificado.</span>
kubectl taint nodes foo <span style=color:#b8860b>dedicated</span><span style=color:#666>=</span>special-user:NoSchedule
</code></pre></div><h3 id=tipos-de-recursos>Tipos de Recursos</h3>
<p>Listar todos os tipos de recursos suportados, juntamente com seus nomes abreviados, <a href=/docs/concepts/overview/kubernetes-api/#api-groups>Grupo de API</a>, se eles são por <a href=/docs/concepts/overview/working-with-objects/namespaces>namespaces</a>, e <a href=/docs/concepts/overview/working-with-objects/kubernetes-objects>objetos</a>:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl api-resources
</code></pre></div><p>Outras operações para explorar os recursos da API:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl api-resources --namespaced<span style=color:#666>=</span><span style=color:#a2f>true</span>      <span style=color:#080;font-style:italic># Todos os recursos com namespace</span>
kubectl api-resources --namespaced<span style=color:#666>=</span><span style=color:#a2f>false</span>     <span style=color:#080;font-style:italic># Todos os recursos sem namespace</span>
kubectl api-resources -o name                <span style=color:#080;font-style:italic># Todos os recursos com saída simples (apenas o nome do recurso)</span>
kubectl api-resources -o wide                <span style=color:#080;font-style:italic># Todos os recursos com saída expandida (também conhecida como &#34;ampla&#34;)</span>
kubectl api-resources --verbs<span style=color:#666>=</span>list,get       <span style=color:#080;font-style:italic># Todos os recursos que suportam os verbos de API &#34;list&#34; e &#34;get&#34;</span>
kubectl api-resources --api-group<span style=color:#666>=</span>extensions <span style=color:#080;font-style:italic># Todos os recursos no grupo de API &#34;extensions&#34;</span>
</code></pre></div><h3 id=formatação-de-saída>Formatação de Saída</h3>
<p>Para enviar detalhes para a janela do terminal em um formato específico, adicione a flag <code>-o</code> (ou <code>--output</code>) para um comando <code>kubectl</code> suportado.</p>
<table>
<thead>
<tr>
<th>Formato de saída</th>
<th>Descrição</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>-o=custom-columns=&lt;spec></code></td>
<td>Imprimir uma tabela usando uma lista separada por vírgula de colunas personalizadas</td>
</tr>
<tr>
<td><code>-o=custom-columns-file=&lt;filename></code></td>
<td>Imprima uma tabela usando o modelo de colunas personalizadas no arquivo <code>&lt;nome do arquivo></code></td>
</tr>
<tr>
<td><code>-o=json</code></td>
<td>Saída de um objeto de API formatado em JSON</td>
</tr>
<tr>
<td><code>-o=jsonpath=&lt;template></code></td>
<td>Imprima os campos definidos em uma expressão <a href=/docs/reference/kubectl/jsonpath>jsonpath</a></td>
</tr>
<tr>
<td><code>-o=jsonpath-file=&lt;filename></code></td>
<td>Imprima os campos definidos pela expressão <a href=/docs/reference/kubectl/jsonpath>jsonpath</a> no arquivo <code>&lt;nome do arquivo></code></td>
</tr>
<tr>
<td><code>-o=name</code></td>
<td>Imprima apenas o nome do recurso e nada mais</td>
</tr>
<tr>
<td><code>-o=wide</code></td>
<td>Saída no formato de texto sem formatação com qualquer informação adicional e, para pods, o nome do nó está incluído</td>
</tr>
<tr>
<td><code>-o=yaml</code></td>
<td>Saída de um objeto de API formatado em YAML</td>
</tr>
</tbody>
</table>
<h3 id=verbosidade-da-saída-do-kubectl-e-debugging>Verbosidade da Saída do Kubectl e Debugging</h3>
<p>A verbosidade do Kubectl é controlado com os sinalizadores <code>-v</code> ou<code> --v</code> seguidos por um número inteiro representando o nível do log. As convenções gerais de log do Kubernetes e os níveis de log associados são descritos <a href=https://github.com/kubernetes/community/blob/master/contributors/devel/sig-instrumentation/logging.md>aqui</a>.</p>
<table>
<thead>
<tr>
<th>Verbosidade</th>
<th>Descrição</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>--v=0</code></td>
<td>Geralmente útil para <em>sempre</em> estar visível para um operador de cluster.</td>
</tr>
<tr>
<td><code>--v=1</code></td>
<td>Um nível de log padrão razoável se você não deseja verbosidade.</td>
</tr>
<tr>
<td><code>--v=2</code></td>
<td>Informações úteis sobre o estado estacionário sobre o serviço e mensagens importantes de log que podem se correlacionar com alterações significativas no sistema. Este é o nível de log padrão recomendado para a maioria dos sistemas.</td>
</tr>
<tr>
<td><code>--v=3</code></td>
<td>Informações estendidas sobre alterações.</td>
</tr>
<tr>
<td><code>--v=4</code></td>
<td>Detalhamento no nível de debugging.</td>
</tr>
<tr>
<td><code>--v=6</code></td>
<td>Exibir os recursos solicitados.</td>
</tr>
<tr>
<td><code>--v=7</code></td>
<td>Exibir cabeçalhos de solicitação HTTP.</td>
</tr>
<tr>
<td><code>--v=8</code></td>
<td>Exibir conteúdo da solicitação HTTP.</td>
</tr>
<tr>
<td><code>--v=9</code></td>
<td>Exiba o conteúdo da solicitação HTTP sem o truncamento do conteúdo.</td>
</tr>
</tbody>
</table>
<h2 id=próximos-passos>Próximos passos</h2>
<ul>
<li>
<p>Saiba mais em <a href=/docs/reference/kubectl/overview/>Visão geral do kubectl</a>.</p>
</li>
<li>
<p>Veja as opções do <a href=/docs/reference/kubectl/kubectl/>kubectl</a>.</p>
</li>
<li>
<p>Veja as <a href=/docs/reference/kubectl/conventions/>Convenções de uso do kubectl</a> para entender como usá-lo em scripts reutilizáveis.</p>
</li>
<li>
<p>Ver mais comunidade <a href=https://github.com/dennyzhang/cheatsheet-kubernetes-A4>kubectl cheatsheets</a>.</p>
</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-4f002b9458521ca7afd32176fd590646>6 - Ferramentas</h1>
<p>O Kubernetes contém várias ferramentas internas para ajudá-lo a trabalhar com o sistema Kubernetes.</p>
<h2 id=kubectl>Kubectl</h2>
<p><a href=/docs/tasks/tools/install-kubectl/><code>kubectl</code></a> é a ferramenta de linha de comando para o Kubernetes. Ela controla o gerenciador de cluster do Kubernetes.</p>
<h2 id=kubeadm>Kubeadm</h2>
<p><a href=/docs/setup/production-environment/tools/kubeadm/install-kubeadm/><code>kubeadm</code></a> é a ferramenta de linha de comando para provisionar facilmente um cluster Kubernetes seguro sobre servidores físicos ou na nuvem ou em máquinas virtuais (atualmente em alfa).</p>
<h2 id=minikube>Minikube</h2>
<p><a href=/docs/tasks/tools/install-minikube/><code>minikube</code></a> é uma ferramenta que facilita a execução local de um cluster Kubernetes de nó único em sua estação de trabalho para fins de desenvolvimento e teste.</p>
<h2 id=dashboard>Dashboard</h2>
<p><a href=/docs/tasks/access-application-cluster/web-ui-dashboard/><code>Dashboard</code></a>, a interface Web do Kubernetes, permite implantar aplicativos em contêiner em um cluster do Kubernetes, solucionar problemas e gerenciar o cluster e seus próprios recursos.</p>
<h2 id=helm>Helm</h2>
<p><a href=https://github.com/kubernetes/helm><code>Kubernetes Helm</code></a> é uma ferramenta para gerenciar pacotes de recursos pré-configurados do Kubernetes, também conhecidos como Kubernetes charts.</p>
<p>Use o Helm para:</p>
<ul>
<li>Encontrar e usar softwares populares empacotados como Kubernetes charts</li>
<li>Compartilhar seus próprios aplicativos como Kubernetes charts</li>
<li>Criar builds reproduzíveis de seus aplicativos Kubernetes</li>
<li>Gerenciar de forma inteligente os arquivos de manifesto do Kubernetes</li>
<li>Gerenciar versões dos pacotes Helm</li>
</ul>
<h2 id=kompose>Kompose</h2>
<p><a href=https://github.com/kubernetes-incubator/kompose><code>Kompose</code></a> é uma ferramenta para ajudar os usuários do Docker Compose a migrar para o Kubernetes.</p>
<p>Use o Kompose para:</p>
<ul>
<li>Converter um arquivo Docker Compose em objetos Kubernetes</li>
<li>Ir do desenvolvimento local do Docker ao gerenciamento de seu aplicativo via Kubernetes</li>
<li>Converter arquivos <code>yaml</code> do Docker Compose v1 ou v2 ou <a href=https://docs.docker.com/compose/bundles/>Bundles de Aplicativos Distribuídos</a></li>
</ul>
</div>
</main>
</div>
</div>
<footer class=d-print-none>
<div class=footer__links>
<nav>
<a class=text-white href=/pt-br/docs/home/>Home</a>
<a class=text-white href=/pt-br/blog/>Blog</a>
<a class=text-white href=/pt-br/partners/>Parceiros</a>
<a class=text-white href=/pt-br/community/>Comunidade</a>
<a class=text-white href=/pt-br/case-studies/>Casos de estudo</a>
</nav>
</div>
<div class=container-fluid>
<div class=row>
<div class="col-6 col-sm-2 text-xs-center order-sm-2">
<ul class="list-inline mb-0">
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="User mailing list" aria-label="User mailing list">
<a class=text-white target=_blank href=https://discuss.kubernetes.io>
<i class="fa fa-envelope"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Twitter aria-label=Twitter>
<a class=text-white target=_blank href=https://twitter.com/kubernetesio>
<i class="fab fa-twitter"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Calendar aria-label=Calendar>
<a class=text-white target=_blank href="https://calendar.google.com/calendar/embed?src=calendar%40kubernetes.io">
<i class="fas fa-calendar-alt"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Youtube aria-label=Youtube>
<a class=text-white target=_blank href=https://youtube.com/kubernetescommunity>
<i class="fab fa-youtube"></i>
</a>
</li>
</ul>
</div>
<div class="col-6 col-sm-2 text-right text-xs-center order-sm-3">
<ul class="list-inline mb-0">
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub>
<a class=text-white target=_blank href=https://github.com/kubernetes/kubernetes>
<i class="fab fa-github"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Slack aria-label=Slack>
<a class=text-white target=_blank href=https://slack.k8s.io>
<i class="fab fa-slack"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Contribute aria-label=Contribute>
<a class=text-white target=_blank href=https://git.k8s.io/community/contributors/guide>
<i class="fas fa-edit"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Stack Overflow" aria-label="Stack Overflow">
<a class=text-white target=_blank href=https://stackoverflow.com/questions/tagged/kubernetes>
<i class="fab fa-stack-overflow"></i>
</a>
</li>
</ul>
</div>
<div class="col-12 col-sm-8 text-center order-sm-2">
<small class=text-white>&copy; 2023 Os autores do Kubernetes | Documentação Distribuída sob <a href=https://git.k8s.io/website/LICENSE class=light-text>CC BY 4.0</a></small>
<br>
<small class=text-white>Copyright &copy; 2023 A Fundação Linux &reg;. Todos os direitos reservados. A Linux Foundation tem marcas registradas e usa marcas registradas. Para uma lista de marcas registradas da The Linux Foundation, por favor, veja nossa <a href=https://www.linuxfoundation.org/trademark-usage class=light-text>Página de uso de marca registrada</a></small>
<br>
<small class=text-white>ICP license: 京ICP备17074266号-3</small>
</div>
</div>
</div>
</footer>
</div>
<script src=/js/popper-1.14.3.min.js integrity=sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49 crossorigin=anonymous></script>
<script src=/js/bootstrap-4.3.1.min.js integrity=sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM crossorigin=anonymous></script>
<script src=/js/main.min.40616251a9b6e4b689e7769be0340661efa4d7ebb73f957404e963e135b4ed52.js integrity="sha256-QGFiUam25LaJ53ab4DQGYe+k1+u3P5V0BOlj4TW07VI=" crossorigin=anonymous></script>
</body>
</html>