<!doctype html><html lang=ja class=no-js>
<head>
<meta name=ROBOTS content="NOINDEX, NOFOLLOW">
<script async src="https://www.googletagmanager.com/gtag/js?id=G-JPP6RFM2BP"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-JPP6RFM2BP')</script>
<link rel=alternate hreflang=en href=https://kubernetes.io/docs/concepts/workloads/controllers/>
<link rel=alternate hreflang=zh href=https://kubernetes.io/zh/docs/concepts/workloads/controllers/>
<link rel=alternate hreflang=ko href=https://kubernetes.io/ko/docs/concepts/workloads/controllers/>
<link rel=alternate hreflang=fr href=https://kubernetes.io/fr/docs/concepts/workloads/controllers/>
<link rel=alternate hreflang=es href=https://kubernetes.io/es/docs/concepts/workloads/controllers/>
<link rel=alternate hreflang=pt-br href=https://kubernetes.io/pt-br/docs/concepts/workloads/controllers/>
<link rel=alternate hreflang=id href=https://kubernetes.io/id/docs/concepts/workloads/controllers/>
<link rel=alternate hreflang=uk href=https://kubernetes.io/uk/docs/concepts/workloads/controllers/>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=generator content="Hugo 0.87.0">
<link rel=canonical type=text/html href=https://kubernetes.io/ja/docs/concepts/workloads/controllers/>
<link rel="shortcut icon" type=image/png href=/images/favicon.png>
<link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180>
<link rel=manifest href=/manifest.webmanifest>
<link rel=apple-touch-icon href=/images/kubernetes-192x192.png>
<title>ワークロードリソース | Kubernetes</title><meta property="og:title" content="ワークロードリソース">
<meta property="og:description" content="プロダクショングレードのコンテナ管理基盤">
<meta property="og:type" content="website">
<meta property="og:url" content="https://kubernetes.io/ja/docs/concepts/workloads/controllers/"><meta property="og:site_name" content="Kubernetes">
<meta itemprop=name content="ワークロードリソース">
<meta itemprop=description content="プロダクショングレードのコンテナ管理基盤"><meta name=twitter:card content="summary">
<meta name=twitter:title content="ワークロードリソース">
<meta name=twitter:description content="プロダクショングレードのコンテナ管理基盤">
<link href=/scss/main.css rel=stylesheet>
<script src=/js/jquery-3.3.1.min.js integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin=anonymous></script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","url":"https://kubernetes.io","logo":"https://kubernetes.io/images/favicon.png"}</script>
<meta name=theme-color content="#326ce5">
<link rel=stylesheet href=/css/feature-states.css>
<meta name=description content>
<meta property="og:description" content>
<meta name=twitter:description content>
<meta property="og:url" content="https://kubernetes.io/ja/docs/concepts/workloads/controllers/">
<meta property="og:title" content="ワークロードリソース">
<meta name=twitter:title content="ワークロードリソース">
<meta name=twitter:image content="https://kubernetes.io/images/favicon.png">
<meta name=twitter:image:alt content="Kubernetes">
<meta property="og:image" content="/images/kubernetes-horizontal-color.png">
<meta property="og:type" content="article">
<script src=/js/script.js></script>
</head>
<body class=td-section>
<header>
<nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar" data-auto-burger=primary>
<a class=navbar-brand href=/ja/></a>
<div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar>
<ul class="navbar-nav mt-2 mt-lg-0">
<li class="nav-item mr-2 mb-lg-0">
<a class="nav-link active" href=/ja/docs/>ドキュメント</a>
</li>
<li class="nav-item mr-2 mb-lg-0">
<a class=nav-link href=/ja/blog/>Blogs</a>
</li>
<li class="nav-item mr-2 mb-lg-0">
<a class=nav-link href=/ja/training/>トレーニング</a>
</li>
<li class="nav-item mr-2 mb-lg-0">
<a class=nav-link href=/ja/partners/>パートナー</a>
</li>
<li class="nav-item mr-2 mb-lg-0">
<a class=nav-link href=/ja/community/>コミュニティ</a>
</li>
<li class="nav-item mr-2 mb-lg-0">
<a class=nav-link href=/ja/case-studies/>ケーススタディ</a>
</li>
<li class="nav-item dropdown">
<a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>
バージョン
</a>
<div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink>
<a class=dropdown-item href=/releases>Release Information</a>
<a class=dropdown-item href=https://kubernetes.io/ja/docs/concepts/workloads/controllers/>v1.27</a>
<a class=dropdown-item href=https://v1-26.docs.kubernetes.io/ja/docs/concepts/workloads/controllers/>v1.26</a>
<a class=dropdown-item href=https://v1-25.docs.kubernetes.io/ja/docs/concepts/workloads/controllers/>v1.25</a>
<a class=dropdown-item href=https://v1-24.docs.kubernetes.io/ja/docs/concepts/workloads/controllers/>v1.24</a>
<a class=dropdown-item href=https://v1-23.docs.kubernetes.io/ja/docs/concepts/workloads/controllers/>v1.23</a>
</div>
</li>
<li class="nav-item dropdown">
<a class="nav-link dropdown-toggle" href=# id=navbarDropdownMenuLink role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>
日本語 Japanese
</a>
<div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink>
<a class=dropdown-item href=/docs/concepts/workloads/controllers/>English</a>
<a class=dropdown-item href=/zh/docs/concepts/workloads/controllers/>中文 Chinese</a>
<a class=dropdown-item href=/ko/docs/concepts/workloads/controllers/>한국어 Korean</a>
<a class=dropdown-item href=/fr/docs/concepts/workloads/controllers/>Français</a>
<a class=dropdown-item href=/es/docs/concepts/workloads/controllers/>Español</a>
<a class=dropdown-item href=/pt-br/docs/concepts/workloads/controllers/>Português</a>
<a class=dropdown-item href=/id/docs/concepts/workloads/controllers/>Bahasa Indonesia</a>
<a class=dropdown-item href=/uk/docs/concepts/workloads/controllers/>Українська</a>
</div>
</li>
</ul>
</div>
<button id=hamburger onclick=kub.toggleMenu() data-auto-burger-exclude><div></div></button>
</nav>
</header>
<div class="container-fluid td-outer">
<div class=td-main>
<div class="row flex-xl-nowrap">
<main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main>
<div class=td-content>
<div class="pageinfo pageinfo-primary d-print-none">
<p>
これは、このセクションの複数ページの印刷可能なビューです。
<a href=# onclick="return print(),!1">印刷するには、ここをクリックしてください</a>.
</p><p>
<a href=/ja/docs/concepts/workloads/controllers/>このページの通常のビューに戻る</a>.
</p>
</div>
<h1 class=title>ワークロードリソース</h1>
<ul>
<li>1: <a href=#pg-a2dc0393e0c4079e1c504b6429844e86>Deployment</a></li>
<li>2: <a href=#pg-d459b930218774655fa7fd1620625539>ReplicaSet</a></li>
<li>3: <a href=#pg-6d72299952c37ca8cc61b416e5bdbcd4>StatefulSet</a></li>
<li>4: <a href=#pg-41600eb8b6631c88848156f381e9d588>DaemonSet</a></li>
<li>5: <a href=#pg-9add0d2120634b63073ad08dc8683bd6>ガベージコレクション</a></li>
<li>6: <a href=#pg-4de50a37ebb6f2340484192126cb7a04>終了したリソースのためのTTLコントローラー(TTL Controller for Finished Resources)</a></li>
<li>7: <a href=#pg-2e4cec01c525b45eccd6010e21cc76d9>CronJob</a></li>
</ul>
<div class=content>
</div>
</div>
<div class=td-content>
<h1 id=pg-a2dc0393e0c4079e1c504b6429844e86>1 - Deployment</h1>
<p><em>Deployment</em> は<a class=glossary-tooltip title="一番小さく一番シンプルな Kubernetes のオブジェクト。Pod とはクラスターで動作しているいくつかのコンテナのまとまりです。" data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a>と<a class=glossary-tooltip title=ReplicaSetは、指定された数のPodレプリカが一度に動作するように保証します。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/controllers/replicaset/ target=_blank aria-label=ReplicaSet>ReplicaSet</a>の宣言的なアップデート機能を提供します。</p>
<p>Deploymentにおいて <em>理想的な状態</em> を記述すると、Deployment<a class=glossary-tooltip title=クラスターの状態をAPIサーバーから取得、見張る制御ループで、現在の状態を望ましい状態に移行するように更新します。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/architecture/controller/ target=_blank aria-label=コントローラー>コントローラー</a>は指定された頻度で現在の状態を理想的な状態に変更します。Deploymentを定義することによって、新しいReplicaSetを作成したり、既存のDeploymentを削除して新しいDeploymentで全てのリソースを適用できます。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> Deploymentによって作成されたReplicaSetを管理しないでください。ご自身のユースケースが以下の項目に含まれない場合、メインのKubernetesリポジトリーにIssueを作成することを検討してください。
</div>
<h2 id=ユースケース>ユースケース</h2>
<p>以下の項目はDeploymentの典型的なユースケースです。</p>
<ul>
<li>ReplicaSetをロールアウトするために<a href=#creating-a-deployment>Deploymentの作成</a>を行う: ReplicaSetはバックグラウンドでPodを作成します。Podの作成が完了したかどうかは、ロールアウトのステータスを確認してください。</li>
<li>DeploymentのPodTemplateSpecを更新することにより<a href=#updating-a-deployment>Podの新しい状態を宣言する</a>: 新しいReplicaSetが作成され、Deploymentは指定された頻度で古いReplicaSetから新しいReplicaSetへのPodの移行を管理します。新しいReplicaSetはDeploymentのリビジョンを更新します。</li>
<li>Deploymentの現在の状態が不安定な場合、<a href=#rolling-back-a-deployment>Deploymentのロールバック</a>をする: ロールバックによる各更新作業は、Deploymentのリビジョンを更新します。</li>
<li>より多くの負荷をさばけるように、<a href=#scaling-a-deployment>Deploymentをスケールアップ</a>する。</li>
<li>PodTemplateSpecに対する複数の修正を適用するために<a href=#pausing-and-resuming-a-deployment>Deploymentを停止(Pause)し</a>、それを再開して新しいロールアウトを開始します。</li>
<li><a href=#deployment-status>Deploymentのステータス</a> をロールアウトが失敗したサインとして利用する。</li>
<li>今後必要としない<a href=#clean-up-policy>古いReplicaSetのクリーンアップ</a></li>
</ul>
<h2 id=creating-a-deployment>Deploymentの作成</h2>
<p>以下はDeploymentの例です。これは<code>nginx</code>Podのレプリカを3つ持つReplicaSetを作成します。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/ja/examples/controllers/nginx-deployment.yaml download=controllers/nginx-deployment.yaml><code>controllers/nginx-deployment.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('controllers-nginx-deployment-yaml')" title="Copy controllers/nginx-deployment.yaml to clipboard">
</img>
</div>
<div class=includecode id=controllers-nginx-deployment-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-deployment<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.14.2<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>この例では、</p>
<ul>
<li>
<p><code>.metadata.name</code>フィールドで指定された<code>nginx-deployment</code>という名前のDeploymentが作成されます。</p>
</li>
<li>
<p>このDeploymentは<code>.spec.replicas</code>フィールドで指定された通り、3つのレプリカPodを作成します。</p>
</li>
<li>
<p><code>.spec.selector</code>フィールドは、Deploymentが管理するPodのラベルを定義します。ここでは、Podテンプレートにて定義されたラベル(<code>app: nginx</code>)を選択しています。しかし、PodTemplate自体がそのルールを満たす限り、さらに洗練された方法でセレクターを指定することができます。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> <code>.spec.selector.matchLabels</code>フィールドはキーバリューペアのマップです。
<code>matchLabels</code>マップにおいて、{key, value}というペアは、keyというフィールドの値が"key"で、その演算子が"In"で、値の配列が"value"のみ含むような<code>matchExpressions</code>の要素と等しくなります。
<code>matchLabels</code>と<code>matchExpressions</code>の両方が設定された場合、条件に一致するには両方とも満たす必要があります。
</div>
</li>
<li>
<p><code>template</code>フィールドは、以下のサブフィールドを持ちます。:</p>
<ul>
<li>Podは<code>.metadata.labels</code>フィールドによって指定された<code>app: nginx</code>というラベルがつけられます。</li>
<li>PodTemplate、または<code>.template.spec</code>フィールドは、Podが<code>nginx</code>という名前で<a href=https://hub.docker.com/>Docker Hub</a>にある<code>nginx</code>のバージョン1.14.2が動くコンテナを1つ動かすことを示します。</li>
<li>1つのコンテナを作成し、<code>.spec.template.spec.containers[0].name</code>フィールドを使って<code>nginx</code>という名前をつけます。</li>
</ul>
</li>
</ul>
<p>作成を始める前に、Kubernetesクラスターが稼働していることを確認してください。
上記のDeploymentを作成するためには以下のステップにしたがってください:</p>
<ol>
<li>以下のコマンドを実行してDeploymentを作成してください。</li>
</ol>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/controllers/nginx-deployment.yaml
</code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> 実行したコマンドを<code>kubernetes.io/change-cause</code>というアノテーションに記録するために<code>--record</code>フラグを指定できます。
これは将来的な問題の調査のために有効です。例えば、各Deploymentのリビジョンにおいて実行されたコマンドを見るときに便利です。
</div>
<ol start=2>
<li>Deploymentが作成されたことを確認するために、<code>kubectl get deployments</code>を実行してください。</li>
</ol>
<p>Deploymentがまだ作成中の場合、コマンドの実行結果は以下のとおりです。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>NAME               READY   UP-TO-DATE   AVAILABLE   AGE
nginx-deployment   0/3     <span style=color:#666>0</span>            <span style=color:#666>0</span>           1s
</code></pre></div><p>クラスターにてDeploymentを調査するとき、以下のフィールドが出力されます。</p>
<ul>
<li><code>NAME</code>は、クラスター内にあるDeploymentの名前一覧です。</li>
<li><code>READY</code>は、ユーザーが使用できるアプリケーションのレプリカの数です。使用可能な数/理想的な数の形式で表示されます。</li>
<li><code>UP-TO-DATE</code>は、理想的な状態を満たすためにアップデートが完了したレプリカの数です。</li>
<li><code>AVAILABLE</code>は、ユーザーが利用可能なレプリカの数です。</li>
<li><code>AGE</code>は、アプリケーションが稼働してからの時間です。</li>
</ul>
<p><code>.spec.replicas</code>フィールドの値によると、理想的なレプリカ数は3であることがわかります。</p>
<ol start=3>
<li>Deploymentのロールアウトステータスを確認するために、<code>kubectl rollout status deployment.v1.apps/nginx-deployment</code>を実行してください。</li>
</ol>
<p>コマンドの実行結果は以下のとおりです。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>Waiting <span style=color:#a2f;font-weight:700>for</span> rollout to finish: <span style=color:#666>2</span> out of <span style=color:#666>3</span> new replicas have been updated...
deployment <span style=color:#b44>&#34;nginx-deployment&#34;</span> successfully rolled out
</code></pre></div><ol start=4>
<li>数秒後、再度<code>kubectl get deployments</code>を実行してください。
コマンドの実行結果は以下のとおりです。</li>
</ol>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>NAME               READY   UP-TO-DATE   AVAILABLE   AGE
nginx-deployment   3/3     <span style=color:#666>3</span>            <span style=color:#666>3</span>           18s
</code></pre></div><p>Deploymentが3つ全てのレプリカを作成して、全てのレプリカが最新(Podが最新のPodテンプレートを含んでいる)になり、利用可能となっていることを確認してください。</p>
<ol start=5>
<li>Deploymentによって作成されたReplicaSet(<code>rs</code>)を確認するには<code>kubectl get rs</code>を実行してください。コマンドの実行結果は以下のとおりです:</li>
</ol>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>NAME                          DESIRED   CURRENT   READY   AGE
nginx-deployment-75675f5897   <span style=color:#666>3</span>         <span style=color:#666>3</span>         <span style=color:#666>3</span>       18s
</code></pre></div><p>ReplicaSetの出力には次のフィールドが表示されます:</p>
<ul>
<li><code>NAME</code>は、名前空間内にあるReplicaSetの名前の一覧です。</li>
<li><code>DESIRED</code>は、アプリケーションの理想的な <em>レプリカ</em> の値です。これはDeploymentを作成したときに定義したもので、これが <em>理想的な状態</em> と呼ばれるものです。</li>
<li><code>CURRENT</code>は現在実行されているレプリカの数です。</li>
<li><code>READY</code>は、ユーザーが使用できるアプリケーションのレプリカの数です。</li>
<li><code>AGE</code>は、アプリケーションが稼働してからの時間です。</li>
</ul>
<p>ReplicaSetの名前は<code>[Deployment名]-[ランダム文字列]</code>という形式になることに注意してください。ランダム文字列はランダムに生成され、pod-template-hashをシードとして使用します。</p>
<ol start=6>
<li>各Podにラベルが自動的に付けられるのを確認するには<code>kubectl get pods --show-labels</code>を実行してください。
コマンドの実行結果は以下のとおりです:</li>
</ol>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>NAME                                READY     STATUS    RESTARTS   AGE       LABELS
nginx-deployment-75675f5897-7ci7o   1/1       Running   <span style=color:#666>0</span>          18s       <span style=color:#b8860b>app</span><span style=color:#666>=</span>nginx,pod-template-hash<span style=color:#666>=</span><span style=color:#666>3123191453</span>
nginx-deployment-75675f5897-kzszj   1/1       Running   <span style=color:#666>0</span>          18s       <span style=color:#b8860b>app</span><span style=color:#666>=</span>nginx,pod-template-hash<span style=color:#666>=</span><span style=color:#666>3123191453</span>
nginx-deployment-75675f5897-qqcnn   1/1       Running   <span style=color:#666>0</span>          18s       <span style=color:#b8860b>app</span><span style=color:#666>=</span>nginx,pod-template-hash<span style=color:#666>=</span><span style=color:#666>3123191453</span>
</code></pre></div><p>作成されたReplicaSetは<code>nginx</code>Podを3つ作成することを保証します。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> <p>Deploymentに対して適切なセレクターとPodテンプレートのラベルを設定する必要があります(このケースでは<code>app: nginx</code>)。</p>
<p>ラベルやセレクターを他のコントローラーと重複させないでください(他のDeploymentやStatefulSetを含む)。Kubernetesはユーザーがラベルを重複させることを阻止しないため、複数のコントローラーでセレクターの重複が発生すると、コントローラー間で衝突し予期せぬふるまいをすることになります。</p>
</div>
<h3 id=pod-template-hashラベル>pod-template-hashラベル</h3>
<div class="alert alert-warning caution callout" role=alert>
<strong>注意:</strong> このラベルを変更しないでください。
</div>
<p><code>pod-template-hash</code>ラベルはDeploymentコントローラーによってDeploymentが作成し適用した各ReplicaSetに対して追加されます。</p>
<p>このラベルはDeploymentが管理するReplicaSetが重複しないことを保証します。このラベルはReplicaSetの<code>PodTemplate</code>をハッシュ化することにより生成され、生成されたハッシュ値はラベル値としてReplicaSetセレクター、Podテンプレートラベル、ReplicaSetが作成した全てのPodに対して追加されます。</p>
<h2 id=updating-a-deployment>Deploymentの更新</h2>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> Deploymentのロールアウトは、DeploymentのPodテンプレート(この場合<code>.spec.template</code>)が変更された場合にのみトリガーされます。例えばテンプレートのラベルもしくはコンテナーイメージが更新された場合です。Deploymentのスケールのような更新では、ロールアウトはトリガーされません。
</div>
<p>Deploymentを更新するには以下のステップに従ってください。</p>
<ol>
<li>
<p>nginxのPodで、<code>nginx:1.14.2</code>イメージの代わりに<code>nginx:1.16.1</code>を使うように更新します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl --record deployment.apps/nginx-deployment <span style=color:#a2f>set</span> image deployment.v1.apps/nginx-deployment <span style=color:#b8860b>nginx</span><span style=color:#666>=</span>nginx:1.16.1
</code></pre></div><p>または単に次のコマンドを使用します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#a2f>set</span> image deployment/nginx-deployment <span style=color:#b8860b>nginx</span><span style=color:#666>=</span>nginx:1.16.1 --record
</code></pre></div><p>実行結果は以下のとおりです。</p>
<pre><code>deployment.apps/nginx-deployment image updated
</code></pre><p>また、Deploymentを<code>編集</code>して、<code>.spec.template.spec.containers[0].image</code>を<code>nginx:1.14.2</code>から<code>nginx:1.16.1</code>に変更することができます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl edit deployment.v1.apps/nginx-deployment
</code></pre></div><p>実行結果は以下のとおりです。</p>
<pre><code>deployment.apps/nginx-deployment edited
</code></pre></li>
<li>
<p>ロールアウトのステータスを確認するには、以下のコマンドを実行してください。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl rollout status deployment.v1.apps/nginx-deployment
</code></pre></div><p>実行結果は以下のとおりです。</p>
<pre><code>Waiting for rollout to finish: 2 out of 3 new replicas have been updated...
</code></pre><p>もしくは</p>
<pre><code>deployment &quot;nginx-deployment&quot; successfully rolled out
</code></pre></li>
</ol>
<p>更新されたDeploymentのさらなる情報を取得するには、以下を確認してください。</p>
<ul>
<li>
<p>ロールアウトが成功したあと、<code>kubectl get deployments</code>を実行してDeploymentを確認できます。
実行結果は以下のとおりです。</p>
<pre><code>NAME               READY   UP-TO-DATE   AVAILABLE   AGE
nginx-deployment   3/3     3            3           36s
</code></pre></li>
<li>
<p>Deploymentが新しいReplicaSetを作成してPodを更新させたり、新しいReplicaSetのレプリカを3にスケールアップさせたり、古いReplicaSetのレプリカを0にスケールダウンさせるのを確認するには<code>kubectl get rs</code>を実行してください。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get rs
</code></pre></div><p>実行結果は以下のとおりです。</p>
<pre><code>NAME                          DESIRED   CURRENT   READY   AGE
nginx-deployment-1564180365   3         3         3       6s
nginx-deployment-2035384211   0         0         0       36s
</code></pre></li>
<li>
<p><code>get pods</code>を実行させると、新しいPodのみ確認できます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods
</code></pre></div><p>実行結果は以下のとおりです。</p>
<pre><code>NAME                                READY     STATUS    RESTARTS   AGE
nginx-deployment-1564180365-khku8   1/1       Running   0          14s
nginx-deployment-1564180365-nacti   1/1       Running   0          14s
nginx-deployment-1564180365-z9gth   1/1       Running   0          14s
</code></pre><p>次にPodを更新させたいときは、DeploymentのPodテンプレートを再度更新するだけです。</p>
<p>Deploymentは、Podが更新されている間に特定の数のPodのみ停止状態になることを保証します。デフォルトでは、目標とするPod数の少なくとも25%が停止状態になることを保証します(25% max unavailable)。</p>
<p>また、DeploymentはPodが更新されている間に、目標とするPod数を特定の数まで超えてPodを稼働させることを保証します。デフォルトでは、目標とするPod数に対して最大でも125%を超えてPodを稼働させることを保証します(25% max surge)。</p>
<p>例えば、上記で説明したDeploymentの状態を注意深く見ると、最初に新しいPodが作成され、次に古いPodが削除されるのを確認できます。十分な数の新しいPodが稼働するまでは、Deploymentは古いPodを削除しません。また十分な数の古いPodが削除しない限り新しいPodは作成されません。少なくとも2つのPodが利用可能で、最大でもトータルで4つのPodが利用可能になっていることを保証します。</p>
</li>
<li>
<p>Deploymentの詳細情報を取得します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe deployments
</code></pre></div><p>実行結果は以下のとおりです。</p>
<pre><code>Name:                   nginx-deployment
Namespace:              default
CreationTimestamp:      Thu, 30 Nov 2017 10:56:25 +0000
Labels:                 app=nginx
Annotations:            deployment.kubernetes.io/revision=2
Selector:               app=nginx
Replicas:               3 desired | 3 updated | 3 total | 3 available | 0 unavailable
StrategyType:           RollingUpdate
MinReadySeconds:        0
RollingUpdateStrategy:  25% max unavailable, 25% max surge
Pod Template:
  Labels:  app=nginx
   Containers:
    nginx:
      Image:        nginx:1.16.1
      Port:         80/TCP
      Environment:  &lt;none&gt;
      Mounts:       &lt;none&gt;
    Volumes:        &lt;none&gt;
  Conditions:
    Type           Status  Reason
    ----           ------  ------
    Available      True    MinimumReplicasAvailable
    Progressing    True    NewReplicaSetAvailable
  OldReplicaSets:  &lt;none&gt;
  NewReplicaSet:   nginx-deployment-1564180365 (3/3 replicas created)
  Events:
    Type    Reason             Age   From                   Message
    ----    ------             ----  ----                   -------
    Normal  ScalingReplicaSet  2m    deployment-controller  Scaled up replica set nginx-deployment-2035384211 to 3
    Normal  ScalingReplicaSet  24s   deployment-controller  Scaled up replica set nginx-deployment-1564180365 to 1
    Normal  ScalingReplicaSet  22s   deployment-controller  Scaled down replica set nginx-deployment-2035384211 to 2
    Normal  ScalingReplicaSet  22s   deployment-controller  Scaled up replica set nginx-deployment-1564180365 to 2
    Normal  ScalingReplicaSet  19s   deployment-controller  Scaled down replica set nginx-deployment-2035384211 to 1
    Normal  ScalingReplicaSet  19s   deployment-controller  Scaled up replica set nginx-deployment-1564180365 to 3
    Normal  ScalingReplicaSet  14s   deployment-controller  Scaled down replica set nginx-deployment-2035384211 to 0
</code></pre><p>最初にDeploymentを作成した時、ReplicaSet(nginx-deployment-2035384211)を作成してすぐにレプリカ数を3にスケールするのを確認できます。Deploymentを更新すると新しいReplicaSet(nginx-deployment-1564180365)を作成してレプリカ数を1にスケールアップし、古いReplicaSeetを2にスケールダウンさせます。これは常に最低でも2つのPodが利用可能で、かつ最大4つのPodが作成されている状態にするためです。Deploymentは同じローリングアップ戦略に従って新しいReplicaSetのスケールアップと古いReplicaSetのスケールダウンを続けます。最終的に新しいReplicaSetを3にスケールアップさせ、古いReplicaSetを0にスケールダウンさせます。</p>
</li>
</ul>
<h3 id=ロールオーバー-リアルタイムでの複数のpodの更新>ロールオーバー (リアルタイムでの複数のPodの更新)</h3>
<p>Deploymentコントローラーにより、新しいDeploymentが観測される度にReplicaSetが作成され、理想とするレプリカ数のPodを作成します。Deploymentが更新されると、既存のReplicaSetが管理するPodのラベルが<code>.spec.selector</code>にマッチするが、テンプレートが<code>.spec.template</code>にマッチしない場合はスケールダウンされます。最終的に、新しいReplicaSetは<code>.spec.replicas</code>の値にスケールアップされ、古いReplicaSetは0にスケールダウンされます。</p>
<p>Deploymentのロールアウトが進行中にDeploymentを更新すると、Deploymentは更新する毎に新しいReplicaSetを作成してスケールアップさせ、以前にスケールアップしたReplicaSetのロールオーバーを行います。Deploymentは更新前のReplicaSetを古いReplicaSetのリストに追加し、スケールダウンを開始します。</p>
<p>例えば、5つのレプリカを持つ<code>nginx:1.14.2</code>のDeploymentを作成し、<code>nginx:1.14.2</code>の3つのレプリカが作成されているときに5つのレプリカを持つ<code>nginx:1.16.1</code>に更新します。このケースではDeploymentは作成済みの<code>nginx:1.14.2</code>の3つのPodをすぐに削除し、<code>nginx:1.16.1</code>のPodの作成を開始します。<code>nginx:1.14.2</code>の5つのレプリカを全て作成するのを待つことはありません。</p>
<h3 id=ラベルセレクターの更新>ラベルセレクターの更新</h3>
<p>通常、ラベルセレクターを更新することは推奨されません。事前にラベルセレクターの使い方を計画しておきましょう。いかなる場合であっても更新が必要なときは十分に注意を払い、変更時の影響範囲を把握しておきましょう。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> <code>apps/v1</code>API バージョンにおいて、Deploymentのラベルセレクターは作成後に不変となります。
</div>
<ul>
<li>セレクターの追加は、Deployment Specのテンプレートラベルも新しいラベルで更新する必要があります。そうでない場合はバリデーションエラーが返されます。この変更は重複がない更新となります。これは新しいセレクターは古いセレクターを持つReplicaSetとPodを選択せず、結果として古い全てのReplicaSetがみなし子状態になり、新しいReplicaSetを作成することを意味します。</li>
<li>セレクターの更新により、セレクターキー内の既存の値が変更されます。これにより、セレクターの追加と同じふるまいをします。</li>
<li>セレクターの削除により、Deploymentのセレクターから存在している値を削除します。これはPodテンプレートのラベルに関する変更を要求しません。既存のReplicaSetはみなし子状態にならず、新しいReplicaSetは作成されませんが、削除されたラベルは既存のPodとReplicaSetでは残り続けます。</li>
</ul>
<h2 id=rolling-back-a-deployment>Deploymentのロールバック</h2>
<p>例えば、クラッシュループ状態などのようにDeploymentが不安定な場合においては、Deploymentをロールバックしたくなることがあります。Deploymentの全てのロールアウト履歴は、いつでもロールバックできるようにデフォルトでシステムに保持されています(リビジョン履歴の上限は設定することで変更可能です)。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> Deploymentのリビジョンは、Deploymentのロールアウトがトリガーされた時に作成されます。これはDeploymentのPodテンプレート(<code>.spec.template</code>)が変更されたときのみ新しいリビジョンが作成されることを意味します。Deploymentのスケーリングなど、他の種類の更新においてはDeploymentのリビジョンは作成されません。これは手動もしくはオートスケーリングを同時に行うことができるようにするためです。これは過去のリビジョンにロールバックするとき、DeploymentのPodテンプレートの箇所のみロールバックされることを意味します。
</div>
<ul>
<li>
<p><code>nginx:1.16.1</code>の代わりに<code>nginx:1.161</code>というイメージに更新して、Deploymentの更新中にタイプミスをしたと仮定します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#a2f>set</span> image deployment.v1.apps/nginx-deployment <span style=color:#b8860b>nginx</span><span style=color:#666>=</span>nginx:1.161 --record<span style=color:#666>=</span><span style=color:#a2f>true</span>
</code></pre></div><p>実行結果は以下のとおりです。</p>
<pre><code>deployment.apps/nginx-deployment image updated
</code></pre></li>
<li>
<p>このロールアウトはうまくいきません。ロールアウトのステータスを見るとそれを確認できます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl rollout status deployment.v1.apps/nginx-deployment
</code></pre></div><p>実行結果は以下のとおりです。</p>
<pre><code>Waiting for rollout to finish: 1 out of 3 new replicas have been updated...
</code></pre></li>
<li>
<p>ロールアウトのステータスの確認は、Ctrl-Cを押すことで停止できます。ロールアウトがうまく行かないときは、<a href=#deployment-status>Deploymentのステータス</a>を読んでさらなる情報を得てください。</p>
</li>
<li>
<p>古いレプリカ数(<code>nginx-deployment-1564180365</code> and <code>nginx-deployment-2035384211</code>)が2になっていることを確認でき、新しいレプリカ数(nginx-deployment-3066724191)は1になっています。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get rs
</code></pre></div><p>実行結果は以下のとおりです。</p>
<pre><code>NAME                          DESIRED   CURRENT   READY   AGE
nginx-deployment-1564180365   3         3         3       25s
nginx-deployment-2035384211   0         0         0       36s
nginx-deployment-3066724191   1         1         0       6s
</code></pre></li>
<li>
<p>作成されたPodを確認していると、新しいReplicaSetによって作成された1つのPodはコンテナイメージのpullに失敗し続けているのがわかります。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods
</code></pre></div><p>実行結果は以下のとおりです。</p>
<pre><code>NAME                                READY     STATUS             RESTARTS   AGE
nginx-deployment-1564180365-70iae   1/1       Running            0          25s
nginx-deployment-1564180365-jbqqo   1/1       Running            0          25s
nginx-deployment-1564180365-hysrc   1/1       Running            0          25s
nginx-deployment-3066724191-08mng   0/1       ImagePullBackOff   0          6s
</code></pre><div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> Deploymentコントローラーは、この悪い状態のロールアウトを自動的に停止し、新しいReplicaSetのスケールアップを止めます。これはユーザーが指定したローリングアップデートに関するパラメータ(特に<code>maxUnavailable</code>)に依存します。デフォルトではKubernetesがこの値を25%に設定します。
</div>
</li>
<li>
<p>Deploymentの詳細情報を取得します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe deployment
</code></pre></div><p>実行結果は以下のとおりです。</p>
<pre><code>Name:           nginx-deployment
Namespace:      default
CreationTimestamp:  Tue, 15 Mar 2016 14:48:04 -0700
Labels:         app=nginx
Selector:       app=nginx
Replicas:       3 desired | 1 updated | 4 total | 3 available | 1 unavailable
StrategyType:       RollingUpdate
MinReadySeconds:    0
RollingUpdateStrategy:  25% max unavailable, 25% max surge
Pod Template:
  Labels:  app=nginx
  Containers:
   nginx:
    Image:        nginx:1.161
    Port:         80/TCP
    Host Port:    0/TCP
    Environment:  &lt;none&gt;
    Mounts:       &lt;none&gt;
  Volumes:        &lt;none&gt;
Conditions:
  Type           Status  Reason
  ----           ------  ------
  Available      True    MinimumReplicasAvailable
  Progressing    True    ReplicaSetUpdated
OldReplicaSets:     nginx-deployment-1564180365 (3/3 replicas created)
NewReplicaSet:      nginx-deployment-3066724191 (1/1 replicas created)
Events:
  FirstSeen LastSeen    Count   From                    SubObjectPath   Type        Reason              Message
  --------- --------    -----   ----                    -------------   --------    ------              -------
  1m        1m          1       {deployment-controller }                Normal      ScalingReplicaSet   Scaled up replica set nginx-deployment-2035384211 to 3
  22s       22s         1       {deployment-controller }                Normal      ScalingReplicaSet   Scaled up replica set nginx-deployment-1564180365 to 1
  22s       22s         1       {deployment-controller }                Normal      ScalingReplicaSet   Scaled down replica set nginx-deployment-2035384211 to 2
  22s       22s         1       {deployment-controller }                Normal      ScalingReplicaSet   Scaled up replica set nginx-deployment-1564180365 to 2
  21s       21s         1       {deployment-controller }                Normal      ScalingReplicaSet   Scaled down replica set nginx-deployment-2035384211 to 1
  21s       21s         1       {deployment-controller }                Normal      ScalingReplicaSet   Scaled up replica set nginx-deployment-1564180365 to 3
  13s       13s         1       {deployment-controller }                Normal      ScalingReplicaSet   Scaled down replica set nginx-deployment-2035384211 to 0
  13s       13s         1       {deployment-controller }                Normal      ScalingReplicaSet   Scaled up replica set nginx-deployment-3066724191 to 1
</code></pre><p>これを修正するために、Deploymentを安定した状態の過去のリビジョンに更新する必要があります。</p>
</li>
</ul>
<h3 id=deploymentのロールアウト履歴の確認>Deploymentのロールアウト履歴の確認</h3>
<p>ロールアウトの履歴を確認するには、以下の手順に従って下さい。</p>
<ol>
<li>
<p>最初に、Deploymentのリビジョンを確認します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl rollout <span style=color:#a2f>history</span> deployment.v1.apps/nginx-deployment
</code></pre></div><p>実行結果は以下のとおりです。</p>
<pre><code>deployments &quot;nginx-deployment&quot;
REVISION    CHANGE-CAUSE
1           kubectl apply --filename=https://k8s.io/examples/controllers/nginx-deployment.yaml --record=true
2           kubectl set image deployment.v1.apps/nginx-deployment nginx=nginx:1.16.1 --record=true
3           kubectl set image deployment.v1.apps/nginx-deployment nginx=nginx:1.161 --record=true
</code></pre><p><code>CHANGE-CAUSE</code>はリビジョンの作成時にDeploymentの<code>kubernetes.io/change-cause</code>アノテーションからリビジョンにコピーされます。以下の方法により<code>CHANGE-CAUSE</code>メッセージを指定できます。</p>
<ul>
<li><code>kubectl annotate deployment.v1.apps/nginx-deployment kubernetes.io/change-cause="image updated to 1.16.1"</code>の実行によりアノテーションを追加します。</li>
<li>リソースの変更時に<code>kubectl</code>コマンドの内容を記録するために<code>--record</code>フラグを追加します。</li>
<li>リソースのマニフェストを手動で編集します。</li>
</ul>
</li>
<li>
<p>各リビジョンの詳細を確認するためには以下のコマンドを実行してください。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl rollout <span style=color:#a2f>history</span> deployment.v1.apps/nginx-deployment --revision<span style=color:#666>=</span><span style=color:#666>2</span>
</code></pre></div><p>実行結果は以下のとおりです。</p>
<pre><code>deployments &quot;nginx-deployment&quot; revision 2
  Labels:       app=nginx
          pod-template-hash=1159050644
  Annotations:  kubernetes.io/change-cause=kubectl set image deployment.v1.apps/nginx-deployment nginx=nginx:1.16.1 --record=true
  Containers:
   nginx:
    Image:      nginx:1.16.1
    Port:       80/TCP
     QoS Tier:
        cpu:      BestEffort
        memory:   BestEffort
    Environment Variables:      &lt;none&gt;
  No volumes.
</code></pre></li>
</ol>
<h3 id=rolling-back-to-a-previous-revision>過去のリビジョンにロールバックする</h3>
<p>現在のリビジョンから過去のリビジョン(リビジョン番号2)にロールバックさせるには、以下の手順に従ってください。</p>
<ol>
<li>
<p>現在のリビジョンから過去のリビジョンにロールバックします。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl rollout undo deployment.v1.apps/nginx-deployment
</code></pre></div><p>実行結果は以下のとおりです。</p>
<pre><code>deployment.apps/nginx-deployment rolled back
</code></pre><p>その他に、<code>--to-revision</code>を指定することにより特定のリビジョンにロールバックできます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl rollout undo deployment.v1.apps/nginx-deployment --to-revision<span style=color:#666>=</span><span style=color:#666>2</span>
</code></pre></div><p>実行結果は以下のとおりです。</p>
<pre><code>deployment.apps/nginx-deployment rolled back
</code></pre><p>ロールアウトに関連したコマンドのさらなる情報は<a href=/docs/reference/generated/kubectl/kubectl-commands#rollout><code>kubectl rollout</code></a>を参照してください。</p>
<p>Deploymentが過去の安定したリビジョンにロールバックされました。Deploymentコントローラーによって、リビジョン番号2にロールバックする<code>DeploymentRollback</code>イベントが作成されたのを確認できます。</p>
</li>
<li>
<p>ロールバックが成功し、Deploymentが正常に稼働していることを確認するために、以下のコマンドを実行してください。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get deployment nginx-deployment
</code></pre></div><p>実行結果は以下のとおりです。</p>
<pre><code>NAME               READY   UP-TO-DATE   AVAILABLE   AGE
nginx-deployment   3/3     3            3           30m
</code></pre></li>
<li>
<p>Deploymentの詳細情報を取得します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe deployment nginx-deployment
</code></pre></div><p>実行結果は以下のとおりです。</p>
<pre><code>Name:                   nginx-deployment
Namespace:              default
CreationTimestamp:      Sun, 02 Sep 2018 18:17:55 -0500
Labels:                 app=nginx
Annotations:            deployment.kubernetes.io/revision=4
                        kubernetes.io/change-cause=kubectl set image deployment.v1.apps/nginx-deployment nginx=nginx:1.16.1 --record=true
Selector:               app=nginx
Replicas:               3 desired | 3 updated | 3 total | 3 available | 0 unavailable
StrategyType:           RollingUpdate
MinReadySeconds:        0
RollingUpdateStrategy:  25% max unavailable, 25% max surge
Pod Template:
  Labels:  app=nginx
  Containers:
   nginx:
    Image:        nginx:1.16.1
    Port:         80/TCP
    Host Port:    0/TCP
    Environment:  &lt;none&gt;
    Mounts:       &lt;none&gt;
  Volumes:        &lt;none&gt;
Conditions:
  Type           Status  Reason
  ----           ------  ------
  Available      True    MinimumReplicasAvailable
  Progressing    True    NewReplicaSetAvailable
OldReplicaSets:  &lt;none&gt;
NewReplicaSet:   nginx-deployment-c4747d96c (3/3 replicas created)
Events:
  Type    Reason              Age   From                   Message
  ----    ------              ----  ----                   -------
  Normal  ScalingReplicaSet   12m   deployment-controller  Scaled up replica set nginx-deployment-75675f5897 to 3
  Normal  ScalingReplicaSet   11m   deployment-controller  Scaled up replica set nginx-deployment-c4747d96c to 1
  Normal  ScalingReplicaSet   11m   deployment-controller  Scaled down replica set nginx-deployment-75675f5897 to 2
  Normal  ScalingReplicaSet   11m   deployment-controller  Scaled up replica set nginx-deployment-c4747d96c to 2
  Normal  ScalingReplicaSet   11m   deployment-controller  Scaled down replica set nginx-deployment-75675f5897 to 1
  Normal  ScalingReplicaSet   11m   deployment-controller  Scaled up replica set nginx-deployment-c4747d96c to 3
  Normal  ScalingReplicaSet   11m   deployment-controller  Scaled down replica set nginx-deployment-75675f5897 to 0
  Normal  ScalingReplicaSet   11m   deployment-controller  Scaled up replica set nginx-deployment-595696685f to 1
  Normal  DeploymentRollback  15s   deployment-controller  Rolled back deployment &quot;nginx-deployment&quot; to revision 2
  Normal  ScalingReplicaSet   15s   deployment-controller  Scaled down replica set nginx-deployment-595696685f to 0
</code></pre></li>
</ol>
<h2 id=scaling-a-deployment>Deploymentのスケーリング</h2>
<p>以下のコマンドを実行させてDeploymentをスケールできます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl scale deployment.v1.apps/nginx-deployment --replicas<span style=color:#666>=</span><span style=color:#666>10</span>
</code></pre></div><p>実行結果は以下のとおりです。</p>
<pre><code>deployment.apps/nginx-deployment scaled
</code></pre><p>クラスター内で<a href=/ja/docs/tasks/run-application/horizontal-pod-autoscale-walkthrough/>水平Podオートスケーラー</a>が有効になっていると仮定します。ここでDeploymentのオートスケーラーを設定し、稼働しているPodのCPU使用量に基づいて、稼働させたいPodのレプリカ数の最小値と最大値を設定できます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl autoscale deployment.v1.apps/nginx-deployment --min<span style=color:#666>=</span><span style=color:#666>10</span> --max<span style=color:#666>=</span><span style=color:#666>15</span> --cpu-percent<span style=color:#666>=</span><span style=color:#666>80</span>
</code></pre></div><p>実行結果は以下のとおりです。</p>
<pre><code>deployment.apps/nginx-deployment scaled
</code></pre><h3 id=比例スケーリング>比例スケーリング</h3>
<p>Deploymentのローリングアップデートは、同時に複数のバージョンのアプリケーションの稼働をサポートします。ユーザーやオートスケーラーがローリングアップデートをロールアウト中(更新中もしくは一時停止中)のDeploymentに対して行うと、Deploymentコントローラーはリスクを削減するために既存のアクティブなReplicaSetのレプリカのバランシングを行います。これを<em>比例スケーリング</em> と呼びます。</p>
<p>レプリカ数が10、<a href=#max-surge>maxSurge</a>=3、<a href=#max-unavailable>maxUnavailable</a>=2であるDeploymentが稼働している例です。</p>
<ul>
<li>
<p>Deployment内で10のレプリカが稼働していることを確認します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get deploy
</code></pre></div><p>実行結果は以下のとおりです。</p>
<pre><code>NAME                 DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
nginx-deployment     10        10        10           10          50s
</code></pre></li>
<li>
<p>クラスター内で、解決できない新しいイメージに更新します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#a2f>set</span> image deployment.v1.apps/nginx-deployment <span style=color:#b8860b>nginx</span><span style=color:#666>=</span>nginx:sometag
</code></pre></div><p>実行結果は以下のとおりです。</p>
<pre><code>deployment.apps/nginx-deployment image updated
</code></pre></li>
<li>
<p>イメージの更新は新しいReplicaSet nginx-deployment-1989198191へのロールアウトを開始させます。しかしロールアウトは、上述した<code>maxUnavailable</code>の要求によりブロックされます。ここでロールアウトのステータスを確認します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get rs
</code></pre></div><p>実行結果は以下のとおりです。</p>
<pre><code>NAME                          DESIRED   CURRENT   READY     AGE
nginx-deployment-1989198191   5         5         0         9s
nginx-deployment-618515232    8         8         8         1m
</code></pre></li>
<li>
<p>次にDeploymentのスケーリングをするための新しい要求が発生します。オートスケーラーはDeploymentのレプリカ数を15に増やします。Deploymentコントローラーは新しい5つのレプリカをどこに追加するか決める必要がでてきます。比例スケーリングを使用していない場合、5つのレプリカは全て新しいReplicaSetに追加されます。比例スケーリングでは、追加されるレプリカは全てのReplicaSetに分散されます。比例割合が大きいものはレプリカ数の大きいReplicaSetとなり、比例割合が低いときはレプリカ数の小さいReplicaSetとなります。残っているレプリカはもっとも大きいレプリカ数を持つReplicaSetに追加されます。レプリカ数が0のReplicaSetはスケールアップされません。</p>
</li>
</ul>
<p>上記の例では、3つのレプリカが古いReplicaSetに追加され、2つのレプリカが新しいReplicaSetに追加されました。ロールアウトの処理では、新しいレプリカ数のPodが正常になったと仮定すると、最終的に新しいReplicaSetに全てのレプリカを移動させます。これを確認するためには以下のコマンドを実行して下さい。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get deploy
</code></pre></div><p>実行結果は以下のとおりです。</p>
<pre><code>NAME                 DESIRED   CURRENT   UP-TO-DATE  AVAILABLE   AGE
nginx-deployment     15        18        7           8           7m
</code></pre><p>ロールアウトのステータスでレプリカがどのように各ReplicaSetに追加されるか確認できます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get rs
</code></pre></div><p>実行結果は以下のとおりです。</p>
<pre><code>NAME                          DESIRED   CURRENT  READY     AGE
nginx-deployment-1989198191   7         7        0         7m
nginx-deployment-618515232    11        11       11        7m
</code></pre><h2 id=pausing-and-resuming-a-deployment>Deployment更新の一時停止と再開</h2>
<p>ユーザーは1つ以上の更新処理をトリガーする前に更新の一時停止と再開ができます。これにより、不必要なロールアウトを実行することなく一時停止と再開を行う間に複数の修正を反映できます。</p>
<ul>
<li>
<p>例えば、作成直後のDeploymentを考えます。
Deploymentの詳細情報を確認します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get deploy
</code></pre></div><p>実行結果は以下のとおりです。</p>
<pre><code>NAME      DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
nginx     3         3         3            3           1m
</code></pre><p>ロールアウトのステータスを確認します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get rs
</code></pre></div><p>実行結果は以下のとおりです。</p>
<pre><code>NAME               DESIRED   CURRENT   READY     AGE
nginx-2142116321   3         3         3         1m
</code></pre></li>
<li>
<p>以下のコマンドを実行して更新処理の一時停止を行います。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl rollout pause deployment.v1.apps/nginx-deployment
</code></pre></div><p>実行結果は以下のとおりです。</p>
<pre><code>deployment.apps/nginx-deployment paused
</code></pre></li>
<li>
<p>次にDeploymentのイメージを更新します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#a2f>set</span> image deployment.v1.apps/nginx-deployment <span style=color:#b8860b>nginx</span><span style=color:#666>=</span>nginx:1.16.1
</code></pre></div><p>実行結果は以下のとおりです。</p>
<pre><code>deployment.apps/nginx-deployment image updated
</code></pre></li>
<li>
<p>新しいロールアウトが開始されていないことを確認します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl rollout <span style=color:#a2f>history</span> deployment.v1.apps/nginx-deployment
</code></pre></div><p>実行結果は以下のとおりです。</p>
<pre><code>deployments &quot;nginx&quot;
REVISION  CHANGE-CAUSE
1   &lt;none&gt;
</code></pre></li>
<li>
<p>Deploymentの更新に成功したことを確認するためにロールアウトのステータスを確認します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get rs
</code></pre></div><p>実行結果は以下のとおりです。</p>
<pre><code>NAME               DESIRED   CURRENT   READY     AGE
nginx-2142116321   3         3         3         2m
</code></pre></li>
<li>
<p>更新は何度でも実行できます。例えば、Deploymentが使用するリソースを更新します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#a2f>set</span> resources deployment.v1.apps/nginx-deployment -c<span style=color:#666>=</span>nginx --limits<span style=color:#666>=</span><span style=color:#b8860b>cpu</span><span style=color:#666>=</span>200m,memory<span style=color:#666>=</span>512Mi
</code></pre></div><p>実行結果は以下のとおりです。</p>
<pre><code>deployment.apps/nginx-deployment resource requirements updated
</code></pre><p>一時停止する前の初期状態では更新処理は機能しますが、Deploymentが一時停止されている間は新しい更新処理は反映されません。</p>
</li>
<li>
<p>最後に、Deploymentの稼働を再開させ、新しいReplicaSetが更新内容を全て反映させているのを確認します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl rollout resume deployment.v1.apps/nginx-deployment
</code></pre></div><p>実行結果は以下のとおりです。</p>
<pre><code>deployment.apps/nginx-deployment resumed
</code></pre></li>
<li>
<p>更新処理が完了するまでロールアウトのステータスを確認します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get rs -w
</code></pre></div><p>実行結果は以下のとおりです。</p>
<pre><code>NAME               DESIRED   CURRENT   READY     AGE
nginx-2142116321   2         2         2         2m
nginx-3926361531   2         2         0         6s
nginx-3926361531   2         2         1         18s
nginx-2142116321   1         2         2         2m
nginx-2142116321   1         2         2         2m
nginx-3926361531   3         2         1         18s
nginx-3926361531   3         2         1         18s
nginx-2142116321   1         1         1         2m
nginx-3926361531   3         3         1         18s
nginx-3926361531   3         3         2         19s
nginx-2142116321   0         1         1         2m
nginx-2142116321   0         1         1         2m
nginx-2142116321   0         0         0         2m
nginx-3926361531   3         3         3         20s
</code></pre></li>
<li>
<p>最新のロールアウトのステータスを確認します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get rs
</code></pre></div><p>実行結果は以下のとおりです。</p>
<pre><code>NAME               DESIRED   CURRENT   READY     AGE
nginx-2142116321   0         0         0         2m
nginx-3926361531   3         3         3         28s
</code></pre></li>
</ul>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> Deploymentの稼働を再開させない限り、一時停止したDeploymentをロールバックすることはできません。
</div>
<h2 id=deployment-status>Deploymentのステータス</h2>
<p>Deploymentは、そのライフサイクルの間に様々な状態に遷移します。新しいReplicaSetへのロールアウト中は<a href=#progressing-deployment>進行中</a>になり、その後は<a href=#complete-deployment>完了</a>し、また<a href=#failed-deployment>失敗</a>にもなります。</p>
<h3 id=progressing-deployment>Deploymentの更新処理</h3>
<p>以下のタスクが実行中のとき、KubernetesはDeploymentの状態を <em>進行中</em> にします。</p>
<ul>
<li>Deploymentが新しいReplicaSetを作成します。</li>
<li>Deploymentが新しいReplicaSetをスケールアップさせています。</li>
<li>Deploymentが古いReplicaSetをスケールダウンさせています。</li>
<li>新しいPodが準備中もしくは利用可能な状態になります(少なくとも<a href=#min-ready-seconds>MinReadySeconds</a>の間は準備中になります)。</li>
</ul>
<p><code>kubectl rollout status</code>を実行すると、Deploymentの進行状態を確認できます。</p>
<h3 id=complete-deployment>Deploymentの更新処理の完了</h3>
<p>Deploymentが以下の状態になったとき、KubernetesはDeploymentのステータスを <em>完了</em> にします。</p>
<ul>
<li>Deploymentの全てのレプリカが、指定された最新のバージョンに更新されます。これは指定した更新処理が完了したことを意味します。</li>
<li>Deploymentの全てのレプリカが利用可能になります。</li>
<li>Deploymentの古いレプリカが1つも稼働していません。</li>
</ul>
<p><code>kubectl rollout status</code>を実行して、Deploymentの更新が完了したことを確認できます。ロールアウトが正常に完了すると<code>kubectl rollout status</code>の終了コードが0で返されます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl rollout status deployment.v1.apps/nginx-deployment
</code></pre></div><p>実行結果は以下のとおりです。</p>
<pre><code>Waiting for rollout to finish: 2 of 3 updated replicas are available...
deployment &quot;nginx-deployment&quot; successfully rolled out
</code></pre><p>そして<code>kubectl rollout</code>の終了ステータスが0となります（成功です）:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#a2f>echo</span> <span style=color:#b8860b>$?</span>
</code></pre></div><pre><code>0
</code></pre><h3 id=failed-deployment>Deploymentの更新処理の失敗</h3>
<p>新しいReplicaSetのデプロイが完了せず、更新処理が止まる場合があります。これは主に以下の要因によるものです。</p>
<ul>
<li>不十分なリソースの割り当て</li>
<li>ReadinessProbeの失敗</li>
<li>コンテナイメージの取得ができない</li>
<li>不十分なパーミッション</li>
<li>リソースリミットのレンジ</li>
<li>アプリケーションランタイムの設定の不備</li>
</ul>
<p>このような状況を検知する1つの方法として、Deploymentのリソース定義でデッドラインのパラメータを指定します(<a href=#progress-deadline-seconds><code>.spec.progressDeadlineSeconds</code></a>)。<code>.spec.progressDeadlineSeconds</code>はDeploymentの更新が停止したことを示す前にDeploymentコントローラーが待つ秒数を示します。</p>
<p>以下の<code>kubectl</code>コマンドでリソース定義に<code>progressDeadlineSeconds</code>を設定します。これはDeploymentの更新が止まってから10分後に、コントローラーが失敗を通知させるためです。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl patch deployment.v1.apps/nginx-deployment -p <span style=color:#b44>&#39;{&#34;spec&#34;:{&#34;progressDeadlineSeconds&#34;:600}}&#39;</span>
</code></pre></div><p>実行結果は以下のとおりです。</p>
<pre><code>deployment.apps/nginx-deployment patched
</code></pre><p>一度デッドラインを超過すると、DeploymentコントローラーはDeploymentの<code>.status.conditions</code>に以下のDeploymentConditionを追加します。</p>
<ul>
<li>Type=Progressing</li>
<li>Status=False</li>
<li>Reason=ProgressDeadlineExceeded</li>
</ul>
<p>ステータスの状態に関するさらなる情報は<a href=https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#typical-status-properties>Kubernetes APIの規則</a>を参照してください。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> Kubernetesは停止状態のDeploymentに対して、ステータス状態を報告する以外のアクションを実行しません。高レベルのオーケストレーターはこれを利用して、状態に応じて行動できます。例えば、前のバージョンへのDeploymentのロールバックが挙げられます。
</div>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> Deploymentを停止すると、Kubernetesは指定したデッドラインを超えたかどうかチェックしません。
ロールアウトの途中でもDeploymentを安全に一時停止でき、デッドラインを超えたイベントをトリガーすることなく再開できます。
</div>
<p>設定したタイムアウトの秒数が小さかったり、一時的なエラーとして扱える他の種類のエラーが原因となり、Deploymentで一時的なエラーが出る場合があります。例えば、リソースの割り当てが不十分な場合を考えます。Deploymentの詳細情報を確認すると、以下のセクションが表示されます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe deployment nginx-deployment
</code></pre></div><p>実行結果は以下のとおりです。</p>
<pre><code>&lt;...&gt;
Conditions:
  Type            Status  Reason
  ----            ------  ------
  Available       True    MinimumReplicasAvailable
  Progressing     True    ReplicaSetUpdated
  ReplicaFailure  True    FailedCreate
&lt;...&gt;
</code></pre><p><code>kubectl get deployment nginx-deployment -o yaml</code>を実行すると、Deploymentのステータスは以下のようになります。</p>
<pre><code>status:
  availableReplicas: 2
  conditions:
  - lastTransitionTime: 2016-10-04T12:25:39Z
    lastUpdateTime: 2016-10-04T12:25:39Z
    message: Replica set &quot;nginx-deployment-4262182780&quot; is progressing.
    reason: ReplicaSetUpdated
    status: &quot;True&quot;
    type: Progressing
  - lastTransitionTime: 2016-10-04T12:25:42Z
    lastUpdateTime: 2016-10-04T12:25:42Z
    message: Deployment has minimum availability.
    reason: MinimumReplicasAvailable
    status: &quot;True&quot;
    type: Available
  - lastTransitionTime: 2016-10-04T12:25:39Z
    lastUpdateTime: 2016-10-04T12:25:39Z
    message: 'Error creating: pods &quot;nginx-deployment-4262182780-&quot; is forbidden: exceeded quota:
      object-counts, requested: pods=1, used: pods=3, limited: pods=2'
    reason: FailedCreate
    status: &quot;True&quot;
    type: ReplicaFailure
  observedGeneration: 3
  replicas: 2
  unavailableReplicas: 2
</code></pre><p>最後に、一度Deploymentの更新処理のデッドラインを越えると、KubernetesはDeploymentのステータスと進行中の状態を更新します。</p>
<pre><code>Conditions:
  Type            Status  Reason
  ----            ------  ------
  Available       True    MinimumReplicasAvailable
  Progressing     False   ProgressDeadlineExceeded
  ReplicaFailure  True    FailedCreate
</code></pre><p>Deploymentか他のリソースコントローラーのスケールダウンを行うか、使用している名前空間内でリソースの割り当てを増やすことで、リソースの割り当て不足の問題に対処できます。割り当て条件を満たすと、DeploymentコントローラーはDeploymentのロールアウトを完了させ、Deploymentのステータスが成功状態になるのを確認できます(<code>Status=True</code>と<code>Reason=NewReplicaSetAvailable</code>)。</p>
<pre><code>Conditions:
  Type          Status  Reason
  ----          ------  ------
  Available     True    MinimumReplicasAvailable
  Progressing   True    NewReplicaSetAvailable
</code></pre><p><code>Status=True</code>の<code>Type=Available</code>は、Deploymentが最小可用性の状態であることを意味します。最小可用性は、Deploymentの更新戦略において指定されているパラメータにより決定されます。<code>Status=True</code>の<code>Type=Progressing</code>は、Deploymentのロールアウトの途中で、更新処理が進行中であるか、更新処理が完了し、必要な最小数のレプリカが利用可能であることを意味します(各TypeのReason項目を確認してください。このケースでは、<code>Reason=NewReplicaSetAvailable</code>はDeploymentの更新が完了したことを意味します)。</p>
<p><code>kubectl rollout status</code>を実行してDeploymentが更新に失敗したかどうかを確認できます。<code>kubectl rollout status</code>はDeploymentが更新処理のデッドラインを超えたときに0以外の終了コードを返します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl rollout status deployment.v1.apps/nginx-deployment
</code></pre></div><p>実行結果は以下のとおりです。</p>
<pre><code>Waiting for rollout to finish: 2 out of 3 new replicas have been updated...
error: deployment &quot;nginx&quot; exceeded its progress deadline
</code></pre><p>そして<code>kubectl rollout</code>の終了ステータスが1となります(エラーを示しています):</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#a2f>echo</span> <span style=color:#b8860b>$?</span>
</code></pre></div><pre><code>1
</code></pre><h3 id=失敗したdeploymentの操作>失敗したDeploymentの操作</h3>
<p>更新完了したDeploymentに適用した全てのアクションは、更新失敗したDeploymentに対しても適用されます。スケールアップ、スケールダウンができ、前のリビジョンへのロールバックや、Deploymentのテンプレートに複数の更新を適用させる必要があるときは一時停止もできます。</p>
<h2 id=clean-up-policy>古いリビジョンのクリーンアップポリシー</h2>
<p>Deploymentが管理する古いReplicaSetをいくつ保持するかを指定するために、<code>.spec.revisionHistoryLimit</code>フィールドを設定できます。この値を超えた古いReplicaSetはバックグラウンドでガーベージコレクションの対象となって削除されます。デフォルトではこの値は10です。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> このフィールドを明示的に0に設定すると、Deploymentの全ての履歴を削除します。従って、Deploymentはロールバックできません。
</div>
<h2 id=カナリアパターンによるデプロイ>カナリアパターンによるデプロイ</h2>
<p>Deploymentを使って一部のユーザーやサーバーに対してリリースのロールアウトをしたい場合、<a href=/ja/docs/concepts/cluster-administration/manage-deployment/#canary-deployments-%E3%82%AB%E3%83%8A%E3%83%AA%E3%82%A2%E3%83%87%E3%83%97%E3%83%AD%E3%82%A4>リソースの管理</a>に記載されているカナリアパターンに従って、リリース毎に1つずつ、複数のDeploymentを作成できます。</p>
<h2 id=deployment-specの記述>Deployment Specの記述</h2>
<p>他の全てのKubernetesの設定と同様に、Deploymentは<code>.apiVersion</code>、<code>.kind</code>や<code>.metadata</code>フィールドを必要とします。
設定ファイルの利用に関する情報は<a href=/ja/docs/tasks/run-application/run-stateless-application-deployment/>アプリケーションのデプロイ</a>を参照してください。コンテナーの設定に関しては<a href=/ja/docs/concepts/overview/working-with-objects/object-management/>リソースを管理するためのkubectlの使用</a>を参照してください。
Deploymentオブジェクトの名前は、有効な<a href=/ja/docs/concepts/overview/working-with-objects/names#dns-subdomain-names>DNSサブドメイン名</a>でなければなりません。
Deploymentは<a href=https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status><code>.spec</code>セクション</a>も必要とします。</p>
<h3 id=podテンプレート>Podテンプレート</h3>
<p><code>.spec.template</code>と<code>.spec.selector</code>は<code>.spec</code>における必須のフィールドです。</p>
<p><code>.spec.template</code>は<a href=/docs/concepts/workloads/pods/#pod-templates>Podテンプレート</a>です。これは.spec内でネストされていないことと、<code>apiVersion</code>や<code>kind</code>を持たないことを除いては<a class=glossary-tooltip title="一番小さく一番シンプルな Kubernetes のオブジェクト。Pod とはクラスターで動作しているいくつかのコンテナのまとまりです。" data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a>と同じスキーマとなります。</p>
<p>Podの必須フィールドに加えて、Deployment内のPodテンプレートでは適切なラベルと再起動ポリシーを設定しなくてはなりません。ラベルは他のコントローラーと重複しないようにしてください。ラベルについては、<a href=#selector>セレクター</a>を参照してください。</p>
<p><a href=/ja/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy><code>.spec.template.spec.restartPolicy</code></a>が<code>Always</code>に等しいときのみ許可されます。これはテンプレートで指定されていない場合のデフォルト値です。</p>
<h3 id=レプリカ数>レプリカ数</h3>
<p><code>.spec.replias</code>は理想的なPodの数を指定するオプションのフィールドです。デフォルトは1です。</p>
<h3 id=selector>セレクター</h3>
<p><code>.spec.selector</code>は必須フィールドで、Deploymentによって対象とされるPodの<a href=/ja/docs/concepts/overview/working-with-objects/labels/>ラベルセレクター</a>を指定します。</p>
<p><code>.spec.selector</code>は<code>.spec.template.metadata.labels</code>と一致している必要があり、一致しない場合はAPIによって拒否されます。</p>
<p><code>apps/v1</code>バージョンにおいて、<code>.spec.selector</code>と<code>.metadata.labels</code>が指定されていない場合、<code>.spec.template.metadata.labels</code>の値に初期化されません。そのため<code>.spec.selector</code>と<code>.metadata.labels</code>を明示的に指定する必要があります。また<code>apps/v1</code>のDeploymentにおいて<code>.spec.selector</code>は作成後に不変になります。</p>
<p>Deploymentのテンプレートが<code>.spec.template</code>と異なる場合や、<code>.spec.replicas</code>の値を超えてPodが稼働している場合、Deploymentはセレクターに一致するラベルを持つPodを削除します。Podの数が理想状態より少ない場合Deploymentは<code>.spec.template</code>をもとに新しいPodを作成します。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> Deploymentのセレクターに一致するラベルを持つPodを直接作成したり、他のDeploymentやReplicaSetやReplicationControllerによって作成するべきではありません。作成してしまうと、最初のDeploymentがラベルに一致する新しいPodを作成したとみなされます。こうなったとしても、Kubernetesは処理を止めません。
</div>
<p>セレクターが重複する複数のコントローラーを持つとき、そのコントローラーは互いに競合状態となり、正しくふるまいません。</p>
<h3 id=更新戦略>更新戦略</h3>
<p><code>.spec.strategy</code>は古いPodから新しいPodに置き換える際の更新戦略を指定します。<code>.spec.strategy.type</code>は"Recreate"もしくは"RollingUpdate"を指定できます。デフォルトは"RollingUpdate"です。</p>
<h4 id=deploymentの再作成>Deploymentの再作成</h4>
<p><code>.spec.strategy.type==Recreate</code>と指定されているとき、既存の全てのPodは新しいPodが作成される前に削除されます。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> これは更新のための作成の前にPodを停止する事を保証するだけです。Deploymentを更新する場合、古いリビジョンのPodは全てすぐに停止されます。削除に成功するまでは、新しいリビジョンのPodは作成されません。手動でPodを削除すると、ライフサイクルがReplicaSetに制御されているのですぐに置き換えが実施されます（たとえ古いPodがまだ停止中のステータスでも）。Podに"高々この程度の"保証を求めるならば<a href=/ja/docs/concepts/workloads/controllers/statefulset/>StatefulSet</a>の使用を検討してください。
</div>
<h4 id=deploymentのローリングアップデート>Deploymentのローリングアップデート</h4>
<p><code>.spec.strategy.type==RollingUpdate</code>と指定されているとき、DeploymentはローリングアップデートによりPodを更新します。ローリングアップデートの処理をコントロールするために<code>maxUnavailable</code>と<code>maxSurge</code>を指定できます。</p>
<h5 id=max-unavailable>Max Unavailable</h5>
<p><code>.spec.strategy.rollingUpdate.maxUnavailable</code>はオプションのフィールドで、更新処理において利用不可となる最大のPod数を指定します。値は絶対値(例: 5)を指定するか、理想状態のPodのパーセンテージを指定します(例: 10%)。パーセンテージを指定した場合、絶対値は小数切り捨てされて計算されます。<code>.spec.strategy.rollingUpdate.maxSurge</code>が0に指定されている場合、この値を0にできません。デフォルトでは25%です。</p>
<p>例えば、この値が30%と指定されているとき、ローリングアップデートが開始すると古いReplicaSetはすぐに理想状態の70%にスケールダウンされます。一度新しいPodが稼働できる状態になると、古いReplicaSetはさらにスケールダウンされ、続いて新しいReplicaSetがスケールアップされます。この間、利用可能なPodの総数は理想状態のPodの少なくとも70%以上になるように保証されます。</p>
<h5 id=max-surge>Max Surge</h5>
<p><code>.spec.strategy.rollingUpdate.maxSurge</code>はオプションのフィールドで、理想状態のPod数を超えて作成できる最大のPod数を指定します。値は絶対値(例: 5)を指定するか、理想状態のPodのパーセンテージを指定します(例: 10%)。パーセンテージを指定した場合、絶対値は小数切り上げで計算されます。<code>MaxUnavailable</code>が0に指定されている場合、この値を0にできません。デフォルトでは25%です。</p>
<p>例えば、この値が30%と指定されているとき、ローリングアップデートが開始すると新しいReplicaSetはすぐに更新されます。このとき古いPodと新しいPodの総数は理想状態の130%を超えないように更新されます。一度古いPodが削除されると、新しいReplicaSetはさらにスケールアップされます。この間、利用可能なPodの総数は理想状態のPodに対して最大130%になるように保証されます。</p>
<h3 id=progress-deadline-seconds>Progress Deadline Seconds</h3>
<p><code>.spec.progressDeadlineSeconds</code>はオプションのフィールドで、システムがDeploymentの<a href=#failed-deployment>更新に失敗</a>したと判断するまでに待つ秒数を指定します。更新に失敗したと判断されたとき、リソースのステータスは<code>Type=Progressing</code>、<code>Status=False</code>かつ<code>Reason=ProgressDeadlineExceeded</code>となるのを確認できます。DeploymentコントローラーはDeploymentの更新のリトライし続けます。デフォルト値は600です。今後、自動的なロールバックが実装されたとき、更新失敗状態になるとすぐにDeploymentコントローラーがロールバックを行うようになります。</p>
<p>この値が指定されているとき、<code>.spec.minReadySeconds</code>より大きい値を指定する必要があります。</p>
<h3 id=min-ready-seconds>Min Ready Seconds</h3>
<p><code>.spec.minReadySeconds</code>はオプションのフィールドで、新しく作成されたPodが利用可能となるために、最低どれくらいの秒数コンテナーがクラッシュすることなく稼働し続ければよいかを指定するものです。デフォルトでは0です(Podは作成されるとすぐに利用可能と判断されます)。Podが利用可能と判断された場合についてさらに学ぶために<a href=/ja/docs/concepts/workloads/pods/pod-lifecycle/#container-probes>Container Probes</a>を参照してください。</p>
<h3 id=リビジョン履歴の保持上限>リビジョン履歴の保持上限</h3>
<p>Deploymentのリビジョン履歴は、Deploymentが管理するReplicaSetに保持されています。</p>
<p><code>.spec.revisionHistoryLimit</code>はオプションのフィールドで、ロールバック可能な古いReplicaSetの数を指定します。この古いReplicaSetは<code>etcd</code>内のリソースを消費し、<code>kubectl get rs</code>の出力結果を見にくくします。Deploymentの各リビジョンの設定はReplicaSetに保持されます。このため一度古いReplicaSetが削除されると、そのリビジョンのDeploymentにロールバックすることができなくなります。デフォルトでは10もの古いReplicaSetが保持されます。しかし、この値の最適値は新しいDeploymentの更新頻度と安定性に依存します。</p>
<p>さらに詳しく言うと、この値を0にすると、0のレプリカを持つ古い全てのReplicaSetが削除されます。このケースでは、リビジョン履歴が完全に削除されているため新しいDeploymentのロールアウトを元に戻すことができません。</p>
<h3 id=paused>paused</h3>
<p><code>.spec.paused</code>はオプションのboolean値で、Deploymentの一時停止と再開のための値です。一時停止されているものと、そうでないものとの違いは、一時停止されているDeploymentはPodTemplateSpecのいかなる変更があってもロールアウトがトリガーされないことです。デフォルトではDeploymentは一時停止していない状態で作成されます。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-d459b930218774655fa7fd1620625539>2 - ReplicaSet</h1>
<p>ReplicaSetの目的は、どのような時でも安定したレプリカPodのセットを維持することです。これは、理想的なレプリカ数のPodが利用可能であることを保証するものとして使用されます。</p>
<h2 id=replicasetがどのように動くか>ReplicaSetがどのように動くか</h2>
<p>ReplicaSetは、ReplicaSetが対象とするPodをどう特定するかを示すためのセレクターや、稼働させたいPodのレプリカ数、Podテンプレート(理想のレプリカ数の条件を満たすために作成される新しいPodのデータを指定するために用意されるもの)といったフィールドとともに定義されます。ReplicaSetは、指定された理想のレプリカ数にするためにPodの作成と削除を行うことにより、その目的を達成します。ReplicaSetが新しいPodを作成するとき、ReplicaSetはそのPodテンプレートを使用します。</p>
<p>ReplicaSetがそのPod群と連携するためのリンクは、Podの<a href=/ja/docs/concepts/workloads/controllers/garbage-collection/#owners-and-dependents>metadata.ownerReferences</a>というフィールド(現在のオブジェクトが所有されているリソースを指定する)を介して作成されます。ReplicaSetによって所持された全てのPodは、それらの<code>ownerReferences</code>フィールドにReplicaSetを特定する情報を保持します。このリンクを通じて、ReplicaSetは管理しているPodの状態を把握したり、その後の実行計画を立てます。</p>
<p>ReplicaSetは、そのセレクターを使用することにより、所有するための新しいPodを特定します。もし<code>ownerReference</code>フィールドの値を持たないPodか、<code>ownerReference</code>フィールドの値が <a class=glossary-tooltip title=クラスターの状態をAPIサーバーから取得、見張る制御ループで、現在の状態を望ましい状態に移行するように更新します。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/architecture/controller/ target=_blank aria-label=コントローラー>コントローラー</a>でないPodで、そのPodがReplicaSetのセレクターとマッチした場合に、そのPodは即座にそのReplicaSetによって所有されます。</p>
<h2 id=replicasetを使うとき>ReplicaSetを使うとき</h2>
<p>ReplicaSetはどんな時でも指定された数のPodのレプリカが稼働することを保証します。しかし、DeploymentはReplicaSetを管理する、より上位レベルの概念で、Deploymentはその他の多くの有益な機能と共に、宣言的なPodのアップデート機能を提供します。それゆえ、我々はユーザーが独自のアップデートオーケストレーションを必要としたり、アップデートを全く必要としないような場合を除いて、ReplicaSetを直接使うよりも代わりにDeploymentを使うことを推奨します。</p>
<p>これは、ユーザーがReplicaSetのオブジェクトを操作する必要が全く無いことを意味します。
代わりにDeploymentを使用して、<code>spec</code>セクションにユーザーのアプリケーションを定義してください。</p>
<h2 id=replicasetの使用例>ReplicaSetの使用例</h2>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/ja/examples/controllers/frontend.yaml download=controllers/frontend.yaml><code>controllers/frontend.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('controllers-frontend-yaml')" title="Copy controllers/frontend.yaml to clipboard">
</img>
</div>
<div class=includecode id=controllers-frontend-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ReplicaSet<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>guestbook<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>tier</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># modify replicas according to your case</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>tier</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- {<span style=color:green;font-weight:700>key: tier, operator: In, values</span>:<span style=color:#bbb> </span>[frontend]}<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>guestbook<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>tier</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>php-redis<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>gcr.io/google_samples/gb-frontend:v3<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span>100m<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>100Mi<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>GET_HOSTS_FROM<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span>dns<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:#080;font-style:italic># If your cluster config does not include a dns service, then to</span><span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:#080;font-style:italic># instead access environment variables to find service host</span><span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:#080;font-style:italic># info, comment out the &#39;value: dns&#39; line above, and uncomment the</span><span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:#080;font-style:italic># line below.</span><span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:#080;font-style:italic># value: env</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>上記のマニフェストを<code>frontend.yaml</code>ファイルに保存しKubernetesクラスターに適用すると、マニフェストに定義されたReplicaSetとそれが管理するPod群を作成します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f http://k8s.io/examples/controllers/frontend.yaml
</code></pre></div><p>ユーザーはデプロイされた現在のReplicaSetの情報も取得できます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get rs
</code></pre></div><p>そして、ユーザーが作成したfrontendリソースについての情報も取得できます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>NAME       DESIRED   CURRENT   READY   AGE
frontend   <span style=color:#666>3</span>         <span style=color:#666>3</span>         <span style=color:#666>3</span>       6s
</code></pre></div><p>ユーザーはまたReplicaSetの状態も確認できます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe rs/frontend
</code></pre></div><p>その結果は以下のようになります。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>Name:		frontend
Namespace:	default
Selector:	<span style=color:#b8860b>tier</span><span style=color:#666>=</span>frontend
Labels:		<span style=color:#b8860b>app</span><span style=color:#666>=</span>guestbook
		<span style=color:#b8860b>tier</span><span style=color:#666>=</span>frontend
Annotations:	kubectl.kubernetes.io/last-applied-configuration:
                <span style=color:#666>{</span><span style=color:#b44>&#34;apiVersion&#34;</span>:<span style=color:#b44>&#34;apps/v1&#34;</span>,<span style=color:#b44>&#34;kind&#34;</span>:<span style=color:#b44>&#34;ReplicaSet&#34;</span>,<span style=color:#b44>&#34;metadata&#34;</span>:<span style=color:#666>{</span><span style=color:#b44>&#34;annotations&#34;</span>:<span style=color:#666>{}</span>,<span style=color:#b44>&#34;labels&#34;</span>:<span style=color:#666>{</span><span style=color:#b44>&#34;app&#34;</span>:<span style=color:#b44>&#34;guestbook&#34;</span>,<span style=color:#b44>&#34;tier&#34;</span>:<span style=color:#b44>&#34;frontend&#34;</span><span style=color:#666>}</span>,<span style=color:#b44>&#34;name&#34;</span>:<span style=color:#b44>&#34;frontend&#34;</span>,...
Replicas:	<span style=color:#666>3</span> current / <span style=color:#666>3</span> desired
Pods Status:	<span style=color:#666>3</span> Running / <span style=color:#666>0</span> Waiting / <span style=color:#666>0</span> Succeeded / <span style=color:#666>0</span> Failed
Pod Template:
  Labels:  <span style=color:#b8860b>tier</span><span style=color:#666>=</span>frontend
  Containers:
   php-redis:
    Image:        gcr.io/google_samples/gb-frontend:v3
    Port:         &lt;none&gt;
    Host Port:    &lt;none&gt;
    Environment:  &lt;none&gt;
    Mounts:       &lt;none&gt;
  Volumes:        &lt;none&gt;
Events:
  Type    Reason            Age   From                   Message
  ----    ------            ----  ----                   -------
  Normal  SuccessfulCreate  117s  replicaset-controller  Created pod: frontend-wtsmm
  Normal  SuccessfulCreate  116s  replicaset-controller  Created pod: frontend-b2zdv
  Normal  SuccessfulCreate  116s  replicaset-controller  Created pod: frontend-vcmts
</code></pre></div><p>そして最後に、ユーザーはReplicaSetによって作成されたPodもチェックできます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods
</code></pre></div><p>表示されるPodに関する情報は以下のようになります。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>NAME             READY   STATUS    RESTARTS   AGE
frontend-b2zdv   1/1     Running   <span style=color:#666>0</span>          6m36s
frontend-vcmts   1/1     Running   <span style=color:#666>0</span>          6m36s
frontend-wtsmm   1/1     Running   <span style=color:#666>0</span>          6m36s
</code></pre></div><p>ユーザーはまた、それらのPodの<code>ownerReferences</code>が<code>frontend</code>ReplicaSetに設定されていることも確認できます。
これを確認するためには、稼働しているPodの中のどれかのyamlファイルを取得します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods frontend-b2zdv -o yaml
</code></pre></div><p>その表示結果は、以下のようになります。その<code>frontend</code>ReplicaSetの情報が<code>metadata</code>の<code>ownerReferences</code>フィールドにセットされています。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>apiVersion: v1
kind: Pod
metadata:
  creationTimestamp: <span style=color:#b44>&#34;2020-02-12T07:06:16Z&#34;</span>
  generateName: frontend-
  labels:
    tier: frontend
  name: frontend-b2zdv
  namespace: default
  ownerReferences:
  - apiVersion: apps/v1
    blockOwnerDeletion: <span style=color:#a2f>true</span>
    controller: <span style=color:#a2f>true</span>
    kind: ReplicaSet
    name: frontend
    uid: f391f6db-bb9b-4c09-ae74-6a1f77f3d5cf
...
</code></pre></div><h2 id=テンプレートなしのpodの所有>テンプレートなしのPodの所有</h2>
<p>ユーザーが問題なくベアPod(Bare Pod: ここではPodテンプレート無しのPodのこと)を作成しているとき、そのベアPodがユーザーのReplicaSetの中のいずれのセレクターともマッチしないことを確認することを強く推奨します。
この理由として、ReplicaSetは、所有対象のPodがReplicaSetのテンプレートによって指定されたPodのみに限定されていないからです(ReplicaSetは前のセクションで説明した方法によって他のPodも所有できます)。</p>
<p>前のセクションで取り上げた<code>frontend</code>ReplicaSetと、下記のマニフェストのPodをみてみます。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/ja/examples/pods/pod-rs.yaml download=pods/pod-rs.yaml><code>pods/pod-rs.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-pod-rs-yaml')" title="Copy pods/pod-rs.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-pod-rs-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pod1<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>tier</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>hello1<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>gcr.io/google-samples/hello-app:2.0<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pod2<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>tier</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>hello2<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>gcr.io/google-samples/hello-app:1.0<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>これらのPodは<code>ownerReferences</code>に何のコントローラー(もしくはオブジェクト)も指定されておらず、そして<code>frontend</code>ReplicaSetにマッチするセレクターをもっており、これらのPodは即座に<code>frontend</code>ReplicaSetによって所有されます。</p>
<p>この<code>frontend</code>ReplicaSetがデプロイされ、初期のPodレプリカがレプリカ数の要求を満たすためにセットアップされた後で、ユーザーがそのPodを作成することを考えます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f http://k8s.io/examples/pods/pod-rs.yaml
</code></pre></div><p>新しいPodはそのReplicaSetによって所有され、そのReplicaSetのレプリカ数が、設定された理想のレプリカ数を超えた場合すぐにそれらのPodは削除されます。</p>
<p>下記のコマンドでPodを取得できます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods
</code></pre></div><p>その表示結果で、新しいPodがすでに削除済みか、削除中のステータスになっているのを確認できます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>NAME             READY   STATUS        RESTARTS   AGE
frontend-b2zdv   1/1     Running       <span style=color:#666>0</span>          10m
frontend-vcmts   1/1     Running       <span style=color:#666>0</span>          10m
frontend-wtsmm   1/1     Running       <span style=color:#666>0</span>          10m
pod1             0/1     Terminating   <span style=color:#666>0</span>          1s
pod2             0/1     Terminating   <span style=color:#666>0</span>          1s
</code></pre></div><p>もしユーザーがそのPodを最初に作成する場合</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f http://k8s.io/examples/pods/pod-rs.yaml
</code></pre></div><p>そしてその後に<code>frontend</code>ReplicaSetを作成すると、</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f http://k8s.io/examples/controllers/frontend.yaml
</code></pre></div><p>ユーザーはそのReplicaSetが作成したPodを所有し、さらにもともと存在していたPodと今回新たに作成されたPodの数が、理想のレプリカ数になるまでPodを作成するのを確認できます。
ここでまたPodの状態を取得します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods
</code></pre></div><p>取得結果は下記のようになります。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>NAME             READY   STATUS    RESTARTS   AGE
frontend-hmmj2   1/1     Running   <span style=color:#666>0</span>          9s
pod1             1/1     Running   <span style=color:#666>0</span>          36s
pod2             1/1     Running   <span style=color:#666>0</span>          36s
</code></pre></div><p>この方法で、ReplicaSetはテンプレートで指定されたもの以外のPodを所有することができます。</p>
<h2 id=replicasetのマニフェストを記述する>ReplicaSetのマニフェストを記述する。</h2>
<p>他の全てのKubernetes APIオブジェクトのように、ReplicaSetは<code>apiVersion</code>、<code>kind</code>と<code>metadata</code>フィールドを必要とします。
ReplicaSetでは、<code>kind</code>フィールドの値は<code>ReplicaSet</code>です。
Kubernetes1.9において、ReplicaSetは<code>apps/v1</code>というAPIバージョンが現在のバージョンで、デフォルトで有効です。<code>apps/v1beta2</code>というAPIバージョンは廃止されています。先ほど作成した<code>frontend.yaml</code>ファイルの最初の行を参考にしてください。</p>
<p>ReplicaSetオブジェクトの名前は、有効な
<a href=/ja/docs/concepts/overview/working-with-objects/names#dns-subdomain-names>DNSサブドメイン名</a>である必要があります。</p>
<p>また、ReplicaSetは<a href=https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status><code>.spec</code> セクション</a>も必須です。</p>
<h3 id=pod-テンプレート>Pod テンプレート</h3>
<p><code>.spec.template</code>はラベルを持つことが必要な<a href=/ja/docs/concepts/workloads/pods/#pod%E3%83%86%E3%83%B3%E3%83%97%E3%83%AC%E3%83%BC%E3%83%88>Pod テンプレート</a> です。先ほど作成した<code>frontend.yaml</code>の例では、<code>tier: frontend</code>というラベルを1つ持っています。
他のコントローラーがこのPodを所有しようとしないためにも、他のコントローラーのセレクターでラベルを上書きしないように注意してください。</p>
<p>テンプレートの<a href=/docs/concepts/workloads/Pods/pod-lifecycle/#restart-policy>再起動ポリシー</a>のためのフィールドである<code>.spec.template.spec.restartPolicy</code>は<code>Always</code>のみ許可されていて、そしてそれがデフォルト値です。</p>
<h3 id=pod-セレクター>Pod セレクター</h3>
<p><code>.spec.selector</code>フィールドは<a href=/ja/docs/concepts/overview/working-with-objects/labels/>ラベルセレクター</a>です。
<a href=#how-a-replicaset-works>先ほど</a>議論したように、ReplicaSetが所有するPodを指定するためにそのラベルが使用されます。
先ほどの<code>frontend.yaml</code>の例では、そのセレクターは下記のようになっていました</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>tier</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span></code></pre></div><p>そのReplicaSetにおいて、<code>.spec.template.metadata.labels</code>フィールドの値は<code>spec.selector</code>と一致しなくてはならず、一致しない場合はAPIによって拒否されます。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> 2つのReplicaSetが同じ<code>.spec.selector</code>の値を設定しているが、それぞれ異なる<code>.spec.template.metadata.labels</code>と<code>.spec.template.spec</code>フィールドの値を持っていたとき、それぞれのReplicaSetはもう一方のReplicaSetによって作成されたPodを無視します。
</div>
<h3 id=レプリカ数について>レプリカ数について</h3>
<p>ユーザーは<code>.spec.replicas</code>フィールドの値を設定することにより、いくつのPodを同時に稼働させるか指定できます。そのときReplicaSetはレプリカ数がこの値に達するまでPodを作成、または削除します。</p>
<p>もしユーザーが<code>.spec.replicas</code>を指定しない場合、デフォルト値として1がセットされます。</p>
<h2 id=replicasetを利用する>ReplicaSetを利用する</h2>
<h3 id=replicasetとpodの削除>ReplicaSetとPodの削除</h3>
<p>ReplicaSetとそれが所有する全てのPod削除したいときは、<a href=/docs/reference/generated/kubectl/kubectl-commands#delete><code>kubectl delete</code></a>コマンドを使ってください。<br>
<a href=/ja/docs/concepts/workloads/controllers/garbage-collection/>ガベージコレクター</a>がデフォルトで自動的に全ての依存するPodを削除します。</p>
<p>REST APIもしくは<code>client-go</code>ライブラリーを使用するとき、ユーザーは<code>-d</code>オプションで<code>propagationPolicy</code>を<code>Background</code>か<code>Foreground</code>と指定しなくてはなりません。
例えば下記のように実行します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl proxy --port<span style=color:#666>=</span><span style=color:#666>8080</span>
curl -X DELETE  <span style=color:#b44>&#39;localhost:8080/apis/apps/v1/namespaces/default/replicasets/frontend&#39;</span> <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>&gt; -d <span style=color:#b44>&#39;{&#34;kind&#34;:&#34;DeleteOptions&#34;,&#34;apiVersion&#34;:&#34;v1&#34;,&#34;propagationPolicy&#34;:&#34;Foreground&#34;}&#39;</span> <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>&gt; -H <span style=color:#b44>&#34;Content-Type: application/json&#34;</span>
</code></pre></div><h3 id=replicasetのみを削除する>ReplicaSetのみを削除する</h3>
<p>ユーザーは<a href=/docs/reference/generated/kubectl/kubectl-commands#delete><code>kubectl delete</code></a>コマンドで<code>--cascade=false</code>オプションを付けることにより、所有するPodに影響を与えることなくReplicaSetを削除できます。
REST APIもしくは<code>client-go</code>ライブラリーを使用するとき、ユーザーは<code>-d</code>オプションで<code>propagationPolicy</code>を<code>Orphan</code>と指定しなくてはなりません。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl proxy --port<span style=color:#666>=</span><span style=color:#666>8080</span>
curl -X DELETE  <span style=color:#b44>&#39;localhost:8080/apis/apps/v1/namespaces/default/replicasets/frontend&#39;</span> <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>&gt; -d <span style=color:#b44>&#39;{&#34;kind&#34;:&#34;DeleteOptions&#34;,&#34;apiVersion&#34;:&#34;v1&#34;,&#34;propagationPolicy&#34;:&#34;Orphan&#34;}&#39;</span> <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>&gt; -H <span style=color:#b44>&#34;Content-Type: application/json&#34;</span>
</code></pre></div><p>一度元のReplicaSetが削除されると、ユーザーは新しいものに置き換えるため新しいReplicaSetを作ることができます。新旧のReplicaSetの<code>.spec.selector</code>の値が同じである間、新しいReplicaSetは古いReplicaSetで稼働していたPodを取り入れます。
しかし、存在するPodが新しく異なるPodテンプレートとマッチさせようとするとき、この仕組みは機能しません。
ユーザーのコントロール下において新しいspecのPodをアップデートしたい場合は、<a href=#rolling-updates>ローリングアップデート</a>を使用してください。</p>
<h3 id=podをreplicasetから分離させる>PodをReplicaSetから分離させる</h3>
<p>ユーザーはPodのラベルを変更することにより、ReplicaSetからそのPodを削除できます。この手法はデバッグや、データ修復などのためにサービスからPodを削除したいときに使用できます。
この方法で削除されたPodは自動的に新しいものに置き換えられます。(レプリカ数は変更されないものと仮定します。)</p>
<h3 id=replicasetのスケーリング>ReplicaSetのスケーリング</h3>
<p>ReplicaSetは、ただ<code>.spec.replicas</code>フィールドを更新することによって簡単にスケールアップまたはスケールダウンできます。ReplicaSetコントローラーは、ラベルセレクターにマッチするような指定した数のPodが利用可能であり、操作可能であることを保証します。</p>
<h3 id=horizontalpodautoscaler-hpa-のターゲットとしてのreplicaset>HorizontalPodAutoscaler(HPA)のターゲットとしてのReplicaSet</h3>
<p>ReplicaSetはまた、<a href=/docs/tasks/run-application/horizontal-pod-autoscale/>Horizontal Pod Autoscalers (HPA)</a>のターゲットにもなることができます。
これはつまりReplicaSetがHPAによってオートスケールされうることを意味します。
ここではHPAが、前の例で作成したReplicaSetをターゲットにする例を示します。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/ja/examples/controllers/hpa-rs.yaml download=controllers/hpa-rs.yaml><code>controllers/hpa-rs.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('controllers-hpa-rs-yaml')" title="Copy controllers/hpa-rs.yaml to clipboard">
</img>
</div>
<div class=includecode id=controllers-hpa-rs-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>autoscaling/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>HorizontalPodAutoscaler<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>frontend-scaler<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>scaleTargetRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ReplicaSet<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>minReplicas</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>maxReplicas</span>:<span style=color:#bbb> </span><span style=color:#666>10</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>targetCPUUtilizationPercentage</span>:<span style=color:#bbb> </span><span style=color:#666>50</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>このマニフェストを<code>hpa-rs.yaml</code>に保存し、Kubernetesクラスターに適用すると、レプリケートされたPodのCPU使用量にもとづいてターゲットのReplicaSetをオートスケールするHPAを作成します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/controllers/hpa-rs.yaml
</code></pre></div><p>同様のことを行うための代替案として、<code>kubectl autoscale</code>コマンドも使用できます。(こちらの方がより簡単です。)</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl autoscale rs frontend --max<span style=color:#666>=</span><span style=color:#666>10</span> --min<span style=color:#666>=</span><span style=color:#666>3</span> --cpu-percent<span style=color:#666>=</span><span style=color:#666>50</span>
</code></pre></div><h2 id=replicasetの代替案>ReplicaSetの代替案</h2>
<h3 id=deployment-推奨>Deployment (推奨)</h3>
<p><a href=/ja/docs/concepts/workloads/controllers/deployment/><code>Deployment</code></a>はReplicaSetを所有することのできるオブジェクトで、宣言的なサーバサイドのローリングアップデートを介してReplicaSetとPodをアップデートできます。
ReplicaSetは単独で使用可能ですが、現在では、ReplicaSetは主にPodの作成、削除とアップデートを司るためのメカニズムとしてDeploymentによって使用されています。ユーザーがDeploymentを使用するとき、Deploymentによって作成されるReplicaSetの管理について心配する必要はありません。DeploymentはReplicaSetを所有し、管理します。
このため、もしユーザーがReplicaSetを必要とするとき、Deploymentの使用を推奨します。</p>
<h3 id=ベアpod-bare-pods>ベアPod(Bare Pods)</h3>
<p>ユーザーがPodを直接作成するケースとは異なり、ReplicaSetはNodeの故障やカーネルのアップグレードといった破壊的なNodeのメンテナンスなど、どのような理由に限らず削除または停止されたPodを置き換えます。
このため、我々はもしユーザーのアプリケーションが単一のPodのみ必要とする場合でもReplicaSetを使用することを推奨します。プロセスのスーパーバイザーについても同様に考えると、それは単一Node上での独立したプロセスの代わりに複数のNodeにまたがった複数のPodを監視します。
ReplicaSetは、Node上のいくつかのエージェント(例えば、KubeletやDocker）に対して、ローカルのコンテナ再起動を移譲します。</p>
<h3 id=job>Job</h3>
<p>PodをPodそれ自身で停止させたいような場合(例えば、バッチ用のジョブなど)は、ReplicaSetの代わりに<a href=/docs/concepts/workloads/controllers/job/><code>Job</code></a>を使用してください。</p>
<h3 id=daemonset>DaemonSet</h3>
<p>マシンの監視やロギングなど、マシンレベルの機能を提供したい場合は、ReplicaSetの代わりに<a href=/ja/docs/concepts/workloads/controllers/daemonset/><code>DaemonSet</code></a>を使用してください。
これらのPodはマシン自体のライフタイムに紐づいています: そのPodは他のPodが起動する前に、そのマシン上で稼働される必要があり、マシンが再起動またはシャットダウンされるときには、安全に停止されます。</p>
<h3 id=replicationcontroller>ReplicationController</h3>
<p>ReplicaSetは<a href=/docs/concepts/workloads/controllers/replicationcontroller/><em>ReplicationControllers</em></a>の後継となるものです。
この2つは、ReplicationControllerが<a href=/ja/docs/concepts/overview/working-with-objects/labels/#label-selectors>ラベルについてのユーザーガイド</a>に書かれているように、集合ベース(set-based)のセレクター要求をサポートしていないことを除いては、同じ目的を果たし、同じようにふるまいます。<br>
このように、ReplicaSetはReplicationControllerよりも好まれます。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-6d72299952c37ca8cc61b416e5bdbcd4>3 - StatefulSet</h1>
<p>StatefulSetはステートフルなアプリケーションを管理するためのワークロードAPIです。</p>
<p>StatefulSetはDeploymentと<a class=glossary-tooltip title="一番小さく一番シンプルな Kubernetes のオブジェクト。Pod とはクラスターで動作しているいくつかのコンテナのまとまりです。" data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a>のセットのスケーリングを管理し、それらのPodの<em>順序と一意性を保証</em> します。</p>
<p><a class=glossary-tooltip title=クラスター上の複製されたアプリケーションを管理します。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/controllers/deployment/ target=_blank aria-label=Deployment>Deployment</a>のように、StatefulSetは指定したコンテナのspecに基づいてPodを管理します。Deploymentとは異なり、StatefulSetは各Podにおいて管理が大変な同一性を維持します。これらのPodは同一のspecから作成されますが、それらは交換可能ではなく、リスケジュール処理をまたいで維持される永続的な識別子を持ちます。</p>
<p>ワークロードに永続性を持たせるためにストレージボリュームを使いたい場合は、解決策の1つとしてStatefulSetが利用できます。StatefulSet内の個々のPodは障害の影響を受けやすいですが、永続化したPodの識別子は既存のボリュームと障害によって置換された新しいPodの紐付けを簡単にします。</p>
<h2 id=statefulsetの使用>StatefulSetの使用</h2>
<p>StatefulSetは下記の1つ以上の項目を要求するアプリケーションにおいて最適です。</p>
<ul>
<li>安定した一意のネットワーク識別子</li>
<li>安定した永続ストレージ</li>
<li>規則的で安全なデプロイとスケーリング</li>
<li>規則的で自動化されたローリングアップデート</li>
</ul>
<p>上記において安定とは、Podのスケジュール(または再スケジュール)をまたいでも永続的であることと同義です。
もしアプリケーションが安定したネットワーク識別子と規則的なデプロイや削除、スケーリングを全く要求しない場合、ユーザーはステートレスなレプリカのセットを提供するワークロードを使ってアプリケーションをデプロイするべきです。
<a href=/ja/docs/concepts/workloads/controllers/deployment/>Deployment</a>や<a href=/ja/docs/concepts/workloads/controllers/replicaset/>ReplicaSet</a>のようなコントローラーはこのようなステートレスな要求に対して最適です。</p>
<h2 id=制限事項>制限事項</h2>
<ul>
<li>提供されたPodのストレージは、要求された<code>storage class</code>にもとづいて<a href=https://github.com/kubernetes/examples/tree/master/staging/persistent-volume-provisioning/README.md>PersistentVolume Provisioner</a>によってプロビジョンされるか、管理者によって事前にプロビジョンされなくてはなりません。</li>
<li>StatefulSetの削除もしくはスケールダウンをすることにより、StatefulSetに関連したボリュームは削除<em>されません</em> 。 これはデータ安全性のためで、関連するStatefulSetのリソース全てを自動的に削除するよりもたいてい有効です。</li>
<li>StatefulSetは現在、Podのネットワークアイデンティティーに責務をもつために<a href=/ja/docs/concepts/services-networking/service/#headless-service>Headless Service</a>を要求します。ユーザーはこのServiceを作成する責任があります。</li>
<li>StatefulSetは、StatefulSetが削除されたときにPodの停止を行うことを保証していません。StatefulSetにおいて、規則的で安全なPodの停止を行う場合、削除のために事前にそのStatefulSetの数を0にスケールダウンさせることが可能です。</li>
<li>デフォルト設定の<a href=#pod-management-policies>Pod管理ポリシー</a> (<code>OrderedReady</code>)によって<a href=#rolling-updates>ローリングアップデート</a>を行う場合、<a href=#forced-rollback>修復のための手動介入</a>を要求するようなブロークンな状態に遷移させることが可能です。</li>
</ul>
<h2 id=コンポーネント>コンポーネント</h2>
<p>下記の例は、StatefulSetのコンポーネントのデモンストレーションとなります。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>web<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>clusterIP</span>:<span style=color:#bbb> </span>None<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StatefulSet<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>web<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb> </span><span style=color:#080;font-style:italic># .spec.template.metadata.labelsの値と一致する必要があります</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>serviceName</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;nginx&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb> </span><span style=color:#080;font-style:italic># by default is 1</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb> </span><span style=color:#080;font-style:italic># .spec.selector.matchLabelsの値と一致する必要があります</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>terminationGracePeriodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>10</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/nginx-slim:0.8<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>web<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>www<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/usr/share/nginx/html<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumeClaimTemplates</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>www<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb> </span>[<span style=color:#bbb> </span><span style=color:#b44>&#34;ReadWriteOnce&#34;</span><span style=color:#bbb> </span>]<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>storageClassName</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;my-storage-class&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>1Gi<span style=color:#bbb>
</span></code></pre></div><p>上記の例では、</p>
<ul>
<li>nginxという名前のHeadlessServiceは、ネットワークドメインをコントロールするために使われます。</li>
<li>webという名前のStatefulSetは、specで3つのnginxコンテナのレプリカを持ち、そのコンテナはそれぞれ別のPodで稼働するように設定されています。</li>
<li>volumeClaimTemplatesは、PersistentVolumeプロビジョナーによってプロビジョンされた<a href=/ja/docs/concepts/storage/persistent-volumes/>PersistentVolume</a>を使って安定したストレージを提供します。</li>
</ul>
<p>StatefulSetの名前は有効な<a href=/ja/docs/concepts/overview/working-with-objects/names#dns-subdomain-names>名前</a>である必要があります。</p>
<h2 id=podセレクター>Podセレクター</h2>
<p>ユーザーは、StatefulSetの<code>.spec.template.metadata.labels</code>のラベルと一致させるため、StatefulSetの<code>.spec.selector</code>フィールドをセットしなくてはなりません。Kubernetes1.8以前では、<code>.spec.selector</code>フィールドは省略された場合デフォルト値になります。Kubernetes1.8とそれ以降のバージョンでは、ラベルに一致するPodセレクターの指定がない場合はStatefulSetの作成時にバリデーションエラーになります。</p>
<h2 id=podアイデンティティー>Podアイデンティティー</h2>
<p>StatefulSetのPodは、順番を示す番号、安定したネットワークアイデンティティー、安定したストレージからなる一意なアイデンティティーを持ちます。
そのアイデンティティーはどのNode上にスケジュール(もしくは再スケジュール)されるかに関わらず、そのPodに紐付きます。</p>
<h3 id=順序インデックス>順序インデックス</h3>
<p>N個のレプリカをもったStatefulSetにおいて、StatefulSet内の各Podは、0からはじまりN-1までの整数値を順番に割り当てられ、そのStatefulSetにおいては一意となります。</p>
<h3 id=安定したネットワークid>安定したネットワークID</h3>
<p>StatefulSet内の各Podは、そのStatefulSet名とPodの順序番号から派生してホストネームが割り当てられます。
作成されたホストネームの形式は<code>$(StatefulSet名)-$(順序番号)</code>となります。先ほどの上記の例では、<code>web-0,web-1,web-2</code>という3つのPodが作成されます。
StatefulSetは、Podのドメインをコントロールするために<a href=/ja/docs/concepts/services-networking/service/#headless-service>Headless Service</a>を使うことができます。
このHeadless Serviceによって管理されたドメインは<code>$(Service名).$(ネームスペース).svc.cluster.local</code>形式となり、"cluster.local"というのはそのクラスターのドメインとなります。
各Podが作成されると、Podは<code>$(Pod名).$(管理するServiceドメイン名)</code>に一致するDNSサブドメインを取得し、管理するServiceはStatefulSetの<code>serviceName</code>で定義されます。</p>
<p>クラスターでのDNSの設定方法によっては、新たに起動されたPodのDNS名をすぐに検索できない場合があります。
この動作は、クラスター内の他のクライアントが、Podが作成される前にそのPodのホスト名に対するクエリーをすでに送信していた場合に発生する可能性があります。
(DNSでは通常)ネガティブキャッシュは、Podの起動後でも、少なくとも数秒間、以前に失敗したルックアップの結果が記憶され、再利用されることを意味します。</p>
<p>Podが作成された後、速やかにPodを検出する必要がある場合は、いくつかのオプションがあります。</p>
<ul>
<li>DNSルックアップに依存するのではなく、Kubernetes APIに直接(例えばwatchを使って)問い合わせる。</li>
<li>Kubernetes DNS プロバイダーのキャッシュ時間を短縮する(これは現在30秒キャッシュされるようになっているCoreDNSのConfigMapを編集することを意味しています。)。</li>
</ul>
<p><a href=#%E5%88%B6%E9%99%90%E4%BA%8B%E9%A0%85>制限事項</a>セクションで言及したように、ユーザーはPodのネットワークアイデンティティーのために<a href=/ja/docs/concepts/services-networking/service/#headless-service>Headless Service</a>を作成する責任があります。</p>
<p>ここで、クラスタードメイン、Service名、StatefulSet名の選択と、それらがStatefulSetのPodのDNS名にどう影響するかの例をあげます。</p>
<table>
<thead>
<tr>
<th>Cluster Domain</th>
<th>Service (ns/name)</th>
<th>StatefulSet (ns/name)</th>
<th>StatefulSet Domain</th>
<th>Pod DNS</th>
<th>Pod Hostname</th>
</tr>
</thead>
<tbody>
<tr>
<td>cluster.local</td>
<td>default/nginx</td>
<td>default/web</td>
<td>nginx.default.svc.cluster.local</td>
<td>web-{0..N-1}.nginx.default.svc.cluster.local</td>
<td>web-{0..N-1}</td>
</tr>
<tr>
<td>cluster.local</td>
<td>foo/nginx</td>
<td>foo/web</td>
<td>nginx.foo.svc.cluster.local</td>
<td>web-{0..N-1}.nginx.foo.svc.cluster.local</td>
<td>web-{0..N-1}</td>
</tr>
<tr>
<td>kube.local</td>
<td>foo/nginx</td>
<td>foo/web</td>
<td>nginx.foo.svc.kube.local</td>
<td>web-{0..N-1}.nginx.foo.svc.kube.local</td>
<td>web-{0..N-1}</td>
</tr>
</tbody>
</table>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> クラスタードメインは<a href=/ja/docs/concepts/services-networking/dns-pod-service/>その他の設定</a>がされない限り、<code>cluster.local</code>にセットされます。
</div>
<h3 id=安定したストレージ>安定したストレージ</h3>
<p>Kubernetesは各VolumeClaimTemplateに対して、1つの<a href=/docs/concepts/storage/persistent-volumes/>PersistentVolume</a>を作成します。上記のnginxの例において、各Podは<code>my-storage-class</code>というStorageClassをもち、1Gibのストレージ容量を持った単一のPersistentVolumeを受け取ります。もしStorageClassが指定されていない場合、デフォルトのStorageClassが使用されます。PodがNode上にスケジュール(もしくは再スケジュール)されたとき、その<code>volumeMounts</code>はPersistentVolume Claimに関連したPersistentVolumeをマウントします。
注意点として、PodのPersistentVolume Claimと関連したPersistentVolumeは、PodやStatefulSetが削除されたときに削除されません。
削除する場合は手動で行わなければなりません。</p>
<h3 id=podのネームラベル>Podのネームラベル</h3>
<p>StatefulSet <a class=glossary-tooltip title=クラスターの状態をAPIサーバーから取得、見張る制御ループで、現在の状態を望ましい状態に移行するように更新します。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/architecture/controller/ target=_blank aria-label=コントローラー>コントローラー</a> がPodを作成したとき、Podの名前として、<code>statefulset.kubernetes.io/pod-name</code>にラベルを追加します。このラベルによってユーザーはServiceにStatefulSet内の指定したPodを割り当てることができます。</p>
<h2 id=デプロイとスケーリングの保証>デプロイとスケーリングの保証</h2>
<ul>
<li>N個のレプリカをもつStatefulSetにおいて、Podがデプロイされるとき、それらのPodは{0..N-1}の番号で順番に作成されます。</li>
<li>Podが削除されるとき、それらのPodは{N-1..0}の番号で降順に削除されます。</li>
<li>Podに対してスケーリングオプションが適用される前に、そのPodの前の順番の全てのPodがRunningかつReady状態になっていなくてはなりません。</li>
<li>Podが停止される前に、そのPodの番号より大きい番号を持つの全てのPodは完全にシャットダウンされていなくてはなりません。</li>
</ul>
<p>StatefulSetは<code>pod.Spec.TerminationGracePeriodSeconds</code>を0に指定すべきではありません。これは不安全で、やらないことを強く推奨します。さらなる説明としては、<a href=/ja/docs/tasks/run-application/force-delete-stateful-set-pod/>StatefulSetのPodの強制削除</a>を参照してください。</p>
<p>上記の例のnginxが作成されたとき、3つのPodは<code>web-0</code>、<code>web-1</code>、<code>web-2</code>の順番でデプロイされます。<code>web-1</code>は<code>web-0</code>が<a href=/ja/docs/concepts/workloads/pods/pod-lifecycle/>RunningかつReady状態</a>になるまでは決してデプロイされないのと、同様に<code>web-2</code>は<code>web-1</code>がRunningかつReady状態にならないとデプロイされません。もし<code>web-0</code>が<code>web-1</code>がRunningかつReady状態になった後だが、<code>web-2</code>が起動する前に失敗した場合、<code>web-2</code>は<code>web-0</code>の再起動が成功し、RunningかつReady状態にならないと再起動されません。</p>
<p>もしユーザーが<code>replicas=1</code>といったようにStatefulSetにパッチをあてることにより、デプロイされたものをスケールすることになった場合、<code>web-2</code>は最初に停止されます。<code>web-1</code>は<code>web-2</code>が完全にシャットダウンされ削除されるまでは、停止されません。もし<code>web-0</code>が、<code>web-2</code>が完全に停止され削除された後だが、<code>web-1</code>の停止の前に失敗した場合、<code>web-1</code>は<code>web-0</code>がRunningかつReady状態になるまでは停止されません。</p>
<h3 id=podの管理ポリシー>Podの管理ポリシー</h3>
<p>Kubernetes1.7とそれ以降のバージョンでは、StatefulSetは<code>.spec.podManagementPolicy</code>フィールドを介して、Podの一意性とアイデンティティーを保証します。</p>
<h4 id=orderedreadyなpod管理>OrderedReadyなPod管理</h4>
<p><code>OrderedReady</code>なPod管理はStatefulSetにおいてデフォルトです。これは<a href=#deployment-and-scaling-guarantees>デプロイとスケーリングの保証</a>に記載されている項目の振る舞いを実装します。</p>
<h4 id=並行なpod管理>並行なPod管理</h4>
<p><code>Parallel</code>なPod管理は、StatefulSetコントローラーに対して、他のPodが起動や停止される前にそのPodが完全に起動し準備完了になるか停止するのを待つことなく、Podが並行に起動もしくは停止するように指示します。</p>
<h2 id=アップデートストラテジー>アップデートストラテジー</h2>
<p>Kubernetes1.7とそれ以降のバージョンにおいて、StatefulSetの<code>.spec.updateStrategy</code>フィールドで、コンテナの自動のローリングアップデートの設定やラベル、リソースのリクエストとリミットや、StatefulSet内のPodのアノテーションを指定できます。</p>
<h3 id=ondelete>OnDelete</h3>
<p><code>OnDelete</code>というアップデートストラテジーは、レガシーな(Kubernetes1.6以前)振る舞いとなります。StatefulSetの<code>.spec.updateStrategy.type</code>が<code>OnDelete</code>にセットされていたとき、そのStatefulSetコントローラーはStatefulSet内でPodを自動的に更新しません。StatefulSetの<code>.spec.template</code>項目の修正を反映した新しいPodの作成をコントローラーに支持するためには、ユーザーは手動でPodを削除しなければなりません。</p>
<h3 id=rollingupdate>RollingUpdate</h3>
<p><code>RollingUpdate</code>というアップデートストラテジーは、StatefulSet内のPodに対する自動化されたローリングアップデートの機能を実装します。これは<code>.spec.updateStrategy</code>フィールドが未指定の場合のデフォルトのストラテジーです。StatefulSetの<code>.spec.updateStrategy.type</code>が<code>RollingUpdate</code>にセットされたとき、そのStatefulSetコントローラーは、StatefulSet内のPodを削除し、再作成します。これはPodの停止(Podの番号の降順)と同じ順番で、一度に1つのPodを更新します。コントローラーは、その前のPodの状態がRunningかつReady状態になるまで次のPodの更新を待ちます。</p>
<h4 id=パーティション>パーティション</h4>
<p><code>RollingUpdate</code>というアップデートストラテジーは、<code>.spec.updateStrategy.rollingUpdate.partition</code>を指定することにより、パーティションに分けることができます。もしパーティションが指定されていたとき、そのパーティションの値と等しいか、大きい番号を持つPodが更新されます。パーティションの値より小さい番号を持つPodは更新されず、たとえそれらのPodが削除されたとしても、それらのPodは以前のバージョンで再作成されます。もしStatefulSetの<code>.spec.updateStrategy.rollingUpdate.partition</code>が、<code>.spec.replicas</code>より大きい場合、<code>.spec.template</code>への更新はPodに反映されません。
多くのケースの場合、ユーザーはパーティションを使う必要はありませんが、もし一部の更新を行う場合や、カナリー版のバージョンをロールアウトする場合や、段階的ロールアウトを行う場合に最適です。</p>
<h4 id=強制ロールバック>強制ロールバック</h4>
<p>デフォルトの<a href=#pod-management-policies>Pod管理ポリシー</a>(<code>OrderedReady</code>)による<a href=#rolling-updates>ローリングアップデート</a>を行う際、修復のために手作業が必要な状態にすることが可能です。</p>
<p>もしユーザーが、決してRunningかつReady状態にならないような設定になるようにPodテンプレートを更新した場合(例えば、不正なバイナリや、アプリケーションレベルの設定エラーなど)、StatefulSetはロールアウトを停止し、待機します。</p>
<p>この状態では、Podテンプレートを正常な状態に戻すだけでは不十分です。<a href=https://github.com/kubernetes/kubernetes/issues/67250>既知の問題</a>によって、StatefulSetは元の正常な状態へ戻す前に、壊れたPodがReady状態(決して起こりえない)に戻るのを待ち続けます。</p>
<p>そのテンプレートを戻したあと、ユーザーはまたStatefulSetが異常状態で稼働しようとしていたPodをすべて削除する必要があります。StatefulSetはその戻されたテンプレートを使ってPodの再作成を始めます。</p>
<h2 id=次の項目>次の項目</h2>
<ul>
<li><a href=/ja/docs/tutorials/stateful-application/basic-stateful-set/>ステートフルなアプリケーションのデプロイ</a>の例を参考にしてください。</li>
<li><a href=/ja/docs/tutorials/stateful-application/cassandra/>StatefulSetを使ったCassandraのデプロイ</a>の例を参考にしてください。</li>
<li><a href=/ja/docs/tasks/run-application/run-replicated-stateful-application/>レプリカを持つステートフルアプリケーションを実行する</a>の例を参考にしてください。</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-41600eb8b6631c88848156f381e9d588>4 - DaemonSet</h1>
<p><em>DaemonSet</em> は全て(またはいくつか)のNodeが単一のPodのコピーを稼働させることを保証します。Nodeがクラスターに追加されるとき、PodがNode上に追加されます。Nodeがクラスターから削除されたとき、それらのPodはガーベージコレクターにより除去されます。DaemonSetの削除により、DaemonSetが作成したPodもクリーンアップします。</p>
<p>DaemonSetのいくつかの典型的な使用例は以下の通りです。</p>
<ul>
<li>クラスターのストレージデーモンを全てのNode上で稼働させる。</li>
<li>ログ集計デーモンを全てのNode上で稼働させる。</li>
<li>Nodeのモニタリングデーモンを全てのNode上で稼働させる。</li>
</ul>
<p>シンプルなケースとして、各タイプのデーモンにおいて、全てのNodeをカバーする1つのDaemonSetが使用されるケースがあります。さらに複雑な設定では、単一のタイプのデーモン用ですが、異なるフラグや、異なるハードウェアタイプに対するメモリー、CPUリクエストを要求する複数のDaemonSetを使用するケースもあります。</p>
<h2 id=daemonset-specの記述>DaemonSet Specの記述</h2>
<h3 id=daemonsetの作成>DaemonSetの作成</h3>
<p>ユーザーはYAMLファイル内でDaemonSetの設定を記述することができます。例えば、下記の<code>daemonset.yaml</code>ファイルでは<code>fluentd-elasticsearch</code>というDockerイメージを稼働させるDaemonSetの設定を記述します。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/ja/examples/controllers/daemonset.yaml download=controllers/daemonset.yaml><code>controllers/daemonset.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('controllers-daemonset-yaml')" title="Copy controllers/daemonset.yaml to clipboard">
</img>
</div>
<div class=includecode id=controllers-daemonset-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>DaemonSet<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>fluentd-elasticsearch<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>kube-system<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>k8s-app</span>:<span style=color:#bbb> </span>fluentd-logging<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>fluentd-elasticsearch<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>fluentd-elasticsearch<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>tolerations</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>node-role.kubernetes.io/master<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span>Exists<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>effect</span>:<span style=color:#bbb> </span>NoSchedule<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>fluentd-elasticsearch<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>quay.io/fluentd_elasticsearch/fluentd:v2.5.2<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>200Mi<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span>100m<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>200Mi<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>varlog<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/var/log<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>varlibdockercontainers<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/var/lib/docker/containers<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>terminationGracePeriodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>30</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>varlog<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>hostPath</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/var/log<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>varlibdockercontainers<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>hostPath</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/var/lib/docker/containers<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>YAMLファイルに基づいてDaemonSetを作成します。</p>
<pre><code>kubectl apply -f https://k8s.io/examples/controllers/daemonset.yaml
</code></pre><h3 id=必須のフィールド>必須のフィールド</h3>
<p>他の全てのKubernetesの設定と同様に、DaemonSetは<code>apiVersion</code>、<code>kind</code>と<code>metadata</code>フィールドが必須となります。設定ファイルの活用法に関する一般的な情報は、<a href=/ja/docs/tasks/run-application/run-stateless-application-deployment/>ステートレスアプリケーションの稼働</a>、<a href=/ja/docs/tasks/>コンテナの設定</a>、<a href=/ja/docs/concepts/overview/working-with-objects/object-management/>kubectlを用いたオブジェクトの管理</a>といったドキュメントを参照ください。</p>
<p>DaemonSetオブジェクトの名前は、有効な
<a href=/ja/docs/concepts/overview/working-with-objects/names#dns-subdomain-names>DNSサブドメイン名</a>である必要があります。</p>
<p>また、DaemonSetにおいて<a href=https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status><code>.spec</code></a>セクションも必須となります。</p>
<h3 id=podテンプレート>Podテンプレート</h3>
<p><code>.spec.template</code>は<code>.spec</code>内での必須のフィールドの1つです。</p>
<p><code>.spec.template</code>は<a href=/docs/concepts/workloads/pods/#pod-templates>Podテンプレート</a>となります。これはフィールドがネストされていて、<code>apiVersion</code>や<code>kind</code>をもたないことを除いては、<a class=glossary-tooltip title="一番小さく一番シンプルな Kubernetes のオブジェクト。Pod とはクラスターで動作しているいくつかのコンテナのまとまりです。" data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a>のテンプレートと同じスキーマとなります。</p>
<p>Podに対する必須のフィールドに加えて、DaemonSet内のPodテンプレートは適切なラベルを指定しなくてはなりません(<a href=#pod-selector>Podセレクター</a>の項目を参照ください)。</p>
<p>DaemonSet内のPodテンプレートでは、<a href=/ja/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy><code>RestartPolicy</code></a>フィールドを指定せずにデフォルトの<code>Always</code>を使用するか、明示的に<code>Always</code>を設定するかのどちらかである必要があります。</p>
<h3 id=podセレクター>Podセレクター</h3>
<p><code>.spec.selector</code>フィールドはPodセレクターとなります。これは<a href=/docs/concepts/workloads/controllers/job/>Job</a>の<code>.spec.selector</code>と同じものです。</p>
<p>Kubernetes1.8のように、ユーザーは<code>.spec.template</code>のラベルにマッチするPodセレクターを指定しなくてはいけません。Podセレクターは、値を空のままにしてもデフォルト設定にならなくなりました。セレクターのデフォルト化は<code>kubectl apply</code>と互換性はありません。また、一度DaemonSetが作成されると、その<code>.spec.selector</code>は変更不可能になります。Podセレクターの変更は、意図しないPodの孤立を引き起こし、ユーザーにとってやっかいなものとなります。</p>
<p><code>.spec.selector</code>は2つのフィールドからなるオブジェクトです。</p>
<ul>
<li><code>matchLabels</code> - <a href=/docs/concepts/workloads/controllers/replicationcontroller/>ReplicationController</a>の<code>.spec.selector</code>と同じように機能します。</li>
<li><code>matchExpressions</code> - キーと、値のリストとさらにはそれらのキーとバリューに関連したオペレーターを指定することにより、より洗練された形式のセレクターを構成できます。</li>
</ul>
<p>上記の2つが指定された場合は、2つの条件をANDでどちらも満たすものを結果として返します。</p>
<p>もし<code>spec.selector</code>が指定されたとき、<code>.spec.template.metadata.labels</code>とマッチしなければなりません。この2つの値がマッチしない設定をした場合、APIによってリジェクトされます。</p>
<h3 id=選択したnode上でpodを稼働させる>選択したNode上でPodを稼働させる</h3>
<p>もしユーザーが<code>.spec.template.spec.nodeSelector</code>を指定したとき、DaemonSetコントローラーは、その<a href=/ja/docs/concepts/scheduling-eviction/assign-pod-node/>node
selector</a>にマッチするPodをNode上に作成します。同様に、もし<code>.spec.template.spec.affinity</code>を指定したとき、DaemonSetコントローラーは<a href=/ja/docs/concepts/scheduling-eviction/assign-pod-node/>node affinity</a>マッチするPodをNode上に作成します。
もしユーザーがどちらも指定しないとき、DaemonSetコントローラーは全てのNode上にPodを作成します。</p>
<h2 id=daemon-podがどのようにスケジューリングされるか>Daemon Podがどのようにスケジューリングされるか</h2>
<h3 id=デフォルトスケジューラーによってスケジューリングされる場合>デフォルトスケジューラーによってスケジューリングされる場合</h3>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes 1.17 [stable]</code>
</div>
<p>DaemonSetは全ての利用可能なNodeが単一のPodのコピーを稼働させることを保証します。通常、Podが稼働するNodeはKubernetesスケジューラーによって選択されます。しかし、DaemonSetのPodは代わりにDaemonSetコントローラーによって作成され、スケジューリングされます。<br>
下記の問題について説明します:</p>
<ul>
<li>矛盾するPodのふるまい: スケジューリングされるのを待っている通常のPodは、作成されているが<code>Pending</code>状態となりますが、DaemonSetのPodは<code>Pending</code>状態で作成されません。これはユーザーにとって困惑するものです。</li>
<li><a href=/docs/concepts/configuration/pod-priority-preemption/>Podプリエンプション(Pod preemption)</a>はデフォルトスケジューラーによってハンドルされます。もしプリエンプションが有効な場合、そのDaemonSetコントローラーはPodの優先順位とプリエンプションを考慮することなくスケジューリングの判断を行います。</li>
</ul>
<p><code>ScheduleDaemonSetPods</code>は、DaemonSetのPodに対して<code>NodeAffinity</code>項目を追加することにより、DaemonSetコントローラーの代わりにデフォルトスケジューラーを使ってDaemonSetのスケジュールを可能にします。その際に、デフォルトスケジューラーはPodをターゲットのホストにバインドします。もしDaemonSetのNodeAffinityが存在するとき、それは新しいものに置き換えられます(ターゲットホストを選択する前に、元のNodeAffinityが考慮されます)。DaemonSetコントローラーはDaemonSetのPodの作成や修正を行うときのみそれらの操作を実施します。そしてDaemonSetの<code>.spec.template</code>フィールドに対しては何も変更が加えられません。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>nodeAffinity</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>requiredDuringSchedulingIgnoredDuringExecution</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>nodeSelectorTerms</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>matchFields</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>metadata.name<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span>In<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>values</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- target-host-name<span style=color:#bbb>
</span></code></pre></div><p>さらに、<code>node.kubernetes.io/unschedulable:NoSchedule</code>というtolarationがDaemonSetのPodに自動的に追加されます。デフォルトスケジューラーは、DaemonSetのPodのスケジューリングのときに、<code>unschedulable</code>なNodeを無視します。</p>
<h3 id=taintsとtolerations>TaintsとTolerations</h3>
<p>DaemonSetのPodは<a href=/ja/docs/concepts/scheduling-eviction/taint-and-toleration/>TaintsとTolerations</a>の設定を尊重します。下記のTolerationsは、関連する機能によって自動的にDaemonSetのPodに追加されます。</p>
<table>
<thead>
<tr>
<th>Toleration Key</th>
<th>Effect</th>
<th>Version</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>node.kubernetes.io/not-ready</code></td>
<td>NoExecute</td>
<td>1.13+</td>
<td>DaemonSetのPodはネットワーク分割のようなNodeの問題が発生したときに除外されません。</td>
</tr>
<tr>
<td><code>node.kubernetes.io/unreachable</code></td>
<td>NoExecute</td>
<td>1.13+</td>
<td>DaemonSetのPodはネットワーク分割のようなNodeの問題が発生したときに除外されません。</td>
</tr>
<tr>
<td><code>node.kubernetes.io/disk-pressure</code></td>
<td>NoSchedule</td>
<td>1.8+</td>
<td></td>
</tr>
<tr>
<td><code>node.kubernetes.io/memory-pressure</code></td>
<td>NoSchedule</td>
<td>1.8+</td>
<td></td>
</tr>
<tr>
<td><code>node.kubernetes.io/unschedulable</code></td>
<td>NoSchedule</td>
<td>1.12+</td>
<td>DaemonSetのPodはデフォルトスケジューラーによってスケジュール不可能な属性を許容(tolerate)します。</td>
</tr>
<tr>
<td><code>node.kubernetes.io/network-unavailable</code></td>
<td>NoSchedule</td>
<td>1.12+</td>
<td>ホストネットワークを使うDaemonSetのPodはデフォルトスケジューラーによってネットワーク利用不可能な属性を許容(tolerate)します。</td>
</tr>
</tbody>
</table>
<h2 id=daemon-podとのコミュニケーション>Daemon Podとのコミュニケーション</h2>
<p>DaemonSet内のPodとのコミュニケーションをする際に考えられるパターンは以下の通りです。:</p>
<ul>
<li><strong>Push</strong>: DaemonSet内のPodは他のサービスに対して更新情報を送信するように設定されます。</li>
<li><strong>NodeIPとKnown Port</strong>: PodがNodeIPを介して疎通できるようにするため、DaemonSet内のPodは<code>hostPort</code>を使用できます。慣例により、クライアントはNodeIPのリストとポートを知っています。</li>
<li><strong>DNS</strong>: 同じPodセレクターを持つ<a href=/ja/docs/concepts/services-networking/service/#headless-service>HeadlessService</a>を作成し、<code>endpoints</code>リソースを使ってDaemonSetを探すか、DNSから複数のAレコードを取得します。</li>
<li><strong>Service</strong>: 同じPodセレクターを持つServiceを作成し、複数のうちのいずれかのNode上のDaemonに疎通させるためにそのServiceを使います。</li>
</ul>
<h2 id=daemonsetの更新>DaemonSetの更新</h2>
<p>もしNodeラベルが変更されたとき、そのDaemonSetは直ちに新しくマッチしたNodeにPodを追加し、マッチしなくなったNodeからPodを削除します。</p>
<p>ユーザーはDaemonSetが作成したPodを修正可能です。しかし、Podは全てのフィールドの更新を許可していません。また、DaemonSetコントローラーは次のNode(同じ名前でも)が作成されたときにオリジナルのテンプレートを使ってPodを作成します。</p>
<p>ユーザーはDaemonSetを削除可能です。<code>kubectl</code>コマンドで<code>--cascade=false</code>を指定するとDaemonSetのPodはNode上に残り続けます。その後、同じセレクターで新しいDaemonSetを作成すると、新しいDaemonSetは既存のPodを再利用します。PodでDaemonSetを置き換える必要がある場合は、<code>updateStrategy</code>に従ってそれらを置き換えます。</p>
<p>ユーザーはDaemonSet上で<a href=/docs/tasks/manage-daemon/update-daemon-set/>ローリングアップデートの実施</a>が可能です。</p>
<h2 id=daemonsetの代替案>DaemonSetの代替案</h2>
<h3 id=initスクリプト>Initスクリプト</h3>
<p>Node上で直接起動することにより(例: <code>init</code>、<code>upstartd</code>、<code>systemd</code>を使用する)、デーモンプロセスを稼働することが可能です。この方法は非常に良いですが、このようなプロセスをDaemonSetを介して起動することはいくつかの利点があります。</p>
<ul>
<li>アプリケーションと同じ方法でデーモンの監視とログの管理ができる。</li>
<li>デーモンとアプリケーションで同じ設定用の言語とツール(例: Podテンプレート、<code>kubectl</code>)を使える。</li>
<li>リソースリミットを使ったコンテナ内でデーモンを稼働させることにより、デーモンとアプリケーションコンテナの分離を促進します。しかし、これはPod内でなく、コンテナ内でデーモンを稼働させることにより可能です(Dockerを介して直接起動する)。</li>
</ul>
<h3 id=ベアpod>ベアPod</h3>
<p>特定のNode上で稼働するように指定したPodを直接作成することは可能です。しかし、DaemonSetはNodeの故障やNodeの破壊的なメンテナンスやカーネルのアップグレードなど、どのような理由に限らず、削除されたもしくは停止されたPodを置き換えます。このような理由で、ユーザーはPod単体を作成するよりもむしろDaemonSetを使うべきです。</p>
<h3 id=静的pod-pods>静的Pod Pods</h3>
<p>Kubeletによって監視されているディレクトリに対してファイルを書き込むことによって、Podを作成することが可能です。これは<a href=/ja/docs/tasks/configure-pod-container/static-pod/>静的Pod</a>と呼ばれます。DaemonSetと違い、静的Podはkubectlや他のKubernetes APIクライアントで管理できません。静的PodはApiServerに依存しておらず、クラスターの自立起動時に最適です。また、静的Podは将来的には廃止される予定です。</p>
<h3 id=deployment>Deployment</h3>
<p>DaemonSetは、Podの作成し、そのPodが停止されることのないプロセスを持つことにおいて<a href=/ja/docs/concepts/workloads/controllers/deployment/>Deployment</a>と同様です(例: webサーバー、ストレージサーバー)。</p>
<p>フロントエンドのようなServiceのように、どのホスト上にPodが稼働するか制御するよりも、レプリカ数をスケールアップまたはスケールダウンしたりローリングアップデートする方が重要であるような、状態をもたないServiceに対してDeploymentを使ってください。
Podのコピーが全てまたは特定のホスト上で常に稼働していることが重要な場合や、他のPodの前に起動させる必要があるときにDaemonSetを使ってください。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-9add0d2120634b63073ad08dc8683bd6>5 - ガベージコレクション</h1>
<p>Kubernetesのガベージコレクターの役割は、かつてオーナーがいたが、現時点でもはやオーナーがいないようなオブジェクトの削除を行うことです。</p>
<h2 id=owners-and-dependents>オーナーとその従属オブジェクト</h2>
<p>いくつかのKubernetesオブジェクトは他のオブジェクトのオーナーとなります。例えば、ReplicaSetはPodのセットに対するオーナーです。オーナーによって所有されたオブジェクトは、オーナーオブジェクトの<em>従属オブジェクト(Dependents)</em> と呼ばれます。全ての従属オブジェクトは、オーナーオブジェクトを指し示す<code>metadata.ownerReferences</code>というフィールドを持ちます。</p>
<p>時々、Kubernetesは<code>ownerReference</code>フィールドに値を自動的にセットします。例えば、ユーザーがReplicaSetを作成したとき、KubernetesはReplicaSet内の各Podの<code>ownerReference</code>フィールドに自動的に値をセットします。Kubernetes1.8において、KubernetesはReplicaController、ReplicaSet、StatefulSet、DaemonSet、Deployment、Job、CronJobによって作成され、適用されたオブジェクトの<code>ownerReference</code>フィールドに自動的にその値をセットします。</p>
<p>ユーザーはまた<code>ownerReference</code>フィールドに手動で値をセットすることにより、オーナーと従属オブジェクト間の関係を指定することができます。</p>
<p>下記の例は、3つのPodを持つReplicaSetの設定ファイルとなります。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/ja/examples/controllers/replicaset.yaml download=controllers/replicaset.yaml><code>controllers/replicaset.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('controllers-replicaset-yaml')" title="Copy controllers/replicaset.yaml to clipboard">
</img>
</div>
<div class=includecode id=controllers-replicaset-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ReplicaSet<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-repset<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>pod-is-for</span>:<span style=color:#bbb> </span>garbage-collection-example<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>pod-is-for</span>:<span style=color:#bbb> </span>garbage-collection-example<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>もしユーザーがReplicaSetを作成し、Podのメタデータを見る時、<code>ownerReference</code>フィールドの値を確認できます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/controllers/replicaset.yaml
kubectl get pods --output<span style=color:#666>=</span>yaml
</code></pre></div><p>その出力結果によると、そのPodのオーナーは<code>my-repset</code>という名前のReplicaSetです。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ownerReferences</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>controller</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>blockOwnerDeletion</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ReplicaSet<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-repset<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>uid</span>:<span style=color:#bbb> </span>d9607e19-f88f-11e6-a518-42010a800195<span style=color:#bbb>
</span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> <p>ネームスペースをまたいだownerReferenceは意図的に許可されていません。これは以下のことを意味します。</p>
<ol>
<li>ネームスペース内のスコープの従属オブジェクトは、同一のネームスペース内のオーナーと、クラスターのスコープ内のオーナーのみ指定できます。</li>
<li>クラスターのスコープ内の従属オブジェクトは、クラスターのスコープ内のオーナーオブジェクトのみ指定でき、ネームスペース内のスコープのオーナーオブジェクトは指定できません。</li>
</ol>
</div>
<h2 id=ガベージコレクターがどのように従属オブジェクトの削除をするかを制御する>ガベージコレクターがどのように従属オブジェクトの削除をするかを制御する</h2>
<p>ユーザーがオブジェクトを削除するとき、それに紐づく従属オブジェクトも自動で削除するか指定できます。従属オブジェクトの自動削除は、<em>カスケード削除(Cascading deletion)</em> と呼ばれます。<em>カスケード削除</em> には2つのモードがあり、<em>バックグラウンド</em> と<em>フォアグラウンド</em> があります。</p>
<p>もしユーザーが、従属オブジェクトの自動削除なしにあるオブジェクトを削除する場合、その従属オブジェクトは<em>みなしご(orphaned)</em> と呼ばれます。</p>
<h3 id=フォアグラウンドのカスケード削除>フォアグラウンドのカスケード削除</h3>
<p><em>フォアグラウンドのカスケード削除</em> において、そのルートオブジェクトは最初に"削除処理中"という状態に遷移します。その<em>削除処理中</em> 状態において、下記の項目は正となります。</p>
<ul>
<li>そのオブジェクトはREST APIを介して確認可能です。</li>
<li>そのオブジェクトの<code>deletionTimestamp</code>がセットされます。</li>
<li>そのオブジェクトの<code>metadata.finalizers</code>フィールドは、<code>foregroundDeletion</code>という値を含みます。</li>
</ul>
<p>一度"削除処理中"状態に遷移すると、そのガベージコレクターはオブジェクトの従属オブジェクトを削除します。一度そのガベージコレクターが全ての”ブロッキングしている”従属オブジェクトを削除すると(<code>ownerReference.blockOwnerDeletion=true</code>という値を持つオブジェクト)、それはオーナーのオブジェクトも削除します。</p>
<p>注意点として、"フォアグラウンドのカスケード削除"において、<code>ownerReference.blockOwnerDeletion=true</code>フィールドを持つ従属オブジェクトのみ、そのオーナーオブジェクトの削除をブロックします。
Kubernetes1.7では、認証されていない従属オブジェクトがオーナーオブジェクトの削除を遅らせることができないようにするために<a href=/docs/reference/access-authn-authz/admission-controllers/#ownerreferencespermissionenforcement>アドミッションコントローラー</a>が追加され、それは、オーナーオブジェクトの削除パーミッションに基づいて<code>blockOwnerDeletion</code>の値がtrueに設定してユーザーアクセスをコントロールします。</p>
<p>もしオブジェクトの<code>ownerReferences</code>フィールドがコントローラー(DeploymentやReplicaSetなど)によってセットされている場合、<code>blockOwnerDeletion</code>は自動的にセットされ、ユーザーはこのフィールドを手動で修正する必要はありません。</p>
<h3 id=バックグラウンドのカスケード削除>バックグラウンドのカスケード削除</h3>
<p><em>バックグラウンドのカスケード削除</em> において、Kubernetesはそのオーナーオブジェクトを即座に削除し、ガベージコレクションはその従属オブジェクトをバックグラウンドで削除します。</p>
<h3 id=カスケード削除ポリシーの設定>カスケード削除ポリシーの設定</h3>
<p>カスケード削除ポリシーを制御するためには、オブジェクトをいつ設定するか<code>deleteOptions</code>引数上の<code>propagationPolicy</code>フィールドに設定してください。設定可能な値は<code>Orphan</code>、<code>Foreground</code>、もしくは<code>Background</code>のどれかです。</p>
<p>下記のコマンドは従属オブジェクトをバックグラウンドで削除する例です。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl proxy --port<span style=color:#666>=</span><span style=color:#666>8080</span>
curl -X DELETE localhost:8080/apis/apps/v1/namespaces/default/replicasets/my-repset <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  -d <span style=color:#b44>&#39;{&#34;kind&#34;:&#34;DeleteOptions&#34;,&#34;apiVersion&#34;:&#34;v1&#34;,&#34;propagationPolicy&#34;:&#34;Background&#34;}&#39;</span> <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  -H <span style=color:#b44>&#34;Content-Type: application/json&#34;</span>
</code></pre></div><p>下記のコマンドは従属オブジェクトをフォアグラウンドで削除する例です。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl proxy --port<span style=color:#666>=</span><span style=color:#666>8080</span>
curl -X DELETE localhost:8080/apis/apps/v1/namespaces/default/replicasets/my-repset <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  -d <span style=color:#b44>&#39;{&#34;kind&#34;:&#34;DeleteOptions&#34;,&#34;apiVersion&#34;:&#34;v1&#34;,&#34;propagationPolicy&#34;:&#34;Foreground&#34;}&#39;</span> <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  -H <span style=color:#b44>&#34;Content-Type: application/json&#34;</span>
</code></pre></div><p>下記のコマンドは従属オブジェクトをみなしご状態になった従属オブジェクトの例です。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl proxy --port<span style=color:#666>=</span><span style=color:#666>8080</span>
curl -X DELETE localhost:8080/apis/apps/v1/namespaces/default/replicasets/my-repset <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  -d <span style=color:#b44>&#39;{&#34;kind&#34;:&#34;DeleteOptions&#34;,&#34;apiVersion&#34;:&#34;v1&#34;,&#34;propagationPolicy&#34;:&#34;Orphan&#34;}&#39;</span> <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  -H <span style=color:#b44>&#34;Content-Type: application/json&#34;</span>
</code></pre></div><p>kubectlもまたカスケード削除をサポートしています。<br>
kubectlを使って従属オブジェクトを自動的に削除するためには、<code>--cascade</code>をtrueにセットしてください。
従属オブジェクトを削除せず、みなしご状態にするには<code>--cascade</code>をfalseにセットしてください。
<code>--cascade</code>オプションのデフォルト値はtrueになります。</p>
<p>下記のコマンドは、ReplicaSetを削除し、その従属オブジェクトをみなしご状態にします。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete replicaset my-repset --cascade<span style=color:#666>=</span><span style=color:#a2f>false</span>
</code></pre></div><h3 id=deploymentsに関する追記事項>Deploymentsに関する追記事項</h3>
<p>Kubernetes1.7以前では、Deploymentに対するカスケード削除において、作成されたReplicaSetだけでなく、それらのPodも削除するためには、ユーザーは<code>propagationPolicy: Foreground</code>と指定<em>しなくてはなりません</em> 。もしこのタイプの<em>propagationPolicy</em>が使われなかった場合、そのReplicaSetは削除されますが、そのPodは削除されずみなしご状態になります。<br>
さらなる詳細に関しては<a href=https://github.com/kubernetes/kubeadm/issues/149#issuecomment-284766613>kubeadm/#149</a>を参照してください。</p>
<h2 id=既知の問題について>既知の問題について</h2>
<p><a href=https://github.com/kubernetes/kubernetes/issues/26120>#26120</a>にてイシューがトラックされています。</p>
<h2 id=次の項目>次の項目</h2>
<p><a href=https://git.k8s.io/community/contributors/design-proposals/api-machinery/garbage-collection.md>Design Doc 1</a></p>
<p><a href=https://git.k8s.io/community/contributors/design-proposals/api-machinery/synchronous-garbage-collection.md>Design Doc 2</a></p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-4de50a37ebb6f2340484192126cb7a04>6 - 終了したリソースのためのTTLコントローラー(TTL Controller for Finished Resources)</h1>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.12 [alpha]</code>
</div>
<p>TTLコントローラーは実行を終えたリソースオブジェクトのライフタイムを制御するためのTTL (time to live) メカニズムを提供します。<br>
TTLコントローラーは現在<a class=glossary-tooltip title="A finite or batch task that runs to completion." data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/controllers/job/ target=_blank aria-label=Job>Job</a>のみ扱っていて、将来的にPodやカスタムリソースなど、他のリソースの実行終了を扱えるように拡張される予定です。</p>
<p>α版の免責事項: この機能は現在α版の機能で、kube-apiserverとkube-controller-managerの<a href=/docs/reference/command-line-tools-reference/feature-gates/>Feature Gate</a>の<code>TTLAfterFinished</code>を有効にすることで使用可能です。</p>
<h2 id=ttlコントローラー>TTLコントローラー</h2>
<p>TTLコントローラーは現在Jobに対してのみサポートされています。クラスターオペレーターはこの<a href=/ja/docs/concepts/workloads/controllers/job/#clean-up-finished-jobs-automatically>例</a>のように、Jobの<code>.spec.ttlSecondsAfterFinished</code>フィールドを指定することにより、終了したJob(<code>完了した</code>もしくは<code>失敗した</code>)を自動的に削除するためにこの機能を使うことができます。<br>
TTLコントローラーは、そのリソースが終了したあと指定したTTLの秒数後に削除できるか推定します。言い換えると、そのTTLが期限切れになると、TTLコントローラーがリソースをクリーンアップするときに、そのリソースに紐づく従属オブジェクトも一緒に連続で削除します。注意点として、リソースが削除されるとき、ファイナライザーのようなライフサイクルに関する保証は尊重されます。</p>
<p>TTL秒はいつでもセット可能です。下記はJobの<code>.spec.ttlSecondsAfterFinished</code>フィールドのセットに関するいくつかの例です。</p>
<ul>
<li>Jobがその終了後にいくつか時間がたった後に自動的にクリーンアップできるように、そのリソースマニフェストにこの値を指定します。</li>
<li>この新しい機能を適用させるために、存在していてすでに終了したリソースに対してこのフィールドをセットします。</li>
<li>リソース作成時に、このフィールドを動的にセットするために、<a href=/docs/reference/access-authn-authz/extensible-admission-controllers/#admission-webhooks>管理webhookの変更</a>をさせます。クラスター管理者は、終了したリソースに対して、このTTLポリシーを強制するために使うことができます。</li>
<li>リソースが終了した後に、このフィールドを動的にセットしたり、リソースステータスやラベルなどの値に基づいて異なるTTL値を選択するために、<a href=/docs/reference/access-authn-authz/extensible-admission-controllers/#admission-webhooks>管理webhookの変更</a>をさせます。</li>
</ul>
<h2 id=注意>注意</h2>
<h3 id=ttl秒の更新>TTL秒の更新</h3>
<p>注意点として、Jobの<code>.spec.ttlSecondsAfterFinished</code>フィールドといったTTL期間はリソースが作成された後、もしくは終了した後に変更できます。しかし、一度Jobが削除可能(TTLの期限が切れたとき)になると、それがたとえTTLを伸ばすような更新に対してAPIのレスポンスで成功したと返されたとしても、そのシステムはJobが稼働し続けることをもはや保証しません。</p>
<h3 id=タイムスキュー-time-skew>タイムスキュー(Time Skew)</h3>
<p>TTLコントローラーが、TTL値が期限切れかそうでないかを決定するためにKubernetesリソース内に保存されたタイムスタンプを使うため、この機能はクラスター内のタイムスキュー(時刻のずれ)に対してセンシティブとなります。タイムスキューは、誤った時間にTTLコントローラーに対してリソースオブジェクトのクリーンアップしてしまうことを引き起こすものです。</p>
<p>Kubernetesにおいてタイムスキューを避けるために、全てのNode上でNTPの稼働を必須とします(<a href=https://github.com/kubernetes/kubernetes/issues/6159#issuecomment-93844058>#6159</a>を参照してください)。クロックは常に正しいものではありませんが、Node間におけるその差はとても小さいものとなります。TTLに0でない値をセットするときにこのリスクに対して注意してください。</p>
<h2 id=次の項目>次の項目</h2>
<ul>
<li>
<p><a href=/ja/docs/concepts/workloads/controllers/job/#clean-up-finished-jobs-automatically>Jobの自動クリーンアップ</a></p>
</li>
<li>
<p><a href=https://github.com/kubernetes/enhancements/blob/master/keps/sig-apps/592-ttl-after-finish/README.md>設計ドキュメント</a></p>
</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-2e4cec01c525b45eccd6010e21cc76d9>7 - CronJob</h1>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.8 [beta]</code>
</div>
<p><em>CronJob</em> は繰り返しのスケジュールによって<a class=glossary-tooltip title="A finite or batch task that runs to completion." data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/controllers/job/ target=_blank aria-label=Job>Job</a>を作成します。</p>
<p><em>CronJob</em> オブジェクトとは <em>crontab</em> (cron table)ファイルでみられる一行のようなものです。
<a href=https://ja.wikipedia.org/wiki/Cron>Cron</a>形式で記述された指定のスケジュールの基づき、定期的にジョブが実行されます。</p>
<div class="alert alert-warning caution callout" role=alert>
<strong>注意:</strong> <p>すべての<strong>CronJob</strong><code>スケジュール</code>: 時刻はジョブが開始された<a class=glossary-tooltip title=コントロールプレーン上で動作するコンポーネントで、複数のコントローラープロセスを実行します。 data-toggle=tooltip data-placement=top href=/docs/reference/command-line-tools-reference/kube-controller-manager/ target=_blank aria-label=kube-controller-manager>kube-controller-manager</a>のタイムゾーンに基づいています。</p>
<p>コントロールプレーンがkube-controller-managerをPodもしくは素のコンテナで実行している場合、CronJobコントローラーのタイムゾーンとして、kube-controller-managerコンテナに設定されたタイムゾーンを使用します。</p>
</div>
<p>CronJobリソースのためのマニフェストを作成する場合、その名前が有効な<a href=/ja/docs/concepts/overview/working-with-objects/names#dns-subdomain-names>DNSサブドメイン名</a>か確認してください。
名前は52文字を超えることはできません。これはCronJobコントローラーが自動的に、与えられたジョブ名に11文字を追加し、ジョブ名の長さは最大で63文字以内という制約があるためです。</p>
<h2 id=cronjob>CronJob</h2>
<p>CronJobは、バックアップの実行やメール送信のような定期的であったり頻発するタスクの作成に役立ちます。
CronJobは、クラスターがアイドル状態になりそうなときにJobをスケジューリングするなど、特定の時間に個々のタスクをスケジュールすることもできます。</p>
<h3 id=例>例</h3>
<p>このCronJobマニフェスト例は、毎分ごとに現在の時刻とhelloメッセージを表示します。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/release-1.23/content/ja/examples/application/job/cronjob.yaml download=application/job/cronjob.yaml><code>application/job/cronjob.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('application-job-cronjob-yaml')" title="Copy application/job/cronjob.yaml to clipboard">
</img>
</div>
<div class=includecode id=application-job-cronjob-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>batch/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>CronJob<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>hello<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>schedule</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;* * * * *&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>jobTemplate</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>hello<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span>- /bin/sh<span style=color:#bbb>
</span><span style=color:#bbb>            </span>- -c<span style=color:#bbb>
</span><span style=color:#bbb>            </span>- date; echo Hello from the Kubernetes cluster<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>OnFailure<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>(<a href=/ja/docs/tasks/job/automated-tasks-with-cron-jobs/>Running Automated Tasks with a CronJob</a>ではこの例をより詳しく説明しています。).</p>
<h2 id=cron-job-limitations>CronJobの制限</h2>
<p>cronジョブは一度のスケジュール実行につき、 <em>おおよそ</em> 1つのジョブオブジェクトを作成します。ここで <em>おおよそ</em> と言っているのは、ある状況下では2つのジョブが作成される、もしくは1つも作成されない場合があるためです。通常、このようなことが起こらないようになっていますが、完全に防ぐことはできません。したがって、ジョブは <em>冪等</em> であるべきです。</p>
<p><code>startingDeadlineSeconds</code>が大きな値、もしくは設定されていない(デフォルト)、そして、<code>concurrencyPolicy</code>を<code>Allow</code>に設定している場合には、少なくとも一度、ジョブが実行されることを保証します。</p>
<p>最後にスケジュールされた時刻から現在までの間に、CronJob<a class=glossary-tooltip title=クラスターの状態をAPIサーバーから取得、見張る制御ループで、現在の状態を望ましい状態に移行するように更新します。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/architecture/controller/ target=_blank aria-label=コントローラー>コントローラー</a>はどれだけスケジュールが間に合わなかったのかをCronJobごとにチェックします。もし、100回以上スケジュールが失敗していると、ジョブは開始されずに、ログにエラーが記録されます。</p>
<pre><code>Cannot determine if job needs to be started. Too many missed start time (&gt; 100). Set or decrease .spec.startingDeadlineSeconds or check clock skew.
</code></pre><p><code>startingDeadlineSeconds</code>フィールドが設定されると(<code>nil</code>ではない)、最後に実行された時刻から現在までではなく、<code>startingDeadlineSeconds</code>の値から現在までで、どれだけジョブを逃したのかをコントローラーが数えます。 <code>startingDeadlineSeconds</code>が<code>200</code>の場合、過去200秒間にジョブが失敗した回数を記録します。</p>
<p>スケジュールされた時間にCronJobが作成できないと、失敗したとみなされます。たとえば、<code>concurrencyPolicy</code>が<code>Forbid</code>に設定されている場合、前回のスケジュールがまだ実行中にCronJobをスケジュールしようとすると、CronJobは作成されません。</p>
<p>例として、CronJobが<code>08:30:00</code>を開始時刻として1分ごとに新しいJobをスケジュールするように設定され、<code>startingDeadlineSeconds</code>フィールドが設定されていない場合を想定します。CronJobコントローラーが<code>08:29:00</code> から<code>10:21:00</code>の間にダウンしていた場合、スケジューリングを逃したジョブの数が100を超えているため、ジョブは開始されません。</p>
<p>このコンセプトをさらに掘り下げるために、CronJobが<code>08:30:00</code>から1分ごとに新しいJobを作成し、<code>startingDeadlineSeconds</code>が200秒に設定されている場合を想定します。CronJobコントローラーが前回の例と同じ期間(<code>08:29:00</code> から<code>10:21:00</code>まで)にダウンしている場合でも、10:22:00時点でJobはまだ動作しています。このようなことは、過去200秒間(言い換えると、3回の失敗)に何回スケジュールが間に合わなかったをコントローラーが確認するときに発生します。これは最後にスケジュールされた時間から今までのものではありません。</p>
<p>CronJobはスケジュールに一致するJobの作成にのみ関与するのに対して、JobはJobが示すPod管理を担います。</p>
<h2 id=次の項目>次の項目</h2>
<p><a href=https://en.wikipedia.org/wiki/Cron>Cron表現形式</a>では、CronJobの<code>schedule</code>フィールドのフォーマットを説明しています。</p>
<p>cronジョブの作成や動作の説明、CronJobマニフェストの例については、<a href=/docs/tasks/job/automated-tasks-with-cron-jobs>Running automated tasks with cron jobs</a>を見てください。</p>
</div>
</main>
</div>
</div>
<footer class=d-print-none>
<div class=footer__links>
<nav>
<a class=text-white href=/ja/docs/home/>ホーム</a>
<a class=text-white href=/ja/blog/>Blogs</a>
<a class=text-white href=/ja/training/>トレーニング</a>
<a class=text-white href=/ja/partners/>パートナー</a>
<a class=text-white href=/ja/community/>コミュニティ</a>
<a class=text-white href=/ja/case-studies/>ケーススタディ</a>
</nav>
</div>
<div class=container-fluid>
<div class=row>
<div class="col-6 col-sm-2 text-xs-center order-sm-2">
<ul class="list-inline mb-0">
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="User mailing list" aria-label="User mailing list">
<a class=text-white target=_blank href=https://discuss.kubernetes.io>
<i class="fa fa-envelope"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Twitter aria-label=Twitter>
<a class=text-white target=_blank href=https://twitter.com/kubernetesio>
<i class="fab fa-twitter"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Calendar aria-label=Calendar>
<a class=text-white target=_blank href="https://calendar.google.com/calendar/embed?src=calendar%40kubernetes.io">
<i class="fas fa-calendar-alt"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Youtube aria-label=Youtube>
<a class=text-white target=_blank href=https://youtube.com/kubernetescommunity>
<i class="fab fa-youtube"></i>
</a>
</li>
</ul>
</div>
<div class="col-6 col-sm-2 text-right text-xs-center order-sm-3">
<ul class="list-inline mb-0">
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub>
<a class=text-white target=_blank href=https://github.com/kubernetes/kubernetes>
<i class="fab fa-github"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Slack aria-label=Slack>
<a class=text-white target=_blank href=https://slack.k8s.io>
<i class="fab fa-slack"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Contribute aria-label=Contribute>
<a class=text-white target=_blank href=https://git.k8s.io/community/contributors/guide>
<i class="fas fa-edit"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Stack Overflow" aria-label="Stack Overflow">
<a class=text-white target=_blank href=https://stackoverflow.com/questions/tagged/kubernetes>
<i class="fab fa-stack-overflow"></i>
</a>
</li>
</ul>
</div>
<div class="col-12 col-sm-8 text-center order-sm-2">
<small class=text-white>&copy; 2023 The Kubernetes Authors | Documentation Distributed under <a href=https://git.k8s.io/website/LICENSE class=light-text>CC BY 4.0</a></small>
<br>
<small class=text-white>Copyright &copy; 2023 The Linux Foundation &reg;. All rights reserved. The Linux Foundation has registered trademarks and uses trademarks. For a list of trademarks of The Linux Foundation, please see our <a href=https://www.linuxfoundation.org/trademark-usage class=light-text>Trademark Usage page</a></small>
<br>
<small class=text-white>ICP license: 京ICP备17074266号-3</small>
</div>
</div>
</div>
</footer>
</div>
<script src=/js/popper-1.14.3.min.js integrity=sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49 crossorigin=anonymous></script>
<script src=/js/bootstrap-4.3.1.min.js integrity=sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM crossorigin=anonymous></script>
<script src=/js/main.min.40616251a9b6e4b689e7769be0340661efa4d7ebb73f957404e963e135b4ed52.js integrity="sha256-QGFiUam25LaJ53ab4DQGYe+k1+u3P5V0BOlj4TW07VI=" crossorigin=anonymous></script>
</body>
</html>