<!doctype html><html lang=ja class=no-js>
<head>
<meta name=ROBOTS content="NOINDEX, NOFOLLOW">
<script async src="https://www.googletagmanager.com/gtag/js?id=G-JPP6RFM2BP"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-JPP6RFM2BP')</script>
<link rel=alternate hreflang=en href=https://kubernetes.io/docs/concepts/containers/>
<link rel=alternate hreflang=zh href=https://kubernetes.io/zh/docs/concepts/containers/>
<link rel=alternate hreflang=ko href=https://kubernetes.io/ko/docs/concepts/containers/>
<link rel=alternate hreflang=fr href=https://kubernetes.io/fr/docs/concepts/containers/>
<link rel=alternate hreflang=it href=https://kubernetes.io/it/docs/concepts/containers/>
<link rel=alternate hreflang=de href=https://kubernetes.io/de/docs/concepts/containers/>
<link rel=alternate hreflang=es href=https://kubernetes.io/es/docs/concepts/containers/>
<link rel=alternate hreflang=pt-br href=https://kubernetes.io/pt-br/docs/concepts/containers/>
<link rel=alternate hreflang=id href=https://kubernetes.io/id/docs/concepts/containers/>
<link rel=alternate hreflang=vi href=https://kubernetes.io/vi/docs/concepts/containers/>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=generator content="Hugo 0.87.0">
<link rel=canonical type=text/html href=https://kubernetes.io/ja/docs/concepts/containers/>
<link rel="shortcut icon" type=image/png href=/images/favicon.png>
<link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180>
<link rel=manifest href=/manifest.webmanifest>
<link rel=apple-touch-icon href=/images/kubernetes-192x192.png>
<title>コンテナ | Kubernetes</title><meta property="og:title" content="コンテナ">
<meta property="og:description" content="アプリケーションとランタイムの依存関係を一緒にパッケージ化するための技術">
<meta property="og:type" content="website">
<meta property="og:url" content="https://kubernetes.io/ja/docs/concepts/containers/"><meta property="og:site_name" content="Kubernetes">
<meta itemprop=name content="コンテナ">
<meta itemprop=description content="アプリケーションとランタイムの依存関係を一緒にパッケージ化するための技術"><meta name=twitter:card content="summary">
<meta name=twitter:title content="コンテナ">
<meta name=twitter:description content="アプリケーションとランタイムの依存関係を一緒にパッケージ化するための技術">
<link href=/scss/main.css rel=stylesheet>
<script src=/js/jquery-3.3.1.min.js integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin=anonymous></script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","url":"https://kubernetes.io","logo":"https://kubernetes.io/images/favicon.png"}</script>
<meta name=theme-color content="#326ce5">
<link rel=stylesheet href=/css/feature-states.css>
<meta name=description content="アプリケーションとランタイムの依存関係を一緒にパッケージ化するための技術">
<meta property="og:description" content="アプリケーションとランタイムの依存関係を一緒にパッケージ化するための技術">
<meta name=twitter:description content="アプリケーションとランタイムの依存関係を一緒にパッケージ化するための技術">
<meta property="og:url" content="https://kubernetes.io/ja/docs/concepts/containers/">
<meta property="og:title" content="コンテナ">
<meta name=twitter:title content="コンテナ">
<meta name=twitter:image content="https://kubernetes.io/images/favicon.png">
<meta name=twitter:image:alt content="Kubernetes">
<meta property="og:image" content="/images/kubernetes-horizontal-color.png">
<meta property="og:type" content="article">
<script src=/js/script.js></script>
</head>
<body class=td-section>
<header>
<nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar" data-auto-burger=primary>
<a class=navbar-brand href=/ja/></a>
<div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar>
<ul class="navbar-nav mt-2 mt-lg-0">
<li class="nav-item mr-2 mb-lg-0">
<a class="nav-link active" href=/ja/docs/>ドキュメント</a>
</li>
<li class="nav-item mr-2 mb-lg-0">
<a class=nav-link href=/ja/blog/>Blogs</a>
</li>
<li class="nav-item mr-2 mb-lg-0">
<a class=nav-link href=/ja/training/>トレーニング</a>
</li>
<li class="nav-item mr-2 mb-lg-0">
<a class=nav-link href=/ja/partners/>パートナー</a>
</li>
<li class="nav-item mr-2 mb-lg-0">
<a class=nav-link href=/ja/community/>コミュニティ</a>
</li>
<li class="nav-item mr-2 mb-lg-0">
<a class=nav-link href=/ja/case-studies/>ケーススタディ</a>
</li>
<li class="nav-item dropdown">
<a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>
バージョン
</a>
<div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink>
<a class=dropdown-item href=/releases>Release Information</a>
<a class=dropdown-item href=https://kubernetes.io/ja/docs/concepts/containers/>v1.27</a>
<a class=dropdown-item href=https://v1-26.docs.kubernetes.io/ja/docs/concepts/containers/>v1.26</a>
<a class=dropdown-item href=https://v1-25.docs.kubernetes.io/ja/docs/concepts/containers/>v1.25</a>
<a class=dropdown-item href=https://v1-24.docs.kubernetes.io/ja/docs/concepts/containers/>v1.24</a>
<a class=dropdown-item href=https://v1-23.docs.kubernetes.io/ja/docs/concepts/containers/>v1.23</a>
</div>
</li>
<li class="nav-item dropdown">
<a class="nav-link dropdown-toggle" href=# id=navbarDropdownMenuLink role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>
日本語 Japanese
</a>
<div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink>
<a class=dropdown-item href=/docs/concepts/containers/>English</a>
<a class=dropdown-item href=/zh/docs/concepts/containers/>中文 Chinese</a>
<a class=dropdown-item href=/ko/docs/concepts/containers/>한국어 Korean</a>
<a class=dropdown-item href=/fr/docs/concepts/containers/>Français</a>
<a class=dropdown-item href=/it/docs/concepts/containers/>Italiano</a>
<a class=dropdown-item href=/de/docs/concepts/containers/>Deutsch</a>
<a class=dropdown-item href=/es/docs/concepts/containers/>Español</a>
<a class=dropdown-item href=/pt-br/docs/concepts/containers/>Português</a>
<a class=dropdown-item href=/id/docs/concepts/containers/>Bahasa Indonesia</a>
<a class=dropdown-item href=/vi/docs/concepts/containers/>Tiếng Việt</a>
</div>
</li>
</ul>
</div>
<button id=hamburger onclick=kub.toggleMenu() data-auto-burger-exclude><div></div></button>
</nav>
</header>
<div class="container-fluid td-outer">
<div class=td-main>
<div class="row flex-xl-nowrap">
<main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main>
<div class=td-content>
<div class="pageinfo pageinfo-primary d-print-none">
<p>
これは、このセクションの複数ページの印刷可能なビューです。
<a href=# onclick="return print(),!1">印刷するには、ここをクリックしてください</a>.
</p><p>
<a href=/ja/docs/concepts/containers/>このページの通常のビューに戻る</a>.
</p>
</div>
<h1 class=title>コンテナ</h1>
<div class=lead>アプリケーションとランタイムの依存関係を一緒にパッケージ化するための技術</div>
<ul>
<li>1: <a href=#pg-8fda96dc403731ceba5e0ddd0ab3ad15>コンテナの概要</a></li>
<li>2: <a href=#pg-16042b4652ad19e565c7263824029a43>イメージ</a></li>
<li>3: <a href=#pg-643212488f778acf04bebed65ba34441>コンテナ環境</a></li>
<li>4: <a href=#pg-a858027489648786a3b16264e451272b>ランタイムクラス(Runtime Class)</a></li>
<li>5: <a href=#pg-e6941d969d81540208a3e78bc56f43bc>コンテナライフサイクルフック</a></li>
</ul>
<div class=content>
<p>実行するそれぞれのコンテナは繰り返し使用可能です。依存関係を含めて標準化されており、どこで実行しても同じ動作が得られることを意味しています。</p>
<p>コンテナは基盤となるホストインフラからアプリケーションを切り離します。これにより、さまざまなクラウドやOS環境下でのデプロイが容易になります。</p>
<h2 id=container-images>コンテナイメージ</h2>
<p><a href=/ja/docs/concepts/containers/images/>コンテナイメージ</a>はすぐに実行可能なソフトウェアパッケージで、アプリケーションの実行に必要なものをすべて含んています。コードと必要なランタイム、アプリケーションとシステムのライブラリ、そして必須な設定項目のデフォルト値を含みます。</p>
<p>設計上、コンテナは不変で、既に実行中のコンテナのコードを変更することはできません。コンテナ化されたアプリケーションがあり変更したい場合は、変更を含んだ新しいイメージをビルドし、コンテナを再作成して、更新されたイメージから起動する必要があります。</p>
<h2 id=コンテナランタイム>コンテナランタイム</h2>
<p>コンテナランタイムは、コンテナの実行を担当するソフトウェアです。</p>
<p>Kubernetesは次の複数のコンテナランタイムをサポートします。
<a class=glossary-tooltip title=Dockerは、コンテナとして知られる、オペレーティングシステムレベルでの仮想化を提供するソフトウェア技術です。 data-toggle=tooltip data-placement=top href=https://docs.docker.com/engine/ target=_blank aria-label=Docker>Docker</a>、<a class=glossary-tooltip title="A container runtime with an emphasis on simplicity, robustness and portability" data-toggle=tooltip data-placement=top href=https://containerd.io/docs/ target=_blank aria-label=containerd>containerd</a>、<a class=glossary-tooltip title="A lightweight container runtime specifically for Kubernetes" data-toggle=tooltip data-placement=top href=https://cri-o.io/#what-is-cri-o target=_blank aria-label=CRI-O>CRI-O</a>、
および全ての
<a href=https://github.com/kubernetes/community/blob/master/contributors/devel/sig-node/container-runtime-interface.md>Kubernetes CRI (Container Runtime Interface)</a>
実装です。</p>
<h2 id=次の項目>次の項目</h2>
<ul>
<li><a href=/docs/concepts/containers/images/>コンテナイメージ</a>についてお読みください。</li>
<li><a href=/ja/docs/concepts/workloads/pods/>Pod</a>についてお読みください。</li>
</ul>
</div>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-8fda96dc403731ceba5e0ddd0ab3ad15>1 - コンテナの概要</h1>
<p>コンテナは、アプリケーションの(コンパイルされた)コードと、実行時に必要な依存関係をパッケージ化するための技術です。実行する各コンテナは再現性があります。依存関係を含めることによる標準化は、どこで実行しても同じ動作が得られることを意味します。</p>
<p>コンテナは、基礎となるホストインフラストラクチャからアプリケーションを切り離します。これにより、さまざまなクラウド環境やOS環境でのデプロイが容易になります。</p>
<h2 id=container-images>コンテナイメージ</h2>
<p><a href=/docs/concepts/containers/images/>コンテナイメージ</a>は、アプリケーションを実行するために必要なすべてのものを含んだ、すぐに実行可能なソフトウェアパッケージです。コードとそれが必要とする任意のランタイム、アプリケーションとシステムのライブラリ、および必須の設定のデフォルト値が含まれています。</p>
<p>設計上、コンテナは不変であるため、すでに実行中のコンテナのコードを変更することはできません。コンテナ化されたアプリケーションがあり、変更を加えたい場合は、変更を含む新しいコンテナをビルドし、コンテナを再作成して更新されたイメージから起動する必要があります。</p>
<h2 id=container-runtimes>コンテナランタイム</h2>
<p>コンテナランタイムは、コンテナの実行を担当するソフトウェアです。</p>
<p>Kubernetesは次の複数のコンテナランタイムをサポートします。
<a class=glossary-tooltip title=Dockerは、コンテナとして知られる、オペレーティングシステムレベルでの仮想化を提供するソフトウェア技術です。 data-toggle=tooltip data-placement=top href=https://docs.docker.com/engine/ target=_blank aria-label=Docker>Docker</a>、<a class=glossary-tooltip title="A container runtime with an emphasis on simplicity, robustness and portability" data-toggle=tooltip data-placement=top href=https://containerd.io/docs/ target=_blank aria-label=containerd>containerd</a>、<a class=glossary-tooltip title="A lightweight container runtime specifically for Kubernetes" data-toggle=tooltip data-placement=top href=https://cri-o.io/#what-is-cri-o target=_blank aria-label=CRI-O>CRI-O</a>、
および全ての
<a href=https://github.com/kubernetes/community/blob/master/contributors/devel/sig-node/container-runtime-interface.md>Kubernetes CRI (Container Runtime Interface)</a>
実装です。</p>
<h2 id=次の項目>次の項目</h2>
<ul>
<li><a href=/docs/concepts/containers/images/>コンテナイメージ</a>についてお読みください。</li>
<li><a href=/ja/docs/concepts/workloads/pods/>Pod</a>についてお読みください。</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-16042b4652ad19e565c7263824029a43>2 - イメージ</h1>
<p>コンテナイメージはアプリケーションと依存関係のあるすべてソフトウェアをカプセル化したバイナリデータを表します。コンテナイメージはスタンドアロンで実行可能なソフトウェアをひとつにまとめ、ランタイム環境に関する想定を明確に定義しています。</p>
<p>アプリケーションのコンテナイメージを作成し、一般的には<a class=glossary-tooltip title="一番小さく一番シンプルな Kubernetes のオブジェクト。Pod とはクラスターで動作しているいくつかのコンテナのまとまりです。" data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a>で参照する前にレジストリへPushします。</p>
<p>このページではコンテナイメージの概要を説明します。</p>
<h2 id=イメージの名称>イメージの名称</h2>
<p>コンテナイメージは、<code>pause</code>、<code>example/mycontainer</code>、または<code>kube-apiserver</code>のような名前が通常つけられます。
イメージにはレジストリのホスト名も含めることができ（例：<code>fictional.registry.example/imagename</code>）、さらにポート番号も含めることが可能です（例：<code>fictional.registry.example:10443/imagename</code>）。</p>
<p>レジストリのホスト名を指定しない場合は、KubernetesはDockerパブリックレジストリを意味していると見なします。</p>
<p>イメージ名の後に、<em>タグ</em> を追加することができます（<code>docker</code>や<code>podman</code>のようなコマンドを利用した場合と同様）。
タグによって同じイメージの異なるバージョンを識別できます。</p>
<p>イメージタグは大文字と小文字、数値、アンダースコア(<code>_</code>)、ピリオド(<code>.</code>)とマイナス(<code>-</code>)で構成されます。
イメージタグでは区切り記号(<code>_</code>、<code>-</code>、<code>.</code>)を指定できる追加ルールがあります。
タグを指定しない場合は、Kubernetesは<code>latest</code>タグを指定したと見なします。</p>
<div class="alert alert-warning caution callout" role=alert>
<strong>注意:</strong> <p>本番環境でコンテナをデプロイする場合は、<code>latest</code>タグの使用を避けるべきです。
実行中のイメージのバージョンを追跡するのが難しく、機能しているバージョンへのロールバックがより困難になるためです。</p>
<p>かわりに、<code>v1.42.0</code>のような特定できるタグを指定してください。</p>
</div>
<h2 id=イメージの更新>イメージの更新</h2>
<p>デフォルトのpull policyでは、<a class=glossary-tooltip title=クラスター内の各ノードで実行されるエージェントです。各コンテナがPodで実行されていることを保証します。 data-toggle=tooltip data-placement=top href=/docs/reference/generated/kubelet target=_blank aria-label=kubelet>kubelet</a>はイメージを既に取得済みの場合、イメージのPullをスキップさせる<code>IfNotPresent</code>が設定されています。
常にPullを強制させたい場合は、次のいずれかの方法で実行できます。</p>
<ul>
<li>コンテナの<code>imagePullPolicy</code>に<code>Always</code>を設定する</li>
<li><code>imagePullPolicy</code>を省略し、使用するイメージに<code>:latest</code>タグを使用する</li>
<li><code>imagePullPolicy</code>と使用するイメージのタグを省略する</li>
<li><a href=/docs/reference/access-authn-authz/admission-controllers/#alwayspullimages>AlwaysPullImages</a>アドミッションコントローラーを有効にする</li>
</ul>
<p><code>imagePullPolicy</code>が値なしで定義された場合、この場合も<code>Always</code>が設定されます。</p>
<h2 id=イメージインデックスを使ったマルチアーキテクチャイメージ>イメージインデックスを使ったマルチアーキテクチャイメージ</h2>
<p>コンテナレジストリはバイナリイメージの提供だけでなく、<a href=https://github.com/opencontainers/image-spec/blob/master/image-index.md>コンテナイメージインデックス</a>も提供する事ができます。イメージインデックスはコンテナのアーキテクチャ固有バージョンに関する複数の<a href=https://github.com/opencontainers/image-spec/blob/master/manifest.md>イメージマニフェスト</a>を指すことができます。イメージインデックスの目的はイメージの名前(例:<code>pause</code>、<code>example/mycontainer</code>、<code>kube-apiserver</code>)をもたせ、様々なシステムが使用しているマシンアーキテクチャにあう適切なバイナリイメージを取得できることです。</p>
<p>Kubernetes自身は、通常コンテナイメージに<code>-$(ARCH)</code>のサフィックスを持つ名前をつけます。下位互換の為にサフィックス付きの古い仕様のイメージを生成してください。その目的は、<code>pause</code>のようなすべてのアーキテクチャのマニフェストを持つイメージと、サフィックスのあるイメージをハードコードしていた可能性のある古い仕様の設定やYAMLファイルと下位互換がある<code>pause-amd64</code>のようなイメージを生成することです。</p>
<h2 id=プライベートレジストリを使用する方法>プライベートレジストリを使用する方法</h2>
<p>プライベートレジストリではイメージを読み込む為にキーが必要になる場合があります。<br>
認証情報はいくつかの方法で提供できます。</p>
<ul>
<li>プライベートレジストリへの認証をNodeに設定する
<ul>
<li>すべてのPodがプライベートレジストリを読み取ることができる</li>
<li>クラスター管理者によるNodeの設定が必要</li>
</ul>
</li>
<li>事前にPullされたイメージ
<ul>
<li>すべてのPodがNode上にキャッシュされたイメージを利用できる</li>
<li>セットアップするためにはすべてのNodeに対するrootアクセスが必要</li>
</ul>
</li>
<li>PodでImagePullSecretsを指定する
<ul>
<li>キーを提供したPodのみがプライベートレジストリへアクセスできる</li>
</ul>
</li>
<li>ベンダー固有またはローカルエクステンション
<ul>
<li>カスタムNode構成を使っている場合、あなた(または、あなたのクラウドプロバイダー)はコンテナレジストリへの認証の仕組みを組み込むことができる</li>
</ul>
</li>
</ul>
<p>これらのオプションについて、以下で詳しく説明します。</p>
<h3 id=プライベートレジストリへの認証をnodeに設定する>プライベートレジストリへの認証をNodeに設定する</h3>
<p>Node上でDockerを実行している場合、プライベートコンテナレジストリへの認証をDockerコンテナランタイムに設定できます。</p>
<p>Node構成を制御できる場合は、この方法が適しています。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> KubernetesはDocker構成の<code>auths</code>と<code>HttpHeaders</code>セクションのみをサポートしています。
Docker認証情報ヘルパー(<code>credHelpers</code>または<code>credsStore</code>)はサポートされていません。
</div>
<p>Dockerは、<code>$HOME/.dockercfg</code>または<code>$HOME/.docker/config.json</code>ファイルの中に、プライベートレジストリのキーを保持します。
下記リストの検索パスに同じファイルを配置した場合、kubeletはイメージをPullする時に認証情報プロバイダーとして利用します。</p>
<ul>
<li><code>{--root-dir:-/var/lib/kubelet}/config.json</code></li>
<li><code>{cwd of kubelet}/config.json</code></li>
<li><code>${HOME}/.docker/config.json</code></li>
<li><code>/.docker/config.json</code></li>
<li><code>{--root-dir:-/var/lib/kubelet}/.dockercfg</code></li>
<li><code>{cwd of kubelet}/.dockercfg</code></li>
<li><code>${HOME}/.dockercfg</code></li>
<li><code>/.dockercfg</code></li>
</ul>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> kubeletプロセスの環境では、明示的に<code>HOME=/root</code>を設定する必要がある場合があります。
</div>
<p>以下は、プライベートレジストリを使用する為にNodeを構成する推奨の手順です。この例では、デスクトップ/ノートPC上で実行します。</p>
<ol>
<li>使用したい認証情報のセット毎に <code>docker login [server]</code>を実行する。これであなたのPC上の<code>$HOME/.docker/config.json</code>が更新される</li>
<li>使用したい認証情報が含まれているかを確認するため、エディターで<code>$HOME/.docker/config.json</code>を見る</li>
<li>Nodeの一覧を取得 例:
<ul>
<li>名称が必要な場合: <code>nodes=$( kubectl get nodes -o jsonpath='{range.items[*].metadata}{.name} {end}' )</code></li>
<li>IPアドレスを取得したい場合: <code>nodes=$( kubectl get nodes -o jsonpath='{range .items[*].status.addresses[?(@.type=="ExternalIP")]}{.address} {end}' )</code></li>
</ul>
</li>
<li>ローカルの<code>.docker/config.json</code>を上記の検索パスのいずれかにコピーする
<ul>
<li>例えば、これでテストを実施する: <code>for n in $nodes; do scp ~/.docker/config.json root@"$n":/var/lib/kubelet/config.json; done</code></li>
</ul>
</li>
</ol>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> 本番環境用クラスターでは、構成管理ツールを使用して必要なすべてのNodeに設定を反映してください。
</div>
<p>プライベートイメージを使用するPodを作成し確認します。
例:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f - <span style=color:#b44>&lt;&lt;EOF
</span><span style=color:#b44>apiVersion: v1
</span><span style=color:#b44>kind: Pod
</span><span style=color:#b44>metadata:
</span><span style=color:#b44>  name: private-image-test-1
</span><span style=color:#b44>spec:
</span><span style=color:#b44>  containers:
</span><span style=color:#b44>    - name: uses-private-image
</span><span style=color:#b44>      image: $PRIVATE_IMAGE_NAME
</span><span style=color:#b44>      imagePullPolicy: Always
</span><span style=color:#b44>      command: [ &#34;echo&#34;, &#34;SUCCESS&#34; ]
</span><span style=color:#b44>EOF</span>
</code></pre></div><pre><code>pod/private-image-test-1 created
</code></pre><p>すべてが機能している場合は、しばらくしてから以下のコマンドを実行します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl logs private-image-test-1
</code></pre></div><p>コマンドの結果を確認してください。</p>
<pre><code>SUCCESS
</code></pre><p>コマンドが失敗したと思われる場合には、以下を実行します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe pods/private-image-test-1 | grep <span style=color:#b44>&#39;Failed&#39;</span>
</code></pre></div><p>失敗している場合、結果が次のようになります。</p>
<pre><code>  Fri, 26 Jun 2015 15:36:13 -0700    Fri, 26 Jun 2015 15:39:13 -0700    19    {kubelet node-i2hq}    spec.containers{uses-private-image}    failed        Failed to pull image &quot;user/privaterepo:v1&quot;: Error: image user/privaterepo:v1 not found
</code></pre><p>クラスターのすべてのNodeが同じ<code>.docker/config.json</code>になっているかを確認する必要があります。
そうでない場合、Podは一部のNodeで実行できますが他のNodeでは実行に失敗します。
例えば、Nodeのオートスケールを使用している場合、各インスタンスのテンプレートに<code>.docker/config.json</code>が含まれている、またはこのファイルが含まれているドライブをマウントする必要があります。</p>
<p>プライベートレジストリキーを<code>.docker/config.json</code>に追加した時点で、すべてのPodがプライベートレジストリのイメージに読み取りアクセス権も持つようになります。</p>
<h3 id=事前にpullしたイメージ>事前にPullしたイメージ</h3>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> Node構成を制御できる場合、この方法が適しています。
クラウドプロバイダーがNodeを管理し自動的に設定を置き換える場合は、確実に機能できません。
</div>
<p>デフォルトでは、kubeletは指定されたレジストリからそれぞれのイメージをPullしようとします。
また一方では、コンテナの<code>imagePullPolicy</code>プロパティに<code>IfNotPresent</code>や<code>Never</code>が設定されている場合、ローカルのイメージが使用されます。(それぞれに対して、優先的またはか排他的に)</p>
<p>レジストリ認証の代替として事前にPullしたイメージを利用したい場合、クラスターのすべてのNodeが同じ事前にPullしたイメージを持っていることを確認する必要があります。</p>
<p>特定のイメージをあらかじめロードしておくことは高速化やプライベートレジストリへの認証の代替として利用することができます。</p>
<p>すべてのPodは事前にPullしたイメージへの読み取りアクセス権をもちます。</p>
<h3 id=podでimagepullsecretsを指定する>PodでimagePullSecretsを指定する</h3>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> この方法がプライベートレジストリのイメージに基づいてコンテナを実行するための推奨の方法です。
</div>
<p>KubernetesはPodでのコンテナイメージレジストリキーの指定をサポートしています。</p>
<h4 id=dockerの設定を利用してsecretを作成する>Dockerの設定を利用してSecretを作成する。</h4>
<p>適切な大文字の値を置き換えて、次のコマンドを実行します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create secret docker-registry &lt;name&gt; --docker-server<span style=color:#666>=</span>DOCKER_REGISTRY_SERVER --docker-username<span style=color:#666>=</span>DOCKER_USER --docker-password<span style=color:#666>=</span>DOCKER_PASSWORD --docker-email<span style=color:#666>=</span>DOCKER_EMAIL
</code></pre></div><p>既にDocker認証情報ファイルを持っている場合は、上記のコマンドの代わりに、認証情報ファイルをKubernetes <a class=glossary-tooltip title=パスワードやOAuthトークン、SSHキーのような機密の情報を保持します。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/configuration/secret/ target=_blank aria-label=Secrets>Secrets</a>としてインポートすることができます。
<a href=/docs/tasks/configure-pod-container/pull-image-private-registry/#registry-secret-existing-credentials>既存のDocker認証情報に基づいてSecretを作成する</a> で、この設定方法を説明します.</p>
<p>これは複数のプライベートコンテナレジストリを使用している場合に特に有効です。<code>kubectl create secret docker-registry</code>はひとつのプライベートレジストリにのみ機能するSecretを作成するからです。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> Podは自分自身のNamespace内にあるimage pull secretsのみが参照可能であるため、この作業はNemespace毎に1回行う必要があります。
</div>
<h4 id=podのimagepullsecretsを参照する方法>PodのimagePullSecretsを参照する方法</h4>
<p>これで、<code>imagePullSecrets</code>セクションをPod定義へ追加することでSecretを参照するPodを作成できます。</p>
<p>例:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>cat <span style=color:#b44>&lt;&lt;EOF &gt; pod.yaml
</span><span style=color:#b44>apiVersion: v1
</span><span style=color:#b44>kind: Pod
</span><span style=color:#b44>metadata:
</span><span style=color:#b44>  name: foo
</span><span style=color:#b44>  namespace: awesomeapps
</span><span style=color:#b44>spec:
</span><span style=color:#b44>  containers:
</span><span style=color:#b44>    - name: foo
</span><span style=color:#b44>      image: janedoe/awesomeapp:v1
</span><span style=color:#b44>  imagePullSecrets:
</span><span style=color:#b44>    - name: myregistrykey
</span><span style=color:#b44>EOF</span>

cat <span style=color:#b44>&lt;&lt;EOF &gt;&gt; ./kustomization.yaml
</span><span style=color:#b44>resources:
</span><span style=color:#b44>- pod.yaml
</span><span style=color:#b44>EOF</span>
</code></pre></div><p>これは、プライベートレジストリを使用する各Podで行う必要があります。</p>
<p>ただし、この項目の設定は<a href=/docs/tasks/configure-pod-container/configure-service-account/>ServiceAccount</a>リソースの中でimagePullSecretsを指定することで自動化することができます。</p>
<p>詳細の手順は、<a href=/docs/tasks/configure-pod-container/configure-service-account/#add-imagepullsecrets-to-a-service-account>ImagePullSecretsをService Accountに追加する</a>をクリックしてください。</p>
<p>これを各Nodeの<code>.docker/config.json</code>に組み合わせて利用できます。認証情報はマージされます。</p>
<h2 id=ユースケース>ユースケース</h2>
<p>プライベートレジストリを設定するためのソリューションはいくつかあります。ここでは、いくつかの一般的なユースケースと推奨される解決方法を示します。</p>
<ol>
<li>クラスターに独自仕様でない(例えば、オープンソース)イメージだけを実行する。イメージを非公開にする必要がない
<ul>
<li>Docker hubのパブリックイメージを利用する
<ul>
<li>設定は必要ない</li>
<li>クラウドプロバイダーによっては、可用性の向上とイメージをPullする時間を短くする為に、自動的にキャッシュやミラーされたパプリックイメージが提供される</li>
</ul>
</li>
</ul>
</li>
<li>社外には非公開の必要があるが、すべてのクラスター利用者には見せてよい独自仕様のイメージをクラスターで実行している
<ul>
<li>ホストされたプライペートな <a href=https://docs.docker.com/registry/>Dockerレジストリ</a>を使用
<ul>
<li><a href=https://hub.docker.com/signup>Docker Hub</a>または他の場所の上でホストされている場合がある</li>
<li>上記のように各Node上のdocker/config.jsonを手動で構成する</li>
</ul>
</li>
<li>または、オープンな読み取りアクセスを許可したファイヤーウォールの背後で内部向けプライベートレジストリを実行する
<ul>
<li>Kubernetesの設定は必要ない</li>
</ul>
</li>
<li>イメージへのアクセスを制御できるホストされたコンテナイメージレジストリサービスを利用する
<ul>
<li>Nodeを手動設定するよりもクラスターのオートスケーリングのほうがうまく機能する</li>
</ul>
</li>
<li>また、Node設定変更を自由にできないクラスターでは<code>imagePullSecrets</code>を使用する</li>
</ul>
</li>
<li>独自仕様のイメージを含むクラスターで、いくつかは厳格なアクセス制御が必要である
<ul>
<li><a href=/docs/reference/access-authn-authz/admission-controllers/#alwayspullimages>AlwaysPullImagesアドミッションコントローラー</a>が有効化かを確認する必要がある。さもないと、全部のPodがすべてのイメージへのアクセスができてしまう可能性がある</li>
<li>機密データはイメージに含めてしまうのではなく、"Secret"リソースに移行する</li>
</ul>
</li>
<li>それぞれのテナントが独自のプライベートレジストリを必要とするマルチテナントのクラスターである
<ul>
<li><a href=/docs/reference/access-authn-authz/admission-controllers/#alwayspullimages>AlwaysPullImagesアドミッションコントローラー</a>が有効化を確認する必要がある。さもないと、すべてのテナントの全Podが全部のイメージにアクセスできてしまう可能性がある</li>
<li>認証が必要なプライベートレジストリを実行する</li>
<li>それぞれのテナントでレジストリ認証を生成し、Secretへ設定し、各テナントのNamespaceに追加する</li>
<li>テナントは、Secretを各NamespaceのimagePullSecretsへ追加する</li>
</ul>
</li>
</ol>
<p>複数のレジストリへのアクセスが必要な場合、それぞれのレジストリ毎にひとつのSecretを作成する事ができます。
Kubeletは複数の<code>imagePullSecrets</code>を単一の仮想的な<code>.docker/config.json</code>にマージします。</p>
<h2 id=次の項目>次の項目</h2>
<ul>
<li><a href=https://github.com/opencontainers/image-spec/blob/master/manifest.md>OCI Image Manifest Specification</a>を読みます。</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-643212488f778acf04bebed65ba34441>3 - コンテナ環境</h1>
<p>このページでは、コンテナ環境で利用可能なリソースについて説明します。</p>
<h2 id=コンテナ環境>コンテナ環境</h2>
<p>Kubernetesはコンテナにいくつかの重要なリソースを提供します。</p>
<ul>
<li>イメージと1つ以上のボリュームの組み合わせのファイルシステム</li>
<li>コンテナ自体に関する情報</li>
<li>クラスター内の他のオブジェクトに関する情報</li>
</ul>
<h3 id=コンテナ情報>コンテナ情報</h3>
<p>コンテナの <em>ホスト名</em> は、コンテナが実行されているPodの名前です。
ホスト名は<code>hostname</code>コマンドまたはlibcの<a href=http://man7.org/linux/man-pages/man2/gethostname.2.html><code>gethostname</code></a>関数呼び出しにより利用可能です。</p>
<p>Podの名前と名前空間は<a href=/docs/tasks/inject-data-application/downward-api-volume-expose-pod-information/>downward API</a>を通じて環境変数として利用可能です。</p>
<p>Pod定義からのユーザー定義の環境変数もコンテナで利用できます。
Dockerイメージで静的に指定されている環境変数も同様です。</p>
<h3 id=クラスター情報>クラスター情報</h3>
<p>コンテナの作成時に実行されていたすべてのサービスのリストは、環境変数として使用できます。
これらの環境変数はDockerリンクの構文と一致します。</p>
<p><em>bar</em> という名前のコンテナに対応する <em>foo</em> という名前のサービスの場合、以下の変数が定義されています。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#b8860b>FOO_SERVICE_HOST</span><span style=color:#666>=</span>&lt;サービスが実行されているホスト&gt;
<span style=color:#b8860b>FOO_SERVICE_PORT</span><span style=color:#666>=</span>&lt;サービスが実行されているポート&gt;
</code></pre></div><p>サービスは専用のIPアドレスを持ち、<a href=http://releases.k8s.io/v1.23.17/cluster/addons/dns/>DNSアドオン</a>が有効の場合、DNSを介してコンテナで利用可能です。</p>
<h2 id=次の項目>次の項目</h2>
<ul>
<li><a href=/ja/docs/concepts/containers/container-lifecycle-hooks/>コンテナライフサイクルフック</a>の詳細</li>
<li><a href=/ja/docs/tasks/configure-pod-container/attach-handler-lifecycle-event/>コンテナライフサイクルイベントへのハンドラー紐付け</a>のハンズオン</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-a858027489648786a3b16264e451272b>4 - ランタイムクラス(Runtime Class)</h1>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.14 [beta]</code>
</div>
<p>このページではRuntimeClassリソースと、runtimeセクションのメカニズムについて説明します。</p>
<p>RuntimeClassはコンテナランタイムの設定を選択するための機能です。そのコンテナランタイム設定はPodのコンテナを稼働させるために使われます。</p>
<h2 id=runtimeclassを使う動機>RuntimeClassを使う動機</h2>
<p>異なるPodに異なるRuntimeClassを設定することで、パフォーマンスとセキュリティのバランスをとることができます。例えば、ワークロードの一部に高レベルの情報セキュリティ保証が必要な場合、ハードウェア仮想化を使用するコンテナランタイムで実行されるようにそれらのPodをスケジュールすることを選択できます。その後、追加のオーバーヘッドを犠牲にして、代替ランタイムをさらに分離することでメリットが得られます。</p>
<p>RuntimeClassを使用して、コンテナランタイムは同じで設定が異なるPodを実行することもできます。</p>
<h2 id=セットアップ>セットアップ</h2>
<p>RuntimeClass機能のフィーチャーゲートが有効になっていることを確認してください(デフォルトで有効です)。フィーチャーゲートを有効にする方法については、<a href=/ja/docs/reference/command-line-tools-reference/feature-gates/>フィーチャーゲート</a>を参照してください。
その<code>RuntimeClass</code>のフィーチャーゲートはApiServerとkubeletのどちらも有効になっていなければなりません。</p>
<ol>
<li>ノード上でCRI実装を設定する。(ランタイムに依存)</li>
<li>対応するRuntimeClassリソースを作成する。</li>
</ol>
<h3 id=1-ノード上でcri実装を設定する>1. ノード上でCRI実装を設定する</h3>
<p>RuntimeClassを通じて利用可能な設定はContainer Runtime Interface (CRI)の実装依存となります。
ユーザーの環境のCRI実装の設定方法は、対応するドキュメント(<a href=#cri-configuration>下記</a>)を参照ください。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> RuntimeClassは、クラスター全体で同じ種類のノード設定であることを仮定しています。(これは全てのノードがコンテナランタイムに関して同じ方法で構成されていることを意味します)。
設定が異なるノードをサポートするには、<a href=#scheduling>スケジューリング</a>を参照してください。
</div>
<p>RuntimeClassの設定は、RuntimeClassによって参照される<code>ハンドラー</code>名を持ちます。そのハンドラーは正式なDNS-1123に準拠する形式のラベルでなくてはなりません(英数字 + <code>-</code>の文字で構成されます)。</p>
<h3 id=2-対応するruntimeclassリソースを作成する>2. 対応するRuntimeClassリソースを作成する</h3>
<p>ステップ1にて設定する各項目は、関連する<code>ハンドラー</code> 名を持ちます。それはどの設定かを指定するものです。各ハンドラーにおいて、対応するRuntimeClassオブジェクトが作成されます。</p>
<p>そのRuntimeClassリソースは現時点で2つの重要なフィールドを持ちます。それはRuntimeClassの名前(<code>metadata.name</code>)とハンドラー(<code>handler</code>)です。そのオブジェクトの定義は下記のようになります。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>node.k8s.io/v1beta1 <span style=color:#bbb> </span><span style=color:#080;font-style:italic># RuntimeClassはnode.k8s.ioというAPIグループで定義されます。</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>RuntimeClass<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>myclass <span style=color:#bbb> </span><span style=color:#080;font-style:italic># RuntimeClass名</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># RuntimeClassはネームスペースなしのリソースです。</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>handler</span>:<span style=color:#bbb> </span>myconfiguration <span style=color:#bbb> </span><span style=color:#080;font-style:italic># 対応するCRI設定</span><span style=color:#bbb>
</span></code></pre></div><p>RuntimeClassオブジェクトの名前は<a href=/ja/docs/concepts/overview/working-with-objects/names#dns-subdomain-names>DNSサブドメイン名</a>に従う必要があります。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> RuntimeClassの書き込み操作(create/update/patch/delete)はクラスター管理者のみに制限されることを推奨します。
これはたいていデフォルトで有効となっています。さらなる詳細に関しては<a href=/docs/reference/access-authn-authz/authorization/>Authorization
Overview</a>を参照してください。
</div>
<h2 id=使用例>使用例</h2>
<p>一度RuntimeClassがクラスターに対して設定されると、それを使用するのは非常に簡単です。PodSpecの<code>runtimeClassName</code>を指定してください。<br>
例えば</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>runtimeClassName</span>:<span style=color:#bbb> </span>myclass<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span></code></pre></div><p>これは、Kubeletに対してPodを稼働させるためのRuntimeClassを使うように指示します。もし設定されたRuntimeClassが存在しない場合や、CRIが対応するハンドラーを実行できない場合、そのPodは<code>Failed</code>という<a href=/ja/docs/concepts/workloads/pods/pod-lifecycle/#pod-phase>フェーズ</a>になります。
エラーメッセージに関しては対応する<a href=/docs/tasks/debug-application-cluster/debug-application-introspection/>イベント</a>を参照して下さい。</p>
<p>もし<code>runtimeClassName</code>が指定されていない場合、デフォルトのRuntimeHandlerが使用され、これはRuntimeClassの機能が無効であるときのふるまいと同じものとなります。</p>
<h3 id=criの設定>CRIの設定</h3>
<p>CRIランタイムのセットアップに関するさらなる詳細は、<a href=/docs/setup/cri/>CRIのインストール</a>を参照してください。</p>
<h4 id=dockershim>dockershim</h4>
<p>Kubernetesのビルトインのdockershim CRIは、ランタイムハンドラーをサポートしていません。</p>
<h4 id=hahahugoshortcode-s3-hbhb><a class=glossary-tooltip title="A container runtime with an emphasis on simplicity, robustness and portability" data-toggle=tooltip data-placement=top href=https://containerd.io/docs/ target=_blank aria-label=containerd>containerd</a></h4>
<p>ランタイムハンドラーは、<code>/etc/containerd/config.toml</code>にあるcontainerdの設定ファイルにより設定されます。
正しいハンドラーは、その<code>runtime</code>セクションで設定されます。</p>
<pre><code>[plugins.&quot;io.containerd.grpc.v1.cri&quot;.containerd.runtimes.${HANDLER_NAME}]
</code></pre><p>containerdの設定に関する詳細なドキュメントは下記を参照してください。<br>
<a href=https://github.com/containerd/cri/blob/master/docs/config.md>https://github.com/containerd/cri/blob/master/docs/config.md</a></p>
<h4 id=hahahugoshortcode-s4-hbhb><a class=glossary-tooltip title="A lightweight container runtime specifically for Kubernetes" data-toggle=tooltip data-placement=top href=https://cri-o.io/#what-is-cri-o target=_blank aria-label=CRI-O>CRI-O</a></h4>
<p>ランタイムハンドラーは、<code>/etc/crio/crio.conf</code>にあるCRI-Oの設定ファイルにより設定されます。
正しいハンドラーは<a href=https://github.com/cri-o/cri-o/blob/master/docs/crio.conf.5.md#crioruntime-table>crio.runtime
table</a>で設定されます。</p>
<pre><code>[crio.runtime.runtimes.${HANDLER_NAME}]
  runtime_path = &quot;${PATH_TO_BINARY}&quot;
</code></pre><p>詳細はCRI-Oの<a href=https://raw.githubusercontent.com/cri-o/cri-o/9f11d1d/docs/crio.conf.5.md>設定に関するドキュメント</a>を参照してください。</p>
<h2 id=scheduling>スケジューリング</h2>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.16 [beta]</code>
</div>
<p>Kubernetes 1.16では、RuntimeClassは<code>scheduling</code>フィールドを使ったクラスター内での異なる設定をサポートしています。
このフィールドによって、設定されたRuntimeClassをサポートするノードに対してPodがスケジュールされることを保証できます。
スケジューリングをサポートするためにはRuntimeClass <a href=/docs/reference/access-authn-authz/admission-controllers/#runtimeclass>アドミッションコントローラー</a>を有効にしなければなりません。(1.16ではデフォルトです)</p>
<p>特定のRuntimeClassをサポートしているノードへPodが配置されることを保証するために、各ノードは<code>runtimeclass.scheduling.nodeSelector</code>フィールドによって選択される共通のラベルを持つべきです。
RuntimeClassのnodeSelectorはアドミッション機能によりPodのnodeSelectorに統合され、効率よくノードを選択します。
もし設定が衝突した場合は、Pod作成は拒否されるでしょう。</p>
<p>もしサポートされているノードが他のRuntimeClassのPodが稼働しないようにtaint付与されていた場合、RuntimeClassに対して<code>tolerations</code>を付与することができます。
<code>nodeSelector</code>と同様に、tolerationsはPodのtolerationsにアドミッション機能によって統合され、効率よく許容されたノードを選択します。</p>
<p>ノードの選択とtolerationsについての詳細は<a href=/ja/docs/concepts/scheduling-eviction/assign-pod-node/>ノード上へのPodのスケジューリング</a>を参照してください。</p>
<h3 id=podオーバーヘッド>Podオーバーヘッド</h3>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.18 [beta]</code>
</div>
<p>Podが稼働する時に関連する <em>オーバーヘッド</em> リソースを指定できます。オーバーヘッドを宣言すると、クラスター(スケジューラーを含む)がPodとリソースに関する決定を行うときにオーバーヘッドを考慮することができます。
Podオーバーヘッドを使うためには、PodOverhead<a href=/ja/docs/reference/command-line-tools-reference/feature-gates/>フィーチャーゲート</a>を有効にしなければなりません。(デフォルトではonです)</p>
<p>PodのオーバーヘッドはRuntimeClass内の<code>overhead</code>フィールドによって定義されます。
このフィールドを使用することで、RuntimeClassを使用して稼働するPodのオーバーヘッドを指定することができ、Kubernetes内部で使用されるオーバーヘッドを確保することができます。</p>
<h2 id=次の項目>次の項目</h2>
<ul>
<li><a href=https://github.com/kubernetes/enhancements/blob/master/keps/sig-node/585-runtime-class/README.md>RuntimeClassデザイン</a></li>
<li><a href=https://github.com/kubernetes/enhancements/blob/master/keps/sig-node/585-runtime-class/README.md#runtimeclass-scheduling>RuntimeClassスケジューリングデザイン</a></li>
<li><a href=/docs/concepts/scheduling-eviction/pod-overhead/>Podオーバーヘッド</a>のコンセプトを読む</li>
<li><a href=https://github.com/kubernetes/enhancements/blob/master/keps/sig-node/20190226-pod-overhead.md>PodOverhead機能デザイン</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-e6941d969d81540208a3e78bc56f43bc>5 - コンテナライフサイクルフック</h1>
<p>このページでは、kubeletにより管理されるコンテナがコンテナライフサイクルフックフレームワークを使用して、管理ライフサイクル中にイベントによって引き起こされたコードを実行する方法について説明します。</p>
<h2 id=概要>概要</h2>
<p>Angularなどのコンポーネントライフサイクルフックを持つ多くのプログラミング言語フレームワークと同様に、Kubernetesはコンテナにライフサイクルフックを提供します。
フックにより、コンテナは管理ライフサイクル内のイベントを認識し、対応するライフサイクルフックが実行されたときにハンドラーに実装されたコードを実行できます。</p>
<h2 id=コンテナフック>コンテナフック</h2>
<p>コンテナに公開されている2つのフックがあります。</p>
<p><code>PostStart</code></p>
<p>このフックはコンテナが作成された直後に実行されます。
しかし、フックがコンテナのENTRYPOINTの前に実行されるという保証はありません。
ハンドラーにパラメーターは渡されません。</p>
<p><code>PreStop</code></p>
<p>このフックは、APIからの要求、またはliveness probeの失敗、プリエンプション、リソース競合などの管理イベントが原因でコンテナが終了する直前に呼び出されます。コンテナがすでに終了状態または完了状態にある場合、preStopフックの呼び出しは失敗します。
これはブロッキング、つまり同期的であるため、コンテナを停止する信号が送信される前に完了する必要があります。
ハンドラーにパラメーターは渡されません。</p>
<p>終了動作の詳細な説明は、<a href=/ja/docs/concepts/workloads/pods/pod-lifecycle/#pod-termination>Termination of Pods</a>にあります。</p>
<h3 id=フックハンドラーの実装>フックハンドラーの実装</h3>
<p>コンテナは、フックのハンドラーを実装して登録することでそのフックにアクセスできます。
コンテナに実装できるフックハンドラーは2種類あります。</p>
<ul>
<li>Exec - コンテナのcgroupsと名前空間の中で、 <code>pre-stop.sh</code>のような特定のコマンドを実行します。
コマンドによって消費されたリソースはコンテナに対してカウントされます。</li>
<li>HTTP - コンテナ上の特定のエンドポイントに対してHTTP要求を実行します。</li>
</ul>
<h3 id=フックハンドラーの実行>フックハンドラーの実行</h3>
<p>コンテナライフサイクル管理フックが呼び出されると、Kubernetes管理システムはフックアクションにしたがってハンドラーを実行します。
<code>exec</code>と<code>tcpSocket</code>はコンテナの中で実行され、<code>httpGet</code>はkubeletプロセスによって実行されます。</p>
<p>フックハンドラーの呼び出しは、コンテナを含むPodのコンテキスト内で同期しています。
これは、<code>PostStart</code>フックの場合、コンテナのENTRYPOINTとフックは非同期に起動することを意味します。
しかし、フックの実行に時間がかかりすぎたりハングしたりすると、コンテナは<code>running</code>状態になることができません。</p>
<p><code>PreStop</code>フックはコンテナを停止する信号から非同期で実行されるのではなく、信号が送られる前に実行を完了する必要があります。
もし<code>PreStop</code>フックが実行中にハングした場合、Podは<code>Terminating</code>状態になり、
<code>terminationGracePeriodSeconds</code>の時間切れで強制終了されるまで続きます。
この猶予時間は、<code>PreStop</code>フックが実行され正常にコンテナを停止できるまでの合計時間に適用されます。
例えば<code>terminationGracePeriodSeconds</code>が60で、フックの終了に55秒かかり、シグナルを受信した後にコンテナを正常に停止させるのに10秒かかる場合、コンテナは正常に停止する前に終了されてしまいます。<code>terminationGracePeriodSeconds</code>が、これら２つの実行にかかる合計時間(55+10)よりも短いからです。</p>
<p><code>PostStart</code>または<code>PreStop</code>フックが失敗した場合、コンテナは強制終了します。</p>
<p>ユーザーはフックハンドラーをできるだけ軽量にするべきです。
ただし、コンテナを停止する前に状態を保存するなどの場合は、長時間のコマンド実行が必要なケースもあります。</p>
<h3 id=フック配信保証>フック配信保証</h3>
<p>フックの配信は <em>少なくとも1回</em> を意図しています。これはフックが<code>PostStart</code>や<code>PreStop</code>のような任意のイベントに対して複数回呼ばれることがあることを意味します。
これを正しく処理するのはフックの実装次第です。</p>
<p>通常、1回の配信のみが行われます。
たとえば、HTTPフックレシーバーがダウンしていてトラフィックを受け取れない場合、再送信は試みられません。
ただし、まれに二重配信が発生することがあります。
たとえば、フックの送信中にkubeletが再起動した場合、kubeletが起動した後にフックが再送信される可能性があります。</p>
<h3 id=フックハンドラーのデバッグ>フックハンドラーのデバッグ</h3>
<p>フックハンドラーのログは、Podのイベントには表示されません。
ハンドラーが何らかの理由で失敗した場合は、イベントをブロードキャストします。
<code>PostStart</code>の場合、これは<code>FailedPostStartHook</code>イベントで、<code>PreStop</code>の場合、これは<code>FailedPreStopHook</code>イベントです。
これらのイベントは <code>kubectl describe pod &lt;pod_name></code>を実行することで見ることができます。
このコマンドの実行によるイベントの出力例をいくつか示します。</p>
<pre><code>Events:
  FirstSeen  LastSeen  Count  From                                                   SubObjectPath          Type      Reason               Message
  ---------  --------  -----  ----                                                   -------------          --------  ------               -------
  1m         1m        1      {default-scheduler }                                                          Normal    Scheduled            Successfully assigned test-1730497541-cq1d2 to gke-test-cluster-default-pool-a07e5d30-siqd
  1m         1m        1      {kubelet gke-test-cluster-default-pool-a07e5d30-siqd}  spec.containers{main}  Normal    Pulling              pulling image &quot;test:1.0&quot;
  1m         1m        1      {kubelet gke-test-cluster-default-pool-a07e5d30-siqd}  spec.containers{main}  Normal    Created              Created container with docker id 5c6a256a2567; Security:[seccomp=unconfined]
  1m         1m        1      {kubelet gke-test-cluster-default-pool-a07e5d30-siqd}  spec.containers{main}  Normal    Pulled               Successfully pulled image &quot;test:1.0&quot;
  1m         1m        1      {kubelet gke-test-cluster-default-pool-a07e5d30-siqd}  spec.containers{main}  Normal    Started              Started container with docker id 5c6a256a2567
  38s        38s       1      {kubelet gke-test-cluster-default-pool-a07e5d30-siqd}  spec.containers{main}  Normal    Killing              Killing container with docker id 5c6a256a2567: PostStart handler: Error executing in Docker Container: 1
  37s        37s       1      {kubelet gke-test-cluster-default-pool-a07e5d30-siqd}  spec.containers{main}  Normal    Killing              Killing container with docker id 8df9fdfd7054: PostStart handler: Error executing in Docker Container: 1
  38s        37s       2      {kubelet gke-test-cluster-default-pool-a07e5d30-siqd}                         Warning   FailedSync           Error syncing pod, skipping: failed to &quot;StartContainer&quot; for &quot;main&quot; with RunContainerError: &quot;PostStart handler: Error executing in Docker Container: 1&quot;
  1m         22s       2      {kubelet gke-test-cluster-default-pool-a07e5d30-siqd}  spec.containers{main}  Warning   FailedPostStartHook
</code></pre><h2 id=次の項目>次の項目</h2>
<ul>
<li><a href=/ja/docs/concepts/containers/container-environment/>コンテナ環境</a>の詳細</li>
<li><a href=/docs/tasks/configure-pod-container/attach-handler-lifecycle-event/>コンテナライフサイクルイベントへのハンドラー紐付け</a>のハンズオン</li>
</ul>
</div>
</main>
</div>
</div>
<footer class=d-print-none>
<div class=footer__links>
<nav>
<a class=text-white href=/ja/docs/home/>ホーム</a>
<a class=text-white href=/ja/blog/>Blogs</a>
<a class=text-white href=/ja/training/>トレーニング</a>
<a class=text-white href=/ja/partners/>パートナー</a>
<a class=text-white href=/ja/community/>コミュニティ</a>
<a class=text-white href=/ja/case-studies/>ケーススタディ</a>
</nav>
</div>
<div class=container-fluid>
<div class=row>
<div class="col-6 col-sm-2 text-xs-center order-sm-2">
<ul class="list-inline mb-0">
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="User mailing list" aria-label="User mailing list">
<a class=text-white target=_blank href=https://discuss.kubernetes.io>
<i class="fa fa-envelope"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Twitter aria-label=Twitter>
<a class=text-white target=_blank href=https://twitter.com/kubernetesio>
<i class="fab fa-twitter"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Calendar aria-label=Calendar>
<a class=text-white target=_blank href="https://calendar.google.com/calendar/embed?src=calendar%40kubernetes.io">
<i class="fas fa-calendar-alt"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Youtube aria-label=Youtube>
<a class=text-white target=_blank href=https://youtube.com/kubernetescommunity>
<i class="fab fa-youtube"></i>
</a>
</li>
</ul>
</div>
<div class="col-6 col-sm-2 text-right text-xs-center order-sm-3">
<ul class="list-inline mb-0">
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub>
<a class=text-white target=_blank href=https://github.com/kubernetes/kubernetes>
<i class="fab fa-github"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Slack aria-label=Slack>
<a class=text-white target=_blank href=https://slack.k8s.io>
<i class="fab fa-slack"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Contribute aria-label=Contribute>
<a class=text-white target=_blank href=https://git.k8s.io/community/contributors/guide>
<i class="fas fa-edit"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Stack Overflow" aria-label="Stack Overflow">
<a class=text-white target=_blank href=https://stackoverflow.com/questions/tagged/kubernetes>
<i class="fab fa-stack-overflow"></i>
</a>
</li>
</ul>
</div>
<div class="col-12 col-sm-8 text-center order-sm-2">
<small class=text-white>&copy; 2023 The Kubernetes Authors | Documentation Distributed under <a href=https://git.k8s.io/website/LICENSE class=light-text>CC BY 4.0</a></small>
<br>
<small class=text-white>Copyright &copy; 2023 The Linux Foundation &reg;. All rights reserved. The Linux Foundation has registered trademarks and uses trademarks. For a list of trademarks of The Linux Foundation, please see our <a href=https://www.linuxfoundation.org/trademark-usage class=light-text>Trademark Usage page</a></small>
<br>
<small class=text-white>ICP license: 京ICP备17074266号-3</small>
</div>
</div>
</div>
</footer>
</div>
<script src=/js/popper-1.14.3.min.js integrity=sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49 crossorigin=anonymous></script>
<script src=/js/bootstrap-4.3.1.min.js integrity=sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM crossorigin=anonymous></script>
<script src=/js/main.min.40616251a9b6e4b689e7769be0340661efa4d7ebb73f957404e963e135b4ed52.js integrity="sha256-QGFiUam25LaJ53ab4DQGYe+k1+u3P5V0BOlj4TW07VI=" crossorigin=anonymous></script>
</body>
</html>